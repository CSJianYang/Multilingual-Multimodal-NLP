[
    {
        "title": "Remove Duplicates from Sorted Array II",
        "question_content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums&nbsp;should hold the final result. It does not matter what you leave beyond the first&nbsp;k&nbsp;elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.\n&nbsp;\nExample 1:\n\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 3 * 104\n\t-104 <= nums[i] <= 104\n\tnums is sorted in non-decreasing order.",
        "solutions": [
            {
                "id": 27976,
                "title": "3-6-easy-lines-c-java-python-ruby",
                "content": "Same simple solution written in several languages. Just go through the numbers and include those in the result that haven't been included twice already.\\n\\n**C++**\\n\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Java**\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Python**\\n\\n    def removeDuplicates(self, nums):\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n**Ruby**\\n\\n    def remove_duplicates(nums)\\n        i = 0\\n        nums.each { |n| nums[(i+=1)-1] = n if i < 2 || n > nums[i-2] }\\n        i\\n    end",
                "solutionTags": [],
                "code": "Same simple solution written in several languages. Just go through the numbers and include those in the result that haven't been included twice already.\\n\\n**C++**\\n\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Java**\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for (int n : nums)\\n            if (i < 2 || n > nums[i-2])\\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n**Python**\\n\\n    def removeDuplicates(self, nums):\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n**Ruby**\\n\\n    def remove_duplicates(nums)\\n        i = 0\\n        nums.each { |n| nums[(i+=1)-1] = n if i < 2 || n > nums[i-2] }\\n        i\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 27987,
                "title": "short-and-simple-java-solution-easy-to-understand",
                "content": "Question wants us to return the length of new array after removing duplicates and that we don't care about what we leave beyond new length , hence we can use `i` to keep track of the position and update the array. \\n\\n \\n----------\\n\\n\\nRemove Duplicates from Sorted Array(no duplicates) :\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int n : nums)\\n            if(i < 1 || n > nums[i - 1]) \\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n\\nRemove Duplicates from Sorted Array II (allow duplicates up to 2):\\n\\n    public int removeDuplicates(int[] nums) {\\n       int i = 0;\\n       for (int n : nums)\\n          if (i < 2 || n > nums[i - 2])\\n             nums[i++] = n;\\n       return i;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Question wants us to return the length of new array after removing duplicates and that we don't care about what we leave beyond new length , hence we can use `i` to keep track of the position and update the array. \\n\\n \\n----------\\n\\n\\nRemove Duplicates from Sorted Array(no duplicates) :\\n\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int n : nums)\\n            if(i < 1 || n > nums[i - 1]) \\n                nums[i++] = n;\\n        return i;\\n    }\\n\\n\\nRemove Duplicates from Sorted Array II (allow duplicates up to 2):\\n\\n    public int removeDuplicates(int[] nums) {\\n       int i = 0;\\n       for (int n : nums)\\n          if (i < 2 || n > nums[i - 2])\\n             nums[i++] = n;\\n       return i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 967951,
                "title": "python-two-pointers-approach-explained",
                "content": "Let us use two pointers approach here: `slow` pointer and `fast` pointer, where slow will always be less or equal to fast. We are asked to remove duplicates only if we have more `2` of them, so we start with `slow` and `fast` equal to `2`.\\n\\nThen we iterate through our data and check if `nums[slow - 2] == nums[fast]`: what does it mean? It means, that in fact `nums[slow-2] = ... = nums[fast]` and that we already have group of `3` or more equal elements: it this case we understand, that `slow` place should be rewritten with something else from future, so we do not move it. In other case, we have group of `2` or smaller, so we need to move `slow` pointer to right. In any case we move `fast` pointer one place to the right.\\n\\n**Complexity**: time complexity is `O(n)`, we move our two pointers only in one direction. Space complexity is `O(1)`: we do it in-place as asked.\\n\\nNote also, that this can be easily adjacted if you asked to have not `2` duplicates, but `k`: in this case we just need to change all 3 occurences of `2` to `k`.\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n\\t\\tif len(nums) < 2: return len(nums)\\n        slow, fast = 2, 2\\n\\n        while fast < len(nums):\\n            if nums[slow - 2] != nums[fast]:\\n                nums[slow] = nums[fast]\\n                slow += 1\\n            fast += 1\\n        return slow\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n\\t\\tif len(nums) < 2: return len(nums)\\n        slow, fast = 2, 2\\n\\n        while fast < len(nums):\\n            if nums[slow - 2] != nums[fast]:\\n                nums[slow] = nums[fast]\\n                slow += 1\\n            fast += 1\\n        return slow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748592,
                "title": "0ms-100-faster-c-solution-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // the intution behind this ->  go through all the elements, along with that check if the \\n\\t\\t// current element has been included previously or not\\n\\t\\t// if included skip it, else add it\\n    int ind = 0;\\n    for (auto it : nums) \\n    {\\n        if (ind < 2 or it > nums[ind-2]) \\n        {\\n            nums[ind++] = it;\\n        }\\n    }\\n    return ind; // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // the intution behind this ->  go through all the elements, along with that check if the \\n\\t\\t// current element has been included previously or not\\n\\t\\t// if included skip it, else add it\\n    int ind = 0;\\n    for (auto it : nums) \\n    {\\n        if (ind < 2 or it > nums[ind-2]) \\n        {\\n            nums[ind++] = it;\\n        }\\n    }\\n    return ind; // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28067,
                "title": "o-n-time-and-o-1-java-solution-when-allowed-at-most-k-times-of-duplicates",
                "content": "Share my general solution for \"Remove Duplicates Problem\".\\n\\nIf anyone could think of a better solution please let me know.    \\n\\n    public int removeDuplicates(int[] nums) {\\n        \\t\\t//define at most k times of duplicate numbers\\n        \\t\\tfinal int k = 2;\\n    \\n        \\t\\t//check if it is an empty array\\n        \\t\\tif(nums.length == 0) return 0;\\n    \\n        \\t\\t//start pointer of new array\\n        \\t\\tint m = 1;\\n    \\n        \\t\\t// count the time of duplicate numbers occurence\\n        \\t\\tint count = 1;\\n    \\n        \\t\\tfor(int i = 1; i < nums.length; ++i) {\\n        \\t\\t\\tif(nums[i] == nums[i - 1]) {\\n        \\t\\t\\t\\tif(count < k) {\\n        \\t\\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t\\tcount++;\\n        \\t\\t\\t} else {\\n        \\t\\t\\t\\tcount = 1;\\n        \\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\treturn m;\\n        \\t}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "Share my general solution for \"Remove Duplicates Problem\".\\n\\nIf anyone could think of a better solution please let me know.    \\n\\n    public int removeDuplicates(int[] nums) {\\n        \\t\\t//define at most k times of duplicate numbers\\n        \\t\\tfinal int k = 2;\\n    \\n        \\t\\t//check if it is an empty array\\n        \\t\\tif(nums.length == 0) return 0;\\n    \\n        \\t\\t//start pointer of new array\\n        \\t\\tint m = 1;\\n    \\n        \\t\\t// count the time of duplicate numbers occurence\\n        \\t\\tint count = 1;\\n    \\n        \\t\\tfor(int i = 1; i < nums.length; ++i) {\\n        \\t\\t\\tif(nums[i] == nums[i - 1]) {\\n        \\t\\t\\t\\tif(count < k) {\\n        \\t\\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t\\t}\\n        \\t\\t\\t\\tcount++;\\n        \\t\\t\\t} else {\\n        \\t\\t\\t\\tcount = 1;\\n        \\t\\t\\t\\tnums[m++] = nums[i];\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t\\treturn m;\\n        \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1329356,
                "title": "c-solution-o-n-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n =nums.size();\\n        if(n < 3) return n;\\n        \\n        int indx = 2;\\n        for(int i =2; i< nums.size(); i++){\\n             if(nums[i] != nums[indx -2]){\\n                 nums[indx] = nums[i];\\n                 indx++;\\n             }\\n        }\\n        return indx;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n =nums.size();\\n        if(n < 3) return n;\\n        \\n        int indx = 2;\\n        for(int i =2; i< nums.size(); i++){\\n             if(nums[i] != nums[indx -2]){\\n                 nums[indx] = nums[i];\\n                 indx++;\\n             }\\n        }\\n        return indx;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748197,
                "title": "java-simple-any-repetitions-explained",
                "content": "**Idea:** 2 pointers\\n* If array length is less than 3, there\\'s nothing to do so exit\\n* Since the array is sorted, all duplicates will be consecutive. So use 2 pointers, one to point at the 3rd or higher occurence of a num, and another one to find the number that can replace the num at the first pointer\\n* Keep doing this until all 3+ repetitions of nums have been overwritten\\n* Example: `[0, 0, 1, 1, 1, 1, 2, 3, 3]`\\n\\n![image](https://assets.leetcode.com/users/images/ba998bdb-4241-469a-85e7-13f5ab60a97e_1644108233.2912471.png)\\n> **T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int removeDuplicates(int[] nums) {\\n\\tvar i = 2;\\n\\t\\n\\tfor (var j = i; j < nums.length; j++)\\n\\t\\tif (nums[j] != nums[i - 2])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```\\nGeneric solution for when k repetitions are allowed\\n```\\npublic int removeDuplicates(int[] nums, int k) {\\n\\tvar n = nums.length;\\n\\tif (n < k + 1)\\n\\t\\treturn n;\\n\\t\\t\\n\\tvar i = k;\\n\\tfor (var j = i; j < n; j++)\\n\\t\\tif (nums[i - k] != nums[j])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int removeDuplicates(int[] nums) {\\n\\tvar i = 2;\\n\\t\\n\\tfor (var j = i; j < nums.length; j++)\\n\\t\\tif (nums[j] != nums[i - 2])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```\n```\\npublic int removeDuplicates(int[] nums, int k) {\\n\\tvar n = nums.length;\\n\\tif (n < k + 1)\\n\\t\\treturn n;\\n\\t\\t\\n\\tvar i = k;\\n\\tfor (var j = i; j < n; j++)\\n\\t\\tif (nums[i - k] != nums[j])\\n\\t\\t\\tnums[i++] = nums[j];\\n\\t\\t\\t\\n\\treturn i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3374696,
                "title": "simple-java-1ms-beats-100-easy-to-understand-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     int   index = 1;\\n      int  count = 0;\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n\\n            if(count <= 1){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```\\n# If this solution helped you, give it an up-vote to help others**Bold**\\n![download.jfif](https://assets.leetcode.com/users/images/e1f75de3-02bf-44d0-bb86-208e5309d274_1680526945.9427269.jpeg)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     int   index = 1;\\n      int  count = 0;\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n\\n            if(count <= 1){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28004,
                "title": "my-c-solution-16ms-5-lines",
                "content": "    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), count = 0;\\n        for (int i = 2; i < n; i++)\\n            if (nums[i] == nums[i - 2 - count]) count++;\\n            else nums[i - count] = nums[i];\\n        return n - count;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), count = 0;\\n        for (int i = 2; i < n; i++)\\n            if (nums[i] == nums[i - 2 - count]) count++;\\n            else nums[i - count] = nums[i];\\n        return n - count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2415500,
                "title": "very-easy-100-fully-explained-java-c-python-javascript-c-python3",
                "content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\\n\\t\\t\\tSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. At last return k after placing the final result in the first k slots of nums.\\n# **Java Solution:**\\nRuntime: 1 ms, faster than 96.73% of Java online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 41.8 MB, less than 87.33% of Java online submissions for Remove Duplicates from Sorted Array II.\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        // Special case...\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1;       // point to previous\\n        int curr = 2;       // point to current\\n        // Traverse all elements through loop...\\n        while (curr < nums.length) {\\n            // If the curr index matches the previous two elements, skip it...\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n                curr++;\\n            }\\n            // Otherwise, count that element and update...\\n            else {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 4 ms, faster than 83.16% of C++ online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 7.7 MB, less than 99.73% of C++ online submissions for Remove Duplicates from Sorted Array II.\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // Special case...\\n        if(nums.size() <= 2) {\\n            return nums.size();\\n        }\\n        // Initialize an integer k that updates the kth index of the array...\\n        // only when the current element does not match either of the two previous indexes...\\n        int k = 2;\\n        // Traverse elements through loop...\\n        for(int i = 2; i < nums.size(); i++){\\n            // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n            if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n                nums[k] = nums[i];\\n                k++;\\n            // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n            }\\n        }\\n        return k;       //Return k after placing the final result in the first k slots of nums...\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\nRuntime: 24 ms, faster than 74.03% of Python online submissions for Remove Duplicates from Sorted Array II.\\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```\\n                    \\n# **JavaScript Solution:**\\nRuntime: 88 ms, faster than 76.14% of JavaScript online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 43.5 MB, less than 98.04% of JavaScript online submissions for Remove Duplicates from Sorted Array II.\\n```\\nvar removeDuplicates = function(nums) {\\n    // Special case...\\n    if(nums.length <= 2) {\\n        return nums.length;\\n    }\\n    // Initialize an integer k that updates the kth index of the array...\\n    // only when the current element does not match either of the two previous indexes...\\n    let k = 2;\\n    // Traverse elements through loop...\\n    for(let i = 2; i < nums.length; i++){\\n        // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n        if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n            nums[k] = nums[i];\\n            k++;\\n        // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n        }\\n    }\\n    return k;       //Return k after placing the final result in the first k slots of nums...\\n};\\n```\\n\\n# **C Language:**\\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    // Special case...\\n    if (numsSize <= 2)\\n        return numsSize;\\n    int prev = 1;       // point to previous\\n    int curr = 2;       // point to current\\n    // Traverse all elements through loop...\\n    while (curr < numsSize) {\\n        // If the curr index matches the previous two elements, skip it...\\n        if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n            curr++;\\n        }\\n        // Otherwise, count that element and update...\\n        else {\\n            prev++;\\n            nums[prev] = nums[curr];\\n            curr++;\\n        }\\n    }\\n    return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        // Special case...\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1;       // point to previous\\n        int curr = 2;       // point to current\\n        // Traverse all elements through loop...\\n        while (curr < nums.length) {\\n            // If the curr index matches the previous two elements, skip it...\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n                curr++;\\n            }\\n            // Otherwise, count that element and update...\\n            else {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        // Special case...\\n        if(nums.size() <= 2) {\\n            return nums.size();\\n        }\\n        // Initialize an integer k that updates the kth index of the array...\\n        // only when the current element does not match either of the two previous indexes...\\n        int k = 2;\\n        // Traverse elements through loop...\\n        for(int i = 2; i < nums.size(); i++){\\n            // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n            if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n                nums[k] = nums[i];\\n                k++;\\n            // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n            }\\n        }\\n        return k;       //Return k after placing the final result in the first k slots of nums...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```\n```\\nvar removeDuplicates = function(nums) {\\n    // Special case...\\n    if(nums.length <= 2) {\\n        return nums.length;\\n    }\\n    // Initialize an integer k that updates the kth index of the array...\\n    // only when the current element does not match either of the two previous indexes...\\n    let k = 2;\\n    // Traverse elements through loop...\\n    for(let i = 2; i < nums.length; i++){\\n        // If the index does not match the (k-1)th and (k-2)th elements, count that element...\\n        if(nums[i] != nums[k - 2] || nums[i] != nums[k - 1]){\\n            nums[k] = nums[i];\\n            k++;\\n        // If the index matches the (k-1)th and (k-2)th elements, we skip it...\\n        }\\n    }\\n    return k;       //Return k after placing the final result in the first k slots of nums...\\n};\\n```\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    // Special case...\\n    if (numsSize <= 2)\\n        return numsSize;\\n    int prev = 1;       // point to previous\\n    int curr = 2;       // point to current\\n    // Traverse all elements through loop...\\n    while (curr < numsSize) {\\n        // If the curr index matches the previous two elements, skip it...\\n        if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) {\\n            curr++;\\n        }\\n        // Otherwise, count that element and update...\\n        else {\\n            prev++;\\n            nums[prev] = nums[curr];\\n            curr++;\\n        }\\n    }\\n    return prev + 1;     // Return k after placing the final result in the first k slots of nums...\\n}\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        # Initialize an integer k that updates the kth index of the array...\\n        # only when the current element does not match either of the two previous indexes. ...\\n        k = 0\\n        # Traverse all elements through loop...\\n        for i in nums:\\n            # If the index does not match elements, count that element and update it...\\n            if k < 2 or i != nums[k - 2]:\\n                nums[k] = i\\n                k += 1\\n        return k       # Return k after placing the final result in the first k slots of nums...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347871,
                "title": "6-lines-c-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (auto e : nums) {\\n            if (i < 2 || e > nums[i - 2])\\n                nums[i++] = e;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;\\n        for (auto e : nums) {\\n            if (i < 2 || e > nums[i - 2])\\n                nums[i++] = e;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835835,
                "title": "runtime-faster-than-99-39-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<=2) return nums.size();\\n        int count=1,j=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]==nums[i]) count++;\\n            else count=1;\\n            if(count<=2) nums[j++]=nums[i];\\n        }\\n        return j;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<=2) return nums.size();\\n        int count=1,j=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]==nums[i]) count++;\\n            else count=1;\\n            if(count<=2) nums[j++]=nums[i];\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921824,
                "title": "simple-easy-100-beats-java-solution",
                "content": "# Intuition\\nIn this solution, we\\'re iterating through the array once. We maintain an index variable that points to the position where the next unique element should be placed. If the current element is not equal to the element at index - 2, it means we haven\\'t encountered this element twice yet, so we can include it in the result array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach works because we\\'re allowed to keep up to two duplicates. If there are more than two duplicates, the elements that are allowed to remain in the array are those that are not equal to the element at index - 2, ensuring that only two duplicates are present.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n\\n        int index = 2;\\n\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[index - 2]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n\\n        int index = 2;\\n\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[index - 2]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n\\n        return index;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062386,
                "title": "0-n-easy-to-understand-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n# **CONNECT WITH ME**\\n#### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n#### **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nThe goal of this function is to remove duplicates from the nums vector while keeping at most two occurrences of any element. The function returns the length of the modified vector after removing duplicates.\\n\\nHere\\'s the approach implemented in the code:\\n\\n- Initialize an integer variable i to 0. This variable will keep track of the current position in the modified nums vector.\\n\\n- Use a for loop to iterate through each element ele in the nums vector using the range-based for loop.\\n\\n- Inside the loop, check the following conditions:\\n\\n---\\n\\n\\n1. i == 0: This condition ensures that the first element is always included in the modified vector.\\n2. i == 1: This condition ensures that the second element is always included in the modified vector.\\n3. nums[i-2] != ele: This condition checks if the current element ele is not the same as the element two positions before the current position i. This ensures that only two occurrences of any element are included in the modified vector.\\n---\\n-  If any of the above conditions are met, copy the current element ele to the nums[i] position in the modified vector, and increment i by 1 to move to the next position.\\n\\n\\n- Repeat this process for all elements in the nums vector.\\n\\n- Finally, return the value of i, which represents the length of the modified vector with duplicates removed.\\n\\nThis approach effectively modifies the nums vector in place, removing duplicates while keeping at most two occurrences of each element. The function returns the length of the modified vector, which can be used to access the unique elements in the first i positions of the vector\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**0(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![upvote.png](https://assets.leetcode.com/users/images/91a084df-cac4-4805-8bbf-78afd5e22977_1695092464.1321526.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i =0;\\n        // int ele= nums[0];\\n        for(auto ele : nums)\\n        {\\n            if(i==0 || i==1 || nums[i-2] != ele)\\n            {\\n                nums[i] = ele;\\n                i++;\\n            }\\n        }\\n    return i ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i =0;\\n        // int ele= nums[0];\\n        for(auto ele : nums)\\n        {\\n            if(i==0 || i==1 || nums[i-2] != ele)\\n            {\\n                nums[i] = ele;\\n                i++;\\n            }\\n        }\\n    return i ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750063,
                "title": "python-implementation-using-two-pointers-o-n-time-space-complexity-95-faster",
                "content": "#### **If You Find This Post Helpful Please Upvote**\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# Edge Condition\\n        if len(nums)<3: return len(nums)\\n        \\n\\t\\t# Main Logic\\n\\t\\t\\n        ind = 2  # Pointer from where we need to replace elements\\n        for i in range(2, len(nums)):\\n            if nums[i]!=nums[ind-2]:\\n                nums[ind] = nums[i]\\n                ind+=1\\n        return ind\\n```\\n**Visit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/**",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# Edge Condition\\n        if len(nums)<3: return len(nums)\\n        \\n\\t\\t# Main Logic\\n\\t\\t\\n        ind = 2  # Pointer from where we need to replace elements\\n        for i in range(2, len(nums)):\\n            if nums[i]!=nums[ind-2]:\\n                nums[ind] = nums[i]\\n                ind+=1\\n        return ind\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529357,
                "title": "java-tc-o-n-sc-o-1-optimized-two-pointers-solution-followup",
                "content": "**In place, one pass solution using 2 pointers**\\n\\n```java\\n/**\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len <= 2) {\\n            return len;\\n        }\\n\\n        int insertPos = 1;\\n        for (int i = 2; i < len; i++) {\\n            if (nums[i] != nums[insertPos - 1]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```\\n\\n---\\n**Follow-Up: Each unique element should appear at most K times**\\n\\n```java\\n/**\\n * Follow-Up: Each unique element should appear at most K times.\\n *\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N-K)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        return removeDuplicatesMoreThanK(nums, 2);\\n    }\\n\\n    public int removeDuplicatesMoreThanK(int[] nums, int k) {\\n        if (nums == null || k < 0) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n        if (k == 0) {\\n            return 0;\\n        }\\n\\n        int len = nums.length;\\n        if (len <= k) {\\n            return len;\\n        }\\n\\n        int insertPos = k - 1;\\n        for (int i = k; i < len; i++) {\\n            if (nums[i] != nums[insertPos - (k - 1)]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Remove Element questions on LeetCode:\\n- [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/discuss/1529341/Java-or-TC:-O(N)-or-SC:-O(1)-or-Optimized-Two-Pointers-solution)\\n- [27. Remove Element + Follow Up](https://leetcode.com/problems/remove-element/discuss/1529351/Java-or-TC:-O(N)-or-SC:-O(1)-or-Optimized-Two-Pointers-solution-and-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\n/**\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int len = nums.length;\\n        if (len <= 2) {\\n            return len;\\n        }\\n\\n        int insertPos = 1;\\n        for (int i = 2; i < len; i++) {\\n            if (nums[i] != nums[insertPos - 1]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```\n```java\\n/**\\n * Follow-Up: Each unique element should appear at most K times.\\n *\\n * In place, one pass solution using 2 pointers\\n *\\n * Time Complexity: O(N-K)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input array.\\n */\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        return removeDuplicatesMoreThanK(nums, 2);\\n    }\\n\\n    public int removeDuplicatesMoreThanK(int[] nums, int k) {\\n        if (nums == null || k < 0) {\\n            throw new IllegalArgumentException(\"Invalid Input\");\\n        }\\n        if (k == 0) {\\n            return 0;\\n        }\\n\\n        int len = nums.length;\\n        if (len <= k) {\\n            return len;\\n        }\\n\\n        int insertPos = k - 1;\\n        for (int i = k; i < len; i++) {\\n            if (nums[i] != nums[insertPos - (k - 1)]) {\\n                nums[++insertPos] = nums[i];\\n            }\\n        }\\n\\n        return insertPos + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025001,
                "title": "accepted-fast-java-code-beats-100-o-n",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length < 3) return nums.length;\\n        int i = 0, j = 0;\\n        while(i < nums.length){\\n            nums[j++] = nums[i++];\\n            if(i < nums.length && nums[i] == nums[j-1])\\n                nums[j++] = nums[i++];\\n            while(i < nums.length && nums[i] == nums[j-1]) i++;\\n        }\\n        return j;\\n    }\\n}\\n```\\n>>> ## Upvote\\uD83D\\uDC4D if you find helpful\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```JAVA []\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length < 3) return nums.length;\\n        int i = 0, j = 0;\\n        while(i < nums.length){\\n            nums[j++] = nums[i++];\\n            if(i < nums.length && nums[i] == nums[j-1])\\n                nums[j++] = nums[i++];\\n            while(i < nums.length && nums[i] == nums[j-1]) i++;\\n        }\\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968051,
                "title": "remove-duplicates-o-n-time-o-1-space-complexity",
                "content": "Let us use two pointers approach here: ``slow`` pointer and ``fast ``pointer, where slow will always be less or equal to fast. We are asked to remove duplicates only if we have more 2 of them, so we start with slow and fast equal to 2.\\n\\nThen we iterate through our data and check if ``nums[slow - 2] == nums[fast]``: what does it mean? It means, that in fact ``nums[slow-2] = ... = nums[fast]`` and that we already have group of `3 `or more equal elements: it this case we understand, that `slow` place should be rewritten with something else from future, so we do not move it. In other case, we have group of `2` or smaller, so we need to move `slow` pointer to right. In any case we move `fast` pointer one place to the right.\\n\\nComplexity: time complexity is `O(n)`, we move our two pointers only in one direction. Space complexity is `O(1)`: we do it in-place as asked.\\n\\nNote also, that this can be easily adjacted if you asked to have not 2 duplicates, but k: in this case we just need to change all `3 `occurences of `2` to` k.`\\n```\\n\\n   public int removeDuplicates(int[] nums) {\\n        int slow=2, fast = 2;\\n        while (fast < nums.length){\\n            if (nums[slow - 2] != nums[fast]){\\n                nums[slow] = nums[fast];\\n                slow ++;\\n            }\\n            fast ++;\\n        }\\n        return slow;\\n    }\\n\\n```\\nOne more easy solution that comes to my mind after attempting above solution\\n```\\npublic int removeDuplicates(int[] nums) {\\n    int i = 0;\\n    for (int n : nums)\\n        if (i < 2 || n > nums[i-2]) nums[i++] = n;\\n    return i;\\n}\\n```\\n**If you have any questions, feel free to ask. If you like solution and explanations, please Upvote!,It inspires me alot.Happy Coding!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n   public int removeDuplicates(int[] nums) {\\n        int slow=2, fast = 2;\\n        while (fast < nums.length){\\n            if (nums[slow - 2] != nums[fast]){\\n                nums[slow] = nums[fast];\\n                slow ++;\\n            }\\n            fast ++;\\n        }\\n        return slow;\\n    }\\n\\n```\n```\\npublic int removeDuplicates(int[] nums) {\\n    int i = 0;\\n    for (int n : nums)\\n        if (i < 2 || n > nums[i-2]) nums[i++] = n;\\n    return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3755474,
                "title": "super-simple-concise-cute-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int j=1;\\n        for(int i=2;i<nums.length;i++)\\n            if(nums[i]!=nums[j-1])\\n                nums[++j]=nums[i];\\n        return j+1;\\n    }\\n}\\n```\\n\\nOk, I saw some of your solutions are not getting accepted.\\nThe main reason for this is because you are writing it in another language. Such as C or C++. In this language, the storage management is not properly done as they are legacy languages and there is no garbage collection.\\n\\nIf you are using such languages then I will suggest you write the following line the the return statement. \\n\\n```\\nreturn nums.size()>2?j+1:nums.size();\\n```\\nsuggested by @IILuciferII\\n\\nHope it Helps. Thanks!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int j=1;\\n        for(int i=2;i<nums.length;i++)\\n            if(nums[i]!=nums[j-1])\\n                nums[++j]=nums[i];\\n        return j+1;\\n    }\\n}\\n```\n```\\nreturn nums.size()>2?j+1:nums.size();\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599075,
                "title": "javascript-pretty-simple",
                "content": "```\\nconst removeDuplicates = (nums) => {\\n  let j = 0;\\n  let i = 0;\\n\\n  for (; i < nums.length; i += 1){\\n    if (nums[i] !== nums[i + 2]) {\\n      nums[j] = nums[i];\\n      j += 1;\\n    }\\n  }\\n\\n  return j;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeDuplicates = (nums) => {\\n  let j = 0;\\n  let i = 0;\\n\\n  for (; i < nums.length; i += 1){\\n    if (nums[i] !== nums[i + 2]) {\\n      nums[j] = nums[i];\\n      j += 1;\\n    }\\n  }\\n\\n  return j;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3602362,
                "title": "easy-clear-solution-python3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-2,0,-1):\\n            if(nums[i]==nums[i-1] and nums[i]==nums[i+1]):\\n                nums.pop(i+1)\\n        return len(nums)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-2,0,-1):\\n            if(nums[i]==nums[i-1] and nums[i]==nums[i+1]):\\n                nums.pop(i+1)\\n        return len(nums)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499165,
                "title": "c-best-solution-2-approach-easy-to-understand",
                "content": "# Approach - 1\\n<!-- Describe your approach to solving the problem. -->\\ntake a map<int, int> which stores the count of each element if the count is less than equal to 2 then insert the element in the required position of the array else skip and go to the next element.\\n> Please see the approach - 2 that is more optimized. no extra space is required for this. We can think about sliding window size 2.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        map<int, int> mp;\\n        for(auto it : nums) {\\n            mp[it]++;\\n            if(mp[it] <= 2) nums[k++] = it;\\n        }\\n        return k;\\n    }\\n};\\n\\n```\\n\\n# Approach - 2\\n<!-- Describe your approach to solving the problem. -->\\nhere the given array is sorted. we use this consept here => at index **i** the element **nums[i]** is present more than two times in the array is **nums[i] == nums[i-2]**\\n> let assume nums [0,0,1,1,1,1,2,3,3]\\n> We start from index 2\\n> so nums[2] != nums[0] then the element in 2nd index is not more than 2 times. so we can add nums[2]\\n> but for index 4\\n> nums[4] == nums[2]\\n> sowe can not add the element nums[4]\\n\\nplease dry run the solution for better understanding\\n\\n**One edge case is if the size of nums is less than 2 then simple return the size**\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nif(nums.size() <= 2)    return nums.size();\\n        int k=0; // here k is the index which is compared to the nums[i] for checking that the current element is occuring more than two times or not\\n        \\n        for(int i=2; i<nums.size(); i++)    {\\n            if(nums[i] != nums[k])  {\\n                nums[k+2] = nums[i];\\n                k++;\\n            }\\n        }\\n        return k+2;\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int k=0;\\n        map<int, int> mp;\\n        for(auto it : nums) {\\n            mp[it]++;\\n            if(mp[it] <= 2) nums[k++] = it;\\n        }\\n        return k;\\n    }\\n};\\n\\n```\n```\\nif(nums.size() <= 2)    return nums.size();\\n        int k=0; // here k is the index which is compared to the nums[i] for checking that the current element is occuring more than two times or not\\n        \\n        for(int i=2; i<nums.size(); i++)    {\\n            if(nums[i] != nums[k])  {\\n                nums[k+2] = nums[i];\\n                k++;\\n            }\\n        }\\n        return k+2;\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28114,
                "title": "simple-java-solution-with-explanation",
                "content": "\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length == 0) {return 0;}\\n        int pointer = 0, flag = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1] && flag == 0) {\\n                flag = 1;\\n                pointer++;\\n            } else if (nums[i] != nums[i - 1]) {\\n                flag = 0;\\n                pointer++;\\n            }\\n            nums[pointer] = nums[i];\\n        }\\n        return pointer + 1;\\n    }\\n\\n\\n----------\\nThe variable flag is to show if this number (nums[i]) has appeared more or equals to third times. The variable pointer is the location that each number (nums[i]) should appeared in. The special case is when the array is empty.",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length == 0) {return 0;}\\n        int pointer = 0, flag = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1] && flag == 0) {\\n                flag = 1;\\n                pointer++;\\n            } else if (nums[i] != nums[i - 1]) {\\n                flag = 0;\\n                pointer++;\\n            }\\n            nums[pointer] = nums[i];\\n        }\\n        return pointer + 1;\\n    }\\n\\n\\n----------\\nThe variable flag is to show if this number (nums[i]) has appeared more or equals to third times. The variable pointer is the location that each number (nums[i]) should appeared in. The special case is when the array is empty.",
                "codeTag": "Unknown"
            },
            {
                "id": 3741215,
                "title": "simple-two-pointer-approach-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf an element has appeared twice already in the array, we ignore the extra appearances of the element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNote: assuming 0-based index; extra appearance = additional to 2 appearances\\n1. if the size(nums) <= 2, then there is no chance that an element would have appeared more than twice, so then we can return the size\\n2. we form the resultant array in-place by overriding the extra appearances of elements.\\n3. we have two variable to track indices: $$i$$ for iterating over elements of given array, $$rIndex$$ to track our resultant array.\\n4. we initiate $$rIndex$$ = 1 and start $$i$$ from 2. why? have look at (1.)\\n5. we iterate $$i$$ from 2 to (n - 1)\\n    a) if nums[$$i$$] same as nums[$$rIndex$$] and nums[$$rIndex$$ - 1], then ignore and continue to next iteration. why? the current element has made it\\'s 2 appearances already.\\n    b) else, the current element can be included in the resultant array. so, increment $$rIndex$$ and assign nums[$$rIndex$$] with nums[$$i$$].\\n6. return $$rIndex$$ + 1. why? we return the size, not the last index value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2)\\n            return n;\\n        int rIndex = 1;\\n        for(int i = 2; i < n; i++)\\n        {\\n            int currentNumber = nums[i];\\n            if(currentNumber == nums[rIndex] && currentNumber == nums[rIndex - 1])\\n                continue;\\n            nums[++rIndex] = nums[i];\\n        }\\n        return rIndex + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2)\\n            return n;\\n        int rIndex = 1;\\n        for(int i = 2; i < n; i++)\\n        {\\n            int currentNumber = nums[i];\\n            if(currentNumber == nums[rIndex] && currentNumber == nums[rIndex - 1])\\n                continue;\\n            nums[++rIndex] = nums[i];\\n        }\\n        return rIndex + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749637,
                "title": "c-with-easy-explanation",
                "content": "\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB Friend\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that motivates me to create a better post like this \\u270D\\uFE0F\\n____________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________\\n\\n#### \\u2714\\uFE0F **Question Conclusion**\\n* Count of any element shoud not be greater than 2 within the limit or return variable.\\n#### \\u2714\\uFE0F **Solution - I (My Best Approach)**\\n##### **Intuition :-**\\n* Take a variable `prev` and point it with element at 0th index of `vector nums`.\\n* Take a variable count and initialize it with 1 as we are already escaping the 0th index.\\n* Take a variable pos in which we will insert any new element which is not equal to prev and update prev with new and increment the pos and count at same time.\\n* Go through the code for better understanding\\n##### **Code :-**\\n```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n            if (prev != nums[i])\\n                count = 1, prev = nums[i], nums[pos++] = nums[i];\\n            else if (count++ < 2)\\n                nums[pos++] = nums[i];\\n        return pos;\\n    }\\n};\\n```\\nJust have a question would you like a solution that is concise like the above where it will give the correct result but for dry run purposes, you have to make changes like putting brackets or the solution which I am pasting below. Let me know in the comments because I think brackets play a major role when we want to see the dry run of every iteration what changes are going to be done by the code using the print statement.\\n```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            if (prev != nums[i])\\n            {\\n                count = 1;\\n                prev = nums[i];\\n                nums[pos] = nums[i];\\n                pos++;\\n            }\\n            else\\n            {\\n                if (count < 2)\\n                {\\n                    nums[pos] = nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```\\n\\n\\n**Time Complexity** : `O(N)`, traverse is done only for once.\\n**Space Complexity** : `O(1)`, No extra space is used.\\n_____________________________________________________________________________________________________________\\n_____________________________________________________________________________________________________________\\n\\n\\uD83D\\uDCBBIf there are any suggestions/questions in my post, comment below \\uD83D\\uDC47",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n            if (prev != nums[i])\\n                count = 1, prev = nums[i], nums[pos++] = nums[i];\\n            else if (count++ < 2)\\n                nums[pos++] = nums[i];\\n        return pos;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int removeDuplicates(vector<int> &nums)\\n    {\\n        int prev = nums[0], count = 1, pos = 1;\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            if (prev != nums[i])\\n            {\\n                count = 1;\\n                prev = nums[i];\\n                nums[pos] = nums[i];\\n                pos++;\\n            }\\n            else\\n            {\\n                if (count < 2)\\n                {\\n                    nums[pos] = nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28128,
                "title": "python-9-lines-2-extra-variables-76ms-any-simpler-solution-else",
                "content": "Skip the middle elements of the duplicates and rearrange the array.\\n\\n\\n    def removeDuplicates(self, nums):\\n            if len(nums) < 3: \\n                return len(nums)\\n            pos = 1\\n            for i in range(1, len(nums)-1):\\n                if nums[i-1] != nums[i+1]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            nums[pos] = nums[-1]\\n            return pos + 1\\n\\n\\nThe idea was pretty like solve [remove-duplicates-from-sorted-array][1] as below: \\n\\n    def removeDuplicates(self, nums):\\n            pos = 0\\n            for i in range(0, len(nums)):\\n                if i == 0 or nums[i-1] != nums[i]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            return pos\\n\\n\\n  [1]: https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
                "solutionTags": [
                    "Python"
                ],
                "code": "Skip the middle elements of the duplicates and rearrange the array.\\n\\n\\n    def removeDuplicates(self, nums):\\n            if len(nums) < 3: \\n                return len(nums)\\n            pos = 1\\n            for i in range(1, len(nums)-1):\\n                if nums[i-1] != nums[i+1]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            nums[pos] = nums[-1]\\n            return pos + 1\\n\\n\\nThe idea was pretty like solve [remove-duplicates-from-sorted-array][1] as below: \\n\\n    def removeDuplicates(self, nums):\\n            pos = 0\\n            for i in range(0, len(nums)):\\n                if i == 0 or nums[i-1] != nums[i]:\\n                    nums[pos] = nums[i]\\n                    pos += 1\\n            return pos\\n\\n\\n  [1]: https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
                "codeTag": "Python3"
            },
            {
                "id": 632374,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = len(nums)\\n        \\n        if n < 3:\\n            return n\\n        \\n        i , j = 1, 2\\n        \\n        while j < n:\\n            if nums[i-1] != nums[j]:\\n                i += 1\\n            \\n            \\n            nums[i] = nums[j]\\n            j+= 1\\n        \\n        return i+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n = len(nums)\\n        \\n        if n < 3:\\n            return n\\n        \\n        i , j = 1, 2\\n        \\n        while j < n:\\n            if nums[i-1] != nums[j]:\\n                i += 1\\n            \\n            \\n            nums[i] = nums[j]\\n            j+= 1\\n        \\n        return i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27967,
                "title": "clean-python-solution",
                "content": "    class Solution(object):\\n        def removeDuplicates(self, nums):\\n            tail = 0\\n            for num in nums:\\n                if tail < 2 or num != nums[tail - 1] or num != nums[tail - 2]:\\n                    nums[tail] = num\\n                    tail += 1\\n            return tail",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def removeDuplicates(self, nums):\\n            tail = 0\\n            for num in nums:\\n                if tail < 2 or num != nums[tail - 1] or num != nums[tail - 2]:\\n                    nums[tail] = num\\n                    tail += 1\\n            return tail",
                "codeTag": "Java"
            },
            {
                "id": 28120,
                "title": "c-code-quite-standard",
                "content": "You only need to change K to allow K repetitions.\\nOne common mistake one can make is \" if(nums[i] != nums[i-K])\" : it is wrong since nums[i-k] can be overwritten in a previous iteration.\\n\\n    class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int len=nums.size(), i, K=2, last = K;\\n            if(len<=K) return len;\\n            for(i=K; i<len; ++i)\\n            {\\n                if(nums[i] != nums[last-K]) nums[last++] = nums[i]; // note it is last-K\\n            }\\n            return last;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int len=nums.size(), i, K=2, last = K;\\n            if(len<=K) return len;\\n            for(i=K; i<len; ++i)\\n            {\\n                if(nums[i] != nums[last-K]) nums[last++] = nums[i]; // note it is last-K\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4006464,
                "title": "simple-beats-100",
                "content": "\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     if(nums.length<3) return nums.length;\\n     int index=2;\\n     for(int i=2;i<nums.length;i++)\\n     {\\n         if(nums[i]!=nums[index-2])\\n         {\\n             nums[index++] = nums[i];\\n         }\\n     }\\n    return index;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     if(nums.length<3) return nums.length;\\n     int index=2;\\n     for(int i=2;i<nums.length;i++)\\n     {\\n         if(nums[i]!=nums[index-2])\\n         {\\n             nums[index++] = nums[i];\\n         }\\n     }\\n    return index;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506920,
                "title": "java-solution-for-remove-duplicates-from-sorted-array-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code removes duplicates from the sorted array \"nums\" and keeps at most two occurrences of each unique element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the length of the array \"nums\" is less than or equal to 2. If true, return the length as there are no duplicates to remove.\\n- Initialize two pointers: \"prev\" points to the position where the next unique element will be placed, and \"curr\" points to the current element being checked.\\n- Iterate through the array starting from the third element (index 2) until the end.\\n- Check if the current element \"nums[curr]\" is equal to the previous two elements \"nums[prev]\" and \"nums[prev - 1]\". If true, it means there are more than two occurrences of this element, so increment \"curr\" to skip it.\\n- If the current element is not a duplicate, move the \"prev\" pointer forward, update \"nums[prev]\" with the current element, and increment both \"prev\" and \"curr\".\\n- Repeat steps 4 and 5 until all elements have been checked.\\n- Return \"prev + 1\" as the new length of the modified array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n) since it iterates through the array once, where n is the length of the input array \"nums\".\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because the algorithm modifies the input array in-place without using any additional data structures, regardless of the input size.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1; // point to previous\\n        int curr = 2; // point to current\\n        while (curr < nums.length) \\n        {\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) \\n            {\\n                curr++;\\n            }\\n            else \\n            {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2)\\n            return nums.length;\\n        int prev = 1; // point to previous\\n        int curr = 2; // point to current\\n        while (curr < nums.length) \\n        {\\n            if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) \\n            {\\n                curr++;\\n            }\\n            else \\n            {\\n                prev++;\\n                nums[prev] = nums[curr];\\n                curr++;\\n            }\\n        }\\n        return prev + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918873,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        let n = nums.count\\n        guard n > 2 else { return n }\\n        var j = 1\\n        var count = 1\\n        \\n        for i in 1..<nums.count {\\n            if nums[i] == nums[i - 1] {\\n                count += 1\\n            } else {\\n                count = 1\\n            }\\n            \\n            if count <= 2 {\\n                nums[j] = nums[i]\\n                j += 1\\n            }\\n        }\\n        \\n        return j\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        let n = nums.count\\n        guard n > 2 else { return n }\\n        var j = 1\\n        var count = 1\\n        \\n        for i in 1..<nums.count {\\n            if nums[i] == nums[i - 1] {\\n                count += 1\\n            } else {\\n                count = 1\\n            }\\n            \\n            if count <= 2 {\\n                nums[j] = nums[i]\\n                j += 1\\n            }\\n        }\\n        \\n        return j\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654614,
                "title": "super-fast-python-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i=0\\n        while i+2<len(nums):\\n            if nums[i]==nums[i+2]:\\n                nums.pop(i+2)\\n            else:\\n                i=i+1\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i=0\\n        while i+2<len(nums):\\n            if nums[i]==nums[i+2]:\\n                nums.pop(i+2)\\n            else:\\n                i=i+1\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740702,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;  // Pointer to track the position to place the next unique element\\n        for (int n : nums) {\\n            if (i < 2 || n > nums[i-2]) {\\n                // The current element is either the first or second occurrence of a number\\n                // or it is greater than the number before the last unique element\\n                // So, it can be included in the updated array\\n                nums[i++] = n;  // Place the current element at the correct position\\n            }\\n        }\\n        return i;  // Return the new length of the array with duplicates removed\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int i = 0;  // Pointer to track the position to place the next unique element\\n        for (int n : nums) {\\n            if (i < 2 || n > nums[i-2]) {\\n                // The current element is either the first or second occurrence of a number\\n                // or it is greater than the number before the last unique element\\n                // So, it can be included in the updated array\\n                nums[i++] = n;  // Place the current element at the correct position\\n            }\\n        }\\n        return i;  // Return the new length of the array with duplicates removed\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600043,
                "title": "0ms-beats-most-intuitive-java-solution",
                "content": "# Intuition and Approach\\nHey Folks\\uD83D\\uDC4B\\uD83C\\uDFFC,\\nI am back with another **AMAZING** solution to a pretty complex problem (that you might think at this point) but let me give you a little spoiler\\uD83D\\uDE02 I will take the solution of an easy problem and add 3 lines of code (one extra condition) and it will solve this problem.\\n\\nAs always , To solve this problem there is a pre-requisite.\\nYou must first solve/try this problem\\uD83D\\uDC47\\uD83C\\uDFFC\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/description/\\n\\nNow, Assuming that you have solved or at least read the problem description, the question basically asks to group the unique elements in the starting part of the array (in-place) and return the count of unique elements.\\n\\nLogic is a simple Two-pointer Approach\\n\\n**Step 1:** we keep a pointer named $$lastUnique$$ pointing to the last unique element that we processed and another pointer $$current$$ pointing to the current element we are standing at.$$lastUnique$$ will start from 0 as first element is always unique.\\n\\n**Step2:** At each $$current$$, check two conditions\\n- If $$current$$ element is equal to the lastUnique element then we can ignore the $$current$$ element.\\n\\n- Otherwise, swap the $$current$$ element with $$lastUnique + 1$$ index and move $$lastUnique$$ one step ahead. (Now this is my lastUnique element processed)\\n\\n**Step 3:** In the End , return $$lastUnique + 1$$ as we need to return count and $$lastUnique$$ signifies the index.\\n\\nCode(Linked Question):\\n```\\npublic static int removeDuplicates(int[] nums) {\\n    int n = nums.length;\\n    if(n == 1) return n;\\n\\t\\n    int lastUnique = 0;\\n    for (int current = 1; current < n; current++) {\\n        if (nums[current] == nums[lastUnique]) {\\n            continue;\\n        }else{\\n            nums[lastUnique + 1] = nums[current];\\n            lastUnique++;\\n        }\\n    }\\n    return lastUnique  + 1;\\n\\n    }\\n```\\n\\n\\nNow, Coming back to this problem, if you see carefully this question also asks us to group unique elements in the starting part of array **(problem statement of Linked Question)** but know one extra condition is added that the unique element can appear at most twice.\\n\\nSo , now we simply can\\'t ignore the $$current$$ element if it is equal to $$lastUnique$$, **we need to check if there exists an element to the left of $$lastUnique$$ that is equal to $$current$$ element, if it is then ignore the $$current$$ element (as duplicate already considered) otherwise we need to add the $$current$$ element to $$lastUnique$$. (Read the bold part again to get better clarity)**\\n\\nYou are done. Just copy the code and in place of $$continue$$ add the extra condition check and submit it to beat \\uD83D\\uDCAF%.\\nCongratulations, you have developed a 0ms solution to a complex(not now\\uD83D\\uDE09) problem.\\n\\nI know this solution can be compressed to 5-6 lines of code but \\n**Are those solutions really intuitive..?\\uD83E\\uDD14** **Can you come up with those solutions directly in an interview..?\\uD83E\\uDD14**  Not for an average Coder like me.\\n\\n> **INTUITION COMES FIRST, OPTIMISATIONS COME LATTER**\\n\\n\\uD83D\\uDE4F\\uD83C\\uDFFCPlzz Upvote if you found this solution helpful and interesting\\uD83D\\uDE4F\\uD83C\\uDFFC\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return n;\\n\\n        int lastUnique = 0;\\n        for (int current = 1; current < n; current++) {\\n            if(nums[current] == nums[lastUnique]){\\n                //If there is no element in the left or the element on left is not equal to current element, then add the current element;\\n                if((lastUnique - 1 < 0) || (nums[lastUnique - 1] != nums[current])){\\n                    nums[lastUnique + 1] = nums[current];\\n                    lastUnique++;\\n                }\\n            }else{\\n                nums[lastUnique + 1] = nums[current];\\n                lastUnique++;\\n            }\\n        }\\n        return lastUnique + 1;\\n        \\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$-> S*ingle Iteration*\\n\\n- Space complexity: $$O(1)$$-> *No extra space used*",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic static int removeDuplicates(int[] nums) {\\n    int n = nums.length;\\n    if(n == 1) return n;\\n\\t\\n    int lastUnique = 0;\\n    for (int current = 1; current < n; current++) {\\n        if (nums[current] == nums[lastUnique]) {\\n            continue;\\n        }else{\\n            nums[lastUnique + 1] = nums[current];\\n            lastUnique++;\\n        }\\n    }\\n    return lastUnique  + 1;\\n\\n    }\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return n;\\n\\n        int lastUnique = 0;\\n        for (int current = 1; current < n; current++) {\\n            if(nums[current] == nums[lastUnique]){\\n                //If there is no element in the left or the element on left is not equal to current element, then add the current element;\\n                if((lastUnique - 1 < 0) || (nums[lastUnique - 1] != nums[current])){\\n                    nums[lastUnique + 1] = nums[current];\\n                    lastUnique++;\\n                }\\n            }else{\\n                nums[lastUnique + 1] = nums[current];\\n                lastUnique++;\\n            }\\n        }\\n        return lastUnique + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759575,
                "title": "precise-c-two-pointers-o-n-time-o-1-space",
                "content": "# Approach\\nIf the array\\'s length is less than 3, we could safely return the length of the array as any element present in it will either appear once or twice which satisfies the given condition.\\n\\nVariable \\'k\\' stores the length of \\'in-place subarray\\' with unique elements which appears at most twice.\\n\\nWe begin with value of \\'k\\' and \\'i\\' as 2 as the array will have at most twice unique elements till 1.\\nThen we check \\'nums[i]\\' with \\'nums[k-2]\\' i.e current element with second element from length of \\'in-place subarray\\' with unique elements and if they are not equal we store current element at end of in-place subarray\\nand increment k by 1.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n \\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return nums.size();\\n        int k=2;\\n        for(int i=2;i<nums.size();i++)\\n         if(nums[k-2]!=nums[i])  \\n            nums[k++]=nums[i];\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size()<3)\\n            return nums.size();\\n        int k=2;\\n        for(int i=2;i<nums.size();i++)\\n         if(nums[k-2]!=nums[i])  \\n            nums[k++]=nums[i];\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750807,
                "title": "js-really-short-and-simple-solution",
                "content": "**Go through the list backwards and remove the excess numbers**\\n```\\nvar removeDuplicates = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--){\\n        let secPrev = nums[i-2]\\n        if(secPrev === nums[i]) nums.splice(i, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--){\\n        let secPrev = nums[i-2]\\n        if(secPrev === nums[i]) nums.splice(i, 1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 28053,
                "title": "share-my-o-n-time-and-o-1-space-short-and-simple-solution-when-duplicates-are-allowed-at-most-k-times",
                "content": "This is my **short and easy to understand** solution for the problem where **duplicates are allowed at most k times.**  My approach is to remain first k elements as it is . Now start from `k'th index`  and check if the element at the position `current index - k` this is the same as new arriving element then skip this element and continue with next element .\\nhere the condition `nums[j-k]!=nums[i]`  is very important because if i will use `i` in place of `j` i.e. `nums[i-k]!=nums[i]` then it will give wrong answer because we have to look `k` steps backward in **new updated array.**\\n\\nplease comment if any test case fails.\\n\\n     int removeDuplicates(vector<int>& nums,int k) {\\n            if(nums.size()<k) return nums.size(); // if array size is less than k then return the same\\n            int i,j;\\n             for(i=k,j=k ; i<nums.size();i++)\\n                 if(nums[j-k]!=nums[i]) nums[j++]=nums[i];\\n             return j;\\n        \\n        }",
                "solutionTags": [],
                "code": "This is my **short and easy to understand** solution for the problem where **duplicates are allowed at most k times.**  My approach is to remain first k elements as it is . Now start from `k'th index`  and check if the element at the position `current index - k` this is the same as new arriving element then skip this element and continue with next element .\\nhere the condition `nums[j-k]!=nums[i]`  is very important because if i will use `i` in place of `j` i.e. `nums[i-k]!=nums[i]` then it will give wrong answer because we have to look `k` steps backward in **new updated array.**\\n\\nplease comment if any test case fails.\\n\\n     int removeDuplicates(vector<int>& nums,int k) {\\n            if(nums.size()<k) return nums.size(); // if array size is less than k then return the same\\n            int i,j;\\n             for(i=k,j=k ; i<nums.size();i++)\\n                 if(nums[j-k]!=nums[i]) nums[j++]=nums[i];\\n             return j;\\n        \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3142015,
                "title": "0-ms-easy-best-solution-brute-force-solution-java",
                "content": "# \\n    ----------------- ||  Please leave a like  || --------------\\n\\n# Code\\n```\\n//---------------- BEST SOLUTION ------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i : nums){\\n            if(k==0 || k == 1 || i != nums[k-2] ){\\n                nums[k++] = i;\\n            }\\n        }\\n        return k;\\n\\n    }\\n}\\n```\\n# \\n    ----------------- ||  Please leave a like  || --------------\\n\\n\\n```\\n//------------Brute Force solution------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i = 0 ; i<nums.length; i++){\\n            int count = 1;\\n            for (int j = i+1; j<nums.length ; j++){\\n                if(nums[i] == nums[j]){\\n                    count = count + 1;\\n                }\\n            }\\n            if(count > 2){\\n                nums[i] = Integer.MAX_VALUE;\\n                k++;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-k;\\n\\n    }\\n}\\n\\n\\n```\\n# \\n    ----------------- ||  Please leave a like  || --------------\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//---------------- BEST SOLUTION ------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i : nums){\\n            if(k==0 || k == 1 || i != nums[k-2] ){\\n                nums[k++] = i;\\n            }\\n        }\\n        return k;\\n\\n    }\\n}\\n```\n```\\n//------------Brute Force solution------------------\\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for(int i = 0 ; i<nums.length; i++){\\n            int count = 1;\\n            for (int j = i+1; j<nums.length ; j++){\\n                if(nums[i] == nums[j]){\\n                    count = count + 1;\\n                }\\n            }\\n            if(count > 2){\\n                nums[i] = Integer.MAX_VALUE;\\n                k++;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-k;\\n\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529279,
                "title": "java-o-n-time-100-beats-o-1-space-simple-easy-to-understand-counter",
                "content": "if you like this aproach kindly upvote and comment so that i can share more my solutions and your one upvote will motivate me to post more precise solutions\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n        int i=1;\\n        boolean b=false;\\n        int count=1;\\n        while(i<arr.length ){\\n            if(arr[i-1]!=arr[i]){\\n                arr[count]=arr[i];\\n                b=false;\\n                count++;\\n            }else if(arr[i-1]==arr[i] && !b){\\n                 arr[count]=arr[i];\\n                  b=true;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count++;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n        int i=1;\\n        boolean b=false;\\n        int count=1;\\n        while(i<arr.length ){\\n            if(arr[i-1]!=arr[i]){\\n                arr[count]=arr[i];\\n                b=false;\\n                count++;\\n            }else if(arr[i-1]==arr[i] && !b){\\n                 arr[count]=arr[i];\\n                  b=true;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749252,
                "title": "two-pointer-approach-in-o-n-time-complexity-with-explanations",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we are using ***Two pointer approach.***\\n- We are taking i & j as pointers and count as counter.\\n- if i & j are equal, we\\u2019ll increase count & if count is less then 3 then we\\u2019ll replace j with i. and increase j value.\\n- else we\\u2019ll store next i value to j & make count 1, then increase j.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 1, count = 1;\\n        if(n < 2) return n;\\n        \\n        while(i < n-1){\\n            if(nums[i] == nums[i+1]){\\n                count++;\\n                if(count <= 2){\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else{\\n                nums[j] = nums[i+1];\\n                count = 1;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = 1, count = 1;\\n        if(n < 2) return n;\\n        \\n        while(i < n-1){\\n            if(nums[i] == nums[i+1]){\\n                count++;\\n                if(count <= 2){\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else{\\n                nums[j] = nums[i+1];\\n                count = 1;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28051,
                "title": "easy-to-understand-java-solution",
                "content": "Save count for distinct numbers. \\nIf the count is less than 3 we can keep it.\\n\\n\\n----------\\n\\n\\n    public class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            int cnt=0;\\n            int len=0;\\n            for(int i=0;i<nums.length;++i){\\n                if(i==0 || nums[i]!=nums[i-1]){\\n                    cnt = 1;\\n                }else{\\n                    cnt++;\\n                }\\n                if(cnt<3){\\n                    nums[len++] = nums[i];\\n                }\\n            }\\n            return len;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            int cnt=0;\\n            int len=0;\\n            for(int i=0;i<nums.length;++i){\\n                if(i==0 || nums[i]!=nums[i-1]){\\n                    cnt = 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 27974,
                "title": "c-simple-ac-solution-in-10-lines-21ms",
                "content": "    class Solution {\\n    public:\\n        int removeDuplicates(int A[], int n) {\\n            if (n <= 2)\\n                return n;\\n            int rear = 1;\\n            for(int i = 2; i < n; i++){\\n                if(!(A[i] == A[rear] && A[i] == A[rear -1])){\\n                    A[++rear] = A[i];\\n                }\\n            }\\n            return rear+1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(int A[], int n) {\\n            if (n <= 2)\\n                return n;\\n            int rear = 1;\\n            for(int i = 2; i < n; i++){\\n                if(!(A[i] == A[rear] && A[i] == A[rear -1])){\\n                    A[++rear] = A[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3958748,
                "title": "simple-python-3-solution-beats-98-7",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return len(nums)\\n\\n        currentIndex = 2\\n        for i in range(2, len(nums)):\\n            if nums[i] != nums[currentIndex - 2]:\\n                nums[currentIndex] = nums[i]\\n                currentIndex += 1\\n\\n        return currentIndex\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return len(nums)\\n\\n        currentIndex = 2\\n        for i in range(2, len(nums)):\\n            if nums[i] != nums[currentIndex - 2]:\\n                nums[currentIndex] = nums[i]\\n                currentIndex += 1\\n\\n        return currentIndex\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183342,
                "title": "80-remove-duplicates-from-sorted-array-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Initialize a variable i to 0.\\n- Loop through each n in nums.\\n- Check if i is less than 2 or n is greater than the nums[i-2].\\n  - If the condition is true, assign n to nums[i] and increment i by 1.\\n- Return i.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for n in nums:\\n            if i < 2 or n > nums[i-2]:\\n                nums[i] = n\\n                i += 1\\n        return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542066,
                "title": "faster-than-98-66-memory-usage-less-than-100",
                "content": "```\\nconst removeDuplicates = nums => {\\n    let i=0;\\n    while (i<nums.length){\\n        nums[i]===nums[i+2]?nums.splice(i,1):i++;\\n    }\\n    return nums.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeDuplicates = nums => {\\n    let i=0;\\n    while (i<nums.length){\\n        nums[i]===nums[i+2]?nums.splice(i,1):i++;\\n    }\\n    return nums.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192080,
                "title": "2-pointers-simplest-python-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 1\\n        while i < len(nums) - 1:\\n            if nums[i] == nums[i - 1] and nums[i] == nums[i + 1]:\\n                del nums[i]\\n            else:\\n                i += 1\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 1\\n        while i < len(nums) - 1:\\n            if nums[i] == nums[i - 1] and nums[i] == nums[i + 1]:\\n                del nums[i]\\n            else:\\n                i += 1\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749406,
                "title": "short-and-simple-java-solution-1ms",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i=0,count=1,j=1;\\n        while(j<nums.length){\\n            if(nums[j]==nums[i]){\\n                if(count<2){\\n                    i++;\\n                    nums[i]=nums[j];\\n                    count++;\\n                }\\n            }\\n            else{\\n                i++;\\n                nums[i]=nums[j];\\n                count=1;\\n            }\\n            j++;\\n        }\\n        return i+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i=0,count=1,j=1;\\n        while(j<nums.length){\\n            if(nums[j]==nums[i]){\\n                if(count<2){\\n                    i++;\\n                    nums[i]=nums[j];\\n                    count++;\\n                }\\n            }\\n            else{\\n                i++;\\n                nums[i]=nums[j];\\n                count=1;\\n            }\\n            j++;\\n        }\\n        return i+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230086,
                "title": "java-100-o-1-space-5-lines-of-code-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    //two pointers \\n    //one fixed and another moving \\n    //if sliding-fixed less than or eq to 1 and both index having equal nos that means \\n    //we  need to keep that entry as duplicates are allowed twice \\n    //else we dont require that value as its repeating  more than twice .\\n    //we also have to maintain currInd to keep track of original arr index values \\n    //Also in the case if we move to next item which is not equal to fixed index item \\n    //that refers we need to reset that fixed ptr as array is sorted and comparsion \\n    //need to be done on same index values\\n    \\n    // UPVOTE if like it . \\n    public int removeDuplicates(int[] nums) {\\n        int currInd=0;\\n        int fx=0;\\n        int sl=0;\\n        while(sl<nums.length){\\n            if(nums[fx]!=nums[sl]) fx=sl;\\n            if(sl-fx<=1 && nums[sl] == nums[fx])  nums[currInd++]=nums[sl];\\n            sl++;\\n        }\\n        return currInd;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //two pointers \\n    //one fixed and another moving \\n    //if sliding-fixed less than or eq to 1 and both index having equal nos that means \\n    //we  need to keep that entry as duplicates are allowed twice \\n    //else we dont require that value as its repeating  more than twice .\\n    //we also have to maintain currInd to keep track of original arr index values \\n    //Also in the case if we move to next item which is not equal to fixed index item \\n    //that refers we need to reset that fixed ptr as array is sorted and comparsion \\n    //need to be done on same index values\\n    \\n    // UPVOTE if like it . \\n    public int removeDuplicates(int[] nums) {\\n        int currInd=0;\\n        int fx=0;\\n        int sl=0;\\n        while(sl<nums.length){\\n            if(nums[fx]!=nums[sl]) fx=sl;\\n            if(sl-fx<=1 && nums[sl] == nums[fx])  nums[currInd++]=nums[sl];\\n            sl++;\\n        }\\n        return currInd;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28175,
                "title": "o-n-in-place-solution",
                "content": "    int removeDuplicates(int A[], int n) {\\n        if (n <= 2) return n;\\n        int repeat = 0, count = 1;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] == A[i-1] && repeat < 1) {\\n                A[count++] = A[i];\\n                repeat++;\\n            }\\n            else if (A[i] > A[i-1]) {\\n                A[count++] = A[i];\\n                repeat = 0;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "    int removeDuplicates(int A[], int n) {\\n        if (n <= 2) return n;\\n        int repeat = 0, count = 1;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] == A[i-1] && repeat < 1) {\\n                A[count++] = A[i];\\n                repeat++;\\n            }\\n            else if (A[i] > A[i-1]) {\\n                A[count++] = A[i];\\n                repeat = 0;\\n            }\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3896472,
                "title": "c-easy-shortest-solution",
                "content": "Just check if the i+2 th element is same or not, if not then use the second pointer to fill the array.\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c=0,n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            if(i<n-2 and nums[i]==nums[i+2]) continue;\\n            else {\\n                nums[c++]=nums[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c=0,n=nums.size();\\n        for(int i=0;i<n;i++) {\\n            if(i<n-2 and nums[i]==nums[i+2]) continue;\\n            else {\\n                nums[c++]=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3589635,
                "title": "js-ts-2-simple-solutions-100-explained-and-commented",
                "content": "# Solution #1\\nWorks for at most any number if we change the comparison value in the if block.\\n## Approach\\n- Check if the input array `nums` is empty. If it is, return `0` as there are no unique elements to remove.\\n- Initialize a pointer `k` to `0`, which will be used to keep track of the unique elements in the array.\\n- Loop through the elements of the input array using a for loop. For each element:\\n    - Check if we have not yet seen this element (i.e., if `k` is less than `2`), or if the current element is greater than the second-to-last unique element (i.e., `nums[i] > nums[k-2]`). If either of these conditions is `true`, then we have a new unique element.\\n- Assign the current element to the new position indicated by `k` in the array `nums`.\\n- Increment `k` to move the pointer to the next position.\\n- After the loop, `k` will contain the number of unique elements in the array. Return `k` as the function output.\\n\\n## Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n## Code\\n```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (k < 2 || nums[i] > nums[k - 2]) {\\n      nums[k] = nums[i];\\n      k++;\\n    }\\n  }\\n\\n  return k;\\n};\\n```\\n\\n# Solution #2\\nWorks only for at most twice\\n## Approach\\n- Check if the input array `nums` is `empty`. If it is, return `0` as there are no unique elements to remove.\\n- Initialize a pointer `k` to `0`, which will be used to keep track of the unique elements in the array.\\n- Loop through the elements of the input array using a for loop, starting at index `1` (since the first element is always unique).\\n    - Check if the current element is not equal to the previous unique element (i.e., `nums[i] !== nums[k]`), or if the current element is equal to the previous unique element but the previous two elements are not equal (i.e., `nums[i] === nums[k] && nums[k] !== nums[k - 1`]). If either of these conditions is `true`, then we have a new unique element.\\n    - Increment `k` to move the pointer to the next position.\\n    - Assign the current element to the new position indicated by `k` in the array `nums`.\\n- After the loop, `k` will contain the number of unique elements in the array. Return `k + 1` as the function output, since `k` is a zero-based index and we need to add `1` to get the number of unique elements.\\n\\n## Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n## Code\\n```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (\\n      nums[i] !== nums[k] ||\\n      (nums[i] === nums[k] && nums[k] !== nums[k - 1])\\n    ) {\\n      k++;\\n      nums[k] = nums[i];\\n    }\\n  }\\n\\n  return k + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (k < 2 || nums[i] > nums[k - 2]) {\\n      nums[k] = nums[i];\\n      k++;\\n    }\\n  }\\n\\n  return k;\\n};\\n```\n```\\nconst removeDuplicates = function (nums) {\\n  if (!nums.length) return 0;\\n\\n  let k = 0;\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (\\n      nums[i] !== nums[k] ||\\n      (nums[i] === nums[k] && nums[k] !== nums[k - 1])\\n    ) {\\n      k++;\\n      nums[k] = nums[i];\\n    }\\n  }\\n\\n  return k + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141821,
                "title": "0ms-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int a : nums){\\n            if(i ==0 || i ==1|| nums[i-2] != a){\\n                nums[i] = a;\\n                i++;\\n            }\\n        \\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int a : nums){\\n            if(i ==0 || i ==1|| nums[i-2] != a){\\n                nums[i] = a;\\n                i++;\\n            }\\n        \\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420762,
                "title": "3-simple-steps-to-solve-same-types-without-if-else",
                "content": "# 3 steps:\\n\\n- **Save** the current value\\n- **Skip** the all equal values `consecutively` and `count` how many times we saw equal value to saved on the way.\\n- **Assign** the saved value in **step 1** to the place pointed by `i`\\n\\n> The above algorithm is a generic algorithm for any question asking for **Removal of elements from a sorted array**\\n\\nTime - O(`n`)\\nSpace - O(`1`)\\n\\n# Java\\n    public int removeDuplicates(int[] nums) {\\n        int n= nums.length,i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n# C++\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= size(nums),i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n**Please upvote if you like**   (\\u2741\\xB4\\u25E1`\\u2741)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "# 3 steps:\\n\\n- **Save** the current value\\n- **Skip** the all equal values `consecutively` and `count` how many times we saw equal value to saved on the way.\\n- **Assign** the saved value in **step 1** to the place pointed by `i`\\n\\n> The above algorithm is a generic algorithm for any question asking for **Removal of elements from a sorted array**\\n\\nTime - O(`n`)\\nSpace - O(`1`)\\n\\n# Java\\n    public int removeDuplicates(int[] nums) {\\n        int n= nums.length,i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n# C++\\n    int removeDuplicates(vector<int>& nums) {\\n        int n= size(nums),i=0,j=0;\\n        while(j<n){\\n            int save= nums[j],cnt=0;\\n            for(;j<n && nums[j]==save;j++,cnt++);\\n            nums[i++]=save;\\n            if(cnt>1) nums[i++]= save;\\n        }\\n        return i;\\n    }\\n**Please upvote if you like**   (\\u2741\\xB4\\u25E1`\\u2741)",
                "codeTag": "Unknown"
            },
            {
                "id": 1752202,
                "title": "python-2-solutions-naive-and-efficient-explained",
                "content": "## The naive approach is using the inbuilt count() method in python, and removing (count-2) instances of the element.\\n## For example the array nums = [1,1,1,1,2,2,2,3,3], it will delete (count of 1 - 2) 1\\'s, that is 4-2 = 2 ones, and so on.\\n## count() method in python returns the frequency of the element, if the frequency is less than 2 skip one place and go ahead if it\\'s more than 2, delete (count-2) elements and then skip 2 places.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        if len(nums) < 2:\\n            return length\\n        i = 0\\n        while(i <=  length-1):\\n            count = nums.count(nums[i])\\n            if count > 2:\\n                for _ in range(i,i+count-2):\\n                    nums.pop(i)\\n                i += 2\\n                length -= (count-2)\\n            else:\\n                i += 1\\n\\t```\\n# Efficient 2-pointer approach\\n## This approach has a start and an end pointer which is 2 indices ahead of start, everytime nums[end] == nums[start], it deleted nums[end]. Once 1st element is done, start shifts to end, and end shifts to start+2.\\n\\n```def  removeDuplicates(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        if length < 2:\\n            return length\\n        start = 0\\n        end = start + 2\\n\\n        while(end <= length-1):\\n            if nums[start+1] == nums[start]:\\n                if nums[end] > nums[start]:\\n                    start = end\\n                    end += 2\\n                else:\\n                    nums.pop(end)\\n                    length -= 1\\n            else:\\n                start += 1\\n                end += 1\\n        \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        if len(nums) < 2:\\n            return length\\n        i = 0\\n        while(i <=  length-1):\\n            count = nums.count(nums[i])\\n            if count > 2:\\n                for _ in range(i,i+count-2):\\n                    nums.pop(i)\\n                i += 2\\n                length -= (count-2)\\n            else:\\n                i += 1\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1750032,
                "title": "java-3ms-solution-leetcode-dc",
                "content": "**please upvote if you like my solution**\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n                if(hm.get(nums[i])>2){\\n                    nums[i]=Integer.MAX_VALUE;\\n                    count++;\\n                }\\n            }\\n            else hm.put(nums[i],1);\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(hm.containsKey(nums[i])){\\n                hm.put(nums[i],hm.get(nums[i])+1);\\n                if(hm.get(nums[i])>2){\\n                    nums[i]=Integer.MAX_VALUE;\\n                    count++;\\n                }\\n            }\\n            else hm.put(nums[i],1);\\n        }\\n        Arrays.sort(nums);\\n        return nums.length-count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749976,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int e: nums){\\n            if(i == 0 || i == 1 || nums[i -2] != e){\\n                nums[i] = e;\\n                i+=1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int i = 0;\\n        for(int e: nums){\\n            if(i == 0 || i == 1 || nums[i -2] != e){\\n                nums[i] = e;\\n                i+=1;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749376,
                "title": "c-simple-and-easy-solution-using-two-pointers-o-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if (nums.size() <= 2) return nums.size();\\n        \\n        int ptr = 2;\\n        for (int i = 2; i < nums.size(); i++) {\\n            if (nums[i] != nums[ptr-2]) {\\n                nums[ptr++] = nums[i];\\n            }\\n        }\\n        return ptr;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if (nums.size() <= 2) return nums.size();\\n        \\n        int ptr = 2;\\n        for (int i = 2; i < nums.size(); i++) {\\n            if (nums[i] != nums[ptr-2]) {\\n                nums[ptr++] = nums[i];\\n            }\\n        }\\n        return ptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271806,
                "title": "c-using-unordered-map",
                "content": "```\\nint removeDuplicates(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n            if(m[nums[i]]<=2){\\n                nums[(j++)]=nums[i];\\n            }\\n        }\\n        return j;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeDuplicates(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        int j=0;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n            if(m[nums[i]]<=2){\\n                nums[(j++)]=nums[i];\\n            }\\n        }\\n        return j;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 377132,
                "title": "python-solution-upvote-if-you-understood",
                "content": "\"\"\"\\nThe approach here is to iterate through the array and at each ith index check if i+1 and i -1 are equal.\\nif so then it means there are more than 2 similar elements. so keep no moving in the array until we find\\na condition where the i-1 and i+1 indexes are not equal, this means we have encountered a unique element\\n and we increase the count in this way we just maintain the len of array with max two entries of each element.\\nTime complexity - O(N)\\nSpace complexity - O(1)\\nexample - [1,1,1,2,2,2,2,3,3,4]\\nposition at 0 - intialize count = 1 continue\\nposition at 1 - i+1 = i-1 -> count = 1 \\npostion at 2 - i+1 != i-1 -> count += 1 = 2\\nposition at 3 - i +1 != i-1 -> count += 2 = 3\\nposition at 4 - i+1 == i -1 -> count  = 3\\nposition at 5 - i+1 == i -1 -> count = 3 \\nposition at 6 - i+1 != i -1 -> count += 3 = 4\\nposition at 7 - i+1 != i -1 -> count += 4 = 5\\nposition at 8 - i+1 != i -1 -> count += 5 = 6\\n\\n                   |   | |     | | | |   ----> \\'|\\' indicates the elements considered.\\n\\t\\texample - [1,1,1,2,2,2,2,3,3,4]\\n\\nfinally take into account the last index also so return count+1 = 7 = [1,1,2,2,3,3,4]\\nBasically we are just taking into account the first and last index elements of the repeated sub-arrays in\\nthe main array.\\n\"\"\"\\n\\n\\tdef removeDuplicates(self, nums):\\n        if len(nums) < 3: \\n            return len(nums)\\n        count = 1\\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] != nums[i+1]:\\n                nums[count] = nums[i]\\n                count += 1\\n        nums[count] = nums[-1]\\n        return count + 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "\"\"\"\\nThe approach here is to iterate through the array and at each ith index check if i+1 and i -1 are equal.\\nif so then it means there are more than 2 similar elements. so keep no moving in the array until we find\\na condition where the i-1 and i+1 indexes are not equal, this means we have encountered a unique element\\n and we increase the count in this way we just maintain the len of array with max two entries of each element.\\nTime complexity - O(N)\\nSpace complexity - O(1)\\nexample - [1,1,1,2,2,2,2,3,3,4]\\nposition at 0 - intialize count = 1 continue\\nposition at 1 - i+1 = i-1 -> count = 1 \\npostion at 2 - i+1 != i-1 -> count += 1 = 2\\nposition at 3 - i +1 != i-1 -> count += 2 = 3\\nposition at 4 - i+1 == i -1 -> count  = 3\\nposition at 5 - i+1 == i -1 -> count = 3 \\nposition at 6 - i+1 != i -1 -> count += 3 = 4\\nposition at 7 - i+1 != i -1 -> count += 4 = 5\\nposition at 8 - i+1 != i -1 -> count += 5 = 6\\n\\n                   |   | |     | | | |   ----> \\'|\\' indicates the elements considered.\\n\\t\\texample - [1,1,1,2,2,2,2,3,3,4]\\n\\nfinally take into account the last index also so return count+1 = 7 = [1,1,2,2,3,3,4]\\nBasically we are just taking into account the first and last index elements of the repeated sub-arrays in\\nthe main array.\\n\"\"\"\\n\\n\\tdef removeDuplicates(self, nums):\\n        if len(nums) < 3: \\n            return len(nums)\\n        count = 1\\n        for i in range(1, len(nums)-1):\\n            if nums[i-1] != nums[i+1]:\\n                nums[count] = nums[i]\\n                count += 1\\n        nums[count] = nums[-1]\\n        return count + 1",
                "codeTag": "Python3"
            },
            {
                "id": 3720279,
                "title": "best-solution-c-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int p=0, count=1, pos=1;\\n        for(int i=1; i<n; i++){\\n            if(nums[p]!=nums[i]){\\n                count=1;\\n                nums[pos]=nums[i];\\n                p=i;\\n                pos++;\\n            }\\n            else{\\n                while(count<2){\\n                    count++;\\n                    nums[pos]=nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int p=0, count=1, pos=1;\\n        for(int i=1; i<n; i++){\\n            if(nums[p]!=nums[i]){\\n                count=1;\\n                nums[pos]=nums[i];\\n                p=i;\\n                pos++;\\n            }\\n            else{\\n                while(count<2){\\n                    count++;\\n                    nums[pos]=nums[i];\\n                    pos++;\\n                }\\n                count++;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585412,
                "title": "simple-java-solution-for-beginners-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347800,
                "title": "java-100-faster-two-pointer-method-in-java-simplify-your-code-and-save-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/c1be1504-3486-4267-a051-24173837f10d_1679924192.437104.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int index = 1;  // Index of the next unique element to add to the array\\n        int count = 1;  // Count of the current element\\n    \\n        // Loop through the array starting from the second element\\n        for(int i = 1; i < nums.length; i++){\\n        \\n            // If the current element is the same as the previous element, increment the count\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            } \\n            // If the current element is different from the previous element, reset the count\\n            else {\\n                count = 1;\\n            }\\n        \\n            // If the count is less than or equal to 2, add the current element to the array\\n            if(count <= 2){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n    // Return the index, which represents the number of unique elements in the array after removing duplicates\\n    return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        int index = 1;  // Index of the next unique element to add to the array\\n        int count = 1;  // Count of the current element\\n    \\n        // Loop through the array starting from the second element\\n        for(int i = 1; i < nums.length; i++){\\n        \\n            // If the current element is the same as the previous element, increment the count\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            } \\n            // If the current element is different from the previous element, reset the count\\n            else {\\n                count = 1;\\n            }\\n        \\n            // If the count is less than or equal to 2, add the current element to the array\\n            if(count <= 2){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n    // Return the index, which represents the number of unique elements in the array after removing duplicates\\n    return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137326,
                "title": "python3-o-n-simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        l = []\\n        for i,j in counter.items():\\n            if j>2:\\n                l+=[i]*2\\n            else:\\n                l+=[i]*j\\n        nums[:] = l  \\n```\\n# **Please upvote guys if you find the solution helpful.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        l = []\\n        for i,j in counter.items():\\n            if j>2:\\n                l+=[i]*2\\n            else:\\n                l+=[i]*j\\n        nums[:] = l  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114911,
                "title": "js-ts-easy-solution",
                "content": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    const len = nums.length;\\n    let gap = 0;\\n    for(let i=0; i<len; i++){\\n        if(nums[i]===nums[i+2]){\\n            gap++;\\n        }else{\\n            nums[i-gap] = nums[i];\\n        } \\n    }\\n    return len-gap;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction removeDuplicates(nums: number[]): number {\\n    const len = nums.length;\\n    let gap = 0;\\n    for(let i=0; i<len; i++){\\n        if(nums[i]===nums[i+2]){\\n            gap++;\\n        }else{\\n            nums[i-gap] = nums[i];\\n        } \\n    }\\n    return len-gap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2513788,
                "title": "go-o-n",
                "content": "```\\nfunc removeDuplicates(nums []int) int {\\n    if len(nums) < 2 {\\n        return len(nums)\\n    }\\n    idx := 2\\n    for i:=2; i<len(nums) ; i++{\\n        if nums[i] != nums[idx-2]{\\n            nums[idx] = nums[i]\\n            idx+=1\\n            \\n        }\\n    }\\n    return idx\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeDuplicates(nums []int) int {\\n    if len(nums) < 2 {\\n        return len(nums)\\n    }\\n    idx := 2\\n    for i:=2; i<len(nums) ; i++{\\n        if nums[i] != nums[idx-2]{\\n            nums[idx] = nums[i]\\n            idx+=1\\n            \\n        }\\n    }\\n    return idx\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732669,
                "title": "c-easy-to-understand-3-approaches",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> temp;\\n        map<int,int> mp;\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n            if(mp[nums[i]]<3)\\n            {\\n                temp.push_back(nums[i]);\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            nums[i]=temp[i];\\n        }\\n        return k;\\n    }\\n};\\n```\\n**Without any extra space and linear time complexity**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size(),j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(j<2||nums[j-2]<nums[i])\\n            {\\n                nums[j++]=nums[i];\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> temp;\\n        map<int,int> mp;\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n            if(mp[nums[i]]<3)\\n            {\\n                temp.push_back(nums[i]);\\n                k++;\\n            }\\n        }\\n        for(int i=0;i<temp.size();i++)\\n        {\\n            nums[i]=temp[i];\\n        }\\n        return k;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size(),j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(j<2||nums[j-2]<nums[i])\\n            {\\n                nums[j++]=nums[i];\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193869,
                "title": "c-easy-code",
                "content": "int removeDuplicates(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        if(n<3)\\n            return n;\\n        int j=2;\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i]!=nums[j-2])\\n                nums[j++]=nums[i];\\n        }\\n        \\n        \\n        return j;\\n\\n    }",
                "solutionTags": [],
                "code": "int removeDuplicates(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        if(n<3)\\n            return n;\\n        int j=2;\\n        \\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i]!=nums[j-2])\\n                nums[j++]=nums[i];\\n        }\\n        \\n        \\n        return j;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 980297,
                "title": "simplest-python-4-lines-solution",
                "content": "* Iterating over the array from last index (i.e. using  for loop reversely ) to eliminate range errors.\\n* Deleting the number that is repeating.\\n\\n\\n```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n    for i in range(len(nums)-1 , 1, -1):\\n\\t    if(nums[i]==nums[i-1]==nums[i-2]):\\n\\t\\t    del(nums[i])\\n    return(len(nums))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n    for i in range(len(nums)-1 , 1, -1):\\n\\t    if(nums[i]==nums[i-1]==nums[i-2]):\\n\\t\\t    del(nums[i])\\n    return(len(nums))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 208796,
                "title": "python-solution",
                "content": "We use the two pointer approach as in 26. Remove Duplicates from Sorted Array, except that we will use an extra `flag` variable to indicate the number of duplicates of `nums[j]` in `nums[:i+1]`. If `flag = False`, then there are `0` or `1` duplicate of `nums[j]` in `nums[:i+1]`, and we should increment `i`, and swap `nums[i]` and `nums[j]`; Else if `flag = True`, there are `2` or more duplicates of `nums[j]` in `nums[:i+1]`, and we should do nothing and continue with the next iteration of `j`. The loop invariant is that `nums[:i+1]` is always the sorted array `nums[:j+1]` with duplicates appear at most twice. Hence when `j` reaches `len(nums)-1`, `nums[:i+1]` is `nums` with duplicates appear at most twice.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        i = 0\\n        count = 1\\n        flag = False \\n        for j in range(1, len(nums)):\\n            if nums[j] == nums[i]:\\n                if not flag: \\n                    flag = True\\n                    i += 1\\n                    nums[i], nums[j] = nums[j], nums[i]\\n                    count += 1\\n            else:\\n                flag = False\\n                i += 1\\n                nums[i], nums[j] = nums[j], nums[i]\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        i = 0\\n        count = 1\\n        flag = False \\n        for j in range(1, len(nums)):\\n            if nums[j] == nums[i]:\\n                if not flag: \\n                    flag = True\\n                    i += 1\\n                    nums[i], nums[j] = nums[j], nums[i]\\n                    count += 1\\n            else:\\n                flag = False\\n                i += 1\\n                nums[i], nums[j] = nums[j], nums[i]\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28072,
                "title": "share-my-o-n-time-and-o-1-space-solution-with-duplicates-are-allowed-at-most-n-times",
                "content": "    public class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums==null || nums.length<3){\\n            return nums==null?0:nums.length;\\n        }\\n        int dif = 2;\\n        for(int i=2;i<nums.length;i++){\\n            if(nums[i]!=nums[dif-2]){\\n                nums[dif++]=nums[i];\\n            }\\n        }\\n        return dif;\\n    }\\n}\\n\\n\\nif N duplicates are allowed,you just need to change the nums[dif-2] to nums[dif-N] ,welcome to discuss with me .",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums==null || nums.length<3){\\n            return nums==null?0:nums.length;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4045552,
                "title": "javascript-easy-and-very-understandable-2-pointers-solution",
                "content": "# Intuition / Approach\\nSince the nums array is already sorted, its actually really easy to see when we have more than 2 duplicates of any given integer. Sounds very simple and stupid, but if you look at 3 numbers at once and you see that they are all the same integer, then we have an obvious extra duplicate. We could drop the right element, and keep incrementing r. As we increment r, if the element reoccurs, then we keep dropping them. However, if we see that our r pointer element breaks from our element at l and mid, then we know that there are no more extra duplicates, and we can start checking the next batch of 3 elements from the first occurance of an integer we havent seen yet (which is at pointer r). Here is where we will fix our pointers, where l = r, mid = l+1, and r = mid+1. And the check from above starts again. In any other situation, we can just move all our pointers by 1 and keep checking the same conditions we listed above.\\n\\nSince I decided to use a placeholder (\"_\") in places where I dropped the integer, for the test cases to pass given the criteria, I need to move all the place holders to the right. \\n\\nI know that I did a lot of extra work with the placeholders and 2nd loop to move the \"_\" to the right, but I wanted to solve this problem clearly as possible and where anyone can see what is happening at any given moment, so I thought that this was the most simplest solution to understand.\\n\\nHope this helps! I thought it was kind of confusing first, but once you realize how the array being sorted works in your favor, its really easy to do. \\n\\n# Complexity\\n- Time complexity:\\n    - First while loop iterates through nums once using 3 pointers. Since the loop passes through the array once-> O(N);\\n    - Second while loop iterates through nums once using 2 pointers. Since the loop passes through the array once -> O(N);\\n    - O(N + N) => O(2N) => (Constants are dropped) O(N); \\n\\n- Space complexity:\\n    - Constant number of extra variables used (k, l, mid, r, i, j)\\n    - No additional data structures used to store inputs with respect to the input size\\n    -  O(1); \\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    let k = nums.length\\n    let l = 0;\\n    let mid = 1;\\n    let r = 2;\\n\\n    while(r<nums.length){\\n        if(nums[l] === nums[mid] && nums[r] === nums[mid]){\\n            nums[r] = \"_\";\\n            k--;\\n            r++;\\n        } else if (nums[l] === nums[mid] && nums[mid]!==nums[r]){\\n            l = r;\\n            mid = l + 1;\\n            r = mid + 1;\\n        } else {\\n            l++;\\n            mid++;\\n            r++\\n        }\\n    }\\n    let i = 0;\\n    let j = 1;\\n\\n    while(j < nums.length){\\n        if(nums[i] === \"_\" && nums[j]!== \"_\"){\\n            [nums[i], nums[j]] = [nums[j], nums[i]];\\n            i++;\\n            j++;\\n        } else if (nums[i] === \"_\" && nums[j] === \"_\"){\\n            j++;\\n        } else {\\n            i++;\\n            j++;\\n        }\\n    }\\n    return k;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\n    let k = nums.length\\n    let l = 0;\\n    let mid = 1;\\n    let r = 2;\\n\\n    while(r<nums.length){\\n        if(nums[l] === nums[mid] && nums[r] === nums[mid]){\\n            nums[r] = \"_\";\\n            k--;\\n            r++;\\n        } else if (nums[l] === nums[mid] && nums[mid]!==nums[r]){\\n            l = r;\\n            mid = l + 1;\\n            r = mid + 1;\\n        } else {\\n            l++;\\n            mid++;\\n            r++\\n        }\\n    }\\n    let i = 0;\\n    let j = 1;\\n\\n    while(j < nums.length){\\n        if(nums[i] === \"_\" && nums[j]!== \"_\"){\\n            [nums[i], nums[j]] = [nums[j], nums[i]];\\n            i++;\\n            j++;\\n        } else if (nums[i] === \"_\" && nums[j] === \"_\"){\\n            j++;\\n        } else {\\n            i++;\\n            j++;\\n        }\\n    }\\n    return k;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907328,
                "title": "best-o-n-solution",
                "content": "# Approach\\nTwo Pointers\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = -1; \\n        for (int j = 0; j < n; j++) {\\n            if (i == -1 || nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n                if (j < n-1 && nums[j] == nums[j+1]) {\\n                    i++;\\n                    nums[i] = nums[j];\\n                    j++;\\n                }\\n            }\\n        }\\n        return i + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = -1; \\n        for (int j = 0; j < n; j++) {\\n            if (i == -1 || nums[i] != nums[j]) {\\n                i++;\\n                nums[i] = nums[j];\\n                if (j < n-1 && nums[j] == nums[j+1]) {\\n                    i++;\\n                    nums[i] = nums[j];\\n                    j++;\\n                }\\n            }\\n        }\\n        return i + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878331,
                "title": "o-n-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompared to \"Remove Elementes From A Sorted Array I\": The key differences are the \">\" symbol and l- 2.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPlaceholder \\'l\\' stops at the 3rd repeated value while \\'i\\' continues and looks for then next different value. The \">\" symbol prevents cases where 2 == 2 would be true and allows \\'i\\' to continue.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n        l = 2\\n\\n        for i in range(2, len(nums)):\\n            if nums[i] > nums[l - 2]:\\n                nums[l] = nums[i]\\n                l += 1\\n\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums):\\n        l = 2\\n\\n        for i in range(2, len(nums)):\\n            if nums[i] > nums[l - 2]:\\n                nums[l] = nums[i]\\n                l += 1\\n\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861369,
                "title": "3-line-easy-to-understand-code-beats-86-in-runtime-99-31-in-memory-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/7d40d8c6-78b0-4c5f-83f3-e20650fbd9e8_1691129420.0068429.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans=2\\n        for i in range(2,len(nums)):\\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans=2\\n        for i in range(2,len(nums)):\\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859756,
                "title": "simple-2-pointers-solution-speed-94-67-memory-86-44",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738535,
                "title": "two-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        l,r,count=0,1,1\\n   \\n        while (r<len(nums)):                \\n            if nums[r]==nums[l] and count<2:\\n                l+=1\\n                nums[l]=nums[r] \\n                count+=1\\n\\n            elif nums[r]==nums[l] and count>=2:\\n                count+=1\\n            else:\\n                count=1\\n                l+=1\\n                nums[l]=nums[r]\\n            r+=1\\n\\n        return l+1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        l,r,count=0,1,1\\n   \\n        while (r<len(nums)):                \\n            if nums[r]==nums[l] and count<2:\\n                l+=1\\n                nums[l]=nums[r] \\n                count+=1\\n\\n            elif nums[r]==nums[l] and count>=2:\\n                count+=1\\n            else:\\n                count=1\\n                l+=1\\n                nums[l]=nums[r]\\n            r+=1\\n\\n        return l+1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717239,
                "title": "the-solution-from-beginner-perspective-easy-to-understand",
                "content": "# Intuition\\nMy program is checking from the first element of the array then it goes one by one until the the 3rd from last element. \\n\\n# Approach\\nif  nums[i]  equals to  nums[i+2]  the program just continue because it means there is more than 2 of this element so we are not going to take it this one.\\nif it\\'s not equal it means this element less than 3 so we take it to our nums array like nums[index] = nums[i] index starting from zero when we arrived to last 3rd element of array we checked last time if it equals to last elemnet of the array we didnt take it but it\\'s not we take this one too. Then we automatically take it last two element of array to our nums array because we checked the last 3rd element then the last 2 elemen either equol or diffrent these two sitsituation is okey for the question.\\n\\nFeetback : I\\'am a beginner for java maybe this code slow which is not i checked :) or maybe it is not suitable for code standards but i think it easy to understand. if you understand that code you can make me understand by upvote my solutions.\\nthanks in advance\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k =2,index=0;\\n        if(nums.length == 1){ \\n            return k = 1;\\n        }    \\n        for(int i = 0; nums.length-3>=i; i++){\\n            if(!(nums[i] == nums [i+2])){\\n                nums[index] = nums[i];\\n                index++;\\n                k++;\\n            }\\n        }\\n        nums[index] = nums[(nums.length-2)];\\n        nums[index+1] = nums[(nums.length-1)];\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k =2,index=0;\\n        if(nums.length == 1){ \\n            return k = 1;\\n        }    \\n        for(int i = 0; nums.length-3>=i; i++){\\n            if(!(nums[i] == nums [i+2])){\\n                nums[index] = nums[i];\\n                index++;\\n                k++;\\n            }\\n        }\\n        nums[index] = nums[(nums.length-2)];\\n        nums[index+1] = nums[(nums.length-1)];\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585488,
                "title": "simple-python-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        i = 2\\n        for j in range(2,len(nums)):\\n            if nums[j] != nums[i - 2]:\\n                nums[i] = nums[j]\\n                i += 1\\n        return i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        i = 2\\n        for j in range(2,len(nums)):\\n            if nums[j] != nums[i - 2]:\\n                nums[i] = nums[j]\\n                i += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541541,
                "title": "c-time-o-n-memory-o-1-10-line-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        int count = 0;\\n        bool isPrevTwice = false;\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            bool isCurrentTwice = nums[count] == nums[i];\\n            if(!isCurrentTwice || !isPrevTwice)\\n                nums[++count] = nums[i];\\n            isPrevTwice = isCurrentTwice;\\n        }\\n        return count + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        int count = 0;\\n        bool isPrevTwice = false;\\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            bool isCurrentTwice = nums[count] == nums[i];\\n            if(!isCurrentTwice || !isPrevTwice)\\n                nums[++count] = nums[i];\\n            isPrevTwice = isCurrentTwice;\\n        }\\n        return count + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433964,
                "title": "easiest-handwritten-approach-with-dry-run-check-it-out",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/bf2875ee-778b-4ce2-9e02-c140706a3949_1681889805.5851915.png)\\n![image.png](https://assets.leetcode.com/users/images/bea318f3-e9ef-42f2-af88-36157512e861_1681889822.9460862.png)\\n![image.png](https://assets.leetcode.com/users/images/17b032ff-d978-4d80-83a2-4d26c2262a56_1681889851.0495398.png)\\n![image.png](https://assets.leetcode.com/users/images/a19c445f-d6f8-46d0-a039-de5617ef44bd_1681889868.721397.png)\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) \\n    {\\n        int s=0;//starting index of a new element\\n        int u=0;//updation index\\n        int n=arr.size();\\n        while(s<n)\\n        {\\n            int e=s;//ending index that will point to the last index of a given element\\n            int count=1;\\n            while(e<n-1 && arr[e+1]==arr[e])\\n            {\\n                e++;\\n                count++;\\n            }\\n            count=min(count,2);\\n            while(count--)\\n                arr[u++]=arr[s];\\n            s=e+1;\\n        }\\n        return u;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) \\n    {\\n        int s=0;//starting index of a new element\\n        int u=0;//updation index\\n        int n=arr.size();\\n        while(s<n)\\n        {\\n            int e=s;//ending index that will point to the last index of a given element\\n            int count=1;\\n            while(e<n-1 && arr[e+1]==arr[e])\\n            {\\n                e++;\\n                count++;\\n            }\\n            count=min(count,2);\\n            while(count--)\\n                arr[u++]=arr[s];\\n            s=e+1;\\n        }\\n        return u;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115163,
                "title": "easy-c-uniform-coding-style-that-works-for-remove-duplicates-from-sorted-array-i-and-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is that go through all the elements, along with that check if the current element has been included previously or not if included skip it, else add it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will keep two pointers:\\nWhile moving left will store the position to store the newly found element. At the end it will containt the number of unique elements.\\nRight(r) will move forward till the end of the given array.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\nFor [26. Remove Duplicates from Sorted Array\\n](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/) Allowed to keep only one instance\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 1) return n;\\n\\n        int left = 1;\\n        for (int r = 1; r < n; ++r)\\n            if (nums[r] != nums[left - 1]) nums[left++] = nums[r];\\n\\n        return left;   \\n    }\\n};\\n```\\n\\nFor [80. Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/)   \\nAllowed to keep atmost two instances\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 2) return n;\\n\\n        int left = 2;\\n        for (int r = 2; r < n; ++r)\\n            if (nums[r] != nums[left - 2]) nums[left++] = nums[r];\\n\\n        return left;  // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 1) return n;\\n\\n        int left = 1;\\n        for (int r = 1; r < n; ++r)\\n            if (nums[r] != nums[left - 1]) nums[left++] = nums[r];\\n\\n        return left;   \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n <= 2) return n;\\n\\n        int left = 2;\\n        for (int r = 2; r < n; ++r)\\n            if (nums[r] != nums[left - 2]) nums[left++] = nums[r];\\n\\n        return left;  // this will contain the no of unique elements in the array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472886,
                "title": "python-elegant-short-99-6-faster-two-variables-one-pass-o-1-memory",
                "content": "\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tMAX_DUPLICATES = 2\\n\\n\\t\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t\\ti = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif i < self.MAX_DUPLICATES or nums[i - self.MAX_DUPLICATES] != num:\\n\\t\\t\\t\\t\\tnums[i] = num\\n\\t\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn i\\n\\n![image](https://assets.leetcode.com/users/images/58e97f94-47de-4e07-b4cd-375064d8a426_1661338238.2996175.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tMAX_DUPLICATES = 2\\n\\n\\t\\tdef removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t\\ti = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif i < self.MAX_DUPLICATES or nums[i - self.MAX_DUPLICATES] != num:\\n\\t\\t\\t\\t\\tnums[i] = num\\n\\t\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\treturn i\\n\\n![image](https://assets.leetcode.com/users/images/58e97f94-47de-4e07-b4cd-375064d8a426_1661338238.2996175.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1758413,
                "title": "simple-solution-in-python-with-clean-code",
                "content": "\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# We don\\'t have to worry about the first two (0, 1 array index) numbers in the array.\\n\\t\\t# We have to decide whether to keep the third (array index 2) element or overwrite it and so on.\\n        write_index = 2\\n        for i in range(2, len(nums)):\\n\\t\\t    # If the last two numbers in the array are the same as the current one, don\\'t increment the write_index.\\n\\t\\t\\t# Our search for the next number to be added to the list continues.\\n            if nums[write_index - 2] == nums[write_index - 1] == nums[i]:\\n                continue\\n\\t\\t\\t# We have found a non duplicate, copy the number into the position of the write_index and increment it.\\n            nums[write_index] = nums[i]\\n            write_index += 1\\n\\n        return write_index\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n\\t\\t# We don\\'t have to worry about the first two (0, 1 array index) numbers in the array.\\n\\t\\t# We have to decide whether to keep the third (array index 2) element or overwrite it and so on.\\n        write_index = 2\\n        for i in range(2, len(nums)):\\n\\t\\t    # If the last two numbers in the array are the same as the current one, don\\'t increment the write_index.\\n\\t\\t\\t# Our search for the next number to be added to the list continues.\\n            if nums[write_index - 2] == nums[write_index - 1] == nums[i]:\\n                continue\\n\\t\\t\\t# We have found a non duplicate, copy the number into the position of the write_index and increment it.\\n            nums[write_index] = nums[i]\\n            write_index += 1\\n\\n        return write_index\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749926,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "\\n\\nHere, we will keep tab on the current element in the variable \\'now\\'. And we are keeping a counter to count the number of elements with the value \\'now\\'.\\n\\nIf the count becomes more than 2, we will remove that element from the list. \\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int now,count=1,pos=1;\\n        now=nums[0];\\n        for(int i=pos;i<nums.size();i++){\\n            if(nums[i]==now){\\n                count++;\\n                if(count>2){\\n                    nums.erase(nums.begin()+i);\\n                    i--;\\n                }\\n            }\\n            else {\\n                    count=1;\\n                    now=nums[i];\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int now,count=1,pos=1;\\n        now=nums[0];\\n        for(int i=pos;i<nums.size();i++){\\n            if(nums[i]==now){\\n                count++;\\n                if(count>2){\\n                    nums.erase(nums.begin()+i);\\n                    i--;\\n                }\\n            }\\n            else {\\n                    count=1;\\n                    now=nums[i];\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749815,
                "title": "python-naive-efficient-approach",
                "content": "Naive approach:\\n\\n- store the count of each number appearing.\\n- if count is greater than 2 then pop and append it to the last of the list \\n- increase the k count by 1 and return length of nums - k as the answer\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        d, k, n, i = {}, 0, len(nums), 0\\n        while i<n:\\n            if d.get(nums[i], 0)>=2 and i<n-k:\\n                nums.append(nums.pop(i))\\n                k += 1\\n                continue\\n            d[nums[i]] = d.get(nums[i], 0) + 1\\n            i+=1\\n        return len(nums)-k\\n```\\n\\nEfficient Approach:\\n\\n- As the array is already sorted we know can track the count of each number by going to next second element to it.\\n- And replace it whenever there is count > 2 and increase k value for both appending and traversal.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        for i in nums:\\n            if k < 2 or i > nums[k-2]:\\n                nums[k] = i\\n                k += 1\\n        return k\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        d, k, n, i = {}, 0, len(nums), 0\\n        while i<n:\\n            if d.get(nums[i], 0)>=2 and i<n-k:\\n                nums.append(nums.pop(i))\\n                k += 1\\n                continue\\n            d[nums[i]] = d.get(nums[i], 0) + 1\\n            i+=1\\n        return len(nums)-k\\n```\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k = 0\\n        for i in nums:\\n            if k < 2 or i > nums[k-2]:\\n                nums[k] = i\\n                k += 1\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749743,
                "title": "python3-simple-and-easy-faster-90",
                "content": "```\\n\\t\\tprev=nums[0]\\n        count=0\\n        ans=0\\n        for i in range(len(nums)):\\n            if nums[i]==prev:\\n                count+=1\\n                if count>2:\\n                    nums[i]=None\\n                    ans+=1\\n            else:\\n                prev=nums[i]\\n                count=1\\n        while ans>0:\\n            nums.remove(None)\\n            ans-=1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\t\\tprev=nums[0]\\n        count=0\\n        ans=0\\n        for i in range(len(nums)):\\n            if nums[i]==prev:\\n                count+=1\\n                if count>2:\\n                    nums[i]=None\\n                    ans+=1\\n            else:\\n                prev=nums[i]\\n                count=1\\n        while ans>0:\\n            nums.remove(None)\\n            ans-=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1749068,
                "title": "easy-to-understand-c-solution-in-linear-time-and-constant-space",
                "content": "Use two pointers i and j, i => to iterate through the array, j => to maintain writing pos for the next element.\\nWhile iterating through the array, keep count of elements having same value as current:\\n-if you encounter same element  and count is less than 2, then store the element in the next position\\n-else if you encounter a different element, then reset the count to 1 and store that element in the next position.\\nreturn j\\n\\nTC: O(n)\\nSC: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int cur = nums[0];\\n        int count = 1;\\n        int j = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] == cur) {\\n                count++;\\n                if(count <= 2) {\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else {\\n                cur = nums[i];\\n                count = 1;\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int cur = nums[0];\\n        int count = 1;\\n        int j = 1;\\n        for(int i = 1; i < nums.size(); i++) {\\n            if(nums[i] == cur) {\\n                count++;\\n                if(count <= 2) {\\n                    nums[j] = nums[i];\\n                    j++;\\n                }\\n            }\\n            else {\\n                cur = nums[i];\\n                count = 1;\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1708962,
                "title": "java-remove-duplicates-o-n-two-pointer-solution",
                "content": "For reference, a solution from which I will build up on:\\n\\n**Remove Duplicates From Sorted Array**\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array/\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i-1] == nums[i]) continue;\\n            nums[++res] = nums[i];\\n        }\\n        return ++res;\\n    }\\n}\\n```\\nSince now two duplicates are allowed, I introduce a boolean flag to indicate duplicates occurring.\\n\\n**Remove Duplicates From Sorted Array II**\\nhttps://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        boolean found = false;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (found && nums[i-1] == nums[i]) continue; // if duplicate past twice move on\\n            if (nums[i-1] == nums[i]) found = true; // 1. if first duplicate, record boolean flag\\n            else found = false; // 2. if not duplicate, reset boolean flag\\n            nums[++res] = nums[i]; // overwrite for both cases\\n        }\\n        return ++res;\\n    }\\n}\\n```\\nTo see why both 1 and 2 cases should overwrite, consider the example `[0,0,1,1,1,1,2,3,3]`.\\nFor case 2, it is clear that the array index at res should be overwritten: a new unduplicated number has been introduced.\\nFor case 1, without the array index at res overwritten the solution would return `[0,0,1,1,2,3,2,_,_]` not `[0,0,1,1,2,3,3,_,_]`.\\nTo see why, note that at index `i == 8` index `res == 5`. We see a smaller number 2 after the 3 that overwrote index `res`.\\n\\n\\nThis is indicative of a corner case in which the duplicate of the last overwriting number was not reflected properly.\\nTo reflect this corner case the solution faithfully overwrites value at `res` whenever it finds a new duplicate. In the best case, it just redundantly overwrites the duplicate that occurred right before. In the worst case, it properly overwrites the value right next to the duplicate that occurred somewhere much before.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i-1] == nums[i]) continue;\\n            nums[++res] = nums[i];\\n        }\\n        return ++res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int res = 0;\\n        boolean found = false;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (found && nums[i-1] == nums[i]) continue; // if duplicate past twice move on\\n            if (nums[i-1] == nums[i]) found = true; // 1. if first duplicate, record boolean flag\\n            else found = false; // 2. if not duplicate, reset boolean flag\\n            nums[++res] = nums[i]; // overwrite for both cases\\n        }\\n        return ++res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356963,
                "title": "most-optimised-code-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int i=0;\\n        for(auto x:nums)\\n        {\\n           if(i<2 or x>nums[i-2]) //after 2 conditions they is no need to check \"i\" we need to compare with  last 2nd element\\n           {\\n               nums[i]=x;\\n               i++;\\n           }\\n        }\\n        return i;\\n\\t\\t//Please UpVote if you are happy\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int i=0;\\n        for(auto x:nums)\\n        {\\n           if(i<2 or x>nums[i-2]) //after 2 conditions they is no need to check \"i\" we need to compare with  last 2nd element\\n           {\\n               nums[i]=x;\\n               i++;\\n           }\\n        }\\n        return i;\\n\\t\\t//Please UpVote if you are happy\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355654,
                "title": "python-simple-two-pointers-with-explanation",
                "content": "`cur_idx` is the current index at which we\\'ll place `nums[i]`\\n\\n`count` is the current count of consecutive elements\\n\\nWe increment `count` if `i` isn\\'t the last index of the array and the next element of the array is equal to the current element of the array. Then, we swap the elements at `i` and `cur_idx`. \\n\\nWe only increment `cur_idx` if the count of duplicate elements is two or less because if the current count is greater than that, we only want to write that element at most two times.\\n\\n```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        cur_idx, count, n = 0, 1, len(nums)\\n        for i in range(n):\\n            count = count+1 if i+1 < n and nums[i] == nums[i+1] else 1\\n            nums[i], nums[cur_idx] = nums[cur_idx], nums[i]\\n            cur_idx += (count <= 2)\\n        return cur_idx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\ndef removeDuplicates(self, nums: List[int]) -> int:\\n        cur_idx, count, n = 0, 1, len(nums)\\n        for i in range(n):\\n            count = count+1 if i+1 < n and nums[i] == nums[i+1] else 1\\n            nums[i], nums[cur_idx] = nums[cur_idx], nums[i]\\n            cur_idx += (count <= 2)\\n        return cur_idx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 744616,
                "title": "nice-and-easy-c-solution-using-two-pointers",
                "content": "```\\n  int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 2){\\n            return nums.size();\\n        }\\n    int pos = 2;\\n    for(int i=2;i<nums.size();i++)\\n    {\\n        if((nums[i] != nums[pos-2])||(nums[i]!=nums[pos-1]))\\n        {\\n            nums[pos] = nums[i];\\n            pos++;\\n        }\\n        \\n    }\\n    return pos;",
                "solutionTags": [],
                "code": "```\\n  int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 2){\\n            return nums.size();\\n        }\\n    int pos = 2;\\n    for(int i=2;i<nums.size();i++)\\n    {\\n        if((nums[i] != nums[pos-2])||(nums[i]!=nums[pos-1]))\\n        {\\n            nums[pos] = nums[i];\\n            pos++;\\n        }\\n        \\n    }\\n    return pos;",
                "codeTag": "Unknown"
            },
            {
                "id": 618939,
                "title": "generic-solution-o-n-time-and-o-1-for-remove-duplicates-from-sorted-array-i-and-ii",
                "content": "\\n[Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 2 || nums[k-2] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```\\n\\n[Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/)\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 1 || nums[k-1] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 2 || nums[k-2] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k = 0;\\n        for (int num : nums) {\\n            if (k < 1 || nums[k-1] < num) {\\n                nums[k++] = num;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391499,
                "title": "javascript-solution-56ms",
                "content": "\\n>\\u221A Accepted\\n  \\u221A 166/166 cases passed (56 ms)\\n  \\u221A Your runtime beats 98.23 % of javascript submissions\\n  \\u221A Your memory usage beats 100 % of javascript submissions (35.6 MB)\\n  \\n```\\nvar removeDuplicates = function(nums) {\\n  if (nums.length < 3) return;\\n  let i = 2;\\n  while(nums[i] !== undefined) {\\n    if (nums[i] === nums[i-2]) {\\n      let cur = i;\\n      while(nums[i] === nums[++i]) {}\\n      nums.splice(cur,i-cur);\\n      i = cur;\\n    } else {\\n      i++;\\n    }\\n  }\\n  return;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/tiokang/image_1569737680.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(nums) {\\n  if (nums.length < 3) return;\\n  let i = 2;\\n  while(nums[i] !== undefined) {\\n    if (nums[i] === nums[i-2]) {\\n      let cur = i;\\n      while(nums[i] === nums[++i]) {}\\n      nums.splice(cur,i-cur);\\n      i = cur;\\n    } else {\\n      i++;\\n    }\\n  }\\n  return;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 174982,
                "title": "python-solution-100-32ms",
                "content": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l=len(nums)\\n        if l<2:\\n            return l\\n        i=2\\n        for num in nums[2:]:\\n            if num!=nums[i-2]:\\n                nums[i]=num\\n                i+=1\\n        return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l=len(nums)\\n        if l<2:\\n            return l\\n        i=2\\n        for num in nums[2:]:\\n            if num!=nums[i-2]:\\n                nums[i]=num\\n                i+=1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28099,
                "title": "java-1ms-solution",
                "content": "    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int length = nums.length;\\n        int start = 0, times = 1;\\n        for (int i = 1; i < length; i++) {\\n            if (nums[i] != nums[start]) {\\n                start++;\\n                nums[start] = nums[i];\\n                times = 1;\\n            } else {\\n                times++;\\n                if (times == 2) {\\n                    start++;\\n                    nums[start] = nums[start - 1];\\n                }\\n            }\\n        }\\n        return start + 1;\\n    }\\n\\ncount how many times the nums[start] comes, if it has 2 times, start++ and set the second one the same as the first one. If the next value is not the same as nums[start], set the next value to nums[start++];",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int length = nums.length;\\n        int start = 0, times = 1;\\n        for (int i = 1; i < length; i++) {\\n            if (nums[i] != nums[start]) {\\n                start++;\\n                nums[start] = nums[i];\\n                times = 1;\\n            } else {\\n                times++;\\n                if (times == 2) {\\n                    start++;\\n                    nums[start] = nums[start - 1];\\n                }\\n            }\\n        }\\n        return start + 1;\\n    }\\n\\ncount how many times the nums[start] comes, if it has 2 times, start++ and set the second one the same as the first one. If the next value is not the same as nums[start], set the next value to nums[start++];",
                "codeTag": "Unknown"
            },
            {
                "id": 3964930,
                "title": "javascript-typescript-efficient-algorithm",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable j to 2. This will keep track of the index where the next non-duplicate element should be placed.\\n\\n2. Iterate over the array nums starting from index 2 (since the first two elements are allowed to appear twice).\\n\\n   a. For each index i starting from 2 and going up to the length of nums:\\n      i. Check if the current element nums[i] is not equal to the element at index j - 2. This condition ensures that we\\'re only allowing duplicates to appear twice.\\n      ii. If the condition is true, assign the value of nums[i] to the position nums[j] (j being the next available index for a non-duplicate element) and increment j by 1.\\n\\n3. After the loop, the variable j now holds the count of unique elements with duplicates allowed at most twice.\\n\\n4. Return the value of j as the new length of the modified array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst removeDuplicates = (nums) => {\\n  let j = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```\\n# Code\\n```typescript []\\nconst removeDuplicates = (nums: number[]): number => {\\n  let j:number = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst removeDuplicates = (nums) => {\\n  let j = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```\n```typescript []\\nconst removeDuplicates = (nums: number[]): number => {\\n  let j:number = 2;\\n\\n  for (let i = 2; i < nums.length; i++) {\\n    if (nums[i] !== nums[j - 2]) {\\n      nums[j++] = nums[i];\\n    }\\n  }\\n  \\n  return j;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3933663,
                "title": "easy-c-solution-beat-100",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ind=0;\\n       for(auto no :nums){\\n           if(ind<2||no>nums[ind-2])\\n               nums[ind++]=no;\\n       }\\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int ind=0;\\n       for(auto no :nums){\\n           if(ind<2||no>nums[ind-2])\\n               nums[ind++]=no;\\n       }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923393,
                "title": "easiest-solution-using-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        index = 0\\n\\n        for num, count in counter.items():\\n            nums[index] = num\\n            index += 1\\n            if count > 1:\\n                nums[index] = num\\n                index += 1\\n\\n        return index\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        index = 0\\n\\n        for num, count in counter.items():\\n            nums[index] = num\\n            index += 1\\n            if count > 1:\\n                nums[index] = num\\n                index += 1\\n\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661984,
                "title": "java-solution-runtime-0-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        if(nums.length == 2)\\n        return nums.length;\\n\\n        int fillindex=0;\\n\\n        int len=0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int startindex=i;\\n           \\n            while(i<nums.length-1 && nums[i] == nums[i+1])\\n            {\\n                i++;\\n            }\\n\\n            len = (i-startindex)+1;\\n\\n            int counter = Math.min(len,2);\\n\\n            while(counter>0 )\\n            {\\n                nums[fillindex]=nums[startindex];\\n                counter--;\\n                fillindex++;\\n            }\\n        }\\n\\n        return fillindex;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        \\n        if(nums.length == 2)\\n        return nums.length;\\n\\n        int fillindex=0;\\n\\n        int len=0;\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int startindex=i;\\n           \\n            while(i<nums.length-1 && nums[i] == nums[i+1])\\n            {\\n                i++;\\n            }\\n\\n            len = (i-startindex)+1;\\n\\n            int counter = Math.min(len,2);\\n\\n            while(counter>0 )\\n            {\\n                nums[fillindex]=nums[startindex];\\n                counter--;\\n                fillindex++;\\n            }\\n        }\\n\\n        return fillindex;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602270,
                "title": "java-4-codes-actually-2-but-the-3rd-one-is-interesting-xd-4th-one-beats-100-time-and-space",
                "content": "# Method 1: Frequency Array\\n\\n## Intuition\\nSo the first intuition on seeing this problem and its constraints was to solve this using frequency array. But the problem is that there are negative numbers also, so had to think of a way to tackle those. Read below to learn how I solved this.\\n\\n## Approach\\nSo the approach is simple:\\n1. There will be an array `freqp[]` for handling the normal positive numbers.\\n\\n2. There will be an array `freqn[]` for handling the negative numbers.\\n\\n3. Next, start filling the `freqp[]` and `freqn[]` arrays (as mentioned in the code given below).\\n\\n4. Now, building of the `freqp[]` is simple, but for `freqn[]`, since we can\\'t have negative array indices, so I will mark the particular negative number at the index `-1*(negative number)` in the `freqn[]` array.\\n\\n5. Next, I run 2 while loops, each with 2 variables, `i` which is used for traversing the frequency arrays, first `freqn[]` (since negative numbers are smaller than the positive numbers), starting with `i=10000` up to `i=0`, because the greater the magnitude the smaller the negative of it (10000>1 but -10000<-1), and later for `freqp[]`, starting with `i=0` up to `i=10000`. And the other variable is `p`, which is used for filling `nums[]`.\\n\\n6. Now, inside each while loop wherever the frequency is greater than `0`, we first check if the frequency is greater than `2`, if so, then replace it with `2`, and fill next 2 positions of nums using `p`, while decrementing the frequency until it becomes `0`.\\n\\n7. After going through both the while loops, `p` will be last index where any value was manually filled, so it is that `k` which is to be returned.\\n\\n## Complexity\\n- **Time complexity:**\\nTime complexity is `O(n+k)`, where `n` is the size of input array, and `k` is the range of numbers (constraints).\\n\\n- **Space complexity:**\\nSpace complexity is also `O(n+k)`.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int freqn[] = new int[10001];\\n        int freqp[] = new int[10001];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                freqn[(-nums[i])]++;\\n            }\\n            else{\\n                freqp[nums[i]]++;\\n            }\\n        }\\n        int i = 10000, p = 0;\\n        while(i>=0){\\n            if(freqn[i]>0){\\n                if(freqn[i]>2)\\n                freqn[i]=2;\\n                while(freqn[i]>0){\\n                    nums[p++]=-i;\\n                    freqn[i]--;\\n                }\\n            }\\n            i--;\\n        }\\n        i=0;\\n        while(i<=10000){\\n            if(freqp[i]>0){\\n                if(freqp[i]>2)\\n                freqp[i]=2;\\n                while(freqp[i]>0){\\n                    nums[p++]=i;\\n                    freqp[i]--;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return p;\\n\\n    }\\n}\\n```\\n\\n## Result\\n\\n![image.png](https://assets.leetcode.com/users/images/ce865d3d-1256-4f85-8d09-047be9d6908a_1685997186.793973.png)\\n\\n\\n---\\n\\n# Method 2: Two Pointers\\n\\n## Intuition\\nI got intuition on seeing that my previous solution had beaten too less of the available JAVA solutions. So, I started thinking in another way. I knew this could be solved by 2 pointers, but the thing was how?\\n\\n## Approach\\nThe approach to this solution needed testing on edges, but rest was easy to think of:\\n1. Have 3 pointers (indexes), `i`, `j`, and `p`. `i` will be used to determine the number which is currently being repeated. `j` is used to traverse the repeated instances of the number at index `i`. And `p` is used to fill the array `nums[]` (in-place). *Yes if it was not mentioned that the solution had to be in-place, then making another `ans[]` array, we could solve the problem with just `i` and `p`.*\\n\\n2. Figuring out 3 pointers were needed was easy but a bit tricky, but the next part is just easy to think of, however slightly complex to implement.\\n\\n3. So, we initialize `i`, `j`, `p` all to `0`, and have a `cnt` variable to count the number of times any particular value has been repeated (however it stops incrementing once it reaches `2`, so it is more sort of a check variable).\\n\\n4. Now, a while loop runs until `j` reaches the end of the `nums[]` array. In each iteration of the while loop:\\n\\n    1. If the value at index `j` is equal to that of `i`, that means, there is a repetition, and the `cnt` variable is incremented until it reaches `2`.\\n\\n        1. If the cnt variable hasn\\'t reached 2, then nums[p] will be filled with the same value at index `i` and `j`. And `p` is also incremented after each fill.\\n\\n        2. If the `cnt` variable has reached `2`, then we won\\'t increment `p`, because we can\\'t have more than 2 occurences in the final array.\\n\\n    2. If the value isn\\'t equal, that means we have found a new value and at this point `nums[i]!=nums[j]`. Hence, we change `i=j`, increment `j`, and set `cnt` to `1` (because the new number itself is also counted). And we also increment `p`, and the rest of the while loop continues.\\n\\n5. After the while loop is terminated, `p` gives the last index at which value was filled, `i` and `j` reach end of the array. So, we return `p`, while our array `nums[]` has been properly modified.\\n\\n\\n\\n## Complexity\\n- **Time complexity:**\\nTime Complexity is `O(n)`, where `n` is the size of the `nums[]` array.\\n\\n- **Space complexity:**\\nSpace Complexity is `O(1)` with in-place operations.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        return p;\\n    }\\n}\\n```\\n\\n## Result\\n![image.png](https://assets.leetcode.com/users/images/19e0b885-f997-426c-b7cd-2b236dc3c366_1685998948.7063458.png)\\n\\n\\n\\n---\\n\\n# Method 3 : Method 2 + Garbage Collector (XD)\\n\\n## Intuition\\nSo, it\\'s obvious when you grind 15 minutes (check difference between time stamps of previous 2 solutions), you won\\'t expect your code\\'s space complexity to just beat 47.15% of the other JAVA solutions. Hence, this is the intuition to do something crazy!\\n\\n## Approach\\nThe approach was nothing, but see the best solution that beats 100% space, so I found a solution (by clicking the first bar in the distribution chart).\\n\\nAnd you know what? I got to know an amazing technique to tease the LeetCode Judge, by manually running the Garbage Collector of JAVA before returning the answer to each test case.\\n\\nAnd the answer is `System.gc();`.\\n\\n# Complexity\\n- **Space complexity:**\\nSpace complexity of this new code as expected, did beat all JAVA solutions, (because you literally cleanup everything before returning lol).\\n\\n- **Time complexity:**\\nNow, the time complexity (`O(t*c),` where t is number of tc and c is the time to run the garbage collector in 1 call) was definitely a concern, because running so many test cases, everytime manually clearing up memory, would take more worth of time than it took to cleanup some small space in memory. This solution took less time than method 1, but no signs of beating 100% solutions.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        System.gc();\\n        return p;\\n    }\\n}\\n```\\n\\n\\n## Result\\n\\n![image.png](https://assets.leetcode.com/users/images/a8f2bf24-97f9-4094-a9b0-dd663b4d3b99_1685999693.956865.png)\\n\\n\\n---\\n\\n# Method 4 : Method 3 (but optimized!)\\n\\n## Intuition\\nSo, by now I had understood the fact that at this point with this 2 pointer solution, it was just space-time tradeoff using the garbage collector. And I just wanted to find some point where it gives the best combination of them.\\n\\n## Approach\\nSo, my approach now was to reduce the number of times that garbage collector was being run. Why not, just run it once in 5 or once in 10 times, and clear up all the space in minimal time?\\n\\nIf it was in my hands (or basically if I knew how the judge worked), I would have called the System.gc() command just before the last return value, but the fact is I don\\'t know how it functions.\\n\\n\\nBut I do have access to the current time in the System clock and how it works, so with different modulo hashes, I tried to get the best performance, and well starting from `%2`, then `%3`, finally `%4` gave me the best result.\\n\\nNow what do I mean by `%4`? It means I added just one line in my code which is of this structure:\\n\\n```\\nif(System.currentTimeMillis()%m==0)\\nSystem.gc();\\n```\\n\\nNow, this `m` can vary for different constraints, while here `m=4` worked for me. And so, finally, below you can see a code that beats 100% of space and 100% time in all JAVA solutions across LeetCode for this problem.\\n\\n\\n## Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n\\n        if(System.currentTimeMillis()%4==1)\\n        System.gc();\\n\\n        return p;\\n    }\\n}\\n```\\n\\n## Result\\n\\n![image.png](https://assets.leetcode.com/users/images/313d42a3-fbed-4d2b-9a8e-f52bc68a366e_1686000339.0158308.png)\\n\\n\\n\\n\\n---\\n\\n# A Request!\\n\\n***Please upvote this post so that other people can also learn something new, a part of which is logical, and the rest is crazy XD!***\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int freqn[] = new int[10001];\\n        int freqp[] = new int[10001];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                freqn[(-nums[i])]++;\\n            }\\n            else{\\n                freqp[nums[i]]++;\\n            }\\n        }\\n        int i = 10000, p = 0;\\n        while(i>=0){\\n            if(freqn[i]>0){\\n                if(freqn[i]>2)\\n                freqn[i]=2;\\n                while(freqn[i]>0){\\n                    nums[p++]=-i;\\n                    freqn[i]--;\\n                }\\n            }\\n            i--;\\n        }\\n        i=0;\\n        while(i<=10000){\\n            if(freqp[i]>0){\\n                if(freqp[i]>2)\\n                freqp[i]=2;\\n                while(freqp[i]>0){\\n                    nums[p++]=i;\\n                    freqp[i]--;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return p;\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        return p;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n        System.gc();\\n        return p;\\n    }\\n}\\n```\n```\\nif(System.currentTimeMillis()%m==0)\\nSystem.gc();\\n```\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int cnt = 0, i = 0, j = 0, p = 0;\\n        while(j<nums.length){\\n            if(nums[i]==nums[j]){\\n                if(cnt<2){\\n                    nums[p++]=nums[j];\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                nums[p++]=nums[j];\\n                i=j;\\n                cnt=1;\\n            }\\n            j++;\\n        }\\n\\n        if(System.currentTimeMillis()%4==1)\\n        System.gc();\\n\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576995,
                "title": "general-for-k-duplicates-easy-c-understandable-solution-beats-100",
                "content": "# Intuition\\nThe given array is sorted. This means next element will be either same element or bigger one. Store current element in a variable and keep comparing it with next element, also keep an eye that count does not exceed K (Here K is 2).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: I come up with the idea that if I swap array for every duplicates, it will be costly, so I thought why not mark that place and swap everything at last.\\nThere will be three cases as you can see in code\\nCase 1: Element of array is same as current element and count is still postive.\\nCase 2: Element of array is same as current element but count is not positive.\\nCase 3: Element of array is not equal to current.\\n\\nStep 2: I sort the array. \\nStep 3: Found the length using loop.\\nStep 4: Check Corner Cases for array size = 1 or 2 or 0;\\nYou are done!!!\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count = 1; // put K-1 here\\n        int curr = INT_MAX;\\n        if (nums.size() == 1) return 1;\\n        for (int i  = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == curr and count > 0)\\n            {\\n                count--;\\n            }\\n            else if (nums[i] == curr and count <= 0)\\n            {\\n                nums[i] = INT_MAX;\\n                count--;\\n            }\\n            else if (nums[i] != curr)\\n            {\\n                curr = nums[i];\\n                count = 1; // Put k-1 here\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        int i = 0, l = 0;\\n        while (i < nums.size())\\n        {\\n            if (nums[i++] < INT_MAX)\\n            l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count = 1; // put K-1 here\\n        int curr = INT_MAX;\\n        if (nums.size() == 1) return 1;\\n        for (int i  = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == curr and count > 0)\\n            {\\n                count--;\\n            }\\n            else if (nums[i] == curr and count <= 0)\\n            {\\n                nums[i] = INT_MAX;\\n                count--;\\n            }\\n            else if (nums[i] != curr)\\n            {\\n                curr = nums[i];\\n                count = 1; // Put k-1 here\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        int i = 0, l = 0;\\n        while (i < nums.size())\\n        {\\n            if (nums[i++] < INT_MAX)\\n            l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569694,
                "title": "same-approach-as-easy-one-0ms-beats-100-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int x = 2;\\n        for(int i = x; i < nums.length; i++) {\\n            if(nums[i] != nums[x - 2]) {\\n                nums[x++] = nums[i];\\n            }\\n        }\\n        return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486377,
                "title": "classical-two-pointer-approach-with-little-tweak-c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 1, j = 1;\\n        int count = 1;\\n\\n        while (i<n) {\\n            if (nums[i] == nums[i-1]) {\\n                if (count < 2) {\\n                    count++; \\n                    nums[j++] = nums[i];\\n                }\\n            }\\n            else {\\n                count = 1;\\n                nums[j++] = nums[i];\\n            }\\n\\n            i++;\\n        }\\n\\n        return j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 1, j = 1;\\n        int count = 1;\\n\\n        while (i<n) {\\n            if (nums[i] == nums[i-1]) {\\n                if (count < 2) {\\n                    count++; \\n                    nums[j++] = nums[i];\\n                }\\n            }\\n            else {\\n                count = 1;\\n                nums[j++] = nums[i];\\n            }\\n\\n            i++;\\n        }\\n\\n        return j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437027,
                "title": "using-java-beats-100-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k=1;\\n        int c=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                c=0;\\n            }\\n             if(c<=1){\\n                nums[k++] = nums[i];\\n                \\n            }\\n          \\n        }\\n        \\n          return k;\\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int k=1;\\n        int c=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n            {\\n                c++;\\n            }\\n            else\\n            {\\n                c=0;\\n            }\\n             if(c<=1){\\n                nums[k++] = nums[i];\\n                \\n            }\\n          \\n        }\\n        \\n          return k;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328439,
                "title": "simple-0ms-solution-beats-100-with-explanation-java-c",
                "content": "# Explanation & Example\\nSo from the question we can see **we need to remove duplicates in place and each element can appear atmost twice**.\\n\\nlet\\'s take the below array for **example**\\n**arr = [0,0,1,1,1,1,2,3,3]**\\n\\nSo in the initial observation we can see everything appears in correct count except 1.\\nWe initialize prev with 1st element(0) in array and we start with index 1,as we know the 1st element in array gonna be unique so we also initialize k with 1.as we are doing it in-place **assume our array(arr) has[0,-,-,-,-,-,-,-,-] for better understanding**.\\n\\n\\n- In 1st iteration prev = 0 as it is equal to ith value(0) we\\'ll increase the count to 1 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(0) and increment k [0,0,-,-,-,-,-,-,-].\\n\\n- In 2nd iteration prev = 0 and arr[i]=1 so the count becomes 0 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(1) and increment k [0,0,1,-,-,-,-,-,-]\\n\\n- In 3rd iteration prev = 1 and arr[i]=1 so the count becomes 1 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(1) and increment k [0,0,1,1,-,-,-,-,-]\\n\\n- In 4th & 5th iteration prev = 1 and arr[i]=1 so the count becomes 2 & 3 respectively as it does not pass the condition(c<=1) the array remains same[0,0,1,1,-,-,-,-,-]\\n\\n- In 6th iteration prev = 1 and arr[i]=2 so the count becomes 0 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(2) and increment k [0,0,1,1,2,-,-,-,-]\\n\\n- In 7th iteration prev = 2 and arr[i]=3 so the count becomes 0 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(3) and increment k [0,0,1,1,2,3,-,-,-]\\n\\n- In 8th iteration prev = 3 and arr[i]=3 so the count becomes 1 as it pass the condition(c<=1) we\\'ll assign arr[k] with ith value(3) and increment k [0,0,1,1,2,3,3,-,-]\\n\\n- In 8th iteration the k will be in 6th index and as usual we\\'ll increment and k becomes 7\\n\\n- so we got the **output as 7** and we can see the array(arr) becomes [0,0,1,1,2,3,3,-,-] and the **first 7 value(0-6 index) in the array has unique elements appears at most twice**.\\n\\n# Complexity\\n- Time complexity : O(N)\\n\\n- Space complexity : O(1)\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.length;i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n}\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.size();i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.length;i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n      int prev = arr[0],k = 1,c=0;\\n\\t    for(int i=1;i<arr.size();i++){\\n\\t        if(prev==arr[i]) c++;\\n\\t        else if(prev!=arr[i]) c = 0;\\n\\t        if(c<=1) arr[k++] = arr[i];\\n\\t        prev = arr[i];\\n\\t    }\\n\\t    return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196900,
                "title": "c-hash-table-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){\\n            if(m[nums[i]]==2){\\n                nums.erase(nums.begin()+i);\\n                i--;\\n            }\\n            else{\\n                m[nums[i]]++;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int, int>m;\\n        for(int i=0; i<nums.size(); i++){\\n            if(m[nums[i]]==2){\\n                nums.erase(nums.begin()+i);\\n                i--;\\n            }\\n            else{\\n                m[nums[i]]++;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090684,
                "title": "remove-duplicates-from-sorted-array",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=list(set(nums))\\n        l={i:nums.count(i) for i in k}\\n        for i in k:\\n            if(l[i]>2):\\n                for j in range(l[i]-2):\\n                    nums.remove(i)\\n        return len(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        k=list(set(nums))\\n        l={i:nums.count(i) for i in k}\\n        for i in k:\\n            if(l[i]>2):\\n                for j in range(l[i]-2):\\n                    nums.remove(i)\\n        return len(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080349,
                "title": "easy-solution-using-maps-o-n-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int idx=0;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int cnt=(it->second<=2)?it->second:2;\\n            while(cnt){\\n                nums[idx++]=it->first;\\n                cnt--;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int idx=0;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int cnt=(it->second<=2)?it->second:2;\\n            while(cnt){\\n                nums[idx++]=it->first;\\n                cnt--;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852511,
                "title": "java-o-n-1ms-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int prev = nums[0], count = 1, idx = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == prev) {\\n                count++;\\n            } else {\\n                count = 1;\\n                prev = nums[i];\\n            }\\n            if (count >= 3) {\\n                continue;\\n            }\\n            nums[idx++] = prev;\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int prev = nums[0], count = 1, idx = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == prev) {\\n                count++;\\n            } else {\\n                count = 1;\\n                prev = nums[i];\\n            }\\n            if (count >= 3) {\\n                continue;\\n            }\\n            nums[idx++] = prev;\\n        }\\n        return idx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786407,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), i = 1, pos = 1, c = 1;\\n\\n        while(i<n){\\n            if(c < 2 && nums[i] == nums[i-1]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c++;\\n            }\\n            else if(nums[pos-1] != nums[i]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c = 1;\\n            }\\n            else {\\n                while(i<n && nums[pos-1] == nums[i]) i++ ;\\n                c = 0;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n = nums.size(), i = 1, pos = 1, c = 1;\\n\\n        while(i<n){\\n            if(c < 2 && nums[i] == nums[i-1]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c++;\\n            }\\n            else if(nums[pos-1] != nums[i]){\\n                nums[pos] = nums[i];\\n                i++, pos++, c = 1;\\n            }\\n            else {\\n                while(i<n && nums[pos-1] == nums[i]) i++ ;\\n                c = 0;\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427237,
                "title": "a-simple-java-solution-that-beats-100-with-explanation",
                "content": "Since the array is already sorted and we want to keep at most two duplicates, we only need to compare `nums[i]` and `nums[i - 2]` if the original array is not modified. For the array `nums = [1,1,1,2,2,3]`, we saw `nums[2] == nums[0]`, which means there are more than 2 duplicates and we should remove one of them. \\n\\nTo remove the duplicates, we need a pointer `current` that points to the index, where the elements before it has at most 2 duplicates. In this way, we can overwrite it with a valid number later. For example, for the array `nums = [1,1,1,2,2,3]`, `2` would be our index because there are only two numbers before. We noticed `nums[2] == nums[0]`. So we may want to replace `nums[2]` with some value after it. Since `nums[3] != nums[1]`, we can replace `nums[2]` with `nums[3]`. Thus the array becomes `[1,1,2,2,2,3]`. For this new array, we saw that `nums[4] == nums[2]`. But we don\\'t want to remove it since we added the extra `2`. We must add the offset, which is `i - current`, where `i` is the pointer of the original array. So the comparation will be between `nums[i]` and `nums[i - 2 - (i - current)]`, which is `nums[current - 2]`.\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int current = 2;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[current - 2]) {\\n                nums[current++] = nums[i];\\n            }\\n        }\\n        return current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int current = 2;\\n        for (int i = 2; i < nums.length; i++) {\\n            if (nums[i] != nums[current - 2]) {\\n                nums[current++] = nums[i];\\n            }\\n        }\\n        return current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195204,
                "title": "o-n-with-o-1-extra-memory-java-c-c",
                "content": "**Algorithm**\\n* If length of nums is less than 2 then simply return length of array\\n* We can solve this question using two pointers i.e., i and count. Count will track the index of array to be sent and i will track the index of next bigger element\\n* If current element is less than next element that means only one element is present, then add the ith element in array at count index, incrementing count for next element.\\n* Else, that means there are more than one elements of that current element. We know that we can add at most two elements, so we will add ith element in the array upto next 2 count pointers. \\n* We need to shift the ith element to the next greater element.\\n* There might be chances that the last element of nums can be remained uncheckd, so once the ith pointer is at second last element then we can add the i+1th element at count place in array.\\n\\nTime Complexity: O(n) with O(1) extra memory\\n**Code in Java**\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length <= 1) return nums.length;\\n        int count = 0; \\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] < nums[i+1]) {\\n                nums[count++] = nums[i];\\n            }\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.length-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.length-1) nums[count++] = nums[i+1];\\n        }\\n        return count++;\\n    }\\n}\\n```\\n**Code in C++**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 1) return nums.size();\\n        int count=0;\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.size()-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.size()-1) nums[count++] = nums[i+1];\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Code in C**\\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    if(numsSize <= 1) return numsSize;\\n    int count=0;\\n    for(int i=0; i<numsSize-1; i++){\\n        if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n        else{\\n            nums[count++] = nums[count++] = nums[i];\\n            while(i<numsSize-1 && nums[i] >= nums[i+1]) i++;\\n        }\\n        if(i+1 == numsSize-1) nums[count++] = nums[i+1];\\n    }\\n    return count;\\n}\\n```\\n\\n**Please upvote if you found the solution helpful**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length <= 1) return nums.length;\\n        int count = 0; \\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i] < nums[i+1]) {\\n                nums[count++] = nums[i];\\n            }\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.length-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.length-1) nums[count++] = nums[i+1];\\n        }\\n        return count++;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() <= 1) return nums.size();\\n        int count=0;\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n            else{\\n                nums[count++] = nums[count++] = nums[i];\\n                while(i<nums.size()-1 && nums[i] >= nums[i+1]) i++;\\n            }\\n            if(i+1 == nums.size()-1) nums[count++] = nums[i+1];\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nint removeDuplicates(int* nums, int numsSize){\\n    if(numsSize <= 1) return numsSize;\\n    int count=0;\\n    for(int i=0; i<numsSize-1; i++){\\n        if(nums[i] < nums[i+1]) nums[count++] = nums[i];\\n        else{\\n            nums[count++] = nums[count++] = nums[i];\\n            while(i<numsSize-1 && nums[i] >= nums[i+1]) i++;\\n        }\\n        if(i+1 == numsSize-1) nums[count++] = nums[i+1];\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750932,
                "title": "very-very-easy-java-with-o-1-memory",
                "content": "```class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int index = 2;\\n        if(nums.length < 2)\\n            return nums.length;\\n        for(int i = 2 ; i < nums.length; i++) {\\n            if(nums[index-2] != nums[i]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int index = 2;\\n        if(nums.length < 2)\\n            return nums.length;\\n        for(int i = 2 ; i < nums.length; i++) {\\n            if(nums[index-2] != nums[i]) {\\n                nums[index] = nums[i];\\n                index++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1750790,
                "title": "swapping-to-preserve-the-relative-order",
                "content": "I think this is not optimal solution but easy to understand.\\n used bubble sort technique.\\n\\n\\tvoid bubbleSwap(vector<int> &nums,int i,int k){\\n        while(i<k){\\n            int temp = nums[i];\\n            nums[i] = nums[i + 1];\\n            nums[i + 1] = temp;\\n            \\n            i++;\\n        }\\n    }\\n    int removeDuplicates(vector<int>& nums) {\\n        int k = nums.size() - 1;\\n        map<int,int> hash;\\n        for(int i = nums.size() -1 ; i>=0; i--){\\n            if(hash[nums[i]]==2){\\n                bubbleSwap(nums,i,k);\\n                k--;\\n            }else{\\n                hash[nums[i]]++;\\n            }\\n        }\\n        \\n        return k + 1;\\n    }",
                "solutionTags": [],
                "code": "I think this is not optimal solution but easy to understand.\\n used bubble sort technique.\\n\\n\\tvoid bubbleSwap(vector<int> &nums,int i,int k){\\n        while(i<k){\\n            int temp = nums[i];\\n            nums[i] = nums[i + 1];\\n            nums[i + 1] = temp;\\n            \\n            i++;\\n        }\\n    }\\n    int removeDuplicates(vector<int>& nums) {\\n        int k = nums.size() - 1;\\n        map<int,int> hash;\\n        for(int i = nums.size() -1 ; i>=0; i--){\\n            if(hash[nums[i]]==2){\\n                bubbleSwap(nums,i,k);\\n                k--;\\n            }else{\\n                hash[nums[i]]++;\\n            }\\n        }\\n        \\n        return k + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1750721,
                "title": "c-simple-solution-easy-to-understand-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c = 0;                             // Initialize a counter \\n        int curr = nums[0];                    // store current value at 0th index in a variable\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if(nums[i] == curr && c < 1) {\\n                c++;                           // If a current value repeats itself atmost twice increase counter (i.e. c=1)\\n            }\\n            else if(nums[i] == curr && c >= 1) {\\n                nums.erase(nums.begin()+(i));  // If current value repeats more than twice than erase that value\\n                i--;                           // To repeat the current index with new value\\n            }\\n            else {\\n                curr = nums[i];                // update curr value\\n                c = 0;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int c = 0;                             // Initialize a counter \\n        int curr = nums[0];                    // store current value at 0th index in a variable\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if(nums[i] == curr && c < 1) {\\n                c++;                           // If a current value repeats itself atmost twice increase counter (i.e. c=1)\\n            }\\n            else if(nums[i] == curr && c >= 1) {\\n                nums.erase(nums.begin()+(i));  // If current value repeats more than twice than erase that value\\n                i--;                           // To repeat the current index with new value\\n            }\\n            else {\\n                curr = nums[i];                // update curr value\\n                c = 0;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749171,
                "title": "cpp-easy-solution-with-time-o-n-space-o-1-and-o-n",
                "content": "\\t\\t\\t//with TC -> O(N) and constant space\\n\\t\\t\\tif(nums.size()<3) return nums.size();\\n\\t\\t\\tint index = 2 ;\\n\\t\\t\\tfor(int i=2;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i] != nums[index-2]) nums[index++] = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn index;\\n\\t\\t\\n\\t\\t\\n\\t\\t/**************************************************************/\\n\\t\\t\\n\\t\\t//with TC -> O(N) and SC -> O(N)\\n\\t\\tunordered_map<int,int> mymap;\\n        int j = -1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           mymap[nums[i]]++;\\n           if(mymap[nums[i]]<3) j++;\\n            \\n            if(mymap[nums[i]]<=2 and nums[j]!=nums[i])\\n                nums[j] = nums[i];\\n            \\n        }\\n        return j+1;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "\\t\\t\\t//with TC -> O(N) and constant space\\n\\t\\t\\tif(nums.size()<3) return nums.size();\\n\\t\\t\\tint index = 2 ;\\n\\t\\t\\tfor(int i=2;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i] != nums[index-2]) nums[index++] = nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn index;\\n\\t\\t\\n\\t\\t\\n\\t\\t/**************************************************************/\\n\\t\\t\\n\\t\\t//with TC -> O(N) and SC -> O(N)\\n\\t\\tunordered_map<int,int> mymap;\\n        int j = -1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           mymap[nums[i]]++;\\n           if(mymap[nums[i]]<3) j++;\\n            \\n            if(mymap[nums[i]]<=2 and nums[j]!=nums[i])\\n                nums[j] = nums[i];\\n            \\n        }\\n        return j+1;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1650174,
                "title": "c-using-single-loop",
                "content": "\\n\\tint removeDuplicates(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n\\t\\tint idx=0;\\n\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(idx<1 or nums[idx]!=nums[i] or nums[idx-1]!=nums[i]) nums[++idx]=nums[i];\\n\\t\\t}\\n\\t\\treturn idx+1;\\n\\t}\\nplease upvote if u like :)",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\tint removeDuplicates(vector<int>& nums) {\\n\\t\\tint n=nums.size();\\n\\t\\tint idx=0;\\n\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(idx<1 or nums[idx]!=nums[i] or nums[idx-1]!=nums[i]) nums[++idx]=nums[i];\\n\\t\\t}\\n\\t\\treturn idx+1;\\n\\t}\\nplease upvote if u like :)",
                "codeTag": "Unknown"
            },
            {
                "id": 1377370,
                "title": "ez-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count,index,same;\\n        //initialize\\n        same=nums[0];\\n        count=index=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==same){//if same increase count\\n                count += 1;\\n\\t\\t\\t}\\n            else{            //if different reset count\\n                count=1;\\n                same=nums[i];\\n            }\\n            if(count<=2){     //for atmost 2 instance of duplicates\\n                nums[index]=nums[i];\\n                index+=1;\\n            }\\n        }\\n        return index;          //return index where last entered\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int count,index,same;\\n        //initialize\\n        same=nums[0];\\n        count=index=1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==same){//if same increase count\\n                count += 1;\\n\\t\\t\\t}\\n            else{            //if different reset count\\n                count=1;\\n                same=nums[i];\\n            }\\n            if(count<=2){     //for atmost 2 instance of duplicates\\n                nums[index]=nums[i];\\n                index+=1;\\n            }\\n        }\\n        return index;          //return index where last entered\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271028,
                "title": "c-solution",
                "content": "**intuition**\\nmaintain two pointers ```i``` and ```j```.\\npointer ```i``` is used to traverse the array, pointer ```j``` is used to mark the position where needs a replace.\\nwhen ```nums[i] == nums[j-2]```, then there are 3 duplicates  (```nums[j] = nums[j-1] = nums[j-2]```). ```j``` is pointing at the position where needs a replacement, so we don\\'t move ```j``` until we find the next number that can replace ```nums[j]```.\\nwhen ```nums[i] > nums[j-2]```, we find the number that can be used to replace ```nums[j]```.\\n\\n**complexity**\\n- time: O(N)\\n- space: O(1)\\n\\n**implementation**\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        \\n        int j = 0;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(i <= 1 || nums[i] > nums[j-2])\\n            {\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```i```\n```j```\n```i```\n```j```\n```nums[i] == nums[j-2]```\n```nums[j] = nums[j-1] = nums[j-2]```\n```j```\n```j```\n```nums[j]```\n```nums[i] > nums[j-2]```\n```nums[j]```\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        \\n        int j = 0;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(i <= 1 || nums[i] > nums[j-2])\\n            {\\n                nums[j] = nums[i];\\n                j++;\\n            }\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208200,
                "title": "two-pointers-c",
                "content": "Two pointer solution\\npointer ans = current space which could be filled if different element found than current number\\npointer i = finding different element \\n```\\nint ans = 2;\\n        if(nums.size()==2 || nums.size()==1) return nums.size();\\n        for(int i =2;i<nums.size();i++){\\n            if(nums[ans-2]!=nums[i]){\\n                nums[ans] = nums[i];\\n                ans++;\\n            }\\n            \\n        }\\n        return ans;",
                "solutionTags": [],
                "code": "Two pointer solution\\npointer ans = current space which could be filled if different element found than current number\\npointer i = finding different element \\n```\\nint ans = 2;\\n        if(nums.size()==2 || nums.size()==1) return nums.size();\\n        for(int i =2;i<nums.size();i++){\\n            if(nums[ans-2]!=nums[i]){\\n                nums[ans] = nums[i];\\n                ans++;\\n            }\\n            \\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 969763,
                "title": "two-pointer-approach-o-n-time-java",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<3)\\n            return nums.length;\\n        int left=2;\\n        for(int right=2;right<nums.length;right++)\\n        {\\n            if(nums[left-2]!=nums[right])\\n                nums[left++]=nums[right];\\n        }\\n        return left;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<3)\\n            return nums.length;\\n        int left=2;\\n        for(int right=2;right<nums.length;right++)\\n        {\\n            if(nums[left-2]!=nums[right])\\n                nums[left++]=nums[right];\\n        }\\n        return left;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968082,
                "title": "c-4ms-fast-solution-easy-to-understand",
                "content": "simple approach \\nStoring the value of last element in the variable a\\n using k to know whether it has iterated for more than two times \\n erasing the element if it comes for third time \\n ans stores the required size of vector\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& n) {\\n        if(n.size()<=1)\\n            return n.size();\\n        int a=n[0],ans=1;\\n        bool k=0;\\n        for(int i=1;i<n.size();i++)\\n        {\\n            if(n[i]==a)\\n            {\\n                if(k)\\n                {\\n                    n.erase(n.begin()+i);\\n                    i--;\\n                }\\n                else\\n                {\\n                    k=1;\\n                    ans++;\\n                }\\n            }\\n            else\\n            {\\n                a=n[i];\\n                k=0;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& n) {\\n        if(n.size()<=1)\\n            return n.size();\\n        int a=n[0],ans=1;\\n        bool k=0;\\n        for(int i=1;i<n.size();i++)\\n        {\\n            if(n[i]==a)\\n            {\\n                if(k)\\n                {\\n                    n.erase(n.begin()+i);\\n                    i--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 968049,
                "title": "c-simple-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int slow,fast,n=nums.size();\\n        if(n<2)\\n            return n;\\n        slow=2;\\n        fast=2;\\n        while(fast<n)\\n        {\\n            if(nums[slow-2]!=nums[fast])\\n            {\\n                swap(nums[slow],nums[fast]);\\n                slow++;\\n            }\\n            fast++;\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) \\n    {\\n        int slow,fast,n=nums.size();\\n        if(n<2)\\n            return n;\\n        slow=2;\\n        fast=2;\\n        while(fast<n)\\n        {\\n            if(nums[slow-2]!=nums[fast])\\n            {\\n                swap(nums[slow],nums[fast]);\\n                slow++;\\n            }\\n            fast++;\\n        }\\n        return slow;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968017,
                "title": "python-binary-search-solution-upper-bound-aka-bisect-right",
                "content": "Something like this maybe, wrote linear search first then replaced with upper bound:\\n```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = j = k = 0\\n        while k<len(nums):\\n            #while k<len(nums) and nums[j]==nums[k]: k += 1 # brute search\\n            k = bisect_right(nums, nums[j], j)\\n            for _ in range(min(2, k-j)):\\n                nums[i] = nums[j]\\n                i += 1\\n            j = k\\n        return i\\n```\\n\\nSolutions in this discussion remind me the Silicon Valley episode about brute search on a sorted list:\\n\\nhttps://www.youtube.com/watch?v=9FzT2I21F3k",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = j = k = 0\\n        while k<len(nums):\\n            #while k<len(nums) and nums[j]==nums[k]: k += 1 # brute search\\n            k = bisect_right(nums, nums[j], j)\\n            for _ in range(min(2, k-j)):\\n                nums[i] = nums[j]\\n                i += 1\\n            j = k\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967991,
                "title": "remove-duplicates-from-sorted-array-ii-c",
                "content": "**My Approach** : I used a pointer  --> i, for keeping track of the position I am currently in and a variable --> count, to count the occurence of the same element. Whenever the count exceeds 2 i.e more than 2 same elements, I erase it from the vector using the inbuilt erase() function; otherwise, I increase the pointer and reset the count variable to 1.\\nPls read the code for better clarity.\\nThanks!\\n**Pls upvote if you find this helpful.**\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        if((nums.size() == 0) || (nums.size() == 1))\\n            return nums.size();\\n        \\n        int i = 1,count = 1;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] == nums[i-1])\\n            {\\n                if(count >= 2)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                }\\n                else\\n                {\\n                    i += 1;\\n                    count += 1;\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n                i += 1;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        \\n        if((nums.size() == 0) || (nums.size() == 1))\\n            return nums.size();\\n        \\n        int i = 1,count = 1;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] == nums[i-1])\\n            {\\n                if(count >= 2)\\n                {\\n                    nums.erase(nums.begin() + i);\\n                }\\n                else\\n                {\\n                    i += 1;\\n                    count += 1;\\n                }\\n            }\\n            else\\n            {\\n                count = 1;\\n                i += 1;\\n            }\\n        }\\n        return nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679623,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 4 ms, faster than 90.35% of Go online submissions for Remove Duplicates from Sorted Array II.\\nMemory Usage: 3 MB, less than 75.25% of Go online submissions for Remove Duplicates from Sorted Array II.\\n\\n```go\\nfunc removeDuplicates(nums []int) int {\\n    i := 0\\n    for _, num := range nums {\\n        if i < 2 || num > nums[i - 2] {\\n            nums[i] = num\\n            i++\\n        }\\n    }\\n    return i\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc removeDuplicates(nums []int) int {\\n    i := 0\\n    for _, num := range nums {\\n        if i < 2 || num > nums[i - 2] {\\n            nums[i] = num\\n            i++\\n        }\\n    }\\n    return i\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674085,
                "title": "python3-linear-scan",
                "content": "**Algo**\\nSimilar to [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\\n\\n**Implementation**\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for x in nums: \\n            if i < 2 or nums[i-2] < x: \\n                nums[i] = x\\n                i += 1\\n        return i \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i = 0\\n        for x in nums: \\n            if i < 2 or nums[i-2] < x: \\n                nums[i] = x\\n                i += 1\\n        return i \\n```",
                "codeTag": "Java"
            },
            {
                "id": 533779,
                "title": "simplest-swift-solution",
                "content": "```\\n   func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        var i = 0;\\n        for num in nums where (i < 2 || num != nums[i-2]) {\\n            nums[i] = num\\n            i += 1\\n        }\\n        \\n        return i\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   func removeDuplicates(_ nums: inout [Int]) -> Int {\\n        var i = 0;\\n        for num in nums where (i < 2 || num != nums[i-2]) {\\n            nums[i] = num\\n            i += 1\\n        }\\n        \\n        return i\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 509355,
                "title": "python3-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, a: List[int]) -> int:\\n        if len(a)==0:\\n            return 0\\n        prev = a[0]\\n        count = 0\\n        j = 0\\n        for i in range(len(a)):\\n            if prev==a[i] and count<2:\\n                a[j] = a[i]\\n                j+=1\\n                count+=1\\n            elif prev!=a[i]:\\n                a[j] = a[i]\\n                j+=1\\n                prev = a[i]\\n                count = 1\\n        return j\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, a: List[int]) -> int:\\n        if len(a)==0:\\n            return 0\\n        prev = a[0]\\n        count = 0\\n        j = 0\\n        for i in range(len(a)):\\n            if prev==a[i] and count<2:\\n                a[j] = a[i]\\n                j+=1\\n                count+=1\\n            elif prev!=a[i]:\\n                a[j] = a[i]\\n                j+=1\\n                prev = a[i]\\n                count = 1\\n        return j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462841,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return n;\\n        int count{};\\n        for(int i=0;i<n-2;i++){\\n            if(nums[i]==nums[i+1]&& nums[i+1]==nums[i+2]){\\n                nums[i]=INT_MAX;\\n                count++;\\n            }\\n        }\\n        sort(nums.begin(),nums.end());\\n        return n-count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n<3)return n;\\n        int count{}",
                "codeTag": "Java"
            },
            {
                "id": 386869,
                "title": "python-2-variables-inplace-popping-easy-to-understand-with-explanation",
                "content": "The approach is quite simple, keep track of the current element in consideration and the count of the element. Initiate the track as the first element in the array and  have the occurence count as the second element, you may use a tuple for this of some simpler structure to save more memory. As you iterate, check if the count of the current element under consideration exceeds that under track, in which case we pop it but do not increment out tracker. While loops are convenient here since the array size changes and the len(nums) si computed prior to every iteration. In case they are different, reinitiate the tracker with the new value and set the second frequency element to 1.\\n \\n```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t#Handle empty case\\n        if not nums:\\n            return None\\n\\t\\t#Initiate track\\n        track = [nums[0],1]\\n\\t\\t#Counter\\n        num = 1\\n\\t\\t#Iterate through the array\\n        while num < len(nums):\\n\\t\\t\\t#If we are still considering the current tracked element, increment frequency and counter\\n            if nums[num] == track[0] and track[1]<=1:\\n                track[1]+=1\\n                num+=1\\n            #If the frequency exceeds our bench mark, then pop it from nums. Dont increase counter\\n\\t\\t\\telif nums[num] == track[0] and track[1]>1:\\n                track[1]+=1\\n                nums.pop(num)\\n\\t\\t\\t#Otherwise reinitiate tracker with new value and frequency 1\\n            elif nums[num]!= track[0]:\\n                track = [nums[num], 1]\\n                num+=1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicates(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\t\\t#Handle empty case\\n        if not nums:\\n            return None\\n\\t\\t#Initiate track\\n        track = [nums[0],1]\\n\\t\\t#Counter\\n        num = 1\\n\\t\\t#Iterate through the array\\n        while num < len(nums):\\n\\t\\t\\t#If we are still considering the current tracked element, increment frequency and counter\\n            if nums[num] == track[0] and track[1]<=1:\\n                track[1]+=1\\n                num+=1\\n            #If the frequency exceeds our bench mark, then pop it from nums. Dont increase counter\\n\\t\\t\\telif nums[num] == track[0] and track[1]>1:\\n                track[1]+=1\\n                nums.pop(num)\\n\\t\\t\\t#Otherwise reinitiate tracker with new value and frequency 1\\n            elif nums[num]!= track[0]:\\n                track = [nums[num], 1]\\n                num+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352667,
                "title": "java-simplest-approach-for-this-exercise",
                "content": "We can copy the exact same solution from https://leetcode.com/problems/remove-duplicates-from-sorted-array/\\nThe only trick is that we allow j to move forward n times when we find duplicates, where n = 2 for this exercise.\\nMake sure to add +1 to j when you return it because we want the length of the new array and not the last valid index.\\n\\n**Remove Duplicates from Sorted Array (LC #26)**\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {    \\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;\\n                nums[j] = nums[i];\\n            }    \\n        }\\n      \\n        return j;  \\n    }\\n}\\n```\\n\\n**Remove Duplicates from Sorted Array II**\\n\\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0, count = 1;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;                \\n                nums[j] = nums[i];\\n                count = 1; // reset the counter\\n            } else {                \\n                if (count < 2) { // we found 2 occurences of current number\\n                    j++;\\n                    nums[j] = nums[i];                    \\n                    count++;                    \\n                }\\n            }\\n        }\\n            \\n        return j+1; // we add one because we want to return the length and not the last index\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {    \\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;\\n                nums[j] = nums[i];\\n            }    \\n        }\\n      \\n        return j;  \\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums == null || nums.length == 0)      \\n            return 0;\\n        \\n        int j = 0, count = 1;        \\n        for (int i = 1; i < nums.length; i++) {              \\n            if (nums[i-1] != nums[i]) {                  \\n                j++;                \\n                nums[j] = nums[i];\\n                count = 1; // reset the counter\\n            } else {                \\n                if (count < 2) { // we found 2 occurences of current number\\n                    j++;\\n                    nums[j] = nums[i];                    \\n                    count++;                    \\n                }\\n            }\\n        }\\n            \\n        return j+1; // we add one because we want to return the length and not the last index\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314125,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<=2) return nums.length;\\n        int res = 2;\\n        for (int i=2; i<nums.length; i++){\\n            if (nums[res-2] != nums[i]){\\n                nums[res++] = nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if(nums.length<=2) return nums.length;\\n        int res = 2;\\n        for (int i=2; i<nums.length; i++){\\n            if (nums[res-2] != nums[i]){\\n                nums[res++] = nums[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27982,
                "title": "6-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() < 3) return nums.size();\\n        int i = 2, j = 2;\\n        while(j < nums.size())\\n            if(nums[j] > nums[i - 2]) nums[i++] = nums[j++];\\n            else j++;\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.size() < 3) return nums.size();\\n        int i = 2, j = 2;\\n        while(j < nums.size())\\n            if(nums[j] > nums[i - 2]) nums[i++] = nums[j++];\\n            else j++;\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 28071,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int n = nums.size();\\n            if (n < 3)\\n                return n;\\n                \\n            int i = 0, newSize = 2;\\n            \\n            for (i = 2; i < n; i++)\\n            {\\n            //if the current element is different from the penultimate element of the new nums,add the current element into the new nums \\n                if (nums[i] != nums[newSize-2])\\n                    nums[newSize++] = nums[i];\\n            }\\n            \\n            return newSize;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int removeDuplicates(vector<int>& nums) {\\n            int n = nums.size();\\n            if (n < 3)\\n                return n;\\n                \\n            int i = 0, newSize = 2;\\n            \\n            for (i = 2; i < n; i++)\\n            {\\n            //if the current element is different from the penultimate element of the new nums,add the current element into the new nums \\n                if (nums[i] != nums[newSize-2])\\n                    nums[newSize++] = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 28098,
                "title": "my-easy-c-solution",
                "content": "    int removeDuplicates(vector<int>& nums) {\\n    \\tif (nums.size() <= 2)\\n    \\t\\treturn nums.size();\\n    \\tfor (int i = 2; i < nums.size(); i++) {\\n    \\t\\tif (nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) {\\n    \\t\\t\\tvector<int>::iterator it = nums.begin() + i;\\n    \\t\\t\\tnums.erase(it);\\n    \\t\\t\\ti--;\\n    \\t\\t}\\n    \\t}\\n    \\treturn nums.size();\\n    }",
                "solutionTags": [],
                "code": "    int removeDuplicates(vector<int>& nums) {\\n    \\tif (nums.size() <= 2)\\n    \\t\\treturn nums.size();\\n    \\tfor (int i = 2; i < nums.size(); i++) {\\n    \\t\\tif (nums[i] == nums[i - 1] && nums[i] == nums[i - 2]) {\\n    \\t\\t\\tvector<int>::iterator it = nums.begin() + i;\\n    \\t\\t\\tnums.erase(it);\\n    \\t\\t\\ti--;\\n    \\t\\t}\\n    \\t}\\n    \\treturn nums.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 28142,
                "title": "java-solution-generalized-to-maximal-k-time-occurences",
                "content": "This solution is inspired by @tech-wonderland.net\\n\\nIn this solution, I use a **for** loop instead of a **while** since we know for sure the iteration will end after loop through the array one time.\\n\\n    public class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            return removeDuplicates(nums, 2);\\n        }\\n        \\n        public int removeDuplicates(int[] nums, int k) {\\n            \\n            int len = nums.length, count = 1;\\n            \\n            // j points the position where the next qualified number \\n            // found by i pointer will be written\\n            for ( int i = 1, j = 1; i < nums.length; i++ ) {\\n    \\n                count = (nums[i] != nums[i-1]) ? 1 : count+1;\\n                \\n                if ( count > k ) {\\n                    len--;\\n                } else {\\n                    nums[j++] = nums[i];\\n                }\\n    \\n            }\\n            return len;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int removeDuplicates(int[] nums) {\\n            return removeDuplicates(nums, 2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 28145,
                "title": "iterative-python-solution-o-n-88ms",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def removeDuplicates(self, nums):\\n            n = len(nums)\\n            if n < 3:\\n                return n\\n    \\n            start, tail = 0, 2\\n    \\n            for i in range(2, n):\\n                if nums[i] != nums[tail - 1] or nums[i] != nums[tail - 2]:\\n                    nums[tail] = nums[i]\\n                    tail += 1\\n    \\n            return tail",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 28132,
                "title": "in-place-solution-in-python-for-reference",
                "content": "    class Solution:\\n    # @param A a list of integers\\n    # @return an integer\\n    def removeDuplicates(self, A):\\n        if len(A)==0:\\n            return 0\\n        cur=0\\n        point=0\\n        \\n        while point<len(A):\\n            if point<len(A)-2 and A[point]==A[point+1] and A[point]==A[point+2]:\\n                point=point+1\\n            else:\\n                A[cur]=A[point]\\n                point=point+1\\n                cur=cur+1\\n        \\n        \\n        return cur    \\n            \\n        \\nthis is essentially the same as problem I.only difference is to check if it has more than 3 duplicates",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param A a list of integers\\n    # @return an integer\\n    def removeDuplicates(self, A):\\n        if len(A)==0:\\n            return 0\\n        cur=0\\n        point=0\\n        \\n        while point<len(A):\\n            if point<len(A)-2 and A[point]==A[point+1] and A[point]==A[point+2]:\\n                point=point+1\\n            else:\\n                A[cur]=A[point]\\n                point=point+1\\n                cur=cur+1\\n        \\n        \\n        return cur    \\n            \\n        \\nthis is essentially the same as problem I.only difference is to check if it has more than 3 duplicates",
                "codeTag": "Java"
            },
            {
                "id": 3989902,
                "title": "simple-easy-solution-beats-100",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n        int k = 0, n = arr.size(), i = 0;\\n        while(i<n){\\n            int curr = arr[i];\\n            int cnt = 0;\\n            while(i< n && arr[i] == curr){\\n                cnt++;\\n                i++;\\n            }\\n            if(cnt > 1){\\n                arr[k] = curr;\\n                k++;\\n                arr[k] = curr;\\n                k++;\\n            }\\n            else{\\n                arr[k] = curr;\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& arr) {\\n        int k = 0, n = arr.size(), i = 0;\\n        while(i<n){\\n            int curr = arr[i];\\n            int cnt = 0;\\n            while(i< n && arr[i] == curr){\\n                cnt++;\\n                i++;\\n            }\\n            if(cnt > 1){\\n                arr[k] = curr;\\n                k++;\\n                arr[k] = curr;\\n                k++;\\n            }\\n            else{\\n                arr[k] = curr;\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880642,
                "title": "best-javascript-simple-solution-easy-to-understand-quickly-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nlet temp = nums[0]\\nlet z = 1 \\nlet count = 0\\nfor(let i=1;i<nums.length;i++)\\n{\\n    if(temp!==nums[i])\\n    {  count=0\\n        nums[z] = nums[i]\\n        temp=nums[i]\\n        z++\\n    }\\n    else if(temp == nums[i] && count<1)\\n    {\\n          nums[z] = nums[i]\\n        temp=nums[i]\\n        count ++ \\n        z++\\n    }\\n}\\n\\nreturn z\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function(nums) {\\nlet temp = nums[0]\\nlet z = 1 \\nlet count = 0\\nfor(let i=1;i<nums.length;i++)\\n{\\n    if(temp!==nums[i])\\n    {  count=0\\n        nums[z] = nums[i]\\n        temp=nums[i]\\n        z++\\n    }\\n    else if(temp == nums[i] && count<1)\\n    {\\n          nums[z] = nums[i]\\n        temp=nums[i]\\n        count ++ \\n        z++\\n    }\\n}\\n\\nreturn z\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659959,
                "title": "java-best-solution-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int k = 2;\\n        int count = 1; \\n        int occurrences = 1; \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                occurrences++;\\n            } else {\\n                occurrences = 1;\\n            }\\n            \\n            if (occurrences <= k) {\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) {\\n            return nums.length;\\n        }\\n        int k = 2;\\n        int count = 1; \\n        int occurrences = 1; \\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                occurrences++;\\n            } else {\\n                occurrences = 1;\\n            }\\n            \\n            if (occurrences <= k) {\\n                nums[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629267,
                "title": "python-intuitive-optimal-2-pointers-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 pointers, one goes first to find the next unique element, the slower one waits until the first one find a new element and fill its current position.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate over `nums`, we first set the amount of the number of duplicates for the current element to 2, `cnt_left = 2`. We only do this when we found a new element: `num != nums[j - 1]` or `j == 0`\\n\\nWe then update the slow pointer and reduce the `cnt_left` when:\\n- We need another duplicate: `cnt_left > 0 and num == nums[j - 1]`\\n- New element found: `j == 0` or `num != nums[j - 1]`\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Idea\\n        - Fast pointer go scanning\\n\\n        - Slow pointer only fills the position when: \\n        nums[fast pointer] != nums[slow pointer - 1]\\n\\n        \"\"\"\\n        j = cnt_left = 0\\n        for num in nums:\\n            if j == 0 or num != nums[j - 1]: cnt_left = 2\\n\\n            conditions = [\\n                num == nums[j - 1] and cnt_left > 0,\\n                j == 0,\\n                (num != nums[j - 1])\\n            ]\\n\\n            if any(conditions):\\n                nums[j] = num\\n                j += 1\\n                cnt_left -= 1\\n\\n        return j\\n            \\n\\n\\n\\n                \\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Idea\\n        - Fast pointer go scanning\\n\\n        - Slow pointer only fills the position when: \\n        nums[fast pointer] != nums[slow pointer - 1]\\n\\n        \"\"\"\\n        j = cnt_left = 0\\n        for num in nums:\\n            if j == 0 or num != nums[j - 1]: cnt_left = 2\\n\\n            conditions = [\\n                num == nums[j - 1] and cnt_left > 0,\\n                j == 0,\\n                (num != nums[j - 1])\\n            ]\\n\\n            if any(conditions):\\n                nums[j] = num\\n                j += 1\\n                cnt_left -= 1\\n\\n        return j\\n            \\n\\n\\n\\n                \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627809,
                "title": "simple-solution-java",
                "content": "# Intuition\\nThe given code aims to remove duplicates from an array nums and return the new length of the array.\\n\\n# Approach\\n1) Create a new array n1 with the same length as nums. This array will store the non-duplicate elements.\\n2) Initialize variables c, c1, and n to keep track of counts and the length of the new array.\\n3) Iterate over the elements of nums using the outer for loop.\\n4) Reset c to zero at the beginning of each outer loop iteration. c will count the number of occurrences of the current element.\\n5) Use the inner for loop to iterate over nums and check for occurrences of the current element. Increment c for each occurrence.\\n6) If c is greater than 1, it means the current element is a duplicate.\\n7) Add the current element twice to n1 (to remove duplicates).\\nUpdate c1 and n accordingly.\\n8) If c is 1, it means the current element is not a duplicate.\\nAdd the current element once to n1.\\nUpdate c1 and n accordingly.\\n9) After the loop ends, copy the elements from n1 back to nums.\\nReturn the final count n, representing the new length of the array after removing duplicates.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int [] n1 = new int[nums.length];\\n        int c=0; \\n        int c1=0;      \\n        int n=0;\\n        \\n        for(int i=0;i<nums.length;i+=c){\\n             c=0;    \\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    c+=1;\\n                }                 \\n            }\\n            if(c>1){\\n                n1[c1]=nums[i];\\n                c1++;\\n                n1[c1]=nums[i];\\n                if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n+=2;               \\n            }\\n            else{\\n                n1[c1]=nums[i];\\n                 if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n++;\\n            }          \\n        }   \\n      \\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=n1[i];\\n        }\\n        return n;\\n    }\\n}\\n```\\n\\n**Please upvote if you like my solution!!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int [] n1 = new int[nums.length];\\n        int c=0; \\n        int c1=0;      \\n        int n=0;\\n        \\n        for(int i=0;i<nums.length;i+=c){\\n             c=0;    \\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    c+=1;\\n                }                 \\n            }\\n            if(c>1){\\n                n1[c1]=nums[i];\\n                c1++;\\n                n1[c1]=nums[i];\\n                if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n+=2;               \\n            }\\n            else{\\n                n1[c1]=nums[i];\\n                 if(i!=nums.length-1){\\n                c1++;\\n                }\\n                n++;\\n            }          \\n        }   \\n      \\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=n1[i];\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625795,
                "title": "kotlin-simple-solution-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     fun removeDuplicates(nums: IntArray): Int {\\n        var i = 1\\n        for (k in 2 until nums.size){\\n            if ((nums[k]!= nums[i] || nums[k]!= nums[i-1])){\\n                nums[++i] = nums[k]\\n            }\\n        }\\n        return i+1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n     fun removeDuplicates(nums: IntArray): Int {\\n        var i = 1\\n        for (k in 2 until nums.size){\\n            if ((nums[k]!= nums[i] || nums[k]!= nums[i-1])){\\n                nums[++i] = nums[k]\\n            }\\n        }\\n        return i+1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598061,
                "title": "easy-c-solution-o-n",
                "content": "\\n```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        if (nums.Length <= 2) { // If array length is 2 or less, no duplicates to remove\\n            return nums.Length;\\n        }\\n\\n        int count = 2; // Count of allowed duplicates\\n\\n        for (int i = 2; i < nums.Length; i++) { // Iterate through the array starting from the third element\\n            if (nums[i] != nums[count - 2]) { // If current element is different from element at count-2, it is a non-duplicate\\n                nums[count] = nums[i]; // Overwrite duplicates with non-duplicates\\n                count++; // Increment count of non-duplicates\\n            }\\n        }\\n\\n        return count; // Length of modified array with duplicates removed\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveDuplicates(int[] nums) {\\n        if (nums.Length <= 2) { // If array length is 2 or less, no duplicates to remove\\n            return nums.Length;\\n        }\\n\\n        int count = 2; // Count of allowed duplicates\\n\\n        for (int i = 2; i < nums.Length; i++) { // Iterate through the array starting from the third element\\n            if (nums[i] != nums[count - 2]) { // If current element is different from element at count-2, it is a non-duplicate\\n                nums[count] = nums[i]; // Overwrite duplicates with non-duplicates\\n                count++; // Increment count of non-duplicates\\n            }\\n        }\\n\\n        return count; // Length of modified array with duplicates removed\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571777,
                "title": "combining-both-versions-easy-and-medium-c-o-1-space",
                "content": "Problem 26. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\\n\\n**Code:**\\n\\nTime: **O(N)**\\nSpace: **O(1)**\\n\\n```\\nint removeDuplicates(vector<int>& nums) {\\n        int j=0;                //It keeps track of uniques elements.\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[j]){\\n\\t\\t\\t\\tj++;          // j has the number of unique elements.\\n\\t\\t\\t}      \\n            nums[j]=nums[i];              //replace next place with new number.\\n        }\\n        return j+1;   //Return the number of unique elements +1.\\n    }\\n```\\n\\n\\n\\n\\n\\n\\nProblem 80. [Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)\\n\\n**Code:**\\n\\nTime: **O(N)**\\nSpace: **O(1)**\\n\\n```\\nint removeDuplicates(vector<int>& nums) {\\n      \\n    int count=0;        // Count variable to allow atmost 2 same numbers \\n    int j=0;\\n\\t\\n    for (int i=1;i<nums.size();i++){\\n        if(nums[i]!=nums[j]){            //we have encountered a new unique element.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=0;\\n            j++;                                  \\n        }\\n        else if(nums[i]==nums[j] && count==0){    //We have encountered same element second time.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=1;                     //It is the second element, so made count=1. This count wont be changed until next\\n            j++;                         // unique element is found.\\n        }\\n    }\\n    return j+1;           \\n}\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint removeDuplicates(vector<int>& nums) {\\n        int j=0;                //It keeps track of uniques elements.\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[j]){\\n\\t\\t\\t\\tj++;          // j has the number of unique elements.\\n\\t\\t\\t}      \\n            nums[j]=nums[i];              //replace next place with new number.\\n        }\\n        return j+1;   //Return the number of unique elements +1.\\n    }\\n```\n```\\nint removeDuplicates(vector<int>& nums) {\\n      \\n    int count=0;        // Count variable to allow atmost 2 same numbers \\n    int j=0;\\n\\t\\n    for (int i=1;i<nums.size();i++){\\n        if(nums[i]!=nums[j]){            //we have encountered a new unique element.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=0;\\n            j++;                                  \\n        }\\n        else if(nums[i]==nums[j] && count==0){    //We have encountered same element second time.\\n            nums[j]=nums[i];\\n\\t\\t\\tcount=1;                     //It is the second element, so made count=1. This count wont be changed until next\\n            j++;                         // unique element is found.\\n        }\\n    }\\n    return j+1;           \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3564625,
                "title": "remove-duplicates-from-sorted-array-ii",
                "content": "**Simple** Solution :\\n1. **step1: **pick the first element from the array( hence given minimum length of array is 1).\\n1. step2: count the frequency of element.\\n1. step3: if count==3  remove the element at that index and decrease the count and length of array(because we deleted one element from array). and stay at that index don\\'t increment the index(i) because next element comes to current index when we delete an element at present index).\\n1. \\xA0step4: if new element comes into picture then change pointer(p) to new element and count to 1.\\n1.  step5: return the final length of the array(l).\\n\\n``` \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \\n        l=len(nums)\\n        i=1\\n        p=nums[0]\\n        cou=1\\n        while(i<l):\\n            \\n            if(p==nums[i]):\\n                cou+=1\\n            else:\\n                p=nums[i]\\n                cou=1\\n            if(cou==3):\\n                nums.pop(i)\\n                cou-=1\\n                l-=1\\n                continue\\n            i+=1\\n        return l\\n        \\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        \\n        l=len(nums)\\n        i=1\\n        p=nums[0]\\n        cou=1\\n        while(i<l):\\n            \\n            if(p==nums[i]):\\n                cou+=1\\n            else:\\n                p=nums[i]\\n                cou=1\\n            if(cou==3):\\n                nums.pop(i)\\n                cou-=1\\n                l-=1\\n                continue\\n            i+=1\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545339,
                "title": "simple-two-pointers-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        count = 1\\n        l = 1\\n        for r in range(1, len(nums)):\\n            if nums[r] == nums[r - 1]:\\n                count += 1\\n            else:\\n                count = 1\\n            if count <= 2:\\n                nums[l] = nums[r]\\n                l += 1\\n        return l\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        count = 1\\n        l = 1\\n        for r in range(1, len(nums)):\\n            if nums[r] == nums[r - 1]:\\n                count += 1\\n            else:\\n                count = 1\\n            if count <= 2:\\n                nums[l] = nums[r]\\n                l += 1\\n        return l\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1922539,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1909153,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1566699,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571187,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1861711,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1737474,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571188,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1977434,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1963176,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1568903,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1922539,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1909153,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1566699,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571187,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1861711,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1737474,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1571188,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1977434,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1963176,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1568903,
                "content": [
                    {
                        "username": "christopherblodgett",
                        "content": "Works on my machine. It is the second time I've had their TS behave differently than TS loaded locally. This is frustrating."
                    },
                    {
                        "username": "peterrauscher",
                        "content": "Same with my Pythonic solution. Modifies \"in place\" on my machine, throws a fit on LC interpreter."
                    },
                    {
                        "username": "sanju1819",
                        "content": "!!!!!!!!  SPOILER ALERT  !!!!!\\n\\n\\n\\nJust take 2 variables fast and slow and place at 2nd index and check both are equal or not. If it is equal increase the fast variable else nums[slow++] = nums[fast++].\\n\\nHey! are you thinking it\\'s completed,\\nThink what you have to return and what you have to do if size is less than 2 ?  "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Popping Unwanted Duplicates\n\n  \n**Approach 2:** Overwriting unwanted duplicates\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "heqingy",
                        "content": "The main idea is to use binary search to find the rightmost value that equal to current value. \\n\\nAnd, for the upper bound of search range, we don't need to set it as the end of the array, instead, we can double the length of range each time, until it's unequal to current value."
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "We do not need to do binary search, would make worst case runtime to O(n logn). We can do it in O(n). "
                    },
                    {
                        "username": "farmanmohd124",
                        "content": "can anyone tell me , in this problem the funtion has a return type of int but in output there is vector . why? "
                    },
                    {
                        "username": "CalCreate",
                        "content": "This is because the question is expecting us to get the length of the array if duplicates allowed are at maximum 2. "
                    },
                    {
                        "username": "kumarpranav6409",
                        "content": "it will take vector as output itself ...... for example if you return any integer n then it will take first n indexex of the vector"
                    },
                    {
                        "username": "constablensw",
                        "content": "When I run my Java code in my IDE I get the correct result but when I put it in Leetcode and run it, it gets an incorrect answer on case 2. It says the code outputs [0,0,1,1,1,2,3] instead of [0,0,1,1,2,3,3]. I\\'m stumped. Here\\'s my code. What am I doing wrong?\\nclass Solution {\\n        public int removeDuplicates(int[] nums) {\\n            for(int TR=2; TR < nums.length-1; TR=TR+2){\\n                if(nums[TR]==nums[TR - 1]){\\n                    nums[TR] =  Integer.MAX_VALUE;\\n                    Arrays.sort(nums);\\n                    nums = Arrays.copyOf(nums, nums.length-1);\\n                    TR=TR-2;\\n                }\\n            }\\n            Arrays.sort(nums);\\n         return nums.length;\\n        }\\n}"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "you need to modify in place, so you cant assign."
                    },
                    {
                        "username": "majun8cn",
                        "content": "I submitted an answer based on a new Array B. I scan the Array A and only put the first 1-2 of the same numbers to B. Then copy the B back to A. \\n\\nIt requires O(N) space. Is there any way to solve this question with O(1) space?"
                    },
                    {
                        "username": "annabellejayadinata",
                        "content": "stdout is correct but output is wrong, how to fix?"
                    },
                    {
                        "username": "Adithyang",
                        "content": "I think u need to make changes in the same array and not use a new array as the solution will refer to the original memory "
                    },
                    {
                        "username": "glaucusec",
                        "content": "Guys it\\'s an intersting problem. If you solved the first  part of this question, you can solve this too. My first solution was around 40 lines of code. I was not able to find a better solution on my own. After solving it, you will be amazed how others think and solved this question."
                    },
                    {
                        "username": "hahoney",
                        "content": "The problem is simple but easy to make mistake. It took me three submissions to pass and some time working on the bugs which mainly come from the incorrect index counting. I wonder if there is any efficient way to avoid these mistakes in coding rather than testing. Thanks !"
                    }
                ]
            },
            {
                "id": 1983237,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 1982040,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 1929287,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 1736627,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2075933,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2073357,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2071883,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2065028,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2064125,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2057740,
                "content": [
                    {
                        "username": "andrew_yasinsky",
                        "content": "\" remove some duplicates in-place such that each unique element appears at most twice.\" - this is pidgin English\\n\"remove some duplicates, such unique elements appear twice\"\\n"
                    },
                    {
                        "username": "bullis",
                        "content": "The \"appears at most twice\" part is also important. For example, you could have a valid input array of [1, 2, 2, 2, 3] and 1 should only appear once, while 2 should only appear twice. The problem isn\\'t saying that all numbers must have exactly 2 duplicates, they just can\\'t have more than that. I.e., a number can appear exactly once or exactly twice, but no more."
                    },
                    {
                        "username": "ahmed_hadaka",
                        "content": "Yeh, I fall into this confusion due to this description.\nthe sentence \"at most\" makes you think that we have the choice to convert the duplicated number say, 11111, into 11 OR 1 only but, it will be wrong if you consider only 1."
                    },
                    {
                        "username": "rwoodward1414",
                        "content": "The \"in-place\" part is important though, its a different problem without it."
                    },
                    {
                        "username": "JasonLee242",
                        "content": "I\\'m returning an int k, but keep getting a type error in python. \"expected return type integer[]\"? The heck"
                    },
                    {
                        "username": "aryan-jain",
                        "content": "Were you able to figure out what was happening? I am getting the same error. I even confirmed the type of the return variable is int before returning."
                    },
                    {
                        "username": "Dostler",
                        "content": "how it possible in O(1) ??? U anyway need to iterate at least one time"
                    },
                    {
                        "username": "shubhamtyagi542",
                        "content": "O(1) extra memory, not runtime complexity."
                    },
                    {
                        "username": "p_linganathan",
                        "content": "Easy Solution \\n\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n        if (nums.length <= 2) return nums.length;\\n        int validPos = 0;\\n        int currCount = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n                currCount = nums[validPos] != nums[i] ? 1 : currCount+1;\\n                if (currCount <= 2) nums[++validPos] = nums[i];        \\n        }\\n        return ++validPos;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut what if your easy solution should be placed in Solutions section not Discussions, huh?"
                    },
                    {
                        "username": "leozartino",
                        "content": "non-decreasing order is just a fancy way to say that the array is sorted in ascending order. \\uD83D\\uDE05"
                    },
                    {
                        "username": "harsh_shah25",
                        "content": "if they have mentioned unique elements must come \\'at most twice\\'  then can\\'t we just return an array in which unique elements come only once?\\n"
                    },
                    {
                        "username": "someshthakur90",
                        "content": "why for nums.length == 1, the answer is accepted while i am returning j = 2, i should return 1 though? \npublic int removeDuplicates(int[] nums) {       \n        int j = 2;\n        for(int i = 2; i < nums.length; i++) {\n            if(nums[i]!=nums[j-2])  nums[j++] = nums[i];\n        }\n        return j;\n    } "
                    },
                    {
                        "username": "Elad770",
                        "content": "I have a program problem, after I seem to remove the unnecessary members, at the end of the array, what values exactly should I put in there?\\nI can\\'t technically insert an underscore?\\nIf I enter huge negative values I will get an error, because there is a chance that I will come across an array with such a large number?\\nSo I can\\'t understand what values can be put there?\\nI can\\'t really delete the array? Or you can throw the duplicated values to the end"
                    },
                    {
                        "username": "hongpengwei",
                        "content": "No, just leave the original values. As in only replace those that are needed. For example: [1,1,1,2,2,3,3,4,4,4,5,6] would just be [1,1,2,2,3,3,4,4,5,6], but you leave the original elements so it remains [1,1,2,2,3,3,4,4,5,6,5,6], since you only need replace the first 10 elements. "
                    },
                    {
                        "username": "raaven_4321",
                        "content": "what if some elements doesn\\'t have duplicates? "
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Insert first two elements and then check if the current element is greater than the element that is present at two index apart"
                    }
                ]
            },
            {
                "id": 2056728,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2055605,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2051670,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2050718,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2050414,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2029005,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2020620,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2005189,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2003421,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 2002773,
                "content": [
                    {
                        "username": "Alphaaab",
                        "content": "Hello, if input is [1,1,1] what should the output be? [1] or [1,1]?"
                    },
                    {
                        "username": "raaven_4321",
                        "content": "[1,1]"
                    },
                    {
                        "username": "chaos_adi",
                        "content": "This solution is confusing and not very intuitive. Check out NeetCode\\'s solution"
                    },
                    {
                        "username": "kumudkishor1901",
                        "content": "****Easy Approach beats 100%******\\n-> We will use Two Pointer approach to find the  unique elements.\\n-> and a count variable to keep check of no. of duplicates allowed.\\n-> Firstly we will handle the edge case if array length is less than two then we will return arrays length.\\n-> then we will initialise the variable j with 0.(to handle unique element)\\n->then we will initialise the count variable with 1(  to handle max duplicates allowed)\\n-> then we will run a for loop with variable i  starting from 1 to arr.length\\n-> then we have to check two condition:\\n      -1st -  if arr[i] != arr[j]      else if arr[i] == arr[j] && count < 2\\n-> in first condition we will increment the j and place arr[i] at jth position in the array. after then we will make the count = 1;\\n-> int second condition we will again increment the j and assign j  position with arr[i] and with that we will also increment count by 1;\\n-> and finally we will return ++j;\\n->> our question is solved beating 100% of users across platform...\\n"
                    },
                    {
                        "username": "kopal41",
                        "content": "!!!!!!!!!!!!!!!!!!!!!!Easy to understand solution!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\nJust take a while inside while and run a loop outside to initialize the element of array and inside to match that element to the remaining element.If count is greater than than 1 then increase k 2 times otherwise increase k 1 time."
                    },
                    {
                        "username": "Anu_23_32",
                        "content": "    int removeduplicates(int*a,int n)\n{\n    int index=0;\n    int j,k;\n    int count=1;\n    \n    while(index<n-1)\n    {\n            j=index;\n            count=1;\n            while(a[j]==a[j+1])\n            {\n                count++;\n                j++;\n            }\n            if(count==1)\n            {\n                index=index+1;\n            }\n            else if(count==2)\n            {\n                index=index+2;\n            }\n\n            else if(count>2)\n            {\n                index=index+2;\n           \n                for(k=index;k<n;k++)\n                {\n                    a[k]=a[k+count-2];\n\n                }\n                n=n-(count-2);\n            }\n                 return index+1;\n    }\n\nThis works well in other compilers, but when submitted here it shows address sanitizier error ,Can someone help ."
                    },
                    {
                        "username": "dannydathua",
                        "content": "For some reason, when debugged, my code returns the correct answers. But the test keeps returning something else.\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        mydict ={}\\n\\n        for i in nums:\\n            if i not in mydict:\\n                mydict[i] = 1\\n            else:\\n                mydict[i] = 2  \\n        print(mydict)\\n        nums = []\\n        for key, value in mydict.items():\\n            while value >0:\\n                nums.append(key)\\n                value-=1\\n        print(nums)\\n            \\n        return len(nums)       \\n\\n```\\nstdout right before return statement: \\n{0: 2, 1: 2, 2: 1, 3: 2}\\n[0, 0, 1, 1, 2, 3, 3]\\nexpected output:\\n[0,0,1,1,2,3,3]\\nreturned output: \\n[0,0,1,1,1,1,2]\\n\\n"
                    },
                    {
                        "username": "shahan989",
                        "content": "Good question. Great follow up to its first question."
                    },
                    {
                        "username": "PelegBN",
                        "content": "My answer passes both test cases but fails on submit! How can this be?\\nVery frustrating...\\n\\n"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "Did you check which test case it is failing for? Try your solution with the test case where you have more then one duplicate. i.e. [0,0,0,1,1,1,2,3,3]. Also You should think about some edge cases here. "
                    },
                    {
                        "username": "Suryansh981",
                        "content": "The Simple Approach is to Follow A Two Pointer Approach and keep a counter for the current Num\\n\\n\\n1. Use two pointers: Initialize two pointers, L and R, to keep track of the elements in the list. L points to the last valid position in the deduplicated list, and R moves through the list to find new elements.\\n2. Count occurrences: Use a num_count variable to keep track of the number of occurrences of the current element being considered. When a new element is encountered, reset num_count to 1. If the current element is a duplicate, check if num_count is less than 2 before adding it to the deduplicated list.\\n3. Modify the list in place: Update the elements in the original list to create the deduplicated list. Move the unique elements towards the beginning of the list by updating nums[L] with the value at nums[R] whenever a new valid element is found. The final deduplicated list will be formed up to the L+1 index, and the function should return this length."
                    },
                    {
                        "username": "omega_arpit",
                        "content": "Suggestion : Don\\'t touch first index of the array."
                    }
                ]
            },
            {
                "id": 1994697,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1986159,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1958088,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1932780,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1916491,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1767478,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1754137,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1741175,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1648709,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1709320,
                "content": [
                    {
                        "username": "rwoodward1414",
                        "content": "I solved it but I am not sure I did it a great way. Does anyone know if this is alright or if this problem should be approached a different way?\\n\\nFirst I set a counter to 0, then I have a for loop from 0 to the length of nums. If i is less than the length of nums - 2 then check if nums[i] and nums[i + 2] are not equal and if so, nums[counter] = nums[i]. Otherwise if i >= length - 2 then just nums[counter] = nums[i]."
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "Step 1) Create a variable index=2 and start your for loop from int i=2 till i<nums.size().\\n\\nStep 2) Create if condition for: nums[i]!=nums[index-2] (for the first case we will check if nums[2]!= nums[0]).\\n\\nStep 3) If this condition is satisfied, store value of nums[i] in nums[index] and then increment both i and index.\\n\\nStep 4) If this is not true only i is incremented and the duplicate number at the position of nums[index] will be later replaced with a non-duplicate one through above if condition.\\n\\nStep 5) return index because this will be the length of your required array.\\n"
                    },
                    {
                        "username": "sorandomem",
                        "content": "I tried the following solution, and it works on my machine but not here. Basically, it doesn't properly execute the second for-loop. Am I doing something wrong?\n\n    def removeDuplicates(self, nums: List[int]) -> int:\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i - 1]:\n                nums[i - 1] += 10 ** 5\n        nums = list(set(nums))\n        for i in range(len(nums)):\n            if nums[i] > 10**4:\n                nums[i] -= 10**5\n        nums.sort()\n        return len(nums)"
                    },
                    {
                        "username": "AjaySRa",
                        "content": "[@sorandomem](/sorandomem) I believe you are changing the reference assigned to nums when you write ```nums = list(set(nums))```. This means nums variable will not point to the orignal array passed to the function. \\n\\nSo your original passed array will have the variables updated with the first loop. Then you created a new list. Judging code on the platform will test the original array so tests will fail because original array now looks something like this from [0,1,1,1,2,3] -> [100000, 1, 1, 100001, 100002, 3].\\n\\nYou have to respect the inplace part of the problem and only modify original passed array."
                    },
                    {
                        "username": "Batman910",
                        "content": "Java fastest solution\\n class Solution {\\n    public int removeDuplicates(int[] nums) {\\n        int n = nums.length;\\n        if(n<=2) return 2;\\n        int rc= 0;\\n        int dc = nums[0] == nums[1] ? 2 : 1;\\n        int ci = 2;\\n        int temp;\\n        for(int i=2;i<n;i++){\\n            if(nums[i]== nums[ci-1]){\\n                if(dc >=2){\\n                    continue;\\n                }\\n                temp = nums[ci];\\n                nums[ci] = nums[i];\\n                nums[i]=temp;\\n                ci++;\\n                dc++;\\n                continue;                \\n            }\\n\\n            temp = nums[ci];\\n            nums[ci] = nums[i];\\n            nums[i]=temp;\\n            dc=1;\\n            ci++;\\n\\n\\n        }\\n        return ci;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++) m[nums[i]]++;\\n\\n        int count=0,s=0;\\n        for(auto e:m){\\n            if(e.second>2) count++;\\n            else s+=e.second;\\n        }\\n        int k=count*2;\\n        int v=k+s;\\n        return v;\\n    }\\n};\\n\\nWhat is wrong in my solution?"
                    },
                    {
                        "username": "rohitkaushik70707",
                        "content": "you are just giving the output ,but you have to delete elements from array as well.\\nread the question custom judge part where the expected array output is matched with your output."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/80_Remove_Duplicates_from_Sorted_Array_II.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "bhuvnesh011995",
                        "content": "can anyone tell me where an i mistaken because this code is working fine in vs code but here neither of test case is passed why?\n\nvar removeDuplicates = function(nums) {\n    for(i=0;i<nums.length;i++){\n            let b;\n            let j =i;\n         if(nums[i]==nums[i+2]){\n            for(j;j<nums.length;j++){\n            b =nums[j+3]\n            nums[j+2]=b;\n                if(!nums[nums.length-1]){\n                    nums.length = nums.length-1\n                    i--\n                    break;\n                }}}}return nums;};"
                    },
                    {
                        "username": "sohamdatey",
                        "content": "do not return nums, return count;"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "https://zeroplusfour.com/remove-duplicates-from-sorted-array-ii-leetcode-solution/\\n\\nFull OPTIMAL solution in Java , Python , C++ , C \\n\\nGet all the solution here at :\\nhttps://zeroplusfour.com/leetcode-all-array-solution-list-all-in-one-place/\\n"
                    },
                    {
                        "username": "fudank",
                        "content": "This is very easy question.\\nLet\\'s look at this\\n\\n\\n\\nint removeDuplicates(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=1;\\n    int count=1;\\n    for(int i=1;i<n;i++)\\n    {\\n        if(nums[i]!=nums[i-1])\\n        {\\n            nums[k]=nums[i];\\n            k++;\\n            count=1;\\n        }\\n        else if(count<2){\\n            nums[k]=nums[i];\\n            k++;\\n            count++;\\n        }\\n    }\\n    return k;\\n    }\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are soooooo smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Consecutive Numbers",
        "question_content": "<p>Table: <code>Logs</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| num         | varchar |\n+-------------+---------+\nIn SQL, id is the primary key for this table.\nid is an autoincrement column.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Find all numbers that appear at least three times consecutively.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nLogs table:\n+----+-----+\n| id | num |\n+----+-----+\n| 1  | 1   |\n| 2  | 1   |\n| 3  | 1   |\n| 4  | 2   |\n| 5  | 1   |\n| 6  | 2   |\n| 7  | 2   |\n+----+-----+\n<strong>Output:</strong> \n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\n<strong>Explanation:</strong> 1 is the only number that appears consecutively for at least three times.\n</pre>\n",
        "solutions": [
            {
                "id": 321205,
                "title": "runtime-299-ms-faster-than-94-39",
                "content": "Runtime: 299 ms, faster than 94.39% of MySQL online submissions for Consecutive Numbers.\\nMemory Usage: N/A\\n\\n```\\nselect distinct Num as ConsecutiveNums\\nfrom Logs\\nwhere (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct Num as ConsecutiveNums\\nfrom Logs\\nwhere (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359304,
                "title": "easy-and-simple-solution-using-lead-try-this",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith cte as (\\n    select num,\\n    lead(num,1) over() num1,\\n    lead(num,2) over() num2\\n    from logs\\n\\n)\\n\\nselect distinct num ConsecutiveNums from cte where (num=num1) and (num=num2)\\n```\\n**If U like the solution, Pls Upvote**\\n\\n![cat.png](https://assets.leetcode.com/users/images/cb4680e8-b410-4c2f-a9f7-914b5be19e87_1680183976.0080035.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith cte as (\\n    select num,\\n    lead(num,1) over() num1,\\n    lead(num,2) over() num2\\n    from logs\\n\\n)\\n\\nselect distinct num ConsecutiveNums from cte where (num=num1) and (num=num2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53418,
                "title": "simple-solution",
                "content": "    Select DISTINCT l1.Num from Logs l1, Logs l2, Logs l3 \\n    where l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\n    and l1.Num=l2.Num and l2.Num=l3.Num",
                "solutionTags": [],
                "code": "    Select DISTINCT l1.Num from Logs l1, Logs l2, Logs l3 \\n    where l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\n    and l1.Num=l2.Num and l2.Num=l3.Num",
                "codeTag": "Unknown"
            },
            {
                "id": 237228,
                "title": "my-version-is-more-flexible-we-can-change-3-to-4-or-5-or-10",
                "content": "#### Question\\n```\\n180. Consecutive Numbers\\nMedium\\n\\nSQL Schema\\nTable: Logs\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| id          | int     |\\n| num         | varchar |\\n+-------------+---------+\\nid is the primary key for this table.\\n \\n\\nWrite an SQL query to find all numbers that appear at least three times consecutively.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nLogs table:\\n+----+-----+\\n| id | num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\nOutput: \\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\nExplanation: 1 is the only number that appears consecutively for at least three times.\\n```\\n#### Answer\\n##### Approach1\\n```SQL\\nselect distinct num as consecutiveNums \\nfrom (select num,sum(c) over (order by id) as flag from \\n(select id, num, case when LAG(Num) OVER (order by id)- Num = 0 then 0 else 1 end as c\\nfrom logs) a\\n) b\\ngroup by num,flag\\nhaving count(*) >=3   --(you can change 3 to any number)\\n```\\n\\n##### Approach2\\n```SQL\\nselect distinct num as ConsecutiveNums from\\n(select num, id - row_number() over (order by num, id) rank from logs) a\\ngroup by num,rank\\nhaving count(*) >2\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n180. Consecutive Numbers\\nMedium\\n\\nSQL Schema\\nTable: Logs\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| id          | int     |\\n| num         | varchar |\\n+-------------+---------+\\nid is the primary key for this table.\\n \\n\\nWrite an SQL query to find all numbers that appear at least three times consecutively.\\n\\nReturn the result table in any order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nLogs table:\\n+----+-----+\\n| id | num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\nOutput: \\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\nExplanation: 1 is the only number that appears consecutively for at least three times.\\n```\n```SQL\\nselect distinct num as consecutiveNums \\nfrom (select num,sum(c) over (order by id) as flag from \\n(select id, num, case when LAG(Num) OVER (order by id)- Num = 0 then 0 else 1 end as c\\nfrom logs) a\\n) b\\ngroup by num,flag\\nhaving count(*) >=3   --(you can change 3 to any number)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420941,
                "title": "mysql-2-different-approach-easy-understanding-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**.*\\n______________________\\n\\u2705 **MySQL Code :**\\n***Approach 1:***\\n```\\nSELECT distinct Num as ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```\\n__________________________________\\n***Approach 2***:\\n\\n```\\nSELECT distinct(t1.num) as ConsecutiveNums \\nFROM logs t1, logs t2 , logs t3\\nWHERE t1.id=t2.id+1 AND t2.id=t3.id+1 AND t1.num=t2.num AND t2.num=t3.num\\n```\\n______________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT distinct Num as ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) in (select * from Logs) and (Id + 2, Num) in (select * from Logs)\\n```\n```\\nSELECT distinct(t1.num) as ConsecutiveNums \\nFROM logs t1, logs t2 , logs t3\\nWHERE t1.id=t2.id+1 AND t2.id=t3.id+1 AND t1.num=t2.num AND t2.num=t3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3509769,
                "title": "easy-approach-clear-code-simple-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Easily taking out the distinct num from the table whose occurence >= 3. \\n- To check that consecutively occurence is atleast 3 times, we do it by `creating 3 tables for every other id by +1 increment` & `matching them that they are equal.` \\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT distinct \\n    i1.num as ConsecutiveNums \\nFROM \\n    logs i1,\\n    logs i2,\\n    logs i3\\nWHERE \\n    i1.id=i2.id+1 AND \\n    i2.id=i3.id+1 AND \\n    i1.num=i2.num AND \\n    i2.num=i3.num\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/59140048-d0f2-482b-8ec7-28bbf0126f63_1683741800.9033337.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT distinct \\n    i1.num as ConsecutiveNums \\nFROM \\n    logs i1,\\n    logs i2,\\n    logs i3\\nWHERE \\n    i1.id=i2.id+1 AND \\n    i2.id=i3.id+1 AND \\n    i1.num=i2.num AND \\n    i2.num=i3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53420,
                "title": "solution-with-user-defined-variables",
                "content": "    select DISTINCT num FROM\\n    (select num,\\n    \\tcase \\n    \\t\\twhen @record = num then @count:=@count+1\\n    \\t\\twhen @record <> @record:=num then @count:=1 end as n\\n        from \\n    \\t    Logs ,(select @count:=0,@record:=(SELECT num from Logs limit 0,1)) r\\n    ) a\\n    where a.n>=3",
                "solutionTags": [],
                "code": "    select DISTINCT num FROM\\n    (select num,\\n    \\tcase \\n    \\t\\twhen @record = num then @count:=@count+1\\n    \\t\\twhen @record <> @record:=num then @count:=1 end as n\\n        from \\n    \\t    Logs ,(select @count:=0,@record:=(SELECT num from Logs limit 0,1)) r\\n    ) a\\n    where a.n>=3",
                "codeTag": "Unknown"
            },
            {
                "id": 3824916,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT L1.num  AS ConsecutiveNums FROM Logs L1, \\nLogs L2,Logs L3 WHERE L1.id=L2.id - 1 AND L1.num=L2.num \\nand  L2.id=L3.id-1 and L2.num=L3.num\\n```\\nIF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE!![5kej8w.jpg](https://assets.leetcode.com/users/images/d5520730-3315-4ebe-a865-3a6bd4416173_1690477599.7336297.jpeg)",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT L1.num  AS ConsecutiveNums FROM Logs L1, \\nLogs L2,Logs L3 WHERE L1.id=L2.id - 1 AND L1.num=L2.num \\nand  L2.id=L3.id-1 and L2.num=L3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 700299,
                "title": "faster-than-99-simple-self-join",
                "content": "```\\nselect distinct a.num ConsecutiveNums from \\nlogs a inner join logs b\\non a.id = b.id-1\\ninner join logs c\\non b.id = c.id-1\\nwhere a.num = b.num and b.num = c.num",
                "solutionTags": [],
                "code": "```\\nselect distinct a.num ConsecutiveNums from \\nlogs a inner join logs b\\non a.id = b.id-1\\ninner join logs c\\non b.id = c.id-1\\nwhere a.num = b.num and b.num = c.num",
                "codeTag": "Unknown"
            },
            {
                "id": 213003,
                "title": "",
                "content": "\\u5927\\u6982\\u4EE3\\u7801\\u8FD9\\u6837\\n```\\nselect distinct l1.Num as ConsecutiveNums from Logs l1, Logs l2, Logs l3 where l1.Id = l2.Id + 1 and l2.Id = l3.Id + 1 and l1.Num = l2.Num and l2.Num = l3.Num and l3.Num = l1.Num;\\n```\\n\\u8BB0\\u5F97\\u52A0\\u4E2Adistinct\\uFF0C\\u4E0D\\u52A0\\u5C31\\u4F1A\\u6709\\u91CD\\u590D\\u7684",
                "solutionTags": [],
                "code": "```\\nselect distinct l1.Num as ConsecutiveNums from Logs l1, Logs l2, Logs l3 where l1.Id = l2.Id + 1 and l2.Id = l3.Id + 1 and l1.Num = l2.Num and l2.Num = l3.Num and l3.Num = l1.Num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3214755,
                "title": "180-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we need to identify the rows that have at least two consecutive numbers equal to each other. We can do this by joining the table with itself twice, with the second copy offset by 1 row, and the third copy offset by 2 rows. If the values in the num column match for all three copies, then we have found a row where the number appears at least three times consecutively. We can use the DISTINCT keyword to remove duplicates and the ORDER BY keyword to sort the result table.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nJOIN Logs l2 ON l1.id = l2.id - 1\\nJOIN Logs l3 ON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num;\\n\\n```\\nWe join the table Logs with itself three times, using aliases l1, l2, and l3. We then check that l1.num = l2.num and l2.num = l3.num, meaning that the number in the num column appears at least three times consecutively. We select the num column from the first copy of the table and use the DISTINCT keyword to remove duplicates.\\n```\\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\n\\n```\\nIn this case, the only number that appears at least three times consecutively is 1.",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nJOIN Logs l2 ON l1.id = l2.id - 1\\nJOIN Logs l3 ON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num;\\n\\n```\n```\\n+-----------------+\\n| ConsecutiveNums |\\n+-----------------+\\n| 1               |\\n+-----------------+\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53439,
                "title": "an-ugly-solution",
                "content": "`select distinct(a.Num) from Logs a, Logs b,Logs c where a.Id=b.Id+1 and a.Num=b.Num and b.Id=c.Id+1 and b.Num=c.Num`",
                "solutionTags": [],
                "code": "`select distinct(a.Num) from Logs a, Logs b,Logs c where a.Id=b.Id+1 and a.Num=b.Num and b.Id=c.Id+1 and b.Num=c.Num`",
                "codeTag": "Unknown"
            },
            {
                "id": 410442,
                "title": "sql-server-91-faster-using-lead",
                "content": "```\\nselect distinct x.num as ConsecutiveNums\\nfrom\\n(\\nselect num,\\nLEAD(num, 1) over(order by id) as next_num,\\nLEAD(num, 2) over(order by id) as next_next_num\\nfrom logs\\n) x\\nwhere x.num = x.next_num \\nand x.num = x.next_next_num\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct x.num as ConsecutiveNums\\nfrom\\n(\\nselect num,\\nLEAD(num, 1) over(order by id) as next_num,\\nLEAD(num, 2) over(order by id) as next_next_num\\nfrom logs\\n) x\\nwhere x.num = x.next_num \\nand x.num = x.next_next_num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53447,
                "title": "simple-sql-with-join-1484-ms",
                "content": "    select distinct l1.num\\n    from Logs l1 \\n        join Logs l2 on l1.id=l2.id-1 \\n        join Logs l3 on l1.id=l3.id-2\\n    where l1.num=l2.num and l2.num=l3.num",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    select distinct l1.num\\n    from Logs l1 \\n        join Logs l2 on l1.id=l2.id-1 \\n        join Logs l3 on l1.id=l3.id-2\\n    where l1.num=l2.num and l2.num=l3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 1186678,
                "title": "easy-solution-can-be-extended-to-n-consecutive-numbers",
                "content": "This solution is the variation from https://leetcode.com/problems/consecutive-numbers/discuss/237228/My-version-is-more-flexible.-We-could-change-3-to-4-or-5-or-10\\n\\nThe solution provided was brilliant but no longer works in the latest tests because of UNSIGNED BIGINT OUT OF RANGE. This is caused by the negative results from the calculation of `id - row_number()`. By default, row_number() returns a number that is stored in UNSIGNED format, making the calculation result stored in UNSIGNED as well. This will encounter an error when a negative number is passed. (Actually there\\'s a more complex logic to convert them automatically)\\n\\nYou may not expect that `SELECT CAST(-1 AS UNSIGNED)` yields 18446744073709551615 , right? Always be careful when calculating numbers between UNSIGNED and SIGNED!!! Try to manually cast them into the same type before processing.\\n\\n```\\nselect\\n    distinct num as ConsecutiveNums \\nfrom \\n(\\n    select \\n        num, \\n        id - cast(row_number() over (order by num, id) as SIGNED) as rk \\n    from \\n        logs\\n) diff_grp\\ngroup by \\n    num,rk\\nhaving \\n    count(*) >= 3\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    distinct num as ConsecutiveNums \\nfrom \\n(\\n    select \\n        num, \\n        id - cast(row_number() over (order by num, id) as SIGNED) as rk \\n    from \\n        logs\\n) diff_grp\\ngroup by \\n    num,rk\\nhaving \\n    count(*) >= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53460,
                "title": "accepted-solution-without-joins-works-in-n-consecutive-cases-with-slight-modification",
                "content": "    select distinct Num from (\\n        select\\n            Num,\\n            case\\n                when @prevNum = Num then @count := @count + 1\\n                when (@prevNum := Num) is not null then @count := 1\\n            end n\\n        from Logs, (select @prevNum := NULL) r\\n        order by Id\\n    ) a where n >= 3",
                "solutionTags": [],
                "code": "    select distinct Num from (\\n        select\\n            Num,\\n            case\\n                when @prevNum = Num then @count := @count + 1\\n                when (@prevNum := Num) is not null then @count := 1\\n            end n\\n        from Logs, (select @prevNum := NULL) r\\n        order by Id\\n    ) a where n >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 2243677,
                "title": "a-clean-solution-using-ctes-and-analytical-functions-mssql",
                "content": "```\\nWITH LogDetails AS (\\n    SELECT LAG(num) OVER (ORDER BY id) AS PrevNum\\n        ,num AS CurrentNum\\n        ,LEAD(num) OVER (ORDER BY id) AS NextNum\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT CurrentNum AS ConsecutiveNums\\nFROM LogDetails\\nWHERE (PrevNum = CurrentNum\\n      AND CurrentNum = NextNum)\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nWITH LogDetails AS (\\n    SELECT LAG(num) OVER (ORDER BY id) AS PrevNum\\n        ,num AS CurrentNum\\n        ,LEAD(num) OVER (ORDER BY id) AS NextNum\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT CurrentNum AS ConsecutiveNums\\nFROM LogDetails\\nWHERE (PrevNum = CurrentNum\\n      AND CurrentNum = NextNum)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 997112,
                "title": "mysql-gaps-and-islands-problem-bigint-unsigned-value-is-out-of-range",
                "content": "This problem can be categorized as a gaps-and-islands problem.\\n\\nThe only issue is that there are test cases having id starts with 0 and that caused the error \"BIGINT UNSIGNED value is out of range\" which can be resolved by casting the row_number as signed. The cause of the error is \"Subtraction between integer values, where one is of type UNSIGNED, produces an unsigned result by default.\"\\n```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    id,\\n    num,\\n    id - cast(row_number() over (partition by num order by id) as signed) as gp\\n    from Logs\\n) t\\ngroup by num, gp\\nhaving count(id) >= 3\\n```\\n\\nOther ways of solving this problem includes,\\nself join:\\n```\\n# Write your MySQL query statement below\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere\\na.Num = b.Num\\nand a.Num = c.Num\\nand a.Id = b.Id + 1\\nand a.Id = c.Id + 2\\n```\\n\\nLAG() / LEAD():\\n```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    num,\\n    lag(num) over (order by id) as ec,\\n    lag(num, 2) over (order by id) as rd\\n    from Logs\\n) a\\nwhere\\nnum = ec\\nand num = rd\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    id,\\n    num,\\n    id - cast(row_number() over (partition by num order by id) as signed) as gp\\n    from Logs\\n) t\\ngroup by num, gp\\nhaving count(id) >= 3\\n```\n```\\n# Write your MySQL query statement below\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere\\na.Num = b.Num\\nand a.Num = c.Num\\nand a.Id = b.Id + 1\\nand a.Id = c.Id + 2\\n```\n```\\n# Write your MySQL query statement below\\nselect distinct\\nnum as ConsecutiveNums \\nfrom (\\n    select \\n    num,\\n    lag(num) over (order by id) as ec,\\n    lag(num, 2) over (order by id) as rd\\n    from Logs\\n) a\\nwhere\\nnum = ec\\nand num = rd\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548839,
                "title": "3-solutions-compared-performance-and-readability",
                "content": "# Option 1: Derived table\\n```\\nselect\\n    distinct num as ConsecutiveNums\\nfrom\\n    (\\n        select\\n            *\\n            , lag(num, 1) over (order by id) as prev\\n            , lead(num, 1) over (order by id) as next\\n        from\\n            logs\\n    ) t -- every derived table must have its own alias\\nwhere\\n    num = prev and num = next\\n\\n```\\n- Performance: This option uses window functions to compare the current row with the previous and next rows. Window functions can be efficient, but the performance can be influenced by the size of the logs table and the ordering requirements. It\\'s important to ensure appropriate indexes are in place to support the window functions and sorting.\\n\\n- Readability: This option utilizes the power of window functions to compare consecutive rows. It expresses the logic succinctly, making it easier to understand for developers familiar with window functions. However, for those less familiar with window functions, the syntax and the concept of lag and lead functions might require some understanding.\\n\\n# Option 2: Joins\\n```\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom \\n    logs l1 \\ninner join \\n    logs l2 \\non l1.id = l2.id + 1 and l1.num = l2.num \\ninner join logs l3 \\non l2.id = l3.id + 1 and l2.num = l3.num\\n```\\n- Performance: This option uses self-joins to compare consecutive rows based on the `id` and `num` columns. The performance can depend on the size of the `logs` table and the presence of appropriate indexes on the `id` and `num` columns. Joins can be efficient, but it\\'s crucial to ensure the indexes are optimized.\\n- Readability: This option expresses the logic using self-joins, which can be more familiar to developers with SQL background. The joins represent the consecutive row comparison, and the logic is relatively straightforward to follow.\\n\\n# Option 3: Implicit Joins\\n```\\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n\\n```\\n- Performance: This option uses implicit joins in the WHERE clause to compare consecutive rows based on the `id` and `num` columns. The performance can depend on the size of the `logs` table and the presence of appropriate indexes. Similar to Option 2, it\\'s important to optimize the indexes for better performance.\\n- Readability: Implicit joins can be less readable compared to explicit joins. While the logic is expressed using simple comparisons in the WHERE clause, it might require careful examination to understand the relationship between the joins and the consecutive row comparison.\\n\\n# Conclusion:\\n\\n- If performance is a top priority, Option 1 (Derived Table) is likely to perform well, especially if appropriate indexes are in place. Window functions can be efficient for comparing consecutive rows.\\n- If readability is a priority, Option 2 (Joins) might be the preferred choice. Self-joins are more familiar to SQL developers and can be easier to understand.\\n- Option 3 (Implicit Joins) may be less preferred in terms of readability due to the implicit nature of the joins.\\n\\nIt\\'s important to benchmark and test the performance of these options with your specific dataset and workload to determine the best-performing option in your environment. Unfortunately, leetcode runtime does not provide fair time, and is not supposed to used as such metric.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    distinct num as ConsecutiveNums\\nfrom\\n    (\\n        select\\n            *\\n            , lag(num, 1) over (order by id) as prev\\n            , lead(num, 1) over (order by id) as next\\n        from\\n            logs\\n    ) t -- every derived table must have its own alias\\nwhere\\n    num = prev and num = next\\n\\n```\n```\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom \\n    logs l1 \\ninner join \\n    logs l2 \\non l1.id = l2.id + 1 and l1.num = l2.num \\ninner join logs l3 \\non l2.id = l3.id + 1 and l2.num = l3.num\\n```\n```\\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2654155,
                "title": "mysql-lag-and-lead-window-functions",
                "content": "```\\nselect distinct t.num as ConsecutiveNums\\nfrom (\\n    select\\n        lag(num) over (order by id) as prev_num,\\n        num,\\n        lead(num) over (order by id) as next_num\\n    from Logs\\n) t\\nwhere t.num = t.prev_num and t.num = t.next_num;\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct t.num as ConsecutiveNums\\nfrom (\\n    select\\n        lag(num) over (order by id) as prev_num,\\n        num,\\n        lead(num) over (order by id) as next_num\\n    from Logs\\n) t\\nwhere t.num = t.prev_num and t.num = t.next_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399362,
                "title": "simple-mysql-solution",
                "content": "Let\\'s take the same example, \\nLogs table:\\n+----+-----+\\n| Id | Num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\n\\nwe need to find all numbers that appear at least  three times **consecutively**\\nSo we need to have records as (Id, x) , (Id+1, x), (Id+2, x) where x is the same number. \\nIn above example we have \\'1\\' which full fills this condition. There exist (Id, num) pair for 1 as (1, 1) , (2, 1) , (3,1) \\n\\nIn the query the pair of Next Id and Same num will get searched in next result set.\\nso the query actually searching, (Id+1, num) and (Id+2, num) in whole resultset. as it should not print same number everytime, we are using distinct.\\n\\n```\\nselect distinct Num as ConsecutiveNums from Logs\\nwhere (Id+1,Num) in (Select * from Logs) and (ID+2, Num) in (Select * from Logs)",
                "solutionTags": [],
                "code": "Let\\'s take the same example, \\nLogs table:\\n+----+-----+\\n| Id | Num |\\n+----+-----+\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\n+----+-----+\\n\\nwe need to find all numbers that appear at least  three times **consecutively**\\nSo we need to have records as (Id, x) , (Id+1, x), (Id+2, x) where x is the same number. \\nIn above example we have \\'1\\' which full fills this condition. There exist (Id, num) pair for 1 as (1, 1) , (2, 1) , (3,1) \\n\\nIn the query the pair of Next Id and Same num will get searched in next result set.\\nso the query actually searching, (Id+1, num) and (Id+2, num) in whole resultset. as it should not print same number everytime, we are using distinct.\\n\\n```\\nselect distinct Num as ConsecutiveNums from Logs\\nwhere (Id+1,Num) in (Select * from Logs) and (ID+2, Num) in (Select * from Logs)",
                "codeTag": "Unknown"
            },
            {
                "id": 1720116,
                "title": "best-practice-for-row-number-and-subqueries",
                "content": "The solution may looks intimidating, but **the logic is very simple.**\\nIt is definitely **great** for anyone wants to practice the logic of using Window Function, RowNumber() and subqueries\\n\\n## Solution\\n``` \\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\n\\tFROM (\\n\\t\\tSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n\\t)T\\n\\tGROUP BY num, ConsecutiveGroup\\n\\tHAVING COUNT(1) >= 3\\n```\\n\\n## Explanation\\n### Let\\'s dive to the deepest nested subquery\\n```\\nSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n```\\nThis part\\n```\\nROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n```\\nmay be the most difficult part to understand\\n\\n![image](https://assets.leetcode.com/users/images/7dc764cb-d1d3-422e-bc71-2df5323e9118_1643164851.0240996.png)\\n\\nUsing the example provided in the question\\n\\nOn this image, notice that third column, row_number(), is as expected just producing the row index, which is the same value as id.\\n\\nHowever, one thing to notice is that the **order of id changes**, id 5 and id 4\\'s positions are exchanged. This is due to the last colum\\'s ```Partition By num```. ```Partition By``` works like ```Group By```, but display all the records and the record in the same group are displayed together. Therefore, to make sure all the 1s are displayed together, id 5 and id 4 are exchanged. Since we have also included ```order by id```, then in every group, the ids should be in ascending order.\\n\\nYou may wonder \"What\\'s the matter about the grouping with partition by? Isn\\'t every same number put in the same group, how can we find consecutive ones?\" \\n\\n**Note that your row number of the nums does not change** \\n\\nWhen you do a subtraction, you\\'ll see\\n![image](https://assets.leetcode.com/users/images/f6786f16-aace-41f6-884a-5305df029fd3_1643164944.063975.png)\\n\\nHey, those consecutive number have the same value(look at the 1s at the top and 2s at the bottom)\\n\\n#### Why those consecutive number have the same value?\\nNote that the first row_number() gives a row value to the nums, the second partition by in the row_number also gives a row value to the nums. The second row value increment 1 as id increases, no matter the value is consecutive or not. The first value increment 1 only if the nums are consecutive. If your nums are consecutive, then both value increment 1, thus the **difference is always the same**!\\n\\n### For the result of the query\\nYou are basically only grabing the part where values in the third column, \\'ConsecutiveGroup\\' or ```ROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) ``` that are same and count for the number of consecutive value you want.\\n\\n## Comment Below if You have any question or confusion!!!\\n\\nThis solution is inspired by [@neilsons](https://leetcode-cn.com/u/neilsons/)",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "``` \\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\n\\tFROM (\\n\\t\\tSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n\\t)T\\n\\tGROUP BY num, ConsecutiveGroup\\n\\tHAVING COUNT(1) >= 3\\n```\n```\\nSELECT id, num, \\n\\t\\t\\t\\tROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n\\t\\tFROM Logs\\n```\n```\\nROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) as \\'ConsecutiveGroup\\'\\n```\n```Partition By num```\n```Partition By```\n```Group By```\n```order by id```\n```ROW_NUMBER() OVER (ORDER BY id) \\n\\t\\t\\t\\t- ROW_NUMBER() OVER (PARTITION BY num ORDER BY id) ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484648,
                "title": "three-lines-solution-easy-to-understand",
                "content": "```\\nselect distinct num as \\'ConsecutiveNums\\' from logs m\\nwhere num = (select num from logs x where x.id=m.id+1)\\nand num = (select num from logs x where x.id=m.id+2);\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nselect distinct num as \\'ConsecutiveNums\\' from logs m\\nwhere num = (select num from logs x where x.id=m.id+1)\\nand num = (select num from logs x where x.id=m.id+2);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261534,
                "title": "mysql-self-join-easy-and-simple",
                "content": "```\\nselect distinct a.num as consecutivenums from logs a,logs b,logs c where a.num=b.num and b.num=c.num AND \\nb.id-a.id=1 and c.id-b.id=1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a.num as consecutivenums from logs a,logs b,logs c where a.num=b.num and b.num=c.num AND \\nb.id-a.id=1 and c.id-b.id=1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 795404,
                "title": "a-general-solution-for-consecutive-problems",
                "content": "Posted solutions are very nice for 3 consecutive number. However, when the consecutive number becomes higher, for example 5, it become too much trouble to put 5 tables in the where clause.\\n\\nBelow is a code inspired by niradranjan\\' s solution on question #1454. It could work for any number of consecutive number.\\n\\n```\\nselect distinct l1.num consecutivenums\\nfrom logs l1, logs l2\\nwhere l1.num = l2.num and (l2.id-l1.id) between 0 and 2\\ngroup by l1.num, l1.id\\nhaving count(distinct l2.id) =3\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct l1.num consecutivenums\\nfrom logs l1, logs l2\\nwhere l1.num = l2.num and (l2.id-l1.id) between 0 and 2\\ngroup by l1.num, l1.id\\nhaving count(distinct l2.id) =3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53467,
                "title": "explanation-of-consecutive-numbers-problems",
                "content": "    select distinct r.num  from \\n        (select num,\\n            case when @last = num then @count:=@count+1\\n                when @last<>@last:=num then @count:=1\\n                end as n\\n            from Logs\\n        ) r ,(select @count:=0,@last:=(select num from Logs limit 0,1)) temp\\n    where r.n>=3\\n\\nIn MYSQL , The execution order is : *from \\u2014\\u2014> select  \\u2014\\u2014> where \\u2014\\u2014>group by \\u2014\\u2014> order by*  ,\\n\\nin this case , we initialize two variables in *from* clause , then when our *database engine* scan the table row by row ,we change the two variables , when it meet the condition in *where* clause , we keep it !   That is the logic",
                "solutionTags": [],
                "code": "    select distinct r.num  from \\n        (select num,\\n            case when @last = num then @count:=@count+1\\n                when @last<>@last:=num then @count:=1\\n                end as n\\n            from Logs\\n        ) r ,(select @count:=0,@last:=(select num from Logs limit 0,1)) temp\\n    where r.n>=3\\n\\nIn MYSQL , The execution order is : *from \\u2014\\u2014> select  \\u2014\\u2014> where \\u2014\\u2014>group by \\u2014\\u2014> order by*  ,\\n\\nin this case , we initialize two variables in *from* clause , then when our *database engine* scan the table row by row ,we change the two variables , when it meet the condition in *where* clause , we keep it !   That is the logic",
                "codeTag": "Unknown"
            },
            {
                "id": 3516976,
                "title": "easy-solution-with-join-and-distinct",
                "content": "# code\\n\\n```sql\\nSELECT\\n    DISTINCT(l1.num) AS ConsecutiveNums\\n\\nFROM\\n    logs l1, logs l2, logs l3\\n\\nWHERE\\n    l1.id = l2.id + 1 AND\\n    l2.id = l3.id + 1 AND\\n    l1.num = l2.num AND\\n    l2.num = l3.num\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```sql\\nSELECT\\n    DISTINCT(l1.num) AS ConsecutiveNums\\n\\nFROM\\n    logs l1, logs l2, logs l3\\n\\nWHERE\\n    l1.id = l2.id + 1 AND\\n    l2.id = l3.id + 1 AND\\n    l1.num = l2.num AND\\n    l2.num = l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2451973,
                "title": "solution-with-proper-explanation-easy-to-understand",
                "content": "**Please Press Star ^ above**\\n\\nHere We Use JOIN two time\\n\\nFirst Time to check if first Consecutive number is coming above second Consecutive and same value.\\n```\\n a.id=b.id+1 AND a.num=b.num\\n```\\nSecond Time to check if first Consecutive number is coming above Third Consecutive and same value.\\n```\\na.id=c.id+2 AND a.num=c.num\\n```\\n**Code**\\n\\n```\\nSELECT DISTINCT a.num AS ConsecutiveNums \\nFROM Logs a \\nJOIN Logs b ON a.id=b.id+1 AND a.num=b.num\\nJOIN Logs c ON a.id=c.id+2 AND a.num=c.num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n a.id=b.id+1 AND a.num=b.num\\n```\n```\\na.id=c.id+2 AND a.num=c.num\\n```\n```\\nSELECT DISTINCT a.num AS ConsecutiveNums \\nFROM Logs a \\nJOIN Logs b ON a.id=b.id+1 AND a.num=b.num\\nJOIN Logs c ON a.id=c.id+2 AND a.num=c.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1696606,
                "title": "easiest-solution-simple",
                "content": "if you like it pls upvote\\n\\njust check three items , if they are in the order and their nums equal eachother just add to result.\\n\\n\\n```\\nSelect DISTINCT l1.Num  as ConsecutiveNums from Logs l1, Logs l2, Logs l3 \\nwhere l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\nand l1.Num=l2.Num and l2.Num=l3.Num\\n```",
                "solutionTags": [],
                "code": "```\\nSelect DISTINCT l1.Num  as ConsecutiveNums from Logs l1, Logs l2, Logs l3 \\nwhere l1.Id=l2.Id-1 and l2.Id=l3.Id-1 \\nand l1.Num=l2.Num and l2.Num=l3.Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1292939,
                "title": "mysql-simple-solution-use-lag",
                "content": "```\\nselect distinct Num as ConsecutiveNums\\nfrom (select Num, lag (Num, 1) over (order by id) as Num1, \\n\\tlag (Num, 2) over (order by id) as Num2\\n\\tfrom Logs) as sub\\nwhere Num = Num1 and Num1 = Num2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct Num as ConsecutiveNums\\nfrom (select Num, lag (Num, 1) over (order by id) as Num1, \\n\\tlag (Num, 2) over (order by id) as Num2\\n\\tfrom Logs) as sub\\nwhere Num = Num1 and Num1 = Num2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1255565,
                "title": "mysql-simple-easy-with-lead-and-lag",
                "content": "```\\n# Write your MySQL query statement below\\nselect \\n   distinct num ConsecutiveNums \\nfrom \\n    (select \\n        id,num,lead(num) over(order by id) leadnum,lag(num) over(order by id) pnum\\n    from\\n        logs\\n    order by id)a\\nwhere num=leadnum and leadnum=pnum\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n   distinct num ConsecutiveNums \\nfrom \\n    (select \\n        id,num,lead(num) over(order by id) leadnum,lag(num) over(order by id) pnum\\n    from\\n        logs\\n    order by id)a\\nwhere num=leadnum and leadnum=pnum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 420588,
                "title": "simple-solution-mysql",
                "content": "SELECT DISTINCT l.num as ConsecutiveNums\\nFROM logs l \\nWHERE (l.id-1) IN (SELECT id FROM logs WHERE num=l.num)\\nAND (l.id+1) IN (SELECT id FROM logs WHERE num=l.num)",
                "solutionTags": [],
                "code": "SELECT DISTINCT l.num as ConsecutiveNums\\nFROM logs l \\nWHERE (l.id-1) IN (SELECT id FROM logs WHERE num=l.num)\\nAND (l.id+1) IN (SELECT id FROM logs WHERE num=l.num)",
                "codeTag": "Unknown"
            },
            {
                "id": 3370881,
                "title": "use-lead-and-lag-windows-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nM1: Using LEAD\\n```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as one_jump_num,\\n    lead(num, 2) over (order by id) as two_jump_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.one_jump_num and temp.num = temp.two_jump_num;\\n```\\n\\nM2: Using LEAD and LAG\\n```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as next_num,\\n    lag(num) over (order by id) as prev_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.next_num and temp.num = temp.prev_num;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as one_jump_num,\\n    lead(num, 2) over (order by id) as two_jump_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.one_jump_num and temp.num = temp.two_jump_num;\\n```\n```\\nselect distinct temp.num as consecutiveNums \\nfrom (\\n    select num, lead(num) over (order by id) as next_num,\\n    lag(num) over (order by id) as prev_num\\n    from logs\\n) as temp\\nwhere temp.num = temp.next_num and temp.num = temp.prev_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3097822,
                "title": "easy-simple-solution-using-window-function-lead-and-lag",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM\\n    (\\n    SELECT num,LEAD(num) OVER(ORDER BY id) AS \\'lead\\', LAG(num) OVER (ORDER BY id)           AS     \\'lag\\'\\n    FROM logs\\n    )t\\nWHERE t.num=t.lead and t.num=t.lag;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM\\n    (\\n    SELECT num,LEAD(num) OVER(ORDER BY id) AS \\'lead\\', LAG(num) OVER (ORDER BY id)           AS     \\'lag\\'\\n    FROM logs\\n    )t\\nWHERE t.num=t.lead and t.num=t.lag;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971912,
                "title": "easy-to-follow-solution-with-explanation-window-functions",
                "content": "**Runtime**: 426 ms, faster than 81.70% of MySQL online submissions\\n\\n**Solution**: \\n```sql\\nWITH logs_lag_lead AS (\\n    SELECT\\n        id,\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS lag_num,\\n        LEAD(num) OVER (ORDER BY id) AS lead_num\\n    FROM Logs)\\n\\nSELECT DISTINCT(num) AS \\'ConsecutiveNums\\'\\nFROM logs_lag_lead\\nWHERE num = lag_num AND num = lead_num;\\n```\\n\\n**Explanation**:\\n\\nThis solution uses the `LAG()` and `LEAD()` window functions. As the name suggests, the `LAG` function has the ability to fetch data from a previous row, while `LEAD` fetches data from a subsequent row. You can visit [this website](https://www.mssqltips.com/sqlservertutorial/9127/sql-server-window-functions-lead-and-lag/) if you want to know more.\\n\\nFirst, we create a Common Table Expression (CTE) named `logs_lag_lead`. This CTE retrieves the `id` and `num` columns from the `Logs` table along with two new columns:\\n\\n- `lag_num`, which stores the preceding number (if one exists, else `null`), and\\n- `lead_num`, which stores the succeeding number (if one exists, else `null`).\\n\\nThe contents of the cte are shown below:\\n\\n![image](https://assets.leetcode.com/users/images/c2e62932-4a50-49f8-bded-cd88c5d05666_1650615007.1811059.png)\\n\\nNotice that when we have three consecutive numbers (first three rows, marked by the red rectangle), the row corresponding to the middle number will have an equal value for `num`, `lag_num`, and `lead_num` (marked by the blue rectangle). That\\'s because these two window functions retrieve the previous and following row values that are equal to `num`. \\n\\nWe finalise our solution by writing a simple query that contains the condition `num = lag_num AND num = lead_num` in the `WHERE` clause. Notice that we need to retrieve distinct rows. That\\'s because there might be more than three consecutive numbers; in that case, all middle rows will satisfy the `WHERE` condition, and the query will return the same number multiple times.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nWITH logs_lag_lead AS (\\n    SELECT\\n        id,\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS lag_num,\\n        LEAD(num) OVER (ORDER BY id) AS lead_num\\n    FROM Logs)\\n\\nSELECT DISTINCT(num) AS \\'ConsecutiveNums\\'\\nFROM logs_lag_lead\\nWHERE num = lag_num AND num = lead_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1698703,
                "title": "faster-than-96-mysql-solution",
                "content": "```\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM \\n(SELECT id,\\nnum,\\nLAG(num, 1) OVER(ORDER BY id) AS x,\\nLAG(num, 2) OVER(ORDER BY id) AS y \\nFROM Logs \\nORDER BY id) A WHERE A.num=A.x AND A.x=A.y AND A.num=A.y;\\n",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM \\n(SELECT id,\\nnum,\\nLAG(num, 1) OVER(ORDER BY id) AS x,\\nLAG(num, 2) OVER(ORDER BY id) AS y \\nFROM Logs \\nORDER BY id) A WHERE A.num=A.x AND A.x=A.y AND A.num=A.y;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1648643,
                "title": "easy-mysql-solution",
                "content": "Here is my simple yet effective MySQL Solution:\\n```\\n# Write your MySQL query statement below\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM Logs\\nWHERE ((id+1, num) IN (SELECT id,num FROM Logs) AND\\n(id+2, num) in (SELECT id, num FROM Logs));\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT(num) AS ConsecutiveNums FROM Logs\\nWHERE ((id+1, num) IN (SELECT id,num FROM Logs) AND\\n(id+2, num) in (SELECT id, num FROM Logs));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444382,
                "title": "window-function-with-partition-flexible-with-any-consecutive-numbers",
                "content": "# **Solution 1: Use Window function, Partition by and order by**\\n\\n```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # need to cast signed as the math operation result can be negative. SQL will fail with BIGINT error\\n        Cast( id as SIGNED) - cast( row_number() over (partition by num order by id) as signed) as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```\\n\\n # **Solution 2: Multiple by 1.0 to float to avoid the bigINT error**\\n```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # multiple by 1.0 to float to avoid the bigINT error\\n        id*1.0 - row_number() over (partition by num order by id)*1.0 as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```\\n\\n# **Problem Solving Process**\\nThis is the problem\\n![image](https://assets.leetcode.com/users/images/6eb3c961-7109-489b-8cd0-1752f369af96_1630774962.319755.png)\\n\\nWe partition the data by Nums and order by Id to get the row_number(). Then we calculate the difference between the id and row_number() to define as the new_group. \\n![image](https://assets.leetcode.com/users/images/188b2519-66a4-4c46-adfa-f5acee3cc033_1630774936.7532938.png)\\n\\nWe group by Nums and new_group and calcuate the count. We filter out the count >= number ( 3 in this problem)\\n![image](https://assets.leetcode.com/users/images/2ff1390a-9bfc-4f3b-aa38-e07fda3de015_1630775196.275442.png)\\n\\n# **Similar Problems**\\n1. 603. Consecutive Available Seats ( Easy )\\n2. 1811. Find Interview Candidates ( Medium )",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # need to cast signed as the math operation result can be negative. SQL will fail with BIGINT error\\n        Cast( id as SIGNED) - cast( row_number() over (partition by num order by id) as signed) as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```\n```\\nselect distinct num as ConsecutiveNums \\nfrom (\\n    select \\n        num, \\n        # multiple by 1.0 to float to avoid the bigINT error\\n        id*1.0 - row_number() over (partition by num order by id)*1.0 as new_group\\n    from logs\\n    ) a\\ngroup by num,new_group\\nhaving count(*) >=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696618,
                "title": "distinct-lead-solution",
                "content": "```\\nSELECT DISTINCT Num0 AS ConsecutiveNums FROM(\\n    SELECT \\n      Num AS Num0,\\n      LEAD(Num, 1) OVER() AS Num1,\\n      LEAD(Num, 2) OVER() AS Num2\\n    FROM Logs\\n) Consecutive\\nWHERE Num0 = Num1 AND Num1 = Num2\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT Num0 AS ConsecutiveNums FROM(\\n    SELECT \\n      Num AS Num0,\\n      LEAD(Num, 1) OVER() AS Num1,\\n      LEAD(Num, 2) OVER() AS Num2\\n    FROM Logs\\n) Consecutive\\nWHERE Num0 = Num1 AND Num1 = Num2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53458,
                "title": "be-sure-to-use-order-by-id",
                "content": "There is a hidden trap: there is no default record ordering in mysql. So if we say \"numbers that appear at least three times consecutively.\", we better to add \"order by id\" here.\\n\\n[http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries][1]\\n\\nMy solution:\\n\\n    select 0 Num from dual where (@pre := null) is null and (@count := 1) is null\\n        union all\\n    select distinct t.Num from (select * from Logs order by Id) t\\n    where (@count := if(@pre = t.Num, @count + 1, 1)) > -1 and (@pre := t.Num) is not null and @count = 3\\n        union all\\n    select 0 from dual where (@pre := null) is null and (@count := null) is not null;\\n\\n  [1]: http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries",
                "solutionTags": [],
                "code": "There is a hidden trap: there is no default record ordering in mysql. So if we say \"numbers that appear at least three times consecutively.\", we better to add \"order by id\" here.\\n\\n[http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries][1]\\n\\nMy solution:\\n\\n    select 0 Num from dual where (@pre := null) is null and (@count := 1) is null\\n        union all\\n    select distinct t.Num from (select * from Logs order by Id) t\\n    where (@count := if(@pre = t.Num, @count + 1, 1)) > -1 and (@pre := t.Num) is not null and @count = 3\\n        union all\\n    select 0 from dual where (@pre := null) is null and (@count := null) is not null;\\n\\n  [1]: http://stackoverflow.com/questions/8746519/sql-what-is-the-default-order-by-of-queries",
                "codeTag": "Unknown"
            },
            {
                "id": 3109417,
                "title": "180-consecutive-numbers-too-hard-approach-sql-solution",
                "content": "**Understandable Solution using **`With Clouse` , `row_number() `and `order by `\\n1. use with clouse assume table as t1 Get Row number based on order id\\n2. Get number partition based on num order based on id\\n3. take the diffrence in 1 and 2 to get the diff\\n4. select distinct value based on num\\n5. just write condition  `having Count(*) >= n` ;  ``\\n```\\n\\nwith t1 as (\\n        select id, num,\\n        row_number() over(order by id) -\\n        row_number() over(partition by num order by id) as diff \\n        from Logs\\n    )\\nselect distinct t1.num as ConsecutiveNums\\nfrom t1\\ngroup by num, diff\\nhaving Count(*) >= 3;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nwith t1 as (\\n        select id, num,\\n        row_number() over(order by id) -\\n        row_number() over(partition by num order by id) as diff \\n        from Logs\\n    )\\nselect distinct t1.num as ConsecutiveNums\\nfrom t1\\ngroup by num, diff\\nhaving Count(*) >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2658920,
                "title": "consecutive-numbers-easiest-approach",
                "content": "\\tSELECT distinct a.num as ConsecutiveNums from Logs a \\n\\tjoin Logs b on a.id=b.id+1 and a.num=b.num\\n\\tjoin logs c on a.id=c.id+2 and a.num=c.num;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT distinct a.num as ConsecutiveNums from Logs a \\n\\tjoin Logs b on a.id=b.id+1 and a.num=b.num\\n\\tjoin logs c on a.id=c.id+2 and a.num=c.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 2016799,
                "title": "3-different-solutions",
                "content": "## Solution 1: window function `lag` and `lead`, beat 43%\\n\\n**Logic**: \\n1. for each row attach the previous number and next number next to the current number, and store in `cte`\\n2. condition the `cte` on current number = previous number = next number\\n3. select only `distinct` and rename to `ConsecutiveNums`\\n\\n```\\nwith cte as(\\n    select\\n        id, num,\\n        lag(num,1) over(order by id asc) as prev_num,\\n        lead(num,1) over(order by id asc) as nxt_num\\n    from Logs\\n)\\n\\nselect distinct num as ConsecutiveNums from cte \\nwhere num = prev_num and num = nxt_num\\n```\\n\\n### Solution 2: using `where`, beat 23%\\n\\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a, Logs b, Logs c\\nwhere \\n    a.id + 1 = b.id and b.id + 1 = c.id and\\n    a.num = b.num and b.num = c.num\\n```\\n\\n### Solution 3: using `inner join`, beat 46%\\n\\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a \\n    inner join Logs b on a.id + 1 = b.id and a.num = b.num\\n    inner join Logs c on b.id + 1 = c.id and b.num = c.num\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nwith cte as(\\n    select\\n        id, num,\\n        lag(num,1) over(order by id asc) as prev_num,\\n        lead(num,1) over(order by id asc) as nxt_num\\n    from Logs\\n)\\n\\nselect distinct num as ConsecutiveNums from cte \\nwhere num = prev_num and num = nxt_num\\n```\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a, Logs b, Logs c\\nwhere \\n    a.id + 1 = b.id and b.id + 1 = c.id and\\n    a.num = b.num and b.num = c.num\\n```\n```\\nselect distinct a.num as ConsecutiveNums \\nfrom Logs a \\n    inner join Logs b on a.id + 1 = b.id and a.num = b.num\\n    inner join Logs c on b.id + 1 = c.id and b.num = c.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803779,
                "title": "simplest-easy-mysql-solution-180-consecutive-numbers",
                "content": "```\\nselect DISTINCT a.num AS \"ConsecutiveNums\" from Logs a \\nJOIN Logs b ON a.id = (b.id+1) AND a.num = b.num\\nJOIN Logs c ON a.id = (c.id+2) AND a.num = c.num;\\n\\n\\n#pls upvote if you find solution easy ...Thanks...!!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect DISTINCT a.num AS \"ConsecutiveNums\" from Logs a \\nJOIN Logs b ON a.id = (b.id+1) AND a.num = b.num\\nJOIN Logs c ON a.id = (c.id+2) AND a.num = c.num;\\n\\n\\n#pls upvote if you find solution easy ...Thanks...!!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529243,
                "title": "mysql-two-methods",
                "content": "select distinct l1.num as ConsecutiveNums \\nfrom logs l1, logs l2, logs l3\\nwhere (l1.num=l2.num and l2.num=l3.num and l3.num = l1.num) \\n    and (l2.id-l1.id=1 and l3.id-l2.id=1)       \\n  \\n  \\nwith cte as(\\n            select num, lead(num,1) over(order by id) as \\'2nd\\', lead(num,2) over(order by id) as \\'3rd\\'\\n            from logs)            \\nselect distinct num as ConsecutiveNums from cte where num = 2nd and 2nd = 3rd",
                "solutionTags": [],
                "code": "select distinct l1.num as ConsecutiveNums \\nfrom logs l1, logs l2, logs l3\\nwhere (l1.num=l2.num and l2.num=l3.num and l3.num = l1.num) \\n    and (l2.id-l1.id=1 and l3.id-l2.id=1)       \\n  \\n  \\nwith cte as(\\n            select num, lead(num,1) over(order by id) as \\'2nd\\', lead(num,2) over(order by id) as \\'3rd\\'\\n            from logs)            \\nselect distinct num as ConsecutiveNums from cte where num = 2nd and 2nd = 3rd",
                "codeTag": "Unknown"
            },
            {
                "id": 1411179,
                "title": "easy-to-understand-mysql-solution",
                "content": "```\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere \\na.num = b.num and b.num = c.num\\nand\\nb.id = a.id + 1 and c.id = b.id + 1 and c.id = a.id + 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere \\na.num = b.num and b.num = c.num\\nand\\nb.id = a.id + 1 and c.id = b.id + 1 and c.id = a.id + 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000765,
                "title": "faster-than-90",
                "content": "```\\nselect distinct Num ConsecutiveNums \\nfrom\\n(\\nselect\\n    Id,\\n    Num,\\n    Lead(Num, 1) over(order by Id) NxtNum,\\n    Lead(Num, 2) over(order by Id) NxtNxtNum\\nfrom Logs\\n) t\\nwhere Num = NxtNum and Num = NxtNxtNum\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct Num ConsecutiveNums \\nfrom\\n(\\nselect\\n    Id,\\n    Num,\\n    Lead(Num, 1) over(order by Id) NxtNum,\\n    Lead(Num, 2) over(order by Id) NxtNxtNum\\nfrom Logs\\n) t\\nwhere Num = NxtNum and Num = NxtNxtNum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 874390,
                "title": "use-distinct-and-dense-rank-row-number",
                "content": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, DENSE_RANK() OVER(ORDER BY Id) - DENSE_RANK() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```\\n\\u9898\\u76EE\\u8981\\u6C42\\u627E\\u51FA\\u8FDE\\u7EED3\\u4E2A\\u76F8\\u540CNum\\u7684\\u8BB0\\u5F55\\n\\u4E00\\u5F00\\u59CB\\u4E5F\\u60F3\\u4E0D\\u51FA\\u89E3\\u6CD5\\uFF0C\\u867D\\u7136\\u8FD9\\u4E2A\\u4EBA\\u773C\\u770B\\u662F\\u633A\\u7B80\\u5355\\u7684\\n\\u7ECF\\u641C\\u7D22\\u53D1\\u73B0\\u4E00\\u4E2A\\u5173\\u952E\\u70B9\\uFF0C\\u5C31\\u662F\\u5982\\u679C\\u6570\\u5B57\\u8FDE\\u7EED\\uFF0C\\u90A3\\u4E48\\u4ED6\\u4EECid\\u589E\\u957F\\u548C\\u5206\\u7EC4\\u5185\\u6392\\u5E8F\\u7684\\u589E\\u957F\\u901F\\u5EA6\\u5E94\\u8BE5\\u662F\\u4E00\\u6837\\u7684\\n\\u53C2\\u8003  https://blog.csdn.net/iteye_20478/article/details/82202514?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.add_param_isCf[](http://)\\n*\\u56E0\\u4E3Adenserank() \\u548Crownum\\u90FD\\u662F\\u8FDE\\u7EED\\u7684\\u8BA1\\u6570\\u7684\\uFF0C\\u4E00\\u4E2A\\u662F\\u5168\\u5C40\\u8BA1\\u6570\\uFF0C\\u4E00\\u4E2A\\u662F\\u5C40\\u90E8\\u5206\\u7EC4\\u8BA1\\u6570\\uFF0C\\u56E0\\u6B64\\uFF0C\\u4E24\\u4E2A\\u9012\\u589E\\u9891\\u7387\\u90FD\\u662F1\\u7684\\u8FDE\\u7EED\\u76F8\\u51CF\\uFF0C\\u503C\\u5E94\\u8BE5\\u662F\\u4E00\\u6837\\u7684\\uFF0C\\u6BD4\\u5982 \\u5168\\u5C40\\u4E3A 1,2,3,4,5\\uFF0C\\u5206\\u7EC4\\u4E3A 1,2 \\uFF1B1;1,2 \\u7ED3\\u679C 1-1=0,2-2=0\\uFF1B 3-1=2\\uFF1B 4-1=3,5-2=3\\uFF1B \\u56E0\\u6B64 1,2\\uFF1B4,5\\u662F\\u8FDE\\u7EED\\u7684*\\n\\u6240\\u4EE5\\u8FD9\\u9898\\u4F7F\\u7528row_number\\u5E94\\u8BE5\\u4E5F\\u53EF\\u4EE5,\\u8BD5\\u4E86\\u4E00\\u4E0B\\u8FD8\\u5FEB1ms\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, ROW_NUMBER() OVER(ORDER BY Id) - ROW_NUMBER() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```\\n\\u7136\\u540E\\u4F7F\\u7528group by\\u6309Num\\u548C\\u5DEE\\u503C\\u5206\\u7EC4\\n\\u6700\\u540E\\u63D0\\u4EA4\\u7684\\u65F6\\u5019\\u53D1\\u73B0\\u8F93\\u5165\\u7684\\u8BB0\\u5F55\\u91CD\\u590D\\u5F88\\u591A\\uFF0C\\u8FD8\\u8981\\u7528distinct\\u53BB\\u91CD\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, DENSE_RANK() OVER(ORDER BY Id) - DENSE_RANK() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Id, Num, ROW_NUMBER() OVER(ORDER BY Id) - ROW_NUMBER() OVER(PARTITION BY Num ORDER BY Id) X FROM Logs)\\nGROUP BY Num, X\\nHAVING COUNT(X)>=3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820303,
                "title": "mysql-using-just-count-easy-to-be-generalized",
                "content": "```\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a\\nwhere 3 = \\n(select count(*)\\nfrom Logs b\\nwhere b.Id between a.Id and a.Id+2\\nand b.Num = a.Num)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a.Num as ConsecutiveNums\\nfrom Logs a\\nwhere 3 = \\n(select count(*)\\nfrom Logs b\\nwhere b.Id between a.Id and a.Id+2\\nand b.Num = a.Num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767760,
                "title": "simple-mysql",
                "content": "SELECT DISTINCT a.Num AS ConsecutiveNums FROM Logs a, Logs b, Logs c\\nWHERE a.Num-b.Num=0\\nAND b.Num-c.Num = 0\\nAND c.Id-b.Id = 1 \\nAND b.Id-a.Id = 1",
                "solutionTags": [],
                "code": "SELECT DISTINCT a.Num AS ConsecutiveNums FROM Logs a, Logs b, Logs c\\nWHERE a.Num-b.Num=0\\nAND b.Num-c.Num = 0\\nAND c.Id-b.Id = 1 \\nAND b.Id-a.Id = 1",
                "codeTag": "Unknown"
            },
            {
                "id": 256431,
                "title": "sql-server-mysql-faster-than-75-join-table-two-times-with-its-own-easy-to-understand",
                "content": "```\\n\\nSELECT DISTINCT l1.Num as ConsecutiveNums \\nFROM Logs l1\\nJOIN Logs l2 ON l1.Num = l2.Num\\nJOIN Logs l3 ON l2.Num = l3.Num\\nWHERE (l1.Id + 1) = l2.Id \\n       AND (l2.Id + 1) = l3.Id",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n\\nSELECT DISTINCT l1.Num as ConsecutiveNums \\nFROM Logs l1\\nJOIN Logs l2 ON l1.Num = l2.Num\\nJOIN Logs l3 ON l2.Num = l3.Num\\nWHERE (l1.Id + 1) = l2.Id \\n       AND (l2.Id + 1) = l3.Id",
                "codeTag": "Unknown"
            },
            {
                "id": 53442,
                "title": "who-said-the-id-increments-by-1",
                "content": "There has been posted many solutions assuming that next row should be identified with Id = Id + 1. As there is no explicit reference in the condition for that, I considered it is fair to give a generic case solution. It is built around a view that identifies the next element:\\n```\\nCREATE VIEW Next AS\\n    SELECT l2.Id, l2.Num, MIN(l1.Id) as Next\\n    FROM Logs l1, Logs l2\\n    WHERE l1.Id > l2.Id\\n    GROUP BY l2.Id ;\\n```\\nWith the original example it'll produce a rather trivial table:\\n```\\n+------+------+------+\\n|  Id  |  Num | Next |\\n+------+------+------+\\n|   1  |   1  |   2  |\\n|   2  |   1  |   3  |\\n|   3  |   1  |   4  |\\n|   4  |   2  |   5  |\\n|   5  |   1  |   6  |\\n|   6  |   2  |   7  |\\n+------+------+------+\\n```\\nAnother view appends a value for the next element:\\n```\\nCREATE VIEW NextNum AS\\n    SELECT n.Id, n.Num, n.Next, l.Num as NextNum\\n    FROM Logs l, Next n\\n    WHERE l.Id = n.Next ;\\n```\\nAnd the last query finally \\n```\\nSELECT DISTINCT n.Num\\nFROM NextNum n, NextNum nn\\nWHERE nn.Id = n.Next AND n.Num = n.NextNum AND n.NextNum = nn.NextNum ;\\n```\\nUnfortunately, creating a view is denied by the OJ: \"CREATE VIEW command denied to user 'student'@'localhost' for table 'Next'\".\\nOtherwise it seems reasonable solution working on my private MySQL DB just fine.",
                "solutionTags": [],
                "code": "```\\nCREATE VIEW Next AS\\n    SELECT l2.Id, l2.Num, MIN(l1.Id) as Next\\n    FROM Logs l1, Logs l2\\n    WHERE l1.Id > l2.Id\\n    GROUP BY l2.Id ;\\n```\n```\\n+------+------+------+\\n|  Id  |  Num | Next |\\n+------+------+------+\\n|   1  |   1  |   2  |\\n|   2  |   1  |   3  |\\n|   3  |   1  |   4  |\\n|   4  |   2  |   5  |\\n|   5  |   1  |   6  |\\n|   6  |   2  |   7  |\\n+------+------+------+\\n```\n```\\nCREATE VIEW NextNum AS\\n    SELECT n.Id, n.Num, n.Next, l.Num as NextNum\\n    FROM Logs l, Next n\\n    WHERE l.Id = n.Next ;\\n```\n```\\nSELECT DISTINCT n.Num\\nFROM NextNum n, NextNum nn\\nWHERE nn.Id = n.Next AND n.Num = n.NextNum AND n.NextNum = nn.NextNum ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899091,
                "title": "easy-approach-using-nested-query-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSelf Explanatory.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing nested queries.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct l1.num as ConsecutiveNums from Logs l1\\nwhere (select count(*) from Logs l2\\n              where l1.num=l2.num and l2.id-l1.id <= 2 and l2.id-l1.id >= 0) >= 3;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct l1.num as ConsecutiveNums from Logs l1\\nwhere (select count(*) from Logs l2\\n              where l1.num=l2.num and l2.id-l1.id <= 2 and l2.id-l1.id >= 0) >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523717,
                "title": "mysql-solution-for-consecutive-numbers-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this SQL query is to retrieve all the numbers that appear consecutively three or more times in the Logs table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use a subquery to select the Num column from the Logs table, along with a calculated column freq that represents the frequency of each number in the sequence of numbers.\\n2. Use the @prev and @cnt variables to keep track of the previous number and the frequency of the current number, respectively.\\n3. If the current number is the same as the previous number, increment the frequency by 1. Otherwise, reset the frequency to 1.\\n4. Use the outer query to select the distinct numbers that have a frequency greater than 2 (i.e., appear consecutively three or more times).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this query depends on the size of the Logs table and the efficiency of the database engine\\'s query optimizer. In general, the time complexity of a subquery with a GROUP BY clause is O(n * log n), where n is the number of rows in the table. However, the use of variables to calculate the frequency may help to optimize the query execution plan and reduce the actual time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this query depends on the size of the result set and the size of the columns being selected. In this case, the result set will have at most as many rows as the number of distinct numbers that appear consecutively three or more times in the Logs table. Therefore, the space complexity is O(k), where k is the number of distinct numbers that meet the criteria. The space used by the variables @prev and @cnt is constant, so it does not affect the overall space complexity.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct Num as ConsecutiveNums from \\n(\\n    select\\n    Num, @cnt := if(@prev = (@prev := Num), @cnt + 1, 1) as freq\\n    from\\n    Logs, (Select @cnt := 0, @prev := (select Num from Logs limit 1)) as C\\n)\\nas n\\nwhere freq > 2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct Num as ConsecutiveNums from \\n(\\n    select\\n    Num, @cnt := if(@prev = (@prev := Num), @cnt + 1, 1) as freq\\n    from\\n    Logs, (Select @cnt := 0, @prev := (select Num from Logs limit 1)) as C\\n)\\nas n\\nwhere freq > 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484633,
                "title": "easiest-and-clear-approach",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutiveNums from logs as l1 \\njoin logs as l2 on l1.id=l2.id-1 \\njoin logs as l3 on l1.id=l3.id-2\\nwhere l1.num=l2.num and l1.num=l3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutiveNums from logs as l1 \\njoin logs as l2 on l1.id=l2.id-1 \\njoin logs as l3 on l1.id=l3.id-2\\nwhere l1.num=l2.num and l1.num=l3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324154,
                "title": "mysql-solution",
                "content": "# Code 1\\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1, Logs t2 , Logs t3\\nwhere t1.id = t2.id + 1 and t2.id = t3.id + 1 and \\nt1.num = t2.num and t2.num = t3.num;\\n```\\n\\n# Code 2\\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1\\njoin Logs t2 on t1.id = t2.id + 1\\njoin Logs t3 on t2.id = t3.id + 1\\nwhere t1.num = t2.num and t2.num = t3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1, Logs t2 , Logs t3\\nwhere t1.id = t2.id + 1 and t2.id = t3.id + 1 and \\nt1.num = t2.num and t2.num = t3.num;\\n```\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums \\nfrom Logs t1\\njoin Logs t2 on t1.id = t2.id + 1\\njoin Logs t3 on t2.id = t3.id + 1\\nwhere t1.num = t2.num and t2.num = t3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3322142,
                "title": "runtime-129-ms-beats-96-28-one-solution-for-mysql-ms-sql-and-oracle",
                "content": "\\n\\n# Approach\\nUsing $$LAG$$ and $$LEAD$$ to get the numbers before and after the current number\\n\\n\\n\\n# Code\\n```\\n\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM (\\n     SELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n ) l\\n WHERE l.num = l.prev_num\\n AND l.prev_num = l.next_num\\n AND l.num = l.next_num;\\n\\n\\n```\\n\\n# Explanation\\n\\n\\nSince, we want to find a number appearing three consecutive times, we need to select a particular number whose previous and next numbers are the same.\\n```\\nSELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n```\\nThis part of code will give us the selected columns. You can verify your output is correct by checking if *prev_num* for the first num and *next_num* for the last num are *NULL*.\\n\\nThen, we simply need to find numbers that have the same value in three columns i.e., *num*, *prev_num* and *next_num*. Put *DISTINCT* keyword in the outer *SELECT* statement to get unique values.\\n\\nCheck out LAG and LEAD functions on this URL:\\nhttps://learnsql.com/blog/lead-and-lag-functions-in-sql/\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM (\\n     SELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n ) l\\n WHERE l.num = l.prev_num\\n AND l.prev_num = l.next_num\\n AND l.num = l.next_num;\\n\\n\\n```\n```\\nSELECT id, num, \\n    LAG(num) OVER(ORDER BY id) as prev_num,\\n    LEAD(num) OVER(ORDER BY id) as next_num\\n    FROM Logs\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2661795,
                "title": "left-join",
                "content": "```\\nselect \\ndistinct tem.num as ConsecutiveNums \\nfrom(\\nselect\\na.id ,a.num as num,\\ncount(b.num) as ConsecutiveNums \\nfrom Logs as a left join Logs as b on a.num=b.num and b.id-a.id<3 and b.id-a.id>=0\\ngroup by a.id,a.num) tem\\nwhere tem.ConsecutiveNums=3\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\ndistinct tem.num as ConsecutiveNums \\nfrom(\\nselect\\na.id ,a.num as num,\\ncount(b.num) as ConsecutiveNums \\nfrom Logs as a left join Logs as b on a.num=b.num and b.id-a.id<3 and b.id-a.id>=0\\ngroup by a.id,a.num) tem\\nwhere tem.ConsecutiveNums=3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551312,
                "title": "180-consecutive-numbers",
                "content": "```\\nSELECT DISTINCT one.num AS ConsecutiveNums\\nFROM logs one\\n\\nJOIN logs two ON one.id = two.id - 1\\nJOIN logs thr ON two.id = thr.id - 1\\n\\nWHERE one.num = two.num \\n    AND two.num = thr.num",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT one.num AS ConsecutiveNums\\nFROM logs one\\n\\nJOIN logs two ON one.id = two.id - 1\\nJOIN logs thr ON two.id = thr.id - 1\\n\\nWHERE one.num = two.num \\n    AND two.num = thr.num",
                "codeTag": "Unknown"
            },
            {
                "id": 2507961,
                "title": "mysql-windows-functions",
                "content": "\\nwith CTE as(\\nselect num,\\n    lead(num) over (order by id) as post,\\n    lag(num) over (order by id) as pre\\nfrom Logs \\n)\\n\\nselect distinct(num) as ConsecutiveNums  from CTE \\nwhere post = num and pre = num \\n;\\n",
                "solutionTags": [],
                "code": "\\nwith CTE as(\\nselect num,\\n    lead(num) over (order by id) as post,\\n    lag(num) over (order by id) as pre\\nfrom Logs \\n)\\n\\nselect distinct(num) as ConsecutiveNums  from CTE \\nwhere post = num and pre = num \\n;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2386497,
                "title": "mysql-lead-lag-no-joins",
                "content": "Problem is really easy if you are aware of some window functions.\\n**LAG(col_name)** function returns previous record from col_name\\n**LEAD(col_name**) function returns next record from col_name\\n\\nAdditionally you can specify offset and default value.\\n\\n```\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM (SELECT *,\\n    LEAD(num) OVER() as next_num,\\n    LAG(num,1,0) OVER() as prev_num\\n    FROM Logs) AS x\\nWHERE x.prev_num = x.num AND x.num = x.next_num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT num as \\'ConsecutiveNums\\'\\nFROM (SELECT *,\\n    LEAD(num) OVER() as next_num,\\n    LAG(num,1,0) OVER() as prev_num\\n    FROM Logs) AS x\\nWHERE x.prev_num = x.num AND x.num = x.next_num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2314821,
                "title": "mysql-multiple-approaches-cte-inner-join-cross-join-subqueries",
                "content": "1. Using `CROSS JOIN`:\\n```\\nSELECT L1.num AS ConsecutiveNums\\nFROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num AND L2.num = L3.num \\n  AND L2.id = L1.id + 1 and L3.id = L2.id + 1\\n```\\n\\n2. Using subqueries:\\n```\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM Logs\\nWHERE (id + 1, Num) IN (SELECT * FROM Logs) AND (id + 2, Num) IN (SELECT * FROM Logs)\\n```\\n\\n3. Using `INNER JOIN`:\\n```\\nSELECT DISTINCT L1.num AS ConsecutiveNums\\nFROM logs AS L1\\nJOIN logs AS L2\\nON L1.id = L2.id + 1\\nJOIN logs AS L3\\nON L2.id = L3.id + 1\\nWHERE L1.num = L2.num AND L2.num = L3.num\\n```\\n\\n4. Using Common Table Expressions with `LAG` and `LEAD`:\\n```\\nWITH LagLead AS (\\n    SELECT num,\\n           LEAD(num) OVER(ORDER BY id) AS \\'lead\\',\\n           LAG(num) OVER(ORDER BY id) AS \\'lag\\'\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\nFROM LagLead AS T\\nWHERE num = T.lag AND num = T.lead \\n```\\n\\n* All solutions will work if the id is incremented regularly (as stated in the problem description). If that\\'s not the case, only the last one will work.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT L1.num AS ConsecutiveNums\\nFROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num AND L2.num = L3.num \\n  AND L2.id = L1.id + 1 and L3.id = L2.id + 1\\n```\n```\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM Logs\\nWHERE (id + 1, Num) IN (SELECT * FROM Logs) AND (id + 2, Num) IN (SELECT * FROM Logs)\\n```\n```\\nSELECT DISTINCT L1.num AS ConsecutiveNums\\nFROM logs AS L1\\nJOIN logs AS L2\\nON L1.id = L2.id + 1\\nJOIN logs AS L3\\nON L2.id = L3.id + 1\\nWHERE L1.num = L2.num AND L2.num = L3.num\\n```\n```\\nWITH LagLead AS (\\n    SELECT num,\\n           LEAD(num) OVER(ORDER BY id) AS \\'lead\\',\\n           LAG(num) OVER(ORDER BY id) AS \\'lag\\'\\n    FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\nFROM LagLead AS T\\nWHERE num = T.lag AND num = T.lead \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2189466,
                "title": "simple-and-fast-sql-solution",
                "content": "with g as (\\n  select id, num, \\n    Row_Number() over(order by id) \\n    - Row_Number() over(partition by num order by id) grp_id\\n  from Logs\\n)\\nselect distinct g.num as ConsecutiveNums\\nfrom g\\ngroup by num, grp_id\\nhaving Count(*) >= 3",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "with g as (\\n  select id, num, \\n    Row_Number() over(order by id) \\n    - Row_Number() over(partition by num order by id) grp_id\\n  from Logs\\n)\\nselect distinct g.num as ConsecutiveNums\\nfrom g\\ngroup by num, grp_id\\nhaving Count(*) >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 1594501,
                "title": "combined-lead-with-lag-in-window-function",
                "content": "What I did was I used the function LEAD and LAG to give me the values after and before, added a condition where they are equal to each other, AND added another condition where either one of those values is equal to the number being evaluated.\\n\\n```\\nWITH marked_rows AS\\n\\n(SELECT     id,\\n            num,\\n            LEAD(num) OVER (ORDER BY id ASC) AS number_after,\\n            LAG(num) OVER (ORDER BY id ASC) AS number_before\\n \\n FROM       Logs)\\n \\n SELECT     DISTINCT(num) AS ConsecutiveNums\\n FROM       marked_rows\\n WHERE      number_after = number_before --this condition tells me if the number before and after are the same,\\n            AND num = number_after --this condition tells me if the number in the current row being evaluated is the same as the number after, this condition would work even if you used number_before\\n```",
                "solutionTags": [],
                "code": "```\\nWITH marked_rows AS\\n\\n(SELECT     id,\\n            num,\\n            LEAD(num) OVER (ORDER BY id ASC) AS number_after,\\n            LAG(num) OVER (ORDER BY id ASC) AS number_before\\n \\n FROM       Logs)\\n \\n SELECT     DISTINCT(num) AS ConsecutiveNums\\n FROM       marked_rows\\n WHERE      number_after = number_before --this condition tells me if the number before and after are the same,\\n            AND num = number_after --this condition tells me if the number in the current row being evaluated is the same as the number after, this condition would work even if you used number_before\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1497543,
                "title": "beats-100",
                "content": "```\\nselect \\n\\tdistinct(t1.num) as ConsecutiveNums \\n\\tfrom logs t1, logs t2 , logs t3\\n\\twhere \\n\\t\\tt1.id=t2.id+1 and \\n\\t\\tt2.id=t3.id+1 and\\n\\t\\tt1.num=t2.num and\\n\\t\\tt2.num=t3.num",
                "solutionTags": [],
                "code": "```\\nselect \\n\\tdistinct(t1.num) as ConsecutiveNums \\n\\tfrom logs t1, logs t2 , logs t3\\n\\twhere \\n\\t\\tt1.id=t2.id+1 and \\n\\t\\tt2.id=t3.id+1 and\\n\\t\\tt1.num=t2.num and\\n\\t\\tt2.num=t3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 1360281,
                "title": "used-window-function-ms-sql-server-solution",
                "content": "```\\nSELECT DISTINCT NUM AS [ConsecutiveNums] FROM (\\nSELECT NUM\\n,LEAD(NUM,1) OVER (ORDER BY ID ASC) AS RANK1\\n,LEAD(NUM,2) OVER (ORDER BY ID ASC) AS RANK2\\nFROM LOGS ) B \\nWHERE (B.NUM=B.RANK1) AND (B.NUM=B.RANK2)\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT NUM AS [ConsecutiveNums] FROM (\\nSELECT NUM\\n,LEAD(NUM,1) OVER (ORDER BY ID ASC) AS RANK1\\n,LEAD(NUM,2) OVER (ORDER BY ID ASC) AS RANK2\\nFROM LOGS ) B \\nWHERE (B.NUM=B.RANK1) AND (B.NUM=B.RANK2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1128822,
                "title": "mysql-solution-with-windows-function",
                "content": "SELECT DISTINCT Num as ConsecutiveNums\\nFROM\\n(SELECT Id, Num, \\nLead(Num, 1) OVER(ORDER BY Id) as NextNum,\\nLead(Num, 2) OVER(ORDER BY Id) as NextNum2\\nFROM Logs)A\\nWHERE Num= NextNum and Num= NextNum2",
                "solutionTags": [],
                "code": "SELECT DISTINCT Num as ConsecutiveNums\\nFROM\\n(SELECT Id, Num, \\nLead(Num, 1) OVER(ORDER BY Id) as NextNum,\\nLead(Num, 2) OVER(ORDER BY Id) as NextNum2\\nFROM Logs)A\\nWHERE Num= NextNum and Num= NextNum2",
                "codeTag": "Unknown"
            },
            {
                "id": 1040628,
                "title": "easy-mysql-solution-w-joins",
                "content": "```\\nSELECT DISTINCT \\n    a.num AS ConsecutiveNums\\nFROM LOGS a\\nJOIN LOGS b\\nON a.id + 1 = b.id\\nJOIN LOGS c \\nON b.id +1 = c.id\\nWHERE a.Num = b.Num AND b.Num = c.Num\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT \\n    a.num AS ConsecutiveNums\\nFROM LOGS a\\nJOIN LOGS b\\nON a.id + 1 = b.id\\nJOIN LOGS c \\nON b.id +1 = c.id\\nWHERE a.Num = b.Num AND b.Num = c.Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 851140,
                "title": "expandable-solution-using-recursive-cte",
                "content": "The given solution of 2 offest inner joins makes the most sense if the \"consecutive number\" you\\'re looking for is guaranteed to be fixed. But if it was a parameter in a stored procedure or something I think the below solution works better.\\n\\nThis has the same issue as the inner join solution in that it relies on the Id being guaranteed consecutive, which might not be the case in the real world. This could be solved by first dumping the necessary data into a temp table and including a ROW_NUMBER() column, and using that in place of the Id.\\n\\nAnother potential issue is that I\\'m not sure how it would scale with a very large dataset. If you\\'re looking at data in the 100,000+ rows range, and still need the consecutive number you\\'re checking to be dynamic, then maybe a cursor, a while loop, or dynamic SQL would perform better.\\n\\n```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , Con = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.Con + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.Con >= 3;\\n```",
                "solutionTags": [],
                "code": "```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , Con = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.Con + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.Con >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 836424,
                "title": "intuitive-solution",
                "content": "```\\nselect distinct l1.Num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2 on l1.Num = l2.Num and (l2.Id - l1.Id) between 0 and 2\\ngroup by l1.Id\\nhaving count(distinct l2.Id) = 3\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct l1.Num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2 on l1.Num = l2.Num and (l2.Id - l1.Id) between 0 and 2\\ngroup by l1.Id\\nhaving count(distinct l2.Id) = 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 687891,
                "title": "simple-ms-sql-solution-with-row-number",
                "content": "\\'\\'\\'with x as (\\nselect id,num, id-row_number()over (order by num,id) as rn\\nfrom logs\\n    )\\n   \\n   select num as ConsecutiveNums \\n    from x\\n    group by num,rn \\n    having count(id)>=3\\'\\'\\'\\n\\t\\n\\tThis one creates a rownumber based on both columns and substracts it from id ( resulting in rn field). Then counts the number of id\\'s grouped by the num and the new field(rn) \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "\\'\\'\\'with x as (\\nselect id,num, id-row_number()over (order by num,id) as rn\\nfrom logs\\n    )\\n   \\n   select num as ConsecutiveNums \\n    from x\\n    group by num,rn \\n    having count(id)>=3\\'\\'\\'\\n\\t\\n\\tThis one creates a rownumber based on both columns and substracts it from id ( resulting in rn field). Then counts the number of id\\'s grouped by the num and the new field(rn) \\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 500601,
                "title": "without-using-join-and-it-beat-98-75",
                "content": "```\\nSELECT\\n  DISTINCT a.Num AS ConsecutiveNums\\nFROM\\n  Logs AS a,\\n  Logs AS b,\\n  Logs AS c\\nWHERE\\n  a.Num = b.Num\\n  AND b.Num = c.Num\\n  AND a.Id = b.Id + 1\\n  AND b.Id = c.Id + 1;\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT\\n  DISTINCT a.Num AS ConsecutiveNums\\nFROM\\n  Logs AS a,\\n  Logs AS b,\\n  Logs AS c\\nWHERE\\n  a.Num = b.Num\\n  AND b.Num = c.Num\\n  AND a.Id = b.Id + 1\\n  AND b.Id = c.Id + 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498428,
                "title": "mysql-two-methods",
                "content": "The performance of below methods/implementations are very comparable. \\n\\nMethod 1 - `JOIN`\\nBelow are the various flavors for implementations. \\n\\n(396ms, 98.91%):\\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a, Logs b, Logs c\\nWHERE a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\\n\\n(337ms, 99.08%): \\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\\n\\n(326ms, 99.25%): \\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1\\nWHERE a.Num = b.Num AND b.Num = c.Num; \\n```\\n\\nMethod 2 - variables (276ms, 99.69%): \\n```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num, @i:=@j AS i, @j:=@k AS j, @k:=CAST(Num AS CHAR) AS k\\nFROM Logs, (SELECT @i:=NULL, @j:=NULL, @k:=NULL) a) b\\nWHERE i = j AND j = k; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a, Logs b, Logs c\\nWHERE a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1 AND a.Num = b.Num AND b.Num = c.Num; \\n```\n```\\nSELECT DISTINCT a.Num AS ConsecutiveNums\\nFROM Logs a JOIN Logs b JOIN Logs c ON a.Id = b.Id+1 AND b.Id = c.Id + 1\\nWHERE a.Num = b.Num AND b.Num = c.Num; \\n```\n```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num, @i:=@j AS i, @j:=@k AS j, @k:=CAST(Num AS CHAR) AS k\\nFROM Logs, (SELECT @i:=NULL, @j:=NULL, @k:=NULL) a) b\\nWHERE i = j AND j = k; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468726,
                "title": "ms-sql-solution",
                "content": "```\\n\\nSELECT distinct(Num) as ConsecutiveNums\\nFROM (\\nSELECT Id,\\nNum,\\nLAG(Num, 1) OVER(order by id) as first,\\nLAG(Num, 2) OVER(order by id) as second\\nFROM Logs\\n) as lag\\nWHERE Num = lag.first  AND Num = lag.second\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT distinct(Num) as ConsecutiveNums\\nFROM (\\nSELECT Id,\\nNum,\\nLAG(Num, 1) OVER(order by id) as first,\\nLAG(Num, 2) OVER(order by id) as second\\nFROM Logs\\n) as lag\\nWHERE Num = lag.first  AND Num = lag.second\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238029,
                "title": "simple-sql-solution",
                "content": "```\\nSelect distinct A.Num as ConsecutiveNums \\nfrom Logs A,Logs B, Logs C\\nwhere (A.Id +1 = B.Id) and (B.Id +1 = C.Id) and (A.Num = B.Num) and (B.Num = C.Num)\\n```",
                "solutionTags": [],
                "code": "```\\nSelect distinct A.Num as ConsecutiveNums \\nfrom Logs A,Logs B, Logs C\\nwhere (A.Id +1 = B.Id) and (B.Id +1 = C.Id) and (A.Num = B.Num) and (B.Num = C.Num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133361,
                "title": "oracle-solution-with-lead-window-function",
                "content": "SELECT DISTINCT \\n  Num AS ConsecutiveNums \\nFROM(\\n  SELECT\\n   Num,\\n   LEAD(Num,1) OVER (Order by Id) as lead_1,\\n   LEAD(Num,2) OVER (Order by Id) as lead_2\\n  FROM Logs) a\\nWHERE Num=lead_1 AND lead_1=lead_2\\n",
                "solutionTags": [],
                "code": "SELECT DISTINCT \\n  Num AS ConsecutiveNums \\nFROM(\\n  SELECT\\n   Num,\\n   LEAD(Num,1) OVER (Order by Id) as lead_1,\\n   LEAD(Num,2) OVER (Order by Id) as lead_2\\n  FROM Logs) a\\nWHERE Num=lead_1 AND lead_1=lead_2\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4067837,
                "title": "using-self-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to find the number which was repeated consecutively three times we are self joining the original table three times by comparing the num value in the first table with the num value in the second table and num value in the second table with the num value in the third table.As mentioned in the problem statement as id is incremented by 1 for every new row.We are joining the tables based on the condition id in the first table should combine with the (id+1) row in the second table when both num values are equal and id in the second table should combine with the (id+1) row in the third table when both num values match\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums\\nfrom logs t1\\njoin logs t2\\non t1.id=t2.id+1 and t1.num=t2.num\\njoin logs t3\\non t2.id=t3.id+1 and t2.num=t3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct t1.num as ConsecutiveNums\\nfrom logs t1\\njoin logs t2\\non t1.id=t2.id+1 and t1.num=t2.num\\njoin logs t3\\non t2.id=t3.id+1 and t2.num=t3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043322,
                "title": "using-cte-and-lag-lead",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH cte AS (\\n    SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS prev_num,\\n        LEAD(num) OVER (ORDER BY id) AS next_num\\n    FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums\\nFROM cte\\nWHERE num = prev_num AND num = next_num\\nGROUP BY num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH cte AS (\\n    SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) AS prev_num,\\n        LEAD(num) OVER (ORDER BY id) AS next_num\\n    FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums\\nFROM cte\\nWHERE num = prev_num AND num = next_num\\nGROUP BY num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3881598,
                "title": "pandas-filter-over-diff-and-diff-diff",
                "content": "# Intuition\\nIf values appear twice in a row, then `.diff() == 0`.\\nif they appear thrice, then `.diff().diff() == 0` as well\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf a value appears a second time consecutively, then `.diff() == 0` for the lower row. If it appears a third time then `.diff() == 0` both for the third and second row. Hence, for the last (third) row we also have `.diff().diff() == 0.` Thus, we arrive at a laconic way to filter values which are consecutive triplicates: `.diff() == 0 & .diff().diff() == 0`. \\n\\nNote that in the actual code we must add `()` around the two conditions since `&` has precedence over `==`. This is because `&` in Python means binary `and` which conventionally precedes equality `==`. However, in `pandas` and `numpy` `&` is overloaded for arrays to function as a vectorized `and`.\\n\\nThe rest of the code is trivial: only keep `num`, drop duplicates, rename column to fit required output format.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ since the table comes sorted\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ bound by worst-case output size\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    return logs[(logs.num.diff() == 0) & (logs.num.diff().diff() == 0)]\\\\\\n        [[\\'num\\']]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\\'num\\':\\'ConsecutiveNums\\'})\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    return logs[(logs.num.diff() == 0) & (logs.num.diff().diff() == 0)]\\\\\\n        [[\\'num\\']]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\\'num\\':\\'ConsecutiveNums\\'})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3867334,
                "title": "easy-solution-using-lead-and-lag-window-function",
                "content": "Lead funtion is used to find the next record and lag is used to find the previous record. I\\'m just comparing whether next number and previous number and current number are equal.\\n\\nUsed CTE (common table expression) for adding lead and lag.\\n\\n```\\nwith temporary_table(num,next_num,prev_num) as\\n(select num, LEAD(num,1,0) OVER(order by id asc) as next_num, LAG(num,1,0) OVER(order by id asc) as prev_num from Logs)\\n\\nselect distinct num as  ConsecutiveNums from temporary_table \\nwhere num=next_num and num=prev_num;\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith temporary_table(num,next_num,prev_num) as\\n(select num, LEAD(num,1,0) OVER(order by id asc) as next_num, LAG(num,1,0) OVER(order by id asc) as prev_num from Logs)\\n\\nselect distinct num as  ConsecutiveNums from temporary_table \\nwhere num=next_num and num=prev_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862867,
                "title": "one-tough-problem-to-solve-but-we-are-tougher-than-this",
                "content": "# Intuition\\nFInd consecutive number which appears three times.\\nWe need to solve this problem using Three columns and assigning equality operator\\n\\n# Approach\\nUse Lag to get previous Number,\\nLead to get Next Number,\\nNum is current Num \\nWhen Curr Num is equal to previous Num and Next Num we know that the number appeared atleast three times in a row\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n DISTINCT nums.currNum AS consecutiveNums\\nFROM\\n(SELECT\\nid,\\nnum As currNum,\\nLag(num) OVER(order by id) AS prevNum,\\nLead(num) OVER(order by id) AS nextNum\\nFROM\\nLogs) AS nums\\nWHERE currNum=prevNum\\nAND prevNum=nextNum\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n DISTINCT nums.currNum AS consecutiveNums\\nFROM\\n(SELECT\\nid,\\nnum As currNum,\\nLag(num) OVER(order by id) AS prevNum,\\nLead(num) OVER(order by id) AS nextNum\\nFROM\\nLogs) AS nums\\nWHERE currNum=prevNum\\nAND prevNum=nextNum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545415,
                "title": "solution-with-window-function-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n;with cte as (select\\r\\n\\t*,\\r\\n\\tLEAD(num) OVER(ORDER BY (SELECT NULL)) nextvalues,\\r\\n\\tLEAD(num,2) OVER(ORDER BY (SELECT NULL)) nextvalues2\\r\\nfrom\\t\\r\\n\\tLogs\\r\\n)\\r\\n,cte2 as (select\\r\\n\\tdistinct iif(num = nextvalues and nextvalues = nextvalues2 and num = nextvalues2,num,null) result \\r\\nfrom\\r\\n\\tcte\\r\\n)\\r\\nselect\\r\\n\\tresult ConsecutiveNums\\r\\nfrom\\t\\r\\n\\tcte2 \\r\\nwhere\\r\\n\\tresult is not null\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n;with cte as (select\\r\\n\\t*,\\r\\n\\tLEAD(num) OVER(ORDER BY (SELECT NULL)) nextvalues,\\r\\n\\tLEAD(num,2) OVER(ORDER BY (SELECT NULL)) nextvalues2\\r\\nfrom\\t\\r\\n\\tLogs\\r\\n)\\r\\n,cte2 as (select\\r\\n\\tdistinct iif(num = nextvalues and nextvalues = nextvalues2 and num = nextvalues2,num,null) result \\r\\nfrom\\r\\n\\tcte\\r\\n)\\r\\nselect\\r\\n\\tresult ConsecutiveNums\\r\\nfrom\\t\\r\\n\\tcte2 \\r\\nwhere\\r\\n\\tresult is not null\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433334,
                "title": "mssql-solution-using-lead",
                "content": "# Approach\\nWe can use LEAD() to see what the num values are one and two ids ahead of the current id. If we store these values in a CTE, we can reference them later in the WHERE statement and isolate nums that are the same as one and two ids ahead.\\n\\n# Code\\n```\\nWITH cte AS (\\nSELECT num,\\n       LEAD(num, 1) OVER (ORDER BY id) AS one_num_forward,\\n       LEAD(num, 2) OVER (ORDER BY id) AS two_num_forward\\n  FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\n  FROM cte\\n  WHERE num = one_num_forward\\n  AND num = two_num_forward\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nWITH cte AS (\\nSELECT num,\\n       LEAD(num, 1) OVER (ORDER BY id) AS one_num_forward,\\n       LEAD(num, 2) OVER (ORDER BY id) AS two_num_forward\\n  FROM Logs\\n)\\n\\nSELECT DISTINCT num AS ConsecutiveNums\\n  FROM cte\\n  WHERE num = one_num_forward\\n  AND num = two_num_forward\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3373892,
                "title": "oracle-easy-solution-2-lines",
                "content": "# Intuition\\n-First, decide that you want to show only the distinct element\\n-Then, think how you are going to put condition in it\\n\\n# Approach\\n-I have said that if the number that we have chosen from Logs table is equal to numbers from logs table with id=id+1 and id=id+2 then that number should be displayed.\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect distinct a.num as ConsecutiveNums from logs a where a.num =(select num from Logs where id=a.id+1)\\nAND a.num=(select num from logs where id=a.id+2)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect distinct a.num as ConsecutiveNums from logs a where a.num =(select num from Logs where id=a.id+1)\\nAND a.num=(select num from logs where id=a.id+2)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327383,
                "title": "simple-lag-window-functions",
                "content": "# Intuition\\nSimple lag Window functions\\n\\n# Approach\\nUsing lag window function to find elements 1 lag and 2 lag away and comparing them against the current number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\n  distinct num as ConsecutiveNums\\nfrom\\n(\\n  select\\n    id,\\n    num,\\n    lag(num, 1, 0) over (order by id asc) as lag_num1,\\n    lag(num, 2, 0) over (order by id asc) as lag_num2\\n  from\\n    Logs\\n) lagging\\nwhere\\n  num = lag_num1\\nand\\n  num = lag_num2;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n  distinct num as ConsecutiveNums\\nfrom\\n(\\n  select\\n    id,\\n    num,\\n    lag(num, 1, 0) over (order by id asc) as lag_num1,\\n    lag(num, 2, 0) over (order by id asc) as lag_num2\\n  from\\n    Logs\\n) lagging\\nwhere\\n  num = lag_num1\\nand\\n  num = lag_num2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3158342,
                "title": "simple-join-solution",
                "content": "\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect distinct l1.num as ConsecutiveNums \\nfrom Logs as l1\\njoin Logs as l2 on l1.id = l2.id + 1\\njoin Logs as l3 on l2.id = l3.id + 1\\nwhere l1.num = l2.num and l2.num = l3.num\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect distinct l1.num as ConsecutiveNums \\nfrom Logs as l1\\njoin Logs as l2 on l1.id = l2.id + 1\\njoin Logs as l3 on l2.id = l3.id + 1\\nwhere l1.num = l2.num and l2.num = l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2888747,
                "title": "consecutive-number-with-cte-lead-over",
                "content": "# Intuition\\nComparing rows to find the consecutive sequence \\n\\n# Approach\\nUse CTE to define value from row, row+1 and row+2 using LEAD() OVER() function by id, and then select the distinct value where the conditions are met in sequence\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS\\n(\\n    SELECT\\n        num AS n1\\n        ,LEAD(num,1) OVER (ORDER BY id) AS n2\\n        ,LEAD(num,2) OVER (ORDER BY id) AS n3\\n    FROM Logs\\n)\\nSELECT\\n    DISTINCT n1 AS ConsecutiveNums\\nFROM CTE\\nWHERE n1 = n2 AND n1 = n3\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWITH CTE AS\\n(\\n    SELECT\\n        num AS n1\\n        ,LEAD(num,1) OVER (ORDER BY id) AS n2\\n        ,LEAD(num,2) OVER (ORDER BY id) AS n3\\n    FROM Logs\\n)\\nSELECT\\n    DISTINCT n1 AS ConsecutiveNums\\nFROM CTE\\nWHERE n1 = n2 AND n1 = n3\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674379,
                "title": "simple-solution",
                "content": "```\\nSELECT DISTINCT l1.num AS \\'ConsecutiveNums\\'\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.id = l2.id + 1 AND l2.id = l3.id + 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT l1.num AS \\'ConsecutiveNums\\'\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.id = l2.id + 1 AND l2.id = l3.id + 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2644029,
                "title": "mysql-lead-over",
                "content": "```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from \\n(select id , num, lead(num,1) over() as n1, lead(num, 2) over() as n2\\nfrom logs) a\\nwhere a.num = a.n1 and a.n1 = a.n2\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from \\n(select id , num, lead(num,1) over() as n1, lead(num, 2) over() as n2\\nfrom logs) a\\nwhere a.num = a.n1 and a.n1 = a.n2\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2601896,
                "title": "clean-simple",
                "content": "with T as (\\nselect\\n    num,\\n    lead(num,1) over(order by id) as num1,\\n    lead(num,2) over(order by id) as num2\\nfrom Logs)\\n\\nselect num as ConsecutiveNums\\nfrom T\\nwhere num = num1 and num = num2\\ngroup by num",
                "solutionTags": [],
                "code": "with T as (\\nselect\\n    num,\\n    lead(num,1) over(order by id) as num1,\\n    lead(num,2) over(order by id) as num2\\nfrom Logs)\\n\\nselect num as ConsecutiveNums\\nfrom T\\nwhere num = num1 and num = num2\\ngroup by num",
                "codeTag": "Unknown"
            },
            {
                "id": 2547902,
                "title": "simple-and-easy-to-understand-using-window-function",
                "content": "\\'\\'\\'\\n#lead () over()---- It is a window Function\\nwith rahul as \\n(select *,lead(num,1) over() as next_1,lead(num,2) over () as next_2\\nfrom logs\\n)\\nselect distinct num as consecutiveNums from rahul\\nwhere num = (next_1) and num=(next_2)\\n\\'\\'\\'\\n\\n**Explaination:-**\\nWith the use of Window Function named LEAD() function will allows to access data of the following row, or the row after the subsequent row, and continue on.\\neg:-lead(num,1) --- used to access next num value.\\n\\t  lead(num,2) --- used to access next to next num value.\\n\\n+----+-----+-----+-------+\\n| id | num | next_1 | next_2|\\n+----+-----+-----+-------+\\n| 1  | 1   | 1 | 1 |\\n| 2  | 1   | 1 | 2 |\\n| 3  | 1   | 2 | 1 |\\n| 4  | 2   | 1 | 2 |\\n| 5  | 1   | 2 | 2 |\\n| 6  | 2   | 2 | Null |\\n| 7  | 2   | Null | Null |\\n+----+-----+\\nHere, I have Used the above table name as \"rahul\"\\n\\nselecting  the num = (next_1) and num=(next_2)\\nwould return \\n| 1  | 1   | 1 | 1 |\\n\\nselect num----- would return 1\\nuse of distinct would return the distinct num values.\\n\\n**Do upvote me, if you like my Explaination.**\\n\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "\\'\\'\\'\\n#lead () over()---- It is a window Function\\nwith rahul as \\n(select *,lead(num,1) over() as next_1,lead(num,2) over () as next_2\\nfrom logs\\n)\\nselect distinct num as consecutiveNums from rahul\\nwhere num = (next_1) and num=(next_2)\\n\\'\\'\\'\\n\\n**Explaination:-**\\nWith the use of Window Function named LEAD() function will allows to access data of the following row, or the row after the subsequent row, and continue on.\\neg:-lead(num,1) --- used to access next num value.\\n\\t  lead(num,2) --- used to access next to next num value.\\n\\n+----+-----+-----+-------+\\n| id | num | next_1 | next_2|\\n+----+-----+-----+-------+\\n| 1  | 1   | 1 | 1 |\\n| 2  | 1   | 1 | 2 |\\n| 3  | 1   | 2 | 1 |\\n| 4  | 2   | 1 | 2 |\\n| 5  | 1   | 2 | 2 |\\n| 6  | 2   | 2 | Null |\\n| 7  | 2   | Null | Null |\\n+----+-----+\\nHere, I have Used the above table name as \"rahul\"\\n\\nselecting  the num = (next_1) and num=(next_2)\\nwould return \\n| 1  | 1   | 1 | 1 |\\n\\nselect num----- would return 1\\nuse of distinct would return the distinct num values.\\n\\n**Do upvote me, if you like my Explaination.**\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2327239,
                "title": "simple-lag-lead-solution-for-beginners",
                "content": "```\\nselect distinct(a.num) ConsecutiveNums from (select id , num , lag(num) over(order by id) as previous_num, lead(num) over(order by id) as next_num from Logs) a where a.num = a.previous_num and a.num = a.next_num;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct(a.num) ConsecutiveNums from (select id , num , lag(num) over(order by id) as previous_num, lead(num) over(order by id) as next_num from Logs) a where a.num = a.previous_num and a.num = a.next_num;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2317121,
                "title": "oracle",
                "content": "```\\nSELECT DISTINCT num AS ConsecutiveNums FROM logs l WHERE \\nl.num = (SELECT num FROM logs WHERE id = l.id+1) AND l.num = (SELECT num FROM logs WHERE id = l.id+2)",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT num AS ConsecutiveNums FROM logs l WHERE \\nl.num = (SELECT num FROM logs WHERE id = l.id+1) AND l.num = (SELECT num FROM logs WHERE id = l.id+2)",
                "codeTag": "Unknown"
            },
            {
                "id": 2277787,
                "title": "cte-using-lag-and-lead",
                "content": "This one was kind of tricky and at first I was doing my ORDER BY in the OVER() function by number. But that doesn\\'t make sense since we are looking at order of each number BY id value: so we really want to order the OVER() function by ID not by number:\\n\\nCODE:\\n```\\n-- create a cte to rank the values in the num column:\\nWITH CTE AS (\\n    -- use lag and lead for the values in the num column:\\nSELECT\\n    num,\\n    -- ORDER BY ID:\\n    LEAD(num) OVER(ORDER BY id) AS next_num,\\n    LAG(num) OVER(ORDER BY id) AS prev_num\\nFROM Logs\\n)\\n\\n-- now select the numbers with 3 or more of the same values consecutively:\\nSELECT \\nDISTINCT num AS ConsecutiveNums\\nFROM CTE\\nWHERE (prev_num = num\\n      AND num = next_num);\\n```",
                "solutionTags": [],
                "code": "```\\n-- create a cte to rank the values in the num column:\\nWITH CTE AS (\\n    -- use lag and lead for the values in the num column:\\nSELECT\\n    num,\\n    -- ORDER BY ID:\\n    LEAD(num) OVER(ORDER BY id) AS next_num,\\n    LAG(num) OVER(ORDER BY id) AS prev_num\\nFROM Logs\\n)\\n\\n-- now select the numbers with 3 or more of the same values consecutively:\\nSELECT \\nDISTINCT num AS ConsecutiveNums\\nFROM CTE\\nWHERE (prev_num = num\\n      AND num = next_num);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271059,
                "title": "with-triple-self-join",
                "content": "select \\ndistinct L1.num as ConsecutiveNums\\nfrom Logs L1\\njoin Logs L2\\non L1.id+1=L2.id and L1.num=L2.num\\njoin Logs L3\\non L2.id+1=L3.id and L2.num=L3.num and L1.num=L3.num",
                "solutionTags": [],
                "code": "select \\ndistinct L1.num as ConsecutiveNums\\nfrom Logs L1\\njoin Logs L2\\non L1.id+1=L2.id and L1.num=L2.num\\njoin Logs L3\\non L2.id+1=L3.id and L2.num=L3.num and L1.num=L3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 2260423,
                "title": "t-sql-with-only-self-joins",
                "content": "```\\nSELECT distinct A.num  as ConsecutiveNums\\nfrom Logs A join Logs B \\non B.id = A.id+1 \\njoin Logs C \\non C.id = B.id+1 \\nwhere A.num = B.num and B.num= C.num\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT distinct A.num  as ConsecutiveNums\\nfrom Logs A join Logs B \\non B.id = A.id+1 \\njoin Logs C \\non C.id = B.id+1 \\nwhere A.num = B.num and B.num= C.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2202207,
                "title": "mysql-lead-lag-easy-fast-solution",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM\\n(\\nSELECT num,LEAD(num) OVER(ORDER BY id) AS lead_num, LAG(num) OVER (ORDER BY id) AS lag_num\\nFROM logs\\n)t\\nWHERE num=lead_num and num=lag_num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT num as ConsecutiveNums\\nFROM\\n(\\nSELECT num,LEAD(num) OVER(ORDER BY id) AS lead_num, LAG(num) OVER (ORDER BY id) AS lag_num\\nFROM logs\\n)t\\nWHERE num=lead_num and num=lag_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2135338,
                "title": "mysql-solutions",
                "content": "```\\nRuntime: 399 ms, faster than 96.31% of MySQL online submissions for Consecutive Numbers.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Consecutive Numbers.\\n```\\n```\\nSELECT \\n      DISTINCT(l1.num) AS ConsecutiveNums\\nFROM  logs AS l1, \\n      logs AS l2,  \\n\\t  logs AS l3\\nWHERE (l2.id = (l1.id+1) and l3.id=(l2.id+1)) and \\n      (l1.num=l2.num and l2.num = l3.num)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nRuntime: 399 ms, faster than 96.31% of MySQL online submissions for Consecutive Numbers.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Consecutive Numbers.\\n```\n```\\nSELECT \\n      DISTINCT(l1.num) AS ConsecutiveNums\\nFROM  logs AS l1, \\n      logs AS l2,  \\n\\t  logs AS l3\\nWHERE (l2.id = (l1.id+1) and l3.id=(l2.id+1)) and \\n      (l1.num=l2.num and l2.num = l3.num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2128640,
                "title": "mssql-mysql-query-statement",
                "content": "```\\n# Write your MySQL query statement below     /* Write your T-SQL query statement below */\\nselect distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.num = b.num and b.num = c.num\\n\\tand a.id+1 = b.id and b.id+1 = c.id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n# Write your MySQL query statement below     /* Write your T-SQL query statement below */\\nselect distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.num = b.num and b.num = c.num\\n\\tand a.id+1 = b.id and b.id+1 = c.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2123589,
                "title": "using-self-joins",
                "content": "```\\nselect distinct a.num as ConsecutiveNums\\nfrom logs a, logs b, logs c\\nwhere a.id = b.id+1 AND b.id = c.id+1 AND\\n      a.num = b.num AND b.num = c.num;",
                "solutionTags": [],
                "code": "```\\nselect distinct a.num as ConsecutiveNums\\nfrom logs a, logs b, logs c\\nwhere a.id = b.id+1 AND b.id = c.id+1 AND\\n      a.num = b.num AND b.num = c.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 2061109,
                "title": "simple-mysql-solution-for-this-tough-question-explanation-in-comments",
                "content": "```\\nSELECT \\nDISTINCT L1.NUM AS ConsecutiveNums\\nFROM LOGS L1, LOGS L2, LOGS L3      #make 3 diff table for checking purpose \\nWHERE \\nL1.ID=L2.ID-1 AND L2.ID=L3.ID-1 AND # check for consecutivity of the ids\\'\\nL1.NUM=L2.NUM AND L2.NUM=L3.NUM;    #check for the similarity of the nums\\'\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\nDISTINCT L1.NUM AS ConsecutiveNums\\nFROM LOGS L1, LOGS L2, LOGS L3      #make 3 diff table for checking purpose \\nWHERE \\nL1.ID=L2.ID-1 AND L2.ID=L3.ID-1 AND # check for consecutivity of the ids\\'\\nL1.NUM=L2.NUM AND L2.NUM=L3.NUM;    #check for the similarity of the nums\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030606,
                "title": "using-left-join",
                "content": "```\\n# Write your MySQL query statement below\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom Logs l1\\nleft join Logs l2 on (l2.id-1)=l1.id\\nleft join Logs l3 on (l3.id-2)=l1.id\\nwhere l1.num=l2.num and l1.num=l3.num",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\n    distinct l1.num as ConsecutiveNums\\nfrom Logs l1\\nleft join Logs l2 on (l2.id-1)=l1.id\\nleft join Logs l3 on (l3.id-2)=l1.id\\nwhere l1.num=l2.num and l1.num=l3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 1995624,
                "title": "logic-that-works-for-all-consecutive-questions",
                "content": "select distinct sub.num as ConsecutiveNums  from\\n(select num, \\nrow_number() over (order by id) - row_number() over (partition by num order by id) as grp\\nfrom Logs)sub\\ngroup by sub.num, sub.grp\\nHaving count(*) >= 3",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "select distinct sub.num as ConsecutiveNums  from\\n(select num, \\nrow_number() over (order by id) - row_number() over (partition by num order by id) as grp\\nfrom Logs)sub\\ngroup by sub.num, sub.grp\\nHaving count(*) >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 1981277,
                "title": "mysql-easy-solution-two-approaches-window-function-and-inner-join",
                "content": "Please upvote this solution if it helps ypu :)\\n\\nApproach 1: Using window function\\n\\nwith newlog as (\\n    select id, num,\\n    lag(num) over (order by id) as lag_num,\\n    lead(num) over (order by  id) as lead_num\\n    from logs\\n)\\nselect distinct num as ConsecutiveNums from newlog \\nwhere lag_num=num and lead_num=num\\n\\n\\nApproach 2: Using three inner join \\n\\nselect distinct l1.num as consecutiveNums from logs l1\\ninner join logs l2 on l1.id=l2.id+1\\ninner join logs l3 on l2.id=l3.id+1\\nwhere l1.num=l2.num and l2.num=l3.num\\n",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "Please upvote this solution if it helps ypu :)\\n\\nApproach 1: Using window function\\n\\nwith newlog as (\\n    select id, num,\\n    lag(num) over (order by id) as lag_num,\\n    lead(num) over (order by  id) as lead_num\\n    from logs\\n)\\nselect distinct num as ConsecutiveNums from newlog \\nwhere lag_num=num and lead_num=num\\n\\n\\nApproach 2: Using three inner join \\n\\nselect distinct l1.num as consecutiveNums from logs l1\\ninner join logs l2 on l1.id=l2.id+1\\ninner join logs l3 on l2.id=l3.id+1\\nwhere l1.num=l2.num and l2.num=l3.num\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1890960,
                "title": "mysql-solution",
                "content": "```\\nselect distinct num as ConsecutiveNums from\\n(select num, lag(num) over (order by id) as \\'previous_num\\',\\nlead(num) over (order by id) as \\'next_num\\'\\nfrom logs) as t\\nwhere num = previous_num\\nand previous_num = next_num;\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct num as ConsecutiveNums from\\n(select num, lag(num) over (order by id) as \\'previous_num\\',\\nlead(num) over (order by id) as \\'next_num\\'\\nfrom logs) as t\\nwhere num = previous_num\\nand previous_num = next_num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1861792,
                "title": "2-solutions-with-and-without-window-functions",
                "content": "With window function LAG:\\n\\n```\\nwith t as (\\n    select id,\\n    num,\\n    lag(num,1,null) over () as prev_num,\\n    lag(num,2,null) over() as prev_prev_num\\n    from Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere (num = prev_num and num = prev_prev_num)\\n```\\n\\nWith JOIN (faster):\\n\\n```\\nselect distinct l.num as ConsecutiveNums\\nfrom Logs l join Logs ll on l.num = ll.num and l.id - ll.id between 1 and 2\\ngroup by l.id,l.num\\nhaving count(distinct ll.id) >= 2\\n```\\n",
                "solutionTags": [],
                "code": "```\\nwith t as (\\n    select id,\\n    num,\\n    lag(num,1,null) over () as prev_num,\\n    lag(num,2,null) over() as prev_prev_num\\n    from Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere (num = prev_num and num = prev_prev_num)\\n```\n```\\nselect distinct l.num as ConsecutiveNums\\nfrom Logs l join Logs ll on l.num = ll.num and l.id - ll.id between 1 and 2\\ngroup by l.id,l.num\\nhaving count(distinct ll.id) >= 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1813485,
                "title": "easy-solution-2-approaches",
                "content": "```\\nJoin:\\nselect distinct a.num as consecutivenums from logs a \\njoin logs b on a.id= b.id+1 and a.num=b.num\\njoin logs c on a.id= c.id+2 and a.num=c.num;\\n\\nWhere:\\nselect distinct a.num  as consecutivenums from logs a, logs b, logs c\\nwhere a.num = b.num and a.num = c.num\\nand a.id = b.id+1 and a.id = c.id+2;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nJoin:\\nselect distinct a.num as consecutivenums from logs a \\njoin logs b on a.id= b.id+1 and a.num=b.num\\njoin logs c on a.id= c.id+2 and a.num=c.num;\\n\\nWhere:\\nselect distinct a.num  as consecutivenums from logs a, logs b, logs c\\nwhere a.num = b.num and a.num = c.num\\nand a.id = b.id+1 and a.id = c.id+2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575044,
                "title": "ms-sql-faster-than-99-01",
                "content": "WITH cte AS (\\n        SELECT num,\\n        CASE\\n            WHEN ABS(id - LEAD(id,1) OVER (PARTITION BY num order by id asc))\\n                +\\n                ABS(id - LEAD(id,2) OVER (PARTITION BY num order by id asc))\\n            = 3 THEN \\'Y\\'\\n        ELSE \\n            \\'N\\'\\n        END as flag\\n        FROM logs\\n    )\\nselect distinct num as ConsecutiveNums\\nFROM cte\\nWHERE flag = \\'Y\\'",
                "solutionTags": [],
                "code": "WITH cte AS (\\n        SELECT num,\\n        CASE\\n            WHEN ABS(id - LEAD(id,1) OVER (PARTITION BY num order by id asc))\\n                +\\n                ABS(id - LEAD(id,2) OVER (PARTITION BY num order by id asc))\\n            = 3 THEN \\'Y\\'\\n        ELSE \\n            \\'N\\'\\n        END as flag\\n        FROM logs\\n    )\\nselect distinct num as ConsecutiveNums\\nFROM cte\\nWHERE flag = \\'Y\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1569990,
                "title": "easy-mysql-solution",
                "content": "```\\nSELECT DISTINCT \\n    l1.num AS ConsecutiveNums \\nFROM \\n    Logs l1, Logs l2, Logs l3 \\nWHERE \\n    l1.Id = l2.Id - 1 \\n    AND l2.Id = l3.Id - 1 \\n    AND l1.Num = l2.Num \\n    AND l2.Num =  l3.Num;\\n```\\nSimilar to id == id - 1 && id - 1 == id - 2",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT \\n    l1.num AS ConsecutiveNums \\nFROM \\n    Logs l1, Logs l2, Logs l3 \\nWHERE \\n    l1.Id = l2.Id - 1 \\n    AND l2.Id = l3.Id - 1 \\n    AND l1.Num = l2.Num \\n    AND l2.Num =  l3.Num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1524966,
                "title": "using-rank-can-be-customized-on-any-number-of-consecutive-time",
                "content": "```\\nwith cte as\\n(select num,\\nid, rank() over(partition by num order by  id) rnk\\nfrom logs)\\n\\nselect distinct num ConsecutiveNums \\nfrom (\\nselect num, min(id) mid, max(id) mad, (( CAST( id AS SIGNED ))-\\n                                       ( CAST( rnk AS SIGNED ))) diff from cte\\ngroup by num, diff) x\\nwhere mad-mid>=2 -- code as parameter\\n```",
                "solutionTags": [],
                "code": "```\\nwith cte as\\n(select num,\\nid, rank() over(partition by num order by  id) rnk\\nfrom logs)\\n\\nselect distinct num ConsecutiveNums \\nfrom (\\nselect num, min(id) mid, max(id) mad, (( CAST( id AS SIGNED ))-\\n                                       ( CAST( rnk AS SIGNED ))) diff from cte\\ngroup by num, diff) x\\nwhere mad-mid>=2 -- code as parameter\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1430260,
                "title": "ms-sql-lead",
                "content": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select num\\n         , lead(num, 1) over(order by id) as lead1\\n         , lead(num, 2) over(order by id) as lead2\\n    from Logs \\n) a\\nwhere num = lead1 and num = lead2\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select num\\n         , lead(num, 1) over(order by id) as lead1\\n         , lead(num, 2) over(order by id) as lead2\\n    from Logs \\n) a\\nwhere num = lead1 and num = lead2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392637,
                "title": "classical-gaps-islands-problem-window-functions",
                "content": "\\n```\\nselect distinct T.num as ConsecutiveNums\\nfrom (\\n         select *,\\n                row_number() over (order by id)                  as rw,\\n                row_number() over (partition by Num order by id) as rn\\n         from logs\\n     ) T\\ngroup by rw - rn, T.num\\nhaving count(*) >= 3;\\n```\\n\\nSee for more details https://explainextended.com/2011/02/18/things-sql-needs-series/",
                "solutionTags": [],
                "code": "```\\nselect distinct T.num as ConsecutiveNums\\nfrom (\\n         select *,\\n                row_number() over (order by id)                  as rw,\\n                row_number() over (partition by Num order by id) as rn\\n         from logs\\n     ) T\\ngroup by rw - rn, T.num\\nhaving count(*) >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313518,
                "title": "easiest-solution-which-works-for-any-number-of-consecutive-asked",
                "content": "In the solution below, we select distinct numbers that appear consecutively atleast 3 times. The @counter and @prev are pointer variables. These variables scan the entire table and keep a count of the numbers in the @counter variable whereas @prev keeps track of the previous number to match with the next. If @prev is same as the current row Num, then @counter is increased by 1, else @counter remains valued at 1. @prev is now set to the recently encountered Num. table1 is an alias for the temporary table containing Num and the occurrences column. SELECT @counter:=1, @prev:=NULL is for the first record encountered.\\n```\\nSELECT  DISTINCT(Num) AS ConsecutiveNums\\nFROM (\\n    SELECT\\n    Num,\\n    @counter := IF(@prev = Num, @counter + 1, 1) AS occurrences,\\n    @prev := Num\\n    FROM Logs, (SELECT @counter:=1, @prev:=NULL) var\\n) table1\\nWHERE occurrences >= 3\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT  DISTINCT(Num) AS ConsecutiveNums\\nFROM (\\n    SELECT\\n    Num,\\n    @counter := IF(@prev = Num, @counter + 1, 1) AS occurrences,\\n    @prev := Num\\n    FROM Logs, (SELECT @counter:=1, @prev:=NULL) var\\n) table1\\nWHERE occurrences >= 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1308569,
                "title": "sql",
                "content": "select distinct (a.num) as ConsecutiveNums from Logs a,Logs b,Logs c where a.id=b.id-1 and b.id=c.id-1 and a.num=b.num and b.num=c.num;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select distinct (a.num) as ConsecutiveNums from Logs a,Logs b,Logs c where a.id=b.id-1 and b.id=c.id-1 and a.num=b.num and b.num=c.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 1286043,
                "title": "easy-mysql-query",
                "content": "select distinct num as ConsecutiveNums\\nfrom\\n(select num, id - Cast(row_number() over (partition by num order by id) as signed)  diff\\nfrom\\nlogs)v\\ngroup by num,diff\\nhaving count(num)>=3",
                "solutionTags": [],
                "code": "select distinct num as ConsecutiveNums\\nfrom\\n(select num, id - Cast(row_number() over (partition by num order by id) as signed)  diff\\nfrom\\nlogs)v\\ngroup by num,diff\\nhaving count(num)>=3",
                "codeTag": "Unknown"
            },
            {
                "id": 1220736,
                "title": "ms-sql-simple-solution",
                "content": "```\\n/* Write your T-SQL query statement below */\\nselect A.Num as ConsecutiveNums \\nfrom Logs A\\njoin Logs B on A.Id+1=B.Id and A.Num=B.Num\\njoin Logs C on B.Id+1=C.Id and B.Num=C.Num\\ngroup by A.Num\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect A.Num as ConsecutiveNums \\nfrom Logs A\\njoin Logs B on A.Id+1=B.Id and A.Num=B.Num\\njoin Logs C on B.Id+1=C.Id and B.Num=C.Num\\ngroup by A.Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1150002,
                "title": "mysql-using-lag-and-lead",
                "content": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select\\n    num,\\n    id,\\n    lag(id) over(partition by num order by id) as previous,\\n    lead(id) over(partition by num order by id) as next\\n    from logs\\n) f\\nwhere previous + 1 = id and next - 1 = id\\n```",
                "solutionTags": [],
                "code": "```\\nselect distinct num as ConsecutiveNums\\nfrom\\n(\\n    select\\n    num,\\n    id,\\n    lag(id) over(partition by num order by id) as previous,\\n    lead(id) over(partition by num order by id) as next\\n    from logs\\n) f\\nwhere previous + 1 = id and next - 1 = id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1146422,
                "title": "ms-sql-using-lead",
                "content": "```\\n/* Write your T-SQL query statement below */\\nwith cte as(\\nselect \\n    num,\\n    lead(num, 1) over(order by id) lead1,\\n    lead(num, 2) over(order by id) lead2\\n    from logs\\n)\\n\\nselect distinct num ConsecutiveNums from cte\\nwhere num = lead1 and num = lead2 and lead1 = lead2\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nwith cte as(\\nselect \\n    num,\\n    lead(num, 1) over(order by id) lead1,\\n    lead(num, 2) over(order by id) lead2\\n    from logs\\n)\\n\\nselect distinct num ConsecutiveNums from cte\\nwhere num = lead1 and num = lead2 and lead1 = lead2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1024006,
                "title": "lag-lead",
                "content": "```\\n# Write your MySQL query statement below\\nWITH \\n    tab1\\nAS\\n    (SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) as lagdiff,\\n        LEAD(num) OVER (ORDER BY id) as leaddiff\\n    FROM   \\n        logs)\\n        \\nSELECT DISTINCT\\n    num AS ConsecutiveNums\\nFROM \\n    tab1\\nWHERE \\n    num = lagdiff AND\\n    num = leaddiff\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nWITH \\n    tab1\\nAS\\n    (SELECT\\n        num,\\n        LAG(num) OVER (ORDER BY id) as lagdiff,\\n        LEAD(num) OVER (ORDER BY id) as leaddiff\\n    FROM   \\n        logs)\\n        \\nSELECT DISTINCT\\n    num AS ConsecutiveNums\\nFROM \\n    tab1\\nWHERE \\n    num = lagdiff AND\\n    num = leaddiff\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1014073,
                "title": "tsql-100-time-space-using-cte-lag-and-lead",
                "content": "\\nCreate a CTE (nums), creating additional before and after columns for each num. Use `DISTINCT` and simple logical operators\\nand your off!\\n```sql\\nWITH nums AS (\\n    SELECT *,\\n        LAG(Num, 1) OVER(ORDER BY Id) AS one_before,\\n        LEAD(Num, 1) OVER(ORDER BY Id) AS one_after\\n    FROM Logs)\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM nums\\nWHERE Num = one_before AND Num = one_after;\\n```",
                "solutionTags": [],
                "code": "```sql\\nWITH nums AS (\\n    SELECT *,\\n        LAG(Num, 1) OVER(ORDER BY Id) AS one_before,\\n        LEAD(Num, 1) OVER(ORDER BY Id) AS one_after\\n    FROM Logs)\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM nums\\nWHERE Num = one_before AND Num = one_after;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 989843,
                "title": "using-self-join-70-faster",
                "content": "```\\nselect \\n   distinct a.Num as ConsecutiveNums\\nfrom Logs a \\n    join Logs b on\\n        a.Num = b.Num and\\n        b.Id -a.Id = 1\\n    join Logs c on \\n        a.Num = c.Num and\\n        c.Id -a.Id = 2\\n",
                "solutionTags": [],
                "code": "```\\nselect \\n   distinct a.Num as ConsecutiveNums\\nfrom Logs a \\n    join Logs b on\\n        a.Num = b.Num and\\n        b.Id -a.Id = 1\\n    join Logs c on \\n        a.Num = c.Num and\\n        c.Id -a.Id = 2\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 955363,
                "title": "using-recursive-cte-scalable-to-any-variable",
                "content": "```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , C = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.C + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.C >= 3;\\n```\\n",
                "solutionTags": [],
                "code": "```\\nWITH T AS (\\nSELECT -- Anchor Set\\n      id\\n    , Num\\n    , C = 1 \\nFROM Logs\\n    \\nUNION ALL\\n\\nSELECT l.id, l.Num, T.C + 1\\nFROM T\\n    JOIN Logs l\\n      ON t.id + 1 = l.id\\nWHERE T.Num = l.Num\\n)\\nSELECT DISTINCT\\nT.Num as ConsecutiveNums\\nFROM T\\nWHERE T.C >= 3;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 954556,
                "title": "find-consecutive-numbers-with-just-inner-joins-and-where-clause",
                "content": "Here is my code for just using  Inner Joins and Where clause (T-SQL).\\n\\n```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nINNER JOIN Logs l2\\nON l1.id = l2.id - 1\\nINNER JOIN Logs l3\\nON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.num = l3.num\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1\\nINNER JOIN Logs l2\\nON l1.id = l2.id - 1\\nINNER JOIN Logs l3\\nON l1.id = l3.id - 2\\nWHERE l1.num = l2.num AND l2.num = l3.num AND l1.num = l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 930813,
                "title": "mysql-very-easy-to-understand",
                "content": "SELECT num as ConsecutiveNums\\nFROM (SELECT DISTINCT(num), lead(num, 2) OVER(ORDER BY id) as next_num, lead(num, 1) OVER(ORDER BY id) as next_next_num\\nfrom logs) as h\\nWHERE num = next_num and num = next_next_num",
                "solutionTags": [],
                "code": "SELECT num as ConsecutiveNums\\nFROM (SELECT DISTINCT(num), lead(num, 2) OVER(ORDER BY id) as next_num, lead(num, 1) OVER(ORDER BY id) as next_next_num\\nfrom logs) as h\\nWHERE num = next_num and num = next_next_num",
                "codeTag": "Unknown"
            },
            {
                "id": 843375,
                "title": "mysql-self-join",
                "content": "SELECT distinct(l1.Num) as ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.Id = l2.Id +1 AND l2.Id = l3.id +1 AND l1.Num = l2.Num AND l2.Num = l3.Num",
                "solutionTags": [],
                "code": "SELECT distinct(l1.Num) as ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3\\nWHERE l1.Id = l2.Id +1 AND l2.Id = l3.id +1 AND l1.Num = l2.Num AND l2.Num = l3.Num",
                "codeTag": "Unknown"
            },
            {
                "id": 802658,
                "title": "simple-mysql-with-lead",
                "content": "```\\nSELECT Num AS ConsecutiveNums\\nFROM(\\n    SELECT Id, Num, LEAD(Num,1) OVER() AS lead1, LEAD(Num,2) OVER() AS lead2\\n    FROM Logs\\n) AS t1\\nWHERE Num = lead1 AND lead1 = lead2\\nGROUP BY Num\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Num AS ConsecutiveNums\\nFROM(\\n    SELECT Id, Num, LEAD(Num,1) OVER() AS lead1, LEAD(Num,2) OVER() AS lead2\\n    FROM Logs\\n) AS t1\\nWHERE Num = lead1 AND lead1 = lead2\\nGROUP BY Num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 793378,
                "title": "ms-sql-server",
                "content": "```\\nSELECT DISTINCT l1.Num AS ConsecutiveNums \\nFROM\\n    Logs l1\\n    JOIN Logs l2 ON l1.Id = l2.Id - 1\\n    JOIN Logs l3 ON l2.Id = l3.Id - 1\\nWHERE\\n    l1.Num = l2.Num\\n    AND l2.Num = l3.Num;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT l1.Num AS ConsecutiveNums \\nFROM\\n    Logs l1\\n    JOIN Logs l2 ON l1.Id = l2.Id - 1\\n    JOIN Logs l3 ON l2.Id = l3.Id - 1\\nWHERE\\n    l1.Num = l2.Num\\n    AND l2.Num = l3.Num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 769884,
                "title": "ms-sql-using-lag-function",
                "content": "```\\nselect distinct(num) as \\'ConsecutiveNums\\'\\nfrom \\n(\\nselect id, num,\\nlag(num,1) over (order by Id) as lag_A, \\nlag(num,2) over (order by Id) as lag_B\\nfrom Logs\\n)t\\nwhere t.lag_A=t.lag_B --check for consecutive values by looking at current number vs the lag values 1 and 2\\nand t.num =t.lag_A\\n\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect distinct(num) as \\'ConsecutiveNums\\'\\nfrom \\n(\\nselect id, num,\\nlag(num,1) over (order by Id) as lag_A, \\nlag(num,2) over (order by Id) as lag_B\\nfrom Logs\\n)t\\nwhere t.lag_A=t.lag_B --check for consecutive values by looking at current number vs the lag values 1 and 2\\nand t.num =t.lag_A\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 714701,
                "title": "mysql-soln-faster-than-97-8",
                "content": "select distinct num as ConsecutiveNums from (\\nselect num, row_number() over (order by id) - row_number() over (partition by num order by id) as temp from logs) tmp\\ngroup by temp, num\\nhaving count(1) >= 3",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select distinct num as ConsecutiveNums from (\\nselect num, row_number() over (order by id) - row_number() over (partition by num order by id) as temp from logs) tmp\\ngroup by temp, num\\nhaving count(1) >= 3",
                "codeTag": "Unknown"
            },
            {
                "id": 637730,
                "title": "msql-very-easy-solution-cross-join",
                "content": "select distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.id = b.id-1\\nand a.id = c.id-2\\nand a.num =b.num\\nand a.num = c.num",
                "solutionTags": [],
                "code": "select distinct a.num as ConsecutiveNums\\nfrom Logs a, Logs b, Logs c\\nwhere a.id = b.id-1\\nand a.id = c.id-2\\nand a.num =b.num\\nand a.num = c.num",
                "codeTag": "Unknown"
            },
            {
                "id": 524379,
                "title": "no-assumption-on-id-uses-lag",
                "content": "no reason to believe the ID numbers are consecutive or give the relevant ordering... if this column was `row_number` or something then it would be reasonable to use it. \\n\\ni\\'m using `lag()` here with `order by null` to leave the ordering as is (and because `order by` specification is mandatory). i couldn\\'t find anything in the docs to support my assumption about the `NULL` behavior but i guess [ppl use it](https://stackoverflow.com/questions/25377014/what-does-this-mean-order-by-null).\\n\\n```\\nwith loglag as (\\n\\tselect\\n\\t\\tNum,\\n\\t\\tlag(Num, 1) over (order by null) as num_prev,\\n\\t\\tlag(Num, 2) over (order by null) as num_prevprev\\n\\tfrom Logs\\n)\\nselect\\n\\tNum as ConsecutiveNums\\nfrom loglag\\nwhere Num = num_prev\\n  and num_prev = num_prevprev\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nwith loglag as (\\n\\tselect\\n\\t\\tNum,\\n\\t\\tlag(Num, 1) over (order by null) as num_prev,\\n\\t\\tlag(Num, 2) over (order by null) as num_prevprev\\n\\tfrom Logs\\n)\\nselect\\n\\tNum as ConsecutiveNums\\nfrom loglag\\nwhere Num = num_prev\\n  and num_prev = num_prevprev\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282107,
                "title": "simple-mysql-tuple-check-fast",
                "content": "SELECT Distinct(Num) as ConsecutiveNums\\nFROM Logs\\nWHERE (ID+1,Num) IN (Select Id, Num From Logs) \\n    AND (ID+2,Num) IN (Select Id, Num From Logs) \\n",
                "solutionTags": [],
                "code": "SELECT Distinct(Num) as ConsecutiveNums\\nFROM Logs\\nWHERE (ID+1,Num) IN (Select Id, Num From Logs) \\n    AND (ID+2,Num) IN (Select Id, Num From Logs) \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 185180,
                "title": "solution-without-using-id",
                "content": "```\nSelect distinct a.Num as ConsecutiveNums From\n(\nselect Num, @counter := IF(@prev = (@prev := Num), @counter := @counter + 1, 1) as n\n    from Logs, (select @prev := -1, @counter := 1) c\n) a\nwhere a.n >= 3;\n```",
                "solutionTags": [],
                "code": "```\nSelect distinct a.Num as ConsecutiveNums From\n(\nselect Num, @counter := IF(@prev = (@prev := Num), @counter := @counter + 1, 1) as n\n    from Logs, (select @prev := -1, @counter := 1) c\n) a\nwhere a.n >= 3;\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172590,
                "title": "my-solution",
                "content": "The idea is from '178.Rank Score'. https://leetcode.com/problems/rank-scores/discuss/53094/Simple-Short-Fast\n\n'''\nSELECT DISTINCT T1.Num ConsecutiveNums\nFROM (\n      SELECT Num, (@Row :=@Row + (@Prev <> @Prev:= Num)) Rank\n      FROM Logs, (SELECT @Row:=0, @Prev:=-1) AS Temp\n      GROUP BY Rank\n      HAVING COUNT(Rank) >=3) T1;\n\t\t\t'''",
                "solutionTags": [],
                "code": "FROM (\n      SELECT Num, (@Row :=@Row + (@Prev <> @Prev:= Num)) Rank\n      FROM Logs, (SELECT @Row:=0, @Prev:=-1) AS Temp\n      HAVING COUNT(Rank) >=3) T1;",
                "codeTag": "Unknown"
            },
            {
                "id": 140359,
                "title": "simple-solution-no-variables-beats-100-310-ms",
                "content": "```\\nSELECT DISTINCT A.Num as ConsecutiveNums\\nFROM (SELECT * FROM Logs) AS A,(SELECT Id+1 as Id,Num FROM Logs) AS B,(SELECT Id+2 as Id,Num FROM Logs) AS C\\nWHERE A.Id=B.Id AND A.Id=C.ID AND A.Num=B.Num AND A.Num=C.Num;\\n",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT A.Num as ConsecutiveNums\\nFROM (SELECT * FROM Logs) AS A,(SELECT Id+1 as Id,Num FROM Logs) AS B,(SELECT Id+2 as Id,Num FROM Logs) AS C\\nWHERE A.Id=B.Id AND A.Id=C.ID AND A.Num=B.Num AND A.Num=C.Num;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 137203,
                "title": "t-sql-windows-function-lag-lead",
                "content": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num,\\nLAG(Num, 1) OVER(ORDER BY Id) AS LAD1,\\nLEAD(Num, 1) OVER (ORDER BY Id) AS LEAD1 FROM Logs) AS a\\nWHERE Num = LAD1 AND Num = LEAD1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM \\n(SELECT Num,\\nLAG(Num, 1) OVER(ORDER BY Id) AS LAD1,\\nLEAD(Num, 1) OVER (ORDER BY Id) AS LEAD1 FROM Logs) AS a\\nWHERE Num = LAD1 AND Num = LEAD1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53464,
                "title": "solution-sharing",
                "content": "select distinct t1.num from Logs t1 join Logs t2 on t1.id+1 = t2.id join Logs t3 on t1.id+2=t3.id where t1.num = t2.num and t2.num = t3.num order by t1.num;",
                "solutionTags": [],
                "code": "select distinct t1.num from Logs t1 join Logs t2 on t1.id+1 = t2.id join Logs t3 on t1.id+2=t3.id where t1.num = t2.num and t2.num = t3.num order by t1.num;",
                "codeTag": "Unknown"
            },
            {
                "id": 4078209,
                "title": "python-intuitive-answer-vs-swe-appproach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nUse `rolling()` function to look at windows of size 3\\n\\ncheck if the window has all the same number either using\\n\\n1. `len(set(lst)) == 1`\\n\\nor\\n\\n2. `lst.nunique() == 1`\\n\\nThen do a simple select distinct, filter, and rename to format your output\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    all_the_same = lambda lst: lst.nunique()==1\\n    logs[\\'is_consecutive\\'] = logs[\\'num\\']\\\\\\n        .rolling(window=3, center=True, min_periods=3)\\\\\\n        .apply(all_the_same)\\n    return logs.query(\"is_consecutive == 1.0\")[[\"num\"]]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\"num\": \"ConsecutiveNums\"})\\n\\n    \\n```\\n\\n\\n# The SWE way\\n\\nSliding window using 2 pointers. \\n\\nPro: intuitive\\nCon: not in the style of data analyst/engineer\\n\\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    # SWE way\\n    nums = logs[\"num\"]\\n    consecutiveNums = set()\\n    i = 1\\n    while i < len(nums)-1:\\n        if nums[i-1]==nums[i]==nums[i+1]:\\n            consecutiveNums.add(nums[i])\\n            i = i+3\\n        elif nums[i]!=nums[i+1]:\\n            i = i+2\\n        elif nums[i-1] != nums[i]:\\n         i = i+1\\n    return pd.DataFrame({\"ConsecutiveNums\":list(consecutiveNums)})\\n\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    all_the_same = lambda lst: lst.nunique()==1\\n    logs[\\'is_consecutive\\'] = logs[\\'num\\']\\\\\\n        .rolling(window=3, center=True, min_periods=3)\\\\\\n        .apply(all_the_same)\\n    return logs.query(\"is_consecutive == 1.0\")[[\"num\"]]\\\\\\n        .drop_duplicates()\\\\\\n        .rename(columns={\"num\": \"ConsecutiveNums\"})\\n\\n    \\n```\n```\\nimport pandas as pd\\n\\ndef consecutive_numbers(logs: pd.DataFrame) -> pd.DataFrame:\\n    # SWE way\\n    nums = logs[\"num\"]\\n    consecutiveNums = set()\\n    i = 1\\n    while i < len(nums)-1:\\n        if nums[i-1]==nums[i]==nums[i+1]:\\n            consecutiveNums.add(nums[i])\\n            i = i+3\\n        elif nums[i]!=nums[i+1]:\\n            i = i+2\\n        elif nums[i-1] != nums[i]:\\n         i = i+1\\n    return pd.DataFrame({\"ConsecutiveNums\":list(consecutiveNums)})\\n\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3975767,
                "title": "unique-and-simple-approach-using-join-only",
                "content": "\\n\\n# PLEASE UPVOTE\\n\\n\\n```\\nSELECT DISTINCT L1.num as ConsecutiveNums \\nFROM\\n\\nLogs L1 JOIN Logs L2\\nON L1.num = L2.num and L2.id - L1.id = 1\\n\\nJOIN Logs L3\\non L2.num = L3.num and L3.id - L2.id = 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT L1.num as ConsecutiveNums \\nFROM\\n\\nLogs L1 JOIN Logs L2\\nON L1.num = L2.num and L2.id - L1.id = 1\\n\\nJOIN Logs L3\\non L2.num = L3.num and L3.id - L2.id = 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908675,
                "title": "indexing-with-join-operation",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutivenums from logs l1 \\njoin logs l2 on l1.id = l2.id+1 and l1.num = l2.num  \\njoin logs l3 on l1.id = l3.id+2 and l1.num = l3.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect distinct l1.num as consecutivenums from logs l1 \\njoin logs l2 on l1.id = l2.id+1 and l1.num = l2.num  \\njoin logs l3 on l1.id = l3.id+2 and l1.num = l3.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3866747,
                "title": "mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\nselect distinct A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582251,
                "title": "simple-mysql-solution-using-select",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere b.id=a.id-1 and c.id=a.id+1 and a.num=b.num and b.num=c.num;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct a.num as ConsecutiveNums from logs a, logs b, logs c\\nwhere b.id=a.id-1 and c.id=a.id+1 and a.num=b.num and b.num=c.num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3339622,
                "title": "correct-approach-to-get-the-answer-in-three-3-lines",
                "content": "# EASY UNDERSTANDING\\n       select  distinct  num  as  ConsecutiveNums  from  logs\\n       where  ( ( id + 1 , num )  in  ( select * from  logs ) )   and\\n       ( ( id + 2 , num )  in ( select  *  from  logs ) )",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# EASY UNDERSTANDING\\n       select  distinct  num  as  ConsecutiveNums  from  logs\\n       where  ( ( id + 1 , num )  in  ( select * from  logs ) )   and\\n       ( ( id + 2 , num )  in ( select  *  from  logs ) )",
                "codeTag": "Unknown"
            },
            {
                "id": 2801130,
                "title": "oracle-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT DISTINCT num AS ConsecutiveNums \\n  FROM logs l \\n WHERE l.num = ( SELECT num \\n                   FROM logs \\n\\t\\t          WHERE id = l.id+1\\n\\t\\t        ) AND \\n        l.num = ( SELECT num \\n                  FROM logs \\n\\t\\t         WHERE id = l.id+2\\n\\t\\t        );\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT DISTINCT num AS ConsecutiveNums \\n  FROM logs l \\n WHERE l.num = ( SELECT num \\n                   FROM logs \\n\\t\\t          WHERE id = l.id+1\\n\\t\\t        ) AND \\n        l.num = ( SELECT num \\n                  FROM logs \\n\\t\\t         WHERE id = l.id+2\\n\\t\\t        );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2584833,
                "title": "simple-mysql",
                "content": "\\tselect distinct l1.num as ConsecutiveNums from logs l1, logs l2, logs l3\\n\\twhere l1.id=l2.id-1 and l1.id=l3.id-2\\n\\tand l1.num=l2.num and l1.num=l3.num",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tselect distinct l1.num as ConsecutiveNums from logs l1, logs l2, logs l3\\n\\twhere l1.id=l2.id-1 and l1.id=l3.id-2\\n\\tand l1.num=l2.num and l1.num=l3.num",
                "codeTag": "Unknown"
            },
            {
                "id": 2559254,
                "title": "simple-solution-with-lag",
                "content": "```\\nwith t as (\\n    select num, \\n    lag(num) over(order by id) as prev_num, \\n    lag(num, 2) over(order by id) as pprev_num from logs\\n)\\n\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere t.num = t.prev_num and t.num = t.pprev_num\\n```",
                "solutionTags": [],
                "code": "```\\nwith t as (\\n    select num, \\n    lag(num) over(order by id) as prev_num, \\n    lag(num, 2) over(order by id) as pprev_num from logs\\n)\\n\\nselect distinct num as ConsecutiveNums\\nfrom t\\nwhere t.num = t.prev_num and t.num = t.pprev_num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2554031,
                "title": "sql-easy-self-join-solution",
                "content": "self joining and comparing the id values and by incrementing and comparing num values.\\n```\\nSELECT DISTINCT l1.num  ConsecutiveNums\\nfrom logs l1\\njoin logs l2 on l1.id=l2.id+1 and l1.num=l2.num\\njoin logs l3 on l1.id=l3.id+2 and l1.num=l3.num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT l1.num  ConsecutiveNums\\nfrom logs l1\\njoin logs l2 on l1.id=l2.id+1 and l1.num=l2.num\\njoin logs l3 on l1.id=l3.id+2 and l1.num=l3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2539036,
                "title": "mysql-2-simple-solutions",
                "content": "```\\n# Write your MySQL query statement below\\n\\n# 1st solution\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3 \\nWHERE l1.id=l2.id-1 AND l2.id=l3.id-1 AND l1.num=l2.num AND l2.num=l3.num\\n\\n-----------------------------------------------------\\n# # 2nd Solution\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) IN (SELECT * FROM Logs) AND (Id + 2, Num) IN (SELECT * FROM Logs)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n# 1st solution\\nSELECT DISTINCT l1.num AS ConsecutiveNums\\nFROM Logs l1, Logs l2, Logs l3 \\nWHERE l1.id=l2.id-1 AND l2.id=l3.id-1 AND l1.num=l2.num AND l2.num=l3.num\\n\\n-----------------------------------------------------\\n# # 2nd Solution\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM Logs\\nWHERE (Id + 1, Num) IN (SELECT * FROM Logs) AND (Id + 2, Num) IN (SELECT * FROM Logs)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2510165,
                "title": "mysql-consecutive-numbers-sol-500ms",
                "content": "```\\nselect distinct a1.num as ConsecutiveNums\\nfrom logs a1 join logs a2 on a1.id = a2.id + 1 and a1.num = a2.num\\njoin logs a3 on a1.id = a3.id + 2 and a1.num = a3.num\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct a1.num as ConsecutiveNums\\nfrom logs a1 join logs a2 on a1.id = a2.id + 1 and a1.num = a2.num\\njoin logs a3 on a1.id = a3.id + 2 and a1.num = a3.num\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2491554,
                "title": "by-using-only-where-clause",
                "content": "select distinct l1.num as ConsecutiveNums from Logs l1, Logs l2, Logs l3\\nwhere l1.id = l2.id-1 and l2.id=l3.id-1 \\nand l1.num=l2.num  and l2.num=l3.num",
                "solutionTags": [],
                "code": "select distinct l1.num as ConsecutiveNums from Logs l1, Logs l2, Logs l3\\nwhere l1.id = l2.id-1 and l2.id=l3.id-1 \\nand l1.num=l2.num  and l2.num=l3.num",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564841,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 2012993,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570345,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1723899,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576891,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575398,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569001,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569942,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570518,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570260,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1564841,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 2012993,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570345,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1723899,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576891,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1575398,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569001,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1569942,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570518,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1570260,
                "content": [
                    {
                        "username": "uttara223",
                        "content": "Although it is little unlikely, imagine doing 3 self joins for the Logs table with million rows. Windows functions to the rescue. Though this solution is slower for smaller tables, it will work better for larger tables.\\n\\nSELECT distinct num ConsecutiveNums\\nFROM\\n(SELECT id, num, \\n           lag(num) over (order by id) as before,\\n           lead(num) over (order by id) as after\\n\\nFROM logs) next_prev\\nWHERE num=before and before =after"
                    },
                    {
                        "username": "Bhavyapriya",
                        "content": "[@hailing_liu](/hailing_liu) before is a keyword in mysql that\\'s why there is a error"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@hailing_liu](/hailing_liu) You can use lead(num,2) instead for lag\\n"
                    },
                    {
                        "username": "hailing_liu",
                        "content": "is there a mistake using \\'as before\\', I got error at that step. When I change it to prev, it works."
                    },
                    {
                        "username": "mohitsharma2692000",
                        "content": "Everyone posting solutions in the discussion box is beyond me now."
                    },
                    {
                        "username": "confusd1",
                        "content": "\\nselect distinct l1.num from logs l1,logs l2,logs l3\\nwhere l1.id = l2.id+1 and l2.Id=l3.Id+1 \\nand l1.Num=l2.Num and l2.Num=l3.Num"
                    },
                    {
                        "username": "rohitahuja823",
                        "content": "Select distinct(num) as ConsecutiveNums\\nfrom(\\n    Select id,num,\\n    lag(num) over(order by id) as prev_num,\\n    lead(num) over(order by id) as next_num\\n    from Logs\\n) sq\\nwhere sq.num = sq.prev_num and sq.prev_num = sq.next_num"
                    },
                    {
                        "username": "janbrook566",
                        "content": "with cte as\\n(\\nselect id,num,lead(num) over(order by id) as nxt,lag(num) over(order by id) as prev\\nfrom Logs\\n)\\n\\nselect  distinct num as ConsecutiveNums from cte where num = nxt and num = prev"
                    },
                    {
                        "username": "vtsl_gpt",
                        "content": "With cte_num AS (Select Num AS V1, LEAD(num,1) Over (order by id) AS V2, LEAD(num,2) Over (order by id) AS V3  From Logs)\\nSelect V1 AS ConsecutiveNums from cte_num \\nwhere V1=V2\\nAnd V2=V3"
                    },
                    {
                        "username": "hpnhxxwn",
                        "content": "Hi all,\\n\\nI'm new to MySQL. I don't quite understand why below query gives run time error?\\n\\nselect L1.Num as ConsecutiveNums from Logs L1, Logs L2, Logs L3\\nWhere L1.Id=L2.Id-1 and L2.Id=L3.Id-1 \\nand L1.Num=L2.Num and L2.Num=L3.Num\\n\\nThank you!"
                    },
                    {
                        "username": "user1037kb",
                        "content": "I\\'m also new to MySQL. \\n\\nI tried putting parentheses on two conditions, where\\n1) checking if they had consecutive Ids,\\n2) checking if they had same numbers.\\n\\nHere is your code added with parentheses, under WHERE clause\\n``` sql\\nWhere (L1.Id=L2.Id-1 and L2.Id=L3.Id-1)  -- condition 1)\\nand (L1.Num=L2.Num and L2.Num=L3.Num) -- condition 2)\\n```"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "[@chandramoulikintada](/chandramoulikintada) SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "chandramoulikintada",
                        "content": "put distinct(l1.num)"
                    },
                    {
                        "username": "Kallaf",
                        "content": "[solution](https://github.com/Kallaf/LeetCode/blob/master/consecutive-numbers.mysql)"
                    },
                    {
                        "username": "srjefers",
                        "content": "Same can be done by join, but there you are using more momory since you are creating three tables with tha same data. Using some window functions could be better."
                    },
                    {
                        "username": "SIMONZHANGZP",
                        "content": "with a as (SELECT id,num,row_number() over (ORDER BY id) as rn\\nfrom logs)\\nselect distinct a1.num ConsecutiveNums\\nfrom a a1 join a a2 \\non a1.rn = a2.rn -1 and a1.num = a2.num\\njoin a a3 \\non a1.rn = a3.rn-2 and a1.num = a3.num"
                    },
                    {
                        "username": "dishantkhanna",
                        "content": "\\'\\'\\'select A.Num as ConsecutiveNums\\nfrom Logs A, Logs B, Logs C\\nwhere A.Num=B.num and B.num=C.num\\nand A.Id=B.Id+1\\nand A.Id=C.Id+2\\n\\'\\'\\'"
                    }
                ]
            },
            {
                "id": 1576547,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1576529,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1576217,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1575200,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1574803,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1574675,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1573730,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1573254,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 1572978,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 2076376,
                "content": [
                    {
                        "username": "raman777",
                        "content": "with cte as (select id, num,lag(num,1) over (order by id) as lagnum,lead(num,1) over(order by id) as leadnum from Logs)\\nselect distinct num as ConsecutiveNums from cte where num=lagnum and num=leadnum and leadnum=lagnum"
                    },
                    {
                        "username": "ashkumar220389",
                        "content": "\\'\\'\\'\\nwith result as \\n    (SELECT *,\\n\\tid- Cast(Row_number() OVER(partition BY num\\n\\t\\t\\t\\t\\t\\tORDER BY id) AS SIGNED) AS grp\\n        FROM logs)\\nSELECT  DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;\\n\\'\\'\\'"
                    },
                    {
                        "username": "Pritam_ath",
                        "content": "is it correct for consecutive"
                    },
                    {
                        "username": "leetcode018",
                        "content": "Why the window function dense_rank() cannot work well here?\\nI can run the code correctly. But when submitting this code, I have the problem of \\'out of range\\'\\n\\n\\'\\'\\'\\nwith t as\\n(select num, id-dense_rank() over(partition by num order by id) grp\\nfrom logs)\\n\\nselect num consecutivenums\\nfrom t\\ngroup by num, grp\\nhaving count(*) >= 3;\\'\\'\\'"
                    },
                    {
                        "username": "lzhou893",
                        "content": "maybe should add CAST \\n\\n\\nwith result as\\n(SELECT *,\\nid- CAST(rank() OVER(partition BY num\\nORDER BY id) AS SIGNED)  AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom result\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "Manju0077",
                        "content": "# it\\'s working fine\\nwith cte as\\n(SELECT *,\\nid-dense_rank() OVER(partition BY num\\nORDER BY id) AS grp\\nFROM logs)\\nSELECT DISTINCT num AS ConsecutiveNums\\nfrom cte\\ngroup by num, grp\\nhaving count(1) >=3;"
                    },
                    {
                        "username": "kunal93v",
                        "content": "\\'\\'\\'\\nselect distinct L1.Num as ConsecutiveNums\\nfrom Logs L1, Logs L2, Logs L3\\nwhere L1.Id = L2.Id - 1\\nand\\nL1.Id = L3.Id - 2\\nand\\n(\\nL1.Num = L2.Num and\\n    L1.Num = L3.Num\\n)\\n\\'\\'\\'"
                    },
                    {
                        "username": "zqtzoe",
                        "content": "with mid as(\\nselect *, lag(num,1)over(order by Id) prev1,\\n    lead(num,1)over(order by Id) next1\\n    from logs\\n    order by Id\\n)\\nselect distinct num as ConsecutiveNums\\nfrom mid\\nwhere num=prev1 and num=next1"
                    },
                    {
                        "username": "logosgzz",
                        "content": "\\n\\'\\'\\'\\nSELECT DISTINCT Num AS ConsecutiveNums\\nFROM (SELECT Num, LEAD(Num, 1) OVER() AS Num1, LEAD(Num, 2) OVER() AS Num2\\n      FROM Logs AS a) AS b\\nWHERE Num = Num1 AND Num = Num2\\n\\'\\'\\'"
                    },
                    {
                        "username": "loopi",
                        "content": "# Write your MySQL query statement below\\n\\n\\nselect distinct l1.num as ConsecutiveNums\\nfrom \\nlogs l1\\njoin\\nlogs l2\\njoin\\nlogs l3\\non \\nl1.id+1=l2.id and\\nl1.num=l2.num and\\nl2.id+1=l3.id and\\nl3.num=l2.num\\n"
                    },
                    {
                        "username": "salmanansari99",
                        "content": "17 of 21 Test cases passed\\n\\n##### Step 1 : Identify Consecutive Records in Inner Query \\n\\n 1. To find out consecutive rows by comparing current row(L1) with previous row (L2)\\n 2.  Mark consecutive values as 1\\n\\n##### Step 2 : Select results in Outer Query**\\n1. Group by Num\\n2. Select any records where consective is 1\\n3. Having 3 or more occurances\\n4. Select top result ( if any )\\n~~~\\nselect Num as ConsecutiveNums  from (\\nselect Id,Num, ( select case when L2.Num = L1.Num then 1 else 0 end from Logs L2 where L2.Id = L1.Id -1 ) as PrevNum from Logs L1 \\n) abc\\nwhere PrevNum = 1\\ngroup by Num \\nhaving  count(PrevNum) >= 2\\norder by count(PrevNum) desc\\n~~~"
                    },
                    {
                        "username": "shodas",
                        "content": "[Select distinct a.Num as ConsecutiveNUms\\nfrom Logs as a\\nINNER JOIN \\nLogs as b\\non a.ID = b.ID+1\\nINNER JOIN \\nLogs as c\\non a.ID = c.ID+2\\nwhere a.Num = b.Num\\nand a.Num = c.Num\\n]"
                    },
                    {
                        "username": "user5460vN",
                        "content": "SELECT A.num as ConsecutiveNums\\nFROM (\\n    SELECT COUNT(id) AS count_id, num\\n    FROM Logs\\n    GROUP BY num\\n    HAVING count_id > 3\\n) AS A;"
                    }
                ]
            },
            {
                "id": 2055133,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 2034541,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 2033887,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 2009540,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1987675,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1981201,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1968192,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1964519,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1964515,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1928129,
                "content": [
                    {
                        "username": "snow3002",
                        "content": "It\\'s easy to misread the instructions here, if a number appears 3 times consecutively more than once (e.g. 3,3,3,4,5,6,3,3,3) you still only include it in the solution once"
                    },
                    {
                        "username": "jay146",
                        "content": " `with data as\\n(select num,\\nlead(num,1) over(order by num ) as  x1,\\nlead(num,2) over(order by num ) as x2\\nfrom Logs\\n)select  distinct num as ConsecutiveNums from data\\nWHERE x1 = num + 1 AND x2 = num + 2; @`"
                    },
                    {
                        "username": "KarenaLL",
                        "content": "with num_lead_lag as (\\nselect id, num,\\nlead (num) over (order by id) as lead_num,\\nlag (num) over (order by id) as lag_num\\nfrom Logs\\n)\\nselect distinct num as ConsecutiveNums\\nfrom number_lag_lead\\nwhere num = lead_num\\nand num = lag_num;"
                    },
                    {
                        "username": "Anish_sd",
                        "content": "WITH CTE AS (\\n  SELECT id, num, LEAD(num,1) OVER (ORDER BY id) AS next_num,LEAD(num,2) OVER (ORDER BY id) AS next_next_num \\n  FROM Logs\\n)\\n\\nSELECT num AS ConsecutiveNums FROM CTE\\nwhere num = next_num = next_next_num;\\n\\n\\nCan somebody tell me what is wrong with this code?"
                    },
                    {
                        "username": "KISAN_GHOSH",
                        "content": "select case when count(num)>=3 then num\\nelse null end \\nas ConsecutiveNums from Logs;\\n\\nis my code wrong??\\n"
                    },
                    {
                        "username": "ak302",
                        "content": "Insufficient test cases\\n\\nSince it is very much possible that a row which belongs to a set of 3 consecutive \\'num\\' values of the \\'Logs\\' table can get deleted, why a test case has not been designed for that? Since this is very much a practical scenario, such a testcase should be designed so that people are forced to solve the question in a more appropriate way.\\n\\nFor e.g., if Logs table is \\nid     Num\\n1        1\\n2        1\\n3        1\\n4        1\\n\\nWe should have a testcase after deletion of id=3, i.e. the testcase will look like: \\n\\nid    Num\\n1       1\\n2       1\\n4       1\\n\\nAs many people are just checking (id+1,Num) and (id+2,Num) in Logs table for a given (id,Num), their solution will fail for this testcase."
                    },
                    {
                        "username": "Zivko",
                        "content": "WITH CTE AS\n(SELECT *, SUM (num) OVER (ORDER BY id ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING) AS Sum_num\nFROM Logs)\n\nSELECT COUNT(*) AS ConsecutiveNums\nFROM CTE\nWHERE Sum_Num % 3 = 0"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to use lag, don\\'t use word before:\\n# Write your MySQL query statement below\\n\\nselect distinct num as ConsecutiveNums\\nfrom (\\n    select num,\\n    lag(num) over (order by id ) as before_num,\\n    lead(num) over (order by id) as after\\n    from logs\\n) subquery\\nwhere num = before_num and num = after\\n\\n"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "https://leetcode.com/problems/consecutive-numbers/submissions/991094773/"
                    },
                    {
                        "username": "Mragya",
                        "content": "select num as ConsecutiveNums \\nfrom \\n(select \\nnum,\\navg(num) over (rows between 1 preceding and current row) as av_val,\\navg(num) over (rows between current row and 1 following) as sb_val\\nfrom logs ) a\\nwhere num = av_val\\nand av_val = sb_val\\ngroup by 1\\nhaving count(1) =2"
                    }
                ]
            },
            {
                "id": 1894173,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1891502,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1886034,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1885098,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1876500,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1840378,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1834277,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1823743,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1812353,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1811468,
                "content": [
                    {
                        "username": "a31122099",
                        "content": "I used \"start of group\" sql pattern in this task.\\nI think it\\'s the best for this task."
                    },
                    {
                        "username": "eparfitt1002",
                        "content": "Here\\'s my very complicated solution LOL : \\nWITH CTE1 as (\\n  SELECT id , num , lag(num,1) OVER (ORDER BY id ASC) as \"LastNum\" , lag(num,2) OVER (ORDER BY id ASC) as \"LastNum2\"\\n  FROM Logs\\n)\\nSELECT DISTINCT b.num as \"ConsecutiveNums\"\\nFROM CTE1 as a \\n  LEFT JOIN Logs as b \\n      ON (a.id = b.id) and (a.LastNum = b.num) and (a.LastNum2 = b.num)\\nWHERE \\nb.num IS NOT NULL"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT DISTINCT(a.num) as ConsecutiveNums\\nFROM Logs as a, Logs as b, Logs as c\\nWHERE a.id + 1 = b.id AND b.id + 1 = c.id AND a.num = b.num and b.num = c.num"
                    },
                    {
                        "username": "user8428J",
                        "content": "select distinct l.num as ConsecutiveNums\\nfrom\\n(select id, num, lead(num) over(order by id) as \\'next\\', lag(num) over(order by id) as \\'prev\\'\\nfrom logs) as l\\nwhere l.num=l.next and l.num=l.prev"
                    },
                    {
                        "username": "challaarun",
                        "content": "SELECT DISTINCT num as ConsecutiveNums FROM\\n\\t   ( SELECT *,\\n       case when num = lead(num) over(order by id) \\n       and num = lead(num,2) over(order by id) \\n       then num \\n       else null \\n       end as ConsecutiveNums \\n       from logs\\n     ) as x\\nWHERE x.ConsecutiveNums is not null;"
                    },
                    {
                        "username": "mdnahidulislam125",
                        "content": "select \\n(Case\\n   when count(num)>2 then num\\n   end ) as \\'ConsecutiveNums\\' \\n\\n from logs ;"
                    },
                    {
                        "username": "akashkmr032",
                        "content": "select num as ConsecutiveNums\\nfrom Logs\\ngroup by num\\nhaving count(num)>3"
                    },
                    {
                        "username": "manoj_rayi_369",
                        "content": "why this is not working\\n `select if(count(num)>=3,num,\\'\\') as ConsecutiveNums from logs group by num\\norder by count(num) desc\\nlimit 1;`"
                    },
                    {
                        "username": "Aryansingh10",
                        "content": "i used oracle my query is showing run time error can anyone explain why\\nwith cte1 as(\\nselect lead(num,1) over(order by num) as num1 from logs\\n),cte2 as\\n(\\nselect lead(num1,1) over(order by num1) as num2 from cte1\\n)\\nselect a.num as consecutivenums from logs a join cte2 b join cte1 c\\non a.num=b.num2 and a.num=c.num1"
                    },
                    {
                        "username": "abhishek0155",
                        "content": "SELECT DISTINCT num AS ConsecutiveNums\\nFROM (\\n  SELECT num, \\n         LEAD(num) OVER (ORDER BY id) AS next_num,\\n         LEAD(num, 2) OVER (ORDER BY id) AS next_next_num\\n  FROM Logs\\n) AS t\\nWHERE num = next_num AND num = next_next_num"
                    }
                ]
            },
            {
                "id": 1798581,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1783851,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1774651,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1771052,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1770055,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1767919,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1761908,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1750843,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1736853,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1736542,
                "content": [
                    {
                        "username": "keshavgarg1454",
                        "content": " `Easiest and Fastest way`\\nselect * from\\n(select distinct\\ncase\\nwhen num= (lead(num,2) over(order by id)) and num= (lead(num,1) over(order by id))  then num\\nend as ConsecutiveNums\\nfrom Logs\\n) a\\nwhere a.ConsecutiveNums is not null"
                    },
                    {
                        "username": "Kutima1998",
                        "content": " `your inline code...your inline code...`\\nSELECT DISTINCT A.NUM AS ConsecutiveNums\\nFROM LOGS A\\nJOIN LOGS B ON A.ID = B.ID+1 AND A.NUM = B.NUM\\nJOIN LOGS C ON A.ID = C.ID+2 AND A.NUM = C.NUM"
                    },
                    {
                        "username": "Ellen_Lan",
                        "content": "can -1 = -1 = -1?\\nI tried to do something like\\n\"Where L.num = L1.num = L2. num\"\\nbut it went wrong for -1 case"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT L1.num AS ConsecutiveNums FROM Logs L1, Logs L2, Logs L3\\nWHERE L1.num = L2.num\\nAND L1.num = L3.num\\nAND L2.id = L1.id + 1\\nAND L3.id = L2.id + 1\\nGROUP BY L1.num;"
                    },
                    {
                        "username": "seemakurtiarun",
                        "content": "Hello, Can we simply not use min of num & fetch the output why do we need to implement CTE over here? Learning SQL please let me know your thoughts."
                    },
                    {
                        "username": "Eshita_22",
                        "content": "with x as\\n(\\n    select id, num, \\n    lead(num,1) over(order by id desc) rn1, \\n    lead(num,2) over(order by id desc) rn2\\n    from Logs\\n)\\nselect distinct num ConsecutiveNums from x\\nwhere num = rn1 and num = rn2"
                    },
                    {
                        "username": "mohitjaraut",
                        "content": "Can anyone suggest, why am I getting this strange problem, where if I assign alias ConsecutiveNums to \\'num\\' during extraction from a derived table, it completely changes the output to:\\n3\\n3\\n\\notherwise, it works just fine.\\n\\n`select num \\nfrom (select id, num, lead(num,1,null) over() as 2nd_row, lead(num,2,null) over() as 3rd_row \\nfrom logs) a\\nwhere (num = 2nd_row and 2nd_row = 3rd_row)`"
                    },
                    {
                        "username": "chanchal21pes",
                        "content": "select distinct a.num as ConsecutiveNums\\nfrom logs a\\nwhere exists (select 1 from logs b where a.id+1 = b.id and a.num=b.num)\\nand exists (select 1 from logs c where a.id+2 = c.id and a.num=c.num)"
                    },
                    {
                        "username": "Ansh123",
                        "content": " `select distinct a.num as ConsecutiveNums from \\n(select num, num-lag(num) over (order by id) as lag_num,num-lead(num) over(order by id) as lead_num\\nfrom Logs)a \\nwhere a.lag_num=0 and a.lead_num=0`"
                    },
                    {
                        "username": "divyanshuparg",
                        "content": "\"a\" should be used before SQL as they are not vowels "
                    }
                ]
            },
            {
                "id": 1734397,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1722840,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1719668,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1714715,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1705254,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1692697,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1682725,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1682689,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1672485,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            },
            {
                "id": 1666852,
                "content": [
                    {
                        "username": "Harsh__Tanwar",
                        "content": "SELECT DISTINCT NUM ConsecutiveNums FROM LOGS L1\\nWHERE EXISTS (SELECT * FROM LOGS L2 WHERE L1.NUM=L2.NUM AND L1.ID-1 = L2.ID)\\nAND EXISTS(SELECT * FROM LOgS L3 WHERE L1.NUM = L3.NUM AND L1.ID+1 = L3.Id)"
                    },
                    {
                        "username": "Paramesh_sareshi",
                        "content": "SELECT distinct num as ConsecutiveNums from (\\nselect id, num, \\nLAG(num, 2) over (order by id) as BFR2,\\nLAG(num, 1) over (order by id) as BFR,\\nLead(num, 1) over (order by id) as AFR,\\nLead(num, 2) over (order by id) as AFR2\\nfrom Logs ) as x\\nwhere (num=BFR and num=AFR) or (num=AFR and num=BFR and BFR=BFR2) or (num=BFR and num=AFR and BFR=AFR2);\\n\\nthis suits from all cases"
                    },
                    {
                        "username": "rahuljishu",
                        "content": "/* Write your T-SQL query statement below */\n\nselect distinct s1.num as ConsecutiveNums from \nLogs s1\njoin Logs s2 on s1.num=s2.num\njoin Logs s3 on s1.num=s3.num\nwhere s1.id=s2.id+1 and s1.id=s3.id+2"
                    },
                    {
                        "username": "suyalmukesh",
                        "content": "select distinct(num) as ConsecutiveNums from \\n(\\nselect num,\\ncase when num = aa.a and num = aa.b  then num \\n     end as ConsecutiveNums\\n     from \\n(\\nselect num , \\nlead(num,1) over (order by id)a,\\nlead(num,2) over (order by id)b\\nfrom logs\\n)aa\\n)my_set\\nwhere ConsecutiveNums is not null;"
                    },
                    {
                        "username": "tushar03engineer",
                        "content": "can anyone please help with issue with my approach?\\n\\nselect distinct num from ( select num,LEAD(num, 1) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount,LEAD(num, 2) OVER (\\nPARTITION BY num\\nORDER BY id ASC\\n) AS Lead_amount_2\\nFROM Logs ) as a where Lead_amount=num and Lead_amount_2=num;\\n\\n\\nLogs =\\n| id | num |\\n| -- | --- |\\n| 1  | 1   |\\n| 2  | 1   |\\n| 3  | 1   |\\n| 4  | 2   |\\n| 5  | 1   |\\n| 6  | 2   |\\n| 7  | 2   |\\nOutput\\n| num |\\n| --- |\\n| 1   |\\n| 2   |\\nExpected\\n| ConsecutiveNums |\\n| --------------- |\\n| 1               |\\n\\n\\n"
                    },
                    {
                        "username": "Atulfs",
                        "content": "select l1.num as ConsecutiveNums\\nfrom Logs l1\\njoin Logs l2\\non l1.id=1+l2.id\\nand l1.num=l2.num\\njoin Logs l3\\non 1+l3.id=l2.id\\nand l3.num=l2.num"
                    },
                    {
                        "username": "ArielleWu",
                        "content": "Method 1: join tables \\nMethod 2: Use lag() and lead()\\n` \\n/* Method 1: join tables \\nSELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num\\n*/\\n\\n# Method 2: Use lag() and lead()\\nSELECT distinct a.num as ConsecutiveNums\\nFROM(\\nSELECT \\n\\tlag(num) OVER(ORDER BY id) AS prev_num,\\n    num,\\n\\tlead(num) OVER(ORDER BY id) AS next_num\\nFROM Logs\\n) a\\nWHERE a.num = a.prev_num AND a.num = a.next_num\\n`\\n"
                    },
                    {
                        "username": "ArielleWu",
                        "content": " `SELECT DISTINCT\\n    l1.Num AS ConsecutiveNums\\nFROM\\n    Logs l1,\\n    Logs l2,\\n    Logs l3\\nWHERE\\n    l1.Id = l2.Id - 1\\n    AND l2.Id = l3.Id - 1\\n    AND l1.Num = l2.Num\\n    AND l2.Num = l3.Num`\\n\\nNotice that this question asks us to provide the number(s) that occur at least three times (CONSECUTIVELY). "
                    },
                    {
                        "username": "user8309vy",
                        "content": "What is wrong with this?\\n `CREATE FUNCTION GetIDValue ( ID_value INT )\\nRETURNS INT\\n\\nBEGIN\\n\\n   DECLARE Value INT;\\n   select num into Value from Logs where id = ID_value;\\n    return Value;\\nEND;\\n\\nselect num as ConsecutiveNums from Logs where num = GetIDValue(id +1) and num = GetIDValue(id+2)`"
                    },
                    {
                        "username": "pallavisv21",
                        "content": "SQL Server Solution :\\n `SELECT \\n           distinct num as ConsecutiveNums \\nfrom\\n       (\\n           SELECT \\n           num,\\n           lead(num) over(order by id) as lead, \\n           lag(num) over(order by id) as lag \\n           from Logs\\n      )a \\nwhere a.num = a.lag and a.num == a.lead`\\n   "
                    }
                ]
            }
        ]
    },
    {
        "title": "Wiggle Sort",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1574148,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1568055,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1792566,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794914,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794852,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1571523,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1847651,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1801339,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793488,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793455,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1574148,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1568055,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1792566,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794914,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1794852,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1571523,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1847651,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1801339,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793488,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            },
            {
                "id": 1793455,
                "content": [
                    {
                        "username": "laodasb",
                        "content": "If you learned discreted mathematics...I\\' m sure that you may need a proof,  here is it, if I was wrong, please correct me, thanks.\\n\\nWe claim that: **If we make odd-indexed element larger than its neighbour elements, it can result a wiggle sorted array.**\\n\\n**Base case: **\\n\\nwhen index i is 0 or 1, that \\'s good--->[2],[2,3].\\nif  i == 2, we simply swap elements to result a array [x,y,z], and y is larger than x and z, the claim is also good.**\\n\\n**Assumption:**\\n\\nAssume that our claim is good for i == k, we need to prove it is also true for i== k+1:\\n\\n4 cases:\\n\\tcase1:i is odd, nums[i-1] smaller: good.\\n\\tcase2:i is odd, nums[i-1] larger:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is smaller...\\n\\tcase3:i is even, nums[i-1] larger:good.\\n\\tcase4:i is even,nums[i-1] smaller:then,swap(i,i-1)--->doesn\\'t matter previous sorted array, because nums[i] is larger.\\n\\t\\nConclusion: \\n\\tFrom above proof, no matter the newly element is an odd-indexed or even-indexed, only if we make the odd-indexed element larger than its neighbour elements, we maintain a wiggle sort array.\\n\\n\\n"
                    },
                    {
                        "username": "reddddddd",
                        "content": "I could not find any example where we cannot wiggle sort an array. \\n\\nBut, do we have a formal proof that every array can be wiggle sorted ?"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "the criteria states <= and >= so an array of all the same elements, eg [1,1,1,1,1,1], is a valid wiggle sort."
                    },
                    {
                        "username": "user8228j",
                        "content": "For Python, if you are reassigning the entire value of the nums array at once, instead of doing \\nnums = ...\\ndo nums[:] = ...\\nThat way python doesnt create a new local variable nums with the same name"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "did you use nums.sort() to sort it in place?"
                    },
                    {
                        "username": "rajs217",
                        "content": "Observation.\\nOne array with increasing order\\nOne array with decreasing order\\n\\nMerge them to the same length of original array.\\n\\neg: \\nOriginal Array: [3,5,2,1,6,4]\\nIncreasing Order Array: [ 1,2,3,4,5,6]\\nDecreasing Order Array: [6,5,4,3,2,1]\\n\\nMerge them ( merge doesnt mean directly add, one element from increasing array and in next turn one element from decreasing array )\\n\\n[1,6,2,5,3,4] ( stop length is same as orignal array )\\n\\nFOR ODD LENGTH OF ARRAY\\n\\nsame steps as even length but in the and add one extra element from increasing array."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "The question can be **reworded** as\\n> **Reorder** given array in such a manner that \"every element at an `odd index` is greater than or equal to its adjoining elements at `even indices`\""
                    },
                    {
                        "username": "johnsonys",
                        "content": "Given an unsorted array nums, reorder it in-place such that nums[0] < nums[1] > nums[2] < nums[3]...\\nFor example, given nums = [1, 1, 1, 3, 3, 3, 2, 2, 2], one possible answer is [1, 3, 2, 3, 2, 3, 1, 2, 1].\\n\\nNote: the difference between this and the former question is that two adjacent number cannot be the same."
                    },
                    {
                        "username": "AlecLC",
                        "content": "My professor would be happy that bubble sort has an actual use lol"
                    },
                    {
                        "username": "mushroom_in_rain",
                        "content": "This one is more like \\'easy\\' for me instead of \\'medium\\' .... Many questions marked as easy but require much more time to think of, like the question #734 from last week."
                    },
                    {
                        "username": "kmp1084",
                        "content": "The O(N) method is genius :)"
                    },
                    {
                        "username": "ajinkyagavane",
                        "content": "*** APPROACH 1****\nTwo hints: I hope you don't need the second hint ;)\n\n**** HINT 1 ****\nObserve alternate terms in the condition: nums[0] <= nums[1] >= nums[2] <= nums[3]...\nPut them under two lists such that all the numbers in list1 are less than all the numbers in list2\n\n*\n*\n*\n**** HINT 2 ****\nWhat if nums[0] >= nums[2], and nums[1] >= nums[3]? \n- we still satisfy the given condition\n\nThus, if we have a sorted list1, and list2.. we should arrive at the solution with a little rearrangement.\n\n\n*** APPROACH 2 ****\n**** HINT *****\nPerhaps, traverse the list and satisfy the given condition in a pairwise fashion."
                    }
                ]
            }
        ]
    },
    {
        "title": "Insert Delete GetRandom O(1)",
        "question_content": "<p>Implement the <code>RandomizedSet</code> class:</p>\n\n<ul>\n\t<li><code>RandomizedSet()</code> Initializes the <code>RandomizedSet</code> object.</li>\n\t<li><code>bool insert(int val)</code> Inserts an item <code>val</code> into the set if not present. Returns <code>true</code> if the item was not present, <code>false</code> otherwise.</li>\n\t<li><code>bool remove(int val)</code> Removes an item <code>val</code> from the set if present. Returns <code>true</code> if the item was present, <code>false</code> otherwise.</li>\n\t<li><code>int getRandom()</code> Returns a random element from the current set of elements (it&#39;s guaranteed that at least one element exists when this method is called). Each element must have the <b>same probability</b> of being returned.</li>\n</ul>\n\n<p>You must implement the functions of the class such that each function works in&nbsp;<strong>average</strong>&nbsp;<code>O(1)</code>&nbsp;time complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]\n[[], [1], [2], [2], [], [1], [2], []]\n<strong>Output</strong>\n[null, true, false, true, 2, true, false, 2]\n\n<strong>Explanation</strong>\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li>At most <code>2 *&nbsp;</code><code>10<sup>5</sup></code> calls will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.</li>\n\t<li>There will be <strong>at least one</strong> element in the data structure when <code>getRandom</code> is called.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 85401,
                "title": "java-solution-using-a-hashmap-and-an-arraylist-along-with-a-follow-up-131-ms",
                "content": "I got a similar question for my phone interview. The difference is that the duplicated number is allowed. So, think that is a follow-up of this question.\\nHow do you modify your code to allow duplicated number?\\n \\n```\\npublic class RandomizedSet {\\n    ArrayList<Integer> nums;\\n    HashMap<Integer, Integer> locs;\\n    java.util.Random rand = new java.util.Random();\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        nums = new ArrayList<Integer>();\\n        locs = new HashMap<Integer, Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean contain = locs.containsKey(val);\\n        if ( contain ) return false;\\n        locs.put( val, nums.size());\\n        nums.add(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        boolean contain = locs.containsKey(val);\\n        if ( ! contain ) return false;\\n        int loc = locs.get(val);\\n        if (loc < nums.size() - 1 ) { // not the last one than swap the last one with this val\\n            int lastone = nums.get(nums.size() - 1 );\\n            nums.set( loc , lastone );\\n            locs.put(lastone, loc);\\n        }\\n        locs.remove(val);\\n        nums.remove(nums.size() - 1);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return nums.get( rand.nextInt(nums.size()) );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedSet {\\n    ArrayList<Integer> nums;\\n    HashMap<Integer, Integer> locs;\\n    java.util.Random rand = new java.util.Random();\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        nums = new ArrayList<Integer>();\\n        locs = new HashMap<Integer, Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        boolean contain = locs.containsKey(val);\\n        if ( contain ) return false;\\n        locs.put( val, nums.size());\\n        nums.add(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        boolean contain = locs.containsKey(val);\\n        if ( ! contain ) return false;\\n        int loc = locs.get(val);\\n        if (loc < nums.size() - 1 ) { // not the last one than swap the last one with this val\\n            int lastone = nums.get(nums.size() - 1 );\\n            nums.set( loc , lastone );\\n            locs.put(lastone, loc);\\n        }\\n        locs.remove(val);\\n        nums.remove(nums.size() - 1);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return nums.get( rand.nextInt(nums.size()) );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85422,
                "title": "ac-c-solution-unordered-map-vector",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (m.find(val) != m.end()) return false;\\n        nums.emplace_back(val);\\n        m[val] = nums.size() - 1;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (m.find(val) == m.end()) return false;\\n        int last = nums.back();\\n        m[last] = m[val];\\n        nums[m[val]] = last;\\n        nums.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\nprivate:\\n    vector<int> nums;\\n    unordered_map<int, int> m;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (m.find(val) != m.end()) return false;\\n        nums.emplace_back(val);\\n        m[val] = nums.size() - 1;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (m.find(val) == m.end()) return false;\\n        int last = nums.back();\\n        m[last] = m[val];\\n        nums[m[val]] = last;\\n        nums.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\nprivate:\\n    vector<int> nums;\\n    unordered_map<int, int> m;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85397,
                "title": "simple-solution-in-python",
                "content": "We just keep track of the index of the added elements, so when we remove them, we copy the last one into it.\\n\\nFrom Python docs (https://wiki.python.org/moin/TimeComplexity) we know that `list.append()` takes O(1), both average and amortized. Dictionary `get` and `set` functions take O(1) average, so we are OK.\\n\\n```\\nimport random\\n\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        self.nums, self.pos = [], {}\\n        \\n    def insert(self, val):\\n        if val not in self.pos:\\n            self.nums.append(val)\\n            self.pos[val] = len(self.nums) - 1\\n            return True\\n        return False\\n        \\n\\n    def remove(self, val):\\n        if val in self.pos:\\n            idx, last = self.pos[val], self.nums[-1]\\n            self.nums[idx], self.pos[last] = last, idx\\n            self.nums.pop(); self.pos.pop(val, 0)\\n            return True\\n        return False\\n            \\n    def getRandom(self):\\n        return self.nums[random.randint(0, len(self.nums) - 1)]\\n\\n# 15 / 15 test cases passed.\\n# Status: Accepted\\n# Runtime: 144 ms\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\n\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        self.nums, self.pos = [], {}\\n        \\n    def insert(self, val):\\n        if val not in self.pos:\\n            self.nums.append(val)\\n            self.pos[val] = len(self.nums) - 1\\n            return True\\n        return False\\n        \\n\\n    def remove(self, val):\\n        if val in self.pos:\\n            idx, last = self.pos[val], self.nums[-1]\\n            self.nums[idx], self.pos[last] = last, idx\\n            self.nums.pop(); self.pos.pop(val, 0)\\n            return True\\n        return False\\n            \\n    def getRandom(self):\\n        return self.nums[random.randint(0, len(self.nums) - 1)]\\n\\n# 15 / 15 test cases passed.\\n# Status: Accepted\\n# Runtime: 144 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455253,
                "title": "python-super-efficient-detailed-explanation",
                "content": "In python, creating a simple api for a set() would be a perfect solution if not for the third operation, getRandom(). We know that we can retrieve an item from a set, and not know what that item will be, but that would not be actually random. (This is due to the way python implements sets. In python3, when using integers, elements are popped from the set in the order they appear in the underlying \\nhashtable. Hence, not actually random.)\\n\\nA set is implemented essentially the same as a dict in python, so the time complexity of add / delete is on average O(1). When it comes to the random function, however, we run into the problem of needing to convert the data into a python list in order to return a random element. That conversion will add a significant overhead to getRandom, thus slowing the whole thing down.\\n\\nInstead of having to do that type conversion (set to list) we can take an approach that involves maintaining both a list and a dictionary side by side. That might look something like:\\n\\n```\\ndata_map == {4: 0, 6: 1, 2: 2, 5: 3}\\ndata == [4, 6, 2, 5]\\n```\\n\\nNotice that the key in the `data_map` is the element in the list, and the value in the `data_map` is the index the element is at in the list. \\n\\nLet\\'s look at the implementation:\\n\\n```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.data_map = {} # dictionary, aka map, aka hashtable, aka hashmap\\n        self.data = [] # list aka array\\n\\n    def insert(self, val: int) -> bool:\\n\\n        # the problem indicates we need to return False if the item \\n        # is already in the RandomizedSet---checking if it\\'s in the\\n        # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val in self.data_map:\\n            return False\\n\\n        # add the element to the dictionary. Setting the value as the \\n        # length of the list will accurately point to the index of the \\n        # new element. (len(some_list) is equal to the index of the last item +1)\\n        self.data_map[val] = len(self.data)\\n\\n        # add to the list\\n        self.data.append(val)\\n        \\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n\\n        # again, if the item is not in the data_map, return False. \\n        # we check the dictionary instead of the list due to lookup complexity\\n        if not val in self.data_map:\\n            return False\\n\\n        # essentially, we\\'re going to move the last element in the list \\n        # into the location of the element we want to remove. \\n        # this is a significantly more efficient operation than the obvious \\n        # solution of removing the item and shifting the values of every item \\n        # in the dicitionary to match their new position in the list\\n        last_elem_in_list = self.data[-1]\\n        index_of_elem_to_remove = self.data_map[val]\\n\\n        self.data_map[last_elem_in_list] = index_of_elem_to_remove\\n        self.data[index_of_elem_to_remove] = last_elem_in_list\\n\\n        # change the last element in the list to now be the value of the element \\n        # we want to remove\\n        self.data[-1] = val\\n\\n        # remove the last element in the list\\n        self.data.pop()\\n\\n        # remove the element to be removed from the dictionary\\n        self.data_map.pop(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n        # if running outside of leetcode, you need to `import random`.\\n        # random.choice will randomly select an element from the list of data.\\n        return random.choice(self.data)\\n```\\n\\nNotes:\\n\\n1) this can be made more efficient by removing the variables `last_elem_in_list` and `index_of_elem_to_remove`. I have used this to aid in readability. \\n2) the remove operation might appear complicated so here\\'s a before and after of what the data looks like:\\n\\n```\\nelement_to_remove = 7\\n\\nbefore:     [4, 7, 9, 3, 5]\\nafter:      [4, 5, 9, 3]\\n\\nbefore:     {4:0, 7:1, 9:2, 3:3, 5:4}\\nafter:      {4:0, 9:2, 3:3, 5:1}\\n```\\n\\nAll we\\'re doing is replacing the element in the list that needs to be removed with the last element in the list. And then we update the values in the dictionary to reflect that.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndata_map == {4: 0, 6: 1, 2: 2, 5: 3}\\ndata == [4, 6, 2, 5]\\n```\n```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.data_map = {} # dictionary, aka map, aka hashtable, aka hashmap\\n        self.data = [] # list aka array\\n\\n    def insert(self, val: int) -> bool:\\n\\n        # the problem indicates we need to return False if the item \\n        # is already in the RandomizedSet---checking if it\\'s in the\\n        # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val in self.data_map:\\n            return False\\n\\n        # add the element to the dictionary. Setting the value as the \\n        # length of the list will accurately point to the index of the \\n        # new element. (len(some_list) is equal to the index of the last item +1)\\n        self.data_map[val] = len(self.data)\\n\\n        # add to the list\\n        self.data.append(val)\\n        \\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n\\n        # again, if the item is not in the data_map, return False. \\n        # we check the dictionary instead of the list due to lookup complexity\\n        if not val in self.data_map:\\n            return False\\n\\n        # essentially, we\\'re going to move the last element in the list \\n        # into the location of the element we want to remove. \\n        # this is a significantly more efficient operation than the obvious \\n        # solution of removing the item and shifting the values of every item \\n        # in the dicitionary to match their new position in the list\\n        last_elem_in_list = self.data[-1]\\n        index_of_elem_to_remove = self.data_map[val]\\n\\n        self.data_map[last_elem_in_list] = index_of_elem_to_remove\\n        self.data[index_of_elem_to_remove] = last_elem_in_list\\n\\n        # change the last element in the list to now be the value of the element \\n        # we want to remove\\n        self.data[-1] = val\\n\\n        # remove the last element in the list\\n        self.data.pop()\\n\\n        # remove the element to be removed from the dictionary\\n        self.data_map.pop(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n        # if running outside of leetcode, you need to `import random`.\\n        # random.choice will randomly select an element from the list of data.\\n        return random.choice(self.data)\\n```\n```\\nelement_to_remove = 7\\n\\nbefore:     [4, 7, 9, 3, 5]\\nafter:      [4, 5, 9, 3]\\n\\nbefore:     {4:0, 7:1, 9:2, 3:3, 5:4}\\nafter:      {4:0, 9:2, 3:3, 5:1}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858286,
                "title": "python3-hashmap-list-got-this-in-google-phone-interview",
                "content": "I had this problem a long time ago in a phone interview with Google and passed it with a hint from the interviewer. Here is what happened:\\n - I started to give the most naive approach.\\n - **init**: create a empty list ```arr```. O(1)\\n - **insert**: Append a new ```val``` to the ```arr```. O(1)\\n - **remove**: Find the index of the ```val``` in the array using ```self.arr.index(val)```, and remove it. O(n)\\n - **getRandom**: random.choice(self.arr) O(1)\\n\\nThe time complexity is O(n) for **remove**, which is not right. So I started to optimize it.\\n - I knew that the indices in the array were important, but I wasn\\'t sure why or what to do with them. So I just created an empty hashmap ```indices```, while talking to the interviewer just to buy myself some time and hopping to get some information from the interviewer.\\n - I modified ```insert``` and ```remove``` by updating the indices when there is a new ```val```, or I need to remove a ```val```.\\n - **Then I got stuck**, I started thinking (and also talking to the interviewer) about how to get the index of ```val``` in ```arr```, will binary search work here somehow? (obviously, I\\'m on the wrong track because remove an element in a list is O(n))\\n - The interviewer was kindly enough and said, **Think about how to remove an element in a list in O(1)**)\\n - **There is only one way, which is arr.pop()**\\n - Then I started to think in this direction, **If I want to remove an element, I need to put it to the end of the ```arr```, and pop it**\\n - What about the element which was originally at the end? I can put it to the position where the ```val``` need to be removed.\\n - Then the algorithm is obvious, \\n (1) Get the index ```i``` of the ```val``` from ```indices```.\\n (2) Update the index of ```arr[-1]``` to ```i``` in the ```indices```, \\n (3) Move the last element ```arr[-1]``` to the i th position.\\n (4) ```pop``` the last element from ```arr``` and remove ```val``` from ```indices```.\\n \\n```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        # Store the index of each val in self.arr.\\n        self.indices = {}\\n        # Store all vals.\\n        self.arr = []\\n\\n    def insert(self, val: int) -> bool:\\n        # Return False if val is already present as requested.\\n        if val in self.indices: return False\\n        \\n        # Append val to the array.\\n        # Store its index in the hashmap\\n        self.arr.append(val)\\n        self.indices[val] = len(self.arr)-1\\n        return True\\n    \\n    def remove(self, val: int) -> bool:\\n        # Return False if val is not present as requested.\\n        if val not in self.indices: return False\\n        \\n        # Get the index of the val that needs to be removed.\\n        i = self.indices[val]\\n        \\n        # Update the index of arr[-1] in the indices.\\n        self.indices[self.arr[-1]] = i\\n        \\n        # Move the last element to the i th position.\\n        self.arr[i] = self.arr[-1]\\n        \\n        # remove the last element, and remove the index of val\\n        self.indices.pop(val)\\n        self.arr.pop()\\n        \\n        return True\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.arr)\\n```\\n\\nNow try the follow up question **[381. Insert Delete GetRandom O(1) - Duplicates allowed](https://leetcode.com/submissions/detail/877869802/)**\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```arr```\n```val```\n```arr```\n```val```\n```self.arr.index(val)```\n```indices```\n```insert```\n```remove```\n```val```\n```val```\n```val```\n```arr```\n```arr```\n```val```\n```i```\n```val```\n```indices```\n```arr[-1]```\n```i```\n```indices```\n```arr[-1]```\n```pop```\n```arr```\n```val```\n```indices```\n```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        # Store the index of each val in self.arr.\\n        self.indices = {}\\n        # Store all vals.\\n        self.arr = []\\n\\n    def insert(self, val: int) -> bool:\\n        # Return False if val is already present as requested.\\n        if val in self.indices: return False\\n        \\n        # Append val to the array.\\n        # Store its index in the hashmap\\n        self.arr.append(val)\\n        self.indices[val] = len(self.arr)-1\\n        return True\\n    \\n    def remove(self, val: int) -> bool:\\n        # Return False if val is not present as requested.\\n        if val not in self.indices: return False\\n        \\n        # Get the index of the val that needs to be removed.\\n        i = self.indices[val]\\n        \\n        # Update the index of arr[-1] in the indices.\\n        self.indices[self.arr[-1]] = i\\n        \\n        # Move the last element to the i th position.\\n        self.arr[i] = self.arr[-1]\\n        \\n        # remove the last element, and remove the index of val\\n        self.indices.pop(val)\\n        self.arr.pop()\\n        \\n        return True\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377728,
                "title": "c-optimal-array-unordered-map-commented-explained-solution-average-time-o-1",
                "content": "**Approach:**\\n\\nThe order of elements is not important in the data structure. If we use an array as the data structure, insertion at the end will be in O(1) time but searching whether the element is already present in the array will take O(N) time. Removal of the element will require searching for the element which will take O(N) time and left shifting the subsequent array elements will also take O(N) time. Getting random element will take O(1) time using the rand() function. So, we need some additional data structure that allows us to locate the array index for removal and also to search whether the element is already present or not. This data structure should do these tasks in **average O(1) time**. Hashmap fulfils our requirements.\\n\\n**Optimal Solution** \\n\\n\\n```\\nclass RandomizedSet {\\n\\t// Average Time O(1) & Auxiliary Space O(N)\\nprivate:\\n    vector<int> a; // array vector\\n    unordered_map<int,int> m; // Unordered Map does searching, insertion & deletion of element in average O(1) time\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    // No need to initialise a & m as they are initialised automatically\\n\\t// to 0 as and when their container size increases.\\n    }\\n    \\n    /** Inserts a value to the array vector. Returns true if the array did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(m.find(val)!=m.end())\\n\\t        // If val is not already present in the map, find() function  \\n\\t        // returns an iterator(m.end()) pointing to the successive memory location  \\n            // from the last element of the map. Otherwise, find() returns an iterator \\n            // pointing to val which was already present in the map.  \\n            return false;\\n        else{\\n            a.push_back(val);  // insert val at the end of the array\\n            m[val]=a.size()-1; // unordered_map[key]=value stores the array element and \\n\\t\\t\\t                   // its index as key=array element & value=array element index\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the array vector. Returns true if the array contained the specified element. */\\n    bool remove(int val) {\\n        if(m.find(val)==m.end()) // val not present in the array vector\\n            return false;\\n        else{\\n\\t        // val present in the array vector\\n\\t        // For example: a=[8,4,3,2], m={[8,0],[4,1],[3,2],[2,3]}, val=4, last=2\\n\\t        // After a[m[val]]=a.back(); a=[8,2,3,2], m={[8,0],[4,1],[3,2],[2,3]}\\n\\t        // After a.pop_back(); a=[8,2,3], m={[8,0],[4,1],[3,2],[2,3]}\\n\\t        // After m[last]=m[val]; a=[8,2,3], m={[8,0],[4,1],[3,2],[2,1]}\\n\\t        // After m.erase(val); a=[8,2,3], m={[8,0],[3,2],[2,1]}\\n            int last=a.back();  // back() fetches last element of the array vector\\n            a[m[val]]=a.back(); // m[val] locates the index of val in the array vector.\\n\\t\\t\\t\\t                // Then we copy array last element value to the val location in the array\\n            a.pop_back();\\t    // Delete the last element of the array \\n            m[last]=m[val];\\t    // In hashmap, assign index of val in array to the index of the last element   \\n            m.erase(val);\\t    // Delete the val entry from map\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the array vector */\\n    int getRandom() {\\n\\t    // rand() function gives random value in the range of 0 to RAND_MAX(whose value is 32767). x%y gives \\n \\t    // remainder when x is divided by y and this remainder is in the range of 0 to y-1.\\n\\t    // rand()%a.size() gives random value in the range of (0 to a.size()-1).\\n\\t    // a[rand()%a.size()] will give random value of array in the range of a[0] to a[a.size()-1].\\n        return a[rand()%a.size()];\\n    }\\n};\\n```\\n\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\t// Average Time O(1) & Auxiliary Space O(N)\\nprivate:\\n    vector<int> a; // array vector\\n    unordered_map<int,int> m; // Unordered Map does searching, insertion & deletion of element in average O(1) time\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    // No need to initialise a & m as they are initialised automatically\\n\\t// to 0 as and when their container size increases.\\n    }\\n    \\n    /** Inserts a value to the array vector. Returns true if the array did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(m.find(val)!=m.end())\\n\\t        // If val is not already present in the map, find() function  \\n\\t        // returns an iterator(m.end()) pointing to the successive memory location  \\n            // from the last element of the map. Otherwise, find() returns an iterator \\n            // pointing to val which was already present in the map.  \\n            return false;\\n        else{\\n            a.push_back(val);  // insert val at the end of the array\\n            m[val]=a.size()-1; // unordered_map[key]=value stores the array element and \\n\\t\\t\\t                   // its index as key=array element & value=array element index\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the array vector. Returns true if the array contained the specified element. */\\n    bool remove(int val) {\\n        if(m.find(val)==m.end()) // val not present in the array vector\\n            return false;\\n        else{\\n\\t        // val present in the array vector\\n\\t        // For example: a=[8,4,3,2], m={[8,0],[4,1],[3,2],[2,3]}, val=4, last=2\\n\\t        // After a[m[val]]=a.back(); a=[8,2,3,2], m={[8,0],[4,1],[3,2],[2,3]}\\n\\t        // After a.pop_back(); a=[8,2,3], m={[8,0],[4,1],[3,2],[2,3]}\\n\\t        // After m[last]=m[val]; a=[8,2,3], m={[8,0],[4,1],[3,2],[2,1]}\\n\\t        // After m.erase(val); a=[8,2,3], m={[8,0],[3,2],[2,1]}\\n            int last=a.back();  // back() fetches last element of the array vector\\n            a[m[val]]=a.back(); // m[val] locates the index of val in the array vector.\\n\\t\\t\\t\\t                // Then we copy array last element value to the val location in the array\\n            a.pop_back();\\t    // Delete the last element of the array \\n            m[last]=m[val];\\t    // In hashmap, assign index of val in array to the index of the last element   \\n            m.erase(val);\\t    // Delete the val entry from map\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the array vector */\\n    int getRandom() {\\n\\t    // rand() function gives random value in the range of 0 to RAND_MAX(whose value is 32767). x%y gives \\n \\t    // remainder when x is divided by y and this remainder is in the range of 0 to y-1.\\n\\t    // rand()%a.size() gives random value in the range of (0 to a.size()-1).\\n\\t    // a[rand()%a.size()] will give random value of array in the range of a[0] to a[a.size()-1].\\n        return a[rand()%a.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85425,
                "title": "java-solution-beats-99-20-using-hashmap-and-arraylist-with-explanation",
                "content": "The List is used to store numbers and serve the getRandom() method. The Map contains the mapping between the value and its index in the ArrayList. The Map helps to check whether a value is already inserted or not. The main trick is when you remove a value. ArrayList's remove method is O(n) if you remove from random location. To overcome that, we swap the values between (randomIndex, lastIndex) and always remove the entry from the end of the list. After the swap, you need to update the new index of the swapped value (which was previously at the end of the list) in the map.\\n\\n````\\npublic class RandomizedSet {\\n\\n    HashMap<Integer, Integer> valToInd;\\n    List<Integer> list;\\n    int ind = 0;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        valToInd = new HashMap<>();\\n        list = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(valToInd.containsKey(val)) return false;\\n        list.add(val);\\n        valToInd.put(val,list.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        int ind = valToInd.getOrDefault(val,-1);\\n        if(ind == -1) return false;\\n        Collections.swap(list,ind,list.size()-1);\\n        int swappedWith = list.get(ind);\\n        valToInd.put(swappedWith,ind);\\n        list.remove(list.size()-1);\\n        valToInd.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int max = list.size();\\n        int min = 0;\\n        int ind = (int)(Math.random() * (max - min) + min);\\n        return list.get(ind);\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\npublic class RandomizedSet {\\n\\n    HashMap<Integer, Integer> valToInd;\\n    List<Integer> list;\\n    int ind = 0;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        valToInd = new HashMap<>();\\n        list = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(valToInd.containsKey(val)) return false;\\n        list.add(val);\\n        valToInd.put(val,list.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        int ind = valToInd.getOrDefault(val,-1);\\n        if(ind == -1) return false;\\n        Collections.swap(list,ind,list.size()-1);\\n        int swappedWith = list.get(ind);\\n        valToInd.put(swappedWith,ind);\\n        list.remove(list.size()-1);\\n        valToInd.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int max = list.size();\\n        int min = 0;\\n        int ind = (int)(Math.random() * (max - min) + min);\\n        return list.get(ind);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683267,
                "title": "python-o-1-using-two-hash-tables-explained",
                "content": "My idea for this problem to achieve `O(1)` complexity for all three operation is to use 2 dictionaries: I called them direct dictionary `dic_direct` and inverse dictionary `dic_invert`.\\n1. In direct dictionary we keep indexes and corresponding values: for example: `0:3`, `1:4`, `2:1` means, that we have `3` values in our dictionary: `[3,4,1]`.\\n2. In invert dictionary we keep the opposite correspondences: `3:0`, `4:1`, `1:2`. Why we need to keep two dictionaries? Because we want to search quickly both by keys and by values.\\n3. `num_elem` is to count number of elements in our set (you can avoid it, but code becomes a bit more readible).\\n\\n**Insert**. When we do insert, we first check if element is already in our invert dictionary, because we are looking for value. We do it in `O(1)`. If element is not here, we just add it to the \"end\" of our dictionaries, by this I mean, we add it with biggest existing index in dicionary, increased by `1`. For example if we want to add new element `10` into  `0:3`, `1:4`, `2:1`, then we have  `0:3`, `1:4`, `2:1`, `3:10`.\\n\\n**Remove:** this one is a bit more complicated. Imagine, that we want to remove element `4` from `0:3`, `1:4`, `2:1`, `3:10`. What we need to do in this case? We find it and delete first, but now we have **gap** in our indexes: `0:3`, `2:1`, `3:10`. We can easily fix it, let us take the last element and put it into our gap, so we have `0:3`, `1:10`, `2:1` now. If we do not have **gap**, that is we removed the last element, then we do not need to do this action. In any case we have `O(1)` complexity.\\n\\n**getRandom** This one is easy, we just generate random number, uniformly distributed between `0` and `1`, multiply it by number of all elements in set and evaluate `floor` function. For example if we have 5 elements, and we generated number `0.7`, then we need to choose element number `3`. Complexity is `O(1)`.\\n\\n```\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.dic_direct = {}\\n        self.dic_invert = {}\\n        self.num_elem = 0\\n        \\n    def insert(self, val: int) -> bool:\\n        if val in self.dic_invert:\\n            return False\\n        else:\\n            self.dic_invert[val] = self.num_elem\\n            self.dic_direct[self.num_elem] = val\\n            self.num_elem += 1\\n            return True\\n        \\n    def remove(self, val):\\n        if val not in self.dic_invert:\\n            return False\\n        else:\\n            ind = self.dic_invert.pop(val)\\n            self.dic_direct.pop(ind)\\n            if ind != self.num_elem - 1:\\n                self.dic_direct[ind] = self.dic_direct[self.num_elem - 1]\\n                self.dic_invert[self.dic_direct[self.num_elem - 1]] = ind\\n                self.dic_direct.pop(self.num_elem - 1)\\n            self.num_elem -= 1\\n            return True\\n        \\n    def getRandom(self):\\n        index = floor(random.random()*self.num_elem)\\n        return self.dic_direct[index]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.dic_direct = {}\\n        self.dic_invert = {}\\n        self.num_elem = 0\\n        \\n    def insert(self, val: int) -> bool:\\n        if val in self.dic_invert:\\n            return False\\n        else:\\n            self.dic_invert[val] = self.num_elem\\n            self.dic_direct[self.num_elem] = val\\n            self.num_elem += 1\\n            return True\\n        \\n    def remove(self, val):\\n        if val not in self.dic_invert:\\n            return False\\n        else:\\n            ind = self.dic_invert.pop(val)\\n            self.dic_direct.pop(ind)\\n            if ind != self.num_elem - 1:\\n                self.dic_direct[ind] = self.dic_direct[self.num_elem - 1]\\n                self.dic_invert[self.dic_direct[self.num_elem - 1]] = ind\\n                self.dic_direct.pop(self.num_elem - 1)\\n            self.num_elem -= 1\\n            return True\\n        \\n    def getRandom(self):\\n        index = floor(random.random()*self.num_elem)\\n        return self.dic_direct[index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532391,
                "title": "javascript-easy-to-understand-map-array",
                "content": "For this problem, we need to make `insert`, `remove`, and `getRandom` all to O(1) time complexity, so it\\'s straightforward to think about using a map. With a map, we could implement the `insert` and `remove` easily with O(1) time complexity. But how about `getRandom`?\\n\\nLet\\'s take a look at what operations do we need for the `getRandom` method:\\n- Get a random number.\\n- Get the real value according to that random number.\\n\\nLooks like it\\'s pretty easy, right? We could get a random number by `Math.random`, and use an array to store index-based values.\\n\\nBut when we try to finish the code, we may find the `remove` method could not be easy, since if we use something like `splice` to remove the value in an array, it could be not O(1) depends on the implementation, and all the indexes after this element need to be updated.\\n\\nSo, here comes the final key point for this problem, how do we make it O(1) with steady indexes? Let\\'s list some clues:\\n- If we want steady indexes, then we can\\'t remove this element from the list. We must put a value here.\\n- If we wanna remove a value with O(1) in a list, it\\'s straightforward to think about removing the last value.\\n\\nCombined with these clues, it is not difficult for us to find out that we could swap the target value and the last value, then remove it. This could meet our two needs at the same time.\\n\\nAt this moment, the whole strategy is clear, so the next step is just coding:\\n\\n```js\\nclass RandomizedSet {\\n  constructor() {\\n    this.map = new Map();\\n    this.list = [];\\n  }\\n\\n  insert(val) {\\n    if (this.map.has(val)) return false;\\n    this.map.set(val, this.list.length);\\n    this.list.push(val);\\n    return true;\\n  }\\n\\n  remove(val) {\\n    if (!this.map.has(val)) return false;\\n    const idx = this.map.get(val);\\n    this._swap(idx, this.list.length - 1);\\n    this.list.pop();\\n    this.map.set(this.list[idx], idx);\\n    this.map.delete(val);\\n    return true;\\n  }\\n\\n  getRandom() {\\n    return this.list[Math.floor(Math.random() * this.list.length)];\\n  }\\n\\n  _swap(a, b) {\\n    const tmp = this.list[a];\\n    this.list[a] = this.list[b];\\n    this.list[b] = tmp;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nclass RandomizedSet {\\n  constructor() {\\n    this.map = new Map();\\n    this.list = [];\\n  }\\n\\n  insert(val) {\\n    if (this.map.has(val)) return false;\\n    this.map.set(val, this.list.length);\\n    this.list.push(val);\\n    return true;\\n  }\\n\\n  remove(val) {\\n    if (!this.map.has(val)) return false;\\n    const idx = this.map.get(val);\\n    this._swap(idx, this.list.length - 1);\\n    this.list.pop();\\n    this.map.set(this.list[idx], idx);\\n    this.map.delete(val);\\n    return true;\\n  }\\n\\n  getRandom() {\\n    return this.list[Math.floor(Math.random() * this.list.length)];\\n  }\\n\\n  _swap(a, b) {\\n    const tmp = this.list[a];\\n    this.list[a] = this.list[b];\\n    this.list[b] = tmp;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532314,
                "title": "c-hashmap-list-swap-last-element-when-remove-o-1-in-time-clean-concise",
                "content": "```c++\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mapVal2Idx;\\n    vector<int> list;\\n    \\n    bool insert(int val) {\\n        if (mapVal2Idx.count(val)) return false;\\n        mapVal2Idx[val] = list.size();\\n        list.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (!mapVal2Idx.count(val)) return false;\\n        int todoRemoveIdx = mapVal2Idx[val];\\n        mapVal2Idx.erase(val);\\n        if (todoRemoveIdx < list.size() - 1) { // if we can replace with last value\\n            int lastVal = list[list.size() - 1];\\n            list[todoRemoveIdx] = lastVal;\\n            mapVal2Idx[lastVal] = todoRemoveIdx;\\n        }\\n        list.pop_back();\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return list[rand() % list.size()];\\n    }\\n};\\n```\\nComplexity:\\n- Time: `O(1)` for all operations",
                "solutionTags": [],
                "code": "```c++\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mapVal2Idx;\\n    vector<int> list;\\n    \\n    bool insert(int val) {\\n        if (mapVal2Idx.count(val)) return false;\\n        mapVal2Idx[val] = list.size();\\n        list.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (!mapVal2Idx.count(val)) return false;\\n        int todoRemoveIdx = mapVal2Idx[val];\\n        mapVal2Idx.erase(val);\\n        if (todoRemoveIdx < list.size() - 1) { // if we can replace with last value\\n            int lastVal = list[list.size() - 1];\\n            list[todoRemoveIdx] = lastVal;\\n            mapVal2Idx[lastVal] = todoRemoveIdx;\\n        }\\n        list.pop_back();\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return list[rand() % list.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551158,
                "title": "c-o-1-solution-using-array-and-hashmap-with-explanation",
                "content": "This problem requires us to design a data structure that supports insert, remove, and getRandom in constant time O(1).\\n\\nThis solution uses two data structures, a Hash Table and a resizable array. The Hash Table maps the values to their respective indices in the array. \\n\\n**Insert Operation**\\nThis operation can be easily supported by inserting the new value to the end of the resizable array and updating its index in the Hash Table.\\n\\n**Remove Operation**\\nThis operation is a little tricky. We can easily remove any element from the Hash Table in constant time as long as we know it\\'s value. However, removing an element from the middle of the array is a costly operation. Fortunately, removing the last element of the array can be done in constant time ( using pop_back() ). We will swap the value we want to remove with the last element of the array and then remove the last element of the array.\\n\\n**getRandom Operation**\\nThis operation can be easily done by using C++ inbuilt rand() on the array.\\n\\nThe code is as follows.\\n\\n\\n\\n```\\nclass RandomizedSet {\\n    vector<int> numberList;\\n    unordered_map<int, int> hashTable;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {}\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(hashTable.find(val) != hashTable.end())\\n        {\\n            return false;\\n        }\\n        hashTable[val] = numberList.size();\\n        numberList.push_back(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(hashTable.find(val) == hashTable.end())\\n        {\\n            return false;\\n        }\\n        swap(numberList[hashTable[val]], numberList[numberList.size() - 1]);\\n        numberList.pop_back();\\n        hashTable[numberList[hashTable[val]]] = hashTable[val];\\n        hashTable.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return numberList[rand() % numberList.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    vector<int> numberList;\\n    unordered_map<int, int> hashTable;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {}\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(hashTable.find(val) != hashTable.end())\\n        {\\n            return false;\\n        }\\n        hashTable[val] = numberList.size();\\n        numberList.push_back(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(hashTable.find(val) == hashTable.end())\\n        {\\n            return false;\\n        }\\n        swap(numberList[hashTable[val]], numberList[numberList.size() - 1]);\\n        numberList.pop_back();\\n        hashTable[numberList[hashTable[val]]] = hashTable[val];\\n        hashTable.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return numberList[rand() % numberList.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858200,
                "title": "python-c-hashmap-array-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a combination of a *hashmap* and an *array* to keep track of values and provide arbitrary (by index) access in constant time. Time complexity is constant: **O(1)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Comment.** Set collections with **O(1)** access time (e.g., *set* in Python or *unordered_set* in C++) do not provide arbitrary access, they are *hashmaps*. This means that we can not query an element by it\\'s index. On the other hand, *SortedSet* (from Python\\'s sortedcontainers) and *set* (C++) store keys in order and do provide access by index, but that\\'s of at least **O(logN)** complexity. As it\\'s common in the data structure development, we can trade space for time. Namely, maintain an additional structure that allows **O(1)** access time. This is possible when we deal with continuously allocated chunks of memory (i.e., arrays), for which we know their precise position (pointer/reference) in memory and can simply shift this position by **k** to get access to the **k**-th element.\\n\\nSo our strategy will be the following.\\n1. Keep a duplicate of all values in the form of array. Now we can query values by index (a random/pseudorandom index in our case).\\n2. When we want to delete a value (by value, not by index), it should also be removed from this array. Thus, for each value we have to store it\\'s index in the array. For this, a hashmap (*dict* in *Python* or *unordered_map* in C++) suffices.\\n3. Insertion is trivial: extend the array by the given value and store its index (i.e., the last index) in the hashmap.\\n4. Deletion is tricky. When we retrieve the index of some value from the hashmap, it\\'s usually somewhere in the middle of the array. To not shift/reallocate space (that is very costly), we simply swap the last value in the array (and pop it) with the removed one. Effectively, this leads to the deletion of the queried value.\\n\\n**Python.** *dict* + *list*.\\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.vals = {}  \\n        self.idxs = []\\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.vals : return False \\n        self.vals[val] = len(self.idxs)\\n        self.idxs.append(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.vals: \\n            lst = self.idxs[-1]     \\n            pos = self.vals[val]\\n            \\n            self.vals[lst] = pos               # move last value to the space\\n            self.idxs[pos] = lst               # occupied by the queried one...\\n            \\n            self.vals.pop(val)                 # ...and delete the respective\\n            self.idxs.pop()                    # data from both structures\\n            \\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.idxs)        # as simple as that\\n```\\n\\n**C++.** *unordered_map* + *vector*.\\n```\\nclass RandomizedSet \\n{\\n    unordered_map<int,int> vals;\\n    vector<int>            idxs;\\n\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) \\n    {\\n        if (vals.count(val)) return false;\\n        vals[val] = idxs.size();\\n        idxs.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val)\\n    {\\n        if (!vals.count(val)) return false;\\n        \\n        int lst = idxs.back();\\n        int pos = vals[val];\\n        \\n        vals[lst] = pos;\\n        idxs[pos] = lst;\\n        \\n        vals.erase(val);\\n        idxs.pop_back();\\n        \\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return idxs[rand() % idxs.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.vals = {}  \\n        self.idxs = []\\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.vals : return False \\n        self.vals[val] = len(self.idxs)\\n        self.idxs.append(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.vals: \\n            lst = self.idxs[-1]     \\n            pos = self.vals[val]\\n            \\n            self.vals[lst] = pos               # move last value to the space\\n            self.idxs[pos] = lst               # occupied by the queried one...\\n            \\n            self.vals.pop(val)                 # ...and delete the respective\\n            self.idxs.pop()                    # data from both structures\\n            \\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.idxs)        # as simple as that\\n```\n```\\nclass RandomizedSet \\n{\\n    unordered_map<int,int> vals;\\n    vector<int>            idxs;\\n\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) \\n    {\\n        if (vals.count(val)) return false;\\n        vals[val] = idxs.size();\\n        idxs.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val)\\n    {\\n        if (!vals.count(val)) return false;\\n        \\n        int lst = idxs.back();\\n        int pos = vals[val];\\n        \\n        vals[lst] = pos;\\n        idxs[pos] = lst;\\n        \\n        vals.erase(val);\\n        idxs.pop_back();\\n        \\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return idxs[rand() % idxs.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85434,
                "title": "java-solution-with-two-hashmaps-easy-to-understand",
                "content": "If we assume the operation of HashMap is O(1), then we have the following solution.\\n\\n```\\nimport java.util.Random;\\n\\npublic class RandomizedSet {\\n    \\n    private Map<Integer, Integer> keyMap;\\n    private Map<Integer, Integer> valueMap;\\n\\tRandom random;\\n    int count;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        keyMap = new HashMap<>();\\n        valueMap = new HashMap<>();\\n\\t\\trandom = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (keyMap.containsKey(val)) {\\n            return false;\\n        } else {\\n            keyMap.put(val, count);\\n            valueMap.put(count, val);\\n            count = keyMap.size();\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!keyMap.containsKey(val)) {\\n            return false;\\n        } else {\\n            int valueKey = keyMap.get(val);\\n            keyMap.remove(val);\\n            if (valueKey != valueMap.size() - 1) {\\n                valueMap.put(valueKey, valueMap.get(valueMap.size() - 1));\\n                keyMap.put(valueMap.get(valueMap.size() - 1), valueKey);\\n                valueMap.remove(valueMap.size() - 1);\\n            } else {\\n                valueMap.remove(valueKey);\\n            }\\n            count = keyMap.size();\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int n = random.nextInt(keyMap.size());\\n        return valueMap.get(n);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Random;\\n\\npublic class RandomizedSet {\\n    \\n    private Map<Integer, Integer> keyMap;\\n    private Map<Integer, Integer> valueMap;\\n\\tRandom random;\\n    int count;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        keyMap = new HashMap<>();\\n        valueMap = new HashMap<>();\\n\\t\\trandom = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (keyMap.containsKey(val)) {\\n            return false;\\n        } else {\\n            keyMap.put(val, count);\\n            valueMap.put(count, val);\\n            count = keyMap.size();\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!keyMap.containsKey(val)) {\\n            return false;\\n        } else {\\n            int valueKey = keyMap.get(val);\\n            keyMap.remove(val);\\n            if (valueKey != valueMap.size() - 1) {\\n                valueMap.put(valueKey, valueMap.get(valueMap.size() - 1));\\n                keyMap.put(valueMap.get(valueMap.size() - 1), valueKey);\\n                valueMap.remove(valueMap.size() - 1);\\n            } else {\\n                valueMap.remove(valueKey);\\n            }\\n            count = keyMap.size();\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int n = random.nextInt(keyMap.size());\\n        return valueMap.get(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495119,
                "title": "java-tc-o-1-sc-o-n-using-arraylist-hashmap",
                "content": "```java\\n/**\\n * Using ArrayList & HashMap\\n *\\n * Time Complexity: All function have average O(1)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Number of values currently stored in the data structure.\\n */\\nclass RandomizedSet {\\n\\n    List<Integer> nums;\\n    Map<Integer, Integer> idxMap;\\n    Random random;\\n\\n    public RandomizedSet() {\\n        nums = new ArrayList<>();\\n        idxMap = new HashMap<>();\\n        random = new Random();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (idxMap.containsKey(val)) {\\n            return false;\\n        }\\n\\n        idxMap.put(val, nums.size());\\n        nums.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!idxMap.containsKey(val)) {\\n            return false;\\n        }\\n\\n        int idx = idxMap.get(val);\\n        int lastIdx = nums.size() - 1;\\n        if (idx != lastIdx) {\\n            int lastVal = nums.get(lastIdx);\\n            nums.set(idx, lastVal);\\n            idxMap.put(lastVal, idx);\\n        }\\n        nums.remove(lastIdx);\\n        idxMap.remove(val);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        return nums.get(random.nextInt(nums.size()));\\n    }\\n}\\n```\\n\\nSolution for Part II: [381. Insert Delete GetRandom O(1) - Duplicates allowed](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/discuss/1495123/Java-or-TC:-O(1)-or-SC:-O(N)-or-Using-ArrayList-and-HashMap)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```java\\n/**\\n * Using ArrayList & HashMap\\n *\\n * Time Complexity: All function have average O(1)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Number of values currently stored in the data structure.\\n */\\nclass RandomizedSet {\\n\\n    List<Integer> nums;\\n    Map<Integer, Integer> idxMap;\\n    Random random;\\n\\n    public RandomizedSet() {\\n        nums = new ArrayList<>();\\n        idxMap = new HashMap<>();\\n        random = new Random();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (idxMap.containsKey(val)) {\\n            return false;\\n        }\\n\\n        idxMap.put(val, nums.size());\\n        nums.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!idxMap.containsKey(val)) {\\n            return false;\\n        }\\n\\n        int idx = idxMap.get(val);\\n        int lastIdx = nums.size() - 1;\\n        if (idx != lastIdx) {\\n            int lastVal = nums.get(lastIdx);\\n            nums.set(idx, lastVal);\\n            idxMap.put(lastVal, idx);\\n        }\\n        nums.remove(lastIdx);\\n        idxMap.remove(val);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        return nums.get(random.nextInt(nums.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678412,
                "title": "solution-with-comments-easy-to-understand-c-0-1",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\nprivate:\\n    std::unordered_map<int, int> mymap;\\n    std::vector<int> list;\\npublic:\\n    RandomizedSet() {\\n        // *The constructor should initialize the member variables.*\\n        //* No need to redeclare them here.*\\n    }\\n    \\n    bool insert(int val) {\\n        //*if value already exist*\\n        if(mymap.count(val)!= 0) return false;\\n\\n        //*if not insert the val to map with value(index of list)*\\n        mymap[val] = list.size(); \\n\\n        //*add the value to list aswell*\\n        list.push_back(val); \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        // *Check if the value exists in the map*\\n        if(mymap.count(val)!=0)\\n        {\\n            // *Get the index of the value in the list*\\n            int index = mymap[val]; \\n\\n            // *Swap the value to be removed with the last value in the list*\\n            int lastvalue = list.back();  //* Get the last value*\\n\\n            //* Replace the value at the given index with the last value*   \\n            list[index] = lastvalue; \\n\\n            list.pop_back(); //* Remove the last element from the list*\\n\\n            // *Update the index of the last value in the map to reflect its new position*\\n            mymap[lastvalue] = index;\\n\\n            //* Remove the value from the map*\\n            mymap.erase(val);\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    int getRandom() {\\n        int randomIndex = std::rand() % list.size();\\n        return list[randomIndex];\\n    }\\n};\\n\\n```\\nYou better Upvote (\\u2741\\xB4\\u25E1`\\u2741)\\n\\n![ED21zjgXsAgW4ee.jpg](https://assets.leetcode.com/users/images/ef8c7ff9-30aa-4a83-9306-cc22cb63a99a_1687635763.6714256.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\nprivate:\\n    std::unordered_map<int, int> mymap;\\n    std::vector<int> list;\\npublic:\\n    RandomizedSet() {\\n        // *The constructor should initialize the member variables.*\\n        //* No need to redeclare them here.*\\n    }\\n    \\n    bool insert(int val) {\\n        //*if value already exist*\\n        if(mymap.count(val)!= 0) return false;\\n\\n        //*if not insert the val to map with value(index of list)*\\n        mymap[val] = list.size(); \\n\\n        //*add the value to list aswell*\\n        list.push_back(val); \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        // *Check if the value exists in the map*\\n        if(mymap.count(val)!=0)\\n        {\\n            // *Get the index of the value in the list*\\n            int index = mymap[val]; \\n\\n            // *Swap the value to be removed with the last value in the list*\\n            int lastvalue = list.back();  //* Get the last value*\\n\\n            //* Replace the value at the given index with the last value*   \\n            list[index] = lastvalue; \\n\\n            list.pop_back(); //* Remove the last element from the list*\\n\\n            // *Update the index of the last value in the map to reflect its new position*\\n            mymap[lastvalue] = index;\\n\\n            //* Remove the value from the map*\\n            mymap.erase(val);\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    int getRandom() {\\n        int randomIndex = std::rand() % list.size();\\n        return list[randomIndex];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858295,
                "title": "c-hashmap-faster-easy-to-understand",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(1) for all the operations***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    \\n    // mp has num val as key and index of val in arr as value\\n    \\n    unordered_map<int, int> mp;\\n    \\n    // store the val in array, for finding random number in O(1)\\n    \\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        \\n        // if val is already present in map\\n        \\n        if(mp.count(val))\\n            return false;\\n        \\n        // if val is not present in map\\n        \\n        // push val in arr\\n        \\n        arr.push_back(val);\\n        \\n        // push val in map\\n        \\n        mp[val] = arr.size() - 1;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        // if val is present in map\\n        \\n        if(mp.count(val))\\n        {\\n            // find the index of val from array\\n            \\n            int idx = mp[val];\\n            \\n            // find the last value from array\\n            \\n            int last_val = arr.back();\\n            \\n            // put the last_val at idx\\n            \\n            arr[idx] = last_val;\\n            \\n            // remove the last element from array\\n            \\n            arr.pop_back();\\n            \\n            // update the value of last_val in map\\n           \\n            mp[last_val] = idx;\\n            \\n            // remove the val from map\\n            \\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        // generate the random number from (0 to arr.size() - 1)\\n        \\n        int rand_idx = rand() % arr.size();\\n        \\n        return arr[rand_idx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    \\n    // mp has num val as key and index of val in arr as value\\n    \\n    unordered_map<int, int> mp;\\n    \\n    // store the val in array, for finding random number in O(1)\\n    \\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        \\n        // if val is already present in map\\n        \\n        if(mp.count(val))\\n            return false;\\n        \\n        // if val is not present in map\\n        \\n        // push val in arr\\n        \\n        arr.push_back(val);\\n        \\n        // push val in map\\n        \\n        mp[val] = arr.size() - 1;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        // if val is present in map\\n        \\n        if(mp.count(val))\\n        {\\n            // find the index of val from array\\n            \\n            int idx = mp[val];\\n            \\n            // find the last value from array\\n            \\n            int last_val = arr.back();\\n            \\n            // put the last_val at idx\\n            \\n            arr[idx] = last_val;\\n            \\n            // remove the last element from array\\n            \\n            arr.pop_back();\\n            \\n            // update the value of last_val in map\\n           \\n            mp[last_val] = idx;\\n            \\n            // remove the val from map\\n            \\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        // generate the random number from (0 to arr.size() - 1)\\n        \\n        int rand_idx = rand() % arr.size();\\n        \\n        return arr[rand_idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653503,
                "title": "simple-clean-and-modern-c-solution",
                "content": "Quick note for C++ developers: Stop using `rand()`.\\n\\n`rand()` is considered harmful: https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful\\n\\n```cpp\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() : seed((random_device())()) {}\\n\\n    bool insert(int val) {\\n        if (lookup.count(val)) return false;\\n        lookup[val] = values.size();\\n        values.emplace_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (!lookup.count(val)) return false;\\n        \\n        // copy the last value in the array\\n        // to the current location of the value\\n        // we want to remove\\n        values[lookup[val]] = values.back();\\n        \\n        // set the location of the last value\\n        // in the array to the current location\\n        lookup[values.back()] = lookup[val];\\n        \\n        // remove the current element\\n        values.pop_back();\\n        lookup.erase(val);\\n\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return values[uniform_int_distribution<>\\n                        (0, values.size() - 1)(seed)];\\n    }\\nprivate:\\n    unordered_map<int, int> lookup;\\n    vector<int> values;\\n    default_random_engine seed;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() : seed((random_device())()) {}\\n\\n    bool insert(int val) {\\n        if (lookup.count(val)) return false;\\n        lookup[val] = values.size();\\n        values.emplace_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (!lookup.count(val)) return false;\\n        \\n        // copy the last value in the array\\n        // to the current location of the value\\n        // we want to remove\\n        values[lookup[val]] = values.back();\\n        \\n        // set the location of the last value\\n        // in the array to the current location\\n        lookup[values.back()] = lookup[val];\\n        \\n        // remove the current element\\n        values.pop_back();\\n        lookup.erase(val);\\n\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return values[uniform_int_distribution<>\\n                        (0, values.size() - 1)(seed)];\\n    }\\nprivate:\\n    unordered_map<int, int> lookup;\\n    vector<int> values;\\n    default_random_engine seed;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356354,
                "title": "python-solution-time-complexity-insert-o-1-remove-o-1-getrandom-o-1",
                "content": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.hashTable = {}\\n        self.arr = []\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val not in self.hashTable:\\n            self.hashTable[val] = len(self.arr)\\n            self.arr.append(val)\\n            return True\\n        \\n        return False\\n        \\n        \\n        \\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.hashTable:\\n        \\n            self.hashTable[self.arr[-1]] = self.hashTable[val]\\n            self.arr[self.hashTable[val]] = self.arr[-1]\\n\\n            self.arr.pop()\\n            self.hashTable.pop(val)\\n            \\n            return True\\n        \\n        return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return random.choice(self.arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.hashTable = {}\\n        self.arr = []\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val not in self.hashTable:\\n            self.hashTable[val] = len(self.arr)\\n            self.arr.append(val)\\n            return True\\n        \\n        return False\\n        \\n        \\n        \\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.hashTable:\\n        \\n            self.hashTable[self.arr[-1]] = self.hashTable[val]\\n            self.arr[self.hashTable[val]] = self.arr[-1]\\n\\n            self.arr.pop()\\n            self.hashTable.pop(val)\\n            \\n            return True\\n        \\n        return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return random.choice(self.arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85459,
                "title": "java-solution-concise-code-with-hashmap-and-arraylist-easy-to-understand",
                "content": "```\\npublic class RandomizedSet {\\n    HashMap<Integer, Integer> map;\\n    ArrayList<Integer> list;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        map = new HashMap<Integer, Integer>();\\n        list = new ArrayList<Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) {\\n            return false;\\n        }else {\\n            map.put(val, list.size());\\n            list.add(val);\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) {\\n            return false;\\n        }else {\\n            int key = map.get(val);\\n            int lastElement = list.get(list.size() - 1);\\n            map.put(lastElement, key);\\n            list.set(key, lastElement);\\n            map.remove(val);\\n            list.remove(list.size() - 1);\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random random = new Random();\\n        return list.get( random.nextInt(list.size()) );\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedSet {\\n    HashMap<Integer, Integer> map;\\n    ArrayList<Integer> list;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        map = new HashMap<Integer, Integer>();\\n        list = new ArrayList<Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) {\\n            return false;\\n        }else {\\n            map.put(val, list.size());\\n            list.add(val);\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) {\\n            return false;\\n        }else {\\n            int key = map.get(val);\\n            int lastElement = list.get(list.size() - 1);\\n            map.put(lastElement, key);\\n            list.set(key, lastElement);\\n            map.remove(val);\\n            list.remove(list.size() - 1);\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random random = new Random();\\n        return list.get( random.nextInt(list.size()) );\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532747,
                "title": "javascript",
                "content": "```javascript\\nvar RandomizedSet = function() {\\n    this.map = {};\\n    this.values = [];\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.map[val] !== undefined) return false;\\n    this.map[val] = this.values.length;\\n    this.values.push(val);\\n    return true;\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if (this.map[val] === undefined) return false;\\n    const idx = this.map[val];\\n    delete this.map[val];\\n    const last = this.values.pop();\\n    if (this.values.length === idx) return true;\\n    this.map[last] = idx;\\n    this.values[idx] = last;\\n    return true\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    if (this.values.length === 0) return null;\\n    return this.values[Math.floor(Math.random() * this.values.length)];\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar RandomizedSet = function() {\\n    this.map = {};\\n    this.values = [];\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.map[val] !== undefined) return false;\\n    this.map[val] = this.values.length;\\n    this.values.push(val);\\n    return true;\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if (this.map[val] === undefined) return false;\\n    const idx = this.map[val];\\n    delete this.map[val];\\n    const last = this.values.pop();\\n    if (this.values.length === idx) return true;\\n    this.map[last] = idx;\\n    this.values[idx] = last;\\n    return true\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    if (this.values.length === 0) return null;\\n    return this.values[Math.floor(Math.random() * this.values.length)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85485,
                "title": "java-with-hashtable-arraylist",
                "content": "The idea is pretty straightforward. Have a HashMap so we now where are our values are in the list. Use the list to get a random number. During remove be careful how to update the map and the list itself.\\n\\n```java\\npublic class RandomizedSet {\\n\\n    Map<Integer, Integer> map = new HashMap<>();\\n    List<Integer> list = new ArrayList<>();\\n    Random rnd = new Random();\\n\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) {\\n            return false;\\n        }\\n        \\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) {\\n            return false;\\n        }\\n        \\n        int idx = map.remove(val);\\n        int last = list.remove(list.size() - 1);\\n        if(val != last) {\\n            list.set(idx, last);\\n            map.put(last, idx);\\n        }\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return list.get(rnd.nextInt(list.size()));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```java\\npublic class RandomizedSet {\\n\\n    Map<Integer, Integer> map = new HashMap<>();\\n    List<Integer> list = new ArrayList<>();\\n    Random rnd = new Random();\\n\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) {\\n            return false;\\n        }\\n        \\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)) {\\n            return false;\\n        }\\n        \\n        int idx = map.remove(val);\\n        int last = list.remove(list.size() - 1);\\n        if(val != last) {\\n            list.set(idx, last);\\n            map.put(last, idx);\\n        }\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return list.get(rnd.nextInt(list.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532784,
                "title": "explanation-of-true-o-1-solution-with-python-code",
                "content": "In order to have O(1) `insert` and `remove` operations, we need an unordered set or dict.\\nIn order to have O(1) `getRandom` operations, we need a data structure with random access. That means we need a `list`. (vector in C)\\nThe hardest part is connecting the two.\\n\\nWhat we can do is have a dictionary (map in C) that for every value we store the index in the list of that value. This way, when we need to remove an element by its value, we know what element from the list to remove without having to traverse the whole list.\\nRemoving an element from the middle of the list while preserving the order of everything else is O(N). But we don\\'t need to preserve the order. So when removing an element from the middle of the list, we can just swap it with the last element of the list, then remove the last element of the list. This makes the remove operation O(1) as whole. Care must be taken to maintain the dictionary of indexes for the swap!\\n\\nCode follows:\\n\\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.elems = []\\n        self.indexes = {}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.indexes:\\n            return False\\n\\t\\t# New element will be at the end of list\\n        self.indexes[val] = len(self.elems)\\n        self.elems.append(val)\\n        return True\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val not in self.indexes:\\n            return False\\n\\n        val_index = self.indexes[val]\\n        last = self.elems[-1]\\n\\t\\t\\n\\t\\t# We\\'re swapping the removed element with the last element in the list.\\n\\t\\t# The last element will move to the position of the element removed.\\n        if val_index < len(self.elems)-1:  # Make sure we\\'re not already last element\\n            self.elems[val_index] = last\\n            self.indexes[last] = val_index\\n\\t\\t\\n\\t\\t# Remove the last element. This is O(1).\\n        self.elems.pop()\\n\\t\\t\\n\\t\\t# The removed element no longer has an index in the list. Update dictionary.\\n        del self.indexes[val]\\n        return True\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.elems)\\n        \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.elems = []\\n        self.indexes = {}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        if val in self.indexes:\\n            return False\\n\\t\\t# New element will be at the end of list\\n        self.indexes[val] = len(self.elems)\\n        self.elems.append(val)\\n        return True\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val not in self.indexes:\\n            return False\\n\\n        val_index = self.indexes[val]\\n        last = self.elems[-1]\\n\\t\\t\\n\\t\\t# We\\'re swapping the removed element with the last element in the list.\\n\\t\\t# The last element will move to the position of the element removed.\\n        if val_index < len(self.elems)-1:  # Make sure we\\'re not already last element\\n            self.elems[val_index] = last\\n            self.indexes[last] = val_index\\n\\t\\t\\n\\t\\t# Remove the last element. This is O(1).\\n        self.elems.pop()\\n\\t\\t\\n\\t\\t# The removed element no longer has an index in the list. Update dictionary.\\n        del self.indexes[val]\\n        return True\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.elems)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858975,
                "title": "c-using-only-set-comments-added",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    set<int> st;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(!st.count(val))                                           // if val is not present in the set then put it into the set and then return true\\n        {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(st.count(val))                                            // if val is present in set then erase it from set and return true\\n        {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() \\n    {\\n        if(st.size()!=0)                                             // when stack is not empty only then we can return something\\n        {\\n            return *next(st.begin(),rand()%st.size());               // it will select randomly next element from set\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    set<int> st;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(!st.count(val))                                           // if val is not present in the set then put it into the set and then return true\\n        {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(st.count(val))                                            // if val is present in set then erase it from set and return true\\n        {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() \\n    {\\n        if(st.size()!=0)                                             // when stack is not empty only then we can return something\\n        {\\n            return *next(st.begin(),rand()%st.size());               // it will select randomly next element from set\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532825,
                "title": "c-super-simple-clean-and-short-solution-all-o-1",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n        if (m.count(val) != 0) return false;\\n        \\n        m[val] = size;\\n        v.push_back(val);\\n        size++;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (m.count(val) == 0) return false;\\n        \\n        int idx = m[val];\\n        v[idx] = v[size - 1];\\n        v.pop_back();\\n        m[v[idx]] = idx;\\n        m.erase(val);\\n        size--;\\n        \\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % size];\\n    }\\n    \\nprivate:\\n    unordered_map<int, int> m;\\n    vector<int> v;\\n    int size = 0;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n        if (m.count(val) != 0) return false;\\n        \\n        m[val] = size;\\n        v.push_back(val);\\n        size++;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (m.count(val) == 0) return false;\\n        \\n        int idx = m[val];\\n        v[idx] = v[size - 1];\\n        v.pop_back();\\n        m[v[idx]] = idx;\\n        m.erase(val);\\n        size--;\\n        \\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand() % size];\\n    }\\n    \\nprivate:\\n    unordered_map<int, int> m;\\n    vector<int> v;\\n    int size = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321789,
                "title": "c-implementation",
                "content": "Notes: Although C# List<T>.Remove is O(n) to shift the elements after removing, that operation practically becomes O(1) when the last element is removed. List<T>.Add is O(1) as the cost of doubling the size is amortized.\\n```\\n    private List<int> nums;\\n    private Dictionary<int,int> map;\\n    private Random rand;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() \\n    {\\n        map = new Dictionary<int,int>();\\n        nums = new List<int>();\\n        rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) \\n    {\\n        if (map.ContainsKey(val))\\n        {\\n            return false;\\n        }\\n        \\n        nums.Add(val);\\n        map.Add(val, nums.Count-1);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) \\n    {\\n        if (!map.ContainsKey(val))\\n        {\\n            return false;\\n        }\\n        \\n        int i = map[val];\\n        nums[i] = nums[nums.Count-1];\\n        map[nums[i]] = i;\\n        \\n        nums.RemoveAt(nums.Count-1);\\n        map.Remove(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() \\n    {\\n        return nums[rand.Next(0,nums.Count)];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private List<int> nums;\\n    private Dictionary<int,int> map;\\n    private Random rand;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() \\n    {\\n        map = new Dictionary<int,int>();\\n        nums = new List<int>();\\n        rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) \\n    {\\n        if (map.ContainsKey(val))\\n        {\\n            return false;\\n        }\\n        \\n        nums.Add(val);\\n        map.Add(val, nums.Count-1);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) \\n    {\\n        if (!map.ContainsKey(val))\\n        {\\n            return false;\\n        }\\n        \\n        int i = map[val];\\n        nums[i] = nums[nums.Count-1];\\n        map[nums[i]] = i;\\n        \\n        nums.RemoveAt(nums.Count-1);\\n        map.Remove(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() \\n    {\\n        return nums[rand.Next(0,nums.Count)];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668525,
                "title": "easy-c-solution-using-hashmap-array-with-detailed-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We\\u2019ll be using two data structures:\\n    1. unordered_map<int, int> to store indexes.\\n    2. vector to store elements.\\n- insert(): First, we\\u2019ll find the element using the map.\\n    - If not present then simply push_back to vector & add to map with last index, cz vector insert at end. ***[mp[val]=a.size()-1]***\\n    - Else we\\u2019ll return false.\\n- remove():\\n    - Find the element to be removed & change the index value with the last element in the vector. *[**a[it->second]=a.back()]***\\n    - Then pop out the last element from vector.\\n    - Now in the map change the current element index number to the element we removed Because we placed that element in place of the removed element. ***[mp[a[it->second]]=it->second]***\\n    - Erase the value from the map.\\n- getRandom():\\n    - The rand() function is used in C/C++ to generate random numbers in the range [0, RAND_MAX).\\n- **Time complexity:** O(1).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class RandomizedSet {\\npublic:\\n    vector<int>a;\\n    unordered_map<int, int> mp;\\n    \\n    /* Initialize your data structure here. */\\n    RandomizedSet() { }\\n    \\n    /* Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {   \\n        auto it=mp.find(val);\\n        if(it == mp.end())\\n        {\\n            a.push_back(val);\\n            mp[val]=a.size()-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /* Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        auto it=mp.find(val);\\n        if(it != mp.end())\\n        {\\n            a[it->second]=a.back();\\n            a.pop_back();\\n            mp[a[it->second]]=it->second;\\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /* Get a random element from the set. */\\n    int getRandom() {\\n        return a[rand()%a.size()];\\n    }\\n};\\n\\n/*\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class RandomizedSet {\\npublic:\\n    vector<int>a;\\n    unordered_map<int, int> mp;\\n    \\n    /* Initialize your data structure here. */\\n    RandomizedSet() { }\\n    \\n    /* Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {   \\n        auto it=mp.find(val);\\n        if(it == mp.end())\\n        {\\n            a.push_back(val);\\n            mp[val]=a.size()-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /* Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        auto it=mp.find(val);\\n        if(it != mp.end())\\n        {\\n            a[it->second]=a.back();\\n            a.pop_back();\\n            mp[a[it->second]]=it->second;\\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /* Get a random element from the set. */\\n    int getRandom() {\\n        return a[rand()%a.size()];\\n    }\\n};\\n\\n/*\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163782,
                "title": "python-solution",
                "content": "a list holding the elements and a hashmap mapping each element to its index:\\n```\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.s = {}\\n        self.arr = []\\n        self.length = 0\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.s:\\n            return False\\n        else:\\n            self.arr.append(val)\\n            self.length += 1\\n            self.s[val] = self.length-1\\n            return True\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.s:\\n            idx = self.s[val]\\n            last = self.arr[self.length-1]\\n            self.arr[idx] = last\\n            self.s[last] = idx\\n            del self.s[val]\\n            self.arr.pop()\\n            self.length -= 1\\n            return True\\n        else:\\n            return False\\n        \\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        idx = random.randint(0,self.length-1)\\n        return self.arr[idx]\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.s = {}\\n        self.arr = []\\n        self.length = 0\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.s:\\n            return False\\n        else:\\n            self.arr.append(val)\\n            self.length += 1\\n            self.s[val] = self.length-1\\n            return True\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.s:\\n            idx = self.s[val]\\n            last = self.arr[self.length-1]\\n            self.arr[idx] = last\\n            self.s[last] = idx\\n            del self.s[val]\\n            self.arr.pop()\\n            self.length -= 1\\n            return True\\n        else:\\n            return False\\n        \\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        idx = random.randint(0,self.length-1)\\n        return self.arr[idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131876,
                "title": "python-easy-and-clear-solution-96-ms-beats-99",
                "content": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.nums, self.ind = [], {}\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val not in self.ind: \\n            self.nums += val, \\n            self.ind[val] = len(self.nums) - 1\\n            return True\\n        return False\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.ind:\\n            ind, last = self.ind[val], self.nums[-1]\\n            self.nums[ind], self.ind[last] = last, ind\\n            self.nums.pop()\\n            self.ind.pop(val)\\n            return True\\n        return False\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        return random.choice(self.nums)\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.nums, self.ind = [], {}\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val not in self.ind: \\n            self.nums += val, \\n            self.ind[val] = len(self.nums) - 1\\n            return True\\n        return False\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.ind:\\n            ind, last = self.ind[val], self.nums[-1]\\n            self.nums[ind], self.ind[last] = last, ind\\n            self.nums.pop()\\n            self.ind.pop(val)\\n            return True\\n        return False\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        return random.choice(self.nums)\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858959,
                "title": "c-use-array-hashmap-easy-and-efficient-approach",
                "content": "```\\nclass RandomizedSet \\n {\\npublic:\\n    vector<int> nums; //for storing val\\n    unordered_map<int, int> mp; //for storing val and its index (nums)\\n    RandomizedSet() \\n    {\\n        \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp.find(val) != mp.end()) return false; //when value exist\\n        nums.push_back(val); //storing val in nums\\n        mp[val] = nums.size()-1; //storing val and its index\\n        return true;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(mp.find(val) == mp.end()) return false; //when value doesn\\'t exist\\n        auto it = mp.find(val); //find val in mp;\\n        \\n        //put a last value of nums at the index of val and remove the last index value\\n        nums[it->second] = nums.back();\\n        nums.pop_back();\\n        \\n        //update last value index in map\\n        mp[nums[it->second]] = it->second; \\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        //take any random number and do modules with size of nums \\n        //to get number lies in nums index range and return it\\n        return nums[rand()%nums.size()];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass RandomizedSet \\n {\\npublic:\\n    vector<int> nums; //for storing val\\n    unordered_map<int, int> mp; //for storing val and its index (nums)\\n    RandomizedSet() \\n    {\\n        \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp.find(val) != mp.end()) return false; //when value exist\\n        nums.push_back(val); //storing val in nums\\n        mp[val] = nums.size()-1; //storing val and its index\\n        return true;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(mp.find(val) == mp.end()) return false; //when value doesn\\'t exist\\n        auto it = mp.find(val); //find val in mp;\\n        \\n        //put a last value of nums at the index of val and remove the last index value\\n        nums[it->second] = nums.back();\\n        nums.pop_back();\\n        \\n        //update last value index in map\\n        mp[nums[it->second]] = it->second; \\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        //take any random number and do modules with size of nums \\n        //to get number lies in nums index range and return it\\n        return nums[rand()%nums.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818397,
                "title": "java-2-solutions-hashmap-arraylist",
                "content": "### **Please Upvote** :D\\n##### Naive approach:\\n```\\nclass RandomizedSet {\\n    private List<Integer> list;\\n\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (list.contains(val)) {\\n            return false;\\n        }\\n        list.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (list.contains(val)) {\\n            list.remove(Integer.valueOf(val));\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(1) - O(n) - O(1)\\n```\\n##### Optimal Solution:\\n```\\nclass RandomizedSet {\\n    private List<Integer> list;\\n    private Map<Integer, Integer> map;\\n\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) return false;\\n\\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) return false;\\n\\n        int index = map.get(val);\\n        int lastElement = list.get(list.size() - 1);\\n        list.set(index, lastElement);\\n        map.put(lastElement, index);\\n        map.remove(val);\\n        list.remove(list.size() - 1);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(1) - O(1) - O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass RandomizedSet {\\n    private List<Integer> list;\\n\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (list.contains(val)) {\\n            return false;\\n        }\\n        list.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (list.contains(val)) {\\n            list.remove(Integer.valueOf(val));\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(1) - O(n) - O(1)\\n```\n```\\nclass RandomizedSet {\\n    private List<Integer> list;\\n    private Map<Integer, Integer> map;\\n\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) return false;\\n\\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) return false;\\n\\n        int index = map.get(val);\\n        int lastElement = list.get(list.size() - 1);\\n        list.set(index, lastElement);\\n        map.put(lastElement, index);\\n        map.remove(val);\\n        list.remove(list.size() - 1);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(1) - O(1) - O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585661,
                "title": "python-hashmap-solution-with-explanation",
                "content": "# Init Function\\nTo keep everything O(1), we have to use a hashmap. \\n\\n**Why hashmap is goated:**\\n1. getting items is constant time\\n2. adding items is constant time\\n3. deleting items is constant time\\n4. checking if items exist is constant time\\n5. editing items is constant time\\n\\nHashmap is `value:index`, btw\\nSo we have a hashmap and an array.\\n\\n# Insert\\nSince nobody likes edge cases, we\\'ll take care of that first: `if val in self.dict: return False`. \\n**Digression Alert:**\\nNotice how I check it with a hashmap? That\\'s O(1). However, if I say `if val in self.list`, then it\\'s O(n). I only add and pop items from the actual list. (You\\'ll see why I pop in just a second)\\n\\n**Back on topic**\\nWe basically append the value to both the goated hashmap and the not-so-goated array:\\n1. for the hashmap, we set `val`\\'s value as the dict\\'s key and `val`\\'s index to the dict\\'s value. (ik it\\'s kinda confusing, go read it again). Since we are appending, the `val`\\'s index will ofc be the last element (length of list)\\n2. for the array, we use the append function\\n\\nAlso don\\'t forget to return true.\\n\\n# Remove\\nThe remove function for an array is O(n), but for a hashmap is O(1). But we have to do it for both. So, how?\\n\\n**Nice little trick:**\\nFact 1: the `pop()` function is O(1)\\nFact 2: you can only `pop()` the last element of an array\\nDoubt: but what if the `val` is in the middle?\\nFact 3: swapping elements is O(1)\\n\\n**THEREFORE**\\nWe swap the value we want to remove with the last value of the array, then pop that value. Ta-da! Constant time!\\n\\nNote: this gets tricky\\n1. we get the last element\\'s value and index\\n2. We set `val`\\'s position in the list to the last element of the list\\'s value\\n3. We set the `val`\\'s value in the dict to the last element of the list\\'s index\\n\\nWe basically overwrite the lsat value in the list, cuz it\\'s going to be deleted anyways. \\n\\nAnd of course we remove the last element from the list and the dict.\\n\\n# getRandom\\nThis is self explanatory. I use `random.choice(` to get a random element from the list. O(1) already, piece of cake.\\n\\n\\n\\n```py\\nclass RandomizedSet():\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dict = {}\\n        self.list = []\\n\\n        \\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val in self.dict:\\n            return False\\n        self.dict[val] = len(self.list)\\n        self.list.append(val)\\n        return True\\n        \\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.dict:\\n            last_element_val, last_element_idx = self.list[-1], self.dict[val]\\n            self.list[last_element_idx], self.dict[last_element_val] = last_element_val, last_element_idx\\n            # delete the last element\\n            self.list.pop()\\n            del self.dict[val]\\n            return True\\n        return False\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return choice(self.list)\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass RandomizedSet():\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.dict = {}\\n        self.list = []\\n\\n        \\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val in self.dict:\\n            return False\\n        self.dict[val] = len(self.list)\\n        self.list.append(val)\\n        return True\\n        \\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.dict:\\n            last_element_val, last_element_idx = self.list[-1], self.dict[val]\\n            self.list[last_element_idx], self.dict[last_element_val] = last_element_val, last_element_idx\\n            # delete the last element\\n            self.list.pop()\\n            del self.dict[val]\\n            return True\\n        return False\\n\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return choice(self.list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684251,
                "title": "javascript-clean-solution-using-map-and-array",
                "content": "```javascript\\nclass RandomizedSet {\\n    \\n    constructor() {\\n        this.map = new Map();\\n        this.arr = [];\\n    }\\n    \\n    insert(val) {\\n        if(this.map.has(val)) return false;\\n        \\n        this.map.set(val, this.arr.length);\\n        this.arr.push(val);\\n        return true;\\n    }\\n    \\n    remove(val) {\\n        if(!this.map.has(val)) return false;\\n        \\n        const valIdx = this.map.get(val);\\n        const lastIdx = this.arr.length-1;\\n        const lastNum = this.arr[lastIdx];\\n        \\n        // swap \\'val\\' with the last element\\n        [this.arr[valIdx], this.arr[lastIdx]] = [this.arr[lastIdx], this.arr[valIdx]];\\n        // pop \\'val\\' from the array\\n        this.arr.pop();\\n        // update the last element\\'s index to be \\'val\\'s\\' index\\n        this.map.set(lastNum, valIdx);\\n        // delete \\'val\\' from the map\\n        this.map.delete(val);\\n        return true;\\n    }\\n    \\n    getRandom() {\\n        const randIdx = Math.floor(Math.random() * this.arr.length);\\n        return this.arr[randIdx];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass RandomizedSet {\\n    \\n    constructor() {\\n        this.map = new Map();\\n        this.arr = [];\\n    }\\n    \\n    insert(val) {\\n        if(this.map.has(val)) return false;\\n        \\n        this.map.set(val, this.arr.length);\\n        this.arr.push(val);\\n        return true;\\n    }\\n    \\n    remove(val) {\\n        if(!this.map.has(val)) return false;\\n        \\n        const valIdx = this.map.get(val);\\n        const lastIdx = this.arr.length-1;\\n        const lastNum = this.arr[lastIdx];\\n        \\n        // swap \\'val\\' with the last element\\n        [this.arr[valIdx], this.arr[lastIdx]] = [this.arr[lastIdx], this.arr[valIdx]];\\n        // pop \\'val\\' from the array\\n        this.arr.pop();\\n        // update the last element\\'s index to be \\'val\\'s\\' index\\n        this.map.set(lastNum, valIdx);\\n        // delete \\'val\\' from the map\\n        this.map.delete(val);\\n        return true;\\n    }\\n    \\n    getRandom() {\\n        const randIdx = Math.floor(Math.random() * this.arr.length);\\n        return this.arr[randIdx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589197,
                "title": "javascript-es6-o-1-using-class-and-maps",
                "content": "* using 2 hashmaps instead of an array, to have a better guarantee that access / deletion will be in O(1)\\n(comments welcome if I am missing something like if an array in js can have element deleted in O(1))\\n\\n```javascript\\nclass RandomizedSet {\\n    constructor() {\\n        this.valMap = new Map(),\\n        this.indexMap = new Map();\\n        \\n        this.highest = -1;\\n    }\\n    \\n    insert(val) {\\n        if(this.valMap.has(val)) return false;\\n        \\n        this.highest += 1;\\n        this.valMap.set(val, this.highest);\\n        this.indexMap.set(this.highest, val);\\n        \\n        return true;\\n    }\\n    \\n    remove(val) {\\n        if(!this.valMap.has(val)) return false;\\n        \\n        const currIdx = this.valMap.get(val);\\n        const valAtLastIdx = this.indexMap.get(this.highest);\\n        this.indexMap.set(currIdx, valAtLastIdx); \\n        this.valMap.set(valAtLastIdx, currIdx);\\n        this.valMap.delete(val);\\n        this.indexMap.delete(this.highest);\\n        \\n        this.highest -= 1;\\n        \\n        return true;\\n    }\\n    \\n    getRandom() {\\n        if(this.highest < 0) return null;\\n        \\n        const rnd = this.generateRandom();\\n        return this.indexMap.get(rnd);\\n    }\\n    \\n    generateRandom() {\\n        return Math.floor(Math.random() * (this.highest + 1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass RandomizedSet {\\n    constructor() {\\n        this.valMap = new Map(),\\n        this.indexMap = new Map();\\n        \\n        this.highest = -1;\\n    }\\n    \\n    insert(val) {\\n        if(this.valMap.has(val)) return false;\\n        \\n        this.highest += 1;\\n        this.valMap.set(val, this.highest);\\n        this.indexMap.set(this.highest, val);\\n        \\n        return true;\\n    }\\n    \\n    remove(val) {\\n        if(!this.valMap.has(val)) return false;\\n        \\n        const currIdx = this.valMap.get(val);\\n        const valAtLastIdx = this.indexMap.get(this.highest);\\n        this.indexMap.set(currIdx, valAtLastIdx); \\n        this.valMap.set(valAtLastIdx, currIdx);\\n        this.valMap.delete(val);\\n        this.indexMap.delete(this.highest);\\n        \\n        this.highest -= 1;\\n        \\n        return true;\\n    }\\n    \\n    getRandom() {\\n        if(this.highest < 0) return null;\\n        \\n        const rnd = this.generateRandom();\\n        return this.indexMap.get(rnd);\\n    }\\n    \\n    generateRandom() {\\n        return Math.floor(Math.random() * (this.highest + 1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85414,
                "title": "2-python-implementations-using-dictionary-and-list-syned-and-asyned-with-explanation",
                "content": "Quite a number of people have posted their C++ code based on the same idea, which is:\\n1. A plain list does most of the job. It makes sure ```insert``` and ```getRandom``` is O(1).\\n2. The dictionary comes in handy when you need to make ```remove``` O(1). The dictionary maps the values to their indices in the list, so when you want to quickly remove something from the list, you always know where to start.\\n\\nSo, here come 2 flavors:\\n\\n**Synced version**, in which the list and dictionary are always having the same size.\\nNo actual swapping is needed for ```remove``` because the last element of the list is always going to be popped out, anyway. Don't bother to write to the last slot.\\n```\\nimport random\\nclass RandomizedSet(object):\\n    def __init__(self):\\n        self.l = []\\n        self.d = {}\\n\\n    def insert(self, val):\\n        if val in self.d:\\n            return False\\n        self.d[val] = len(self.l)\\n        self.l.append(val)\\n        return True        \\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val], self.l[-1]\\n        self.l[i], self.d[newVal] = newVal, i\\n        del self.d[val]\\n        self.l.pop()\\n        return True\\n\\n    def getRandom(self):\\n        return random.choice(self.l)\\n```\\n\\n**Asynced version**, in which I use the dict to keep track of the array size so I can avoid shrinking the list.\\n```\\nimport random\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        self.l = []\\n        self.d = {}\\n\\n    def insert(self, val):\\n        if val in self.d:\\n            return False\\n        i = len(self.d)\\n        self.d[val] = i\\n        if i < len(self.l):\\n            self.l[i] = val\\n        else:\\n            self.l.append(val)\\n        return True        \\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val], self.l[len(self.d)-1]\\n        self.l[i], self.d[newVal] = newVal, i\\n        del self.d[val]\\n        return True\\n\\n    def getRandom(self):\\n        return self.l[random.randrange(len(self.d))]\\n```\\n\\nThe first implementation is shorter and cleaner, but i may prefer the second one in real life because it has less memory expansion and shrinking.",
                "solutionTags": [],
                "code": "```insert```\n```getRandom```\n```remove```\n```remove```\n```\\nimport random\\nclass RandomizedSet(object):\\n    def __init__(self):\\n        self.l = []\\n        self.d = {}\\n\\n    def insert(self, val):\\n        if val in self.d:\\n            return False\\n        self.d[val] = len(self.l)\\n        self.l.append(val)\\n        return True        \\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val], self.l[-1]\\n        self.l[i], self.d[newVal] = newVal, i\\n        del self.d[val]\\n        self.l.pop()\\n        return True\\n\\n    def getRandom(self):\\n        return random.choice(self.l)\\n```\n```\\nimport random\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        self.l = []\\n        self.d = {}\\n\\n    def insert(self, val):\\n        if val in self.d:\\n            return False\\n        i = len(self.d)\\n        self.d[val] = i\\n        if i < len(self.l):\\n            self.l[i] = val\\n        else:\\n            self.l.append(val)\\n        return True        \\n\\n    def remove(self, val):\\n        if val not in self.d:\\n            return False\\n        i, newVal = self.d[val], self.l[len(self.d)-1]\\n        self.l[i], self.d[newVal] = newVal, i\\n        del self.d[val]\\n        return True\\n\\n    def getRandom(self):\\n        return self.l[random.randrange(len(self.d))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 85492,
                "title": "sharing-my-c-solution-with-explanation-swap-and-pop-when-remove",
                "content": "Idea is to use two data structures to do book-keeping:\\n1. unordered_map<int, int> to store <number-to-index> relationship\\n2. vector<int> to store <index-to-number> relationship\\n3. You can use the size from map or vector to determine how many elements are there but I tend to use a explicit member variable \"size\" to record as we are designing a new data structure.\\n* insert():\\nsimply add to map and push_back to vector\\nincrement size\\n* getRandom():\\ngenerate a random integer randIdx from 0 to size - 1, and simply return the element at index randIdx (from the vector)\\n* remove():\\nswap the element to be removed with the last element in the vector\\npop out the last element\\nupdate book-keeping information in both data structures\\ndecrement size\\n\\ncode in cpp:\\n```\\nclass RandomizedSet {\\n    unordered_map<int, int> index; // map of num to its index in nums array\\n    vector<int> nums; // storing the actual numbers inserted\\n    int size;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() : size(0) {\\n        /* initialize random seed: */\\n        srand (time(NULL));\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (index.find(val) != index.end())\\n            return false;\\n            \\n        nums.push_back(val);\\n        index[val] = size ++;\\n        return true;s\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (index.find(val) == index.end())\\n            return false;\\n        \\n        int back = nums.back();\\n        int backIdx = index[back];\\n        \\n        int delIdx = index[val];\\n        \\n        swap(nums[backIdx], nums[delIdx]); // swap with last element in nums\\n        nums.pop_back();\\n        \\n        index[back] = delIdx; // update last element's index in map\\n        index.erase(val); // erase val entry from map\\n        \\n        size --;\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (size <= 0) return -1; // should be an exception\\n        \\n        /* generate secret number between 0 and size - 1: */\\n        int randIdx = rand() % size;\\n        \\n        return nums[randIdx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\n    unordered_map<int, int> index; // map of num to its index in nums array\\n    vector<int> nums; // storing the actual numbers inserted\\n    int size;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() : size(0) {\\n        /* initialize random seed: */\\n        srand (time(NULL));\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (index.find(val) != index.end())\\n            return false;\\n            \\n        nums.push_back(val);\\n        index[val] = size ++;\\n        return true;s\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (index.find(val) == index.end())\\n            return false;\\n        \\n        int back = nums.back();\\n        int backIdx = index[back];\\n        \\n        int delIdx = index[val];\\n        \\n        swap(nums[backIdx], nums[delIdx]); // swap with last element in nums\\n        nums.pop_back();\\n        \\n        index[back] = delIdx; // update last element's index in map\\n        index.erase(val); // erase val entry from map\\n        \\n        size --;\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (size <= 0) return -1; // should be an exception\\n        \\n        /* generate secret number between 0 and size - 1: */\\n        int randIdx = rand() % size;\\n        \\n        return nums[randIdx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111760,
                "title": "c-simple-vector-hash-map-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a map and a vector. Map will keep track of indexes of vals  and vector for vals . At remove operation just swap the number which is to be removed and the last one and then do pop_back and also update the index of last element in map. In this way we can remove the elements and also check the element is presnt or not. \\nAnd for getRandom just return a random number presnt in the vector using `rand() ` function use `rand()%size` becuase rand() should be genrating indexes upto n-1 not beyond that .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    map<int,int>mp;\\n    vector<int>ans;\\n  \\n    bool insert(int val) {\\n        if(mp.find(val)==mp.end()){\\n        ans.push_back(val);\\n        mp[val]=ans.size()-1;\\n        }\\n        else return false;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)!=mp.end()){\\n            mp[ans.back()]=mp[val];\\n         swap(ans.back(),ans[mp[val]]);\\n         ans.pop_back();\\n        mp.erase(val);\\n        }\\n        else return false;\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return ans[rand()%mp.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Randomized"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    map<int,int>mp;\\n    vector<int>ans;\\n  \\n    bool insert(int val) {\\n        if(mp.find(val)==mp.end()){\\n        ans.push_back(val);\\n        mp[val]=ans.size()-1;\\n        }\\n        else return false;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)!=mp.end()){\\n            mp[ans.back()]=mp[val];\\n         swap(ans.back(),ans[mp[val]]);\\n         ans.pop_back();\\n        mp.erase(val);\\n        }\\n        else return false;\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return ans[rand()%mp.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463464,
                "title": "c-hashmap-96-faster-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> num;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(m.find(val)==m.end())\\n        {\\n            m[val]=num.size();\\n            num.push_back(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(m.find(val)!=m.end())\\n        {\\n            // replace the element val in num by last element of num and delete last element of num\\n            int ind=m[val];\\n            num[ind]=num[num.size()-1];\\n            m[num[num.size()-1]]=ind;\\n            num.pop_back();\\n            m.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int p=rand()%num.size();\\n        return num[p];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> num;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(m.find(val)==m.end())\\n        {\\n            m[val]=num.size();\\n            num.push_back(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(m.find(val)!=m.end())\\n        {\\n            // replace the element val in num by last element of num and delete last element of num\\n            int ind=m[val];\\n            num[ind]=num[num.size()-1];\\n            m[num[num.size()-1]]=ind;\\n            num.pop_back();\\n            m.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int p=rand()%num.size();\\n        return num[p];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532364,
                "title": "simple-to-understand-using-map-list-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\nThe main idea of this solution is to use a list to store the values added, and use a map to determine if an item has been added already.\\n\\nThe map is also used to store the list index of the added item. This makes it so we know which index to work with when we want to remove an item from the list.\\n\\nIn some testcases, values are removed in non-uniform order, so to ensure proper removal, we \\'swap\\' places of the value to remove with the last item in the list. This makes it so only the last item in the list is always the index to have items removed from.\\n\\n```\\npublic class RandomizedSet {\\n    // For randomizing the list\\n    private Random r;\\n    \\n    // To determine if an item has been added, and store its list index\\n    private Dictionary<int, int> map;\\n    \\n    // To store the items added\\n    private List<int> values;\\n\\n    public RandomizedSet() {\\n        r = new Random();\\n        map = new Dictionary<int, int>();\\n        values = new List<int>();\\n    }\\n    \\n    public bool Insert(int val) {\\n        // Determine if item exists in map\\n        if (map.ContainsKey(val)) {\\n            return false;\\n        }\\n        \\n        // Add value to the list\\n        values.Add(val);   \\n\\n        // Save the value with its list index to the map\\n        map[val] = values.Count - 1;\\n        \\n        return true;\\n    }\\n    \\n    public bool Remove(int val) {\\n        // Determine if item exists in map\\n        if (!map.ContainsKey(val)) {\\n            return false;\\n        }\\n                \\n        // Get the current index for the item to remove\\n        var currentIndex = map[val];\\n\\n        // Get the last index for the item at the end\\n        var lastIndex = values.Count - 1;\\n\\n        // \\'Swap\\' places of the last item in the list with the item to be removed\\n        values[currentIndex] = values[lastIndex];\\n\\n        // Update the map for the item that we \\'swapped\\' with its new list index\\n        map[values[currentIndex]] = currentIndex;\\n\\n        // Remove the swapped item from the list (this is the item to be removed)\\n        values.RemoveAt(lastIndex);\\n\\n        // Remove the item to be removed from the map\\n        map.Remove(val);\\n            \\n        return true;\\n    }\\n    \\n    public int GetRandom() {\\n        var randomIndex = r.Next(0, values.Count);\\n        return values[randomIndex];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedSet {\\n    // For randomizing the list\\n    private Random r;\\n    \\n    // To determine if an item has been added, and store its list index\\n    private Dictionary<int, int> map;\\n    \\n    // To store the items added\\n    private List<int> values;\\n\\n    public RandomizedSet() {\\n        r = new Random();\\n        map = new Dictionary<int, int>();\\n        values = new List<int>();\\n    }\\n    \\n    public bool Insert(int val) {\\n        // Determine if item exists in map\\n        if (map.ContainsKey(val)) {\\n            return false;\\n        }\\n        \\n        // Add value to the list\\n        values.Add(val);   \\n\\n        // Save the value with its list index to the map\\n        map[val] = values.Count - 1;\\n        \\n        return true;\\n    }\\n    \\n    public bool Remove(int val) {\\n        // Determine if item exists in map\\n        if (!map.ContainsKey(val)) {\\n            return false;\\n        }\\n                \\n        // Get the current index for the item to remove\\n        var currentIndex = map[val];\\n\\n        // Get the last index for the item at the end\\n        var lastIndex = values.Count - 1;\\n\\n        // \\'Swap\\' places of the last item in the list with the item to be removed\\n        values[currentIndex] = values[lastIndex];\\n\\n        // Update the map for the item that we \\'swapped\\' with its new list index\\n        map[values[currentIndex]] = currentIndex;\\n\\n        // Remove the swapped item from the list (this is the item to be removed)\\n        values.RemoveAt(lastIndex);\\n\\n        // Remove the item to be removed from the map\\n        map.Remove(val);\\n            \\n        return true;\\n    }\\n    \\n    public int GetRandom() {\\n        var randomIndex = r.Next(0, values.Count);\\n        return values[randomIndex];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494177,
                "title": "the-simplest-solution-c-using-set-only",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)!=s.end())\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n            return false;\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return *next(s.begin(),rand()%s.size());\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)!=s.end())\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n            return false;\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return *next(s.begin(),rand()%s.size());\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230425,
                "title": "javascript-solution-with-comments-performance-beat-100-using-array-and-map",
                "content": "```\\n/**\\n * Thoughts:\\n * 0. What is the type of the items to be inserted? Is it always a number?\\n * 1a. Keep a dynamically sized array of the items, supporting O(1) insertion\\n *     and O(1) getRandom using a randomly generated number from 0 to array length\\n * 1b. Keep a hash map of items to their index in the array. When an item\\n *     is to be removed, get index from the hash map and move last element\\n *     in the array to overwrite this index (to prevent the array from\\n *     growing sparse and breaking getRandom). Then remove the value-index\\n *     mapping from the hash map. Now we have O(1) delete.\\n * 2. Alternative approach: Depending on the answer to 0, we could use a trie\\n *    instead of a hash map + array. A trie provides O(m) insertion and deletion,\\n *    where m is the number of characters in the item key. Hash map always has to\\n *    look at the entire key, so this is still a relative O(1). If the items are\\n *    alphanumeric strings, we can do a-z nodes at the top level and binary\\n *    tree nodes below. If the items are numbers, we can stringify them and do\\n *    0-9 at the top level and binary below. It\\'s a bit trickier to equalize\\n *    the likelihood of getRandom for the trie though. Have to track number of nodes in each \\n *    branch and calculate based on that.\\n * 3. Use array/hashtable approach from 1a and 1b above (not trie from 2)\\n *\\n * Time spent: ~20 mins thinking at night + ~15 implementing + 5 + 5 (+ ~15 debugging!)\\n */\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar RandomizedSet = function() {\\n    this.map = new Map();\\n    this.array = [];\\n};\\n\\n/**\\n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    const {array, map} = this;\\n    \\n    if (map.has(val))\\n        return false;\\n    \\n    array.push(val);\\n    map.set(val, array.length - 1);\\n    \\n    // TODO account for wrong type of val or array too large?\\n    return true;\\n};\\n\\n/**\\n * Removes a value from the set. Returns true if the set contained the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    const {array, map} = this;\\n    \\n    if (!map.has(val))\\n        return false;\\n    \\n    const [last, index] = [array[array.length - 1], map.get(val)];\\n    \\n    array[index] = last;\\n    map.set(last, index);\\n    \\n    array.pop();\\n    map.delete(val);\\n    \\n    return true;    \\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number}\\n * TODO: What should behavior be on empty set?\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    const {array} = this;\\n    \\n    const r = Math.floor(array.length * Math.random());\\n    return array[r];\\n};\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = Object.create(RandomizedSet).createNew()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n * \\n * Me: I\\'ve heard that before. I bet it\\'s really instantiated like this:\\n * var obj = new RandomizedSet();\\n * Update: Actually their API worked!\\n */\\n\\n/*\\n== TESTING (cases we\\'d want to test) ==\\nsimple example (given)\\noperations on empty set\\nduplicates\\nnull/undefined values\\nnon-number values\\nnegative numbers\\nmassive numbers\\nmassive array size and number of operations\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Thoughts:\\n * 0. What is the type of the items to be inserted? Is it always a number?\\n * 1a. Keep a dynamically sized array of the items, supporting O(1) insertion\\n *     and O(1) getRandom using a randomly generated number from 0 to array length\\n * 1b. Keep a hash map of items to their index in the array. When an item\\n *     is to be removed, get index from the hash map and move last element\\n *     in the array to overwrite this index (to prevent the array from\\n *     growing sparse and breaking getRandom). Then remove the value-index\\n *     mapping from the hash map. Now we have O(1) delete.\\n * 2. Alternative approach: Depending on the answer to 0, we could use a trie\\n *    instead of a hash map + array. A trie provides O(m) insertion and deletion,\\n *    where m is the number of characters in the item key. Hash map always has to\\n *    look at the entire key, so this is still a relative O(1). If the items are\\n *    alphanumeric strings, we can do a-z nodes at the top level and binary\\n *    tree nodes below. If the items are numbers, we can stringify them and do\\n *    0-9 at the top level and binary below. It\\'s a bit trickier to equalize\\n *    the likelihood of getRandom for the trie though. Have to track number of nodes in each \\n *    branch and calculate based on that.\\n * 3. Use array/hashtable approach from 1a and 1b above (not trie from 2)\\n *\\n * Time spent: ~20 mins thinking at night + ~15 implementing + 5 + 5 (+ ~15 debugging!)\\n */\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar RandomizedSet = function() {\\n    this.map = new Map();\\n    this.array = [];\\n};\\n\\n/**\\n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    const {array, map} = this;\\n    \\n    if (map.has(val))\\n        return false;\\n    \\n    array.push(val);\\n    map.set(val, array.length - 1);\\n    \\n    // TODO account for wrong type of val or array too large?\\n    return true;\\n};\\n\\n/**\\n * Removes a value from the set. Returns true if the set contained the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    const {array, map} = this;\\n    \\n    if (!map.has(val))\\n        return false;\\n    \\n    const [last, index] = [array[array.length - 1], map.get(val)];\\n    \\n    array[index] = last;\\n    map.set(last, index);\\n    \\n    array.pop();\\n    map.delete(val);\\n    \\n    return true;    \\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number}\\n * TODO: What should behavior be on empty set?\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    const {array} = this;\\n    \\n    const r = Math.floor(array.length * Math.random());\\n    return array[r];\\n};\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = Object.create(RandomizedSet).createNew()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n * \\n * Me: I\\'ve heard that before. I bet it\\'s really instantiated like this:\\n * var obj = new RandomizedSet();\\n * Update: Actually their API worked!\\n */\\n\\n/*\\n== TESTING (cases we\\'d want to test) ==\\nsimple example (given)\\noperations on empty set\\nduplicates\\nnull/undefined values\\nnon-number values\\nnegative numbers\\nmassive numbers\\nmassive array size and number of operations\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85505,
                "title": "c-solution-using-unordered-map-and-vector",
                "content": "Hi all,\\n\\nThe idea is to keep a vector for picking a random number and hash map (unordered_map in c++) for quick insert / removal. The map keeps the indices in the vector as the value so the corresponding entry in vector can be adjusted in O(1) time.\\n\\n    class RandomizedSet {\\n    private:\\n        unordered_map<int, int> indices; // the value is the index of the key\\n        vector<int> vals;\\n    public:\\n        /** Initialize your data structure here. */\\n        RandomizedSet() {\\n            srand((int)time(0));\\n        }\\n        \\n        /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n        bool insert(int val) {\\n            unordered_map<int, int>::iterator it = indices.find(val);\\n            if (it == indices.end())   {\\n                // add the new value's index\\n                indices.insert(pair<int, int>(val, vals.size()));\\n                vals.push_back(val);\\n                \\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        /** Removes a value from the set. Returns true if the set contained the specified element. */\\n        bool remove(int val) {\\n            unordered_map<int, int>::iterator it = indices.find(val);\\n            if (it == indices.end())   {\\n                return false;\\n            }\\n            \\n            // remove val\\n            int index = it->second;\\n            vals[index] = vals[vals.size() - 1];\\n            indices.find(vals[index])->second = index;\\n            vals.pop_back();\\n            indices.erase(it);\\n\\n            return true;\\n        }\\n        \\n        /** Get a random element from the set. */\\n        int getRandom() {\\n            int pick = rand() % vals.size();\\n\\n            return vals[pick];\\n        }\\n    };",
                "solutionTags": [],
                "code": "Hi all,\\n\\nThe idea is to keep a vector for picking a random number and hash map (unordered_map in c++) for quick insert / removal. The map keeps the indices in the vector as the value so the corresponding entry in vector can be adjusted in O(1) time.\\n\\n    class RandomizedSet {\\n    private:\\n        unordered_map<int, int> indices; // the value is the index of the key\\n        vector<int> vals;\\n    public:\\n        /** Initialize your data structure here. */\\n        RandomizedSet() {\\n            srand((int)time(0));\\n        }\\n        \\n        /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n        bool insert(int val) {\\n            unordered_map<int, int>::iterator it = indices.find(val);\\n            if (it == indices.end())   {\\n                // add the new value's index\\n                indices.insert(pair<int, int>(val, vals.size()));\\n                vals.push_back(val);\\n                \\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        /** Removes a value from the set. Returns true if the set contained the specified element. */\\n        bool remove(int val) {\\n            unordered_map<int, int>::iterator it = indices.find(val);\\n            if (it == indices.end())   {\\n                return false;\\n            }\\n            \\n            // remove val\\n            int index = it->second;\\n            vals[index] = vals[vals.size() - 1];\\n            indices.find(vals[index])->second = index;\\n            vals.pop_back();\\n            indices.erase(it);\\n\\n            return true;\\n        }\\n        \\n        /** Get a random element from the set. */\\n        int getRandom() {\\n            int pick = rand() % vals.size();\\n\\n            return vals[pick];\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3904827,
                "title": "cpp-solution-hash-table",
                "content": "\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> mp; //<num , index at which num is present>\\n    vector<int> ans;\\n    RandomizedSet() \\n    {\\n        ios_base::sync_with_stdio(false);    \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp.find(val)!=mp.end())\\n        {\\n            return false;\\n        }    \\n        ans.push_back(val);\\n        mp[val]=ans.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(mp.find(val)==mp.end())\\n        {\\n            return false;\\n        }    \\n        int index = mp[val]; //index of no that has to be removed\\n        int last_ele = ans.back();\\n\\n        mp[last_ele] = index;\\n        swap(ans[index],ans[ans.size()-1]); //swapping last element and val\\n\\n        ans.pop_back(); //removing val\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return ans[rand()%ans.size()];    \\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> mp; //<num , index at which num is present>\\n    vector<int> ans;\\n    RandomizedSet() \\n    {\\n        ios_base::sync_with_stdio(false);    \\n    }\\n    \\n    bool insert(int val) \\n    {\\n        if(mp.find(val)!=mp.end())\\n        {\\n            return false;\\n        }    \\n        ans.push_back(val);\\n        mp[val]=ans.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) \\n    {\\n        if(mp.find(val)==mp.end())\\n        {\\n            return false;\\n        }    \\n        int index = mp[val]; //index of no that has to be removed\\n        int last_ele = ans.back();\\n\\n        mp[last_ele] = index;\\n        swap(ans[index],ans[ans.size()-1]); //swapping last element and val\\n\\n        ans.pop_back(); //removing val\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() \\n    {\\n        return ans[rand()%ans.size()];    \\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858191,
                "title": "c-dictionary-and-list",
                "content": "As a bonus there is a [video](https://www.youtube.com/watch?v=46dZH7LDbf8) where Neetcode creator interviews one arrogant Meta intern by using exactly the same question.\\n```\\npublic class RandomizedSet {\\n    private Random rnd = new();\\n    private Dictionary<int, int> map = new();\\n    private List<int> list = new();\\n\\n    public RandomizedSet() {}\\n    \\n    public bool Insert(int val) {\\n        if(map.ContainsKey(val)) return false;\\n        list.Add(val);\\n        map.Add(val, list.Count-1);\\n        return true;\\n    }\\n    public bool Remove(int val) {\\n        if(!map.ContainsKey(val)) return false;\\n        int lastVal = list[list.Count-1];\\n        list[list.Count-1] = val;\\n        list[map[val]] = lastVal;\\n        map[lastVal] = map[val];\\n        map.Remove(val);\\n        list.RemoveAt(list.Count-1);\\n        return true;\\n    }\\n    public int GetRandom() {\\n        int idx = rnd.Next(0, list.Count);\\n        return list[idx];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RandomizedSet {\\n    private Random rnd = new();\\n    private Dictionary<int, int> map = new();\\n    private List<int> list = new();\\n\\n    public RandomizedSet() {}\\n    \\n    public bool Insert(int val) {\\n        if(map.ContainsKey(val)) return false;\\n        list.Add(val);\\n        map.Add(val, list.Count-1);\\n        return true;\\n    }\\n    public bool Remove(int val) {\\n        if(!map.ContainsKey(val)) return false;\\n        int lastVal = list[list.Count-1];\\n        list[list.Count-1] = val;\\n        list[map[val]] = lastVal;\\n        map[lastVal] = map[val];\\n        map.Remove(val);\\n        list.RemoveAt(list.Count-1);\\n        return true;\\n    }\\n    public int GetRandom() {\\n        int idx = rnd.Next(0, list.Count);\\n        return list[idx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790366,
                "title": "this-is-why-we-love-c",
                "content": "380. Insert Delete GetRandom O(1)\\n\\nlet C# do all the under the hood magic. \\n\\n```\\npublic class RandomizedSet {\\n    \\n    HashSet<int> myHash;\\n    Random myRand;\\n\\n    public RandomizedSet() {\\n        myHash = new HashSet<int>();\\n        myRand = new Random();\\n    }\\n    \\n    public bool Insert(int val) {\\n        if(myHash.Contains(val))\\n            return false;\\n        myHash.Add(val);\\n        return true;\\n    }\\n    \\n    public bool Remove(int val) {\\n        if(myHash.Contains(val))\\n        {\\n            myHash.Remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int GetRandom() {\\n        return myHash.ElementAt(myRand.Next(myHash.Count));\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * bool param_1 = obj.Insert(val);\\n * bool param_2 = obj.Remove(val);\\n * int param_3 = obj.GetRandom();\\n */\\n ```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RandomizedSet {\\n    \\n    HashSet<int> myHash;\\n    Random myRand;\\n\\n    public RandomizedSet() {\\n        myHash = new HashSet<int>();\\n        myRand = new Random();\\n    }\\n    \\n    public bool Insert(int val) {\\n        if(myHash.Contains(val))\\n            return false;\\n        myHash.Add(val);\\n        return true;\\n    }\\n    \\n    public bool Remove(int val) {\\n        if(myHash.Contains(val))\\n        {\\n            myHash.Remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int GetRandom() {\\n        return myHash.ElementAt(myRand.Next(myHash.Count));\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * bool param_1 = obj.Insert(val);\\n * bool param_2 = obj.Remove(val);\\n * int param_3 = obj.GetRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1533092,
                "title": "easy-java-solution-with-explanations",
                "content": "\\tclass RandomizedSet {\\n\\t\\t// map contains value with it\\'s index\\n\\t\\tMap<Integer, Integer> map;\\n\\t\\t// contains values\\n\\t\\tList<Integer> allValues;\\n\\n\\t\\tpublic RandomizedSet() {\\n\\t\\t\\tmap = new HashMap<>();\\n\\t\\t\\tallValues = new ArrayList<>();\\n\\t\\t}\\n\\n\\t\\tpublic boolean insert(int val) {\\n\\t\\t\\tif (map.containsKey(val)) return false;\\n\\n\\t\\t\\tallValues.add(val);\\n\\t\\t\\t// keep track of index in array\\n\\t\\t\\tmap.put(val, allValues.size() - 1);\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tpublic boolean remove(int val) {\\n\\t\\t\\tif (!map.containsKey(val)) return false;\\n\\n\\t\\t\\t// set the index of val with last element\\n\\t\\t\\tallValues.set(map.get(val), allValues.get(allValues.size() - 1));\\n\\t\\t\\t// update index in map\\n\\t\\t\\tmap.put(allValues.get(allValues.size() - 1), map.get(val));\\n\\n\\t\\t\\tmap.remove(val);\\n\\t\\t\\t// O(1) remove\\n\\t\\t\\tallValues.remove(allValues.size() - 1);\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tpublic int getRandom() {\\n\\t\\t\\t// [0, size - 1]\\n\\t\\t\\treturn allValues.get((int)(Math.random() * allValues.size()));\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tclass RandomizedSet {\\n\\t\\t// map contains value with it\\'s index\\n\\t\\tMap<Integer, Integer> map;\\n\\t\\t// contains values\\n\\t\\tList<Integer> allValues;\\n\\n\\t\\tpublic RandomizedSet() {\\n\\t\\t\\tmap = new HashMap<>();\\n\\t\\t\\tallValues = new ArrayList<>();\\n\\t\\t}\\n\\n\\t\\tpublic boolean insert(int val) {\\n\\t\\t\\tif (map.containsKey(val)) return false;\\n\\n\\t\\t\\tallValues.add(val);\\n\\t\\t\\t// keep track of index in array\\n\\t\\t\\tmap.put(val, allValues.size() - 1);\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tpublic boolean remove(int val) {\\n\\t\\t\\tif (!map.containsKey(val)) return false;\\n\\n\\t\\t\\t// set the index of val with last element\\n\\t\\t\\tallValues.set(map.get(val), allValues.get(allValues.size() - 1));\\n\\t\\t\\t// update index in map\\n\\t\\t\\tmap.put(allValues.get(allValues.size() - 1), map.get(val));\\n\\n\\t\\t\\tmap.remove(val);\\n\\t\\t\\t// O(1) remove\\n\\t\\t\\tallValues.remove(allValues.size() - 1);\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tpublic int getRandom() {\\n\\t\\t\\t// [0, size - 1]\\n\\t\\t\\treturn allValues.get((int)(Math.random() * allValues.size()));\\n\\t\\t}\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 699791,
                "title": "python-logic-explained-simple-solution",
                "content": "```\\nclass RandomizedSet:\\n    ## RC ##\\n    ## APPROACH : HASHMAP ##\\n    #   1. Insertion operation in list is O(1) but not deletion\\n    #   2. So we create one Hashmap with key,index and other list\\n    #   3. for deleting we go to hashmap, get index, go to that index in list, swap that element with last element.\\n    #   4. save the index to last element in hashmap and delete list last element\\n\\n    def __init__(self):\\n        self.lists = []\\n        self.hmap = {}\\n        self.length = 0\\n\\n    def insert(self, val: int) -> bool:\\n        if(val in self.hmap):\\n            return False\\n        self.hmap[val] = self.length\\n        self.length += 1\\n        self.lists.append(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if(val not in self.hmap):\\n            return False\\n        index = self.hmap[val]\\n        self.hmap[self.lists[-1]] = index\\n        self.lists[index], self.lists[-1] = self.lists[-1], self.lists[index]\\n        self.lists.pop()\\n        self.hmap.pop(val)\\n        self.length -= 1\\n        return True\\n\\n    def getRandom(self) -> int:\\n        ri = random.randint(0, self.length - 1)\\n        return self.lists[ri]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass RandomizedSet:\\n    ## RC ##\\n    ## APPROACH : HASHMAP ##\\n    #   1. Insertion operation in list is O(1) but not deletion\\n    #   2. So we create one Hashmap with key,index and other list\\n    #   3. for deleting we go to hashmap, get index, go to that index in list, swap that element with last element.\\n    #   4. save the index to last element in hashmap and delete list last element\\n\\n    def __init__(self):\\n        self.lists = []\\n        self.hmap = {}\\n        self.length = 0\\n\\n    def insert(self, val: int) -> bool:\\n        if(val in self.hmap):\\n            return False\\n        self.hmap[val] = self.length\\n        self.length += 1\\n        self.lists.append(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if(val not in self.hmap):\\n            return False\\n        index = self.hmap[val]\\n        self.hmap[self.lists[-1]] = index\\n        self.lists[index], self.lists[-1] = self.lists[-1], self.lists[index]\\n        self.lists.pop()\\n        self.hmap.pop(val)\\n        self.length -= 1\\n        return True\\n\\n    def getRandom(self) -> int:\\n        ri = random.randint(0, self.length - 1)\\n        return self.lists[ri]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243033,
                "title": "a-picture-is-worth-a-thousand-words-here-is-the-clearest-explanation-for-the-classic-approach",
                "content": "Classic Approach: **hashtable + array**\\n\\nTo **Insert**, we just have to\\n1. append the item to the end of the array\\n2. add the key:index in the hashtable\\n![image](https://assets.leetcode.com/users/calvinchankf/image_1550985158.png)\\n\\n\\nTo **Remove**, we just have to\\n1. assign the last item to the target index\\n2. swap the target item and the last item\\n3. delete the key from the hashtable\\n![image](https://assets.leetcode.com/users/calvinchankf/image_1550985430.png)\\n\\n\\nTo **Random**, just randomly get a number between 0 and length of array(exclusively) and return arr[random number]\\n\\nHere is the code for your reference\\n\\n```go\\n// 32 ms, faster than 100.00%\\n\\ntype RandomizedSet struct {\\n\\tHashTable map[int]int\\n\\tArr       []int\\n}\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() RandomizedSet {\\n\\treturn RandomizedSet{make(map[int]int), []int{}}\\n}\\n\\n/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n\\tif _, x := this.HashTable[val]; x {\\n\\t\\treturn false\\n\\t}\\n\\tthis.HashTable[val] = len(this.Arr)\\n\\tthis.Arr = append(this.Arr, val)\\n\\treturn true\\n}\\n\\n/** Removes a value from the set. Returns true if the set contained the specified element. */\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n\\tif _, x := this.HashTable[val]; x {\\n\\t\\t// find the target index of the val from the hashtable\\n\\t\\ttargetIdx := this.HashTable[val]\\n\\t\\t// assign the last item to the target index\\n\\t\\tthis.HashTable[this.Arr[len(this.Arr)-1]] = targetIdx\\n\\t\\t// swap the target item and the last item\\n\\t\\tthis.Arr[targetIdx], this.Arr[len(this.Arr)-1] = this.Arr[len(this.Arr)-1], this.Arr[targetIdx]\\n\\t\\t// remove the last item\\n\\t\\tthis.Arr = this.Arr[:len(this.Arr)-1]\\n\\t\\t// delete the key from hashtable\\n\\t\\tdelete(this.HashTable, val)\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\n/** Get a random element from the set. */\\nfunc (this *RandomizedSet1) GetRandom() int {\\n\\tr := rand.Intn(len(this.Arr))\\n\\treturn this.Arr[r]\\n}\\n```\\n\\nRef:  https://www.youtube.com/watch?v=y240Qh9H9uk",
                "solutionTags": [],
                "code": "```go\\n// 32 ms, faster than 100.00%\\n\\ntype RandomizedSet struct {\\n\\tHashTable map[int]int\\n\\tArr       []int\\n}\\n\\n/** Initialize your data structure here. */\\nfunc Constructor() RandomizedSet {\\n\\treturn RandomizedSet{make(map[int]int), []int{}}\\n}\\n\\n/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n\\tif _, x := this.HashTable[val]; x {\\n\\t\\treturn false\\n\\t}\\n\\tthis.HashTable[val] = len(this.Arr)\\n\\tthis.Arr = append(this.Arr, val)\\n\\treturn true\\n}\\n\\n/** Removes a value from the set. Returns true if the set contained the specified element. */\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n\\tif _, x := this.HashTable[val]; x {\\n\\t\\t// find the target index of the val from the hashtable\\n\\t\\ttargetIdx := this.HashTable[val]\\n\\t\\t// assign the last item to the target index\\n\\t\\tthis.HashTable[this.Arr[len(this.Arr)-1]] = targetIdx\\n\\t\\t// swap the target item and the last item\\n\\t\\tthis.Arr[targetIdx], this.Arr[len(this.Arr)-1] = this.Arr[len(this.Arr)-1], this.Arr[targetIdx]\\n\\t\\t// remove the last item\\n\\t\\tthis.Arr = this.Arr[:len(this.Arr)-1]\\n\\t\\t// delete the key from hashtable\\n\\t\\tdelete(this.HashTable, val)\\n\\t\\treturn true\\n\\t}\\n\\treturn false\\n}\\n\\n/** Get a random element from the set. */\\nfunc (this *RandomizedSet1) GetRandom() int {\\n\\tr := rand.Intn(len(this.Arr))\\n\\treturn this.Arr[r]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 141493,
                "title": "c-easy-to-understand-solution-with-explanation",
                "content": "**Basic Idea:** \\n* List is used to store the numbers and serve GetRandom() method. \\n* Dictionary contains the mapping between the value and it\\'s index in the List. \\n* Dictionary helps to check whether a value is already inserted or not. \\n* The **trick** is when you **remove** a value. List\\'s RemoveAt method is O(n), if you remove from random location. To overcome that, we swap the values between (randomIndex, lastIndex) and always remove the entry from the end of the list. \\n* After the swap, you need to update the new index of the swapped value (which was previously at the end of the list) in the map.\\n```\\npublic class RandomizedSet {\\n    \\n    List<int> set;\\n    Dictionary<int, int> map;\\n    Random random;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet()\\n    {\\n        this.set = new List<int>();\\n        this.map = new Dictionary<int, int>();\\n        this.random = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val)\\n    {\\n        if (!this.map.ContainsKey(val))\\n        {\\n            this.map[val] = this.set.Count;\\n            this.set.Add(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val)\\n    {\\n        int valIndex;\\n        if (this.map.TryGetValue(val, out valIndex))\\n        {\\n            //Cache current last element in set.\\n            int lastIndexInSet = this.set.Count - 1;\\n            int lastElement = this.set[lastIndexInSet];   \\n            //Move val to be removed to last in set.\\n            this.map[val] = lastIndexInSet;   \\n            this.set[lastIndexInSet] = val;\\n            //Move cached last element to where the val to be removed was before it was move to last.\\n            this.set[valIndex] = lastElement;   \\n            this.map[lastElement] = valIndex;\\n            //Remove the last element from the set.\\n            this.set.RemoveAt(this.set.Count - 1);\\n            this.map.Remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /** Get a random element from the set. */\\n    public int GetRandom()\\n    {\\n        return this.set[this.random.Next(this.set.Count)];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class RandomizedSet {\\n    \\n    List<int> set;\\n    Dictionary<int, int> map;\\n    Random random;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet()\\n    {\\n        this.set = new List<int>();\\n        this.map = new Dictionary<int, int>();\\n        this.random = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val)\\n    {\\n        if (!this.map.ContainsKey(val))\\n        {\\n            this.map[val] = this.set.Count;\\n            this.set.Add(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val)\\n    {\\n        int valIndex;\\n        if (this.map.TryGetValue(val, out valIndex))\\n        {\\n            //Cache current last element in set.\\n            int lastIndexInSet = this.set.Count - 1;\\n            int lastElement = this.set[lastIndexInSet];   \\n            //Move val to be removed to last in set.\\n            this.map[val] = lastIndexInSet;   \\n            this.set[lastIndexInSet] = val;\\n            //Move cached last element to where the val to be removed was before it was move to last.\\n            this.set[valIndex] = lastElement;   \\n            this.map[lastElement] = valIndex;\\n            //Remove the last element from the set.\\n            this.set.RemoveAt(this.set.Count - 1);\\n            this.map.Remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /** Get a random element from the set. */\\n    public int GetRandom()\\n    {\\n        return this.set[this.random.Next(this.set.Count)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321129,
                "title": "easy-c-solution-using-unordered-set",
                "content": "\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)==s.end()){\\n            s.insert(val);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)!=s.end()){\\n            auto it=s.find(val);\\n            s.erase(it);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int n=rand()%s.size();\\n        auto it =s.begin();\\n        advance(it, n); // advances the iterator \\u2018it\\u2019 by n element positions\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)==s.end()){\\n            s.insert(val);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)!=s.end()){\\n            auto it=s.find(val);\\n            s.erase(it);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int n=rand()%s.size();\\n        auto it =s.begin();\\n        advance(it, n); // advances the iterator \\u2018it\\u2019 by n element positions\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859387,
                "title": "short-and-super-clear-set-solution",
                "content": "The built-in `HashSet` set class already has everything we need, except getting an element by index, so let\\'s use LINQ\\'s `ElementAt` method for that, even though it\\'s a bit slow:\\n```csharp\\npublic class RandomizedSet\\n{\\n    HashSet<int> set = new();\\n    Random rnd = new();\\n\\n    public bool Insert(int n) => set.Add(n);\\n    \\n    public bool Remove(int n) => set.Remove(n);\\n    \\n    public int GetRandom() => set.ElementAt(rnd.Next(set.Count));\\n}\\n```\\nTo make `GetRandom()` faster, we can convert the set to a list with `ToList()` and only then get an element by index:\\n```csharp\\nset.ToList()[rnd.Next(set.Count)];\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```csharp\\npublic class RandomizedSet\\n{\\n    HashSet<int> set = new();\\n    Random rnd = new();\\n\\n    public bool Insert(int n) => set.Add(n);\\n    \\n    public bool Remove(int n) => set.Remove(n);\\n    \\n    public int GetRandom() => set.ElementAt(rnd.Next(set.Count));\\n}\\n```\n```csharp\\nset.ToList()[rnd.Next(set.Count)];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161458,
                "title": "java-beats-100",
                "content": "```\\nclass RandomizedSet {\\n    HashMap<Integer,Integer> list=null;\\n    int[] array=null;\\n    int index=0;\\n    Random random=null;\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        list=new HashMap<Integer,Integer>();\\n        array=new int[100001];\\n        random=new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(list.containsKey(val)){\\n            return false;\\n        }\\n        else{\\n            array[index]=val;\\n            list.put(val,index);\\n            index++;\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!list.containsKey(val)){\\n            return false;\\n        }\\n        else{\\n            int pos=list.remove(val);\\n            array[pos]=array[index-1];\\n            if(list.containsKey(array[index-1])){\\n            list.put(array[index-1],pos);\\n            }\\n            index--;\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return array[random.nextInt(index)];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n    HashMap<Integer,Integer> list=null;\\n    int[] array=null;\\n    int index=0;\\n    Random random=null;\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        list=new HashMap<Integer,Integer>();\\n        array=new int[100001];\\n        random=new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(list.containsKey(val)){\\n            return false;\\n        }\\n        else{\\n            array[index]=val;\\n            list.put(val,index);\\n            index++;\\n            return true;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!list.containsKey(val)){\\n            return false;\\n        }\\n        else{\\n            int pos=list.remove(val);\\n            array[pos]=array[index-1];\\n            if(list.containsKey(array[index-1])){\\n            list.put(array[index-1],pos);\\n            }\\n            index--;\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return array[random.nextInt(index)];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683251,
                "title": "easy-c-explanation",
                "content": "```\\nclass RandomizedSet {\\n    //this map monitors if a values is present or not\\n    //if present it also gives its index\\n    unordered_map<int, int> cache;  \\n    \\n    //here we store the values\\n    vector<int> values;\\n    \\n    //Note : map is required for O(1) insertion and deletion\\n    //       vector is required for O(1) random selection\\n    \\n    int n = 0;        //this keeps the size of vector\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n      if(cache.count(val))\\n          return false;\\n        \\n      cache[val] = n++;\\n      values.push_back(val);\\n      return true;\\n    }\\n    \\n    bool remove(int val) {\\n       if(!cache.count(val))\\n          return false;\\n      \\n        \\n        //To remove an element we get it\\'s index from cache map,\\n        //place last element of vector at this index\\n        //also update index of last element in cache map\\n        //and remove the last element in O(1) time\\n        //Also note : if we would have used  erase function for vector, it would have cost O(n)\\n        \\n        int ind = cache[val];\\n        int last_element = values.back();\\n        values[ind] = last_element;\\n        cache[last_element] = ind;\\n        values.pop_back();\\n        n--;\\n\\n        cache.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n     return values[rand()%n];\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    //this map monitors if a values is present or not\\n    //if present it also gives its index\\n    unordered_map<int, int> cache;  \\n    \\n    //here we store the values\\n    vector<int> values;\\n    \\n    //Note : map is required for O(1) insertion and deletion\\n    //       vector is required for O(1) random selection\\n    \\n    int n = 0;        //this keeps the size of vector\\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n      if(cache.count(val))\\n          return false;\\n        \\n      cache[val] = n++;\\n      values.push_back(val);\\n      return true;\\n    }\\n    \\n    bool remove(int val) {\\n       if(!cache.count(val))\\n          return false;\\n      \\n        \\n        //To remove an element we get it\\'s index from cache map,\\n        //place last element of vector at this index\\n        //also update index of last element in cache map\\n        //and remove the last element in O(1) time\\n        //Also note : if we would have used  erase function for vector, it would have cost O(n)\\n        \\n        int ind = cache[val];\\n        int last_element = values.back();\\n        values[ind] = last_element;\\n        cache[last_element] = ind;\\n        values.pop_back();\\n        n--;\\n\\n        cache.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n     return values[rand()%n];\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3546345,
                "title": "really-easy-approach-java-o-1-beats-45",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    private Map<Integer, Integer> map;\\n    private List<Integer> listOfNumbers;\\n    private Random rn;\\n\\n    public RandomizedSet() {\\n        this.map = new HashMap<Integer, Integer>();\\n        this.listOfNumbers = new ArrayList<Integer>();\\n        this.rn = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (!map.containsKey(val)) {\\n            listOfNumbers.add(val);\\n            map.put(val, listOfNumbers.size() - 1);\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (map.containsKey(val)) {\\n            int index = map.remove(val);\\n            int lastVal = listOfNumbers.remove(listOfNumbers.size() - 1);\\n            if (lastVal != val) {\\n                listOfNumbers.set(index, lastVal);\\n                map.put(lastVal, index);\\n            }\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        int random = rn.nextInt(listOfNumbers.size());\\n        return listOfNumbers.get(random);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n    private Map<Integer, Integer> map;\\n    private List<Integer> listOfNumbers;\\n    private Random rn;\\n\\n    public RandomizedSet() {\\n        this.map = new HashMap<Integer, Integer>();\\n        this.listOfNumbers = new ArrayList<Integer>();\\n        this.rn = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (!map.containsKey(val)) {\\n            listOfNumbers.add(val);\\n            map.put(val, listOfNumbers.size() - 1);\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (map.containsKey(val)) {\\n            int index = map.remove(val);\\n            int lastVal = listOfNumbers.remove(listOfNumbers.size() - 1);\\n            if (lastVal != val) {\\n                listOfNumbers.set(index, lastVal);\\n                map.put(lastVal, index);\\n            }\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        int random = rn.nextInt(listOfNumbers.size());\\n        return listOfNumbers.get(random);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252931,
                "title": "380-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe class RandomizedSet is implemented using a hash table and an array. The hash table stores the values and their indices in the array, while the array stores the actual values.\\n\\nThe insert method takes a value as input and adds it to the set if it does not already exist in the set. If the value already exists, it returns False to indicate that the operation was not successful. To check if the value exists in the set, the hash table is checked. If the value does not exist, the value is added to the end of the array, and the value-index pair is added to the hash table. The time complexity of this method is O(1) on average.\\n\\nThe remove method takes a value as input and removes it from the set if it exists in the set. If the value does not exist, it returns False to indicate that the operation was not successful. To check if the value exists in the set, the hash table is checked. If the value exists, the index of the value in the array is obtained from the hash table, and the last value in the array is obtained. The value at the index is replaced with the last value in the array, and the index of the last value in the hash table is updated. The last value in the array is then removed, and the value-index pair for the removed value is removed from the hash table. The time complexity of this method is O(1) on average.\\n\\nThe getRandom method returns a random value from the set. To do this, a random value is chosen from the array using the random.choice method. The time complexity of this method is O(1) on average.\\n\\nOverall, the time complexity of each method is O(1) on average since all operations involve constant time hash table and array operations. The space complexity of the class is O(n), where n is the number of values in the set, since it uses a hash table and an array to store the values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet:\\n\\n  def __init__(self):\\n    \"\"\"\\n    Initialize your data structure here.\\n    \"\"\"\\n    self.val_to_index = {}  # Hash table to store values and their indices in the array\\n    self.vals = []          # Array to store the actual values\\n\\n  def insert(self, val: int) -> bool:\\n    \"\"\"\\n    Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n    \"\"\"\\n    if val in self.val_to_index:    # If the value already exists in the hash table, return false\\n        return False\\n    self.val_to_index[val] = len(self.vals)    # Add the value to the hash table with its index in the array\\n    self.vals.append(val)           # Append the value to the end of the array\\n    return True                     # Return true to indicate success\\n\\n  def remove(self, val: int) -> bool:\\n    \"\"\"\\n    Removes a value from the set. Returns true if the set contained the specified element.\\n    \"\"\"\\n    if val not in self.val_to_index:    # If the value does not exist in the hash table, return false\\n        return False\\n    index = self.val_to_index[val]      # Get the index of the value in the array\\n    last_val = self.vals[-1]            # Get the last value in the array\\n    self.vals[index] = last_val         # Swap the value at the index with the last value in the array\\n    self.val_to_index[last_val] = index # Update the index of the last value in the hash table\\n    self.vals.pop()                     # Remove the last value from the array\\n    del self.val_to_index[val]           # Remove the removed value from the hash table\\n    return True                          # Return true to indicate success\\n\\n  def getRandom(self) -> int:\\n    \"\"\"\\n    Get a random element from the set.\\n    \"\"\"\\n    return random.choice(self.vals)     # Return a random value from the array\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass RandomizedSet:\\n\\n  def __init__(self):\\n    \"\"\"\\n    Initialize your data structure here.\\n    \"\"\"\\n    self.val_to_index = {}  # Hash table to store values and their indices in the array\\n    self.vals = []          # Array to store the actual values\\n\\n  def insert(self, val: int) -> bool:\\n    \"\"\"\\n    Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n    \"\"\"\\n    if val in self.val_to_index:    # If the value already exists in the hash table, return false\\n        return False\\n    self.val_to_index[val] = len(self.vals)    # Add the value to the hash table with its index in the array\\n    self.vals.append(val)           # Append the value to the end of the array\\n    return True                     # Return true to indicate success\\n\\n  def remove(self, val: int) -> bool:\\n    \"\"\"\\n    Removes a value from the set. Returns true if the set contained the specified element.\\n    \"\"\"\\n    if val not in self.val_to_index:    # If the value does not exist in the hash table, return false\\n        return False\\n    index = self.val_to_index[val]      # Get the index of the value in the array\\n    last_val = self.vals[-1]            # Get the last value in the array\\n    self.vals[index] = last_val         # Swap the value at the index with the last value in the array\\n    self.val_to_index[last_val] = index # Update the index of the last value in the hash table\\n    self.vals.pop()                     # Remove the last value from the array\\n    del self.val_to_index[val]           # Remove the removed value from the hash table\\n    return True                          # Return true to indicate success\\n\\n  def getRandom(self) -> int:\\n    \"\"\"\\n    Get a random element from the set.\\n    \"\"\"\\n    return random.choice(self.vals)     # Return a random value from the array\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860038,
                "title": "java-o-1-solution-using-hashset-and-array",
                "content": "```\\nclass RandomizedSet {\\n\\n    Set<Integer> randomSet;\\n        \\n    public RandomizedSet() {\\n        randomSet = new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (randomSet.contains(val)) {\\n            return false;\\n        }\\n        randomSet.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (randomSet.contains(val)) {\\n            randomSet.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        Integer[] numbers = randomSet.toArray(new Integer[randomSet.size()]);\\n        Random random = new Random();\\n        int randomNumber = random.nextInt(randomSet.size());\\n        return numbers[randomNumber];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\n    Set<Integer> randomSet;\\n        \\n    public RandomizedSet() {\\n        randomSet = new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (randomSet.contains(val)) {\\n            return false;\\n        }\\n        randomSet.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (randomSet.contains(val)) {\\n            randomSet.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        Integer[] numbers = randomSet.toArray(new Integer[randomSet.size()]);\\n        Random random = new Random();\\n        int randomNumber = random.nextInt(randomSet.size());\\n        return numbers[randomNumber];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859125,
                "title": "easy-cpp-solution-using-vector-and-rand-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to create functions to insert values, remove values and to output any random element from set of elements.\\nSo we can use vector to store the input values and to get random values we can use CPP In-Built function rand() .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly we initialize a vector,\\nthen before inserting we check if element is already present,if  present then we return false as we can\\'t insert same element again, else we can insert element and we return true.\\nNow, \\nwhen creating remove(int val), we first need to check that if there is no element in the vector then we can\\'t remove further elements and thus we return false, else we remove element using erase() function and return true,else if we don\\'t find element then we return false.\\n\\nNow, the most interesting part is getRandom(), where we have to return a random element where we use rand() function which generates a random value in a specific range, thus we return elements at random indices in vector and return them.\\nHope you Understand!\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBest case:   **O(1)**\\nWorst case:  **O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(N)**\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    private:\\n    vector<int>vec;\\npublic:\\n    RandomizedSet() {\\n    }\\n    \\n    bool insert(int val) {\\n        for(auto it:vec)\\n        {\\n            if(it==val)\\n            return false;\\n        }\\n        vec.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(vec.size()<1)return false;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i]==val)\\n            {\\n                vec.erase(vec.begin()+i);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        return vec[rand()%vec.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass RandomizedSet {\\n    private:\\n    vector<int>vec;\\npublic:\\n    RandomizedSet() {\\n    }\\n    \\n    bool insert(int val) {\\n        for(auto it:vec)\\n        {\\n            if(it==val)\\n            return false;\\n        }\\n        vec.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(vec.size()<1)return false;\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i]==val)\\n            {\\n                vec.erase(vec.begin()+i);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        return vec[rand()%vec.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859103,
                "title": "c-solution",
                "content": "``` C++ []\\nclass RandomizedSet {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n        \\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n                \\n        if(mp.count(val))\\n            return false;\\n        \\n        arr.push_back(val);\\n        \\n        mp[val] = arr.size() - 1;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(mp.count(val))\\n        {            \\n            int idx = mp[val];\\n                        \\n            int last_val = arr.back();\\n                        \\n            arr[idx] = last_val;\\n                        \\n            arr.pop_back();\\n                       \\n            mp[last_val] = idx;\\n                        \\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n                \\n        int rand_idx = rand() % arr.size();\\n        \\n        return arr[rand_idx];\\n    }\\n};\\n```\\n\\n*Upvote if it helped*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass RandomizedSet {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n        \\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n                \\n        if(mp.count(val))\\n            return false;\\n        \\n        arr.push_back(val);\\n        \\n        mp[val] = arr.size() - 1;\\n        \\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(mp.count(val))\\n        {            \\n            int idx = mp[val];\\n                        \\n            int last_val = arr.back();\\n                        \\n            arr[idx] = last_val;\\n                        \\n            arr.pop_back();\\n                       \\n            mp[last_val] = idx;\\n                        \\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n                \\n        int rand_idx = rand() % arr.size();\\n        \\n        return arr[rand_idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165896,
                "title": "easy-to-understand-c-solution-using-vector-and-hash-map",
                "content": "```\\nclass RandomizedSet {\\n    unordered_map<int, int> mymap;\\n    vector<int> myvec;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (mymap.find(val) != mymap.end()) return false;\\n        myvec.push_back(val);\\n        int index = myvec.size() - 1;\\n        mymap[val] = index;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (mymap.find(val) == mymap.end()) return false;\\n        // Reset the last value of myvec to the index and pop back\\n        int index = mymap[val];\\n        int last_val = myvec.back();\\n        myvec[index] = last_val;\\n        myvec.pop_back();\\n        mymap[last_val] = index;\\n        mymap.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (myvec.size() == 1) return myvec[0];\\n        int size  = myvec.size();\\n        //cout << \"size is \" << size << endl;\\n        int index = rand() % (size);\\n        return myvec[index];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    unordered_map<int, int> mymap;\\n    vector<int> myvec;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (mymap.find(val) != mymap.end()) return false;\\n        myvec.push_back(val);\\n        int index = myvec.size() - 1;\\n        mymap[val] = index;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (mymap.find(val) == mymap.end()) return false;\\n        // Reset the last value of myvec to the index and pop back\\n        int index = mymap[val];\\n        int last_val = myvec.back();\\n        myvec[index] = last_val;\\n        myvec.pop_back();\\n        mymap[last_val] = index;\\n        mymap.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (myvec.size() == 1) return myvec[0];\\n        int size  = myvec.size();\\n        //cout << \"size is \" << size << endl;\\n        int index = rand() % (size);\\n        return myvec[index];\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1006328,
                "title": "a-c-solution-and-thought-process",
                "content": "First up my solution:\\n```\\n// Time: O(1), Space: O(n)\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(ht.find(val)==ht.end()){\\n            vec.push_back(val);\\n            ht[val]=vec.size()-1;\\n            return true;\\n        }\\n        else\\n            return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(ht.find(val)!=ht.end()){\\n            vec[ht[val]]=vec[vec.size()-1];\\n            ht[vec[vec.size()-1]]=ht[val];\\n            vec.pop_back();\\n            ht.erase(val);\\n            return true;\\n        }\\n        else \\n            return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if(vec.size()==1)\\n            return vec[0];\\n        else{\\n            int idx=rand()%(vec.size());\\n            return vec[idx];   \\n        }\\n    }\\n    \\n    unordered_map<int,int> ht;\\n    vector<int> vec;\\n};\\n```\\n\\nWhen I first looked at the problem, it seems quite straightforward. Inserting and deleting in constant time means hashtable. But when I start working on the get random, it starts to get trickier. I was initially thinking that I can find random in constant time using unordered_set iterator and do something like (ht.begin()+somerandint). But I realized that ht iterator is not a random access iterator, meaning in order to get to a specific iterator I have to iterator from the begin iterator which takes linear time. Therefore, we need a container with random access. vector is an obvious choice. But I was stuck again, because vector erasing sounds like linear time. After looking at the solution, I realize that the erasing is usually linear because we need to keep the order vector. In cases like this, we don\\'t care about maintaining the order of elements and removing a specific element can be done in constant time by utilizing pop_back().\\n\\nNot very familiar with the random stl class, so if there\\'s a better way to get rand from a vector, let me know.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Time: O(1), Space: O(n)\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(ht.find(val)==ht.end()){\\n            vec.push_back(val);\\n            ht[val]=vec.size()-1;\\n            return true;\\n        }\\n        else\\n            return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(ht.find(val)!=ht.end()){\\n            vec[ht[val]]=vec[vec.size()-1];\\n            ht[vec[vec.size()-1]]=ht[val];\\n            vec.pop_back();\\n            ht.erase(val);\\n            return true;\\n        }\\n        else \\n            return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if(vec.size()==1)\\n            return vec[0];\\n        else{\\n            int idx=rand()%(vec.size());\\n            return vec[idx];   \\n        }\\n    }\\n    \\n    unordered_map<int,int> ht;\\n    vector<int> vec;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731469,
                "title": "standard-java-solution",
                "content": "### Theory\\nThe main issue with this problem is that we are asked to generate a random value from any value of a set, and sets aren\\'t indexed. So we must keep a list as the main structure, with a map that maps from value -> index, as well as a psudeo random generator object.\\n\\nIn order to maintain O(1) time in the remove (ArrayList.remove() will take O(N) worst case), we must shift the last element in the list to the spot where we delete the value. It makes much more sense in code,\\n\\n### Solution\\n```\\n    private List<Integer> list;\\n    private Map<Integer, Integer> map;\\n    private Random rand;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n        rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) return false;\\n        list.add(val);\\n        map.put(val, list.size() - 1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) return false;\\n        int lastElement = list.get(list.size() - 1);\\n        int index = map.get(val);\\n        list.set(index, lastElement);\\n        map.put(lastElement, index);\\n        list.remove(list.size() - 1);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private List<Integer> list;\\n    private Map<Integer, Integer> map;\\n    private Random rand;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n        rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) return false;\\n        list.add(val);\\n        map.put(val, list.size() - 1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) return false;\\n        int lastElement = list.get(list.size() - 1);\\n        int index = map.get(val);\\n        list.set(index, lastElement);\\n        map.put(lastElement, index);\\n        list.remove(list.size() - 1);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685574,
                "title": "challenge-me-for-shorter-solution-4-line",
                "content": "**Idea**:  \\njust to prove how close the desired data structre is to set. BTW, it is also another case where it is possible to write short and sexy code as python.\\n\\nTo get the solution 100% meet the requirement, you can refer to other top voted posts. \\nIf you this post increase your love for STL, please help upvote. Thanks.\\n\\n**Warning**:  This dose not meet the O(1) time complexity requirement.\\n\\nThe solution here is a sub-optimal solution just to illustrate the power of STL.\\nMay the force of STL be with you.**\\n\\n\\nTime complexity:\\nInsert:  O(1)\\nremove: O(1)\\ngetRandom:O(N). But this took me one year to realize we can do this.\\nReference: \\nhttps://en.cppreference.com/w/cpp/container/unordered_set/erase\\nhttps://en.cppreference.com/w/cpp/container/unordered_set/insert\\n\\n\\n```\\nclass RandomizedSet { // An elegant sub-optimal Solution for fun in the name of study by codedayday: https://leetcode.com/codedayday/\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_set<int> m_;\\n    RandomizedSet() {       }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        return m_.insert(val).second;       \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {        \\n        return m_.erase(val); //return the number of elements erased. \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {        \\n        return *next(m_.begin(), rand() % m_.size());\\n    }\\n};\\n```\\n\\n\\nAs a reference, a 9-line python solution with same idea from https://leetcode.com/dayeon486/ is also pasted at the end of this poster.\\nOnce again, the solution is sub-optimal since the implementation of getRandom() is based on hashset, the time cost must be O(N), instead of O(1).\\n\\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.s = set()\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.s:\\n            self.s.add(val)\\n            return True\\n        return False\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.s:\\n            self.s.remove(val)\\n            return True\\n        return False\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.sample(self.s, 1)[0]\\n```\\nCredit:\\nhttps://leetcode.com/problems/insert-delete-getrandom-o1/discuss/684502/Accepted-python-using-only-one-SET\\n\\nNote1:\\nLet\\'s be clear: the time complexity of following operation is O(N)\\n```\\nrandom.sample(self.s, 1)[0]\\n```\\nReference: \\nYou can check the implementation of random.sample() for more details here:      \\n https://stackoverflow.com/questions/10483377/time-complexity-of-random-sample\\n",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet { // An elegant sub-optimal Solution for fun in the name of study by codedayday: https://leetcode.com/codedayday/\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_set<int> m_;\\n    RandomizedSet() {       }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        return m_.insert(val).second;       \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {        \\n        return m_.erase(val); //return the number of elements erased. \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {        \\n        return *next(m_.begin(), rand() % m_.size());\\n    }\\n};\\n```\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.s = set()\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.s:\\n            self.s.add(val)\\n            return True\\n        return False\\n        \\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.s:\\n            self.s.remove(val)\\n            return True\\n        return False\\n        \\n\\n    def getRandom(self) -> int:\\n        return random.sample(self.s, 1)[0]\\n```\n```\\nrandom.sample(self.s, 1)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683902,
                "title": "c-solution-using-vector-hash-map",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(!m_.count(val)) {\\n            v_.push_back(val);\\n            m_[val]=v_.size()-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(m_.count(val)){\\n            int i=m_[val];\\n            swap(v_[i], v_[v_.size()-1]);\\n            v_.pop_back();\\n            m_[v_[i]]=i;\\n            m_.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int i=rand()%m_.size();\\n        return v_[i];\\n        \\n    }\\n    \\nprivate:\\n    vector<int> v_;\\n    unordered_map<int, int> m_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(!m_.count(val)) {\\n            v_.push_back(val);\\n            m_[val]=v_.size()-1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(m_.count(val)){\\n            int i=m_[val];\\n            swap(v_[i], v_[v_.size()-1]);\\n            v_.pop_back();\\n            m_[v_[i]]=i;\\n            m_.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int i=rand()%m_.size();\\n        return v_[i];\\n        \\n    }\\n    \\nprivate:\\n    vector<int> v_;\\n    unordered_map<int, int> m_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138129,
                "title": "python-solution",
                "content": "```\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.array = []\\n        self.idx_dict = {}\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val not in self.idx_dict:\\n            self.array.append(val)\\n            self.idx_dict[val] = len(self.array) - 1\\n            return True\\n\\n        return False\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.idx_dict:\\n            idx = self.idx_dict[val]\\n            self.array[idx], self.array[len(self.array)-1] = self.array[len(self.array)-1], self.array[idx]\\n            self.idx_dict[self.array[idx]] = idx\\n            self.array.pop()\\n            self.idx_dict.pop(val, None)\\n            return True\\n\\n        return False\\n\\n    # Assume there are element in the array\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        ran_idx = random.randint(0, len(self.array)-1)\\n        return self.array[ran_idx]\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.array = []\\n        self.idx_dict = {}\\n\\n    def insert(self, val):\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val not in self.idx_dict:\\n            self.array.append(val)\\n            self.idx_dict[val] = len(self.array) - 1\\n            return True\\n\\n        return False\\n\\n    def remove(self, val):\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        :type val: int\\n        :rtype: bool\\n        \"\"\"\\n        if val in self.idx_dict:\\n            idx = self.idx_dict[val]\\n            self.array[idx], self.array[len(self.array)-1] = self.array[len(self.array)-1], self.array[idx]\\n            self.idx_dict[self.array[idx]] = idx\\n            self.array.pop()\\n            self.idx_dict.pop(val, None)\\n            return True\\n\\n        return False\\n\\n    # Assume there are element in the array\\n    def getRandom(self):\\n        \"\"\"\\n        Get a random element from the set.\\n        :rtype: int\\n        \"\"\"\\n        ran_idx = random.randint(0, len(self.array)-1)\\n        return self.array[ran_idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062167,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(mp.find(val)!=mp.end())\\n        return false;\\n        v.push_back(val);\\n        mp[val]=v.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)==mp.end())\\n        return false;\\n        int i=mp[val];\\n        v[i]=v[v.size()-1];\\n        mp[v[v.size()-1]]=i;\\n        v.pop_back();\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(mp.find(val)!=mp.end())\\n        return false;\\n        v.push_back(val);\\n        mp[val]=v.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.find(val)==mp.end())\\n        return false;\\n        int i=mp[val];\\n        v[i]=v[v.size()-1];\\n        mp[v[v.size()-1]]=i;\\n        v.pop_back();\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860897,
                "title": "python-3-380-insert-delete-getrandom-t-m-80-75",
                "content": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.randSet = defaultdict()\\n\\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.randSet: return False\\n        \\n        self.randSet[val]= None\\n        return True\\n        \\n        \\n    def remove(self, val: int) -> bool:\\n        \\n        if val not in self.randSet: return False\\n        \\n        self.randSet.pop(val)\\n        return True\\n\\n    \\n    def getRandom(self) -> int:\\n        \\n        return choice(list(self.randSet.keys()))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.randSet = defaultdict()\\n\\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.randSet: return False\\n        \\n        self.randSet[val]= None\\n        return True\\n        \\n        \\n    def remove(self, val: int) -> bool:\\n        \\n        if val not in self.randSet: return False\\n        \\n        self.randSet.pop(val)\\n        return True\\n\\n    \\n    def getRandom(self) -> int:\\n        \\n        return choice(list(self.randSet.keys()))",
                "codeTag": "Java"
            },
            {
                "id": 2860859,
                "title": "c-vector-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought came in mind to choose \\'set\\' as data structure, but it take O(n) time comlexity for the finding of random number, so i have use vector, but time complexity for removal of the element from vector will be O(n), to reduce the time complexity of removal i have use unordered_map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have apply simple approach, swap the element which have to remove to the last index then remove the last index. Update the index of swapped element in map and remove the element from map.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> mp;\\n    int i;\\n    RandomizedSet() {\\n        i=-1;\\n    }\\n    bool insert(int val) {\\n        if(mp.find(val)==mp.end()){\\n            v.push_back(val);\\n            i++;\\n            mp[val]=i;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(i>=0 && mp.find(val)!=mp.end()){\\n            int index=mp[val];\\n            swap(v[index],v[i]);\\n            mp[v[index]]=index;\\n            mp.erase(val);\\n            v.pop_back();\\n            i--;\\n            return true;\\n        }\\n        return false;\\n    }\\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> mp;\\n    int i;\\n    RandomizedSet() {\\n        i=-1;\\n    }\\n    bool insert(int val) {\\n        if(mp.find(val)==mp.end()){\\n            v.push_back(val);\\n            i++;\\n            mp[val]=i;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(i>=0 && mp.find(val)!=mp.end()){\\n            int index=mp[val];\\n            swap(v[index],v[i]);\\n            mp[v[index]]=index;\\n            mp.erase(val);\\n            v.pop_back();\\n            i--;\\n            return true;\\n        }\\n        return false;\\n    }\\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859787,
                "title": "array-and-hashmap-used-o-1-for-each-operation-very-east-and-concise",
                "content": "# Intuition\\n> Always insert elements in the end of the array and put the index and value in the hashmap\\n\\n> To Delete, always swap the element with the last element of the array and update the index of the last element in the hashmap and delete the last element from the array and hashmap\\n\\n> To get random element, return random element from the array from the range: 0 to top-1\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ for EachOperation\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2*10e5)$$, but for Asymptomatic cases, it is $$O(1)$$ since the program do not allocate extra space for the array for the following runtimes.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    static int[] arr;\\n    int top=-1;\\n    HashMap<Integer,Integer> map = new HashMap<>();\\n    public RandomizedSet() {\\n        if(arr==null) arr = new int[200001];\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(!map.containsKey(val)){\\n            top++;\\n            arr[top]=val;\\n            map.put(val,top);\\n            return true;\\n        }else return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            int pos = map.get(val);\\n            map.put(arr[top],pos);\\n            arr[pos] = arr[pos] + arr[top] - (arr[top] = arr[pos]); // swapping\\n            top--;\\n            map.remove(val);\\n            return true;\\n        }else return false;\\n    }\\n    \\n    public int getRandom() {\\n        return arr[(int)(Math.random()*(top+1))];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Randomized"
                ],
                "code": "```\\nclass RandomizedSet {\\n    static int[] arr;\\n    int top=-1;\\n    HashMap<Integer,Integer> map = new HashMap<>();\\n    public RandomizedSet() {\\n        if(arr==null) arr = new int[200001];\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(!map.containsKey(val)){\\n            top++;\\n            arr[top]=val;\\n            map.put(val,top);\\n            return true;\\n        }else return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            int pos = map.get(val);\\n            map.put(arr[top],pos);\\n            arr[pos] = arr[pos] + arr[top] - (arr[top] = arr[pos]); // swapping\\n            top--;\\n            map.remove(val);\\n            return true;\\n        }else return false;\\n    }\\n    \\n    public int getRandom() {\\n        return arr[(int)(Math.random()*(top+1))];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858201,
                "title": "golang",
                "content": "```\\ntype RandomizedSet struct {\\n    m map[int]int\\n    l []int\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    m := make(map[int]int)\\n    l := make([]int, 0)\\n    return RandomizedSet{m, l}\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.m[val]; ok {\\n        return false\\n    }\\n    this.m[val] = len(this.l)\\n    this.l = append(this.l, val)\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    if _, ok := this.m[val]; !ok {\\n        return false\\n    }\\n    n, i := len(this.l), this.m[val]\\n    this.l[i], this.l[n-1] = this.l[n-1], this.l[i]\\n    this.m[this.l[i]] = i\\n    this.l = this.l[:n-1]\\n    delete(this.m, val)\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    i := rand.Intn(len(this.l))\\n    return this.l[i]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype RandomizedSet struct {\\n    m map[int]int\\n    l []int\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    m := make(map[int]int)\\n    l := make([]int, 0)\\n    return RandomizedSet{m, l}\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.m[val]; ok {\\n        return false\\n    }\\n    this.m[val] = len(this.l)\\n    this.l = append(this.l, val)\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    if _, ok := this.m[val]; !ok {\\n        return false\\n    }\\n    n, i := len(this.l), this.m[val]\\n    this.l[i], this.l[n-1] = this.l[n-1], this.l[i]\\n    this.m[this.l[i]] = i\\n    this.l = this.l[:n-1]\\n    delete(this.m, val)\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    i := rand.Intn(len(this.l))\\n    return this.l[i]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858185,
                "title": "explained-optimized-o-1-cpp-fully-commented",
                "content": "# Complexity\\n- Time complexity: Average Time O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Auxiliary Space O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Approach\\n- We will take order of elements is not important in the data structure. \\n- If we use an array as the data structure, insertion at the end will be in O(1) time but searching whether the element is already present in the array will take O(N) time. \\n- Removal of the element will require searching for the element which will take O(N) time and left shifting the subsequent array elements will also take O(N) time.\\n-  Getting random element will take O(1) time using the rand() function. \\n- So, we need some additional data structure that allows us to locate the array index for removal and also to search whether the element is already present or not. \\n- This data structure should do these tasks in average O(1) time. Hashmap fulfils our requirements.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# CPP Code\\n```\\nclass RandomizedSet {\\n\\t// Thanks to Bhalerao-2002\\nprivate:\\n    // array vector\\n    vector<int> a;\\n     // Unordered Map does searching, insertion & deletion of element in average O(1) time\\n    unordered_map<int,int> m;\\npublic:\\n    RandomizedSet() {\\n    // No need to initialise a & m as they are initialised automatically\\n\\t// to 0 as and when their container size increases.\\n    }\\n    //Insert\\n    bool insert(int val) {\\n        if(m.find(val)!=m.end())\\n\\t        // If val is not already present in the map, find() function  \\n\\t        // returns an iterator(m.end()) pointing to next memory location  \\n            // of the last element of the map. Otherwise, find() returns an iterator \\n            // pointing to val which was already present in the map.  \\n            return false;\\n        else{\\n            a.push_back(val);  \\n            m[val]=a.size()-1; \\n            return true;\\n        }\\n    }\\n    \\n    //Remove\\n    bool remove(int val) {\\n        if(m.find(val)==m.end()) // val not present in the array vector\\n            return false;\\n        else{\\n\\t        // val present in the array vector\\n            int last=a.back();  // back() fetches last element of the array vector\\n            a[m[val]]=a.back(); // m[val] locates the index of val in the array vector.     \\n            a.pop_back();\\t   \\n            m[last]=m[val];\\t     \\n            m.erase(val);\\t    // Delete the val entry from map\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the array vector */\\n    int getRandom() {\\n        return a[rand()%a.size()];\\n    }\\n};\\n```\\n#Upvote if it Helped :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\t// Thanks to Bhalerao-2002\\nprivate:\\n    // array vector\\n    vector<int> a;\\n     // Unordered Map does searching, insertion & deletion of element in average O(1) time\\n    unordered_map<int,int> m;\\npublic:\\n    RandomizedSet() {\\n    // No need to initialise a & m as they are initialised automatically\\n\\t// to 0 as and when their container size increases.\\n    }\\n    //Insert\\n    bool insert(int val) {\\n        if(m.find(val)!=m.end())\\n\\t        // If val is not already present in the map, find() function  \\n\\t        // returns an iterator(m.end()) pointing to next memory location  \\n            // of the last element of the map. Otherwise, find() returns an iterator \\n            // pointing to val which was already present in the map.  \\n            return false;\\n        else{\\n            a.push_back(val);  \\n            m[val]=a.size()-1; \\n            return true;\\n        }\\n    }\\n    \\n    //Remove\\n    bool remove(int val) {\\n        if(m.find(val)==m.end()) // val not present in the array vector\\n            return false;\\n        else{\\n\\t        // val present in the array vector\\n            int last=a.back();  // back() fetches last element of the array vector\\n            a[m[val]]=a.back(); // m[val] locates the index of val in the array vector.     \\n            a.pop_back();\\t   \\n            m[last]=m[val];\\t     \\n            m.erase(val);\\t    // Delete the val entry from map\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the array vector */\\n    int getRandom() {\\n        return a[rand()%a.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854916,
                "title": "easy-explanation-of-getrandom-function-golang-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever in questions it says O(1), I always think about HashMap. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare map in our concrete class, which is going to store the keys.\\n- Insert() - straight forward, if not present then add\\n- Remove() - straight forward, if present then delete\\n- GetRandom() - Need to think how we can get the randomKey, here we will find the length of the map, and using golang `rand` package we can get the random value in a range(in our case len of the map). We will introduce a counter which is going to tell us when to return the key.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\ntype RandomizedSet struct {\\n    mp map[int]bool\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{\\n        mp: make(map[int]bool),\\n    }\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.mp[val]; !ok{\\n        this.mp[val] = true\\n        return true\\n    } \\n    return false\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    if _, ok := this.mp[val]; ok {\\n        delete(this.mp, val)\\n        return true\\n    } \\n    return false\\n}\\n\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    l := len(this.mp)\\n    randNumber := rand.Intn(l)\\n    counter := 0\\n\\n    for k := range this.mp {\\n        if counter == randNumber {\\n            return k\\n        }\\n        counter++\\n    }\\n    return -1\\n}\\n\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Insert(val);\\n * param_2 := obj.Remove(val);\\n * param_3 := obj.GetRandom();\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\ntype RandomizedSet struct {\\n    mp map[int]bool\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{\\n        mp: make(map[int]bool),\\n    }\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.mp[val]; !ok{\\n        this.mp[val] = true\\n        return true\\n    } \\n    return false\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    if _, ok := this.mp[val]; ok {\\n        delete(this.mp, val)\\n        return true\\n    } \\n    return false\\n}\\n\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    l := len(this.mp)\\n    randNumber := rand.Intn(l)\\n    counter := 0\\n\\n    for k := range this.mp {\\n        if counter == randNumber {\\n            return k\\n        }\\n        counter++\\n    }\\n    return -1\\n}\\n\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * obj := Constructor();\\n * param_1 := obj.Insert(val);\\n * param_2 := obj.Remove(val);\\n * param_3 := obj.GetRandom();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2766001,
                "title": "easy-peasy-using-dictnory-and-sortedcontainer-library-tc-logn",
                "content": "```\\nimport random\\nfrom sortedcontainers import SortedList\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.arr=SortedList([])\\n        self.dc=defaultdict(lambda:0)\\n    def insert(self, val: int) -> bool:\\n        if(self.dc[val]==1):\\n            return False\\n        self.dc[val]=1\\n        self.arr.add(val)\\n        return True\\n    def remove(self, val: int) -> bool:\\n        if(self.dc[val]==0):\\n            return False\\n        self.dc[val]=0\\n        self.arr.discard(val)\\n        return True\\n    def getRandom(self) -> int:\\n        x=random.randint(0,len(self.arr)-1)\\n        return(self.arr[x])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport random\\nfrom sortedcontainers import SortedList\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.arr=SortedList([])\\n        self.dc=defaultdict(lambda:0)\\n    def insert(self, val: int) -> bool:\\n        if(self.dc[val]==1):\\n            return False\\n        self.dc[val]=1\\n        self.arr.add(val)\\n        return True\\n    def remove(self, val: int) -> bool:\\n        if(self.dc[val]==0):\\n            return False\\n        self.dc[val]=0\\n        self.arr.discard(val)\\n        return True\\n    def getRandom(self) -> int:\\n        x=random.randint(0,len(self.arr)-1)\\n        return(self.arr[x])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676472,
                "title": "python-solution-using-dictionary-and-list-392-ms-faster-then-98-18-with-comments",
                "content": "\\tdef __init__(self):\\n        # Using Dictionary and List\\n        self.dict = {} # To maintain the index\\n        self.list = [] # To store all the values\\n\\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.dict:\\n            return False # If the element is already in the dictionary then return False\\n        \\n        self.dict[val] = len(self.list) # settinng the value with their in dex in hashmap\\n        self.list.append(val) #Appending the value in the list\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.dict: # Removing only if the value is in the dictionary\\n            last_element = self.list[-1] # getting the last element in the list\\n            index = self.dict[val] # getting the index value of the element to be removed from the dictionary\\n            \\n            self.list[index] = last_element # Replacing the element to be removed with the last element in the list\\n            self.dict[last_element] = index # setting the index value of the last element which was changed recently in the dictionary\\n            \\n            self.list.pop() # Popping the last element from the list\\n            del self.dict[val] #deleting the value from dictionary too which was deleted from the list\\n            return True\\n        return False # IF value not in the dictionary then return false\\n\\n    def getRandom(self) -> int:\\n        \\n        return choice(self.list) #Function to get the random element from the list\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/7274f826-6295-4059-91ed-7a3a759e1755_1641681196.611421.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "\\tdef __init__(self):\\n        # Using Dictionary and List\\n        self.dict = {} # To maintain the index\\n        self.list = [] # To store all the values\\n\\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.dict:\\n            return False # If the element is already in the dictionary then return False\\n        \\n        self.dict[val] = len(self.list) # settinng the value with their in dex in hashmap\\n        self.list.append(val) #Appending the value in the list\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        if val in self.dict: # Removing only if the value is in the dictionary\\n            last_element = self.list[-1] # getting the last element in the list\\n            index = self.dict[val] # getting the index value of the element to be removed from the dictionary\\n            \\n            self.list[index] = last_element # Replacing the element to be removed with the last element in the list\\n            self.dict[last_element] = index # setting the index value of the last element which was changed recently in the dictionary\\n            \\n            self.list.pop() # Popping the last element from the list\\n            del self.dict[val] #deleting the value from dictionary too which was deleted from the list\\n            return True\\n        return False # IF value not in the dictionary then return false\\n\\n    def getRandom(self) -> int:\\n        \\n        return choice(self.list) #Function to get the random element from the list\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/7274f826-6295-4059-91ed-7a3a759e1755_1641681196.611421.png)\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1541026,
                "title": "python3-o-1",
                "content": "```\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.stack = []\\n        self.dict = {}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val in self.dict:\\n            return False\\n\\n        self.dict[val] = len(self.stack)\\n        self.stack.append(val)\\n        return True\\n        \\n    def remove(self, val: int) -> bool:\\n\\t    # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val not in self.dict:\\n            return False        \\n        last = self.stack[-1]\\n        ind = self.dict[val] \\n        \\n        self.dict[last] = ind\\n        self.stack[ind] = last\\n        \\n        self.stack.pop()\\n        \\n        self.dict.pop(val)\\n        \\n        \\n        return True        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.stack)\\n\\t\\t```\\n\\t\\tfeel free to ask Q...\\n\\t\\t#happytohelpu",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass RandomizedSet:\\n    def __init__(self):\\n        self.stack = []\\n        self.dict = {}\\n        \\n\\n    def insert(self, val: int) -> bool:\\n        # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val in self.dict:\\n            return False\\n\\n        self.dict[val] = len(self.stack)\\n        self.stack.append(val)\\n        return True\\n        \\n    def remove(self, val: int) -> bool:\\n\\t    # dictionary is on average O(1) where as\\n        # checking the array is on average O(n)\\n        if val not in self.dict:\\n            return False        \\n        last = self.stack[-1]\\n        ind = self.dict[val] \\n        \\n        self.dict[last] = ind\\n        self.stack[ind] = last\\n        \\n        self.stack.pop()\\n        \\n        self.dict.pop(val)\\n        \\n        \\n        return True        \\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.stack)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1532400,
                "title": "simple-c-solution-using-unordered-set",
                "content": "This is O(n) Solution :\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> S;\\n    \\n    RandomizedSet() {\\n        S.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        \\n        if(S.find(val) == S.end())\\n        {\\n            S.insert(val);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(S.find(val) != S.end())\\n        {\\n            S.erase(val);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        int r = rand()%S.size();\\n        \\n        auto it = S.begin();\\n        \\n        while(r--)\\n            it++;\\n        \\n        return *it;\\n    }\\n};\\n```\\n\\nThis is O(1) Solution :\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        mp.clear();\\n        arr.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        \\n        if(mp.find(val) == mp.end())\\n        {\\n            arr.push_back(val);\\n            mp[val] = arr.size()-1;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(mp.find(val) != mp.end())\\n        {\\n            int t = mp[val];\\n            int s = arr.size();\\n            \\n            arr[t] = arr[s-1];\\n            mp[arr[t]] = t;\\n            \\n            arr.pop_back();\\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {      \\n        \\n        int s = arr.size();\\n        \\n        return arr[rand() % s];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> S;\\n    \\n    RandomizedSet() {\\n        S.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        \\n        if(S.find(val) == S.end())\\n        {\\n            S.insert(val);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(S.find(val) != S.end())\\n        {\\n            S.erase(val);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        \\n        int r = rand()%S.size();\\n        \\n        auto it = S.begin();\\n        \\n        while(r--)\\n            it++;\\n        \\n        return *it;\\n    }\\n};\\n```\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        mp.clear();\\n        arr.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        \\n        if(mp.find(val) == mp.end())\\n        {\\n            arr.push_back(val);\\n            mp[val] = arr.size()-1;\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        \\n        if(mp.find(val) != mp.end())\\n        {\\n            int t = mp[val];\\n            int s = arr.size();\\n            \\n            arr[t] = arr[s-1];\\n            mp[arr[t]] = t;\\n            \\n            arr.pop_back();\\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int getRandom() {      \\n        \\n        int s = arr.size();\\n        \\n        return arr[rand() % s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506448,
                "title": "c-188ms-98-simple-easy-small-and-clean",
                "content": "Runtime: 188 ms, faster than 97.88% of C++ online submissions for Insert Delete GetRandom O(1).\\nMemory Usage: 97 MB, less than 83.92% of C++ online submissions for Insert Delete GetRandom O(1).\\n**General idea:**\\nwe asked to solve this task with time O1 for all cases : \\n1. inserting : put new value into \"tail\" vector and into map {value , index into vector}  **=> all operation with time O1**\\n2. erasing : **small trick !** we do swap with our erasing element and \"tail\" of vector and change in table value with key from \"tail\" of vector , after it do pop_back and erase(old key)  **=> all operation with time O1** \\n3. give random element form array **=> all operation with time O1**\\n```\\nclass RandomizedSet {\\npublic:\\n  unordered_map<int,int>table;\\n  vector<int>v;\\n  \\n  bool insert(int val) {\\n    if(table.count(val)) return false; \\n    table[val] = v.size();\\n    v.push_back(val);\\n    return true;\\n  }\\n    \\n  bool remove(int val) {\\n    if(!table.count(val)) return false;\\n    int old_index = table[val];\\n    table[v[old_index] = v.back()] = old_index;\\n    \\n    v.pop_back();\\n    table.erase(val);\\n    return true;\\n  }\\n    \\n  int getRandom() {\\n     return v[rand()%v.size()];   \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n  unordered_map<int,int>table;\\n  vector<int>v;\\n  \\n  bool insert(int val) {\\n    if(table.count(val)) return false; \\n    table[val] = v.size();\\n    v.push_back(val);\\n    return true;\\n  }\\n    \\n  bool remove(int val) {\\n    if(!table.count(val)) return false;\\n    int old_index = table[val];\\n    table[v[old_index] = v.back()] = old_index;\\n    \\n    v.pop_back();\\n    table.erase(val);\\n    return true;\\n  }\\n    \\n  int getRandom() {\\n     return v[rand()%v.size()];   \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440937,
                "title": "java-hashmap-arraylist-solution",
                "content": "```\\n// HashMap + ArrayList Solution\\n// HashMap to store <val, index> pair. \\n// remove(): Move the last element in ArrayList to the deleted element position to remove the element. Update the <val, index> pair in HashMap.\\n// Time complexity: O(1) for initialization, insert, remove and getRandom\\n// Space complexity: O(N)\\nclass RandomizedSet {\\n    private Random random;\\n    private List<Integer> list;\\n    private Map<Integer, Integer> valIdxMap;  // Stores <val, index> pair\\n\\n    public RandomizedSet() {\\n        random = new Random();\\n        list = new ArrayList<>();\\n        valIdxMap = new HashMap<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (valIdxMap.containsKey(val)) return false;\\n        valIdxMap.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (!valIdxMap.containsKey(val)) return false;\\n        int idx = valIdxMap.get(val);\\n        // Move last element to deleted position.\\n        int lastVal = list.get(list.size() - 1);\\n        list.set(idx, lastVal);\\n        valIdxMap.put(lastVal, idx);\\n        // Remove last element\\n        list.remove(list.size() - 1);\\n        valIdxMap.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        int idx = random.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// HashMap + ArrayList Solution\\n// HashMap to store <val, index> pair. \\n// remove(): Move the last element in ArrayList to the deleted element position to remove the element. Update the <val, index> pair in HashMap.\\n// Time complexity: O(1) for initialization, insert, remove and getRandom\\n// Space complexity: O(N)\\nclass RandomizedSet {\\n    private Random random;\\n    private List<Integer> list;\\n    private Map<Integer, Integer> valIdxMap;  // Stores <val, index> pair\\n\\n    public RandomizedSet() {\\n        random = new Random();\\n        list = new ArrayList<>();\\n        valIdxMap = new HashMap<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if (valIdxMap.containsKey(val)) return false;\\n        valIdxMap.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if (!valIdxMap.containsKey(val)) return false;\\n        int idx = valIdxMap.get(val);\\n        // Move last element to deleted position.\\n        int lastVal = list.get(list.size() - 1);\\n        list.set(idx, lastVal);\\n        valIdxMap.put(lastVal, idx);\\n        // Remove last element\\n        list.remove(list.size() - 1);\\n        valIdxMap.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        int idx = random.nextInt(list.size());\\n        return list.get(idx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129713,
                "title": "readable-java-solution",
                "content": "**Approch:**\\n1. We know one thing that remove last element from a arraylist is O(1) operation . \\n2. will try to remove in such a way that we will get the idx of value which to be remove in arraylist and then swap it with last value in arraylist and then remove (O(1)).\\n3. we need to store every value with their index . -> HashMap<Integer,Integer> best fit.\\n4. If getrandom function was not there then we can solve it using hashmap only just remove the value and insert the value in O(1) but because of getRandom we need to maintain values  in arraylist.  \\n**CODE:**\\n```\\nclass RandomizedSet {\\n     HashMap<Integer,Integer> valueIndexMap;\\n     ArrayList<Integer> values;\\n \\n    public RandomizedSet() {\\n        valueIndexMap=new HashMap<>();\\n        values=new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n       if(valueIndexMap.containsKey(val)) return false;\\n        values.add(val);\\n        valueIndexMap.put(val,values.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!valueIndexMap.containsKey(val)) return false;\\n        int idx=valueIndexMap.get(val);            //idx of value to be deleted\\n        if(idx==values.size()-1){\\n            valueIndexMap.remove(val);\\n             values.remove(values.size()-1);\\n            return true;\\n        }\\n        \\n        int lastValue=values.get(values.size()-1);  //last value\\n        valueIndexMap.remove(val);                 \\n        valueIndexMap.put(lastValue,idx);\\n     \\n        Collections.swap(values,idx,values.size()-1);\\n        values.remove(values.size()-1);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random rand=new Random();\\n        int random=rand.nextInt(values.size());\\n        return values.get(random);\\n    } \\n}\\n```\\n**COMPLEXITY:**\\n```\\nTime : Insert :O(1) and Remove:O(1)\\n Space:O(n)\\n```\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n     HashMap<Integer,Integer> valueIndexMap;\\n     ArrayList<Integer> values;\\n \\n    public RandomizedSet() {\\n        valueIndexMap=new HashMap<>();\\n        values=new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n       if(valueIndexMap.containsKey(val)) return false;\\n        values.add(val);\\n        valueIndexMap.put(val,values.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!valueIndexMap.containsKey(val)) return false;\\n        int idx=valueIndexMap.get(val);            //idx of value to be deleted\\n        if(idx==values.size()-1){\\n            valueIndexMap.remove(val);\\n             values.remove(values.size()-1);\\n            return true;\\n        }\\n        \\n        int lastValue=values.get(values.size()-1);  //last value\\n        valueIndexMap.remove(val);                 \\n        valueIndexMap.put(lastValue,idx);\\n     \\n        Collections.swap(values,idx,values.size()-1);\\n        values.remove(values.size()-1);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random rand=new Random();\\n        int random=rand.nextInt(values.size());\\n        return values.get(random);\\n    } \\n}\\n```\n```\\nTime : Insert :O(1) and Remove:O(1)\\n Space:O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110295,
                "title": "c-hash-map-to-vector-index-solution-with-explanations",
                "content": "**Thought process:**\\n* Constant insert, lookup, remove indicates we need a hash map or hash set. If there is no getRandom it would be the end of the story.\\n* Randomly access any data member is screaming for random access container, like vector.\\n* How to take advantage of the capabilities from both containers? We build a hash map mapping from key to vector index where key is the value.\\n* Insert and getRandom are easy and straight forward but remove is a bit tricky.\\n* If the item being removed is not at the end of the vector, we need to swap its position with the end of the vector item then reduce the vector size by one. Rememer to update hash map after vector data swap.\\n```\\n  /** Initialize your data structure here. */\\n  RandomizedSet() {\\n    // Could consider use time to init random seed here.\\n  }\\n    \\n  /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n  bool insert(int val) {\\n    auto itor = lut_.find(val);\\n    if (itor != lut_.end())\\n      return false;\\n    lut_.insert({val, vals_.size()});\\n    vals_.push_back(val);\\n    return true;\\n  }\\n  \\n  /** Removes a value from the set. Returns true if the set contained the specified element. */\\n  bool remove(int val) {\\n    auto itor = lut_.find(val);\\n    if (itor == lut_.end())\\n      return false;\\n    int pos = itor->second;\\n    lut_.erase(itor);\\n    if (pos != vals_.size()-1) {\\n      vals_[pos] = vals_.back();\\n      lut_[vals_[pos]] = pos;\\n    }\\n    vals_.pop_back();\\n    return true;\\n  }\\n  \\n  /** Get a random element from the set. */\\n  int getRandom() {\\n    return vals_[rand()%vals_.size()];\\n  }\\n\\nprivate:\\n  std::unordered_map<int, int> lut_;\\n  std::vector<int> vals_;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  /** Initialize your data structure here. */\\n  RandomizedSet() {\\n    // Could consider use time to init random seed here.\\n  }\\n    \\n  /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n  bool insert(int val) {\\n    auto itor = lut_.find(val);\\n    if (itor != lut_.end())\\n      return false;\\n    lut_.insert({val, vals_.size()});\\n    vals_.push_back(val);\\n    return true;\\n  }\\n  \\n  /** Removes a value from the set. Returns true if the set contained the specified element. */\\n  bool remove(int val) {\\n    auto itor = lut_.find(val);\\n    if (itor == lut_.end())\\n      return false;\\n    int pos = itor->second;\\n    lut_.erase(itor);\\n    if (pos != vals_.size()-1) {\\n      vals_[pos] = vals_.back();\\n      lut_[vals_[pos]] = pos;\\n    }\\n    vals_.pop_back();\\n    return true;\\n  }\\n  \\n  /** Get a random element from the set. */\\n  int getRandom() {\\n    return vals_[rand()%vals_.size()];\\n  }\\n\\nprivate:\\n  std::unordered_map<int, int> lut_;\\n  std::vector<int> vals_;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 932085,
                "title": "commented-c-easy",
                "content": "```\\nclass RandomizedSet {\\n    \\n    // has the numbers to store\\n    vector<int> num;\\n    \\n    // has index of the numbers stored\\n    unordered_map<int, int> num_index;\\n    \\npublic:\\n    RandomizedSet() {\\n    }\\n\\n   /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        \\n        // add number in our vector and store\\n        // its position in \\n        \\n        if(num_index.find(val) != num_index.end())\\n            return false;\\n            \\n        num.push_back(val);\\n        num_index[val] = (num.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        \\n        // we will remove the element from map and from vector\\n        // as well, but we can only remove from vector when it\\n        // the element to be removed is at the end\\n        \\n        // so, we will move the last element to the place of the\\n        // element to be removed and then  delete the last value\\n        // of the vector\\n        \\n        if(num_index.find(val) == num_index.end())\\n            return false;\\n        \\n        int last = num.back();\\n        int to_be_removed = num_index[val];\\n      \\n        num[to_be_removed] = last;\\n        num_index[last] = to_be_removed;\\n        num_index.erase(val);\\n        num.pop_back();\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return num[rand()%num.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    \\n    // has the numbers to store\\n    vector<int> num;\\n    \\n    // has index of the numbers stored\\n    unordered_map<int, int> num_index;\\n    \\npublic:\\n    RandomizedSet() {\\n    }\\n\\n   /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        \\n        // add number in our vector and store\\n        // its position in \\n        \\n        if(num_index.find(val) != num_index.end())\\n            return false;\\n            \\n        num.push_back(val);\\n        num_index[val] = (num.size()-1);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        \\n        // we will remove the element from map and from vector\\n        // as well, but we can only remove from vector when it\\n        // the element to be removed is at the end\\n        \\n        // so, we will move the last element to the place of the\\n        // element to be removed and then  delete the last value\\n        // of the vector\\n        \\n        if(num_index.find(val) == num_index.end())\\n            return false;\\n        \\n        int last = num.back();\\n        int to_be_removed = num_index[val];\\n      \\n        num[to_be_removed] = last;\\n        num_index[last] = to_be_removed;\\n        num_index.erase(val);\\n        num.pop_back();\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return num[rand()%num.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750733,
                "title": "c-solution-using-hashtable-and-array",
                "content": "```\\n/*\\n    https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/\\n*/\\nclass RandomizedSet {\\nprivate:\\n    // (element, idx in array)\\n    unordered_map<int, int> elements_;\\n    default_random_engine gen_;\\n    vector<int> all_nums_;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(elements_.count(val))\\n            return false;\\n        // The new element is added to the last of vector \\n        elements_.emplace(val, all_nums_.size());\\n        all_nums_.emplace_back(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(elements_.count(val)) {\\n            // to make the removal from array in O(1),\\n            // we swap it with the last element\\n            swap(all_nums_[elements_[val]], all_nums_.back());\\n            // update the index of swapped element in hash table\\n            elements_[all_nums_[elements_[val]]] = elements_[val];\\n            elements_.erase(val);\\n            all_nums_.pop_back();\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int low = 0, high = elements_.size() - 1;\\n        int idx = uniform_int_distribution<int>{low, high}(gen_);\\n        return all_nums_[idx];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/\\n*/\\nclass RandomizedSet {\\nprivate:\\n    // (element, idx in array)\\n    unordered_map<int, int> elements_;\\n    default_random_engine gen_;\\n    vector<int> all_nums_;\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(elements_.count(val))\\n            return false;\\n        // The new element is added to the last of vector \\n        elements_.emplace(val, all_nums_.size());\\n        all_nums_.emplace_back(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(elements_.count(val)) {\\n            // to make the removal from array in O(1),\\n            // we swap it with the last element\\n            swap(all_nums_[elements_[val]], all_nums_.back());\\n            // update the index of swapped element in hash table\\n            elements_[all_nums_[elements_[val]]] = elements_[val];\\n            elements_.erase(val);\\n            all_nums_.pop_back();\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int low = 0, high = elements_.size() - 1;\\n        int idx = uniform_int_distribution<int>{low, high}(gen_);\\n        return all_nums_[idx];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684531,
                "title": "vector-hashmap-c-easy-understanding-o-1-with-picture-explanation",
                "content": "\\nFirst we use srand(time(0)) to get the random value: if you curious check this out: http://www.cplusplus.com/reference/cstdlib/srand/\\n\\nonly unordered_set will not give you o(1) random_element_get\\n\\nyou need to use combination of map+ vector(List) as shown below:\\n\\n![image](https://assets.leetcode.com/users/frostcs/image_1592024176.png)\\n\\n\\n```\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n     srand(time(0));   \\n    }\\n    \\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(m.find(val) == m.end()){\\n            v.emplace_back(val);\\n            int n = v.size();\\n            m[val] = n-1;\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(m.find(val) == m.end()){\\n            return false;\\n        }\\n        m[v.back()] = m[val];\\n        v[m[val]] = v.back();\\n        v.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int r = rand() % v.size();\\n        return v[r];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n     srand(time(0));   \\n    }\\n    \\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(m.find(val) == m.end()){\\n            v.emplace_back(val);\\n            int n = v.size();\\n            m[val] = n-1;\\n            return true;\\n        } \\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(m.find(val) == m.end()){\\n            return false;\\n        }\\n        m[v.back()] = m[val];\\n        v[m[val]] = v.back();\\n        v.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int r = rand() % v.size();\\n        return v[r];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683944,
                "title": "c-simple-o-1-solution-using-list-and-dictionary",
                "content": "```\\npublic class RandomizedSet {\\n    private Dictionary<int,int> _dict;\\n    private List<int> _list;\\n    private Random _rand;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        _dict = new Dictionary<int,int>();\\n        _list = new List<int>();\\n        _rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) {\\n        if (_dict.ContainsKey(val))\\n            return false;\\n        _list.Add(val);\\n        int index = _list.Count-1;\\n        _dict[val] = index;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) {\\n        if (!_dict.ContainsKey(val))\\n            return false;\\n        int index = _dict[val];\\n        (_list[index], _list[^1]) = (_list[^1], _list[index]);\\n        _dict[_list[index]] = index;\\n        _list.RemoveAt(_list.Count-1);\\n        _dict.Remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() {\\n        int index = _rand.Next(0,_list.Count);\\n        return _list[index];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class RandomizedSet {\\n    private Dictionary<int,int> _dict;\\n    private List<int> _list;\\n    private Random _rand;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        _dict = new Dictionary<int,int>();\\n        _list = new List<int>();\\n        _rand = new Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) {\\n        if (_dict.ContainsKey(val))\\n            return false;\\n        _list.Add(val);\\n        int index = _list.Count-1;\\n        _dict[val] = index;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) {\\n        if (!_dict.ContainsKey(val))\\n            return false;\\n        int index = _dict[val];\\n        (_list[index], _list[^1]) = (_list[^1], _list[index]);\\n        _dict[_list[index]] = index;\\n        _list.RemoveAt(_list.Count-1);\\n        _dict.Remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() {\\n        int index = _rand.Next(0,_list.Count);\\n        return _list[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683882,
                "title": "heavily-commented-javascript-solution-with-thought-process-explained",
                "content": "```\\n/* Interesting question. My first thought would be to use a map/dict as that\\nwould support insert & remove at O(1)\\n\\nBut how would we make random work? to pick a random element, we need to either have a \\ntotal number, plus a way to access by that number. We could put the vals in an extra array\\nbut that would lead to O(n) with deletion. \\n\\nUnless we\\'re ok with ruining our look up array \\nand only delete when we come across them randomly when asked.\\nThat would work as long as there are not a ton of deletetions.\\n\\nAt this point I went to check solutions, I saw this one:\\nhttps://leetcode.com/explore/featured/card/june-leetcoding-challenge/540/week-2-june-8th-june-14th/3358/discuss/683603/Javascript-and-C%2B%2B-solutions/576499\\n\\nI don\\'t agree with the first solution, but the second is promising:\\n\\nA basic array with the inserts\\nA Map with the inserts as keys and the position in the basic array as values.\\n\\nAdding will be : \\nBasic array: push(inserted)\\nMap: set(inserted, basicArray.length - 1)\\n\\nRemoving will be:\\nMap: index = get(inserted) delete(inserted)\\nBasic Array: swap index with end of array (and update the swap in the Map) and pop off\\n\\nRandom is classic random on the array\\n\\nIt will be beautiful\\n\\n*/\\n\\n\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar RandomizedSet = function() {\\n    this.basicArray = [];\\n    this.map = new Map();\\n};\\n\\n/**\\n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (!this.map.has(val)) {\\n        // simple push\\n        this.basicArray.push(val);\\n    \\n        // store in map and also where in the array it\\'s located\\n        this.map.set(val, this.basicArray.length - 1);\\n        return true;\\n    } else {\\n        return false;\\n    }\\n    \\n};\\n\\n/**\\n * Removes a value from the set. Returns true if the set contained the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    var index;\\n    \\n    var swap = function (arr, i1, i2) {\\n        var temp = arr[i1];\\n        arr[i1] = arr[i2];\\n        arr[i2] = temp;\\n    }\\n    \\n    if (this.map.has(val)) {\\n        // where in the basic array is it\\n        index = this.map.get(val);\\n        \\n        // delete from map\\n        this.map.delete(val);\\n        \\n        // delete from array\\n        if (index !== this.basicArray.length - 1) {\\n            // we need to swap with the last element so we can pop it off\\n            // without disrupting too much else in the array. only the swapped item needs\\n            // to be updated in the map\\n            \\n            swap(this.basicArray, index, this.basicArray.length - 1);            \\n            \\n            // update the new location for the poor swapped item \\n            // that had nothing to do with val but just happened \\n            // to be at the end of the array\\n            this.map.set(this.basicArray[index], index);\\n        }\\n        this.basicArray.pop();\\n        return true;\\n        \\n    } else {\\n        return false;    \\n    }\\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    var randomIndex = Math.floor(this.basicArray.length * Math.random());\\n    \\n    return this.basicArray[randomIndex];\\n};\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/* Interesting question. My first thought would be to use a map/dict as that\\nwould support insert & remove at O(1)\\n\\nBut how would we make random work? to pick a random element, we need to either have a \\ntotal number, plus a way to access by that number. We could put the vals in an extra array\\nbut that would lead to O(n) with deletion. \\n\\nUnless we\\'re ok with ruining our look up array \\nand only delete when we come across them randomly when asked.\\nThat would work as long as there are not a ton of deletetions.\\n\\nAt this point I went to check solutions, I saw this one:\\nhttps://leetcode.com/explore/featured/card/june-leetcoding-challenge/540/week-2-june-8th-june-14th/3358/discuss/683603/Javascript-and-C%2B%2B-solutions/576499\\n\\nI don\\'t agree with the first solution, but the second is promising:\\n\\nA basic array with the inserts\\nA Map with the inserts as keys and the position in the basic array as values.\\n\\nAdding will be : \\nBasic array: push(inserted)\\nMap: set(inserted, basicArray.length - 1)\\n\\nRemoving will be:\\nMap: index = get(inserted) delete(inserted)\\nBasic Array: swap index with end of array (and update the swap in the Map) and pop off\\n\\nRandom is classic random on the array\\n\\nIt will be beautiful\\n\\n*/\\n\\n\\n\\n/**\\n * Initialize your data structure here.\\n */\\nvar RandomizedSet = function() {\\n    this.basicArray = [];\\n    this.map = new Map();\\n};\\n\\n/**\\n * Inserts a value to the set. Returns true if the set did not already contain the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (!this.map.has(val)) {\\n        // simple push\\n        this.basicArray.push(val);\\n    \\n        // store in map and also where in the array it\\'s located\\n        this.map.set(val, this.basicArray.length - 1);\\n        return true;\\n    } else {\\n        return false;\\n    }\\n    \\n};\\n\\n/**\\n * Removes a value from the set. Returns true if the set contained the specified element. \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    var index;\\n    \\n    var swap = function (arr, i1, i2) {\\n        var temp = arr[i1];\\n        arr[i1] = arr[i2];\\n        arr[i2] = temp;\\n    }\\n    \\n    if (this.map.has(val)) {\\n        // where in the basic array is it\\n        index = this.map.get(val);\\n        \\n        // delete from map\\n        this.map.delete(val);\\n        \\n        // delete from array\\n        if (index !== this.basicArray.length - 1) {\\n            // we need to swap with the last element so we can pop it off\\n            // without disrupting too much else in the array. only the swapped item needs\\n            // to be updated in the map\\n            \\n            swap(this.basicArray, index, this.basicArray.length - 1);            \\n            \\n            // update the new location for the poor swapped item \\n            // that had nothing to do with val but just happened \\n            // to be at the end of the array\\n            this.map.set(this.basicArray[index], index);\\n        }\\n        this.basicArray.pop();\\n        return true;\\n        \\n    } else {\\n        return false;    \\n    }\\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    var randomIndex = Math.floor(this.basicArray.length * Math.random());\\n    \\n    return this.basicArray[randomIndex];\\n};\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249013,
                "title": "java-concise-fast-beats-100",
                "content": "There\\'s no cool new idea here; it\\'s just another HashMap & ArrayList solution.\\n\\nBut I noticed that many of the posted solutions are very...wordy.  I\\'ve tried to be more concise.\\n\\n```\\nclass RandomizedSet {\\n    ArrayList<Integer> byIndex = new ArrayList<Integer>();\\n    HashMap<Integer,Integer> byValue = new HashMap<Integer,Integer>();\\n    Random rng = new Random();\\n\\n    public RandomizedSet() {}\\n    \\n    public boolean insert(int val) {\\n        if( byValue.containsKey(val) ) return false;\\n        byValue.put( val, byValue.size() );\\n        byIndex.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if( !byValue.containsKey(val) ) return false;\\n        byIndex.set( byValue.get(val), byIndex.get( byIndex.size()-1 ) );\\n        byValue.put( byIndex.remove( byIndex.size()-1 ), byValue.get(val) );\\n        byValue.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() { return byIndex.get( rng.nextInt( byIndex.size() ) ); }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    ArrayList<Integer> byIndex = new ArrayList<Integer>();\\n    HashMap<Integer,Integer> byValue = new HashMap<Integer,Integer>();\\n    Random rng = new Random();\\n\\n    public RandomizedSet() {}\\n    \\n    public boolean insert(int val) {\\n        if( byValue.containsKey(val) ) return false;\\n        byValue.put( val, byValue.size() );\\n        byIndex.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if( !byValue.containsKey(val) ) return false;\\n        byIndex.set( byValue.get(val), byIndex.get( byIndex.size()-1 ) );\\n        byValue.put( byIndex.remove( byIndex.size()-1 ), byValue.get(val) );\\n        byValue.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() { return byIndex.get( rng.nextInt( byIndex.size() ) ); }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904434,
                "title": "using-one-hash-map-and-one-array",
                "content": "# Code\\n```\\nvar RandomizedSet = function () {\\n    this.data = []; // Store the elements in the set\\n    this.indexMap = new Map(); // Map to store element-to-index mapping\\n};\\n\\n/** \\n * Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n * @param {number} val - The value to insert.\\n * @return {boolean} - True if the set did not already contain the specified element, otherwise false.\\n */\\nRandomizedSet.prototype.insert = function (val) {\\n    if (this.indexMap.has(val)) return false; // Element already exists in the set\\n    this.data.push(val); // Add the element to the end of the array\\n    this.indexMap.set(val, this.data.length - 1); // Map element to its index\\n    return true;\\n};\\n\\n/** \\n * Removes a value from the set. Returns true if the set contained the specified element.\\n * @param {number} val - The value to remove.\\n * @return {boolean} - True if the set contained the specified element, otherwise false.\\n */\\nRandomizedSet.prototype.remove = function (val) {\\n    if (!this.indexMap.has(val)) return false; // Element doesn\\'t exist in the set\\n\\n    const index = this.indexMap.get(val); // Get the index of the element to remove\\n    const lastElement = this.data.pop(); // Remove and get the last element\\n\\n    // If the element to remove is not the last element, swap it with the last element\\n    if (index !== this.data.length) {\\n        this.data[index] = lastElement; // Swap with the removed element\\n        this.indexMap.set(lastElement, index); // Update indexMap\\n    }\\n\\n    this.indexMap.delete(val); // Remove the element from the indexMap\\n    return true;\\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number} - A random element from the set.\\n */\\nRandomizedSet.prototype.getRandom = function () {\\n    const i = Math.floor(Math.random() * this.data.length); // Generate a random index\\n    return this.data[i]; // Return the element at the random index\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar RandomizedSet = function () {\\n    this.data = []; // Store the elements in the set\\n    this.indexMap = new Map(); // Map to store element-to-index mapping\\n};\\n\\n/** \\n * Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n * @param {number} val - The value to insert.\\n * @return {boolean} - True if the set did not already contain the specified element, otherwise false.\\n */\\nRandomizedSet.prototype.insert = function (val) {\\n    if (this.indexMap.has(val)) return false; // Element already exists in the set\\n    this.data.push(val); // Add the element to the end of the array\\n    this.indexMap.set(val, this.data.length - 1); // Map element to its index\\n    return true;\\n};\\n\\n/** \\n * Removes a value from the set. Returns true if the set contained the specified element.\\n * @param {number} val - The value to remove.\\n * @return {boolean} - True if the set contained the specified element, otherwise false.\\n */\\nRandomizedSet.prototype.remove = function (val) {\\n    if (!this.indexMap.has(val)) return false; // Element doesn\\'t exist in the set\\n\\n    const index = this.indexMap.get(val); // Get the index of the element to remove\\n    const lastElement = this.data.pop(); // Remove and get the last element\\n\\n    // If the element to remove is not the last element, swap it with the last element\\n    if (index !== this.data.length) {\\n        this.data[index] = lastElement; // Swap with the removed element\\n        this.indexMap.set(lastElement, index); // Update indexMap\\n    }\\n\\n    this.indexMap.delete(val); // Remove the element from the indexMap\\n    return true;\\n};\\n\\n/**\\n * Get a random element from the set.\\n * @return {number} - A random element from the set.\\n */\\nRandomizedSet.prototype.getRandom = function () {\\n    const i = Math.floor(Math.random() * this.data.length); // Generate a random index\\n    return this.data[i]; // Return the element at the random index\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767488,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\n\\n    Set<Integer> s;\\n    public RandomizedSet() {\\n     s=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(s.contains(val)){\\n            return false;\\n        }\\n        else{\\n            s.add(val);\\n            return true;\\n        }\\n\\n    }\\n    \\n    public boolean remove(int val) {\\n         if(s.contains(val)){\\n           s.remove(val);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n       List<Integer> list = new ArrayList<Integer>(s);\\n       int r=(int)(Math.random()*s.size());\\n        \\n       return list.get(r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\n    Set<Integer> s;\\n    public RandomizedSet() {\\n     s=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(s.contains(val)){\\n            return false;\\n        }\\n        else{\\n            s.add(val);\\n            return true;\\n        }\\n\\n    }\\n    \\n    public boolean remove(int val) {\\n         if(s.contains(val)){\\n           s.remove(val);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n       List<Integer> list = new ArrayList<Integer>(s);\\n       int r=(int)(Math.random()*s.size());\\n        \\n       return list.get(r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757600,
                "title": "c-simple-solution-using-unordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing unordered_set\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitializing unordered_set and simply checking whether element is present or not, inserting, erasing. Randomly selecting any insex and advancing iterator to that index and returning value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> s;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)==s.end())\\n        {\\n            s.insert(val);\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n        return false;\\n        else\\n        {\\n            s.erase(val);\\n            return true;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int t = rand()%s.size();\\n        auto it = s.begin();\\n        advance(it,t);\\n        return *(it);\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```\\nPlease upvote if you liked solution",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> s;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val)==s.end())\\n        {\\n            s.insert(val);\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n        return false;\\n        else\\n        {\\n            s.erase(val);\\n            return true;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int t = rand()%s.size();\\n        auto it = s.begin();\\n        advance(it,t);\\n        return *(it);\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687193,
                "title": "step-by-step-approach-o-1",
                "content": "# Intuition\\nThe problem requires us to implement a data structure called RandomizedSet, which supports three operations: insert, remove, and getRandom. The insert operation adds a value to the set if it doesn\\'t already exist and returns true, or returns false if the value already exists. The remove operation removes a value from the set if it exists and returns true, or returns false if the value doesn\\'t exist. The getRandom operation returns a random value from the set.\\n\\n# Approach\\nTo solve this problem, we can use a combination of a Set and an array. We\\'ll use the Set to store the unique values and ensure constant-time operations for checking existence and removing values. We\\'ll use the array to store the values in a random order and facilitate the getRandom operation.\\n\\nHere\\'s a breakdown of each operation:\\n\\n1. insert(val: number): boolean: To insert a value, we\\'ll first check if it already exists in the set using set.has(val). If it does, we\\'ll return false to indicate that the value was not inserted. Otherwise, we\\'ll add the value to both the set and the array, and return true.\\n\\n2. remove(val: number): boolean: To remove a value, we\\'ll first check if it exists in the set using set.has(val). If it doesn\\'t, we\\'ll return false to indicate that the value was not removed. Otherwise, we\\'ll delete the value from both the set and the array. To efficiently remove the value from the array, we\\'ll swap it with the last value in the array and then pop the last element. This way, the array remains in a random order even after removal. Finally, we\\'ll return true.\\n\\n3. getRandom(): number: To get a random value, we\\'ll convert the set to an array using Array.from(set). Then, we\\'ll generate a random index within the bounds of the array using Math.random() * array.length. Finally, we\\'ll return the value at the random index.\\n\\n# Complexity\\n- Time complexity:\\nInsert: O(1)\\nRemove: O(1)\\ngetRandom: O(1)\\n- Space complexity:\\nO(n), where n is the number of elements in the set.\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    private set: Set<number>;\\n    private array: number[];\\n\\n    constructor() {\\n        this.set = new Set<number>();\\n        this.array = [];\\n    }\\n\\n    insert(val: number): boolean {\\n        if (this.set.has(val)) {\\n            return false;\\n        }\\n        this.set.add(val);\\n        this.array.push(val);\\n        return true;\\n    }\\n\\n    remove(val: number): boolean {\\n        if (!this.set.has(val)) {\\n            return false;\\n        }\\n        this.set.delete(val);\\n        const index = this.array.indexOf(val);\\n        this.array[index] = this.array[this.array.length - 1];\\n        this.array.pop();\\n        return true;\\n    }\\n\\n    getRandom(): number {\\n        const randomIndex = Math.floor(Math.random() * this.array.length);\\n        return this.array[randomIndex];\\n    }\\n}\\n\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Hash Table",
                    "Randomized"
                ],
                "code": "```\\nclass RandomizedSet {\\n    private set: Set<number>;\\n    private array: number[];\\n\\n    constructor() {\\n        this.set = new Set<number>();\\n        this.array = [];\\n    }\\n\\n    insert(val: number): boolean {\\n        if (this.set.has(val)) {\\n            return false;\\n        }\\n        this.set.add(val);\\n        this.array.push(val);\\n        return true;\\n    }\\n\\n    remove(val: number): boolean {\\n        if (!this.set.has(val)) {\\n            return false;\\n        }\\n        this.set.delete(val);\\n        const index = this.array.indexOf(val);\\n        this.array[index] = this.array[this.array.length - 1];\\n        this.array.pop();\\n        return true;\\n    }\\n\\n    getRandom(): number {\\n        const randomIndex = Math.floor(Math.random() * this.array.length);\\n        return this.array[randomIndex];\\n    }\\n}\\n\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666361,
                "title": "insert-delete-getrandom-o-1",
                "content": "```\\nclass RandomizedSet {\\n\\n    Set<Integer> s;\\n    public RandomizedSet() {\\n     s=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(s.contains(val)){\\n            return false;\\n        }\\n        else{\\n            s.add(val);\\n            return true;\\n        }\\n\\n    }\\n    \\n    public boolean remove(int val) {\\n         if(s.contains(val)){\\n           s.remove(val);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n       List<Integer> list = new ArrayList<Integer>(s);\\n       int r=(int)(Math.random()*s.size());\\n        \\n       return list.get(r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\n    Set<Integer> s;\\n    public RandomizedSet() {\\n     s=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(s.contains(val)){\\n            return false;\\n        }\\n        else{\\n            s.add(val);\\n            return true;\\n        }\\n\\n    }\\n    \\n    public boolean remove(int val) {\\n         if(s.contains(val)){\\n           s.remove(val);\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    \\n    public int getRandom() {\\n       List<Integer> list = new ArrayList<Integer>(s);\\n       int r=(int)(Math.random()*s.size());\\n        \\n       return list.get(r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399642,
                "title": "simple-c-solution-using-unordered-set",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() {\\n        \\n    }\\n    bool insert(int val) {\\n        if (st.count(val)) return false;\\n        st.insert(val);\\n        return true;\\n    }\\n    bool remove(int val) {\\n        if (!st.count(val)) return false;\\n        st.erase(val);\\n        return true;\\n    }\\n    int getRandom() {\\n        int n = rand() % st.size();\\n        auto it = st.begin();\\n        advance(it, n);\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() {\\n        \\n    }\\n    bool insert(int val) {\\n        if (st.count(val)) return false;\\n        st.insert(val);\\n        return true;\\n    }\\n    bool remove(int val) {\\n        if (!st.count(val)) return false;\\n        st.erase(val);\\n        return true;\\n    }\\n    int getRandom() {\\n        int n = rand() % st.size();\\n        auto it = st.begin();\\n        advance(it, n);\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859704,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Map or Set\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code 1\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(!mp.count(val)) {\\n            arr.push_back(val);\\n            mp[val] = arr.size() - 1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.count(val)) {\\n            int idx = mp[val];\\n            int last_val = arr.back();\\n            arr[idx] = last_val;\\n            arr.pop_back();  \\n            mp[last_val] = idx;            \\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int rand_idx = rand() % arr.size();\\n        return arr[rand_idx];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```\\n\\n\\n# Code 2\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> st;\\n\\n    RandomizedSet() {\\n  \\n    }\\n\\n    bool insert(int val) {\\n        if(!st.count(val)) {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.count(val)) {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int r = rand() % st.size();\\n        return *next(st.begin(), r);\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int, int> mp;\\n    vector<int> arr;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(!mp.count(val)) {\\n            arr.push_back(val);\\n            mp[val] = arr.size() - 1;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(mp.count(val)) {\\n            int idx = mp[val];\\n            int last_val = arr.back();\\n            arr[idx] = last_val;\\n            arr.pop_back();  \\n            mp[last_val] = idx;            \\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int rand_idx = rand() % arr.size();\\n        return arr[rand_idx];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> st;\\n\\n    RandomizedSet() {\\n  \\n    }\\n\\n    bool insert(int val) {\\n        if(!st.count(val)) {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.count(val)) {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int r = rand() % st.size();\\n        return *next(st.begin(), r);\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859563,
                "title": "java-easy-to-understand-hashmap-arraylist",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/design/RandomizedSet.java",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2859235,
                "title": "rust-swap-remove",
                "content": "# Code\\n```rust\\nuse std::collections::HashMap;\\nuse rand::seq::SliceRandom;\\n\\nstruct RandomizedSet {\\n    hash: HashMap<i32, usize>,\\n    v: Vec<i32>,\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RandomizedSet {\\n\\n    fn new() -> Self {\\n        Self {\\n            hash: HashMap::new(),\\n            v: Vec::new(),\\n        }\\n    }\\n    \\n    fn insert(&mut self, val: i32) -> bool {\\n        if self.hash.contains_key(&val) {\\n            return false;\\n        }\\n        self.hash.insert(val, self.v.len());\\n        self.v.push(val);\\n        true\\n    }\\n    \\n    fn remove(&mut self, val: i32) -> bool {\\n        match self.hash.remove(&val) {\\n            None => false,\\n            Some(i) => {\\n                self.v.swap_remove(i);\\n                if i < self.v.len() {\\n                    self.hash.insert(self.v[i], i);\\n                }\\n                true\\n            }\\n        }\\n    }\\n    \\n    fn get_random(&self) -> i32 {\\n        *self.v.choose(&mut rand::thread_rng()).unwrap()\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * let obj = RandomizedSet::new();\\n * let ret_1: bool = obj.insert(val);\\n * let ret_2: bool = obj.remove(val);\\n * let ret_3: i32 = obj.get_random();\\n */\\n```",
                "solutionTags": [
                    "Rust",
                    "Hash Table"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\nuse rand::seq::SliceRandom;\\n\\nstruct RandomizedSet {\\n    hash: HashMap<i32, usize>,\\n    v: Vec<i32>,\\n}\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl RandomizedSet {\\n\\n    fn new() -> Self {\\n        Self {\\n            hash: HashMap::new(),\\n            v: Vec::new(),\\n        }\\n    }\\n    \\n    fn insert(&mut self, val: i32) -> bool {\\n        if self.hash.contains_key(&val) {\\n            return false;\\n        }\\n        self.hash.insert(val, self.v.len());\\n        self.v.push(val);\\n        true\\n    }\\n    \\n    fn remove(&mut self, val: i32) -> bool {\\n        match self.hash.remove(&val) {\\n            None => false,\\n            Some(i) => {\\n                self.v.swap_remove(i);\\n                if i < self.v.len() {\\n                    self.hash.insert(self.v[i], i);\\n                }\\n                true\\n            }\\n        }\\n    }\\n    \\n    fn get_random(&self) -> i32 {\\n        *self.v.choose(&mut rand::thread_rng()).unwrap()\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * let obj = RandomizedSet::new();\\n * let ret_1: bool = obj.insert(val);\\n * let ret_2: bool = obj.remove(val);\\n * let ret_3: i32 = obj.get_random();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2859143,
                "title": "easy-approach-using-map-c-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we are using array, then insert and getRandom operation will take constant time but delete operation will take linear time complexity, as we will have to traverse to that index. But we can do it in O(1) time if we can store the indexes of each element in array somewhere so that instead of traversing each time for deletion, we can directly go to that index and delete.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We can use unordered map to store the indexes as it operates in constant time complexity.\\n2. While inserting the val to our set, we will store its index in map.\\n3. While deleting, we can simply pop back after locating the last element to current index as order of elements do not matter here.\\n4. Update the index of last element in map which was shifted.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    vector<int> set;\\n    unordered_map<int,int> indexFinder;\\n    RandomizedSet() {\\n        //RandomizedSet randomizedSet = new RandomizedSet();\\n    }\\n    \\n    bool insert(int val) {\\n        if(indexFinder.find(val) != indexFinder.end()) return false;\\n        else\\n        {\\n            set.push_back(val);\\n            indexFinder[val] = set.size()-1;\\n            return true;\\n        }\\n    }\\n    \\n    bool remove(int val) {\\n        if(indexFinder.find(val) == indexFinder.end()) return false;\\n        else{\\n            int lastEle = set.back();\\n            int indexToBeRemoved = indexFinder[val];\\n            set[indexToBeRemoved] = lastEle;\\n            set.pop_back();\\n            indexFinder[lastEle] = indexToBeRemoved;\\n            indexFinder.erase(val);\\n            return true;\\n\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return set[rand()%set.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    vector<int> set;\\n    unordered_map<int,int> indexFinder;\\n    RandomizedSet() {\\n        //RandomizedSet randomizedSet = new RandomizedSet();\\n    }\\n    \\n    bool insert(int val) {\\n        if(indexFinder.find(val) != indexFinder.end()) return false;\\n        else\\n        {\\n            set.push_back(val);\\n            indexFinder[val] = set.size()-1;\\n            return true;\\n        }\\n    }\\n    \\n    bool remove(int val) {\\n        if(indexFinder.find(val) == indexFinder.end()) return false;\\n        else{\\n            int lastEle = set.back();\\n            int indexToBeRemoved = indexFinder[val];\\n            set[indexToBeRemoved] = lastEle;\\n            set.pop_back();\\n            indexFinder[lastEle] = indexToBeRemoved;\\n            indexFinder.erase(val);\\n            return true;\\n\\n        }\\n    }\\n    \\n    int getRandom() {\\n        return set[rand()%set.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859001,
                "title": "python-pain",
                "content": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.storage = dict() # \\n        self.MODULO = 1000\\n        self.vals = []\\n\\n        \\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.storage:\\n            return False\\n        else:\\n            self.storage[val] = len(self.vals)\\n            self.vals.append(val)\\n            return True\\n        \\n    def remove(self, val: int) -> bool:\\n        \\n        if val in self.storage:\\n            index_of_removal = self.storage[val]\\n            self.vals[index_of_removal] = self.vals[-1]\\n            self.storage[self.vals[-1]] = index_of_removal\\n            self.vals.pop()\\n            del self.storage[val]\\n            \\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        return choice(self.vals)\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.storage = dict() # \\n        self.MODULO = 1000\\n        self.vals = []\\n\\n        \\n    def insert(self, val: int) -> bool:\\n        \\n        if val in self.storage:\\n            return False\\n        else:\\n            self.storage[val] = len(self.vals)\\n            self.vals.append(val)\\n            return True\\n        \\n    def remove(self, val: int) -> bool:\\n        \\n        if val in self.storage:\\n            index_of_removal = self.storage[val]\\n            self.vals[index_of_removal] = self.vals[-1]\\n            self.storage[self.vals[-1]] = index_of_removal\\n            self.vals.pop()\\n            del self.storage[val]\\n            \\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        return choice(self.vals)\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858556,
                "title": "most-easiest-clean-optimized-code",
                "content": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() { }\\n    \\n    bool insert(int val) {\\n        if(!st.count(val)) {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.count(val))\\n        {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        vector<int> a;\\n        for(auto it : st) a.push_back(it);\\n        return a[(rand() % a.size())];  // rand() function % size of the array, means it will generate a random index from 0 to array.size()-1, thats all we need.\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n ```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() { }\\n    \\n    bool insert(int val) {\\n        if(!st.count(val)) {\\n            st.insert(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.count(val))\\n        {\\n            st.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        vector<int> a;\\n        for(auto it : st) a.push_back(it);\\n        return a[(rand() % a.size())];  // rand() function % size of the array, means it will generate a random index from 0 to array.size()-1, thats all we need.\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2858469,
                "title": "javascript-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/11/insert-delete-getrandom-o1.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\n\\nvar RandomizedSet = function() {\\n    this.map = new Map();\\n    this.list = [];\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.map.has(val)) return false;\\n\\n    this.map.set(val, this.list.length);\\n    this.list.push(val);\\n    return true;\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    if (!this.map.has(val)) return false;\\n\\n    const idx = this.map.get(val);\\n    this._swap(idx, this.list.length - 1);\\n    this.list.pop();\\n    this.map.set(this.list[idx], idx);\\n    this.map.delete(val);\\n    return true;\\n};\\n\\n/**\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.list[Math.floor(Math.random() * this.list.length)];\\n};\\n\\nRandomizedSet.prototype._swap = function(a, b) {\\n    const tmp = this.list[a];\\n    this.list[a] = this.list[b];\\n    this.list[b] = tmp;\\n};\\n\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar RandomizedSet = function() {\\n    this.map = new Map();\\n    this.list = [];\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.map.has(val)) return false;\\n\\n    this.map.set(val, this.list.length);\\n    this.list.push(val);\\n    return true;\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    if (!this.map.has(val)) return false;\\n\\n    const idx = this.map.get(val);\\n    this._swap(idx, this.list.length - 1);\\n    this.list.pop();\\n    this.map.set(this.list[idx], idx);\\n    this.map.delete(val);\\n    return true;\\n};\\n\\n/**\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.list[Math.floor(Math.random() * this.list.length)];\\n};\\n\\nRandomizedSet.prototype._swap = function(a, b) {\\n    const tmp = this.list[a];\\n    this.list[a] = this.list[b];\\n    this.list[b] = tmp;\\n};\\n\\n\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858206,
                "title": "simple-ts-solution",
                "content": "# Intuition\\nSet can do all tasks except for getRandom().\\nHence, the task is to establish the getRandom() function.\\n\\n# Approach\\nUse an array to store values, use a Map to store val -> position_in_array.\\n\\nThen for insert, array push is O(1), record position is easy.\\n\\nFor delete, Map delete is O(1), if element is at last, array pop is O(1), if it is not at the last position, swap the element at last position with it, update the position record in Map. Then pop() O(1).\\n\\nTo get random index, just use `Math.floor(Math.random() * array.length)`.\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(n) where n is the maximum number of elements stored.\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    valPos: Map<number, number> // value, index\\n    vals: number[]\\n\\n    constructor() {\\n        this.valPos = new Map()\\n        this.vals = []\\n    }\\n\\n    insert(val: number): boolean {\\n        if (this.valPos.has(val)) return false\\n        this.valPos.set(val, this.vals.length)\\n        this.vals.push(val)\\n        return true\\n    }\\n\\n    remove(val: number): boolean {\\n        if (!this.valPos.has(val)) return false\\n        const pos = this.valPos.get(val)\\n        if (pos !== this.vals.length - 1) {\\n            const lastVal = this.vals[this.vals.length - 1];\\n            // swap position with the last element\\n            [this.vals[pos], this.vals[this.vals.length - 1]] = [this.vals[this.vals.length - 1], this.vals[pos]]\\n            this.valPos.set(lastVal, pos) // update position record\\n        }\\n        this.valPos.delete(val)\\n        this.vals.pop()\\n        return true\\n    }\\n\\n    getRandom(): number {\\n        return this.vals[Math.floor(Math.random() * this.vals.length)]\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass RandomizedSet {\\n    valPos: Map<number, number> // value, index\\n    vals: number[]\\n\\n    constructor() {\\n        this.valPos = new Map()\\n        this.vals = []\\n    }\\n\\n    insert(val: number): boolean {\\n        if (this.valPos.has(val)) return false\\n        this.valPos.set(val, this.vals.length)\\n        this.vals.push(val)\\n        return true\\n    }\\n\\n    remove(val: number): boolean {\\n        if (!this.valPos.has(val)) return false\\n        const pos = this.valPos.get(val)\\n        if (pos !== this.vals.length - 1) {\\n            const lastVal = this.vals[this.vals.length - 1];\\n            // swap position with the last element\\n            [this.vals[pos], this.vals[this.vals.length - 1]] = [this.vals[this.vals.length - 1], this.vals[pos]]\\n            this.valPos.set(lastVal, pos) // update position record\\n        }\\n        this.valPos.delete(val)\\n        this.vals.pop()\\n        return true\\n    }\\n\\n    getRandom(): number {\\n        return this.vals[Math.floor(Math.random() * this.vals.length)]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858162,
                "title": "daily-leetcoding-challenge-november-day-29",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/insert-delete-getrandom-o1/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** HashMap + ArrayList\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/insert-delete-getrandom-o1/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2853456,
                "title": "java-randomizedset-has-hybrid-set-made-of-map-and-list-to-allow-tc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- As the name of the class says, it shall behave like a set upon insertion or removal of values. So a \"set-ish\" abstract data type is needed to store the values, and will allow constant access times for insertion and removal.\\n- The randomized get() requires to use a random number generator to calculate the choice, and one can assume, that the library standard provides such a constant time random number generator.\\n- But the Java sets do not provide constant time random access methods to the stored items by index. Thus, a common set must probably be iterated.\\n- To support both acess methods (insert/remove by key, and get by randomized index), a kind of hybrid data structure is needed: a set that can be accessed randomly by index, like a list, and by key, like a set or map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use a HashMap to store the inserted values (as keys), so that the set aspect gets satisfied.\\n- Use an ArrayList to store the values as themselves, and use the indexes of the values in the list as values for the key map. This satisfies the random access by index requirement.\\n- Both tables are associated by the indexes:\\n  - HashMap: value (key aspect) --> index\\n  - ArrayList: index --> value (value aspect).\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ average for all operations\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, where n is the number of items stored in the class at any time. Grows by one with each successful insertion, shrinks by one with each successful removal.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet {\\n\\n    private final Map<Integer, Integer> keys;\\n    private final List<Integer> values;\\n    private final Random random = new Random();\\n\\n    public RandomizedSet() {\\n        keys = new HashMap<>();\\n        values = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (keys.containsKey(val)) return false;\\n        keys.put(val, values.size());\\n        values.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!keys.containsKey(val)) return false;\\n        int candidateIndex = keys.get(val);\\n        int lastIndex = values.size() - 1;\\n        values.set(candidateIndex, values.get(lastIndex));\\n        keys.put(values.get(candidateIndex), candidateIndex);\\n        keys.remove(val);\\n        values.remove(lastIndex);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        return values.get(random.nextInt(values.size()));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n\\n    private final Map<Integer, Integer> keys;\\n    private final List<Integer> values;\\n    private final Random random = new Random();\\n\\n    public RandomizedSet() {\\n        keys = new HashMap<>();\\n        values = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        if (keys.containsKey(val)) return false;\\n        keys.put(val, values.size());\\n        values.add(val);\\n        return true;\\n    }\\n\\n    public boolean remove(int val) {\\n        if (!keys.containsKey(val)) return false;\\n        int candidateIndex = keys.get(val);\\n        int lastIndex = values.size() - 1;\\n        values.set(candidateIndex, values.get(lastIndex));\\n        keys.put(values.get(candidateIndex), candidateIndex);\\n        keys.remove(val);\\n        values.remove(lastIndex);\\n        return true;\\n    }\\n\\n    public int getRandom() {\\n        return values.get(random.nextInt(values.size()));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847534,
                "title": "javascript-map",
                "content": "It\\'s easy to solve this problem by Object in JavaScript. But hashmap is a good way that need to be implement.\\n\\nRecord the Value-Index pair in hashmap to simplify the remove process.\\n\\n```\\n\\nvar RandomizedSet = function() {\\n    this.set = [];\\n    // record the value index to simpilfy the element swap\\n    this.valueIndexMap = new Map();\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.valueIndexMap.has(val)) {\\n        return false;\\n    }\\n    this.set.push(val);\\n    this.valueIndexMap.set(val, this.set.length -1);\\n    return true;\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    if (!this.valueIndexMap.has(val)) {\\n        return false;\\n    }\\n    const indexToRemove = this.valueIndexMap.get(val);\\n    // update valueIndexMap first\\n    this.valueIndexMap.set(this.set[this.set.length - 1], indexToRemove);\\n    this.valueIndexMap.delete(val);\\n    this.set[indexToRemove] = this.set[this.set.length - 1];\\n    this.set[this.set.length - 1] = val;\\n    this.set.pop();\\n    return true;\\n};\\n\\n/**\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.set[Math.floor(Math.random()*this.set.length)];\\n}\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar RandomizedSet = function() {\\n    this.set = [];\\n    // record the value index to simpilfy the element swap\\n    this.valueIndexMap = new Map();\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.insert = function(val) {\\n    if (this.valueIndexMap.has(val)) {\\n        return false;\\n    }\\n    this.set.push(val);\\n    this.valueIndexMap.set(val, this.set.length -1);\\n    return true;\\n};\\n\\n/** \\n * @param {number} val\\n * @return {boolean}\\n */\\nRandomizedSet.prototype.remove = function(val) {\\n    if (!this.valueIndexMap.has(val)) {\\n        return false;\\n    }\\n    const indexToRemove = this.valueIndexMap.get(val);\\n    // update valueIndexMap first\\n    this.valueIndexMap.set(this.set[this.set.length - 1], indexToRemove);\\n    this.valueIndexMap.delete(val);\\n    this.set[indexToRemove] = this.set[this.set.length - 1];\\n    this.set[this.set.length - 1] = val;\\n    this.set.pop();\\n    return true;\\n};\\n\\n/**\\n * @return {number}\\n */\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.set[Math.floor(Math.random()*this.set.length)];\\n}\\n/** \\n * Your RandomizedSet object will be instantiated and called as such:\\n * var obj = new RandomizedSet()\\n * var param_1 = obj.insert(val)\\n * var param_2 = obj.remove(val)\\n * var param_3 = obj.getRandom()\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2786085,
                "title": "optimised-java-solution-unlike-others-only-hashset",
                "content": "**Easiest Solution :D\\nUpvote \\uD83D\\uDD3C\\u2705**\\n```\\nclass RandomizedSet {\\n\\n    HashSet<Integer> hs;\\n    \\n    public RandomizedSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(!hs.contains(val))\\n        {\\n            hs.add(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(hs.contains(val))\\n        {\\n            hs.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    int t=0;\\n    public int getRandom() {\\n        \\n        //int n=hs.size();\\n       List<Integer> list = new ArrayList<Integer>(hs);\\n       int r=(int)(Math.random()*hs.size());\\n        \\n       return list.get(r);\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "**Easiest Solution :D\\nUpvote \\uD83D\\uDD3C\\u2705**\\n```\\nclass RandomizedSet {\\n\\n    HashSet<Integer> hs;\\n    \\n    public RandomizedSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(!hs.contains(val))\\n        {\\n            hs.add(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(hs.contains(val))\\n        {\\n            hs.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    int t=0;\\n    public int getRandom() {\\n        \\n        //int n=hs.size();\\n       List<Integer> list = new ArrayList<Integer>(hs);\\n       int r=(int)(Math.random()*hs.size());\\n        \\n       return list.get(r);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2309586,
                "title": "easy-solution-using-vectors-and-map-c",
                "content": "Please upvote if you like my solution .\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    int size;\\n    RandomizedSet() {\\n        size = 0;\\n    }\\n    \\n    bool insert(int val) {\\n        if(m.find(val) == m.end()){\\n            m[val] = size;\\n            v.push_back(val);\\n            size++;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(m.find(val) != m.end()){\\n            int ind = m[val];\\n            v[ind] = v[size-1];\\n            v.pop_back();\\n            m[v[ind]] = ind;\\n            m.erase(val);\\n            size--;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int ans = rand()%size;\\n        return v[ans];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    int size;\\n    RandomizedSet() {\\n        size = 0;\\n    }\\n    \\n    bool insert(int val) {\\n        if(m.find(val) == m.end()){\\n            m[val] = size;\\n            v.push_back(val);\\n            size++;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool remove(int val) {\\n        if(m.find(val) != m.end()){\\n            int ind = m[val];\\n            v[ind] = v[size-1];\\n            v.pop_back();\\n            m[v[ind]] = ind;\\n            m.erase(val);\\n            size--;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        int ans = rand()%size;\\n        return v[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219082,
                "title": "easy-solution-combined-array-and-hashmap",
                "content": "If we only consider the insert and delete method, hashmap can solve this proble. \\nAdding the new function: Each element must have the same probability of being returned.\\nSo Array is must be used to generate the random index number. \\nHashMap key is its value, and value part is the index of the key in the arraylist to maintain this arraylist to achieve random pick function.\\n\\n```\\nclass RandomizedSet {\\n    Map<Integer, Integer> map;\\n    List<Integer> loc;\\n    Random rand;\\n    public RandomizedSet() {\\n        \\n        map = new HashMap<>();\\n        loc = new ArrayList<>();\\n        rand = new Random();\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n        if(map.containsKey(val)){\\n            return false;\\n        }\\n        map.put(val, loc.size());\\n        loc.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)){\\n            return false;\\n        }\\n        \\n        int temp;\\n        int index = map.get(val);\\n        temp = loc.get(loc.size() - 1);\\n        loc.set(index, temp);\\n        \\n        loc.remove(loc.size() - 1);\\n        \\n        map.put(temp, index);\\n        map.remove(val);\\n        return true;\\n\\n    }\\n    \\n    public int getRandom() {\\n        return loc.get(rand.nextInt(loc.size()));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass RandomizedSet {\\n    Map<Integer, Integer> map;\\n    List<Integer> loc;\\n    Random rand;\\n    public RandomizedSet() {\\n        \\n        map = new HashMap<>();\\n        loc = new ArrayList<>();\\n        rand = new Random();\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n        if(map.containsKey(val)){\\n            return false;\\n        }\\n        map.put(val, loc.size());\\n        loc.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val)){\\n            return false;\\n        }\\n        \\n        int temp;\\n        int index = map.get(val);\\n        temp = loc.get(loc.size() - 1);\\n        loc.set(index, temp);\\n        \\n        loc.remove(loc.size() - 1);\\n        \\n        map.put(temp, index);\\n        map.remove(val);\\n        return true;\\n\\n    }\\n    \\n    public int getRandom() {\\n        return loc.get(rand.nextInt(loc.size()));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780409,
                "title": "java-solution-with-arraylist-and-hashmap",
                "content": "```\\nclass RandomizedSet {\\n\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    Random rand = new Random(); \\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list  = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val))\\n            return false;\\n        \\n        map.put(val, list.size());\\n        list.add(val); //\\u5148\\u52A0map\\u518D\\u52A0list\\u4E0D\\u7136index\\u4F1A\\u51FA\\u95EE\\u9898\\u3002\\u3002\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val))\\n            return false;\\n        \\n        int ind = map.get(val);\\n        int last = list.get(list.size()-1);\\n        //swap\\n        list.set(ind, last);\\n        map.put(last,ind);\\n        //last element is the thing you want to delete from both\\n        list.remove(list.size()-1);\\n        map.remove(val);\\n        \\n        return true;\\n        \\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    Random rand = new Random(); \\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list  = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val))\\n            return false;\\n        \\n        map.put(val, list.size());\\n        list.add(val); //\\u5148\\u52A0map\\u518D\\u52A0list\\u4E0D\\u7136index\\u4F1A\\u51FA\\u95EE\\u9898\\u3002\\u3002\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val))\\n            return false;\\n        \\n        int ind = map.get(val);\\n        int last = list.get(list.size()-1);\\n        //swap\\n        list.set(ind, last);\\n        map.put(last,ind);\\n        //last element is the thing you want to delete from both\\n        list.remove(list.size()-1);\\n        map.remove(val);\\n        \\n        return true;\\n        \\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625918,
                "title": "c-hashmap-array",
                "content": "Use hashmap to store the mapping between numbers and their indexes in array.\\n\\nRemove:\\nswap the target with last element in the array and delete.\\n\\nGet Random:\\nget a random number from array using a random index.\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(m.count(val)){\\n            return false;\\n        }\\n        m[val]=v.size();\\n        v.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(!m.count(val))\\n            return false;\\n        else{\\n            int lastnum=v[v.size()-1];\\n            swap(v[m[val]],v[v.size()-1]);\\n            v.pop_back();\\n            m[lastnum]=m[val];\\n            m.erase(val);\\n            return true;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int sz=v.size();\\n        int rnum=rand()%sz;\\n        return v[rnum];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(m.count(val)){\\n            return false;\\n        }\\n        m[val]=v.size();\\n        v.push_back(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(!m.count(val))\\n            return false;\\n        else{\\n            int lastnum=v[v.size()-1];\\n            swap(v[m[val]],v[v.size()-1]);\\n            v.pop_back();\\n            m[lastnum]=m[val];\\n            m.erase(val);\\n            return true;\\n        }\\n    }\\n    \\n    int getRandom() {\\n        int sz=v.size();\\n        int rnum=rand()%sz;\\n        return v[rnum];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558069,
                "title": "python-faster-than-89",
                "content": "```\\nimport random\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.indexes = {}\\n        self.values = []\\n        \\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        \\n        if val in self.indexes:\\n            return False\\n        else: \\n            self.values.append(val)\\n            self.indexes[val] = len(self.values)-1\\n            return True\\n        \\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.indexes:\\n            last = len(self.values)-1\\n            index = self.indexes[val]\\n            \\n            self.indexes[self.values[last]] = index\\n            self.values[index], self.values[last] = self.values[last], self.values[index]\\n            \\n            del self.indexes[val]\\n            self.values.pop(last)\\n            \\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return random.choice(self.values)\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.indexes = {}\\n        self.values = []\\n        \\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        \\n        if val in self.indexes:\\n            return False\\n        else: \\n            self.values.append(val)\\n            self.indexes[val] = len(self.values)-1\\n            return True\\n        \\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.indexes:\\n            last = len(self.values)-1\\n            index = self.indexes[val]\\n            \\n            self.indexes[self.values[last]] = index\\n            self.values[index], self.values[last] = self.values[last], self.values[index]\\n            \\n            del self.indexes[val]\\n            self.values.pop(last)\\n            \\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return random.choice(self.values)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517398,
                "title": "python-faster-than-96",
                "content": "Key thing is that every operation has to be O(1) . let\\'s work from backwards.\\n\\n1. getRandom() -> we can only get O(1) for this if the values are stored in something like list and \\nwe are able to select a random index. We won\\'t be able to do this with a hashmap or hashet since \\nwe would have to convert all the keys to a list first and that will entail an O(N) operation. \\n\\n2. remove() -> since we know that getRandom() woud need a list , but removal of value in a list is O(N).\\nIf we have access to the index we want to remove, then it could be O(1). So we can use an extra dictionary \\nto store the value as key and index as value. But there is a catch here, when we delete an element from the list the mapping that we have already also needs to be updated. One trick here is to swap out the element that is to be deleted with the last element of the array, so that we are only doing a pop operation. The index of the last value has to be also updated correctly. \\n\\n3. insert() -> insert is straightforward . We check if the value is not present in the dictionary, then add it to both the list and dictionary. \\n\\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.hm = {}\\n        self.arr = []\\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.hm:\\n            self.hm[val] = len(self.arr)\\n            self.arr.append(val)\\n            return True\\n        return False\\n    \\n    def remove(self, val: int) -> bool:\\n        if len(self.arr) == 0:\\n            return False\\n        if val in self.hm:\\n                \\n            idx = self.hm[val]\\n            last_val = self.arr[-1]\\n            self.hm[last_val] = idx\\n            self.arr[idx], self.arr[-1] = last_val, self.arr[idx]\\n            self.arr.pop()\\n            del self.hm[val]\\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.arr)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Key thing is that every operation has to be O(1) . let\\'s work from backwards.\\n\\n1. getRandom() -> we can only get O(1) for this if the values are stored in something like list and \\nwe are able to select a random index. We won\\'t be able to do this with a hashmap or hashet since \\nwe would have to convert all the keys to a list first and that will entail an O(N) operation. \\n\\n2. remove() -> since we know that getRandom() woud need a list , but removal of value in a list is O(N).\\nIf we have access to the index we want to remove, then it could be O(1). So we can use an extra dictionary \\nto store the value as key and index as value. But there is a catch here, when we delete an element from the list the mapping that we have already also needs to be updated. One trick here is to swap out the element that is to be deleted with the last element of the array, so that we are only doing a pop operation. The index of the last value has to be also updated correctly. \\n\\n3. insert() -> insert is straightforward . We check if the value is not present in the dictionary, then add it to both the list and dictionary. \\n\\n```\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.hm = {}\\n        self.arr = []\\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.hm:\\n            self.hm[val] = len(self.arr)\\n            self.arr.append(val)\\n            return True\\n        return False\\n    \\n    def remove(self, val: int) -> bool:\\n        if len(self.arr) == 0:\\n            return False\\n        if val in self.hm:\\n                \\n            idx = self.hm[val]\\n            last_val = self.arr[-1]\\n            self.hm[last_val] = idx\\n            self.arr[idx], self.arr[-1] = last_val, self.arr[idx]\\n            self.arr.pop()\\n            del self.hm[val]\\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        return random.choice(self.arr)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1489610,
                "title": "java-easy-to-understand",
                "content": "\\n\\n```\\nclass RandomizedSet {\\n\\n    int arr[];\\n    HashMap<Integer,Integer> hm;\\n    int last;\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        arr=new int[200001];\\n        hm=new HashMap<Integer,Integer>();\\n        last=-1;\\n        //print();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        //print();\\n        if(hm.containsKey(val))\\n            return false;\\n        last++;\\n        arr[last]=val;\\n        hm.put(val,last);\\n        //System.out.println(last);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        //print();\\n\\t\\t/*\\n\\t\\twe find index of the element that is to be removed\\n\\t\\tintead of removing it we replace it with last element\\n\\t\\tupdate index in hashmap as we just changed it\\n\\t\\t*/\\n        if(hm.containsKey(val)){\\n            int index=hm.get(val);\\n            arr[index]=arr[last];\\n            hm.put(arr[index],index);\\n            last--;\\n            hm.remove(val);\\n            //System.out.println(last);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        //print();\\n        Random rand = new Random(); //instance of random class\\n        int upperbound = last+1;\\n        //generate random values from 0-24\\n        int index = rand.nextInt(upperbound); \\n        //System.out.println(\"index \"+index);\\n        return arr[index];\\n    }\\n    public void print(){\\n        for(int i=0;i<=last;i++){\\n            System.out.print(arr[i]+\" \");\\n        }\\n        System.out.println(hm);\\n    }\\n\\t//if you find this helpful, please upvote..\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n\\n    int arr[];\\n    HashMap<Integer,Integer> hm;\\n    int last;\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        arr=new int[200001];\\n        hm=new HashMap<Integer,Integer>();\\n        last=-1;\\n        //print();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        //print();\\n        if(hm.containsKey(val))\\n            return false;\\n        last++;\\n        arr[last]=val;\\n        hm.put(val,last);\\n        //System.out.println(last);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        //print();\\n\\t\\t/*\\n\\t\\twe find index of the element that is to be removed\\n\\t\\tintead of removing it we replace it with last element\\n\\t\\tupdate index in hashmap as we just changed it\\n\\t\\t*/\\n        if(hm.containsKey(val)){\\n            int index=hm.get(val);\\n            arr[index]=arr[last];\\n            hm.put(arr[index],index);\\n            last--;\\n            hm.remove(val);\\n            //System.out.println(last);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        //print();\\n        Random rand = new Random(); //instance of random class\\n        int upperbound = last+1;\\n        //generate random values from 0-24\\n        int index = rand.nextInt(upperbound); \\n        //System.out.println(\"index \"+index);\\n        return arr[index];\\n    }\\n    public void print(){\\n        for(int i=0;i<=last;i++){\\n            System.out.print(arr[i]+\" \");\\n        }\\n        System.out.println(hm);\\n    }\\n\\t//if you find this helpful, please upvote..\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282582,
                "title": "c-easy-simple-clean-using-only-unordered-map",
                "content": "```\\n// Using Unordred_map \\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,bool> mp;\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(mp.find(val) == mp.end()){\\n            mp[val] = true;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(mp.find(val) != mp.end()){\\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        auto it = mp.begin();\\n        advance(it, rand() % mp.size());\\n        return it -> first;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n// Using Unordred_map \\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,bool> mp;\\n    RandomizedSet() {\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(mp.find(val) == mp.end()){\\n            mp[val] = true;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(mp.find(val) != mp.end()){\\n            mp.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        auto it = mp.begin();\\n        advance(it, rand() % mp.size());\\n        return it -> first;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225544,
                "title": "discussion-on-various-data-structure-possibilities-why-hashmap-arrays-c-explained",
                "content": "```\\n\\n/*\\n\\nHarshit Gupta | 24th May, 2021\\n---------------------------------\\n\\nC++ program for \"Inserting, Deleting and Getting Random Element in O(1) time\"\\nhttps://leetcode.com/problems/insert-delete-getrandom-o1/\\n------\\n\\nSolution: The data structure that comes to our mind with O(1) are:\\n    - HashMaps: Insert, Delete in O(1) but getting any random value would need an iterator and that \\n        iteration in hashmap to a random index would be O(n).\\n        It  doesn\\'t have support for [] operator.\\n    - DLL: Insert, Delete in O(1) time but again to traverse to a specific index will take O(n) time. \\n        It  doesn\\'t have support for [] operator\\n    - Set: Insert and Remove in O(1) time for unordered_set but it doesnt have the [] operator to access any index.\\n        To acccess a random index, you must traverse the set in O(n) time.\\n    - Vectors/Arrays: Insert is O(1) but to know if an element is already present will take O(n) time if done at end. \\n        Remove any element is O(1) through a stratergy discussed below but to know iff it is present is again O(n)\\n        Getting Random Index is O(1) since any index can be accessed through [] operator.\\n        The only difficulty with Vectors is \"HOW TO KNOW IF AN ELEMENT IS PRESENT IN IT?\" in O(1) time.\\n        \\n    - Vectors/Arrays+HashMaps: Hashmaps store indexes of elements and solve the problem above, vector stores the elements.\\n        Insert: To know if already inserted, we use Hashmap and get it in O(1) time.\\n            If not inserted, we insert in vector in O(1) time\\n        Remove: TO know if present or not, we use Hashmap and get it in O(1) time.\\n            If present, we remove it from vector like this:\\n                Copy element of last index to the element to be removed index\\n                Pop the last index in O(1) time.\\n                Update map with new index of last element and remove element to be deleted from the map\\n        Get Random: Simply choose a random number and access it with the [] operator.\\n\\nTime Complexity: O(1) for all operations\\nSpace Complexity: O(1) for all operations\\n---\\n  NOTE: \\n\\n*/\\n\\n\\n\\nclass RandomizedSet {\\npublic:\\n    unordered_map <int, int > m;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        // If my map has the val, return false\\n        if(m.count(val)){\\n            return false;\\n        }\\n        // If my map doesn\\'t have it, push it in the vector\\n        // Update the map with the val and index of the vector\\n        else{\\n            v.push_back(val);\\n            m[val] = v.size()-1;\\n            return true;\\n        }\\n    }\\n    \\n    \\n    bool remove(int val) {\\n        // If map doesn\\'t have the value, return false    \\n        if (m.find(val) == m.end()) return false;\\n        \\n        // We\\'re sure that map has the val. Get the index of the stored val\\n        auto it = m.find(val);\\n        \\n        // update the vector in index of val to be = last element in v\\n        // it->second : index of the element \\'val\\' which is to be deleted\\n        v[it->second] = v.back();\\n        \\n        // remove the last element, we have got rid of \\'val\\' from the vector \\'v\\' now\\n        v.pop_back();\\n        \\n        // map\\'s index for last element has changed to old index of val, so update it\\n        m[v[it->second]] = it->second;\\n        \\n        // map\\'s val would still show the old index, erase it\\n        m.erase(val);\\n\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return v[rand() % v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\n\\n/*\\n\\nHarshit Gupta | 24th May, 2021\\n---------------------------------\\n\\nC++ program for \"Inserting, Deleting and Getting Random Element in O(1) time\"\\nhttps://leetcode.com/problems/insert-delete-getrandom-o1/\\n------\\n\\nSolution: The data structure that comes to our mind with O(1) are:\\n    - HashMaps: Insert, Delete in O(1) but getting any random value would need an iterator and that \\n        iteration in hashmap to a random index would be O(n).\\n        It  doesn\\'t have support for [] operator.\\n    - DLL: Insert, Delete in O(1) time but again to traverse to a specific index will take O(n) time. \\n        It  doesn\\'t have support for [] operator\\n    - Set: Insert and Remove in O(1) time for unordered_set but it doesnt have the [] operator to access any index.\\n        To acccess a random index, you must traverse the set in O(n) time.\\n    - Vectors/Arrays: Insert is O(1) but to know if an element is already present will take O(n) time if done at end. \\n        Remove any element is O(1) through a stratergy discussed below but to know iff it is present is again O(n)\\n        Getting Random Index is O(1) since any index can be accessed through [] operator.\\n        The only difficulty with Vectors is \"HOW TO KNOW IF AN ELEMENT IS PRESENT IN IT?\" in O(1) time.\\n        \\n    - Vectors/Arrays+HashMaps: Hashmaps store indexes of elements and solve the problem above, vector stores the elements.\\n        Insert: To know if already inserted, we use Hashmap and get it in O(1) time.\\n            If not inserted, we insert in vector in O(1) time\\n        Remove: TO know if present or not, we use Hashmap and get it in O(1) time.\\n            If present, we remove it from vector like this:\\n                Copy element of last index to the element to be removed index\\n                Pop the last index in O(1) time.\\n                Update map with new index of last element and remove element to be deleted from the map\\n        Get Random: Simply choose a random number and access it with the [] operator.\\n\\nTime Complexity: O(1) for all operations\\nSpace Complexity: O(1) for all operations\\n---\\n  NOTE: \\n\\n*/\\n\\n\\n\\nclass RandomizedSet {\\npublic:\\n    unordered_map <int, int > m;\\n    vector<int> v;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        // If my map has the val, return false\\n        if(m.count(val)){\\n            return false;\\n        }\\n        // If my map doesn\\'t have it, push it in the vector\\n        // Update the map with the val and index of the vector\\n        else{\\n            v.push_back(val);\\n            m[val] = v.size()-1;\\n            return true;\\n        }\\n    }\\n    \\n    \\n    bool remove(int val) {\\n        // If map doesn\\'t have the value, return false    \\n        if (m.find(val) == m.end()) return false;\\n        \\n        // We\\'re sure that map has the val. Get the index of the stored val\\n        auto it = m.find(val);\\n        \\n        // update the vector in index of val to be = last element in v\\n        // it->second : index of the element \\'val\\' which is to be deleted\\n        v[it->second] = v.back();\\n        \\n        // remove the last element, we have got rid of \\'val\\' from the vector \\'v\\' now\\n        v.pop_back();\\n        \\n        // map\\'s index for last element has changed to old index of val, so update it\\n        m[v[it->second]] = it->second;\\n        \\n        // map\\'s val would still show the old index, erase it\\n        m.erase(val);\\n\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return v[rand() % v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136695,
                "title": "java-simple-solution",
                "content": "JAVA CODE IS:\\n# \\n```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    List<Integer>list;\\n    //pair as num-index index in list;\\n    Map<Integer,Integer>map;\\n    public RandomizedSet() {\\n      list=new ArrayList<>();\\n        map=new HashMap<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) return false;\\n        map.put(val,list.size());\\n        list.add(list.size(),val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n      if(!map.containsKey(val)) return false;\\n        int pos=map.get(val);\\n        for(int i=pos+1;i<list.size();i++)\\n            map.put(list.get(i),i-1);\\n        list.remove(pos);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int index=(int)(Math.random()*(list.size()));\\n        return list.get(index);\\n    }\\n}\\n```\\ngetRandom() and insert() are both O(1) in worst case\\nbut remove() have O(1) in average case \\n\\n***please,upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    List<Integer>list;\\n    //pair as num-index index in list;\\n    Map<Integer,Integer>map;\\n    public RandomizedSet() {\\n      list=new ArrayList<>();\\n        map=new HashMap<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(map.containsKey(val)) return false;\\n        map.put(val,list.size());\\n        list.add(list.size(),val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n      if(!map.containsKey(val)) return false;\\n        int pos=map.get(val);\\n        for(int i=pos+1;i<list.size();i++)\\n            map.put(list.get(i),i-1);\\n        list.remove(pos);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int index=(int)(Math.random()*(list.size()));\\n        return list.get(index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030464,
                "title": "javascript-o-1-beat-96-29-run-time-super-easy-understanding-short-code",
                "content": "```\\nRuntime: 140 ms, faster than 96.29% of JavaScript online submissions for Insert Delete GetRandom O(1).\\nMemory Usage: 47.3 MB, less than 77.29% of JavaScript online submissions for Insert Delete GetRandom O(1).\\n```\\n\\n```\\nvar RandomizedSet = function() {\\n    this.storage = {}\\n    this.nums = []\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if(this.storage[val] !== undefined) return false\\n    this.nums.push(val)\\n    this.storage[val] = this.nums.length - 1\\n    return true\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if(this.storage[val] === undefined) return false\\n    let len = this.nums.length - 1;\\n    let index = this.storage[val];\\n    this.storage[this.nums[len]] = this.storage[val];\\n    [this.nums[index], this.nums[len]] = [this.nums[len], this.nums[index]];\\n    this.nums.pop()\\n    return delete this.storage[val]\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.nums[Math.floor(this.nums.length * Math.random())]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nRuntime: 140 ms, faster than 96.29% of JavaScript online submissions for Insert Delete GetRandom O(1).\\nMemory Usage: 47.3 MB, less than 77.29% of JavaScript online submissions for Insert Delete GetRandom O(1).\\n```\n```\\nvar RandomizedSet = function() {\\n    this.storage = {}\\n    this.nums = []\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if(this.storage[val] !== undefined) return false\\n    this.nums.push(val)\\n    this.storage[val] = this.nums.length - 1\\n    return true\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if(this.storage[val] === undefined) return false\\n    let len = this.nums.length - 1;\\n    let index = this.storage[val];\\n    this.storage[this.nums[len]] = this.storage[val];\\n    [this.nums[index], this.nums[len]] = [this.nums[len], this.nums[index]];\\n    this.nums.pop()\\n    return delete this.storage[val]\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.nums[Math.floor(this.nums.length * Math.random())]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 928434,
                "title": "java-o-1-beats-100-hashmap-arraylist",
                "content": "Maintaining a HashMap is necessary for O(1) inserts, removals, and membership checks. Each map entry is a key-value pair of (value, index of value in ArrayList). ArrayList is necessary for O(1) access to random elements.\\n\\ninsert() and getRandom() are relatively straightforward, the tricky part is the removal. ArrayList removal takes O(n) time for a random element, but if the element is at the end of the ArrayList, it takes constant time. So whenever an element is removed, swap it in the ArrayList with the final element before removing the element from both the ArrayList and HashMap. The HashMap index entry of the swapped element needs to be updated accordingly (the swapped element was originally at the end, but is now where the removed element used to be).\\n\\n```\\nclass RandomizedSet {\\n    List<Integer> list = new ArrayList<Integer>(); \\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>(); \\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) {\\n            return false;\\n        }\\n        map.put(val, list.size());\\n        list.add(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n        int swap1 = map.get(val);\\n        int swap2 = list.size() - 1;\\n        int val2 = list.get(swap2);\\n        map.put(val2, swap1);\\n        map.remove(val);\\n        list.set(swap1, val2);\\n        list.remove(list.size() - 1);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int a = (int)(Math.random() * list.size());\\n        return list.get(a);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    List<Integer> list = new ArrayList<Integer>(); \\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>(); \\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) {\\n            return false;\\n        }\\n        map.put(val, list.size());\\n        list.add(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n        int swap1 = map.get(val);\\n        int swap2 = list.size() - 1;\\n        int val2 = list.get(swap2);\\n        map.put(val2, swap1);\\n        map.remove(val);\\n        list.set(swap1, val2);\\n        list.remove(list.size() - 1);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int a = (int)(Math.random() * list.size());\\n        return list.get(a);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 816623,
                "title": "solution-using-both-hashmap-and-hashset",
                "content": "We can use HashSet if we call getRandom rarely to save memory.\\n\\n```\\nclass RandomizedSet {\\n    Set<Integer> hset;\\n    java.util.Random random;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        hset = new HashSet<Integer>();\\n        random = new java.util.Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(hset.contains(val)) return false;\\n        \\n        hset.add(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!hset.contains(val)) return false;\\n        \\n        hset.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Integer[] temp = hset.toArray(new Integer[0]);\\n        return temp[random.nextInt(hset.size())];\\n    }\\n}\\n```\\nHashMap + ArrayList Solution:\\n\\n```\\nclass RandomizedSet {\\n    Map<Integer, Integer> hash;\\n    ArrayList<Integer> list;\\n    java.util.Random random;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        hash = new HashMap<Integer, Integer>();\\n        list = new ArrayList<Integer>();\\n        random = new java.util.Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(hash.containsKey(val)) return false;\\n        \\n        hash.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!hash.containsKey(val)) return false;\\n        \\n        int index = hash.get(val);\\n        if(index < list.size() - 1) {\\n            list.set(index, list.get(list.size() -1));\\n        }\\n        hash.put(list.get(list.size() - 1), index);\\n        hash.remove(val);\\n        list.remove(list.size() - 1);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass RandomizedSet {\\n    Set<Integer> hset;\\n    java.util.Random random;\\n    \\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        hset = new HashSet<Integer>();\\n        random = new java.util.Random();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(hset.contains(val)) return false;\\n        \\n        hset.add(val);\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(!hset.contains(val)) return false;\\n        \\n        hset.remove(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Integer[] temp = hset.toArray(new Integer[0]);\\n        return temp[random.nextInt(hset.size())];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794826,
                "title": "swift-simple-using-array-and-hashmap-for-indexes",
                "content": "```\\nfinal class RandomizedSet {\\n    var hashMap = [Int: Int]()\\n    var arr = [Int]()\\n    \\n    init() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    func insert(_ val: Int) -> Bool {\\n        if hashMap[val] != nil {\\n            return false\\n        }\\n        arr.append(val)\\n        hashMap[val] = arr.count - 1\\n        return true\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    func remove(_ val: Int) -> Bool {\\n        if hashMap[val] == nil {\\n            return false\\n        }\\n        let index = hashMap[val]!\\n        let lastVal = arr.last!\\n        arr.swapAt(index, arr.count - 1)\\n        hashMap[lastVal] = index\\n        arr.removeLast()\\n        hashMap.removeValue(forKey: val)\\n        return true\\n    }\\n    \\n    /** Get a random element from the set. */\\n    func getRandom() -> Int {\\n        return arr.randomElement()!\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class RandomizedSet {\\n    var hashMap = [Int: Int]()\\n    var arr = [Int]()\\n    \\n    init() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    func insert(_ val: Int) -> Bool {\\n        if hashMap[val] != nil {\\n            return false\\n        }\\n        arr.append(val)\\n        hashMap[val] = arr.count - 1\\n        return true\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    func remove(_ val: Int) -> Bool {\\n        if hashMap[val] == nil {\\n            return false\\n        }\\n        let index = hashMap[val]!\\n        let lastVal = arr.last!\\n        arr.swapAt(index, arr.count - 1)\\n        hashMap[lastVal] = index\\n        arr.removeLast()\\n        hashMap.removeValue(forKey: val)\\n        return true\\n    }\\n    \\n    /** Get a random element from the set. */\\n    func getRandom() -> Int {\\n        return arr.randomElement()!\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683806,
                "title": "c-an-accepted-but-wrong-solution-with-hashset",
                "content": "**Idea:**\\nThis is only for fun and help readers like myself to understand the iterator manipulation within c++ hashmap and hashset\\n\\nThe only point of this point is that: no random access within hashmap and hashset.\\nSo we should resort to random accessible containor like vector to complete picture.\\n\\n\\nTime Complexity:  O(N)   (Because of getRandom() )\\nSpace Complexity: O(N)\\n\\n\\n```\\nclass RandomizedSet { // An elegant WRONG Solution for fun in the name of study\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {       }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        return m_.insert(val).second;       \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {        \\n        return m_.erase(val); // return the number of elements erased.                       \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if(m_.size() < 1 ) return -1;\\n        int index = rand() % m_.size();        \\n        //return *(m_.begin() + index); // Note: Err. No + operation for for C++ hashset/hashmap\\n        auto it=m_.begin();\\n        //while(index-- > 0) it++; // ok\\n        std::advance(it, index);\\n        return *it;\\n    }\\n    \\nprivate:      \\n    unordered_set<int> m_;  \\n};\\n```\\n\\n**Bonus:**\\nHere is the my updated version of 4-line, it is so sexy that I write a new post:\\nhttps://leetcode.com/problems/insert-delete-getrandom-o1/discuss/685574/challenge-me-for-shorter-solution-4-line",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet { // An elegant WRONG Solution for fun in the name of study\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {       }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        return m_.insert(val).second;       \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {        \\n        return m_.erase(val); // return the number of elements erased.                       \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if(m_.size() < 1 ) return -1;\\n        int index = rand() % m_.size();        \\n        //return *(m_.begin() + index); // Note: Err. No + operation for for C++ hashset/hashmap\\n        auto it=m_.begin();\\n        //while(index-- > 0) it++; // ok\\n        std::advance(it, index);\\n        return *it;\\n    }\\n    \\nprivate:      \\n    unordered_set<int> m_;  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623157,
                "title": "simple-c-faster-than-71-63",
                "content": "### Accepted Solution with Runtime: 164 ms, faster than 71.63%\\n#### Main idea behind this solution:\\n- create a `List<int>` with all added elements\\n- keep values also in `Dictionary<int, int>` with `value` as a key and `index` (of above `List<int>`) as a value\\n- when adding new element - expand `List<int>` and add value to `Dictionary<int, int>`\\n- when removing - remove from `Dictionary` and update `List<int>` by putting **its last element** in place of the deleted one (accessible by index kept in Dictionary)\\n\\n```\\npublic class RandomizedSet {\\n    Dictionary<int, int> dict;\\n    List<int> elements;\\n    private Random random;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        dict = new Dictionary<int, int>();\\n        elements = new List<int>();\\n        random = new Random();        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) {\\n        if(dict.ContainsKey(val))\\n            return false;\\n\\n        var newIdx = elements.Count();\\n        elements.Add(val);\\n        dict.Add(val, newIdx);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) {\\n        if(dict.ContainsKey(val))\\n        {\\n            var elementIdx = dict[val];\\n            dict.Remove(val);\\n            \\n            RemoveElementAtIdx(elementIdx);           \\n        }\\n        else\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private void RemoveElementAtIdx(int idx)\\n    {\\n        var countElements = elements.Count();\\n        if (idx == countElements - 1)\\n            elements.RemoveAt(idx);\\n        else\\n        {\\n            var lastElem = elements[countElements - 1];\\n            elements[idx] = lastElem;\\n            elements.RemoveAt(countElements - 1);\\n            dict[lastElem] = idx;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() {\\n        var rnd = random.Next(0, elements.Count);\\n        return elements[rnd];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class RandomizedSet {\\n    Dictionary<int, int> dict;\\n    List<int> elements;\\n    private Random random;\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        dict = new Dictionary<int, int>();\\n        elements = new List<int>();\\n        random = new Random();        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public bool Insert(int val) {\\n        if(dict.ContainsKey(val))\\n            return false;\\n\\n        var newIdx = elements.Count();\\n        elements.Add(val);\\n        dict.Add(val, newIdx);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public bool Remove(int val) {\\n        if(dict.ContainsKey(val))\\n        {\\n            var elementIdx = dict[val];\\n            dict.Remove(val);\\n            \\n            RemoveElementAtIdx(elementIdx);           \\n        }\\n        else\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private void RemoveElementAtIdx(int idx)\\n    {\\n        var countElements = elements.Count();\\n        if (idx == countElements - 1)\\n            elements.RemoveAt(idx);\\n        else\\n        {\\n            var lastElem = elements[countElements - 1];\\n            elements[idx] = lastElem;\\n            elements.RemoveAt(countElements - 1);\\n            dict[lastElem] = idx;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int GetRandom() {\\n        var rnd = random.Next(0, elements.Count);\\n        return elements[rnd];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 614685,
                "title": "simple-approach-using-unordered-map-and-vector-with-full-explanation-and-complete-code-in-c",
                "content": "In this question we are required to generete a special kind of data structure supporting following features:-\\n1. insert(val)\\n2. remove(val)\\n3. getRandom\\n\\nAll operations in O(1)\\n\\n***Resolving getRandom : -***\\nhere we have to return any random value that is present in our data structure. At first sight we observe that both insert and remove operation are satisfied by using set in O(1). Let us say that we are using unordered_set for first 2 operations, than we found that to get any random value from the set you have to iterate over it as set or even map does not support getting any value in O(1) but using vector you can achieve this, as with index value you can access any item in array in O(1).\\n\\nThus using set alone you cannot achieve all the 3 functions in required time. Thus use of set is eliminanted from above discussion.\\n\\nNow we have to use 2 different data structure one is unordered map and another is a vector\\nkey as the given val and value as index of the vector where that value is stored in vector.\\nSo, when we remove anything from map we should also remove it from vector.\\n***Now you say that removing something from vector is not O(1) as we are required to do because when remove function is called we should delete our value both from map and vector. However in this case we can achieve delete operation in O(1), by moving swapping the value to be deleted with the last value in vector and then deleting the last value, deleting last value in vector is O(1) operation.***\\n\\n***return v[rand()%v.size()];***\\nwe use rand() function to generate any random value and mod it with vector size thus giving us random index value of vector.\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,int> mp;\\n    vector<int> v;\\n    int currIndex = 0;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(mp.find(val) == mp.end()){\\n            mp[val] = currIndex;\\n            v.push_back(val);\\n            currIndex++;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(mp.find(val) == mp.end()){\\n            return false;\\n        }\\n        int index = mp[val];\\n        int size = v.size();\\n        \\n        if(index ==  size-1){\\n            v.pop_back();\\n            mp.erase(val);\\n            return true;\\n        }\\n        else{\\n            mp.erase(val);\\n            mp[v[size-1]] = index;\\n            swap(v[index],v[size-1]);\\n            v.pop_back();\\n            currIndex--;\\n            return true;\\n        }     \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n ```\\n \\n hope it helps!!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    unordered_map<int,int> mp;\\n    vector<int> v;\\n    int currIndex = 0;\\n    \\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(mp.find(val) == mp.end()){\\n            mp[val] = currIndex;\\n            v.push_back(val);\\n            currIndex++;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if(mp.find(val) == mp.end()){\\n            return false;\\n        }\\n        int index = mp[val];\\n        int size = v.size();\\n        \\n        if(index ==  size-1){\\n            v.pop_back();\\n            mp.erase(val);\\n            return true;\\n        }\\n        else{\\n            mp.erase(val);\\n            mp[v[size-1]] = index;\\n            swap(v[index],v[size-1]);\\n            v.pop_back();\\n            currIndex--;\\n            return true;\\n        }     \\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        return v[rand()%v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 436771,
                "title": "javascript-array-of-values-and-map-of-values-and-locations-in-array",
                "content": "```\\nvar RandomizedSet = function() {\\n    this.map = {};\\n    this.arr = [];\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if(val in this.map) return false;\\n    this.map[val] = this.arr.length;\\n    this.arr.push(val);\\n    return true;\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if(!(val in this.map)) return false;\\n    var end = this.arr[this.arr.length - 1];\\n    var original = this.map[val];\\n    this.map[end] = original;\\n    this.arr[original] = end;\\n    delete this.map[val];\\n    this.arr.pop();\\n    return true;\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.arr[Math.floor(Math.random() * this.arr.length)];\\n};\\n ```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar RandomizedSet = function() {\\n    this.map = {};\\n    this.arr = [];\\n};\\n\\nRandomizedSet.prototype.insert = function(val) {\\n    if(val in this.map) return false;\\n    this.map[val] = this.arr.length;\\n    this.arr.push(val);\\n    return true;\\n};\\n\\nRandomizedSet.prototype.remove = function(val) {\\n    if(!(val in this.map)) return false;\\n    var end = this.arr[this.arr.length - 1];\\n    var original = this.map[val];\\n    this.map[end] = original;\\n    this.arr[original] = end;\\n    delete this.map[val];\\n    this.arr.pop();\\n    return true;\\n};\\n\\nRandomizedSet.prototype.getRandom = function() {\\n    return this.arr[Math.floor(Math.random() * this.arr.length)];\\n};\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 396771,
                "title": "strictly-o-1-python-solution-easy-to-understand-beats-97",
                "content": "Basically you will need a dictionary, a list and an int to record the number of elements in the list. \\n\\nThe dictionary will store values and their positions in the list.\\nThe list store the values. \\nEvery time you remove a value, you get the position of this value in the list. Exchange it with the last element in the list, so that the other elements in the list have the same position as before, except for the last element. You can modify the position of the last element from the dictionary\\n\\n```\\nimport random\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \\n        self.dic={}\\n        self.lst=[]\\n        self.cnt=0\\n        \\n\\n    def insert(self, val):\\n      \\n        if val in self.dic:\\n            return False\\n        self.dic[val]=self.cnt\\n        self.cnt+=1\\n        self.lst.append(val)\\n        return True\\n        \\n\\n    def remove(self, val):\\n\\n        \\n        if val not in self.dic:\\n            return False\\n        \\n        pos=self.dic[val]\\n        if pos!=self.cnt-1:\\n            self.lst[pos]=self.lst[-1]\\n            self.dic[self.lst[-1]]=pos\\n        self.dic.pop(val)\\n        self.lst.pop()\\n        self.cnt-=1\\n        return True\\n            \\n        \\n\\n    def getRandom(self):\\n\\n        randnum=random.randint(0, self.cnt-1)\\n        return self.lst[randnum]\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nimport random\\nclass RandomizedSet(object):\\n\\n    def __init__(self):\\n        \\n        self.dic={}\\n        self.lst=[]\\n        self.cnt=0\\n        \\n\\n    def insert(self, val):\\n      \\n        if val in self.dic:\\n            return False\\n        self.dic[val]=self.cnt\\n        self.cnt+=1\\n        self.lst.append(val)\\n        return True\\n        \\n\\n    def remove(self, val):\\n\\n        \\n        if val not in self.dic:\\n            return False\\n        \\n        pos=self.dic[val]\\n        if pos!=self.cnt-1:\\n            self.lst[pos]=self.lst[-1]\\n            self.dic[self.lst[-1]]=pos\\n        self.dic.pop(val)\\n        self.lst.pop()\\n        self.cnt-=1\\n        return True\\n            \\n        \\n\\n    def getRandom(self):\\n\\n        randnum=random.randint(0, self.cnt-1)\\n        return self.lst[randnum]\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 329120,
                "title": "python-o-1-o-1-o-1",
                "content": "```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.d = {}\\n        self.l = []\\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val in self.d:\\n            return False\\n        else:\\n            self.d[val] = len(self.l)\\n            self.l.append(val)\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.d:\\n            self.d[self.l[-1]] = self.d[val]\\n            self.l[self.d.pop(val)] = self.l[-1]\\n            self.l.pop()\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return self.l[random.randint(0, len(self.l) - 1)]\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \"\"\"\\n        Initialize your data structure here.\\n        \"\"\"\\n        self.d = {}\\n        self.l = []\\n\\n    def insert(self, val: int) -> bool:\\n        \"\"\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \"\"\"\\n        if val in self.d:\\n            return False\\n        else:\\n            self.d[val] = len(self.l)\\n            self.l.append(val)\\n            return True\\n\\n    def remove(self, val: int) -> bool:\\n        \"\"\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \"\"\"\\n        if val in self.d:\\n            self.d[self.l[-1]] = self.d[val]\\n            self.l[self.d.pop(val)] = self.l[-1]\\n            self.l.pop()\\n            return True\\n        else:\\n            return False\\n\\n    def getRandom(self) -> int:\\n        \"\"\"\\n        Get a random element from the set.\\n        \"\"\"\\n        return self.l[random.randint(0, len(self.l) - 1)]\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247273,
                "title": "c-100-using-hashmap-and-vector-no-vector-removal",
                "content": "Overall my solution is similar to hashmap and array method mentioned in other answers. My method don\\'t need to remove element from vector. A variable is used to mark the new entry of vector. Code see below.\\n\\n```\\nclass RandomizedSet {\\nprivate: \\n    unordered_map<int, int> numLoc;\\n    vector<int> nums;\\n    int In = 0;\\n    \\n    std::random_device rd;  //Will be used to obtain a seed for the random number engine\\n    std::mt19937 gen; //Standard mersenne_twister_engine seeded with rd()\\n    std::uniform_int_distribution<int> dis;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        gen = mt19937(rd());\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (numLoc.find(val) != numLoc.end()) return false;\\n        numLoc.insert({val, In});\\n        if (In == nums.size())\\n            nums.push_back(val);\\n        else nums[In] = val;\\n        ++In;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (numLoc.find(val) == numLoc.end()) return false;\\n        int loc = numLoc.find(val)->second;\\n        nums[loc] = nums[In - 1];\\n        numLoc.find(nums[loc])->second = loc;\\n        --In;\\n        numLoc.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (In > 0) {\\n            dis = uniform_int_distribution<int>(0, In - 1);\\n            // cout << dis(gen);\\n            return nums[dis(gen)];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\nprivate: \\n    unordered_map<int, int> numLoc;\\n    vector<int> nums;\\n    int In = 0;\\n    \\n    std::random_device rd;  //Will be used to obtain a seed for the random number engine\\n    std::mt19937 gen; //Standard mersenne_twister_engine seeded with rd()\\n    std::uniform_int_distribution<int> dis;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        gen = mt19937(rd());\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if (numLoc.find(val) != numLoc.end()) return false;\\n        numLoc.insert({val, In});\\n        if (In == nums.size())\\n            nums.push_back(val);\\n        else nums[In] = val;\\n        ++In;\\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        if (numLoc.find(val) == numLoc.end()) return false;\\n        int loc = numLoc.find(val)->second;\\n        nums[loc] = nums[In - 1];\\n        numLoc.find(nums[loc])->second = loc;\\n        --In;\\n        numLoc.erase(val);\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        if (In > 0) {\\n            dis = uniform_int_distribution<int>(0, In - 1);\\n            // cout << dis(gen);\\n            return nums[dis(gen)];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 197079,
                "title": "go-faster-than-100",
                "content": "```\\nimport \"math/rand\"\\n\\ntype RandomizedSet struct {\\n    nums []int\\n    nti map[int]int // num to index\\n}\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{[]int{}, make(map[int]int)}\\n}\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    \\n    if _, ok := this.nti[val]; ok {\\n        return false\\n    }\\n    \\n    this.nums     = append(this.nums, val)\\n    this.nti[val] = len(this.nums)-1\\n    \\n    return true\\n}\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    \\n    if i, ok := this.nti[val]; !ok {\\n        return false\\n    } else {\\n        \\n        if len(this.nums) < 2 {\\n            this.nums = this.nums[0:0]\\n        } else {\\n            \\n            swap := this.nums[len(this.nums)-1]\\n            \\n            this.nti[swap] = i\\n            this.nums[i]   = swap\\n            this.nums      = this.nums[0:len(this.nums)-1]\\n        }\\n        \\n        delete(this.nti, val)\\n        return true\\n    }\\n}\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    return this.nums[rand.Int() % len(this.nti)]\\n}\\n```\\n\\nIt\\'s important to note that Golang\\'s list implementation is a Linked List, so  \\n`this.nums      = this.nums[0:len(this.nums)-1]`\\nis an O(1) operation",
                "solutionTags": [],
                "code": "```\\nimport \"math/rand\"\\n\\ntype RandomizedSet struct {\\n    nums []int\\n    nti map[int]int // num to index\\n}\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{[]int{}, make(map[int]int)}\\n}\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    \\n    if _, ok := this.nti[val]; ok {\\n        return false\\n    }\\n    \\n    this.nums     = append(this.nums, val)\\n    this.nti[val] = len(this.nums)-1\\n    \\n    return true\\n}\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    \\n    if i, ok := this.nti[val]; !ok {\\n        return false\\n    } else {\\n        \\n        if len(this.nums) < 2 {\\n            this.nums = this.nums[0:0]\\n        } else {\\n            \\n            swap := this.nums[len(this.nums)-1]\\n            \\n            this.nti[swap] = i\\n            this.nums[i]   = swap\\n            this.nums      = this.nums[0:len(this.nums)-1]\\n        }\\n        \\n        delete(this.nti, val)\\n        return true\\n    }\\n}\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    return this.nums[rand.Int() % len(this.nti)]\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 188460,
                "title": "java-solution-using-hashmap-arraylist-all-operations-o-1-with-explanation",
                "content": "Many people have a question of how we do removal in ```O(1)``` So for removal we can swap the value with last element in the list and then just remove last element. Removal of last element is ```O(1)``` as the last space is just deallocated whereas if we do a remove without swapping then it can take ```O(n)``` in worse case as we would have to shift the complete  array.\\n```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    int lastIndex;\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list = new ArrayList<>();\\n        lastIndex = 0;\\n    }\\n\\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) {\\n            return false;\\n        }\\n\\n        list.add(val);\\n        map.put(val, lastIndex);\\n        lastIndex++;\\n\\n        return true;\\n    }\\n\\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n\\n        map.put(list.get(lastIndex-1), map.get(val));\\n        swap(map.get(val), lastIndex-1);\\n        list.remove(lastIndex-1);\\n        map.remove(val);\\n        lastIndex--;\\n\\n        return true;\\n    }\\n\\n    private void swap(int id1, int id2) {\\n        int temp = list.get(id1);\\n        list.set(id1, list.get(id2));\\n        list.set(id2, temp);\\n    }\\n\\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random rand = new Random();\\n        int idx = rand.nextInt(((lastIndex-1) - 0) + 1) + 0;\\n        return list.get(idx);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [],
                "code": "```O(1)```\n```O(1)```\n```O(n)```\n```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    int lastIndex;\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list = new ArrayList<>();\\n        lastIndex = 0;\\n    }\\n\\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (map.containsKey(val)) {\\n            return false;\\n        }\\n\\n        list.add(val);\\n        map.put(val, lastIndex);\\n        lastIndex++;\\n\\n        return true;\\n    }\\n\\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!map.containsKey(val)) {\\n            return false;\\n        }\\n\\n        map.put(list.get(lastIndex-1), map.get(val));\\n        swap(map.get(val), lastIndex-1);\\n        list.remove(lastIndex-1);\\n        map.remove(val);\\n        lastIndex--;\\n\\n        return true;\\n    }\\n\\n    private void swap(int id1, int id2) {\\n        int temp = list.get(id1);\\n        list.set(id1, list.get(id2));\\n        list.set(id2, temp);\\n    }\\n\\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        Random rand = new Random();\\n        int idx = rand.nextInt(((lastIndex-1) - 0) + 1) + 0;\\n        return list.get(idx);\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184120,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    HashSet<Integer> h;\\n    Random rand = new Random();\\n    public RandomizedSet() {\\n        h = new HashSet<Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(h.contains(val))\\n            return false;\\n        h.add(val);\\n        return true;        \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(h.contains(val))\\n            h.remove(val);\\n        else\\n            return false;\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int index = rand.nextInt(h.size());\\n        Iterator<Integer> iter = h.iterator();\\n        for (int i = 0; i < index; i++) {\\n            iter.next();\\n        }\\n        return iter.next();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n\\n    /** Initialize your data structure here. */\\n    HashSet<Integer> h;\\n    Random rand = new Random();\\n    public RandomizedSet() {\\n        h = new HashSet<Integer>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if(h.contains(val))\\n            return false;\\n        h.add(val);\\n        return true;        \\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if(h.contains(val))\\n            h.remove(val);\\n        else\\n            return false;\\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        int index = rand.nextInt(h.size());\\n        Iterator<Integer> iter = h.iterator();\\n        for (int i = 0; i < index; i++) {\\n            iter.next();\\n        }\\n        return iter.next();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 138375,
                "title": "map-and-list",
                "content": "There are 2 classic data structures: list, map\\n- For O(1) insertion, list and map satisfy\\n- For O(1) removal by value, map satisfies\\n- For O(1) getRandom, list satisfies\\n\\nIn order to achive the above at the same time, we maintain both map and list:\\n- list of values `valList`\\n- map value to location `valToLoc`\\n\\nAs for removal, the entry should be removed from both `valList` and `valToLoc`.\\n\\nBut removal in `valList` takes O(n) time since it requires all the succeeding elements to be shifted to fill out the space created by removed element.\\n\\nWe can avoid that by swapping `val` with the last element of the list (`if val is not the last one`), and then deleting the last element.\\n\\n```\\n    // Map value to location in list.\\n    private static Map<Integer, Integer> valToLoc;\\n    // List of values.\\n    private static List<Integer> valList;\\n    private static final Random random = new Random();\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        valToLoc = new HashMap<>();\\n        valList = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (valToLoc.containsKey(val)) \\n            return false;\\n        \\n        valToLoc.put(val, valList.size());\\n        valList.add(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!valToLoc.containsKey(val))\\n            return false;\\n        \\n        int posToDelete = valToLoc.get(val);\\n        valToLoc.remove(val);\\n        if (posToDelete != valList.size() - 1) {\\n            int lastVal = valList.get(valList.size() - 1);\\n            valList.set(posToDelete, lastVal);\\n            valToLoc.put(lastVal, posToDelete);\\n        }\\n        valList.remove(valList.size() - 1);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return valList.get(random.nextInt(valList.size()));\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    // Map value to location in list.\\n    private static Map<Integer, Integer> valToLoc;\\n    // List of values.\\n    private static List<Integer> valList;\\n    private static final Random random = new Random();\\n\\n    /** Initialize your data structure here. */\\n    public RandomizedSet() {\\n        valToLoc = new HashMap<>();\\n        valList = new ArrayList<>();\\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    public boolean insert(int val) {\\n        if (valToLoc.containsKey(val)) \\n            return false;\\n        \\n        valToLoc.put(val, valList.size());\\n        valList.add(val);\\n        \\n        return true;\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    public boolean remove(int val) {\\n        if (!valToLoc.containsKey(val))\\n            return false;\\n        \\n        int posToDelete = valToLoc.get(val);\\n        valToLoc.remove(val);\\n        if (posToDelete != valList.size() - 1) {\\n            int lastVal = valList.get(valList.size() - 1);\\n            valList.set(posToDelete, lastVal);\\n            valToLoc.put(lastVal, posToDelete);\\n        }\\n        valList.remove(valList.size() - 1);\\n        \\n        return true;\\n    }\\n    \\n    /** Get a random element from the set. */\\n    public int getRandom() {\\n        return valList.get(random.nextInt(valList.size()));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 85412,
                "title": "why-always-hash-the-truely-o-1",
                "content": "Change echo value into binary, and regard it as a string.\\nWe can storage it with a Trie.\\nAnd we change a little and fit duplicates allowed version.\\n```\\ntypedef struct RandomizedSetNode_S {\\n    int iCnt;\\n    struct RandomizedSetNode_S* apstSucc[2];\\n} RandomizedSetNode;\\n\\ntypedef struct {\\n    RandomizedSetNode *head;\\n} RandomizedSet;\\n\\n/** Initialize your data structure here. */\\nRandomizedSetNode* randomizedSetNodeCreate() {\\n    RandomizedSetNode *pstRet = malloc(sizeof(RandomizedSetNode));\\n    pstRet->iCnt = 0;\\n    pstRet->apstSucc[0] = NULL;\\n    pstRet->apstSucc[1] = NULL;\\n    return pstRet;\\n}\\n\\nvoid randomizedSetNodeFree(RandomizedSetNode* obj) {\\n    if (obj->apstSucc[0] != NULL) {\\n        randomizedSetNodeFree(obj->apstSucc[0]);\\n    }\\n    if (obj->apstSucc[1] != NULL) {\\n        randomizedSetNodeFree(obj->apstSucc[1]);\\n    }\\n    free(obj);\\n}\\n\\n/** Initialize your data structure here. */\\nRandomizedSet* randomizedSetCreate() {\\n    RandomizedSet *pstRet = malloc(sizeof(RandomizedSet));\\n    pstRet->head = randomizedSetNodeCreate();\\n    return pstRet;\\n}\\n\\n/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\nbool randomizedSetInsert(RandomizedSet* obj, int val) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode == NULL) {\\n            break;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    if (pstNode != NULL) {\\n        return false;\\n    }\\n    pstNode = obj->head;\\n    pstNode->iCnt++;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit] == NULL) {\\n            pstNode->apstSucc[iBit] = randomizedSetNodeCreate();\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n        pstNode->iCnt++;\\n    }\\n    return true;\\n}\\n\\n/** Removes a value from the set. Returns true if the set contained the specified element. */\\nbool randomizedSetRemove(RandomizedSet* obj, int val) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit] == NULL) {\\n            return false;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    pstNode = obj->head;\\n    pstNode->iCnt--;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit]->iCnt == 1) {\\n            randomizedSetNodeFree(pstNode->apstSucc[iBit]);\\n            pstNode->apstSucc[iBit] = NULL;\\n            break;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n        pstNode->iCnt--;\\n    }\\n    return true;\\n}\\n\\n/** Get a random element from the set. */\\nint randomizedSetGetRandom(RandomizedSet* obj) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    int iZeroCnt, iOneCnt;\\n    int iAnswer = 0, iBit;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        iZeroCnt = 0;\\n        iOneCnt = 0;\\n        if (pstNode->apstSucc[0] != NULL) {\\n            iZeroCnt = pstNode->apstSucc[0]->iCnt;\\n        }\\n        if (pstNode->apstSucc[1] != NULL) {\\n            iOneCnt = pstNode->apstSucc[1]->iCnt;\\n        }\\n        assert(iZeroCnt + iOneCnt > 0);\\n        if ((rand() + 1.) / (RAND_MAX + 2.) < iZeroCnt * 1. / (iZeroCnt + iOneCnt)) {\\n            iBit = 0;\\n        } else {\\n            iBit = 1;\\n        }\\n        assert(iBit == 1 || iZeroCnt > 0);\\n        assert(iBit == 0 || iOneCnt > 0);\\n        iAnswer |= iBit << iPos;\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    \\n    return iAnswer;\\n}\\n\\nvoid randomizedSetFree(RandomizedSet* obj) {\\n    randomizedSetNodeFree(obj->head);\\n    free(obj);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct RandomizedSetNode_S {\\n    int iCnt;\\n    struct RandomizedSetNode_S* apstSucc[2];\\n} RandomizedSetNode;\\n\\ntypedef struct {\\n    RandomizedSetNode *head;\\n} RandomizedSet;\\n\\n/** Initialize your data structure here. */\\nRandomizedSetNode* randomizedSetNodeCreate() {\\n    RandomizedSetNode *pstRet = malloc(sizeof(RandomizedSetNode));\\n    pstRet->iCnt = 0;\\n    pstRet->apstSucc[0] = NULL;\\n    pstRet->apstSucc[1] = NULL;\\n    return pstRet;\\n}\\n\\nvoid randomizedSetNodeFree(RandomizedSetNode* obj) {\\n    if (obj->apstSucc[0] != NULL) {\\n        randomizedSetNodeFree(obj->apstSucc[0]);\\n    }\\n    if (obj->apstSucc[1] != NULL) {\\n        randomizedSetNodeFree(obj->apstSucc[1]);\\n    }\\n    free(obj);\\n}\\n\\n/** Initialize your data structure here. */\\nRandomizedSet* randomizedSetCreate() {\\n    RandomizedSet *pstRet = malloc(sizeof(RandomizedSet));\\n    pstRet->head = randomizedSetNodeCreate();\\n    return pstRet;\\n}\\n\\n/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\nbool randomizedSetInsert(RandomizedSet* obj, int val) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode == NULL) {\\n            break;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    if (pstNode != NULL) {\\n        return false;\\n    }\\n    pstNode = obj->head;\\n    pstNode->iCnt++;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit] == NULL) {\\n            pstNode->apstSucc[iBit] = randomizedSetNodeCreate();\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n        pstNode->iCnt++;\\n    }\\n    return true;\\n}\\n\\n/** Removes a value from the set. Returns true if the set contained the specified element. */\\nbool randomizedSetRemove(RandomizedSet* obj, int val) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit] == NULL) {\\n            return false;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    pstNode = obj->head;\\n    pstNode->iCnt--;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        int iBit = (val >> iPos) & 1;\\n        if (pstNode->apstSucc[iBit]->iCnt == 1) {\\n            randomizedSetNodeFree(pstNode->apstSucc[iBit]);\\n            pstNode->apstSucc[iBit] = NULL;\\n            break;\\n        }\\n        pstNode = pstNode->apstSucc[iBit];\\n        pstNode->iCnt--;\\n    }\\n    return true;\\n}\\n\\n/** Get a random element from the set. */\\nint randomizedSetGetRandom(RandomizedSet* obj) {\\n    RandomizedSetNode *pstNode = obj->head;\\n    int iZeroCnt, iOneCnt;\\n    int iAnswer = 0, iBit;\\n    for (int iPos = 0; iPos < 32; iPos++) {\\n        iZeroCnt = 0;\\n        iOneCnt = 0;\\n        if (pstNode->apstSucc[0] != NULL) {\\n            iZeroCnt = pstNode->apstSucc[0]->iCnt;\\n        }\\n        if (pstNode->apstSucc[1] != NULL) {\\n            iOneCnt = pstNode->apstSucc[1]->iCnt;\\n        }\\n        assert(iZeroCnt + iOneCnt > 0);\\n        if ((rand() + 1.) / (RAND_MAX + 2.) < iZeroCnt * 1. / (iZeroCnt + iOneCnt)) {\\n            iBit = 0;\\n        } else {\\n            iBit = 1;\\n        }\\n        assert(iBit == 1 || iZeroCnt > 0);\\n        assert(iBit == 0 || iOneCnt > 0);\\n        iAnswer |= iBit << iPos;\\n        pstNode = pstNode->apstSucc[iBit];\\n    }\\n    \\n    return iAnswer;\\n}\\n\\nvoid randomizedSetFree(RandomizedSet* obj) {\\n    randomizedSetNodeFree(obj->head);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 85431,
                "title": "c-80ms-solution",
                "content": " class RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(umap.find(val) == umap.end()) {\\n            umap[val] = vec.size();\\n            vec.push_back(val);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        auto iter = umap.find(val);\\n        if(iter == umap.end()) {\\n            return false;\\n        } else {\\n            int back = vec.back();\\n            if(back != val) {\\n                vec[umap[val]] = back;\\n                umap[back] = umap[val];\\n            }\\n            umap.erase(iter);\\n            vec.pop_back();\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int size = vec.size();\\n        srand(time(0));\\n        return vec[rand()%size];\\n        \\n    }\\nprivate:\\n    vector<int> vec;\\n    unordered_map<int, int> umap;\\n};",
                "solutionTags": [],
                "code": " class RandomizedSet {\\npublic:\\n    /** Initialize your data structure here. */\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\\n    bool insert(int val) {\\n        if(umap.find(val) == umap.end()) {\\n            umap[val] = vec.size();\\n            vec.push_back(val);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    /** Removes a value from the set. Returns true if the set contained the specified element. */\\n    bool remove(int val) {\\n        auto iter = umap.find(val);\\n        if(iter == umap.end()) {\\n            return false;\\n        } else {\\n            int back = vec.back();\\n            if(back != val) {\\n                vec[umap[val]] = back;\\n                umap[back] = umap[val];\\n            }\\n            umap.erase(iter);\\n            vec.pop_back();\\n            return true;\\n        }\\n    }\\n    \\n    /** Get a random element from the set. */\\n    int getRandom() {\\n        int size = vec.size();\\n        srand(time(0));\\n        return vec[rand()%size];\\n        \\n    }\\nprivate:\\n    vector<int> vec;\\n    unordered_map<int, int> umap;\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3584797,
                "title": "best-optimised-solution-with-the-best-runtime-provided-beats-90-of-cpp-solutions-in-speed-and-mem",
                "content": "# Intuition\\nWe can use the set but we cannot access the random index directly from the set without traversing it..so this will result in more time complexity.\\n\\n# Approach\\nWe can use an unordered_map and vector in the insertion we keep track of the indices and we add the value to vector and add the index of the element\\'s index to the map and in the deletion we change the key index to the last index and replace it with the last value and we just delete and erase from the map..so in random we can return a value by rand() funtion.\\n\\n# Complexity\\n- Time complexity:\\nInsertion-->O(1)\\nDeletion-->O(1map)\\nRandom-->O(1)\\n- Space complexity:\\nmap-->O(n)\\nvector-->O(n)\\n\\n# Code\\n```\\nclass RandomizedSet {\\nprivate:\\nunordered_map<int,int> m;\\nvector<int>v;    \\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n       if(m.count(val))\\n       return false;\\n       m[val]=v.size();\\n       v.push_back(val);\\n       return true;\\n    }\\n    \\n    bool remove(int val) {\\n      if(!m.count(val))\\n      return false;\\n      int p=v.back();\\n      m[p]=m[val];\\n      v[m[val]]=p;\\n      v.pop_back();\\n      m.erase(val);\\n      return true;\\n    }\\n    \\n    int getRandom() {\\n     return v[rand()% v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\nprivate:\\nunordered_map<int,int> m;\\nvector<int>v;    \\npublic:\\n    RandomizedSet() {}\\n    \\n    bool insert(int val) {\\n       if(m.count(val))\\n       return false;\\n       m[val]=v.size();\\n       v.push_back(val);\\n       return true;\\n    }\\n    \\n    bool remove(int val) {\\n      if(!m.count(val))\\n      return false;\\n      int p=v.back();\\n      m[p]=m[val];\\n      v[m[val]]=p;\\n      v.pop_back();\\n      m.erase(val);\\n      return true;\\n    }\\n    \\n    int getRandom() {\\n     return v[rand()% v.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423045,
                "title": "insert-delete-getrandom-o-1",
                "content": "------------------- Easy C++ Solution -------------------\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    set<int>s;\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val) != s.end()){\\n            return false;\\n        }\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n         if(s.find(val) == s.end()){\\n            return false;\\n        }\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        set<int>::iterator it = s.begin();\\n        advance(it, rand()%s.size());\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\n    set<int>s;\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(s.find(val) != s.end()){\\n            return false;\\n        }\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n         if(s.find(val) == s.end()){\\n            return false;\\n        }\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        set<int>::iterator it = s.begin();\\n        advance(it, rand()%s.size());\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279003,
                "title": "using-inbuilt-function-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass RandomizedSet\\n    def initialize()\\n        @a = []\\n    end\\n\\n\\n=begin\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def insert(val)\\n        if @a.include?(val)\\n            return false\\n        else\\n            @a.push(val)\\n            return true\\n        end\\n    end\\n\\n\\n=begin\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def remove(val)\\n        if @a.include?(val)\\n            @a.delete(val)\\n            return true\\n        else\\n            return false\\n        end\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def get_random()\\n        @a.sample\\n    end\\n\\n\\nend\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet.new()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.get_random()\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass RandomizedSet\\n    def initialize()\\n        @a = []\\n    end\\n\\n\\n=begin\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def insert(val)\\n        if @a.include?(val)\\n            return false\\n        else\\n            @a.push(val)\\n            return true\\n        end\\n    end\\n\\n\\n=begin\\n    :type val: Integer\\n    :rtype: Boolean\\n=end\\n    def remove(val)\\n        if @a.include?(val)\\n            @a.delete(val)\\n            return true\\n        else\\n            return false\\n        end\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def get_random()\\n        @a.sample\\n    end\\n\\n\\nend\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet.new()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.get_random()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270967,
                "title": "java-using-arraylist-30-ms",
                "content": "I used binary search to make the elements inside array list unique.\\n\\n# Complexity\\n- Time complexity: \\n\\n# Code\\n```\\nclass RandomizedSet {\\n    ArrayList<Integer> list;\\n    static Random random = new Random();\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        int res = Collections.binarySearch(list, val);\\n        if (res < 0) {\\n            list.add(-res - 1, val);\\n            return true;\\n        } else return false;\\n    }\\n\\n    public boolean remove(int val) {\\n        int res = Collections.binarySearch(list, val);\\n        if (res < 0) {\\n            return false;\\n        } else {\\n            list.remove(res);\\n            return true;\\n        }\\n    }\\n\\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n    ArrayList<Integer> list;\\n    static Random random = new Random();\\n    public RandomizedSet() {\\n        list = new ArrayList<>();\\n    }\\n\\n    public boolean insert(int val) {\\n        int res = Collections.binarySearch(list, val);\\n        if (res < 0) {\\n            list.add(-res - 1, val);\\n            return true;\\n        } else return false;\\n    }\\n\\n    public boolean remove(int val) {\\n        int res = Collections.binarySearch(list, val);\\n        if (res < 0) {\\n            return false;\\n        } else {\\n            list.remove(res);\\n            return true;\\n        }\\n    }\\n\\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220426,
                "title": "c-self-explanatory",
                "content": "#\\n\\n# Code\\n```\\nclass RandomizedSet {\\n    unordered_map<int, int> index;\\n    vector<int>value;\\n\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(index.count(val) > 0){\\n            if(index[val] >= 0){\\n                return false;\\n            }\\n            \\n        }\\n        this->value.push_back(val);\\n        this->index[val] = this->value.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(index.count(val) > 0){\\n            if(index[val] >= 0){\\n                index[value.back()] = index[val];\\n                value[index[val]] = value.back();\\n                index[val] = -1;\\n                value.pop_back();\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        return value[rand()%value.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\n    unordered_map<int, int> index;\\n    vector<int>value;\\n\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(index.count(val) > 0){\\n            if(index[val] >= 0){\\n                return false;\\n            }\\n            \\n        }\\n        this->value.push_back(val);\\n        this->index[val] = this->value.size()-1;\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(index.count(val) > 0){\\n            if(index[val] >= 0){\\n                index[value.back()] = index[val];\\n                value[index[val]] = value.back();\\n                index[val] = -1;\\n                value.pop_back();\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        return value[rand()%value.size()];\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051687,
                "title": "simple-c-solution-using-map-and-array",
                "content": "\\tclass RandomizedSet {\\n\\tpublic:\\n\\t   unordered_map<int,int>mp;\\n\\t\\tvector<int>arr;\\n\\t\\tRandomizedSet() {\\n\\n\\t\\t}\\n    \\n    bool insert(int val) {\\n     if(mp.count(val))\\n     {\\n         return false;\\n     }\\n     arr.push_back(val);\\n     mp[val] = arr.size()-1;\\n     return true;\\n    }\\n    \\n    bool remove(int val) {\\n     if(mp.count(val))\\n     {\\n     int index = mp[val];\\n     int v = arr.back();\\n     arr[index] = v;\\n     mp[v] = index;\\n     arr.pop_back();\\n     mp.erase(val);\\n    return true;\\n     }\\n    return false;\\n    }\\n    \\n    int getRandom() {\\n      int index = rand()%arr.size();\\n      return arr[index];  \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "\\tclass RandomizedSet {\\n\\tpublic:\\n\\t   unordered_map<int,int>mp;\\n\\t\\tvector<int>arr;\\n\\t\\tRandomizedSet() {\\n\\n\\t\\t}\\n    \\n    bool insert(int val) {\\n     if(mp.count(val))\\n     {\\n         return false;\\n     }\\n     arr.push_back(val);\\n     mp[val] = arr.size()-1;\\n     return true;\\n    }\\n    \\n    bool remove(int val) {\\n     if(mp.count(val))\\n     {\\n     int index = mp[val];\\n     int v = arr.back();\\n     arr[index] = v;\\n     mp[v] = index;\\n     arr.pop_back();\\n     mp.erase(val);\\n    return true;\\n     }\\n    return false;\\n    }\\n    \\n    int getRandom() {\\n      int index = rand()%arr.size();\\n      return arr[index];  \\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2860093,
                "title": "insert-delete-getrandom-o-1-unordered-map-vector",
                "content": "**Insert Delete GetRandom O(1)**\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int>mp;\\n    vector<int>arr;\\n\\t\\n    // Initializes the RandomizedSet object.\\n    RandomizedSet() { }\\n    \\n\\t// Inserts an item val into the set if not present.\\n\\t//Returns true if the set did not already contain the specified element,\\n\\t//false otherwise.\\n\\t//count function returns true if val is present in map\\n    bool insert(int val) {\\n        if(mp.count(val)){\\n            return false;\\n        }\\n        arr.push_back(val);\\n        mp[val]=arr.size()-1;\\n        return true;\\n    }\\n    \\n\\t//Removes an item val from the set if present. \\n\\t//Returns true if the set contained the specified element.\\n    bool remove(int val) {\\n        \\n        if(mp.count(val)){\\n            int indexx = mp[val];\\n            int v=arr.back();\\n            arr[indexx]=v;\\n            mp[v]=indexx;\\n            arr.pop_back();\\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n\\t// Get a random element from the set.\\n\\t//rand()%arr.size() will give the random element in the \\n\\t//range of arr size.\\n    int getRandom() {\\n        int index = rand()%arr.size();\\n        return arr[index];\\n    }\\n};\\n```\\n\\n**More Explanation**(found this in discussion section)\\n\\nUsually the first thing that comes to find when we hear \"insert\" in constant time is \"hashmaps\".\\nThat\\'s the reason we use an unordered_map here which stores the element as \" key \" and its position in vector as the \"value \".. The average time complexity of search , insert and remove elements from a hashmap is O(1).\\n\\nHowever , here we need to support \"Random()\" access in O(1) as well. so we are using a vector here to achieve that.\\nHere is the trick to remove in constant time.\\nHere is the pseudo-code\\n\\n1) If the element you are trying to remove is the last element in the vector, remove it, done, ELSE,\\n2) Read the last element of the vector and write it over the element-to-be-removed\\n\\n3) Now remove the last element of the vector. (C++ pop_back() in a vector is O(1))\\nThat is exactly the trick we are using here, only that we need to update our hashmap as well.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_map<int,int>mp;\\n    vector<int>arr;\\n\\t\\n    // Initializes the RandomizedSet object.\\n    RandomizedSet() { }\\n    \\n\\t// Inserts an item val into the set if not present.\\n\\t//Returns true if the set did not already contain the specified element,\\n\\t//false otherwise.\\n\\t//count function returns true if val is present in map\\n    bool insert(int val) {\\n        if(mp.count(val)){\\n            return false;\\n        }\\n        arr.push_back(val);\\n        mp[val]=arr.size()-1;\\n        return true;\\n    }\\n    \\n\\t//Removes an item val from the set if present. \\n\\t//Returns true if the set contained the specified element.\\n    bool remove(int val) {\\n        \\n        if(mp.count(val)){\\n            int indexx = mp[val];\\n            int v=arr.back();\\n            arr[indexx]=v;\\n            mp[v]=indexx;\\n            arr.pop_back();\\n            mp.erase(val);\\n            \\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n\\t// Get a random element from the set.\\n\\t//rand()%arr.size() will give the random element in the \\n\\t//range of arr size.\\n    int getRandom() {\\n        int index = rand()%arr.size();\\n        return arr[index];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859750,
                "title": "go-solution-everything-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\ntype RandomizedSet struct {\\n    store map[int]int\\n    indexes []int\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{store: make(map[int]int), indexes: make([]int, 0)}\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.store[val]; ok {\\n        return false\\n    }\\n    this.indexes = append(this.indexes, val)\\n    this.store[val] = len(this.indexes) -1\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    itemIndex, ok := this.store[val]\\n    if !ok {\\n        return false\\n    }\\n    lastIndex := len(this.indexes) -1\\n    lastElem := this.indexes[lastIndex]\\n    this.indexes[itemIndex] = lastElem\\n    this.store[lastElem] = itemIndex\\n    delete(this.store, val)\\n    this.indexes = this.indexes[:len(this.indexes)-1]\\n    return true\\n}\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    return this.indexes[rand.Intn(len(this.indexes))]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\ntype RandomizedSet struct {\\n    store map[int]int\\n    indexes []int\\n}\\n\\n\\nfunc Constructor() RandomizedSet {\\n    return RandomizedSet{store: make(map[int]int), indexes: make([]int, 0)}\\n}\\n\\n\\nfunc (this *RandomizedSet) Insert(val int) bool {\\n    if _, ok := this.store[val]; ok {\\n        return false\\n    }\\n    this.indexes = append(this.indexes, val)\\n    this.store[val] = len(this.indexes) -1\\n    return true\\n}\\n\\n\\nfunc (this *RandomizedSet) Remove(val int) bool {\\n    itemIndex, ok := this.store[val]\\n    if !ok {\\n        return false\\n    }\\n    lastIndex := len(this.indexes) -1\\n    lastElem := this.indexes[lastIndex]\\n    this.indexes[itemIndex] = lastElem\\n    this.store[lastElem] = itemIndex\\n    delete(this.store, val)\\n    this.indexes = this.indexes[:len(this.indexes)-1]\\n    return true\\n}\\n\\nfunc (this *RandomizedSet) GetRandom() int {\\n    return this.indexes[rand.Intn(len(this.indexes))]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2859673,
                "title": "java-solution",
                "content": "Solution - \\n```\\nclass RandomizedSet {\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    Random random;\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list = new ArrayList<>();\\n        random = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(map.containsKey(val))\\n            return false;\\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val))\\n            return false;\\n        \\n        int i = map.remove(val);\\n        int last = list.size()-1;\\n        if(i != last){\\n            int lastVal = list.get(last);\\n            list.set(i, lastVal);\\n            map.put(lastVal, i);\\n        }\\n        list.remove(last);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass RandomizedSet {\\n    Map<Integer, Integer> map;\\n    List<Integer> list;\\n    Random random;\\n    public RandomizedSet() {\\n        map = new HashMap<>();\\n        list = new ArrayList<>();\\n        random = new Random();\\n    }\\n    \\n    public boolean insert(int val) {\\n        if(map.containsKey(val))\\n            return false;\\n        map.put(val, list.size());\\n        list.add(val);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!map.containsKey(val))\\n            return false;\\n        \\n        int i = map.remove(val);\\n        int last = list.size()-1;\\n        if(i != last){\\n            int lastVal = list.get(last);\\n            list.set(i, lastVal);\\n            map.put(lastVal, i);\\n        }\\n        list.remove(last);\\n        map.remove(val);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet obj = new RandomizedSet();\\n * boolean param_1 = obj.insert(val);\\n * boolean param_2 = obj.remove(val);\\n * int param_3 = obj.getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859606,
                "title": "swift-4-lines-easy-to-understand",
                "content": "```\\nclass RandomizedSet {\\n    var store: Set<Int> = []\\n\\n    init() {}\\n    \\n    func insert(_ val: Int) -> Bool {\\n        return store.insert(val).inserted == false ? false : true\\n    }\\n    \\n    func remove(_ val: Int) -> Bool {\\n        return store.remove(val) != nil ? true : false\\n    }\\n    \\n    func getRandom() -> Int {\\n        // store.first ?? 0 should work as set is an unordered list and \\n        // store.first O(1) but it doesn\\'t work here and test 17 is wrong\\n        return store.randomElement() ?? 0\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass RandomizedSet {\\n    var store: Set<Int> = []\\n\\n    init() {}\\n    \\n    func insert(_ val: Int) -> Bool {\\n        return store.insert(val).inserted == false ? false : true\\n    }\\n    \\n    func remove(_ val: Int) -> Bool {\\n        return store.remove(val) != nil ? true : false\\n    }\\n    \\n    func getRandom() -> Int {\\n        // store.first ?? 0 should work as set is an unordered list and \\n        // store.first O(1) but it doesn\\'t work here and test 17 is wrong\\n        return store.randomElement() ?? 0\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858902,
                "title": "easy-approach-using-set",
                "content": "**Approach**\\nWe will make use of Unordered_Set. We know we can insert , find and remove an element in O(1) using unordered_set.\\nThe question arises for getRandom() method. Using C++ rand() function we will generate any random number between 0 to set.size()-1 , and we will move the Set iterator to point to that index.\\n\\n**To generate random number between 0 to set.size() -1**\\n\\t\\t int random=rand()%s.size();\\n**To move set iterator to that index we will make use of advance() method of set library,**\\nauto it=s.begin();\\nadvance(it , random());\\nThis will advance the iterator **it** to the index speicified in random.\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s; \\n    RandomizedSet() {\\n      \\n    }\\n    \\n    bool insert(int val) {\\n        bool flag=true;\\n        if(s.find(val)!=s.end())\\n            flag=false;\\n        s.insert(val);\\n        return flag;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n            return false;\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        auto it = s.begin();\\n        int random = rand() % s.size();\\n        advance(it,random);\\n        return *it;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int>s; \\n    RandomizedSet() {\\n      \\n    }\\n    \\n    bool insert(int val) {\\n        bool flag=true;\\n        if(s.find(val)!=s.end())\\n            flag=false;\\n        s.insert(val);\\n        return flag;\\n    }\\n    \\n    bool remove(int val) {\\n        if(s.find(val)==s.end())\\n            return false;\\n        s.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        auto it = s.begin();\\n        int random = rand() % s.size();\\n        advance(it,random);\\n        return *it;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858821,
                "title": "rust-hashset",
                "content": "```\\nuse std::collections::HashSet;\\nuse rand::{Rng, prelude::IteratorRandom};\\n\\nstruct RandomizedSet {\\n    set: HashSet<i32>,\\n}\\n\\nimpl RandomizedSet {\\n\\n    fn new() -> Self {\\n        RandomizedSet{set: HashSet::new()}\\n    }\\n    \\n    fn insert(&mut self, val: i32) -> bool {\\n        self.set.insert(val)\\n    }\\n    \\n    fn remove(&mut self, val: i32) -> bool {\\n        self.set.remove(&val)\\n    }\\n    \\n    fn get_random(&self) -> i32 {\\n        let mut rng = rand::thread_rng();\\n        *self.set.iter().choose(&mut rng).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nuse rand::{Rng, prelude::IteratorRandom};\\n\\nstruct RandomizedSet {\\n    set: HashSet<i32>,\\n}\\n\\nimpl RandomizedSet {\\n\\n    fn new() -> Self {\\n        RandomizedSet{set: HashSet::new()}\\n    }\\n    \\n    fn insert(&mut self, val: i32) -> bool {\\n        self.set.insert(val)\\n    }\\n    \\n    fn remove(&mut self, val: i32) -> bool {\\n        self.set.remove(&val)\\n    }\\n    \\n    fn get_random(&self) -> i32 {\\n        let mut rng = rand::thread_rng();\\n        *self.set.iter().choose(&mut rng).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858561,
                "title": "python-simple-and-easy-way-to-solve-with-explanation-92-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nimport random\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        # Initialize Set\\n        self.sets = set()\\n\\n    def insert(self, val: int) -> bool:\\n        # If n is present in set then return false\\n        if val in self.sets : \\n            return False\\n        \\n        # If n is not present in set then add it to the set.\\n        self.sets.add(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        # If n is in set then remove n else return false\\n        if val in self.sets:\\n            self.sets.remove(val)\\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        # Return random number using random module\\n        return random.choice(list(self.sets))\\n```\\n**For Leetcode Solution with Explanation Visit this Blog:\\nhttps://www.python-techs.com\\n(Please open this link in new tab)**\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nimport random\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        # Initialize Set\\n        self.sets = set()\\n\\n    def insert(self, val: int) -> bool:\\n        # If n is present in set then return false\\n        if val in self.sets : \\n            return False\\n        \\n        # If n is not present in set then add it to the set.\\n        self.sets.add(val)\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        # If n is in set then remove n else return false\\n        if val in self.sets:\\n            self.sets.remove(val)\\n            return True\\n        return False\\n\\n    def getRandom(self) -> int:\\n        # Return random number using random module\\n        return random.choice(list(self.sets))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858520,
                "title": "java-hashmap-arraylist",
                "content": "Lets thing of the solution incrementally, consider you put the values in an ArrayList, that way is trivial to add values and get random values. \\nThe only problem is how do you delete a value from there. This can be solved by using a HashMap to keep the indexes of the values, so when you need to remove a value you know where to remove the value from. \\nthe new problem is that removing a value will change the indexes in all the values following the deleted one, adjusting the values would bump complexity to O(n) (remember we want O(1)). So what if no value follows the deleted one... so you guessed it, the fix to this problem is to always delete the value at the end, that way there are no indexes to be adjusted. so first you swap the value to be deleted with the last value, and then you delete the last value. I hope this was helpful. remember to vote up in case you found this useful :)\\n```\\nclass RandomizedSet {\\n    Map<Integer, Integer> valToPos = new HashMap<>();\\n    List <Integer> vals = new ArrayList<>();\\n    Random rand = new Random();\\n    public RandomizedSet() {\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n        if(valToPos.containsKey(val)) return false;\\n        vals.add(val);\\n        valToPos.put(val, vals.size()-1);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!valToPos.containsKey(val)) return false;\\n        int pos = valToPos.remove(val);\\n        int last = vals.remove(vals.size() - 1);\\n        if(pos == vals.size()) return true;\\n        vals.set(pos, last);\\n        valToPos.put(last, pos);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return vals.get(rand.nextInt(vals.size()));\\n    }\\n}",
                "solutionTags": [],
                "code": "Lets thing of the solution incrementally, consider you put the values in an ArrayList, that way is trivial to add values and get random values. \\nThe only problem is how do you delete a value from there. This can be solved by using a HashMap to keep the indexes of the values, so when you need to remove a value you know where to remove the value from. \\nthe new problem is that removing a value will change the indexes in all the values following the deleted one, adjusting the values would bump complexity to O(n) (remember we want O(1)). So what if no value follows the deleted one... so you guessed it, the fix to this problem is to always delete the value at the end, that way there are no indexes to be adjusted. so first you swap the value to be deleted with the last value, and then you delete the last value. I hope this was helpful. remember to vote up in case you found this useful :)\\n```\\nclass RandomizedSet {\\n    Map<Integer, Integer> valToPos = new HashMap<>();\\n    List <Integer> vals = new ArrayList<>();\\n    Random rand = new Random();\\n    public RandomizedSet() {\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n        if(valToPos.containsKey(val)) return false;\\n        vals.add(val);\\n        valToPos.put(val, vals.size()-1);\\n        return true;\\n    }\\n    \\n    public boolean remove(int val) {\\n        if(!valToPos.containsKey(val)) return false;\\n        int pos = valToPos.remove(val);\\n        int last = vals.remove(vals.size() - 1);\\n        if(pos == vals.size()) return true;\\n        vals.set(pos, last);\\n        valToPos.put(last, pos);\\n        return true;\\n    }\\n    \\n    public int getRandom() {\\n        return vals.get(rand.nextInt(vals.size()));\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2685432,
                "title": "easy-solution-in-c-using-advance-iterator-in-hashset",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() {\\n    }\\n    \\n    bool insert(int val) {\\n        if(st.find(val)!=st.end())\\n            return false;\\n        st.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.find(val)!=st.end()){\\n            st.erase(st.find(val));\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it=st.begin();\\n        int random=rand()%st.size();\\n        advance(it,random);\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    unordered_set<int> st;\\n    RandomizedSet() {\\n    }\\n    \\n    bool insert(int val) {\\n        if(st.find(val)!=st.end())\\n            return false;\\n        st.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(st.find(val)!=st.end()){\\n            st.erase(st.find(val));\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n        auto it=st.begin();\\n        int random=rand()%st.size();\\n        advance(it,random);\\n        return *it;\\n    }\\n};\\n\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672216,
                "title": "c-easy-to-understand-short",
                "content": "\\n# Code\\n```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    bool insert(int val) {\\n        if (m.find(val) != m.end()) return false;\\n        nums.emplace_back(val);\\n        m[val] = nums.size() - 1;\\n        return true;\\n    }\\n    bool remove(int val) {\\n        if (m.find(val) == m.end()) return false;\\n        int last = nums.back();\\n        m[last] = m[val];\\n        nums[m[val]] = last;\\n        nums.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\nprivate:\\n    vector<int> nums;\\n    unordered_map<int, int> m;\\n};\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    RandomizedSet() {\\n        \\n    }\\n    bool insert(int val) {\\n        if (m.find(val) != m.end()) return false;\\n        nums.emplace_back(val);\\n        m[val] = nums.size() - 1;\\n        return true;\\n    }\\n    bool remove(int val) {\\n        if (m.find(val) == m.end()) return false;\\n        int last = nums.back();\\n        m[last] = m[val];\\n        nums[m[val]] = last;\\n        nums.pop_back();\\n        m.erase(val);\\n        return true;\\n    }\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\nprivate:\\n    vector<int> nums;\\n    unordered_map<int, int> m;\\n};\\n/**\\n * Your RandomizedSet object will be instantiated and called as such:\\n * RandomizedSet* obj = new RandomizedSet();\\n * bool param_1 = obj->insert(val);\\n * bool param_2 = obj->remove(val);\\n * int param_3 = obj->getRandom();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571481,
                "title": "typescript",
                "content": "```\\nclass RandomizedSet {\\n    set = new Set<number>();\\n\\n    constructor() { }\\n\\n    insert(val: number): boolean {\\n        let result = !this.set.has(val);\\n        this.set.add(val);\\n        return result;\\n    }\\n\\n    remove(val: number): boolean {\\n        let result = this.set.has(val);\\n        this.set.delete(val);\\n        return result;\\n    }\\n\\n    getRandom(): number {\\n        return [...this.set.values()][Math.floor(Math.random() * this.set.size)];\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nclass RandomizedSet {\\n    set = new Set<number>();\\n\\n    constructor() { }\\n\\n    insert(val: number): boolean {\\n        let result = !this.set.has(val);\\n        this.set.add(val);\\n        return result;\\n    }\\n\\n    remove(val: number): boolean {\\n        let result = this.set.has(val);\\n        this.set.delete(val);\\n        return result;\\n    }\\n\\n    getRandom(): number {\\n        return [...this.set.values()][Math.floor(Math.random() * this.set.size)];\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536845,
                "title": "c-inser-delete-getrandom-o-1",
                "content": "Idea: If we want to delete an element val in the array in O(1) time, we can first swap this element to the end of the array, and then pop it off. And we need a hash table  to record the index corresponding to each element value.\\n```\\nclass RandomizedSet {\\n    public:\\n    vector<int> nums;\\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\n    public:\\n    vector<int> nums;\\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516920,
                "title": "java-fast-than-97",
                "content": "class RandomizedSet {\\n    Map<Integer,Integer> map; //record value and index in list\\n    List<Integer> list;  // get random element\\n    \\n\\n\\n\\n  ```\\nclass RandomizedSet {\\n    Map<Integer,Integer> map; //record value and index in list\\n    List<Integer> list;  // get random element\\n\\n    public RandomizedSet() {\\n       map= new HashMap<>();\\n       list = new ArrayList<>();\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n       if(map.containsKey(val)){\\n           return false;\\n       }\\n        \\n          int index = list.size();\\n          list.add(val);\\n          map.put(val,index);\\n          return true;\\n       \\n       \\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            int index = map.get(val);\\n\\t\\t\\t//remove in list is not lways O(1), only when it is last one\\n\\t\\t\\t//so if it is last one, we just remove it\\n\\t\\t\\t//if it is in the other place, we could swap with last one, then remove it\\n            if(index == list.size()-1){\\n                list.remove(index);\\n            }else{\\n                int last = list.size()-1;\\n                int swapvalue = list.get(last);\\n                list.set(index,swapvalue);\\n                list.remove(last);\\n                map.put(swapvalue,index);    \\n            }\\n            map.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        int size = list.size();\\n        int random = (int)(Math.random()*size);\\n        return list.get(random);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class RandomizedSet {\\n    Map<Integer,Integer> map; //record value and index in list\\n    List<Integer> list;  // get random element\\n    \\n\\n\\n\\n  ```\\nclass RandomizedSet {\\n    Map<Integer,Integer> map; //record value and index in list\\n    List<Integer> list;  // get random element\\n\\n    public RandomizedSet() {\\n       map= new HashMap<>();\\n       list = new ArrayList<>();\\n        \\n    }\\n    \\n    public boolean insert(int val) {\\n       if(map.containsKey(val)){\\n           return false;\\n       }\\n        \\n          int index = list.size();\\n          list.add(val);\\n          map.put(val,index);\\n          return true;\\n       \\n       \\n    }\\n    \\n    public boolean remove(int val) {\\n        if(map.containsKey(val)){\\n            int index = map.get(val);\\n\\t\\t\\t//remove in list is not lways O(1), only when it is last one\\n\\t\\t\\t//so if it is last one, we just remove it\\n\\t\\t\\t//if it is in the other place, we could swap with last one, then remove it\\n            if(index == list.size()-1){\\n                list.remove(index);\\n            }else{\\n                int last = list.size()-1;\\n                int swapvalue = list.get(last);\\n                list.set(index,swapvalue);\\n                list.remove(last);\\n                map.put(swapvalue,index);    \\n            }\\n            map.remove(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public int getRandom() {\\n        int size = list.size();\\n        int random = (int)(Math.random()*size);\\n        return list.get(random);\\n        \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2491664,
                "title": "python-simple-implementation-using-map",
                "content": "```\\nfrom random import randint\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.m = {}\\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.m:\\n            self.m[val] = val\\n            return True\\n        else:\\n            return False\\n        \\n    def remove(self, val: int) -> bool:\\n        if val not in self.m:\\n            return False\\n        del self.m[val]\\n        return True\\n\\n    def getRandom(self) -> int:\\n        size = len(self.m)\\n        ind = randint(0, size-1)\\n        keys = list(self.m)\\n        return keys[ind]\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom random import randint\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.m = {}\\n\\n    def insert(self, val: int) -> bool:\\n        if val not in self.m:\\n            self.m[val] = val\\n            return True\\n        else:\\n            return False\\n        \\n    def remove(self, val: int) -> bool:\\n        if val not in self.m:\\n            return False\\n        del self.m[val]\\n        return True\\n\\n    def getRandom(self) -> int:\\n        size = len(self.m)\\n        ind = randint(0, size-1)\\n        keys = list(self.m)\\n        return keys[ind]\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483261,
                "title": "tc-o-1-short-easy-super-efficient-approach-beats-99-76-without-using-find-function",
                "content": "This problem only requires to design a data structure that supports these operations insert, remove, and getRandom in constant time complexity O(1).\\n\\nPlease **upvote** if you like this simpler solution (**Without using find function basically which avoids O(log n) time extra operation**).\\n\\n```\\nclass RandomizedSet {\\npublic:\\n    // Using vector to store elements and map to store elements with index+1 value;\\n    unordered_map<int,int>mp;\\n    vector<int>vec;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(mp[val])\\n            return false;\\n        \\n        vec.push_back(val); //0 based indexing\\n        mp[val]=vec.size(); //1 based indexing to avoid to use find func in map\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(!mp[val])\\n            return false;\\n        \\n        int index=mp[val]-1;\\n        int last_val=vec.back();\\n        swap(vec[index],vec[vec.size()-1]); // swapping last element with index of val index\\n        vec.pop_back();\\n        mp[last_val]=index+1;\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        if(vec.size()>0)\\n            return vec[rand()%vec.size()];\\n        \\n        return -1; // list is empty\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass RandomizedSet {\\npublic:\\n    // Using vector to store elements and map to store elements with index+1 value;\\n    unordered_map<int,int>mp;\\n    vector<int>vec;\\n    RandomizedSet() {\\n        \\n    }\\n    \\n    bool insert(int val) {\\n        if(mp[val])\\n            return false;\\n        \\n        vec.push_back(val); //0 based indexing\\n        mp[val]=vec.size(); //1 based indexing to avoid to use find func in map\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if(!mp[val])\\n            return false;\\n        \\n        int index=mp[val]-1;\\n        int last_val=vec.back();\\n        swap(vec[index],vec[vec.size()-1]); // swapping last element with index of val index\\n        vec.pop_back();\\n        mp[last_val]=index+1;\\n        mp.erase(val);\\n        return true;\\n    }\\n    \\n    int getRandom() {\\n        if(vec.size()>0)\\n            return vec[rand()%vec.size()];\\n        \\n        return -1; // list is empty\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566348,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1565062,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1564790,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1565840,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1938482,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1699778,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1571653,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1927731,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1699732,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1571879,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1566348,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1565062,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1564790,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1565840,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1938482,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1699778,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1571653,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1927731,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1699732,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1571879,
                "content": [
                    {
                        "username": "pawel753",
                        "content": "Anyone else having troubles with Asserting Random values in unit tests? \\nMy solution was not accepted because ranom values which it generates is sometimes different than defined as expected in Unit tests. Of course it is, because **it\\'s random!**\\nHas anybody overcome this problem for C# solution?"
                    },
                    {
                        "username": "xinyu6",
                        "content": "An issue I found for myself is that Random.Next(int 32) is to return value *Less* than the specified maximum, not <=. \nSo previously I use Random.Next(MaxLength-1) and failed since I never return the last digit."
                    },
                    {
                        "username": "wxly",
                        "content": "I am stuck on this as well in C. wondering if i am missing something... how could any solution generate the exact same random numbers as the ones its expecting?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "try using Random rand = new Random(); int randInd = rand.nextInt(list.size()); instead of math.random()"
                    },
                    {
                        "username": "IgorPykhtin",
                        "content": "[@alge](/alge) Funny, but it helped, thanks! :)"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I have a similar problem with my C++ Code, I generate random numbers from the Set; and then it doesn't match with the sequency in the unit case. Isn't **Random** supposed to be **Random**?"
                    },
                    {
                        "username": "alge",
                        "content": "I had similar situation:\\nall differences between my output and expected in one big test were for `getRandom` operation, all.. except one for `remove` operation\\n\\nWhen I fixed this wrong answer for `remove` it passed\\n\\nMaybe it will help somebody"
                    },
                    {
                        "username": "BatCoder",
                        "content": "If we just use a hashset (`unordered_set`), then we can implement both `insert()` and `remove()` in O(1) time, by using the `insert()` and `erase()` methods.  [Refer [this](https://stackoverflow.com/questions/222658/multiset-map-and-hash-map-complexity) link for more details].  \\n\\nThe only challenge is with implementing `getRandom()` in `O(1)`.  Something na\\xEFve like just `rand()` cannot be used on a hashset, so we need to use the `std::advance()` method which would inturn result in this being an `O(n)` method.  \\n\\nThus, in order to implement `getRandom()` as well in O(1), we need to use a different method (of using a hashMap and arraylist) than just using a hashset.\\n\\nPlease let me know if you find something incorrect in this post."
                    },
                    {
                        "username": "cswartzell",
                        "content": "I really wish they\\u2019d clarify that the intent is extending existing base classes. Pretty sure I\\u2019m not being asked to write an explicit hashing and memory management algorthm from scratch here, but then again it\\u2019s beyond trivial to \\u201Cinplement\\u201D a method that just calls an existing method on an existing object you\\u2019ve called. It\\u2019s like claiming I\\u2019ve \\u201Cprepared\\u201D dinner by ordering it for delivery "
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "I predict that many of us will think of using a hash table, but I'm not aware of any that really offer the needed operations in O(1). Are there any?\\n\\nWe do usually think of them as O(1), and I think that's ok because in practice they do average/amortize O(1) and everybody knows what is meant (right?) and they're usually just a small building block in the actual algorithm. Would be pretty annoying if we had to always asterisk the complexity discussion of every algorithm that uses hash tables. But here, the set data structure isn't just a helping part in the actual thing we're building. It ***is*** the actual thing. And we're explicitly required to achieve O(1), it's even the problem title. So I think we shouldn't be sloppy here.\\n\\n**Update:** The problem has been updated to say \"average\"."
                    },
                    {
                        "username": "xiaochenzhou",
                        "content": "This OJ problem is intrinsically different from all others, as randomness is involved here.\\n\\nLet's say someone comes up with an answer where getRandom always returns the smallest val (or maybe first val in some array or hash set). Then, how can the test cases tell that this solution is wrong?\\n\\nEven when some random choice algorithm is used, how can it be tested that all values are equally likely to be chosen, and different calls of getRandom are independent?"
                    },
                    {
                        "username": "jventura3",
                        "content": "You would just have a bunch of trials run.  If we have 0, 1, 2, 3, 4, then we expect after 10000 calls to `getRandom()` to see each element appear approximately 10000/5 = 2000 times"
                    },
                    {
                        "username": "AviralSharma8309",
                        "content": "got this in my deshaw interview ,"
                    },
                    {
                        "username": "piocarz",
                        "content": "Got question about Python implementation:\nsince set.pop() removes from set random value and then returns it, why such silly implementation wouldnt work? :\n\n`x = self.set_name.pop();\nself.set_name.add(x);\nreturn x`\n\nI know its not best or anything, just wonder why it doesnt work?"
                    },
                    {
                        "username": "ranbir7",
                        "content": "as far as I know  I havent used pop() on sets. I have used discard(), remove()."
                    },
                    {
                        "username": "eundoosong",
                        "content": "This problem says,\\nEach element must have the same probability of being returned.\\nWhat does \\u201csame probability\\u201d mean?\\n\\nPer my understanding of probability,  to have the same probability, \\ngetRandom should return each element in the same probability like\\nP(X) = 1/N (X = x1, x2, x3,\\u2026\\u2026.xN)\\n\\nI saw all of you here used random function to return an element randomly.\\nHow this can be the same probability?\\n\\nI get confused in understanding this sentence when I first read the problem and had no idea how to solve.\\nDid I misunderstand?"
                    },
                    {
                        "username": "psionl0",
                        "content": "The need for O(1) random access complicates this exercise slightly. You need a hashmap for O(1) insertions and removals and an integer array for the O(1) random access. The hashmap entries should include an index with each value to show where it is in the array.\\n\\nOne way to ensure O(1) removal from the array is to move just the end element to where the gap is (instead of shifting all the elements over). Don\\'t forget to store the new index for this particular value."
                    },
                    {
                        "username": "Omarito",
                        "content": "Why a hashmap + linkedlist doesn't work ? My get random is failing to pass test cases.\nMy idea for get random is essentially taking the head and re-assign it to the end of the linkedlist while returning its value (basically recycling the list to get equal probability)"
                    },
                    {
                        "username": "MariaMozgunova",
                        "content": "Also, how do you insert a new value to the linked list in your implementation? If you always insert to the end of the linked list, then this value will be returned after `n` calls to `getRandom` where `n` is the length of the linked list before inserting this new element.\\n\\nIf you were to try to randomize it, then you would need to generate a random `k`, iterate the linked list until the position of `k` and insert the new value there. This makes `getRandom` work in `O(n)`."
                    },
                    {
                        "username": "arneish",
                        "content": "No, your solution is not returning a probabilistic output. In other words, your approach will return a deterministic output given a history of API calls made to this interface. You are not incorporating any randomness at all in the process. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "I think the online judge is testing your code's randomness like, for example, running with the same test case for 100 times, and then see if your output is always the same."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Maybe because you return consecutive values when you are asked to return random ones? "
                    },
                    {
                        "username": "david_taylor",
                        "content": "Can leetcode really verifies if the submitted solution is O(1), and fails if it is not? I am using arrays in my javascript solution for constant time access of element. But arrays in javascript does not provide constant time access as they are implemented using key-value objects."
                    }
                ]
            },
            {
                "id": 1571652,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2025084,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 1572651,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 1571654,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 1575880,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 1632263,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2069454,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2055711,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2054644,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2054315,
                "content": [
                    {
                        "username": "tmmmm12",
                        "content": "Can someone please point out why the below test case fails? \\nI think if we remove an element to the set and then remove it and re-insert it, then re-insert should return true. Please help clarify the below test case.\\n\\nInput:\\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\\n[[],[0],[0],[0],[],[0],[0]]\\nOutput:\\n[null,false,false,true,0,true,false]\\nExpected:\\n[null,false,false,true,0,true,true]"
                    },
                    {
                        "username": "user7854c",
                        "content": "The contents of your set when getRandom is called: [0].\nNow you do a remove(0), it becomes empty.\nNext you insert 0 which will return true, thats where my friend it is incorrect."
                    },
                    {
                        "username": "NagendraD",
                        "content": "While inserting if the element already present return false, otherwise the element added to list and return true"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "yes reinsert should return true and your output is false"
                    },
                    {
                        "username": "denisOgr",
                        "content": "The Expected output is not uniformly distributed (with the same probability). \\nI tested it.\\nI ran one case with many `getRandom` calls, but it failed, and I checked the actual (my results from the getRandom) with the expected result.\\nNext, I calculated the distribution of the result numbers \\nMy result: Counter({1: 2500, 10: 2500, 20: 2500, 30: 2500})\\nExpected result: Counter({1: 2533, 30: 2513, 20: 2507, 10: 2447})\\n\\nAs you can see, my solution of the `getRandom` provides perfect uniform distribution (each number was returning the same number of times, in my case 2500 times), but the expected result is not the uniform distribution (the number `1` was returning 2533 times but number `10` only 2447)\\n\\nMy conclusion: this task expects NOT uniform distribution from the `getRandom` method; it expects similar distribution (similar algo) as in the internal solution (that provides the expected results). "
                    },
                    {
                        "username": "sergei99",
                        "content": "Encountered exactly same thing 10 days ago."
                    },
                    {
                        "username": "ravitejathoram",
                        "content": "For the given question how can we handle concurrent usage?\\n\\nIs it just replacing HashMap with HashTable and ArrayList with Vector? or Need to declare methods as synchronized?"
                    },
                    {
                        "username": "BaskWind",
                        "content": "I'm using C++ and the interface given in the code snippet is delete(), while in the description the function is actually named as remove(). Also, using delete as the function name would cause compiler error as well."
                    },
                    {
                        "username": "sarthaksuperb",
                        "content": "# Can\\'t we implement it using unordered set??"
                    },
                    {
                        "username": "lampuiho",
                        "content": "when you use getrandom(), you need to access the set somehow but numbers stored in the set are not contagious memory so you can\\'t just add a position to the first element\\'s iterator."
                    },
                    {
                        "username": "shiyisrsly",
                        "content": "class RandomizedSet {\\n    public:\\n\\n    vector<int> nums;\\n \\n    unordered_map<int,int> valToIndex;\\n\\n    bool insert(int val) {\\n\\n        if (valToIndex.count(val)) {\\n            return false;\\n        }\\n\\n        valToIndex[val] = nums.size();\\n        nums.push_back(val);\\n        return true;\\n    }\\n\\n    bool remove(int val) {\\n        if (!valToIndex.count(val)) {\\n            return false;\\n        }\\n        int index = valToIndex[val];\\n        valToIndex[nums.back()] = index;\\n        swap(nums[index], nums.back());\\n        nums.pop_back();\\n        valToIndex.erase(val);\\n        return true;\\n    }\\n\\n    int getRandom() {\\n        return nums[rand() % nums.size()];\\n    }\\n};"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "My code failed just because I used mapp[val] instead of mapp.count(val) in insert. It\\'s so dumb!!! Can anyone explain what could be the reason?"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "I solved this by making a large array of binary trees, and I got an interesting result, increasing or decreasing the size of the array from 10000, makes it slower, can anyone explain this behaviour?"
                    },
                    {
                        "username": "samDeopa",
                        "content": "to randomize the val use Random rand = new Random(); instead of Using Math.Random to get the test cases right."
                    },
                    {
                        "username": "vbarinov",
                        "content": "Don\\'t use `Math.round` with `getRandom` in JS/TS, use `Math.floor`"
                    },
                    {
                        "username": "jls47",
                        "content": "This is great.  More class implementation based problems, please!"
                    }
                ]
            },
            {
                "id": 2027680,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 2017395,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 2010852,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 2007158,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1964069,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1959369,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1956467,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1935914,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1917844,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1909513,
                "content": [
                    {
                        "username": "auyeungaidan",
                        "content": "Bruh how are we supposed to know that random.choice is a thing :/"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "Tip: Don\\'t use math.random(). Use the random class from Java if you\\'re coding in Java."
                    },
                    {
                        "username": "sergei99",
                        "content": "Amazing that it does not accept strictly even distribution, frequences of numbers returned by getRandom have to deviate from the median to some extent, but not too far. And this is not described in \"constraints\", one has to guess."
                    },
                    {
                        "username": "firezdog",
                        "content": "This isn\\'t really a question involving randomization -- more a question involving creating a map / array association and updating it properly."
                    },
                    {
                        "username": "ladnijnama",
                        "content": "can anyone please help about this test case\\ninput\\n[\"RandomizedSet\",\"insert\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"remove\",\"remove\",\"insert\",\"remove\",\"insert\",\"insert\",\"insert\",\"insert\",\"insert\",\"getRandom\",\"insert\",\"remove\",\"insert\",\"insert\"]\\n[[],[3],[-2],[2],[1],[-3],[-2],[-2],[3],[-1],[-3],[1],[-2],[-2],[-2],[1],[],[-2],[0],[-3],[1]]\\noutput\\n[null,true,true,false,true,true,false,true,true,true,true,false,FALSE,false,false,false,-2,false,false,true,false]\\nexpected\\n[null,true,true,false,true,true,false,true,true,true,true,false,TRUE,false,false,false,-2,false,false,true,false]\\n\\nwhat can be the error?\\ni think my output is correct\\nplease check \\uD83D\\uDE4F "
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If you want to find solution for java , you can follow this link: https://leetcode.com/problems/insert-delete-getrandom-o1/submissions/988219675"
                    },
                    {
                        "username": "CryptoRhinoGH",
                        "content": "After reading the comments and the solutions, I feel like I\\'m wayyy off base here. Need some help in understanding this one.... Why don\\'t you just make a list, append to it, remove from it, (you can store indices for those numbers in a dictionary or something to preserve O(1) instead of searching from index causing O(n)) and then just use random.choice to choose? Is there something wrong with that? What\\'s the reason to use HashTables and LinkedLists or Queues in this case? Can someone help me understand?"
                    },
                    {
                        "username": "Techsmart07",
                        "content": "First off, you only need a HashSet to solve this in C#\n\nCan your approach work? yes, but it would put your performance, in speed and memory, at the bottom, and you would run into risks\n\nHashSets, by virtue of what they are, inherently handle duplicates, and have O[1] lookups when validating if something exists, so instead of having to add items to a list and a dictionary (which uses a structure similar to a hashset under the hood), your insert becomes this:\n\n    public bool Insert(int val) {\n        if (myHashSet.Contains(val))\n            return false;\n        myHashSet.Add(val);\n        return true;\n    }\n\nRemoval is similar. \n    public bool Remove(int val) {\n        if (!set.Contains(val))\n            return false;\n        set.Remove(val);\n        return true;\n    }\n\nIn Addition to this, you run into an indexing risk. Say your insert order is like this\n1,10,4\nYour dictionary would be\n{{1,0}, {10,1},{4,2}}\nIf you call remove(10), you would need to\n - Find the index for 10\n - Remove 10 from the list,\n - Remove {10,1} from the dictionary\n - Update every record in your dictionary pointing to index > 1\nIf you miss this last step (which makes it O(n)), when you then call Remove(4), it will try to look for IX 2, which doesnt exist in your list anymore, throwing an exception. Each of the others carry other issues of varying weight, but all can create unnecessary bugs in your code.\n\nBy using a hashset, I was able to get performance in the >90% for speed and >80% for memory.\n"
                    },
                    {
                        "username": "yadavankit8969",
                        "content": "Why this solution is getting wronged \\n\\n```\\nclass RandomizedSet {\\npublic:\\n    set<int> s;\\n    RandomizedSet() {\\n        s.clear();\\n    }\\n    \\n    bool insert(int val) {\\n        if (s.count(val))\\n            return false;\\n        s.insert(val);\\n        return true;\\n    }\\n    \\n    bool remove(int val) {\\n        if (s.count(val)){\\n            s.erase(val);\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int getRandom() {\\n       // I am asuming, I am getting always my first value as random\\n        int t = *(s.begin());\\n        return t;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "If I understood tests correctly, they test for your random yielding the same values as theirs. So it\\'s just a \"guess which random tester uses\" game.\\n\\nHave no idea what this task is supposed to test."
                    },
                    {
                        "username": "abhiMikasa",
                        "content": "if we can return any value present in getRandom than why it gives error ;- \n\n\nHere is my code can anyone point out mistake in it :- \n\n// code \n class RandomizedSet {\n        HashMap<Integer,Integer> map;\n        List<Integer> list;\n        Random rand ;\n\n        public RandomizedSet() {\n            map = new HashMap<>();\n            list = new LinkedList<>();\n            rand = new Random();\n        }\n\n        public boolean insert(int val) {\n            if(map.containsKey(val)) return false;\n            map.put(val,list.size());\n            list.add(val);\n            return true;\n        }\n\n        public boolean remove(int val) {\n            if(!map.containsKey(val)) return false;\n            list.remove(map.get(val));\n            map.remove(val);\n            return true;\n        }\n\n        public int getRandom() {\n            return list.get(rand.nextInt(list.size()));\n        }\n    }"
                    }
                ]
            },
            {
                "id": 1796538,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1769803,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1768485,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1757001,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1750096,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1741927,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1741199,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1715813,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1700351,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1700278,
                "content": [
                    {
                        "username": "izzatullohboy007",
                        "content": "class RandomizedSet:\\n\\n    def __init__(self):\\n     self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n     \\n     if val not in self.set:\\n        self.set.append(val)\\n        return True\\n     return False\\n\\n\\n    def remove(self, val: int) -> bool:\\n     if val not in self.set:\\n        return False\\n     else:\\n        self.set.remove(val)\\n        return True\\n\\n    def getRandom(self) -> int:\\n     if len(self.set) == 0:\\n        return []\\n     return random.choice(self.set)"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "2 things. 1) You aren\\'t supposed to post answers here. 2) python\\'s set does not satisfy the requirements of this problem for random access, so you answer is wrong."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "ucancallmex",
                        "content": "Can somebody please explain me what is wrong with using set() from Python?"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "with a set you can add or remove in constant time, but random access is not O(1)."
                    },
                    {
                        "username": "Aditya_Padhy",
                        "content": "I clearly don\\'t understand about this question can you clarify me about this in my email?"
                    },
                    {
                        "username": "ozans",
                        "content": "Sorry for bothering you but I want this place better :) For some reason this case is not accepted. I believe the solution is correct. Difficulty should be focused on DS, not other criteria.\n\nUp vote for different random generated but correct solutions :)\n\n`    public int getRandom() {\n    \tif(list.size() - 1 == 0) {\n    \t\treturn list.get(0);\n    \t}\n        return list.get(random.nextInt(0, list.size() - 1));\n    }`"
                    },
                    {
                        "username": "smittyplusplus",
                        "content": "a list does not provide O(1) random access, which is a very clear requirement in the problem."
                    },
                    {
                        "username": "mu_gouda",
                        "content": "This should be ranked as Easy problem "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "akash21009",
                        "content": "In C and C++ rand() function is not random! rand() function always give some random sequence of numbers when particular program is running but when you run the program it will give same sequence again.\\nThis question demands that rand() function only hence it wont accept any other random integer generating function."
                    },
                    {
                        "username": "RunchangZ",
                        "content": "Can I use array.remove(val ) in remove  function? "
                    },
                    {
                        "username": "Yiiipu",
                        "content": "does anyone know if this is o(1) for getRandom? rdic is a hashmap:\\nind=random.randint(0,len(self.rdic)-1)\\nlist(self.rdic)[ind]"
                    },
                    {
                        "username": "00abin00",
                        "content": "Can someone point out the issue in this code. when I run it in leetcode console it is failing for one case but i checked the same thing in my local it is giving the expected output\nTestcase:-\nInput\n[\"RandomizedSet\",\"remove\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\"]\n[[],[0],[0],[0],[],[0],[0]]\nOutput\n[null,false,false,true,0,true,false]\nExpected\n[null,false,false,true,0,true,true]\n\n\n\nCode:-\n\nclass RandomizedSet {\n    Set <Integer> setR;\n\n    public RandomizedSet() {\n        setR = new TreeSet<>();\n        \n    }\n    \n    public boolean insert(int val) {\n        if(setR.contains(val)){\n        return false;\n        }else{\n            setR.add(val);\n            return true;\n        }\n    }\n    \n    public boolean remove(int val) {\n        if(setR.contains(val)){\n            return true;\n        }\n        setR.remove(val);\n        return false;\n        \n    }\n    \n    public int getRandom() {\n        Random rndm = new Random();\n        \n        List<Integer> list= new ArrayList<Integer>(setR);\n        int index=rndm.nextInt(list.size());\n        return list.get(index);\n        \n    }\n}"
                    },
                    {
                        "username": "00abin00",
                        "content": "[@akaka0039](/akaka0039) thanks bro\\n"
                    },
                    {
                        "username": "akaka0039",
                        "content": "I think your mistake is remove function\\nespecially, please check \"setR.remove(val);\"\\nwhen should you remove element in TreeSet?"
                    }
                ]
            },
            {
                "id": 1700217,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1700210,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1700195,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699871,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699860,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699721,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699600,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699540,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699535,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            },
            {
                "id": 1699451,
                "content": [
                    {
                        "username": "akaka0039",
                        "content": "Hello everyone, I need your help.\\nI\\u2019m confused that the average of my solution in Java is O(1) or not.\\nI think this average is O(1). Could you check my code and send message to me if you have any ideas?\\n\\n[My solution](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/2860689/java-solution-beginner/)\\n\\nThank you "
                    },
                    {
                        "username": "lampuiho",
                        "content": "use uniform_int_distribution not rand to avoid test error"
                    },
                    {
                        "username": "wild_knight",
                        "content": "the only purpose the word \"set\" in the description serves is to push you down the wrong lane."
                    },
                    {
                        "username": "triuzzi",
                        "content": "Python\\nMy solution use the possibility of accessing an element of a list, assuming this takes O(1) time:\\n`self.list_of_elements[index] = self.list_of_elements[-1]`\\n\\nIs this valid? I can see from other solutions that almost everyone use this approach, but doesn\\'t accessing a value of a list given the index require O(n) time?"
                    },
                    {
                        "username": "staryash25",
                        "content": "i cant get how we get methods from the given! Actually i am not understanding the input and output format\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Welp, I submitted my solution and it passed, but my getRandom() was definitely not O(1) time on average.\\n\\nPerhaps time limit constraints need to be more strict?"
                    },
                    {
                        "username": "Flankerr",
                        "content": "seems like O(N) TC also gets accepted, So i guess test case needs to be improved for this"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "I see several Java/Kotlin solutions using ArrayList without specifying an initial size. Are these solutions technically correct (i.e. O(1))? Doesn\\'t add() at some point cause array augmentation?"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "[@Minamikaze392](/Minamikaze392) Thank you! This helps clarifying things quite a bit."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "This post may be useful to you:\\nhttps://stackoverflow.com/questions/45972160/understanding-amortized-time-and-why-array-inserts-are-o1"
                    },
                    {
                        "username": "chrihop",
                        "content": "The judger is so strict that my alternative implementation uses two hash sets and randomly shift one element from one set to another does not pass. (definitely same probability for each element to be fetched)"
                    },
                    {
                        "username": "Luna-martinez",
                        "content": "import random\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        self.set = []\\n\\n    def insert(self, val: int) -> bool:\\n        self.value = val\\n        if self.value not in self.set:\\n            self.set.append(self.value)\\n            return True\\n        return True\\n\\n\\n    def remove(self, val: int) -> bool:\\n        if self.value not in self.set:\\n            return False\\n        else:\\n            self.set.remove(self.value)\\n            return True\\n\\n    def isEmpty(self):\\n        if len(self.set) == 0:\\n            return true\\n\\n    def getRandom(self) -> int:\\n        if len(self.set) == 0:\\n            return []\\n        return random.choice(self.set)\\nInput\\n[\"RandomizedSet\",\"insert\",\"remove\",\"insert\",\"getRandom\",\"remove\",\"insert\",\"getRandom\"]\\n[[],[1],[2],[2],[],[1],[2],[]]\\nOutput\\n[null,true,true,true,2,true,true,2]\\nExpected\\n[null,true,true,true,1,true,false,2]"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "dude in your remove function you are not doing self.value = val\\nsecondly why are you using self at the first place"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sliding Window Median",
        "question_content": "<p>The <strong>median</strong> is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.</p>\n\n<ul>\n\t<li>For examples, if <code>arr = [2,<u>3</u>,4]</code>, the median is <code>3</code>.</li>\n\t<li>For examples, if <code>arr = [1,<u>2,3</u>,4]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.</li>\n</ul>\n\n<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. There is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>\n\n<p>Return <em>the median array for each window in the original array</em>. Answers within <code>10<sup>-5</sup></code> of the actual value will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3\n<strong>Output:</strong> [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\n<strong>Explanation:</strong> \nWindow position                Median\n---------------                -----\n[<strong>1  3  -1</strong>] -3  5  3  6  7        1\n 1 [<strong>3  -1  -3</strong>] 5  3  6  7       -1\n 1  3 [<strong>-1  -3  5</strong>] 3  6  7       -1\n 1  3  -1 [<strong>-3  5  3</strong>] 6  7        3\n 1  3  -1  -3 [<strong>5  3  6</strong>] 7        5\n 1  3  -1  -3  5 [<strong>3  6  7</strong>]       6\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,2,3,1,4,2], k = 3\n<strong>Output:</strong> [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 96346,
                "title": "java-using-two-tree-sets-o-n-logk",
                "content": "Inspired by this [solution](https://discuss.leetcode.com/topic/27521/short-simple-java-c-python-o-log-n-o-1). to the problem: [295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)\\n\\nHowever instead of using two priority queue's we use two ```Tree Sets``` as we want ```O(logk)``` for ```remove(element)```. Priority Queue would have been ```O(k)``` for ```remove(element)``` giving us an overall time complexity of ```O(nk)``` instead of ```O(nlogk)```.\\n\\nHowever there is an issue when it comes to duplicate values so to get around this we store the ```index``` into ```nums``` in our ```Tree Set```. To break ties in our Tree Set comparator we compare the index.\\n\\n```\\npublic double[] medianSlidingWindow(int[] nums, int k) {\\n    Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;\\n    TreeSet<Integer> left = new TreeSet<>(comparator.reversed());\\n    TreeSet<Integer> right = new TreeSet<>(comparator);\\n    \\n    Supplier<Double> median = (k % 2 == 0) ?\\n        () -> ((double) nums[left.first()] + nums[right.first()]) / 2 :\\n        () -> (double) nums[right.first()];\\n    \\n    // balance lefts size and rights size (if not equal then right will be larger by one)\\n    Runnable balance = () -> { while (left.size() > right.size()) right.add(left.pollFirst()); };\\n    \\n    double[] result = new double[nums.length - k + 1];\\n    \\n    for (int i = 0; i < k; i++) left.add(i);\\n    balance.run(); result[0] = median.get();\\n    \\n    for (int i = k, r = 1; i < nums.length; i++, r++) {\\n        // remove tail of window from either left or right\\n        if(!left.remove(i - k)) right.remove(i - k);\\n\\n        // add next num, this will always increase left size\\n        right.add(i); left.add(right.pollFirst());\\n        \\n        // rebalance left and right, then get median from them\\n        balance.run(); result[r] = median.get();\\n    }\\n    \\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```Tree Sets```\n```O(logk)```\n```remove(element)```\n```O(k)```\n```remove(element)```\n```O(nk)```\n```O(nlogk)```\n```index```\n```nums```\n```Tree Set```\n```\\npublic double[] medianSlidingWindow(int[] nums, int k) {\\n    Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;\\n    TreeSet<Integer> left = new TreeSet<>(comparator.reversed());\\n    TreeSet<Integer> right = new TreeSet<>(comparator);\\n    \\n    Supplier<Double> median = (k % 2 == 0) ?\\n        () -> ((double) nums[left.first()] + nums[right.first()]) / 2 :\\n        () -> (double) nums[right.first()];\\n    \\n    // balance lefts size and rights size (if not equal then right will be larger by one)\\n    Runnable balance = () -> { while (left.size() > right.size()) right.add(left.pollFirst()); };\\n    \\n    double[] result = new double[nums.length - k + 1];\\n    \\n    for (int i = 0; i < k; i++) left.add(i);\\n    balance.run(); result[0] = median.get();\\n    \\n    for (int i = k, r = 1; i < nums.length; i++, r++) {\\n        // remove tail of window from either left or right\\n        if(!left.remove(i - k)) right.remove(i - k);\\n\\n        // add next num, this will always increase left size\\n        right.add(i); left.add(right.pollFirst());\\n        \\n        // rebalance left and right, then get median from them\\n        balance.run(); result[r] = median.get();\\n    }\\n    \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96340,
                "title": "o-n-log-k-c-using-multiset-and-updating-middle-iterator",
                "content": "Keep the window elements in a multiset and keep an iterator pointing to the middle value (to \"index\" k/2, to be precise). Thanks to [@votrubac's solution and comments](https://discuss.leetcode.com/topic/74739/c-95-ms-single-multiset-o-n-log-n).\\n\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        multiset<int> window(nums.begin(), nums.begin() + k);\\n        auto mid = next(window.begin(), k / 2);\\n        vector<double> medians;\\n        for (int i=k; ; i++) {\\n    \\n            // Push the current median.\\n            medians.push_back((double(*mid) + *prev(mid, 1 - k%2)) / 2);\\n    \\n            // If all done, return.\\n            if (i == nums.size())\\n                return medians;\\n                \\n            // Insert nums[i].\\n            window.insert(nums[i]);\\n            if (nums[i] < *mid)\\n                mid--;\\n    \\n            // Erase nums[i-k].\\n            if (nums[i-k] <= *mid)\\n                mid++;\\n            window.erase(window.lower_bound(nums[i-k]));\\n        }\\n    }",
                "solutionTags": [],
                "code": "Keep the window elements in a multiset and keep an iterator pointing to the middle value (to \"index\" k/2, to be precise). Thanks to [@votrubac's solution and comments](https://discuss.leetcode.com/topic/74739/c-95-ms-single-multiset-o-n-log-n).\\n\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        multiset<int> window(nums.begin(), nums.begin() + k);\\n        auto mid = next(window.begin(), k / 2);\\n        vector<double> medians;\\n        for (int i=k; ; i++) {\\n    \\n            // Push the current median.\\n            medians.push_back((double(*mid) + *prev(mid, 1 - k%2)) / 2);\\n    \\n            // If all done, return.\\n            if (i == nums.size())\\n                return medians;\\n                \\n            // Insert nums[i].\\n            window.insert(nums[i]);\\n            if (nums[i] < *mid)\\n                mid--;\\n    \\n            // Erase nums[i-k].\\n            if (nums[i-k] <= *mid)\\n                mid++;\\n            window.erase(window.lower_bound(nums[i-k]));\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 96352,
                "title": "never-create-max-heap-in-java-like-this",
                "content": "I spent 2 hours debugging my code because I couldn't pass the last test case:\\n```\\n[-2147483648,-2147483648,2147483647,-2147483648,1,3,-2147483648,-100,8,17,22,-2147483648,-2147483648,2147483647,2147483647,2147483647,2147483647,-2147483648,2147483647,-2147483648]\\n6\\n```\\nFinally, I found out why:\\n\\nI created my max heap like this:\\n```\\nPriorityQueue<Integer> max = new PriorityQueue<Integer>(1, new Comparator<Integer>(){\\n    @Override\\n    public int compare(Integer x, Integer y){\\n        return y-x;\\n    }\\n});\\n```\\nseems pretty standard right? I always create max heap like this in java\\n\\nIt works correctly most of the time, however, consider this case:  ```x = 1, y=-2147483648```, now ```y-x``` will cause overflow, ```y-x=2147483647``` which is the wrong result. \\n\\nDamn, I'm stupid.. ( \\u02c9 \\u2313 \\u02c9 \\u0e51)\\ufeff\\ufeff\\n\\nFor those who creates max heap like this, please don't do it again, create max heap correctly as follows:\\n```\\nPriorityQueue<Integer> max = new PriorityQueue<>(1, Collections.reverseOrder());\\n```\\nor like this:\\n```\\nPriorityQueue<Integer> max = new PriorityQueue<Integer>(1, new Comparator<Integer>(){\\n    @Override\\n    public int compare(Integer x, Integer y){\\n        return y.compareTo(x);\\n    }\\n});\\n```\\nPlease vote this if you made the same mistake as I did.",
                "solutionTags": [],
                "code": "```\\n[-2147483648,-2147483648,2147483647,-2147483648,1,3,-2147483648,-100,8,17,22,-2147483648,-2147483648,2147483647,2147483647,2147483647,2147483647,-2147483648,2147483647,-2147483648]\\n6\\n```\n```\\nPriorityQueue<Integer> max = new PriorityQueue<Integer>(1, new Comparator<Integer>(){\\n    @Override\\n    public int compare(Integer x, Integer y){\\n        return y-x;\\n    }\\n});\\n```\n```x = 1, y=-2147483648```\n```y-x```\n```y-x=2147483647```\n```\\nPriorityQueue<Integer> max = new PriorityQueue<>(1, Collections.reverseOrder());\\n```\n```\\nPriorityQueue<Integer> max = new PriorityQueue<Integer>(1, new Comparator<Integer>(){\\n    @Override\\n    public int compare(Integer x, Integer y){\\n        return y.compareTo(x);\\n    }\\n});\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3004596,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n            vector<double> medians;\\n            unordered_map<int, int> hashTable;\\n            priority_queue<int> lo;\\n            priority_queue<int, vector<int>, greater<int>> hi;\\n\\n            int i = 0;\\n\\n            while(i < k){\\n                lo.push(nums[i++]);\\n            }\\n            for(int j = 0; j < k / 2; ++j){\\n                hi.push(lo.top());\\n                lo.pop();\\n            }\\n\\n            while(true){\\n                medians.push_back(k & 1 ? lo.top() : ((double)lo.top() + (double)hi.top()) * 0.5);\\n\\n                if(i >= nums.size()) break;\\n\\n                int outNum = nums[i - k];\\n                int inNum = nums[i++];\\n                int balance = 0;\\n\\n                balance += outNum <= lo.top() ? -1 : 1;\\n                hashTable[outNum]++;\\n\\n                if(!lo.empty() && inNum <= lo.top()){\\n                    balance++;\\n                    lo.push(inNum);\\n                }\\n                else{\\n                    balance--;\\n                    hi.push(inNum);\\n                }\\n\\n                if(balance < 0){\\n                    lo.push(hi.top());\\n                    hi.pop();\\n                    balance++;\\n                }\\n                if(balance > 0){\\n                    hi.push(lo.top());\\n                    lo.pop();\\n                    balance--;\\n                }\\n\\n                while(hashTable[lo.top()]){\\n                    hashTable[lo.top()]--;\\n                    lo.pop();\\n                }\\n\\n                while(!hi.empty() && hashTable[hi.top()]){\\n                    hashTable[hi.top()]--;\\n                    hi.pop();\\n                }\\n            }\\n        return medians;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if k == 1:\\n            return nums\\n        if k == 2:\\n            return [(p + q) / 2 for p,q in pairwise(nums)]\\n        kodd = k % 2\\n        ref = sorted(nums[:k])\\n        hl = [-x for x in ref[:k//2]]\\n        hl.reverse()\\n        hr = ref[k//2:]\\n        if kodd:\\n            out = [hr[0]]\\n        else:\\n            out = [(hr[0] - hl[0]) / 2]\\n        hrd = []\\n        hld = []\\n        def cleanr():\\n            while hrd and hrd[0] == hr[0]:\\n                heappop(hrd)\\n                heappop(hr)\\n        def cleanl():\\n            while hld and hld[0] == hl[0]:\\n                heappop(hld)\\n                heappop(hl)\\n        for idx,x in enumerate(nums[k:]):\\n            y = nums[idx]\\n            mid = hr[0]\\n            if y >= mid:\\n                if x < mid:\\n                    x = -heappushpop(hl, -x)\\n                    cleanl()\\n                heappush(hr, x)\\n                heappush(hrd, y)\\n                cleanr()\\n            else:\\n                if x >= mid:\\n                    x = heappushpop(hr, x)\\n                    cleanr()\\n                heappush(hl, -x)\\n                heappush(hld, -y)\\n                cleanl()\\n            if kodd:\\n                out.append(hr[0])\\n            else:\\n                out.append((hr[0] - hl[0]) / 2)\\n        return out\\n```\\n\\n```Java []\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || nums.length == 0)\\n            return new double[0];\\n        \\n        Node root = null;\\n        for (int i = 0; i < k; i++) {\\n            root = insert(root, nums[i]);\\n        }\\n        \\n        double[] r = new double[nums.length - k + 1];\\n        boolean even = k % 2 == 0;\\n        int j = 0;\\n        for (int i = k; i <= nums.length; i++) {\\n            double sum = 0.0;\\n            if (even)\\n                sum = (findSmallest(root, k/2).val + findSmallest(root, k/2 + 1).val) / 2.0;\\n            else\\n                sum = findSmallest(root, k/2 + 1).val;\\n            r[j++] = sum;\\n            if (i < nums.length) {\\n                root = insert(root, nums[i]);\\n                root = delete(root, nums[i - k]);\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    private Node findSmallest(Node root, int k) {\\n        int s = countWith(root.left) + 1;\\n        if (s == k)\\n            return root;\\n        if (s > k) {\\n            return findSmallest(root.left, k);\\n        }\\n        return findSmallest(root.right, k - s);\\n    } \\n  \\n    private Node delete(Node root, long val) {\\n        if (root == null)\\n            return null;\\n        else if (val > root.val) \\n            root.right = delete(root.right, val);\\n        else if (val < root.val)\\n            root.left = delete(root.left, val);\\n        else {\\n            if (root.left == null)\\n                root = root.right;\\n            else if (root.right == null)\\n                root = root.left;\\n            else {\\n                Node t = findMin(root.right);\\n                root.val = t.val;\\n                root.right = delete(root.right, t.val);\\n            }\\n        }\\n        \\n        return updateNode(root);\\n    }\\n    \\n    private Node findMin(Node root) {\\n        if (root.left != null)\\n            return findMin(root.left);\\n        return root;\\n    }\\n\\n    private Node insert(Node root, long val)\\n    {\\n        if (root == null)\\n        {\\n            return new Node(val);\\n        }\\n        if (val >= root.val)\\n        {\\n            root.right = insert(root.right, val);\\n        }\\n        else\\n        {\\n            root.left = insert(root.left, val);\\n        }\\n       \\n        return updateNode(root);\\n    }\\n    \\n    private Node updateNode(Node root) {\\n        int b = balance(root); \\t\\t\\n        if (b == 2 && balance(root.left) < 0)\\n        {\\n            root.left = leftRotate(root.left);\\n            root = rightRotate(root);\\n        }\\n        else if (b == -2 && balance(root.right) > 0)\\n        {\\n            root.right = rightRotate(root.right);\\n            root = leftRotate(root);\\n        }\\n        else if (b == 2)\\n        {\\n            root = rightRotate(root);\\n        }\\n        else if (b == -2)\\n        {\\n            root = leftRotate(root);\\n        }\\n        update(root);\\n        return root;\\n    }\\n\\n    private Node leftRotate(Node n)\\n    {\\n        Node r = n.right;\\n        n.right = r.left;\\n        r.left = n;\\n        update(n);\\n        update(r);\\n        return r;\\n    }\\n\\n    private Node rightRotate(Node n)\\n    {\\n        Node l = n.left;\\n        n.left = l.right;\\n        l.right = n;\\n        update(n);\\n        update(l);\\n        return l;\\n    }\\n\\n    private int balance(Node n)\\n    {\\n        if (n==null)return 0;\\n        return height(n.left) - height(n.right);\\n    }\\n\\n    private void update(Node n)\\n    {\\n        if (n==null)return;\\n        n.height = Math.max(height(n.left), height(n.right)) + 1;\\n        n.count = n.left != null ? n.left.count + 1 : 0;\\n        n.count += n.right != null ? n.right.count + 1 : 0;\\n    }\\n\\n    private int height(Node n)\\n    {\\n        return n != null ? n.height : 0;\\n    }\\n\\n    private int countWith(Node n)\\n    {\\n        return n != null ? n.count + 1 : 0;\\n    }\\n\\n    static class Node\\n    {\\n        Node left;\\n        Node right;\\n        long val;\\n        int count;\\n        int height;\\n\\n        Node(long val)\\n        {\\n            this.val = val;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n            vector<double> medians;\\n            unordered_map<int, int> hashTable;\\n            priority_queue<int> lo;\\n            priority_queue<int, vector<int>, greater<int>> hi;\\n\\n            int i = 0;\\n\\n            while(i < k){\\n                lo.push(nums[i++]);\\n            }\\n            for(int j = 0; j < k / 2; ++j){\\n                hi.push(lo.top());\\n                lo.pop();\\n            }\\n\\n            while(true){\\n                medians.push_back(k & 1 ? lo.top() : ((double)lo.top() + (double)hi.top()) * 0.5);\\n\\n                if(i >= nums.size()) break;\\n\\n                int outNum = nums[i - k];\\n                int inNum = nums[i++];\\n                int balance = 0;\\n\\n                balance += outNum <= lo.top() ? -1 : 1;\\n                hashTable[outNum]++;\\n\\n                if(!lo.empty() && inNum <= lo.top()){\\n                    balance++;\\n                    lo.push(inNum);\\n                }\\n                else{\\n                    balance--;\\n                    hi.push(inNum);\\n                }\\n\\n                if(balance < 0){\\n                    lo.push(hi.top());\\n                    hi.pop();\\n                    balance++;\\n                }\\n                if(balance > 0){\\n                    hi.push(lo.top());\\n                    lo.pop();\\n                    balance--;\\n                }\\n\\n                while(hashTable[lo.top()]){\\n                    hashTable[lo.top()]--;\\n                    lo.pop();\\n                }\\n\\n                while(!hi.empty() && hashTable[hi.top()]){\\n                    hashTable[hi.top()]--;\\n                    hi.pop();\\n                }\\n            }\\n        return medians;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if k == 1:\\n            return nums\\n        if k == 2:\\n            return [(p + q) / 2 for p,q in pairwise(nums)]\\n        kodd = k % 2\\n        ref = sorted(nums[:k])\\n        hl = [-x for x in ref[:k//2]]\\n        hl.reverse()\\n        hr = ref[k//2:]\\n        if kodd:\\n            out = [hr[0]]\\n        else:\\n            out = [(hr[0] - hl[0]) / 2]\\n        hrd = []\\n        hld = []\\n        def cleanr():\\n            while hrd and hrd[0] == hr[0]:\\n                heappop(hrd)\\n                heappop(hr)\\n        def cleanl():\\n            while hld and hld[0] == hl[0]:\\n                heappop(hld)\\n                heappop(hl)\\n        for idx,x in enumerate(nums[k:]):\\n            y = nums[idx]\\n            mid = hr[0]\\n            if y >= mid:\\n                if x < mid:\\n                    x = -heappushpop(hl, -x)\\n                    cleanl()\\n                heappush(hr, x)\\n                heappush(hrd, y)\\n                cleanr()\\n            else:\\n                if x >= mid:\\n                    x = heappushpop(hr, x)\\n                    cleanr()\\n                heappush(hl, -x)\\n                heappush(hld, -y)\\n                cleanl()\\n            if kodd:\\n                out.append(hr[0])\\n            else:\\n                out.append((hr[0] - hl[0]) / 2)\\n        return out\\n```\n```Java []\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || nums.length == 0)\\n            return new double[0];\\n        \\n        Node root = null;\\n        for (int i = 0; i < k; i++) {\\n            root = insert(root, nums[i]);\\n        }\\n        \\n        double[] r = new double[nums.length - k + 1];\\n        boolean even = k % 2 == 0;\\n        int j = 0;\\n        for (int i = k; i <= nums.length; i++) {\\n            double sum = 0.0;\\n            if (even)\\n                sum = (findSmallest(root, k/2).val + findSmallest(root, k/2 + 1).val) / 2.0;\\n            else\\n                sum = findSmallest(root, k/2 + 1).val;\\n            r[j++] = sum;\\n            if (i < nums.length) {\\n                root = insert(root, nums[i]);\\n                root = delete(root, nums[i - k]);\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    private Node findSmallest(Node root, int k) {\\n        int s = countWith(root.left) + 1;\\n        if (s == k)\\n            return root;\\n        if (s > k) {\\n            return findSmallest(root.left, k);\\n        }\\n        return findSmallest(root.right, k - s);\\n    } \\n  \\n    private Node delete(Node root, long val) {\\n        if (root == null)\\n            return null;\\n        else if (val > root.val) \\n            root.right = delete(root.right, val);\\n        else if (val < root.val)\\n            root.left = delete(root.left, val);\\n        else {\\n            if (root.left == null)\\n                root = root.right;\\n            else if (root.right == null)\\n                root = root.left;\\n            else {\\n                Node t = findMin(root.right);\\n                root.val = t.val;\\n                root.right = delete(root.right, t.val);\\n            }\\n        }\\n        \\n        return updateNode(root);\\n    }\\n    \\n    private Node findMin(Node root) {\\n        if (root.left != null)\\n            return findMin(root.left);\\n        return root;\\n    }\\n\\n    private Node insert(Node root, long val)\\n    {\\n        if (root == null)\\n        {\\n            return new Node(val);\\n        }\\n        if (val >= root.val)\\n        {\\n            root.right = insert(root.right, val);\\n        }\\n        else\\n        {\\n            root.left = insert(root.left, val);\\n        }\\n       \\n        return updateNode(root);\\n    }\\n    \\n    private Node updateNode(Node root) {\\n        int b = balance(root); \\t\\t\\n        if (b == 2 && balance(root.left) < 0)\\n        {\\n            root.left = leftRotate(root.left);\\n            root = rightRotate(root);\\n        }\\n        else if (b == -2 && balance(root.right) > 0)\\n        {\\n            root.right = rightRotate(root.right);\\n            root = leftRotate(root);\\n        }\\n        else if (b == 2)\\n        {\\n            root = rightRotate(root);\\n        }\\n        else if (b == -2)\\n        {\\n            root = leftRotate(root);\\n        }\\n        update(root);\\n        return root;\\n    }\\n\\n    private Node leftRotate(Node n)\\n    {\\n        Node r = n.right;\\n        n.right = r.left;\\n        r.left = n;\\n        update(n);\\n        update(r);\\n        return r;\\n    }\\n\\n    private Node rightRotate(Node n)\\n    {\\n        Node l = n.left;\\n        n.left = l.right;\\n        l.right = n;\\n        update(n);\\n        update(l);\\n        return l;\\n    }\\n\\n    private int balance(Node n)\\n    {\\n        if (n==null)return 0;\\n        return height(n.left) - height(n.right);\\n    }\\n\\n    private void update(Node n)\\n    {\\n        if (n==null)return;\\n        n.height = Math.max(height(n.left), height(n.right)) + 1;\\n        n.count = n.left != null ? n.left.count + 1 : 0;\\n        n.count += n.right != null ? n.right.count + 1 : 0;\\n    }\\n\\n    private int height(Node n)\\n    {\\n        return n != null ? n.height : 0;\\n    }\\n\\n    private int countWith(Node n)\\n    {\\n        return n != null ? n.count + 1 : 0;\\n    }\\n\\n    static class Node\\n    {\\n        Node left;\\n        Node right;\\n        long val;\\n        int count;\\n        int height;\\n\\n        Node(long val)\\n        {\\n            this.val = val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262689,
                "title": "python-small-large-heaps",
                "content": "To calculate the median, we can maintain divide array into subarray equally: **small** and **large**. All elements in **small** are no larger than any element in **large**. So median would be (largest in **small** + smallest in **large**) / 2 if **small**\\'s size = **large**\\'s size. If large\\'s size = small\\'s size + 1, median is smallest in **large**.\\n\\nThus, we can use heap here to maintain **small**(max heap) and **large**(min heap) so we can fetch smallest and largest element in logarithmic time.\\n\\nWe can also maintain \"**large**\\'s size - **small**\\'s size <= 1\" and \"smallest in **large** >= largest in **small**\" by heap\\'s property: once **large**\\'s size - **small**\\'s size > 1, we pop one element from large and add it to small. And vice versa when **small**\\'s size > **large**\\'s size.\\n\\nBesides, since its a sliding window median, we need to keep track of window ends. So we will also push element\\'s index to the heap. So each element takes a form of (val, index). Since Python\\'s heapq is a min heap, so we convert small to a max heap by pushing (-val, index).\\n\\nIntially for first k elements, we push them all into **small** and then pop k/2 element from **small** and add them to **large**. \\nThen we can intialize our answer array as ```[large[0][0] if k & 1 else (large[0][0]-small[0][0])/2]``` as we discussed above.\\n\\nThen for rest iterations, each time we add a new element **x** whose index is **i+k**, and remove an old element **nums[i]** which is out of window scope. Then we calculate our median in current window as the same way before.\\nIf right end\\'s **x** is no smaller than **large[0]**, then it belongs to **large** heap. If left end\\'s **nums[i]** is no larger than **large[0]**, then it belongs to **small** heap. So we will add one to **large** while remove one from **small** and heaps\\' sizes will be unbalanced. So we will move **large[0]** to **small** to rebalance two heaps.\\nVice versa when we have to add one to **small** while remove one from **large**.\\n\\nBut we don\\'t have to hurry and remove element in each iteration. As long as **nums[i]** is neither **small[0]** nor **large[0]**, it has no effect to median calculation. So we wait later and use a while loop to remove those out-of-window **small[0]** or **large[0]** at one time. This also make whole logic clearer.\\n```\\ndef medianSlidingWindow(nums, k):\\n\\tsmall, large = [], []\\n\\tfor i, x in enumerate(nums[:k]): \\n\\t\\theapq.heappush(small, (-x,i))\\n\\tfor _ in range(k-(k>>1)): \\n\\t\\tmove(small, large)\\n\\tans = [get_med(small, large, k)]\\n\\tfor i, x in enumerate(nums[k:]):\\n\\t\\tif x >= large[0][0]:\\n\\t\\t\\theapq.heappush(large, (x, i+k))\\n\\t\\t\\tif nums[i] <= large[0][0]: \\n\\t\\t\\t\\tmove(large, small)\\n\\t\\telse:\\n\\t\\t\\theapq.heappush(small, (-x, i+k))\\n\\t\\t\\tif nums[i] >= large[0][0]: \\n\\t\\t\\t\\tmove(small, large)\\n\\t\\twhile small and small[0][1] <= i: \\n\\t\\t\\theapq.heappop(small)\\n\\t\\twhile large and large[0][1] <= i: \\n\\t\\t\\theapq.heappop(large)\\n\\t\\tans.append(get_med(small, large, k))\\n\\treturn ans\\n\\ndef move(h1, h2):\\n\\tx, i = heapq.heappop(h1)\\n\\theapq.heappush(h2, (-x, i))\\n\\t\\ndef get_med(h1, h2, k):\\n\\treturn h2[0][0] * 1. if k & 1 else (h2[0][0]-h1[0][0]) / 2.\\n```\\nSince we are using k-size heap here, the time complexity is O(nlogk) and space complexity is O(logk).",
                "solutionTags": [],
                "code": "```[large[0][0] if k & 1 else (large[0][0]-small[0][0])/2]```\n```\\ndef medianSlidingWindow(nums, k):\\n\\tsmall, large = [], []\\n\\tfor i, x in enumerate(nums[:k]): \\n\\t\\theapq.heappush(small, (-x,i))\\n\\tfor _ in range(k-(k>>1)): \\n\\t\\tmove(small, large)\\n\\tans = [get_med(small, large, k)]\\n\\tfor i, x in enumerate(nums[k:]):\\n\\t\\tif x >= large[0][0]:\\n\\t\\t\\theapq.heappush(large, (x, i+k))\\n\\t\\t\\tif nums[i] <= large[0][0]: \\n\\t\\t\\t\\tmove(large, small)\\n\\t\\telse:\\n\\t\\t\\theapq.heappush(small, (-x, i+k))\\n\\t\\t\\tif nums[i] >= large[0][0]: \\n\\t\\t\\t\\tmove(small, large)\\n\\t\\twhile small and small[0][1] <= i: \\n\\t\\t\\theapq.heappop(small)\\n\\t\\twhile large and large[0][1] <= i: \\n\\t\\t\\theapq.heappop(large)\\n\\t\\tans.append(get_med(small, large, k))\\n\\treturn ans\\n\\ndef move(h1, h2):\\n\\tx, i = heapq.heappop(h1)\\n\\theapq.heappush(h2, (-x, i))\\n\\t\\ndef get_med(h1, h2, k):\\n\\treturn h2[0][0] * 1. if k & 1 else (h2[0][0]-h1[0][0]) / 2.\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 96348,
                "title": "java-solution-using-two-priorityqueues",
                "content": "Almost the same idea of ```Find Median from Data Stream``` https://leetcode.com/problems/find-median-from-data-stream/\\n1. Use two ```Heaps``` to store numbers. ```maxHeap``` for numbers smaller than current median,  ```minHeap``` for numbers bigger than and ```equal``` to current median. A small trick I used is always make size of ```minHeap``` equal (when there are ```even``` numbers) or 1 element more (when there are ```odd``` numbers) than the size of ```maxHeap```. Then it will become very easy to calculate current median.\\n2. Keep adding number from the right side of the sliding window and remove number from left side of the sliding window. And keep adding current median to the result.\\n```\\npublic class Solution {\\n    PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(\\n        new Comparator<Integer>() {\\n            public int compare(Integer i1, Integer i2) {\\n                return i2.compareTo(i1);\\n            }\\n        }\\n    );\\n\\t\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int n = nums.length - k + 1;\\n\\tif (n <= 0) return new double[0];\\n        double[] result = new double[n];\\n        \\n        for (int i = 0; i <= nums.length; i++) {\\n            if (i >= k) {\\n        \\tresult[i - k] = getMedian();\\n        \\tremove(nums[i - k]);\\n            }\\n            if (i < nums.length) {\\n        \\tadd(nums[i]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void add(int num) {\\n\\tif (num < getMedian()) {\\n\\t    maxHeap.add(num);\\n\\t}\\n\\telse {\\n\\t    minHeap.add(num);\\n\\t}\\n\\tif (maxHeap.size() > minHeap.size()) {\\n            minHeap.add(maxHeap.poll());\\n\\t}\\n        if (minHeap.size() - maxHeap.size() > 1) {\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n\\t\\n    private void remove(int num) {\\n\\tif (num < getMedian()) {\\n\\t    maxHeap.remove(num);\\n\\t}\\n\\telse {\\n\\t    minHeap.remove(num);\\n\\t}\\n\\tif (maxHeap.size() > minHeap.size()) {\\n            minHeap.add(maxHeap.poll());\\n\\t}\\n        if (minHeap.size() - maxHeap.size() > 1) {\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n\\t\\n    private double getMedian() {\\n\\tif (maxHeap.isEmpty() && minHeap.isEmpty()) return 0;\\n\\t    \\n\\tif (maxHeap.size() == minHeap.size()) {\\n\\t    return ((double)maxHeap.peek() + (double)minHeap.peek()) / 2.0;\\n\\t}\\n\\telse {\\n            return (double)minHeap.peek();\\n\\t}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Find Median from Data Stream```\n```Heaps```\n```maxHeap```\n```minHeap```\n```equal```\n```minHeap```\n```even```\n```odd```\n```maxHeap```\n```\\npublic class Solution {\\n    PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(\\n        new Comparator<Integer>() {\\n            public int compare(Integer i1, Integer i2) {\\n                return i2.compareTo(i1);\\n            }\\n        }\\n    );\\n\\t\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int n = nums.length - k + 1;\\n\\tif (n <= 0) return new double[0];\\n        double[] result = new double[n];\\n        \\n        for (int i = 0; i <= nums.length; i++) {\\n            if (i >= k) {\\n        \\tresult[i - k] = getMedian();\\n        \\tremove(nums[i - k]);\\n            }\\n            if (i < nums.length) {\\n        \\tadd(nums[i]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void add(int num) {\\n\\tif (num < getMedian()) {\\n\\t    maxHeap.add(num);\\n\\t}\\n\\telse {\\n\\t    minHeap.add(num);\\n\\t}\\n\\tif (maxHeap.size() > minHeap.size()) {\\n            minHeap.add(maxHeap.poll());\\n\\t}\\n        if (minHeap.size() - maxHeap.size() > 1) {\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n\\t\\n    private void remove(int num) {\\n\\tif (num < getMedian()) {\\n\\t    maxHeap.remove(num);\\n\\t}\\n\\telse {\\n\\t    minHeap.remove(num);\\n\\t}\\n\\tif (maxHeap.size() > minHeap.size()) {\\n            minHeap.add(maxHeap.poll());\\n\\t}\\n        if (minHeap.size() - maxHeap.size() > 1) {\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n\\t\\n    private double getMedian() {\\n\\tif (maxHeap.isEmpty() && minHeap.isEmpty()) return 0;\\n\\t    \\n\\tif (maxHeap.size() == minHeap.size()) {\\n\\t    return ((double)maxHeap.peek() + (double)minHeap.peek()) / 2.0;\\n\\t}\\n\\telse {\\n            return (double)minHeap.peek();\\n\\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394302,
                "title": "python-clean-solution-easy-to-understand",
                "content": "I was confused by the official solution and many of the top posts. This problem shouldn\\'t be that hard! I ended up using the same template as in Question 295 and passed all tests on my first attempt. The key is using two heaps (just like 295) and keeping track of just two things - the element to include and the element to remove. Below is my Python solution:\\n```\\nimport heapq\\nfrom collections import defaultdict\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if not nums or not k:\\n            return []\\n        lo = [] # max heap\\n        hi = [] # min heap\\n        for i in range(k):\\n            if len(lo) == len(hi):\\n                heapq.heappush(hi, -heapq.heappushpop(lo, -nums[i]))\\n            else:\\n                heapq.heappush(lo, -heapq.heappushpop(hi, nums[i]))\\n        ans = [float(hi[0])] if k & 1 else [(hi[0] - lo[0]) / 2.0]\\n        to_remove = defaultdict(int)\\n        for i in range(k, len(nums)): # right bound of window\\n            heapq.heappush(lo, -heapq.heappushpop(hi, nums[i])) # always push to lo\\n            out_num = nums[i-k]\\n            if out_num > -lo[0]:\\n                heapq.heappush(hi, -heapq.heappop(lo))\\n            to_remove[out_num] += 1\\n            while lo and to_remove[-lo[0]]:\\n                to_remove[-lo[0]] -= 1\\n                heapq.heappop(lo)\\n            while to_remove[hi[0]]:\\n                to_remove[hi[0]] -= 1\\n                heapq.heappop(hi)\\n            if k % 2:\\n                ans.append(float(hi[0]))\\n            else:\\n                ans.append((hi[0] - lo[0]) / 2.0)\\n        return ans\\n```\\nA few important things to clarify:\\n1. Two heaps (lo and hi). The size of hi, as measured by the number of **valid** elements it contains, is either equal to that of lo or one greater than that of lo, depending on the value of k. (This is an invariant we enforce when we add and remove elements from lo and hi). It\\'s worth noting that by \"valid\" I mean elements **within the current window**. \\n2. Lazy removal. I used a defaultdict to_remove to keep track of elements to be removed and their occurrances, and remove them if and only if they are at the top of either heaps. \\n3. How to add and remove. The logic is extremely straightforward. When adding a new element, we always add to lo. If the element to be removed is in lo as well, great! We don\\'t need to do anything because the heap sizes do not change. However, if the element to be removed happen to be in hi, we then pop an element from lo and add it to hi. **Important: that element we pop is guaranteed be a valid element(!!) because otherwise it should have been removed during the previous iteration.**\\n4. Some may be worried that removing elements makes heaps imbalanced. That never happens! No matter how many elements are removed at the end of an iteration, they are invalid elements! The heap lo can contain all the invalid elements and much greater in size than hi, but still in perfect balance with hi. As long as lo and hi each contains half (or (half, half+1) when k is odd) of the **elements in the current window**, we say that they are balanced.",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nfrom collections import defaultdict\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if not nums or not k:\\n            return []\\n        lo = [] # max heap\\n        hi = [] # min heap\\n        for i in range(k):\\n            if len(lo) == len(hi):\\n                heapq.heappush(hi, -heapq.heappushpop(lo, -nums[i]))\\n            else:\\n                heapq.heappush(lo, -heapq.heappushpop(hi, nums[i]))\\n        ans = [float(hi[0])] if k & 1 else [(hi[0] - lo[0]) / 2.0]\\n        to_remove = defaultdict(int)\\n        for i in range(k, len(nums)): # right bound of window\\n            heapq.heappush(lo, -heapq.heappushpop(hi, nums[i])) # always push to lo\\n            out_num = nums[i-k]\\n            if out_num > -lo[0]:\\n                heapq.heappush(hi, -heapq.heappop(lo))\\n            to_remove[out_num] += 1\\n            while lo and to_remove[-lo[0]]:\\n                to_remove[-lo[0]] -= 1\\n                heapq.heappop(lo)\\n            while to_remove[hi[0]]:\\n                to_remove[hi[0]] -= 1\\n                heapq.heappop(hi)\\n            if k % 2:\\n                ans.append(float(hi[0]))\\n            else:\\n                ans.append((hi[0] - lo[0]) / 2.0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96355,
                "title": "easy-python-o-nk",
                "content": "Just keep the window as a sorted list.\\n\\n    def medianSlidingWindow(self, nums, k):\\n        window = sorted(nums[:k])\\n        medians = []\\n        for a, b in zip(nums, nums[k:] + [0]):\\n            medians.append((window[k/2] + window[~(k/2)]) / 2.)\\n            window.remove(a)\\n            bisect.insort(window, b)\\n        return medians",
                "solutionTags": [],
                "code": "Just keep the window as a sorted list.\\n\\n    def medianSlidingWindow(self, nums, k):\\n        window = sorted(nums[:k])\\n        medians = []\\n        for a, b in zip(nums, nums[k:] + [0]):\\n            medians.append((window[k/2] + window[~(k/2)]) / 2.)\\n            window.remove(a)\\n            bisect.insort(window, b)\\n        return medians",
                "codeTag": "Python3"
            },
            {
                "id": 96347,
                "title": "o-n-log-n-time-c-solution-using-two-heaps-and-a-hash-table",
                "content": "There are a few solutions using BST with worst case time complexity O(n*k), but we know k can be become large. I wanted to come up with a solution that is guaranteed to run in O(n\\\\*log(n)) time. This is in my opinion the best solution so far.\\n\\nThe idea is inspired by solutions to [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/): use two heaps to store numbers in the sliding window. However there is the issue of numbers moving out of the window, and it turns out that a hash table that records these numbers will just work (and is surprisingly neat). The recorded numbers will only be deleted when they come to the top of the heaps.\\n```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> medians;\\n        unordered_map<int, int> hash;                          // count numbers to be deleted\\n        priority_queue<int, vector<int>> bheap;                // heap on the bottom\\n        priority_queue<int, vector<int>, greater<int>> theap;  // heap on the top\\n        \\n        int i = 0;\\n        \\n        // Initialize the heaps\\n        while (i < k)  { bheap.push(nums[i++]); }\\n        for (int count = k/2; count > 0; --count) {\\n            theap.push(bheap.top()); bheap.pop();\\n        }\\n        \\n        while (true) {\\n            // Get median\\n            if (k % 2) medians.push_back(bheap.top());\\n            else medians.push_back( ((double)bheap.top() + theap.top()) / 2 );\\n            \\n            if (i == nums.size()) break;\\n            int m = nums[i-k], n = nums[i++], balance = 0;\\n            \\n            // What happens to the number m that is moving out of the window\\n            if (m <= bheap.top())  { --balance;  if (m == bheap.top()) bheap.pop(); else ++hash[m]; }\\n            else                   { ++balance;  if (m == theap.top()) theap.pop(); else ++hash[m]; }\\n            \\n            // Insert the new number n that enters the window\\n            if (!bheap.empty() && n <= bheap.top())  { ++balance; bheap.push(n); }\\n            else                                     { --balance; theap.push(n); }\\n            \\n            // Rebalance the bottom and top heaps\\n            if      (balance < 0)  { bheap.push(theap.top()); theap.pop(); }\\n            else if (balance > 0)  { theap.push(bheap.top()); bheap.pop(); }\\n            \\n            // Remove numbers that should be discarded at the top of the two heaps\\n            while (!bheap.empty() && hash[bheap.top()])  { --hash[bheap.top()]; bheap.pop(); }\\n            while (!theap.empty() && hash[theap.top()])  { --hash[theap.top()]; theap.pop(); }\\n        }\\n        \\n        return medians;\\n    }\\n};\\n```\\nSince both heaps will never have a size greater than n, the time complexity is O(n*log(n)) in the worst case.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> medians;\\n        unordered_map<int, int> hash;                          // count numbers to be deleted\\n        priority_queue<int, vector<int>> bheap;                // heap on the bottom\\n        priority_queue<int, vector<int>, greater<int>> theap;  // heap on the top\\n        \\n        int i = 0;\\n        \\n        // Initialize the heaps\\n        while (i < k)  { bheap.push(nums[i++]); }\\n        for (int count = k/2; count > 0; --count) {\\n            theap.push(bheap.top()); bheap.pop();\\n        }\\n        \\n        while (true) {\\n            // Get median\\n            if (k % 2) medians.push_back(bheap.top());\\n            else medians.push_back( ((double)bheap.top() + theap.top()) / 2 );\\n            \\n            if (i == nums.size()) break;\\n            int m = nums[i-k], n = nums[i++], balance = 0;\\n            \\n            // What happens to the number m that is moving out of the window\\n            if (m <= bheap.top())  { --balance;  if (m == bheap.top()) bheap.pop(); else ++hash[m]; }\\n            else                   { ++balance;  if (m == theap.top()) theap.pop(); else ++hash[m]; }\\n            \\n            // Insert the new number n that enters the window\\n            if (!bheap.empty() && n <= bheap.top())  { ++balance; bheap.push(n); }\\n            else                                     { --balance; theap.push(n); }\\n            \\n            // Rebalance the bottom and top heaps\\n            if      (balance < 0)  { bheap.push(theap.top()); theap.pop(); }\\n            else if (balance > 0)  { theap.push(bheap.top()); bheap.pop(); }\\n            \\n            // Remove numbers that should be discarded at the top of the two heaps\\n            while (!bheap.empty() && hash[bheap.top()])  { --hash[bheap.top()]; bheap.pop(); }\\n            while (!theap.empty() && hash[theap.top()])  { --hash[theap.top()]; theap.pop(); }\\n        }\\n        \\n        return medians;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96353,
                "title": "easy-to-understand-o-nlogk-java-solution-using-treemap",
                "content": "TreeMap is used to implement an ordered MultiSet.\\n\\nIn this problem, I use two Ordered MultiSets as Heaps. One heap maintains the lowest 1/2 of the elements, and the other heap maintains the higher 1/2 of elements.\\n \\nThis implementation is faster than the usual implementation that uses 2 PriorityQueues, because unlike PriorityQueue, TreeMap can remove arbitrary element in logarithmic time.\\n```\\npublic class Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res = new double[nums.length-k+1];\\n        TreeMap<Integer, Integer> minHeap = new TreeMap<Integer, Integer>();\\n        TreeMap<Integer, Integer> maxHeap = new TreeMap<Integer, Integer>(Collections.reverseOrder());\\n        \\n        int minHeapCap = k/2; //smaller heap when k is odd.\\n        int maxHeapCap = k - minHeapCap; \\n        \\n        for(int i=0; i< k; i++){\\n            maxHeap.put(nums[i], maxHeap.getOrDefault(nums[i], 0) + 1);\\n        }\\n        int[] minHeapSize = new int[]{0};\\n        int[] maxHeapSize = new int[]{k};\\n        for(int i=0; i< minHeapCap; i++){\\n            move1Over(maxHeap, minHeap, maxHeapSize, minHeapSize);\\n        }\\n        \\n        res[0] = getMedian(maxHeap, minHeap, maxHeapSize, minHeapSize);\\n        int resIdx = 1;\\n        \\n        for(int i=0; i< nums.length-k; i++){\\n            int addee = nums[i+k];\\n            if(addee <= maxHeap.keySet().iterator().next()){\\n                add(addee, maxHeap, maxHeapSize);\\n            } else {\\n                add(addee, minHeap, minHeapSize);\\n            }\\n            \\n            int removee = nums[i];\\n            if(removee <= maxHeap.keySet().iterator().next()){\\n                remove(removee, maxHeap, maxHeapSize);\\n            } else {\\n                remove(removee, minHeap, minHeapSize);\\n            }\\n\\n            //rebalance\\n            if(minHeapSize[0] > minHeapCap){\\n                move1Over(minHeap, maxHeap, minHeapSize, maxHeapSize);\\n            } else if(minHeapSize[0] < minHeapCap){\\n                move1Over(maxHeap, minHeap, maxHeapSize, minHeapSize);\\n            }\\n            \\n            res[resIdx] = getMedian(maxHeap, minHeap, maxHeapSize, minHeapSize);\\n            resIdx++;\\n        }\\n        return res;\\n    }\\n\\n    public double getMedian(TreeMap<Integer, Integer> bigHeap, TreeMap<Integer, Integer> smallHeap, int[] bigHeapSize, int[] smallHeapSize){\\n        return bigHeapSize[0] > smallHeapSize[0] ? (double) bigHeap.keySet().iterator().next() : ((double) bigHeap.keySet().iterator().next() + (double) smallHeap.keySet().iterator().next()) / 2.0;\\n    }\\n    \\n    //move the top element of heap1 to heap2\\n    public void move1Over(TreeMap<Integer, Integer> heap1, TreeMap<Integer, Integer> heap2, int[] heap1Size, int[] heap2Size){\\n        int peek = heap1.keySet().iterator().next();\\n        add(peek, heap2, heap2Size);\\n        remove(peek, heap1, heap1Size);\\n    }\\n    \\n    public void add(int val, TreeMap<Integer, Integer> heap, int[] heapSize){\\n        heap.put(val, heap.getOrDefault(val,0) + 1);\\n        heapSize[0]++;\\n    }\\n    \\n    public void remove(int val, TreeMap<Integer, Integer> heap, int[] heapSize){\\n        if(heap.put(val, heap.get(val) - 1) == 1) heap.remove(val);\\n        heapSize[0]--;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res = new double[nums.length-k+1];\\n        TreeMap<Integer, Integer> minHeap = new TreeMap<Integer, Integer>();\\n        TreeMap<Integer, Integer> maxHeap = new TreeMap<Integer, Integer>(Collections.reverseOrder());\\n        \\n        int minHeapCap = k/2; //smaller heap when k is odd.\\n        int maxHeapCap = k - minHeapCap; \\n        \\n        for(int i=0; i< k; i++){\\n            maxHeap.put(nums[i], maxHeap.getOrDefault(nums[i], 0) + 1);\\n        }\\n        int[] minHeapSize = new int[]{0};\\n        int[] maxHeapSize = new int[]{k};\\n        for(int i=0; i< minHeapCap; i++){\\n            move1Over(maxHeap, minHeap, maxHeapSize, minHeapSize);\\n        }\\n        \\n        res[0] = getMedian(maxHeap, minHeap, maxHeapSize, minHeapSize);\\n        int resIdx = 1;\\n        \\n        for(int i=0; i< nums.length-k; i++){\\n            int addee = nums[i+k];\\n            if(addee <= maxHeap.keySet().iterator().next()){\\n                add(addee, maxHeap, maxHeapSize);\\n            } else {\\n                add(addee, minHeap, minHeapSize);\\n            }\\n            \\n            int removee = nums[i];\\n            if(removee <= maxHeap.keySet().iterator().next()){\\n                remove(removee, maxHeap, maxHeapSize);\\n            } else {\\n                remove(removee, minHeap, minHeapSize);\\n            }\\n\\n            //rebalance\\n            if(minHeapSize[0] > minHeapCap){\\n                move1Over(minHeap, maxHeap, minHeapSize, maxHeapSize);\\n            } else if(minHeapSize[0] < minHeapCap){\\n                move1Over(maxHeap, minHeap, maxHeapSize, minHeapSize);\\n            }\\n            \\n            res[resIdx] = getMedian(maxHeap, minHeap, maxHeapSize, minHeapSize);\\n            resIdx++;\\n        }\\n        return res;\\n    }\\n\\n    public double getMedian(TreeMap<Integer, Integer> bigHeap, TreeMap<Integer, Integer> smallHeap, int[] bigHeapSize, int[] smallHeapSize){\\n        return bigHeapSize[0] > smallHeapSize[0] ? (double) bigHeap.keySet().iterator().next() : ((double) bigHeap.keySet().iterator().next() + (double) smallHeap.keySet().iterator().next()) / 2.0;\\n    }\\n    \\n    //move the top element of heap1 to heap2\\n    public void move1Over(TreeMap<Integer, Integer> heap1, TreeMap<Integer, Integer> heap2, int[] heap1Size, int[] heap2Size){\\n        int peek = heap1.keySet().iterator().next();\\n        add(peek, heap2, heap2Size);\\n        remove(peek, heap1, heap1Size);\\n    }\\n    \\n    public void add(int val, TreeMap<Integer, Integer> heap, int[] heapSize){\\n        heap.put(val, heap.getOrDefault(val,0) + 1);\\n        heapSize[0]++;\\n    }\\n    \\n    public void remove(int val, TreeMap<Integer, Integer> heap, int[] heapSize){\\n        if(heap.put(val, heap.get(val) - 1) == 1) heap.remove(val);\\n        heapSize[0]--;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806480,
                "title": "python-real-o-nlogk-solution-easy-to-understand",
                "content": "Solution 1: \\nmaitain a sorted window.  We can use binary search for remove and insert. \\nBecause insert takes O(k), the overall time complexity is O(nk).\\n\\nSolution 2: \\nsimilar with LC 295, we need to maintain two heaps in the window, leftHq and rightHq. \\nTo slide one step is actually to do two things: step 1. add a number, which is exactly the same as that in LC 295, which is O(logk)\\nstep 2. remove the number that is outside the window; there is not a remove method in heapq, so it takes O(k).  So overall the heapq solution will take O(nk).\\n\\nSolution 3: \\nuse a SortedList structure, which was implemented using self-balanced tree.  \\nSortedList enables O(logk) add and O(logk) remove.  So the total time complexity is O(nlogk).\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        lst = SortedList()    # maintain a sorted list\\n        \\n        res = []\\n        for i in range(len(nums)):\\n            lst.add(nums[i])            # O(logk)\\n            if len(lst) > k:\\n                lst.remove(nums[i-k])   # if we use heapq here, it takes O(k) here, but for sortedList, it takes O(logk)\\n            if len(lst) == k:\\n                median = lst[k//2] if k%2 == 1 else (lst[k//2-1] + lst[k//2]) / 2\\n                res.append(median)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        lst = SortedList()    # maintain a sorted list\\n        \\n        res = []\\n        for i in range(len(nums)):\\n            lst.add(nums[i])            # O(logk)\\n            if len(lst) > k:\\n                lst.remove(nums[i-k])   # if we use heapq here, it takes O(k) here, but for sortedList, it takes O(logk)\\n            if len(lst) == k:\\n                median = lst[k//2] if k%2 == 1 else (lst[k//2-1] + lst[k//2]) / 2\\n                res.append(median)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96337,
                "title": "python-sortedarray-beats-100-and-2-heap-beats-90-solution",
                "content": "\\n### Array based solution:  \\n- the window is an array maintained in sorted order\\n- the mid of the array is used to calculate the median\\n- every iteration, the incoming number is added in sorted order in the array using insert - `O(log K)` ?\\n- every iteration, the outgoing number is removed from the array using bisect `O(log K)` ?\\n\\n`O(N logK)`  beats 100%\\n```\\n# 132 ms\\nclass SolutionSortedArrayFast(object):\\n    def medianSlidingWindow(self, nums, k):\\n        win, rv = nums[:k], []\\n        win.sort()\\n        odd = k%2\\n        for i,n in enumerate(nums[k:],k):\\n            rv.append((win[k/2]+win[k/2-1])/2. if not odd else win[(k-1)/2]*1.)\\n            win.pop(bisect(win, nums[i-k])-1) # <<< bisect is faster than .remove()\\n            insort(win, nums[i])\\n        rv.append((win[k/2]+win[k/2-1])/2. if not odd else win[(k-1)/2]*1.)\\n        return rv\\n```\\n\\n### 2-heap (min, max) based solution:  \\n- uses 2 heaps left-(max)heap `lh` and right-(min)heap `rh`. The key idea is the maintain the size invariance of the heaps as we add and remove elements. The top of both the heaps can be used to calculate the median.\\n- We use `lazy-deletion` from the heap \\n- using the first `k` elements construct a min heap `lh`. Then pop `k-k/2` and add it to the `rh`. Now the heap sized are set at `k/2` and `k-k/2`\\n- Iterate over rest of the numbers and add it to the appropriate heap and maintain heap size invariance by moving the top number from one heap to another as needed.\\n\\n`O(N logK)` beats 90%\\n\\n```\\n# avg:180ms\\nclass SolutionHeap(object):\\n    def medianSlidingWindow(self, nums, k):\\n        lh,rh,rv = [],[],[]\\n        # create the initial left and right heap\\n        for i,n in enumerate(nums[:k]): heappush(lh, (-n,i))\\n        for i in range(k-k/2):\\n            heappush(rh, (-lh[0][0], lh[0][1]))\\n            heappop(lh)\\n        for i,n in enumerate(nums[k:]):\\n            rv.append(rh[0][0]/1. if k%2 else (rh[0][0] - lh[0][0])/2.)\\n            if n >= rh[0][0]:\\n                heappush(rh,(n,i+k))        # rh +1\\n                if nums[i] <= rh[0][0]:     # lh-1, unbalanced\\n                    heappush(lh, (-rh[0][0], rh[0][1]))\\n                    heappop(rh)\\n                # else: pass                # rh-1, balanced\\n            else:\\n                heappush(lh,(-n,i+k))        # rh +1\\n                if nums[i] >= rh[0][0]:     # rh-1, unbalanced\\n                    heappush(rh, (-lh[0][0], lh[0][1]))\\n                    heappop(lh)\\n                # else: pass                # lh-1, balanced\\n            while(lh and lh[0][1] <= i): heappop(lh)  # lazy-deletion\\n            while(rh and rh[0][1] <= i): heappop(rh)  # lazy-deletion\\n        rv.append(rh[0][0]/1. if k%2 else (rh[0][0] - lh[0][0])/2.)\\n        return rv\\n```",
                "solutionTags": [],
                "code": "```\\n# 132 ms\\nclass SolutionSortedArrayFast(object):\\n    def medianSlidingWindow(self, nums, k):\\n        win, rv = nums[:k], []\\n        win.sort()\\n        odd = k%2\\n        for i,n in enumerate(nums[k:],k):\\n            rv.append((win[k/2]+win[k/2-1])/2. if not odd else win[(k-1)/2]*1.)\\n            win.pop(bisect(win, nums[i-k])-1) # <<< bisect is faster than .remove()\\n            insort(win, nums[i])\\n        rv.append((win[k/2]+win[k/2-1])/2. if not odd else win[(k-1)/2]*1.)\\n        return rv\\n```\n```\\n# avg:180ms\\nclass SolutionHeap(object):\\n    def medianSlidingWindow(self, nums, k):\\n        lh,rh,rv = [],[],[]\\n        # create the initial left and right heap\\n        for i,n in enumerate(nums[:k]): heappush(lh, (-n,i))\\n        for i in range(k-k/2):\\n            heappush(rh, (-lh[0][0], lh[0][1]))\\n            heappop(lh)\\n        for i,n in enumerate(nums[k:]):\\n            rv.append(rh[0][0]/1. if k%2 else (rh[0][0] - lh[0][0])/2.)\\n            if n >= rh[0][0]:\\n                heappush(rh,(n,i+k))        # rh +1\\n                if nums[i] <= rh[0][0]:     # lh-1, unbalanced\\n                    heappush(lh, (-rh[0][0], rh[0][1]))\\n                    heappop(rh)\\n                # else: pass                # rh-1, balanced\\n            else:\\n                heappush(lh,(-n,i+k))        # rh +1\\n                if nums[i] >= rh[0][0]:     # rh-1, unbalanced\\n                    heappush(rh, (-lh[0][0], lh[0][1]))\\n                    heappop(lh)\\n                # else: pass                # lh-1, balanced\\n            while(lh and lh[0][1] <= i): heappop(lh)  # lazy-deletion\\n            while(rh and rh[0][1] <= i): heappop(rh)  # lazy-deletion\\n        rv.append(rh[0][0]/1. if k%2 else (rh[0][0] - lh[0][0])/2.)\\n        return rv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96392,
                "title": "c-95-ms-single-multiset-o-n-log-n",
                "content": "The reason to use two heaps is to have O(1) lookup for the median. It's is O(n) if we use multiset, but what if we reuse the median pointer when we can?\\nThe solution below still has the O(n^2) worst case run-time, and the average case run-time is O(n * log n). We can achieve O(n * log n) in the worst case if we make sure that the multiset comparator is stable. \\n```\\nvector<double> medianSlidingWindow(vector<int>& nums, int k)\\n{\\n    int size = nums.size(), median_pos = k - k / 2 - 1;\\n    vector<double> res(size - k + 1);\\n    multiset<int> s(nums.begin(), nums.begin() + k);\\n    auto it = next(s.begin(), median_pos);\\n\\n    for (auto i = k; i <= size; ++i)\\n    {\\n        res[i - k] = ((double)*it + (k % 2 != 0 ? *it : *next(it))) / 2;\\n        if (i < size)\\n        {\\n            // magic numbers (instead of enum) for brevity. INT_MAX means to retrace the iterator from the beginning.\\n            int repos_it = INT_MAX; \\n            if (k > 2)\\n            {\\n                // if inserted or removed item equals to the current median, we need to retrace.\\n                // we do not know which exact element will be removed/inserted, and we cannot compare multiset iterators.\\n                // otherwise, we can keep or increment/decrement the current median iterator.\\n                if ((nums[i - k] < *it && nums[i] < *it) || (nums[i - k] > *it && nums[i] > *it)) repos_it = 0;\\n                else if (nums[i - k] < *it && nums[i] > *it) repos_it = 1; // advance forward.\\n                else if (nums[i - k] > *it && nums[i] < *it) repos_it = -1; // advance backward.\\n            }\\n            s.insert(nums[i]);\\n            s.erase(s.find(nums[i - k]));\\n\\n            if (repos_it == INT_MAX) it = next(s.begin(), median_pos);\\n            else if (repos_it == 1) ++it;\\n            else if (repos_it == -1) --it;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<double> medianSlidingWindow(vector<int>& nums, int k)\\n{\\n    int size = nums.size(), median_pos = k - k / 2 - 1;\\n    vector<double> res(size - k + 1);\\n    multiset<int> s(nums.begin(), nums.begin() + k);\\n    auto it = next(s.begin(), median_pos);\\n\\n    for (auto i = k; i <= size; ++i)\\n    {\\n        res[i - k] = ((double)*it + (k % 2 != 0 ? *it : *next(it))) / 2;\\n        if (i < size)\\n        {\\n            // magic numbers (instead of enum) for brevity. INT_MAX means to retrace the iterator from the beginning.\\n            int repos_it = INT_MAX; \\n            if (k > 2)\\n            {\\n                // if inserted or removed item equals to the current median, we need to retrace.\\n                // we do not know which exact element will be removed/inserted, and we cannot compare multiset iterators.\\n                // otherwise, we can keep or increment/decrement the current median iterator.\\n                if ((nums[i - k] < *it && nums[i] < *it) || (nums[i - k] > *it && nums[i] > *it)) repos_it = 0;\\n                else if (nums[i - k] < *it && nums[i] > *it) repos_it = 1; // advance forward.\\n                else if (nums[i - k] > *it && nums[i] < *it) repos_it = -1; // advance backward.\\n            }\\n            s.insert(nums[i]);\\n            s.erase(s.find(nums[i - k]));\\n\\n            if (repos_it == INT_MAX) it = next(s.begin(), median_pos);\\n            else if (repos_it == 1) ++it;\\n            else if (repos_it == -1) --it;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 868749,
                "title": "easiest-solution-using-only-vector-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        \\n        vector<double> res;\\n        vector<long long> med;\\n        \\n        for(int i= 0; i<k; i++)\\n            med.insert(lower_bound(med.begin(),med.end(),nums[i]),nums[i]);\\n        if(k%2==0)\\n            res.push_back((double)(med[k/2]+med[k/2-1])/2 );\\n        else\\n            res.push_back((double)med[k/2]);\\n        \\n        \\n        for(int i=k; i<nums.size(); i++)\\n        {\\n            med.erase(lower_bound(med.begin(),med.end(),nums[i-k]));\\n            med.insert(lower_bound(med.begin(),med.end(),nums[i]),nums[i]);\\n            if(k%2==0)\\n                res.push_back((double)(med[k/2]+med[k/2-1])/2 );\\n            else\\n                res.push_back((double)med[k/2]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        \\n        vector<double> res;\\n        vector<long long> med;\\n        \\n        for(int i= 0; i<k; i++)\\n            med.insert(lower_bound(med.begin(),med.end(),nums[i]),nums[i]);\\n        if(k%2==0)\\n            res.push_back((double)(med[k/2]+med[k/2-1])/2 );\\n        else\\n            res.push_back((double)med[k/2]);\\n        \\n        \\n        for(int i=k; i<nums.size(); i++)\\n        {\\n            med.erase(lower_bound(med.begin(),med.end(),nums[i-k]));\\n            med.insert(lower_bound(med.begin(),med.end(),nums[i]),nums[i]);\\n            if(k%2==0)\\n                res.push_back((double)(med[k/2]+med[k/2-1])/2 );\\n            else\\n                res.push_back((double)med[k/2]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507981,
                "title": "java-tc-o-n-logk-sc-k-optimized-sliding-window-using-treeset",
                "content": "**In following solution we are using TreeSet. Here, the remove operation in Java is most optimized**\\n```java\\n/**\\n * Using TreeSet. (Here time complexity is most optimized)\\n *\\n * Very similar to https://leetcode.com/problems/find-median-from-data-stream/\\n *\\n * Time Complexity: O((N-K)*log K + N*log K) = O(N * log K)\\n * Add Elements = O(N*Log K)\\n * Remove Elements = O((N-K)*log K) ==> TreeSet.remove() in JAVA is O(log K)\\n *\\n * Space Complexity: O(K)\\n *\\n * N = Length of nums array. K = Input k.\\n */\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        double[] result = new double[len - k + 1];\\n        if (k == 1) {\\n            for (int i = 0; i < len; i++) {\\n                result[i] = (double) nums[i];\\n            }\\n            return result;\\n            // return Arrays.stream(nums).asDoubleStream().toArray();\\n        }\\n\\n        Comparator<Integer> comparator = (a, b) -> (nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : Integer.compare(a, b));\\n        TreeSet<Integer> smallNums = new TreeSet<>(comparator.reversed());\\n        TreeSet<Integer> largeNums = new TreeSet<>(comparator);\\n\\n        for (int i = 0; i < len; i++) {\\n            if (i >= k) {\\n                removeElement(smallNums, largeNums, nums, i - k);\\n            }\\n            addElement(smallNums, largeNums, i);\\n            if (i >= k - 1) {\\n                result[i - (k - 1)] = getMedian(smallNums, largeNums, nums);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void addElement(TreeSet<Integer> smallNums, TreeSet<Integer> largeNums, int idx) {\\n        smallNums.add(idx);\\n        largeNums.add(smallNums.pollFirst());\\n        if (smallNums.size() < largeNums.size()) {\\n            smallNums.add(largeNums.pollFirst());\\n        }\\n    }\\n\\n    private void removeElement(TreeSet<Integer> smallNums, TreeSet<Integer> largeNums, int[] nums, int idx) {\\n        if (largeNums.contains(idx)) {\\n            largeNums.remove(idx);\\n            if (smallNums.size() == largeNums.size() + 2) {\\n                largeNums.add(smallNums.pollFirst());\\n            }\\n        } else {\\n            smallNums.remove(idx);\\n            if (smallNums.size() < largeNums.size()) {\\n                smallNums.add(largeNums.pollFirst());\\n            }\\n        }\\n    }\\n\\n    private double getMedian(TreeSet<Integer> smallNums, TreeSet<Integer> largeNums, int[] nums) {\\n        if (smallNums.size() == largeNums.size()) {\\n            return ((double) nums[smallNums.first()] + nums[largeNums.first()]) / 2;\\n        }\\n        return nums[smallNums.first()];\\n    }\\n}\\n```\\n\\n----\\n**In following solution we are using Priority Queue (heap). Here, the remove operation in Java is not optimized**\\n\\n```java\\n/**\\n * Using Priority Queue. (Here time complexity is not optimized)\\n *\\n * Very similar to https://leetcode.com/problems/find-median-from-data-stream/\\n *\\n * Time Complexity: O((N-K)*K + N*log K).\\n * Add Elements = O(N*Log K)\\n * Remove Elements = O((N-K)*K) ==> PQ.remove() in JAVA is O(K)\\n *\\n * Space Complexity: O(K)\\n *\\n * N = Length of nums array. K = Input k.\\n */\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        double[] result = new double[len - k + 1];\\n        if (k == 1) {\\n            for (int i = 0; i < len; i++) {\\n                result[i] = (double) nums[i];\\n            }\\n            return result;\\n            // return Arrays.stream(nums).asDoubleStream().toArray();\\n        }\\n\\n        // MaxHeap\\n        PriorityQueue<Integer> smallNums = new PriorityQueue<>(Collections.reverseOrder());\\n        // Min Heap\\n        PriorityQueue<Integer> largeNums = new PriorityQueue<>();\\n\\n        for (int i = 0; i < len; i++) {\\n            if (i >= k) {\\n                removeElement(smallNums, largeNums, nums[i - k]);\\n            }\\n            addElement(smallNums, largeNums, nums[i]);\\n            if (i >= k - 1) {\\n                result[i - (k - 1)] = getMedian(smallNums, largeNums);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void addElement(PriorityQueue<Integer> smallNums, PriorityQueue<Integer> largeNums, int n) {\\n        smallNums.offer(n);\\n        largeNums.offer(smallNums.poll());\\n        if (smallNums.size() < largeNums.size()) {\\n            smallNums.offer(largeNums.poll());\\n        }\\n    }\\n\\n    private void removeElement(PriorityQueue<Integer> smallNums, PriorityQueue<Integer> largeNums, int n) {\\n        if (n >= largeNums.peek()) {\\n            largeNums.remove(n);\\n            if (smallNums.size() == largeNums.size() + 2) {\\n                largeNums.offer(smallNums.poll());\\n            }\\n        } else {\\n            smallNums.remove(n);\\n            if (smallNums.size() < largeNums.size()) {\\n                smallNums.offer(largeNums.poll());\\n            }\\n        }\\n    }\\n\\n    private double getMedian(PriorityQueue<Integer> smallNums, PriorityQueue<Integer> largeNums) {\\n        if (smallNums.size() == largeNums.size()) {\\n            return ((double) smallNums.peek() + largeNums.peek()) / 2.0;\\n        }\\n        return smallNums.peek();\\n    }\\n}\\n```\\n\\n\\n---\\n\\nSolutions to other Sliding Window questions on LeetCode:\\n- [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/1496754/Java-or-TC:-O(S+T)-or-SC:-O(T)-or-Space-optimized-Sliding-Window-using-Two-Pointers)\\n- [340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/1496838/Java-or-TC:-O(N)-or-SC:-O(K)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/1496840/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/1500039/Java-or-TC:-O(S+P)-or-SC:-O(1)-or-Sliding-window-solution)\\n- [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1500874/Java-or-TC:-O(N)-or-SC:-O(1)-or-Sliding-Window-using-HashMap-and-Two-Pointers)\\n- [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/1500877/Java-or-Both-O(N)-and-O(N-logN)-solutions-with-O(1)-space-or-Sliding-Window-and-Binary-Search-solutions)\\n- [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/1500887/Java-or-TC:-O(N)-or-SC:-O(min(N-K))-or-Sliding-Window-using-HashSet)\\n- [220. Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/discuss/1500895/Java-or-TC:-O(N)-or-SC:-O(min(NK))-or-Sliding-Window-using-Buckets)\\n- [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/discuss/1500902/Java-or-TC:-O(S2)-or-SC:-O(1)-or-Constant-space-Sliding-Window-solution)\\n- [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/discuss/1506048/Java-or-TC:-O(N)-or-SC:-O(K)-or-Using-Deque-as-Sliding-Window)\\n- [487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/discuss/1508045/Java-or-TC:-O(N)-or-SC:-O(1)-or-Four-solutions-with-Follow-up-handled)\\n- [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1508044/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Optimized-Sliding-Window)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Sliding Window",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```java\\n/**\\n * Using TreeSet. (Here time complexity is most optimized)\\n *\\n * Very similar to https://leetcode.com/problems/find-median-from-data-stream/\\n *\\n * Time Complexity: O((N-K)*log K + N*log K) = O(N * log K)\\n * Add Elements = O(N*Log K)\\n * Remove Elements = O((N-K)*log K) ==> TreeSet.remove() in JAVA is O(log K)\\n *\\n * Space Complexity: O(K)\\n *\\n * N = Length of nums array. K = Input k.\\n */\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        double[] result = new double[len - k + 1];\\n        if (k == 1) {\\n            for (int i = 0; i < len; i++) {\\n                result[i] = (double) nums[i];\\n            }\\n            return result;\\n            // return Arrays.stream(nums).asDoubleStream().toArray();\\n        }\\n\\n        Comparator<Integer> comparator = (a, b) -> (nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : Integer.compare(a, b));\\n        TreeSet<Integer> smallNums = new TreeSet<>(comparator.reversed());\\n        TreeSet<Integer> largeNums = new TreeSet<>(comparator);\\n\\n        for (int i = 0; i < len; i++) {\\n            if (i >= k) {\\n                removeElement(smallNums, largeNums, nums, i - k);\\n            }\\n            addElement(smallNums, largeNums, i);\\n            if (i >= k - 1) {\\n                result[i - (k - 1)] = getMedian(smallNums, largeNums, nums);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void addElement(TreeSet<Integer> smallNums, TreeSet<Integer> largeNums, int idx) {\\n        smallNums.add(idx);\\n        largeNums.add(smallNums.pollFirst());\\n        if (smallNums.size() < largeNums.size()) {\\n            smallNums.add(largeNums.pollFirst());\\n        }\\n    }\\n\\n    private void removeElement(TreeSet<Integer> smallNums, TreeSet<Integer> largeNums, int[] nums, int idx) {\\n        if (largeNums.contains(idx)) {\\n            largeNums.remove(idx);\\n            if (smallNums.size() == largeNums.size() + 2) {\\n                largeNums.add(smallNums.pollFirst());\\n            }\\n        } else {\\n            smallNums.remove(idx);\\n            if (smallNums.size() < largeNums.size()) {\\n                smallNums.add(largeNums.pollFirst());\\n            }\\n        }\\n    }\\n\\n    private double getMedian(TreeSet<Integer> smallNums, TreeSet<Integer> largeNums, int[] nums) {\\n        if (smallNums.size() == largeNums.size()) {\\n            return ((double) nums[smallNums.first()] + nums[largeNums.first()]) / 2;\\n        }\\n        return nums[smallNums.first()];\\n    }\\n}\\n```\n```java\\n/**\\n * Using Priority Queue. (Here time complexity is not optimized)\\n *\\n * Very similar to https://leetcode.com/problems/find-median-from-data-stream/\\n *\\n * Time Complexity: O((N-K)*K + N*log K).\\n * Add Elements = O(N*Log K)\\n * Remove Elements = O((N-K)*K) ==> PQ.remove() in JAVA is O(K)\\n *\\n * Space Complexity: O(K)\\n *\\n * N = Length of nums array. K = Input k.\\n */\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || k <= 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        double[] result = new double[len - k + 1];\\n        if (k == 1) {\\n            for (int i = 0; i < len; i++) {\\n                result[i] = (double) nums[i];\\n            }\\n            return result;\\n            // return Arrays.stream(nums).asDoubleStream().toArray();\\n        }\\n\\n        // MaxHeap\\n        PriorityQueue<Integer> smallNums = new PriorityQueue<>(Collections.reverseOrder());\\n        // Min Heap\\n        PriorityQueue<Integer> largeNums = new PriorityQueue<>();\\n\\n        for (int i = 0; i < len; i++) {\\n            if (i >= k) {\\n                removeElement(smallNums, largeNums, nums[i - k]);\\n            }\\n            addElement(smallNums, largeNums, nums[i]);\\n            if (i >= k - 1) {\\n                result[i - (k - 1)] = getMedian(smallNums, largeNums);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private void addElement(PriorityQueue<Integer> smallNums, PriorityQueue<Integer> largeNums, int n) {\\n        smallNums.offer(n);\\n        largeNums.offer(smallNums.poll());\\n        if (smallNums.size() < largeNums.size()) {\\n            smallNums.offer(largeNums.poll());\\n        }\\n    }\\n\\n    private void removeElement(PriorityQueue<Integer> smallNums, PriorityQueue<Integer> largeNums, int n) {\\n        if (n >= largeNums.peek()) {\\n            largeNums.remove(n);\\n            if (smallNums.size() == largeNums.size() + 2) {\\n                largeNums.offer(smallNums.poll());\\n            }\\n        } else {\\n            smallNums.remove(n);\\n            if (smallNums.size() < largeNums.size()) {\\n                smallNums.offer(largeNums.poll());\\n            }\\n        }\\n    }\\n\\n    private double getMedian(PriorityQueue<Integer> smallNums, PriorityQueue<Integer> largeNums) {\\n        if (smallNums.size() == largeNums.size()) {\\n            return ((double) smallNums.peek() + largeNums.peek()) / 2.0;\\n        }\\n        return smallNums.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158561,
                "title": "easy-to-understand-java-solution-using-2-priority-queues",
                "content": "```\\nclass Solution {\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        MeanQueue queue = new MeanQueue();\\n        double[] result = new double[nums.length - k + 1];\\n        int index = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            queue.offer(nums[i]);\\n            if(queue.size() == k){\\n                result[index++] = queue.getMedian();\\n                queue.remove(nums[i+1 - k]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    class MeanQueue{\\n        PriorityQueue<Integer> max = new PriorityQueue<Integer>(Collections.reverseOrder());  //max is a Max-heap stores smaller half of nums\\n        PriorityQueue<Integer> min = new PriorityQueue<Integer>(); // min is a Min-heap stores larger half of nums\\n    \\n        // Adds a number into the data structure\\n        void offer(int num){\\n            max.offer(num);             // Add number\\n            min.offer(max.poll());      // Balancing step\\n            \\n            if(max.size() < min.size()){ // maintain size property\\n                max.offer(min.poll());\\n            }\\n        }\\n        \\n        double getMedian(){\\n            return max.size() > min.size() ? max.peek() : ((long)max.peek() + min.peek()) * 0.5;\\n        }\\n        \\n        int size(){\\n            return max.size() + min.size();\\n        }\\n        \\n        boolean remove(int x){\\n            return max.remove(x) || min.remove(x);\\n        }\\n     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        MeanQueue queue = new MeanQueue();\\n        double[] result = new double[nums.length - k + 1];\\n        int index = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            queue.offer(nums[i]);\\n            if(queue.size() == k){\\n                result[index++] = queue.getMedian();\\n                queue.remove(nums[i+1 - k]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    class MeanQueue{\\n        PriorityQueue<Integer> max = new PriorityQueue<Integer>(Collections.reverseOrder());  //max is a Max-heap stores smaller half of nums\\n        PriorityQueue<Integer> min = new PriorityQueue<Integer>(); // min is a Min-heap stores larger half of nums\\n    \\n        // Adds a number into the data structure\\n        void offer(int num){\\n            max.offer(num);             // Add number\\n            min.offer(max.poll());      // Balancing step\\n            \\n            if(max.size() < min.size()){ // maintain size property\\n                max.offer(min.poll());\\n            }\\n        }\\n        \\n        double getMedian(){\\n            return max.size() > min.size() ? max.peek() : ((long)max.peek() + min.peek()) * 0.5;\\n        }\\n        \\n        int size(){\\n            return max.size() + min.size();\\n        }\\n        \\n        boolean remove(int x){\\n            return max.remove(x) || min.remove(x);\\n        }\\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942580,
                "title": "easiest-python-o-n-log-k-two-heaps-lazy-removal-96-23",
                "content": "How to understand this solution:\\n1) After we build our window, the length of window will ALWAYS be the same (now we will keep the length of valid elements in max_heap and min_heap the same too)\\n2) Based on this, when we slide our window, the balance variable can be equal to 0, 2 or -2. It will NEVER be -1 or 1.\\nExamples:\\n0 -> when we remove an element from max_heap and then add a new one back to max_heap (or the same for min_heap)\\n-2 -> when we remove an element from max_heap and then add a new one to min_heap (max_heap will have two less elements)\\n2 -> when we remove an element from min_heap and then add a new one to max_heap (min_heap will have two less elements)\\n3) Based on this - it is enough for us to move 1 element from one heap to another when the balance variable is equal to 2 or -2\\n\\nIf some points are not clear - Approach 2 in leetcode solutions should help. Best Regards!\\n```\\nclass Solution:\\n    # TC - O((n - k)*log(k))\\n    # SC - O(k)\\n\\t# 121 ms, faster than 96.23%\\n\\n    def find_median(self, max_heap, min_heap, heap_size):\\n        if heap_size % 2 == 1:\\n            return -max_heap[0]\\n        else:\\n            return (-max_heap[0] + min_heap[0]) / 2\\n\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        max_heap = []\\n        min_heap = []\\n        heap_dict = defaultdict(int)\\n        result = []\\n        \\n        for i in range(k):\\n            heappush(max_heap, -nums[i])\\n            heappush(min_heap, -heappop(max_heap))\\n            if len(min_heap) > len(max_heap):\\n                heappush(max_heap, -heappop(min_heap))\\n        \\n        median = self.find_median(max_heap, min_heap, k)\\n        result.append(median)\\n        \\n        for i in range(k, len(nums)):\\n            prev_num = nums[i - k]\\n            heap_dict[prev_num] += 1\\n\\n            balance = -1 if prev_num <= median else 1\\n            \\n            if nums[i] <= median:\\n                balance += 1\\n                heappush(max_heap, -nums[i])\\n            else:\\n                balance -= 1\\n                heappush(min_heap, nums[i])\\n            \\n            if balance < 0:\\n                heappush(max_heap, -heappop(min_heap))\\n            elif balance > 0:\\n                heappush(min_heap, -heappop(max_heap))\\n\\n            while max_heap and heap_dict[-max_heap[0]] > 0:\\n                heap_dict[-max_heap[0]] -= 1\\n                heappop(max_heap)\\n            \\n            while min_heap and heap_dict[min_heap[0]] > 0:\\n                heap_dict[min_heap[0]] -= 1\\n                heappop(min_heap)\\n\\n            median = self.find_median(max_heap, min_heap, k)\\n            result.append(median)\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    # TC - O((n - k)*log(k))\\n    # SC - O(k)\\n\\t# 121 ms, faster than 96.23%\\n\\n    def find_median(self, max_heap, min_heap, heap_size):\\n        if heap_size % 2 == 1:\\n            return -max_heap[0]\\n        else:\\n            return (-max_heap[0] + min_heap[0]) / 2\\n\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        max_heap = []\\n        min_heap = []\\n        heap_dict = defaultdict(int)\\n        result = []\\n        \\n        for i in range(k):\\n            heappush(max_heap, -nums[i])\\n            heappush(min_heap, -heappop(max_heap))\\n            if len(min_heap) > len(max_heap):\\n                heappush(max_heap, -heappop(min_heap))\\n        \\n        median = self.find_median(max_heap, min_heap, k)\\n        result.append(median)\\n        \\n        for i in range(k, len(nums)):\\n            prev_num = nums[i - k]\\n            heap_dict[prev_num] += 1\\n\\n            balance = -1 if prev_num <= median else 1\\n            \\n            if nums[i] <= median:\\n                balance += 1\\n                heappush(max_heap, -nums[i])\\n            else:\\n                balance -= 1\\n                heappush(min_heap, nums[i])\\n            \\n            if balance < 0:\\n                heappush(max_heap, -heappop(min_heap))\\n            elif balance > 0:\\n                heappush(min_heap, -heappop(max_heap))\\n\\n            while max_heap and heap_dict[-max_heap[0]] > 0:\\n                heap_dict[-max_heap[0]] -= 1\\n                heappop(max_heap)\\n            \\n            while min_heap and heap_dict[min_heap[0]] > 0:\\n                heap_dict[min_heap[0]] -= 1\\n                heappop(min_heap)\\n\\n            median = self.find_median(max_heap, min_heap, k)\\n            result.append(median)\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364984,
                "title": "c-simple-code-using-multiset-shorter-replicable-for-interviews",
                "content": "The idea can be borrowed from https://leetcode.com/problems/find-median-from-data-stream/ i.e. using a max-heap and min-heap for the left and right halves of the window elements. \\n\\nHowever, we also want efficient insertion and deletion from the heaps, so instead of priority queue we can use set in C++ to store sorted values with O(logn) insert/find/delete. Now, if we can insert and balance the heaps as in the solution to the linked problem, the only thing that is different is to add a deletion of the old element before adding the new element from the window. \\n\\nTo make the code easier to read, I convert insert, balance and median finding into separate functions. Since elements can be repeated, multiset can be used, and because this question has edge cases using INT_MAX, double is used instead of int to avoid overflow. \\n\\n```\\n    void insert(multiset<double,greater<double>> &left, multiset<double> &right, int num)\\n    {\\n            if(left.empty() || num < *left.begin())\\n            {\\n                left.insert(num);\\n            }\\n            else\\n            {\\n                right.insert(num);\\n            }\\n    }\\n    \\n    void balance(multiset<double,greater<double>> &left, multiset<double> &right)\\n    {\\n            if(left.size() + 1 < right.size())\\n            {\\n                left.insert(*right.begin());\\n                right.erase(right.begin());\\n            }\\n            else if(right.size() + 1 < left.size())\\n            {\\n                right.insert(*left.begin());\\n                left.erase(left.begin());\\n            }\\n    }\\n    \\n    void add_median(multiset<double,greater<double>> &left, multiset<double> &right, vector<double> &median)\\n    {\\n        if(right.size() == left.size())\\n        {\\n            median.push_back((*left.begin() + *right.begin())/2.0);\\n        }\\n        else if(right.size() > left.size())\\n        {\\n            median.push_back(*right.begin());\\n        }\\n        else\\n        {\\n            median.push_back(*left.begin());\\n        }\\n        \\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        multiset<double> right;\\n        multiset<double,greater<double>> left;\\n        \\n        vector<double> median;\\n        \\n        for(int i = 0; i<k; i++)\\n        {\\n            insert(left,right,nums[i]);\\n            balance(left,right);\\n        }\\n        \\n        add_median(left,right,median);\\n\\n        for(int i = k; i<nums.size(); i++)\\n        {\\n            auto lcheck = left.find(nums[i-k]);\\n            auto rcheck = right.find(nums[i-k]);\\n            \\n            if(lcheck != left.end())\\n            {\\n                left.erase(lcheck);\\n            }\\n            else\\n            {\\n                right.erase(rcheck);\\n            }\\n        \\n            balance(left,right);\\n            insert(left,right,nums[i]);\\n            balance(left,right);\\n            add_median(left,right,median);\\n    \\n        }\\n    \\n        return median;\\n    }\\n```\\n\\nSince all the operations are O(logk) where k is the window size, and we have to do the same for n elements, the time complexity is O(nlogk).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    void insert(multiset<double,greater<double>> &left, multiset<double> &right, int num)\\n    {\\n            if(left.empty() || num < *left.begin())\\n            {\\n                left.insert(num);\\n            }\\n            else\\n            {\\n                right.insert(num);\\n            }\\n    }\\n    \\n    void balance(multiset<double,greater<double>> &left, multiset<double> &right)\\n    {\\n            if(left.size() + 1 < right.size())\\n            {\\n                left.insert(*right.begin());\\n                right.erase(right.begin());\\n            }\\n            else if(right.size() + 1 < left.size())\\n            {\\n                right.insert(*left.begin());\\n                left.erase(left.begin());\\n            }\\n    }\\n    \\n    void add_median(multiset<double,greater<double>> &left, multiset<double> &right, vector<double> &median)\\n    {\\n        if(right.size() == left.size())\\n        {\\n            median.push_back((*left.begin() + *right.begin())/2.0);\\n        }\\n        else if(right.size() > left.size())\\n        {\\n            median.push_back(*right.begin());\\n        }\\n        else\\n        {\\n            median.push_back(*left.begin());\\n        }\\n        \\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        multiset<double> right;\\n        multiset<double,greater<double>> left;\\n        \\n        vector<double> median;\\n        \\n        for(int i = 0; i<k; i++)\\n        {\\n            insert(left,right,nums[i]);\\n            balance(left,right);\\n        }\\n        \\n        add_median(left,right,median);\\n\\n        for(int i = k; i<nums.size(); i++)\\n        {\\n            auto lcheck = left.find(nums[i-k]);\\n            auto rcheck = right.find(nums[i-k]);\\n            \\n            if(lcheck != left.end())\\n            {\\n                left.erase(lcheck);\\n            }\\n            else\\n            {\\n                right.erase(rcheck);\\n            }\\n        \\n            balance(left,right);\\n            insert(left,right,nums[i]);\\n            balance(left,right);\\n            add_median(left,right,median);\\n    \\n        }\\n    \\n        return median;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96339,
                "title": "java-clean-and-easily-readable-solution-with-a-helper-class",
                "content": "```\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        MedianQueue window = new MedianQueue();\\n        double[] median = new double[nums.length - k + 1]; \\n        for (int i = 0; i < nums.length; i++) {\\n            window.add(nums[i]);\\n            if (i >= k) window.remove(nums[i - k]);\\n            if (i >= k - 1) median[i - k + 1] = window.median();\\n        }   \\n        return median;\\n    }   \\n\\n    static class MedianQueue {\\n        Queue<Long> maxHeap = new PriorityQueue<>(Collections.reverseOrder()), minHeap = new PriorityQueue<>();\\n\\n        public void add(long n) {\\n            maxHeap.add(n);\\n            minHeap.add(maxHeap.poll());\\n        }   \\n\\n        public double median() {\\n            while (maxHeap.size() - minHeap.size() >= 2) minHeap.offer(maxHeap.poll());\\n            while (minHeap.size() - maxHeap.size() >= 1) maxHeap.offer(minHeap.poll());\\n            return maxHeap.size() == minHeap.size() ? (maxHeap.peek() + minHeap.peek()) / 2.0 : maxHeap.peek();\\n        }   \\n\\n        public boolean remove(long n) {\\n            return maxHeap.remove(n) || minHeap.remove(n);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        MedianQueue window = new MedianQueue();\\n        double[] median = new double[nums.length - k + 1]; \\n        for (int i = 0; i < nums.length; i++) {\\n            window.add(nums[i]);\\n            if (i >= k) window.remove(nums[i - k]);\\n            if (i >= k - 1) median[i - k + 1] = window.median();\\n        }   \\n        return median;\\n    }   \\n\\n    static class MedianQueue {\\n        Queue<Long> maxHeap = new PriorityQueue<>(Collections.reverseOrder()), minHeap = new PriorityQueue<>();\\n\\n        public void add(long n) {\\n            maxHeap.add(n);\\n            minHeap.add(maxHeap.poll());\\n        }   \\n\\n        public double median() {\\n            while (maxHeap.size() - minHeap.size() >= 2) minHeap.offer(maxHeap.poll());\\n            while (minHeap.size() - maxHeap.size() >= 1) maxHeap.offer(minHeap.poll());\\n            return maxHeap.size() == minHeap.size() ? (maxHeap.peek() + minHeap.peek()) / 2.0 : maxHeap.peek();\\n        }   \\n\\n        public boolean remove(long n) {\\n            return maxHeap.remove(n) || minHeap.remove(n);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96351,
                "title": "short-and-clear-o-nlogk-java-solutions",
                "content": "**Use 2 priorityQueues:**\\n3 steps: remove out-of-bound element, add new element and keep small.peek()<=big.peek(), and get median. \\nTime: O(nk). The drawback is remove function of priorityQueue takes O(k) time. \\n```\\npublic class Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res = new double[nums.length - k + 1];\\n        int idx = 0;\\n        boolean useBoth = k % 2 == 0;\\n        PriorityQueue<Integer> small = new PriorityQueue<>((a, b)->{return (int)((double)b-a);});\\n        PriorityQueue<Integer> big = new PriorityQueue<>();\\n        for(int i = 0; i<nums.length; i++){\\n            if(small.size() + big.size()==k){\\n                Integer toRemove = new Integer(nums[i-k]);\\n                if(toRemove <= small.peek()) small.remove(toRemove);\\n                else big.remove(toRemove);\\n            }\\n            //always keep small.size() == big.size() or small.size() == big.size()+1\\n            if(small.size()<=big.size()) small.add(nums[i]);\\n            else big.add(nums[i]);\\n            if(big.size()>0){\\n                while(small.peek()>big.peek()){\\n                    big.add(small.poll());\\n                    small.add(big.poll());\\n                }\\n            }\\n            if(small.size() + big.size()==k){\\n                if(useBoth) res[idx++] = ((double)small.peek() + big.peek())/2.0;\\n                else res[idx++] = (double)small.peek();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nTo overcome priorityQueue's remove O(k) problem and make our solution O(nlogk), we can replace head/priorityQueue to BST, which is treemap, as below. This would be complicated to write, because we need to deal with duplicated elements and update counts, but the logic is entirely the same as the above solution. \\nTime: O(nlogk).\\n\\n```\\npublic class Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res = new double[nums.length - k + 1];\\n        int idx = 0;\\n        boolean useBoth = k % 2 == 0;\\n        TreeMap<Integer, Integer> small = new TreeMap<>((a, b)->{return (int)((double)b-a);});\\n        int smallSize = 0; \\n        TreeMap<Integer, Integer> big = new TreeMap<>();\\n        int bigSize = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(smallSize + bigSize == k){\\n                if(nums[i-k] <= small.firstKey()){\\n                    remove(small, nums[i-k]);\\n                    smallSize--;\\n                }else{\\n                    remove(big, nums[i-k]);\\n                    bigSize--;\\n                }\\n            }\\n\\n            if(smallSize<=bigSize){\\n                add(small, nums[i]);\\n                smallSize++;\\n            }else{\\n                add(big, nums[i]);\\n                bigSize++;\\n            }\\n            if(bigSize>0){\\n                while(small.firstKey()>big.firstKey()){\\n                    add(big, remove(small, small.firstKey()));\\n                    add(small, remove(big, big.firstKey()));\\n                }\\n            }\\n            \\n            if(smallSize + bigSize==k){\\n                if(useBoth) res[idx++] = ((double)small.firstKey() + big.firstKey())/2.0;\\n                else res[idx++] = (double)small.firstKey();\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int remove(TreeMap<Integer, Integer> map, int i){\\n        map.put(i, map.get(i)-1);\\n        if(map.get(i)==0) map.remove(i);\\n        return i; \\n    }\\n    \\n    private void add(TreeMap<Integer, Integer> map, int i){\\n        if(!map.containsKey(i)) map.put(i, 1);\\n        else map.put(i, map.get(i)+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res = new double[nums.length - k + 1];\\n        int idx = 0;\\n        boolean useBoth = k % 2 == 0;\\n        PriorityQueue<Integer> small = new PriorityQueue<>((a, b)->{return (int)((double)b-a);});\\n        PriorityQueue<Integer> big = new PriorityQueue<>();\\n        for(int i = 0; i<nums.length; i++){\\n            if(small.size() + big.size()==k){\\n                Integer toRemove = new Integer(nums[i-k]);\\n                if(toRemove <= small.peek()) small.remove(toRemove);\\n                else big.remove(toRemove);\\n            }\\n            //always keep small.size() == big.size() or small.size() == big.size()+1\\n            if(small.size()<=big.size()) small.add(nums[i]);\\n            else big.add(nums[i]);\\n            if(big.size()>0){\\n                while(small.peek()>big.peek()){\\n                    big.add(small.poll());\\n                    small.add(big.poll());\\n                }\\n            }\\n            if(small.size() + big.size()==k){\\n                if(useBoth) res[idx++] = ((double)small.peek() + big.peek())/2.0;\\n                else res[idx++] = (double)small.peek();\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res = new double[nums.length - k + 1];\\n        int idx = 0;\\n        boolean useBoth = k % 2 == 0;\\n        TreeMap<Integer, Integer> small = new TreeMap<>((a, b)->{return (int)((double)b-a);});\\n        int smallSize = 0; \\n        TreeMap<Integer, Integer> big = new TreeMap<>();\\n        int bigSize = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            if(smallSize + bigSize == k){\\n                if(nums[i-k] <= small.firstKey()){\\n                    remove(small, nums[i-k]);\\n                    smallSize--;\\n                }else{\\n                    remove(big, nums[i-k]);\\n                    bigSize--;\\n                }\\n            }\\n\\n            if(smallSize<=bigSize){\\n                add(small, nums[i]);\\n                smallSize++;\\n            }else{\\n                add(big, nums[i]);\\n                bigSize++;\\n            }\\n            if(bigSize>0){\\n                while(small.firstKey()>big.firstKey()){\\n                    add(big, remove(small, small.firstKey()));\\n                    add(small, remove(big, big.firstKey()));\\n                }\\n            }\\n            \\n            if(smallSize + bigSize==k){\\n                if(useBoth) res[idx++] = ((double)small.firstKey() + big.firstKey())/2.0;\\n                else res[idx++] = (double)small.firstKey();\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int remove(TreeMap<Integer, Integer> map, int i){\\n        map.put(i, map.get(i)-1);\\n        if(map.get(i)==0) map.remove(i);\\n        return i; \\n    }\\n    \\n    private void add(TreeMap<Integer, Integer> map, int i){\\n        if(!map.containsKey(i)) map.put(i, 1);\\n        else map.put(i, map.get(i)+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069360,
                "title": "java-easy-to-understand-2-heaps",
                "content": "#### Inutition\\nIf we can maintain 2 Heaps - `maxHeap` and `minHeap`, where `maxHeap` stores the smaller half values and `minHeap` stores the larger half values, so that any point of time the top most element of the 2 heaps will provide the median.\\n\\n#### Code\\n```\\nclass Solution {\\n    private PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n    private PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n            \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        double[] median = new double[nums.length - k + 1];\\n        for(int i=0; i < nums.length; i++){\\n            add(nums[i]);\\n\\t\\t\\t// When the index reaches size of k, we can find the median and remove the first element in the window\\n            if (i + 1 >= k) {\\n                median[i-k+1] = findMedian();\\n                remove(nums[i-k+1]);\\n            }\\n        }\\n        return median;\\n    }\\n    \\n\\t// For odd number of elements, top most element in maxHeap is the median of the current window, \\n\\t// else mean of maxHeap top & minHeap top represents the median\\n    private double findMedian(){\\n        return maxHeap.size() > minHeap.size() ? maxHeap.peek() : minHeap.peek() / 2.0 + maxHeap.peek() / 2.0;\\n    }\\n\\n\\t// This method adds the next element in the sliding window in the appropriate heap and rebalances the heaps\\n    private void add(int num){\\n        if (maxHeap.size() == 0 || maxHeap.peek() >= num) \\n            maxHeap.add(num);\\n        else minHeap.add(num);\\n        rebalanceHeaps();\\n    }\\n\\n\\t// This method removes the first element in the sliding window from the appropriate heap and rebalances the heaps\\n    private void remove(int num){\\n        if (num > maxHeap.peek())\\n            minHeap.remove(num);\\n        else maxHeap.remove(num);\\n        rebalanceHeaps();\\n    }    \\n    \\n\\t// This method keeps the height of the 2 heaps same\\n    private void rebalanceHeaps(){\\n        if (maxHeap.size() == minHeap.size())\\n            return;\\n        if (maxHeap.size() > minHeap.size() + 1)\\n            minHeap.add(maxHeap.poll());\\n        else if (maxHeap.size() < minHeap.size())\\n            maxHeap.add(minHeap.poll());        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    private PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n    private PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n            \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        double[] median = new double[nums.length - k + 1];\\n        for(int i=0; i < nums.length; i++){\\n            add(nums[i]);\\n\\t\\t\\t// When the index reaches size of k, we can find the median and remove the first element in the window\\n            if (i + 1 >= k) {\\n                median[i-k+1] = findMedian();\\n                remove(nums[i-k+1]);\\n            }\\n        }\\n        return median;\\n    }\\n    \\n\\t// For odd number of elements, top most element in maxHeap is the median of the current window, \\n\\t// else mean of maxHeap top & minHeap top represents the median\\n    private double findMedian(){\\n        return maxHeap.size() > minHeap.size() ? maxHeap.peek() : minHeap.peek() / 2.0 + maxHeap.peek() / 2.0;\\n    }\\n\\n\\t// This method adds the next element in the sliding window in the appropriate heap and rebalances the heaps\\n    private void add(int num){\\n        if (maxHeap.size() == 0 || maxHeap.peek() >= num) \\n            maxHeap.add(num);\\n        else minHeap.add(num);\\n        rebalanceHeaps();\\n    }\\n\\n\\t// This method removes the first element in the sliding window from the appropriate heap and rebalances the heaps\\n    private void remove(int num){\\n        if (num > maxHeap.peek())\\n            minHeap.remove(num);\\n        else maxHeap.remove(num);\\n        rebalanceHeaps();\\n    }    \\n    \\n\\t// This method keeps the height of the 2 heaps same\\n    private void rebalanceHeaps(){\\n        if (maxHeap.size() == minHeap.size())\\n            return;\\n        if (maxHeap.size() > minHeap.size() + 1)\\n            minHeap.add(maxHeap.poll());\\n        else if (maxHeap.size() < minHeap.size())\\n            maxHeap.add(minHeap.poll());        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620197,
                "title": "python3-o-nlogk-heap-with-intuitive-lazy-deletion-sliding-window-median",
                "content": "```\\nimport heapq\\n\\nclass Heap:\\n    def __init__(self, indices: List[int], nums: List[int], max=False) -> None:\\n        self.max = max\\n        self.heap = [[-nums[i], i] if self.max else [nums[i],i] for i in indices]\\n        self.indices = set(indices)\\n        heapq.heapify(self.heap)\\n        \\n    def __len__(self) -> int:\\n        return len(self.indices)\\n    \\n    def remove(self, index: int) -> None:\\n        if index in self.indices:\\n            self.indices.remove(index)\\n                \\n    def pop(self) -> List[int]:\\n        while self.heap and self.heap[0][1] not in self.indices:\\n            heapq.heappop(self.heap)\\n        item = heapq.heappop(self.heap)\\n        self.indices.remove(item[1])\\n        return [-item[0], item[1]] if self.max else item\\n    \\n    def push(self, item: List[int]) -> None:\\n        self.indices.add(item[1])\\n        heapq.heappush(self.heap, [-item[0], item[1]] if self.max else item)\\n    \\n    def peek(self) -> int:\\n        while self.heap and self.heap[0][1] not in self.indices:\\n            heapq.heappop(self.heap)\\n        v, _ = self.heap[0]\\n        return -v if self.max else v\\n                \\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        indices = sorted(range(k), key=lambda x:nums[x])\\n        minheap = Heap(indices[(k+1)//2:], nums)\\n        maxheap = Heap(indices[:(k+1)//2], nums, max=True)\\n        median = ((lambda: maxheap.peek()) if k % 2 else \\n\\t\\t          (lambda: (minheap.peek() + maxheap.peek()) / 2))\\n        ans = []\\n        ans.append(median())\\n        for i in range(k, len(nums)):\\n            v = nums[i]\\n            minheap.remove(i-k)\\n            maxheap.remove(i-k)\\n            maxheap.push([v, i])\\n            minheap.push(maxheap.pop())\\n            if len(minheap) > len(maxheap):\\n                maxheap.push(minheap.pop())\\n            ans.append(median())\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Heap:\\n    def __init__(self, indices: List[int], nums: List[int], max=False) -> None:\\n        self.max = max\\n        self.heap = [[-nums[i], i] if self.max else [nums[i],i] for i in indices]\\n        self.indices = set(indices)\\n        heapq.heapify(self.heap)\\n        \\n    def __len__(self) -> int:\\n        return len(self.indices)\\n    \\n    def remove(self, index: int) -> None:\\n        if index in self.indices:\\n            self.indices.remove(index)\\n                \\n    def pop(self) -> List[int]:\\n        while self.heap and self.heap[0][1] not in self.indices:\\n            heapq.heappop(self.heap)\\n        item = heapq.heappop(self.heap)\\n        self.indices.remove(item[1])\\n        return [-item[0], item[1]] if self.max else item\\n    \\n    def push(self, item: List[int]) -> None:\\n        self.indices.add(item[1])\\n        heapq.heappush(self.heap, [-item[0], item[1]] if self.max else item)\\n    \\n    def peek(self) -> int:\\n        while self.heap and self.heap[0][1] not in self.indices:\\n            heapq.heappop(self.heap)\\n        v, _ = self.heap[0]\\n        return -v if self.max else v\\n                \\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        indices = sorted(range(k), key=lambda x:nums[x])\\n        minheap = Heap(indices[(k+1)//2:], nums)\\n        maxheap = Heap(indices[:(k+1)//2], nums, max=True)\\n        median = ((lambda: maxheap.peek()) if k % 2 else \\n\\t\\t          (lambda: (minheap.peek() + maxheap.peek()) / 2))\\n        ans = []\\n        ans.append(median())\\n        for i in range(k, len(nums)):\\n            v = nums[i]\\n            minheap.remove(i-k)\\n            maxheap.remove(i-k)\\n            maxheap.push([v, i])\\n            minheap.push(maxheap.pop())\\n            if len(minheap) > len(maxheap):\\n                maxheap.push(minheap.pop())\\n            ans.append(median())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343130,
                "title": "easy-to-understand-c-solution-with-multiset",
                "content": "```\\nmultiset <double> m;\\n    \\n    double findMedian(double remove, double add) {\\n        m.insert(add);\\n        m.erase(m.find(remove));\\n        int n = m.size();\\n        double a = *next(m.begin(), n/2 - 1);\\n        double b = *next(m.begin(), n/2);\\n        return n & 1? b : (a + b) * 0.5;\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector <double> ans;\\n        if(nums.size() < k)\\n            return ans;\\n        for(int i=0; i<k; i++) {\\n            m.insert(nums[i]);\\n        }\\n        ans.push_back(findMedian(0, 0));\\n        for(int i=k; i<nums.size(); i++) {\\n            ans.push_back(findMedian(nums[i-k], nums[i]));\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nmultiset <double> m;\\n    \\n    double findMedian(double remove, double add) {\\n        m.insert(add);\\n        m.erase(m.find(remove));\\n        int n = m.size();\\n        double a = *next(m.begin(), n/2 - 1);\\n        double b = *next(m.begin(), n/2);\\n        return n & 1? b : (a + b) * 0.5;\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector <double> ans;\\n        if(nums.size() < k)\\n            return ans;\\n        for(int i=0; i<k; i++) {\\n            m.insert(nums[i]);\\n        }\\n        ans.push_back(findMedian(0, 0));\\n        for(int i=k; i<nums.size(); i++) {\\n            ans.push_back(findMedian(nums[i-k], nums[i]));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2051327,
                "title": "simple-c-two-heap-explained-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> medians;\\n        int n = nums.size();\\n        unordered_map<int,int> mp; // for late deletion\\n        priority_queue<int> maxh; // max heap for lower half\\n        priority_queue<int, vector<int>, greater<int>> minh; // min heap for upper half\\n        \\n        for(int i=0;i<k;i++) {\\n            maxh.push(nums[i]);\\n        }\\n         for(int i=0;i<(k/2);i++) {\\n            minh.push(maxh.top());\\n            maxh.pop();\\n        }\\n        // always try to main the middle element on the top of maxh heap\\n        // if we have even elements in both the heaps, median is avg of top of both heaps\\n        for(int i=k;i<n;i++) {\\n            if(k&1) { // if k is odd, we will have median on the top of maxheap\\n                medians.push_back(maxh.top()*1.0);\\n            }\\n            else {\\n                medians.push_back(((double)maxh.top()+(double)minh.top())/2);\\n            }\\n            int p=nums[i-k], q=nums[i]; // \\n            // we need to remove p and add q;\\n            // we will delete p when it will come on the top\\n            // to keep track we will maintain map\\n            int balance = 0; // keep heaps in balance, for correct ans\\n            // we decrese balance when remove elements from maxh, so basically if balance<0 it means maxheap has lesser elemets the minheap\\n            // removing p or adding p to map to delete it later\\n            if(p<=maxh.top()) { // p is in maxheap\\n                balance--;\\n                if(p==maxh.top())\\n                    maxh.pop();\\n                else\\n                    mp[p]++;\\n            }\\n            else { // p is min heap\\n                balance++;\\n                if(p == minh.top())\\n                    minh.pop();\\n                else\\n                    mp[p]++;\\n            }\\n            \\n            // inserting q to the right heap\\n            if(!maxh.empty() and q<=maxh.top()) { // pushing q to maxheap\\n                maxh.push(q);\\n                balance++;\\n            }\\n            else { // pushing q to minheap\\n                minh.push(q);\\n                balance--;\\n            }\\n            \\n            // balancing both the heaps\\n            if(balance<0) {\\n                maxh.push(minh.top());\\n                minh.pop();\\n            }\\n            else if(balance>0) {\\n                minh.push(maxh.top());\\n                maxh.pop();\\n            }\\n            \\n            // removing top elements if they exist in our map(late deletion)\\n            while(!maxh.empty() and mp[maxh.top()]) {\\n                mp[maxh.top()]--;\\n                maxh.pop();\\n            }\\n            while(!minh.empty() and mp[minh.top()]) {\\n                mp[minh.top()]--;\\n                minh.pop();\\n            }\\n        }\\n        if(k&1) {\\n            medians.push_back(maxh.top()*1.0);\\n        }\\n        else {\\n            medians.push_back(((double)maxh.top()+(double)minh.top())/2.0);\\n        }\\n        return medians;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> medians;\\n        int n = nums.size();\\n        unordered_map<int,int> mp; // for late deletion\\n        priority_queue<int> maxh; // max heap for lower half\\n        priority_queue<int, vector<int>, greater<int>> minh; // min heap for upper half\\n        \\n        for(int i=0;i<k;i++) {\\n            maxh.push(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 96402,
                "title": "c-two-multiset-solution",
                "content": "Similar idea as 295. Find Median from Data Stream\\nKeep a max heap and a min heap\\nBut in this case, we need to keep on removing elements out of the window\\nSo use multiset insead of heap\\nT = O(n*log(k)), S = O(k)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> res;\\n        multiset<int> u, l;\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            \\n            // Insert new number\\n            if (u.empty() or nums[i] >= *u.begin())\\n                u.insert(nums[i]);\\n            else l.insert(nums[i]);\\n            \\n            // Remove number out of the window\\n            if (i >= k) {\\n                if (nums[i-k] >= *u.begin())\\n                    u.erase(u.find(nums[i-k]));\\n                else l.erase(l.find(nums[i-k]));\\n            }\\n            \\n            // Balance the size of two sets\\n            while (u.size() < l.size()) {\\n                u.insert(*l.rbegin());\\n                l.erase(--l.end());\\n            }\\n            while (u.size() > l.size() + 1) {\\n                l.insert(*u.begin());\\n                u.erase(u.begin());\\n            }\\n            \\n            // Push back median\\n            if (i >= k-1) {\\n                if (k & 1) res.push_back(*u.begin());\\n                else res.push_back(((double)*u.begin() + *l.rbegin()) / 2);\\n            }\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> res;\\n        multiset<int> u, l;\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            \\n            // Insert new number\\n            if (u.empty() or nums[i] >= *u.begin())\\n                u.insert(nums[i]);\\n            else l.insert(nums[i]);\\n            \\n            // Remove number out of the window\\n            if (i >= k) {\\n                if (nums[i-k] >= *u.begin())\\n                    u.erase(u.find(nums[i-k]));\\n                else l.erase(l.find(nums[i-k]));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 412047,
                "title": "two-heaps-sliding-window-approach-o-n-k-runtime-o-k-space",
                "content": "```\\n\"\"\"\\n# BCR\\nRuntime: O(n)\\nSpacetime: O(1)\\n\\n# Brute force soultion\\nCreate z subsets of nums, where z is len(nums) / k\\nSort z\\ncalcuate median\\nRuntime: O(n * k * log k) -- calling merge sort on each subset in z\\nSpacetime: O(z), -- where z is len(nums) / k\\n\\n# Two heap apporach\\ncreate a max heap and min heap to effecintly model the middle of the array so its easy to calculat the median.\\nuse a sliding window of size k, to iterate through nums and populate the heaps\\ncalcuate the median when heaps equal size k \\nslide the window, remove the value that is no longer included, add the new value\\nrepeat\\n\\nRuntime: O( n * k )\\nSpacetime: O(k)\\n\\n\"\"\"\\nimport heapq\\nfrom heapq import * \\n\\nclass Solution:\\n    \\n    @staticmethod\\n    def calculate_median(max_heap: List[int], min_heap: List[int]) -> float:\\n        if len(max_heap) == len(min_heap):\\n            return (-max_heap[0] + min_heap[0]) / 2.0\\n        return min_heap[0]\\n    \\n    @staticmethod\\n    def add_to_heaps(max_heap: List[int], min_heap: List[int], num) -> None:\\n        heappush(max_heap, -heappushpop(min_heap, num))\\n        \\n        if len(max_heap) > len(min_heap):\\n            heappush(min_heap, -heappop(max_heap))\\n    \\n    @staticmethod\\n    def remove_from_heap(heap: List[int], num) -> None:\\n        index = heap.index(num)\\n        # delete in O(1)\\n        # replace the value we want to remove with the last value\\n        heap[index] = heap[-1]\\n        del heap[-1]\\n        \\n        # Restore heap property thoughout the tree\\n        if index < len(heap):\\n            heapq._siftup(heap, index)\\n            heapq._siftdown(heap, 0, index)\\n            \\n    def remove_from_heaps(self, max_heap: List[int], min_heap: List[int], num) -> None:\\n        if min_heap[0] <= num:\\n            self.remove_from_heap(min_heap, num)\\n            return\\n        self.remove_from_heap(max_heap, -num)\\n        \\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        max_heap: List[int] = []\\n        min_heap: List[int] = []\\n        result: List[int] = []\\n        size_of_k = k - 1\\n\\n        for i in range(size_of_k):\\n            self.add_to_heaps(max_heap, min_heap, nums[i])\\n        \\n        for i in range(size_of_k, len(nums)):\\n            self.add_to_heaps(max_heap, min_heap, nums[i])\\n            median = self.calculate_median(max_heap, min_heap)\\n            result.append(median)\\n            self.remove_from_heaps(max_heap, min_heap, nums[i - size_of_k ])\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\"\"\"\\n# BCR\\nRuntime: O(n)\\nSpacetime: O(1)\\n\\n# Brute force soultion\\nCreate z subsets of nums, where z is len(nums) / k\\nSort z\\ncalcuate median\\nRuntime: O(n * k * log k) -- calling merge sort on each subset in z\\nSpacetime: O(z), -- where z is len(nums) / k\\n\\n# Two heap apporach\\ncreate a max heap and min heap to effecintly model the middle of the array so its easy to calculat the median.\\nuse a sliding window of size k, to iterate through nums and populate the heaps\\ncalcuate the median when heaps equal size k \\nslide the window, remove the value that is no longer included, add the new value\\nrepeat\\n\\nRuntime: O( n * k )\\nSpacetime: O(k)\\n\\n\"\"\"\\nimport heapq\\nfrom heapq import * \\n\\nclass Solution:\\n    \\n    @staticmethod\\n    def calculate_median(max_heap: List[int], min_heap: List[int]) -> float:\\n        if len(max_heap) == len(min_heap):\\n            return (-max_heap[0] + min_heap[0]) / 2.0\\n        return min_heap[0]\\n    \\n    @staticmethod\\n    def add_to_heaps(max_heap: List[int], min_heap: List[int], num) -> None:\\n        heappush(max_heap, -heappushpop(min_heap, num))\\n        \\n        if len(max_heap) > len(min_heap):\\n            heappush(min_heap, -heappop(max_heap))\\n    \\n    @staticmethod\\n    def remove_from_heap(heap: List[int], num) -> None:\\n        index = heap.index(num)\\n        # delete in O(1)\\n        # replace the value we want to remove with the last value\\n        heap[index] = heap[-1]\\n        del heap[-1]\\n        \\n        # Restore heap property thoughout the tree\\n        if index < len(heap):\\n            heapq._siftup(heap, index)\\n            heapq._siftdown(heap, 0, index)\\n            \\n    def remove_from_heaps(self, max_heap: List[int], min_heap: List[int], num) -> None:\\n        if min_heap[0] <= num:\\n            self.remove_from_heap(min_heap, num)\\n            return\\n        self.remove_from_heap(max_heap, -num)\\n        \\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        max_heap: List[int] = []\\n        min_heap: List[int] = []\\n        result: List[int] = []\\n        size_of_k = k - 1\\n\\n        for i in range(size_of_k):\\n            self.add_to_heaps(max_heap, min_heap, nums[i])\\n        \\n        for i in range(size_of_k, len(nums)):\\n            self.add_to_heaps(max_heap, min_heap, nums[i])\\n            median = self.calculate_median(max_heap, min_heap)\\n            result.append(median)\\n            self.remove_from_heaps(max_heap, min_heap, nums[i - size_of_k ])\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402609,
                "title": "c-solution-using-two-heaps-using-multi-set",
                "content": "```\\nclass Solution {\\n    private:\\n    multiset<double>MinH, MaxH;\\n    vector<double> ans;\\n    \\n    public:  \\n    void balance()\\n    {\\n         if(MaxH.size() > MinH.size() + 1)\\n            {\\n                MinH.insert(*MaxH.rbegin());\\n                MaxH.erase(MaxH.find(*MaxH.rbegin()));\\n            }\\n            else if(MaxH.size() + 1 < MinH.size())\\n            {\\n                MaxH.insert(*MinH.begin());\\n                MinH.erase(MinH.find(*MinH.begin()));\\n            }\\n    }\\n    \\n    void addNum(double n)\\n    {\\n        \\n        if(MaxH.size()==0)\\n            MaxH.insert(n);\\n        else\\n        {\\n            if(n < *MaxH.rbegin())\\n                MaxH.insert(n);\\n            else\\n                MinH.insert(n);\\n            \\n            balance();\\n        }    \\n    }\\n    \\n    void addAns()\\n    {\\n        if(MaxH.size() == MinH.size())\\n            ans.push_back((*MaxH.rbegin() + *MinH.begin())/2);\\n        else\\n        {\\n            if(MaxH.size() > MinH.size())\\n                ans.push_back(*MaxH.rbegin());\\n            else\\n                ans.push_back(*MinH.begin());\\n        }\\n    }\\n    \\n    void slideWindow(double n)\\n    {\\n        if(MaxH.size() and MaxH.find(n) != MaxH.end())\\n            MaxH.erase(MaxH.find(n));\\n        else\\n            MinH.erase(MinH.find(n));\\n        \\n        balance();\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            addNum(nums[i]*1.0);\\n            if(i + 1 >= k)\\n            {\\n                addAns();\\n                slideWindow(nums[i-k+1]*1.0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    multiset<double>MinH, MaxH;\\n    vector<double> ans;\\n    \\n    public:  \\n    void balance()\\n    {\\n         if(MaxH.size() > MinH.size() + 1)\\n            {\\n                MinH.insert(*MaxH.rbegin());\\n                MaxH.erase(MaxH.find(*MaxH.rbegin()));\\n            }\\n            else if(MaxH.size() + 1 < MinH.size())\\n            {\\n                MaxH.insert(*MinH.begin());\\n                MinH.erase(MinH.find(*MinH.begin()));\\n            }\\n    }\\n    \\n    void addNum(double n)\\n    {\\n        \\n        if(MaxH.size()==0)\\n            MaxH.insert(n);\\n        else\\n        {\\n            if(n < *MaxH.rbegin())\\n                MaxH.insert(n);\\n            else\\n                MinH.insert(n);\\n            \\n            balance();\\n        }    \\n    }\\n    \\n    void addAns()\\n    {\\n        if(MaxH.size() == MinH.size())\\n            ans.push_back((*MaxH.rbegin() + *MinH.begin())/2);\\n        else\\n        {\\n            if(MaxH.size() > MinH.size())\\n                ans.push_back(*MaxH.rbegin());\\n            else\\n                ans.push_back(*MinH.begin());\\n        }\\n    }\\n    \\n    void slideWindow(double n)\\n    {\\n        if(MaxH.size() and MaxH.find(n) != MaxH.end())\\n            MaxH.erase(MaxH.find(n));\\n        else\\n            MinH.erase(MinH.find(n));\\n        \\n        balance();\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            addNum(nums[i]*1.0);\\n            if(i + 1 >= k)\\n            {\\n                addAns();\\n                slideWindow(nums[i-k+1]*1.0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043751,
                "title": "c-sortedset-o-n-log-k",
                "content": "Referencing https://leetcode.com/problems/sliding-window-median/discuss/96346/Java-using-two-Tree-Sets-O(n-logk)\\n\\nThe idea is to reduct the time complexity in the inner loop. C# has a few built in data structures\\n* List/SortedList - The search is always O(log(k)), but insert and delete are O(k). So the total complexicty becomes O(n * k)\\n* Sorted Set - It\\'s basically a advanced heap. The search, insert, delete all are O(log(k)).  (A standard heap delete take O(k) as well).\\nBut the problem is it can\\'t take duplicates. So we can use different Comparer to handle this.\\n\\n```\\npublic class Solution{\\n     void BalanceHeap(SortedSet<int> left, SortedSet<int> right){\\n         if(Math.Abs(left.Count - right.Count) <= 1)\\n             return;\\n         else if(left.Count > right.Count){            \\n             var max = left.Max;\\n             left.Remove(max);\\n             right.Add(max);             \\n         }\\n         else{\\n            var min = right.Min;\\n            right.Remove(min);\\n            left.Add(min);                 \\n         }\\n     }\\n     \\n     double GetMedian(SortedSet<int> left, SortedSet<int> right, int[] nums, bool isOdd){\\n         if(isOdd)\\n             return left.Count > right.Count ? nums[left.Max] : nums[right.Min];\\n         else\\n             return nums[left.Max] * 0.5 + nums[right.Min] * 0.5;\\n     }\\n     \\n     public double[] MedianSlidingWindow(int[] nums, int k) {\\n        var comparer = Comparer<int>.Create((x, y)=> nums[x] != nums[y] ? (nums[x] > nums[y] ? 1 : -1) : (x-y));\\n        var leftHeap = new SortedSet<int>(comparer);\\n        var rightHeap = new SortedSet<int>(comparer);\\n        var isOdd = k % 2 == 1; \\n        var res = new double[nums.Length - k + 1];\\n        \\n        for(var i = 0; i< nums.Length; i ++){\\n            var val = nums[i];\\n            if(leftHeap.Count > 0 && nums[leftHeap.Max] >= val){\\n                leftHeap.Add(i);                \\n            }else if(rightHeap.Count > 0 && nums[rightHeap.Min] < val){\\n                rightHeap.Add(i);                \\n            }else{\\n                leftHeap.Add(i);\\n            }\\n            \\n            BalanceHeap(leftHeap, rightHeap);                        \\n            if(i >= k -1){\\n                res[i - k + 1] = GetMedian(leftHeap, rightHeap, nums, isOdd);\\n                \\n                if(!leftHeap.Remove(i-k + 1))\\n                    rightHeap.Remove(i-k + 1);                    \\n            }\\n        }\\n        return res;\\n     }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution{\\n     void BalanceHeap(SortedSet<int> left, SortedSet<int> right){\\n         if(Math.Abs(left.Count - right.Count) <= 1)\\n             return;\\n         else if(left.Count > right.Count){            \\n             var max = left.Max;\\n             left.Remove(max);\\n             right.Add(max);             \\n         }\\n         else{\\n            var min = right.Min;\\n            right.Remove(min);\\n            left.Add(min);                 \\n         }\\n     }\\n     \\n     double GetMedian(SortedSet<int> left, SortedSet<int> right, int[] nums, bool isOdd){\\n         if(isOdd)\\n             return left.Count > right.Count ? nums[left.Max] : nums[right.Min];\\n         else\\n             return nums[left.Max] * 0.5 + nums[right.Min] * 0.5;\\n     }\\n     \\n     public double[] MedianSlidingWindow(int[] nums, int k) {\\n        var comparer = Comparer<int>.Create((x, y)=> nums[x] != nums[y] ? (nums[x] > nums[y] ? 1 : -1) : (x-y));\\n        var leftHeap = new SortedSet<int>(comparer);\\n        var rightHeap = new SortedSet<int>(comparer);\\n        var isOdd = k % 2 == 1; \\n        var res = new double[nums.Length - k + 1];\\n        \\n        for(var i = 0; i< nums.Length; i ++){\\n            var val = nums[i];\\n            if(leftHeap.Count > 0 && nums[leftHeap.Max] >= val){\\n                leftHeap.Add(i);                \\n            }else if(rightHeap.Count > 0 && nums[rightHeap.Min] < val){\\n                rightHeap.Add(i);                \\n            }else{\\n                leftHeap.Add(i);\\n            }\\n            \\n            BalanceHeap(leftHeap, rightHeap);                        \\n            if(i >= k -1){\\n                res[i - k + 1] = GetMedian(leftHeap, rightHeap, nums, isOdd);\\n                \\n                if(!leftHeap.Remove(i-k + 1))\\n                    rightHeap.Remove(i-k + 1);                    \\n            }\\n        }\\n        return res;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263505,
                "title": "java-time-100-space-100-using-binary-search-explained",
                "content": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int len = nums.length, p = 0;\\n        double[] sol = new double[len - k + 1];\\n        boolean flag = (k % 2 == 0);\\n        List<Integer> list = new ArrayList<>();\\n        \\n        //Insert first k-1 elements into the Arraylist \\n        for (int j = 0; j < k - 1; j++) list.add(nums[j]);\\n        \\n        //sort the initial list with k-1 elements, later on we will just add and remove elements from this sorted list\\n        Collections.sort(list);\\n        \\n        for (int i = k - 1; i < len; i++) {\\n            //Binary search if the element is already present in the list \\n            //below function returns index if the element is present else it returns the  -(expected position +1) , yeah thats the negative sign\\n            int expectedindex = Collections.binarySearch(list, nums[i]);\\n\\n            if (expectedindex > -1) {\\n                list.add(expectedindex + 1, nums[i]); // add just next to it\\n            } \\n            else {\\n                list.add(Math.abs(expectedindex + 1), nums[i]); // add it in its expected position\\n            }\\n\\n            //Insert into the sol list the median according to the value of k \\n            if (flag) {\\n                sol[i - k + 1] = list.get((k / 2) - 1) / 2.0 + list.get((k / 2)) / 2.0;\\n            } else {\\n                sol[i - k + 1] = list.get((k / 2));\\n            }\\n\\n            // when the window slides by one element, we just find its positon in the sorted list and delete it \\n            int index = Collections.binarySearch(list, nums[p]);\\n            list.remove(index);\\n            p++;\\n        }\\n\\n        return sol;\\n    }\\n}\\n```\\n We are adding the element that slides in at the expected position into the sorted list and removing the element that slides out from the window using binary search.\\n \\n Please **Upvote** if you found it useful.",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int len = nums.length, p = 0;\\n        double[] sol = new double[len - k + 1];\\n        boolean flag = (k % 2 == 0);\\n        List<Integer> list = new ArrayList<>();\\n        \\n        //Insert first k-1 elements into the Arraylist \\n        for (int j = 0; j < k - 1; j++) list.add(nums[j]);\\n        \\n        //sort the initial list with k-1 elements, later on we will just add and remove elements from this sorted list\\n        Collections.sort(list);\\n        \\n        for (int i = k - 1; i < len; i++) {\\n            //Binary search if the element is already present in the list \\n            //below function returns index if the element is present else it returns the  -(expected position +1) , yeah thats the negative sign\\n            int expectedindex = Collections.binarySearch(list, nums[i]);\\n\\n            if (expectedindex > -1) {\\n                list.add(expectedindex + 1, nums[i]); // add just next to it\\n            } \\n            else {\\n                list.add(Math.abs(expectedindex + 1), nums[i]); // add it in its expected position\\n            }\\n\\n            //Insert into the sol list the median according to the value of k \\n            if (flag) {\\n                sol[i - k + 1] = list.get((k / 2) - 1) / 2.0 + list.get((k / 2)) / 2.0;\\n            } else {\\n                sol[i - k + 1] = list.get((k / 2));\\n            }\\n\\n            // when the window slides by one element, we just find its positon in the sorted list and delete it \\n            int index = Collections.binarySearch(list, nums[p]);\\n            list.remove(index);\\n            p++;\\n        }\\n\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520663,
                "title": "javascript-solution-beats-98-81",
                "content": "The idea is pretty simple. You need to keep the sorted array, adding and deleting numbers one by one. For this purpose, you can use binary insertion and binary deletion.\\n\\n\\tconst medianSlidingWindow = (nums, k) => {\\n\\t\\tconst arr = []\\n\\t\\tconst output = []\\n\\t\\tconst isEven = k % 2 === 0\\n\\t\\tconst m = k >> 1\\n\\n\\t\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\t\\tbinaryInsertion(arr, nums[i])\\n\\n\\t\\t\\tif (arr.length > k) {\\n\\t\\t\\t\\tbinaryDeletion(arr, nums[i - k])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (arr.length === k) {\\n\\t\\t\\t\\toutput.push(isEven ? (arr[m - 1] + arr[m]) / 2 : arr[m])\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn output\\n\\t}\\n\\n\\tconst binaryInsertion = (arr, target) => {\\n\\t\\tlet left = 0\\n\\t\\tlet right = arr.length\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tconst mid = (left + right) >> 1\\n\\n\\t\\t\\tif (target > arr[mid]) {\\n\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tarr.splice(left, 0, target)\\n\\t}\\n\\n\\tconst binaryDeletion = (arr, target) => {\\n\\t\\tlet left = 0\\n\\t\\tlet right = arr.length\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tconst mid = (left + right) >> 1\\n\\n\\t\\t\\tif (target === arr[mid]) {\\n\\t\\t\\t\\tarr.splice(mid, 1)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t} else if (target > arr[mid]) {\\n\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "The idea is pretty simple. You need to keep the sorted array, adding and deleting numbers one by one. For this purpose, you can use binary insertion and binary deletion.\\n\\n\\tconst medianSlidingWindow = (nums, k) => {\\n\\t\\tconst arr = []\\n\\t\\tconst output = []\\n\\t\\tconst isEven = k % 2 === 0\\n\\t\\tconst m = k >> 1\\n\\n\\t\\tfor (let i = 0; i < nums.length; i++) {\\n\\t\\t\\tbinaryInsertion(arr, nums[i])\\n\\n\\t\\t\\tif (arr.length > k) {\\n\\t\\t\\t\\tbinaryDeletion(arr, nums[i - k])\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (arr.length === k) {\\n\\t\\t\\t\\toutput.push(isEven ? (arr[m - 1] + arr[m]) / 2 : arr[m])\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn output\\n\\t}\\n\\n\\tconst binaryInsertion = (arr, target) => {\\n\\t\\tlet left = 0\\n\\t\\tlet right = arr.length\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tconst mid = (left + right) >> 1\\n\\n\\t\\t\\tif (target > arr[mid]) {\\n\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tarr.splice(left, 0, target)\\n\\t}\\n\\n\\tconst binaryDeletion = (arr, target) => {\\n\\t\\tlet left = 0\\n\\t\\tlet right = arr.length\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tconst mid = (left + right) >> 1\\n\\n\\t\\t\\tif (target === arr[mid]) {\\n\\t\\t\\t\\tarr.splice(mid, 1)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t} else if (target > arr[mid]) {\\n\\t\\t\\t\\tleft = mid + 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tright = mid\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1002124,
                "title": "easy-to-understand-with-explanation-python-two-heaps-o-n-k-and-o-k",
                "content": "# Explanation:\\nSimilar to finding median from a stream with the following changes:\\n- We need to keep track of a sliding window of \"k\" numbers.\\n- This means, in each iteration, when we insert a new number in the heaps, we need to remove one number from the heaps which is going out of the sliding window.\\n - After the removal, we need to re-balance the heaps in the same way that we did while inserting.\\n\\n# Time complexity: O(N * K)\\nWhere N is the total number of elements in the input array and K is the size of the sliding window!\\n- Inserting/removing numbers from heaps of Size K: O(log K)\\n- Removing the element going out of the sliding window from the heap takes: O(K)\\n\\n# Space complexity: O(K) \\n- We will be storing all the numbers within the sliding window.\\n\\n\\n# Code:\\n```\\nclass SlidingWindowMedian:\\n    def __init__(self):\\n        self.max_heap = []  # max heap to store smaller numbers, get largest of small numbers\\n        self.min_heap = []  # min heap to store larger numbers, get smallest of large numbers\\n\\n    def find_median_in_sliding_window(self, nums, k):\\n\\t\\tresult = [0.0 for _ in range(len(nums) - k + 1)] # avoid getting index out of bound error later on if initialized as empty\\n\\n        for i in range(0, len(nums)):\\n\\t\\t\\t# negative sign for max heap since python has min heap by default, so negative sign is to simulate the proposed max heap!\\n\\t\\t\\t# basically remember: \\n\\t\\t\\t# - Add negative sign before the number when adding to max heap!\\n\\t\\t\\t# - Put back the negative sign while popping the number!\\n\\t\\t\\t# - Keep the sign in while comparing the top element of max heap to any number!\\n            if not self.max_heap or nums[i] <= -self.max_heap[0]:\\n                heappush(self.max_heap, -nums[i])\\n            else:\\n                heappush(self.min_heap, nums[i])\\n\\n            # re-balance heaps after inserting every number in the heaps\\n            self.rebalance_heaps()\\n\\n            # if we have at least \"k\" elements in the sliding window\\n            if i - k + 1 >= 0:\\n                # add the median to the resulting array\\n                if len(self.max_heap) == len(self.min_heap):\\n                    # we got even number of elements, take avg of the top of the element from both heaps\\n                    result[i-k+1] = (self.min_heap[0] + (- self.max_heap[0])) / 2.0\\n                else:\\n                    # get the top element from the max heap\\n                    result[i-k+1] = -self.max_heap[0] / 1.0\\n\\n                # remove the element going out of the window, from the heap\\n                element_to_remove = nums[i-k+1]\\n                if element_to_remove <= -self.max_heap[0]:\\n                    self.remove_element_from_heap(self.max_heap, -element_to_remove)\\n                else:\\n                    self.remove_element_from_heap(self.min_heap, element_to_remove)\\n\\n                # re-balance the heaps after element removal\\n                self.rebalance_heaps()\\n\\n        return result\\n\\n    @staticmethod\\n    def remove_element_from_heap(heap, element):\\n        # find the index of the element to remove from the heap\\n        index = heap.index(element)\\n        # move this indexed element to the end of the heap to remove it\\n        heap[index] = heap[-1]  # this basically overrides the element at index to that of last element\\n        # now remove the last element, thereby removing the indexed element (because of previous step)\\n        del heap[-1]\\n\\n        # adjust only one element instead of using heapify (heapify takes O(K), this takes O(Log K))\\n        if index < len(heap):\\n            heapify(heap)\\n            # TODO, understand this better\\n            # heapq._siftup(heap, index)\\n            # heapq._siftdown(heap, 0, index)\\n\\n    def rebalance_heaps(self):\\n        # either both the heaps will have equal number of elements or max-heap will have\\n        # one more element than the min-heap\\n        if len(self.max_heap) > len(self.min_heap) + 1:\\n            heappush(self.min_heap, -heappop(self.max_heap))\\n        elif len(self.max_heap) < len(self.min_heap):\\n            heappush(self.max_heap, -heappop(self.min_heap))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass SlidingWindowMedian:\\n    def __init__(self):\\n        self.max_heap = []  # max heap to store smaller numbers, get largest of small numbers\\n        self.min_heap = []  # min heap to store larger numbers, get smallest of large numbers\\n\\n    def find_median_in_sliding_window(self, nums, k):\\n\\t\\tresult = [0.0 for _ in range(len(nums) - k + 1)] # avoid getting index out of bound error later on if initialized as empty\\n\\n        for i in range(0, len(nums)):\\n\\t\\t\\t# negative sign for max heap since python has min heap by default, so negative sign is to simulate the proposed max heap!\\n\\t\\t\\t# basically remember: \\n\\t\\t\\t# - Add negative sign before the number when adding to max heap!\\n\\t\\t\\t# - Put back the negative sign while popping the number!\\n\\t\\t\\t# - Keep the sign in while comparing the top element of max heap to any number!\\n            if not self.max_heap or nums[i] <= -self.max_heap[0]:\\n                heappush(self.max_heap, -nums[i])\\n            else:\\n                heappush(self.min_heap, nums[i])\\n\\n            # re-balance heaps after inserting every number in the heaps\\n            self.rebalance_heaps()\\n\\n            # if we have at least \"k\" elements in the sliding window\\n            if i - k + 1 >= 0:\\n                # add the median to the resulting array\\n                if len(self.max_heap) == len(self.min_heap):\\n                    # we got even number of elements, take avg of the top of the element from both heaps\\n                    result[i-k+1] = (self.min_heap[0] + (- self.max_heap[0])) / 2.0\\n                else:\\n                    # get the top element from the max heap\\n                    result[i-k+1] = -self.max_heap[0] / 1.0\\n\\n                # remove the element going out of the window, from the heap\\n                element_to_remove = nums[i-k+1]\\n                if element_to_remove <= -self.max_heap[0]:\\n                    self.remove_element_from_heap(self.max_heap, -element_to_remove)\\n                else:\\n                    self.remove_element_from_heap(self.min_heap, element_to_remove)\\n\\n                # re-balance the heaps after element removal\\n                self.rebalance_heaps()\\n\\n        return result\\n\\n    @staticmethod\\n    def remove_element_from_heap(heap, element):\\n        # find the index of the element to remove from the heap\\n        index = heap.index(element)\\n        # move this indexed element to the end of the heap to remove it\\n        heap[index] = heap[-1]  # this basically overrides the element at index to that of last element\\n        # now remove the last element, thereby removing the indexed element (because of previous step)\\n        del heap[-1]\\n\\n        # adjust only one element instead of using heapify (heapify takes O(K), this takes O(Log K))\\n        if index < len(heap):\\n            heapify(heap)\\n            # TODO, understand this better\\n            # heapq._siftup(heap, index)\\n            # heapq._siftdown(heap, 0, index)\\n\\n    def rebalance_heaps(self):\\n        # either both the heaps will have equal number of elements or max-heap will have\\n        # one more element than the min-heap\\n        if len(self.max_heap) > len(self.min_heap) + 1:\\n            heappush(self.min_heap, -heappop(self.max_heap))\\n        elif len(self.max_heap) < len(self.min_heap):\\n            heappush(self.max_heap, -heappop(self.min_heap))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764147,
                "title": "python-2-heap-solution-o-n-k",
                "content": "Use a deque to slide through and 2 heaps to compute the median of the stream of data. Tc = O(N*K), K because of heapify in remove(). \\nFinding median of a stream: https://leetcode.com/problems/find-median-from-data-stream/discuss/74062/Short-simple-JavaC%2B%2BPython-O(log-n)-%2B-O(1)\\n```\\nfrom heapq import *\\nfrom collections import deque\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.small = [] # max heap\\n        self.large = [] # min heap\\n\\n    def addNum(self, num: int) -> None:\\n        heappush(self.small, -heappushpop(self.large, num))\\n        if len(self.large)<len(self.small):\\n            heappush(self.large, -heappop(self.small))\\n\\n    def findMedian(self) -> float:\\n        if len(self.large)>len(self.small): return self.large[0]\\n        else: return (self.large[0]-self.small[0])/2\\n    \\n    def remove(self, heap, element):\\n        ind = heap.index(element) \\n        heap[ind] = heap[-1]\\n        del heap[-1]\\n        heapify(heap)\\n        \\nclass Solution:\\n    \\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        start = 0\\n        obj= MedianFinder()\\n        window = deque()\\n        res = []\\n        for i in range(len(nums)):\\n            window.append(nums[i])\\n            obj.addNum(nums[i])\\n            if len(window)==k:\\n                res.append(obj.findMedian())\\n                x = window.popleft()\\n                if obj.small and x<=-obj.small[0]: obj.remove(obj.small, -x)\\n                else: obj.remove(obj.large, x)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import *\\nfrom collections import deque\\nclass MedianFinder:\\n\\n    def __init__(self):\\n        \"\"\"\\n        initialize your data structure here.\\n        \"\"\"\\n        self.small = [] # max heap\\n        self.large = [] # min heap\\n\\n    def addNum(self, num: int) -> None:\\n        heappush(self.small, -heappushpop(self.large, num))\\n        if len(self.large)<len(self.small):\\n            heappush(self.large, -heappop(self.small))\\n\\n    def findMedian(self) -> float:\\n        if len(self.large)>len(self.small): return self.large[0]\\n        else: return (self.large[0]-self.small[0])/2\\n    \\n    def remove(self, heap, element):\\n        ind = heap.index(element) \\n        heap[ind] = heap[-1]\\n        del heap[-1]\\n        heapify(heap)\\n        \\nclass Solution:\\n    \\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        start = 0\\n        obj= MedianFinder()\\n        window = deque()\\n        res = []\\n        for i in range(len(nums)):\\n            window.append(nums[i])\\n            obj.addNum(nums[i])\\n            if len(window)==k:\\n                res.append(obj.findMedian())\\n                x = window.popleft()\\n                if obj.small and x<=-obj.small[0]: obj.remove(obj.small, -x)\\n                else: obj.remove(obj.large, x)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96374,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "The idea is similar to [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/discuss/887170/Evolve-from-brute-force-to-optimal).\\n1. Array O(nk)  Store the window in a sorted list.\\n```\\n\\tpublic double[] medianSlidingWindow(int[] nums, int k) {\\n        int n=nums.length;\\n        double[] median=new double[n-k+1];\\n        List<Integer> window = new ArrayList<>();\\n        for(int i=0;i<n;i++) {\\n            int j = Collections.binarySearch(window,nums[i]);\\n            if(j<0)\\n                j=-j-1;\\n            window.add(j,nums[i]);\\n            if(i>=k) {\\n                window.remove(new Integer(nums[i-k]));\\n            }\\n            if(i>=k-1) {\\n                median[i-k+1]=((long)window.get(k/2)+window.get((k-1)/2))/2.0;\\n            }\\n        }\\n        return median;\\n    }\\n```\\n2. Heap O(nk). Another simple idea is to reuse [295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/discuss/957550/Evolve-from-brute-force). Add is O(logk), findMedian is O(1), remove is O(k) for priorty queue. Same as 295, we want the invariance that heap sizes are be equal or the left heap is larger by 1 to simplify the logic to findMedian. This can be achieved by remove old number before adding new number. After removing, left size could be smaller by one or larger by two in the worst case. Then we add to the smaller heap to satisfy the invariance. \\n```\\n\\tpublic double[] medianSlidingWindow(int[] nums, int k) {\\n        int n=nums.length;\\n        double[] median=new double[n-k+1];\\n        PriorityQueue<Integer> small=new PriorityQueue<>((a,b)->b.compareTo(a)), large=new PriorityQueue<>();\\n        for(int i=0;i<n;i++) {\\n            if(i>=k) {\\n                if(!small.remove(nums[i-k])) {\\n                    large.remove(nums[i-k]);   \\n                }\\n            }\\n            addNum(nums[i],small, large);\\n            if(i>=k-1)\\n                median[i-k+1] = findMedian(small, large);\\n        }\\n        return median;\\n    }\\n    private void addNum(int num, Queue<Integer> small, Queue<Integer> large) {\\n        if(small.size()>large.size()) {\\n            small.add(num);\\n            large.add(small.poll());\\n        } else {\\n            large.add(num);\\n            small.add(large.poll());      \\n        }\\n    }\\n    private double findMedian(Queue<Integer> small, Queue<Integer> large) {\\n        if(small.size()>large.size()) {\\n            return small.peek(); \\n        } else {\\n            return ((long)small.peek()+large.peek())/2.0;\\n        }\\n    }\\n```\\n3. Binary search tree O(nlogk). BST can remove in log(k). Use two bst to store the smaller half and the larger half of the current window. The challenge is how to store duplicate in BST. An easy approach is to store array index in BST and overload the comparator so that it is sorted by value.\\n* java\\n```\\n\\tpublic double[] medianSlidingWindow(int[] nums, int k) {\\n        int n=nums.length;\\n        double[] median=new double[n-k+1];\\n        Comparator<Integer> comp = (i,j)->nums[i]==nums[j]?i-j:nums[i] - nums[j];\\n        TreeSet<Integer> small=new TreeSet<>(comp), large=new TreeSet<>(comp);\\n        for(int i=0;i<n;i++) {\\n            if(i>=k) {\\n                if(!small.remove(i-k)) {\\n                    large.remove(i-k);   \\n                }\\n            }\\n            addNum(i, small, large);\\n            if(i>=k-1)\\n                median[i-k+1] = findMedian(nums, small, large);\\n        }\\n        return median;\\n    }\\n    private void addNum(int i, TreeSet<Integer> small, TreeSet<Integer> large) {\\n        if(small.size() > large.size()) {\\n            small.add(i);\\n            large.add(small.pollLast());     \\n        } else {\\n            large.add(i);\\n            small.add(large.pollFirst());        \\n        } \\n    }\\n    private double findMedian(int[] nums, TreeSet<Integer> small, TreeSet<Integer> large) {\\n        if(small.size() > large.size()) {\\n            return nums[small.last()]; \\n        } else {\\n            return ((long)nums[small.last()]+nums[large.first()])/2.0;\\n        }\\n    }\\n```\\nAfter each add or erase, the two bst are balanced so that their sizes differ by at most 1. This makes it easier to partition the number and compute the median.\\n* c++\\n```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<double> med(n-k+1);\\n        for(int i=0;i<n;i++) {\\n            if(i>k-1) {\\n                auto it = sm.find(nums[i-k]);\\n                if(it!=sm.end()) sm.erase(it);\\n                else lg.erase(lg.find(nums[i-k]));\\n                balance();\\n            }\\n            if(sm.empty()||nums[i]<=*sm.rbegin()) sm.insert(nums[i]);\\n            else lg.insert(nums[i]);\\n            balance();\\n            if(i>=k-1) med[i-k+1] = sm.size()>lg.size() ? *sm.rbegin() : \\n                lg.size()>sm.size() ? *lg.begin() : ((long)*sm.rbegin()+*lg.begin())/2.0;\\n        }\\n        return med;\\n    }\\nprivate:\\n    void balance() {\\n        if(sm.size()>lg.size()+1) {\\n            lg.insert(*sm.rbegin());\\n            sm.erase(--sm.end());\\n        }\\n        if(lg.size()>sm.size()+1) {\\n            sm.insert(*lg.begin());\\n            lg.erase(lg.begin());\\n        }\\n    }\\n    multiset<int> sm,lg;\\n};\\n```\\n4. O(nlogk) , we can just use one bst and keep track of the middle element. The great idea is from [@StefanPochmann](https://discuss.leetcode.com/topic/74963/o-n-log-k-c-using-multiset-and-updating-middle-iterator). The idea is to keep the middle pointer points to index k/2 after insertion and erasure. \\n```\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<double> med(n-k+1);\\n        multiset<double> window(nums.begin(),nums.begin()+k);\\n        auto m = next(window.begin(),k/2);\\n        for(int i=k;;i++) {\\n            med[i-k] = ((double)*m+*next(m,k%2-1))/2;\\n            if(i==n) return med;\\n            window.insert(nums[i]);\\n            if(nums[i]<*m) m--;\\n            if(nums[i-k]<=*m) m++;\\n            window.erase(window.lower_bound(nums[i-k]));\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n\\tpublic double[] medianSlidingWindow(int[] nums, int k) {\\n        int n=nums.length;\\n        double[] median=new double[n-k+1];\\n        List<Integer> window = new ArrayList<>();\\n        for(int i=0;i<n;i++) {\\n            int j = Collections.binarySearch(window,nums[i]);\\n            if(j<0)\\n                j=-j-1;\\n            window.add(j,nums[i]);\\n            if(i>=k) {\\n                window.remove(new Integer(nums[i-k]));\\n            }\\n            if(i>=k-1) {\\n                median[i-k+1]=((long)window.get(k/2)+window.get((k-1)/2))/2.0;\\n            }\\n        }\\n        return median;\\n    }\\n```\n```\\n\\tpublic double[] medianSlidingWindow(int[] nums, int k) {\\n        int n=nums.length;\\n        double[] median=new double[n-k+1];\\n        PriorityQueue<Integer> small=new PriorityQueue<>((a,b)->b.compareTo(a)), large=new PriorityQueue<>();\\n        for(int i=0;i<n;i++) {\\n            if(i>=k) {\\n                if(!small.remove(nums[i-k])) {\\n                    large.remove(nums[i-k]);   \\n                }\\n            }\\n            addNum(nums[i],small, large);\\n            if(i>=k-1)\\n                median[i-k+1] = findMedian(small, large);\\n        }\\n        return median;\\n    }\\n    private void addNum(int num, Queue<Integer> small, Queue<Integer> large) {\\n        if(small.size()>large.size()) {\\n            small.add(num);\\n            large.add(small.poll());\\n        } else {\\n            large.add(num);\\n            small.add(large.poll());      \\n        }\\n    }\\n    private double findMedian(Queue<Integer> small, Queue<Integer> large) {\\n        if(small.size()>large.size()) {\\n            return small.peek(); \\n        } else {\\n            return ((long)small.peek()+large.peek())/2.0;\\n        }\\n    }\\n```\n```\\n\\tpublic double[] medianSlidingWindow(int[] nums, int k) {\\n        int n=nums.length;\\n        double[] median=new double[n-k+1];\\n        Comparator<Integer> comp = (i,j)->nums[i]==nums[j]?i-j:nums[i] - nums[j];\\n        TreeSet<Integer> small=new TreeSet<>(comp), large=new TreeSet<>(comp);\\n        for(int i=0;i<n;i++) {\\n            if(i>=k) {\\n                if(!small.remove(i-k)) {\\n                    large.remove(i-k);   \\n                }\\n            }\\n            addNum(i, small, large);\\n            if(i>=k-1)\\n                median[i-k+1] = findMedian(nums, small, large);\\n        }\\n        return median;\\n    }\\n    private void addNum(int i, TreeSet<Integer> small, TreeSet<Integer> large) {\\n        if(small.size() > large.size()) {\\n            small.add(i);\\n            large.add(small.pollLast());     \\n        } else {\\n            large.add(i);\\n            small.add(large.pollFirst());        \\n        } \\n    }\\n    private double findMedian(int[] nums, TreeSet<Integer> small, TreeSet<Integer> large) {\\n        if(small.size() > large.size()) {\\n            return nums[small.last()]; \\n        } else {\\n            return ((long)nums[small.last()]+nums[large.first()])/2.0;\\n        }\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<double> med(n-k+1);\\n        for(int i=0;i<n;i++) {\\n            if(i>k-1) {\\n                auto it = sm.find(nums[i-k]);\\n                if(it!=sm.end()) sm.erase(it);\\n                else lg.erase(lg.find(nums[i-k]));\\n                balance();\\n            }\\n            if(sm.empty()||nums[i]<=*sm.rbegin()) sm.insert(nums[i]);\\n            else lg.insert(nums[i]);\\n            balance();\\n            if(i>=k-1) med[i-k+1] = sm.size()>lg.size() ? *sm.rbegin() : \\n                lg.size()>sm.size() ? *lg.begin() : ((long)*sm.rbegin()+*lg.begin())/2.0;\\n        }\\n        return med;\\n    }\\nprivate:\\n    void balance() {\\n        if(sm.size()>lg.size()+1) {\\n            lg.insert(*sm.rbegin());\\n            sm.erase(--sm.end());\\n        }\\n        if(lg.size()>sm.size()+1) {\\n            sm.insert(*lg.begin());\\n            lg.erase(lg.begin());\\n        }\\n    }\\n    multiset<int> sm,lg;\\n};\\n```\n```\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<double> med(n-k+1);\\n        multiset<double> window(nums.begin(),nums.begin()+k);\\n        auto m = next(window.begin(),k/2);\\n        for(int i=k;;i++) {\\n            med[i-k] = ((double)*m+*next(m,k%2-1))/2;\\n            if(i==n) return med;\\n            window.insert(nums[i]);\\n            if(nums[i]<*m) m--;\\n            if(nums[i-k]<=*m) m++;\\n            window.erase(window.lower_bound(nums[i-k]));\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777700,
                "title": "the-most-optimal-t-o-nlogk-s-o-k-using-2-heaps-c-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// Custom structures for max & min heaps\\n    struct maxstruct{\\n        bool operator()(pair<double,double>& a, pair<double,double>& b){\\n            return a.second<b.second;\\n        }  \\n    };\\n    struct minstruct{\\n        bool operator()(pair<double,double>& a, pair<double,double>& b){\\n            return a.second>b.second;\\n        }  \\n    };\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<double> result;\\n\\t\\t\\n\\t\\t//max_heap for left half and min_heap for right half\\n        priority_queue<pair<double,double>, vector<pair<double,double>>, maxstruct> max_heap;\\n        priority_queue<pair<double,double>, vector<pair<double,double>>, minstruct> min_heap;\\n        \\n\\t\\t//Initialize both Heaps\\n        for(int i=0; i<k; i++)\\n            max_heap.push({i, nums[i]});\\n        \\n        while(max_heap.size()>min_heap.size()+1){\\n            min_heap.push(max_heap.top());\\n            max_heap.pop();\\n        }\\n            \\n        for(int i=k; i<n; i++){\\n\\t\\t\\n\\t\\t\\t// Store median into result for previous window\\n            if(k%2==0){\\n                double ans=max_heap.top().second + min_heap.top().second;\\n                ans/=2;\\n                result.push_back(ans);\\n            }\\n            else\\n                result.push_back(max_heap.top().second);\\n            \\n\\t\\t\\t// Main Part\\n            double outgoing=nums[i-k], incoming=nums[i], balance=0;\\n            // Balance for outgoing element\\n            if(outgoing<max_heap.top().second || (outgoing==max_heap.top().second && max_heap.top().first<=i-k) || (!min_heap.empty() && outgoing<min_heap.top().second))\\n                balance--;\\n            else\\n                balance++;\\n            \\n\\t\\t\\t// Balance for incoming element\\n            if(incoming<max_heap.top().second || (incoming==max_heap.top().second && max_heap.top().first>i-k) ||(!min_heap.empty() && incoming<min_heap.top().second)){\\n                balance++;\\n                max_heap.push({i, incoming});\\n            }\\n            else{\\n                balance--;\\n                min_heap.push({i, incoming});\\n            }\\n            \\n\\t\\t\\t// Check Balance\\n            if(!min_heap.empty() && balance<0){\\n                max_heap.push(min_heap.top());\\n                min_heap.pop();\\n                balance++;\\n            }\\n            else if(!max_heap.empty() && balance>0){\\n                min_heap.push(max_heap.top());\\n                max_heap.pop();\\n                balance--;\\n            }\\n            \\n\\t\\t\\t// Lazy Removal when out of window range element at the top\\n            while(!min_heap.empty() && min_heap.top().first<=i-k)\\n                min_heap.pop();\\n            \\n            while(!max_heap.empty() && max_heap.top().first<=i-k)\\n                max_heap.pop();\\n        }\\n        \\n\\t\\t\\t// Store median into result for last window\\n            if(k%2==0){\\n                double ans=max_heap.top().second + min_heap.top().second;\\n                ans/=2;\\n                result.push_back(ans);\\n            }\\n            else\\n                result.push_back(max_heap.top().second);\\n        \\n        return result;\\n    }\\n};\\n```\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// Custom structures for max & min heaps\\n    struct maxstruct{\\n        bool operator()(pair<double,double>& a, pair<double,double>& b){\\n            return a.second<b.second;\\n        }  \\n    };\\n    struct minstruct{\\n        bool operator()(pair<double,double>& a, pair<double,double>& b){\\n            return a.second>b.second;\\n        }  \\n    };\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<double> result;\\n\\t\\t\\n\\t\\t//max_heap for left half and min_heap for right half\\n        priority_queue<pair<double,double>, vector<pair<double,double>>, maxstruct> max_heap;\\n        priority_queue<pair<double,double>, vector<pair<double,double>>, minstruct> min_heap;\\n        \\n\\t\\t//Initialize both Heaps\\n        for(int i=0; i<k; i++)\\n            max_heap.push({i, nums[i]});\\n        \\n        while(max_heap.size()>min_heap.size()+1){\\n            min_heap.push(max_heap.top());\\n            max_heap.pop();\\n        }\\n            \\n        for(int i=k; i<n; i++){\\n\\t\\t\\n\\t\\t\\t// Store median into result for previous window\\n            if(k%2==0){\\n                double ans=max_heap.top().second + min_heap.top().second;\\n                ans/=2;\\n                result.push_back(ans);\\n            }\\n            else\\n                result.push_back(max_heap.top().second);\\n            \\n\\t\\t\\t// Main Part\\n            double outgoing=nums[i-k], incoming=nums[i], balance=0;\\n            // Balance for outgoing element\\n            if(outgoing<max_heap.top().second || (outgoing==max_heap.top().second && max_heap.top().first<=i-k) || (!min_heap.empty() && outgoing<min_heap.top().second))\\n                balance--;\\n            else\\n                balance++;\\n            \\n\\t\\t\\t// Balance for incoming element\\n            if(incoming<max_heap.top().second || (incoming==max_heap.top().second && max_heap.top().first>i-k) ||(!min_heap.empty() && incoming<min_heap.top().second)){\\n                balance++;\\n                max_heap.push({i, incoming});\\n            }\\n            else{\\n                balance--;\\n                min_heap.push({i, incoming});\\n            }\\n            \\n\\t\\t\\t// Check Balance\\n            if(!min_heap.empty() && balance<0){\\n                max_heap.push(min_heap.top());\\n                min_heap.pop();\\n                balance++;\\n            }\\n            else if(!max_heap.empty() && balance>0){\\n                min_heap.push(max_heap.top());\\n                max_heap.pop();\\n                balance--;\\n            }\\n            \\n\\t\\t\\t// Lazy Removal when out of window range element at the top\\n            while(!min_heap.empty() && min_heap.top().first<=i-k)\\n                min_heap.pop();\\n            \\n            while(!max_heap.empty() && max_heap.top().first<=i-k)\\n                max_heap.pop();\\n        }\\n        \\n\\t\\t\\t// Store median into result for last window\\n            if(k%2==0){\\n                double ans=max_heap.top().second + min_heap.top().second;\\n                ans/=2;\\n                result.push_back(ans);\\n            }\\n            else\\n                result.push_back(max_heap.top().second);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96378,
                "title": "python-hash-heap-implementation",
                "content": "Apparently, we need a data structure which supports both `Insert` and `Remove` operation in `O(log K)` time and supports `getMin` operation in `O(1)` or `O(log K)` time.\\n\\nThe Data Structure we could choose may be Balanced BST or Hash Heap. But there is no such implemented data structure in Python. Here is my implementation of Hash Heap in Python. Then, with this data structure, this problem could be easily solved just as [LeetCode 295 Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/). \\n\\n[The Chinese version on my blog](http://hankerzheng.com/blog/Python-Hash-Heap)\\n\\n```python\\n# This is the Python implementation of Hash Heap based on the list implementation \\n# of binary heap. The difference between Hash Heap and Binary Heap is that Hash\\n# Heap supports the `heapRemove` operation in O(log n) time and can check whether\\n# certain element is in the Hash Heap or not in O(1) time.\\n# \\n# Basic automatic tests are given in `pushpopTest()` and `removeTest()`.\\n# Note: It may takes about 10 seconds to run both test functions.\\n\\n# import random module for test use.\\nimport random\\n\\nclass HeapNode(object):\\n    \"\"\"\\n    The node in the HashHeap to deal with duplicates.\\n    Each node store the value of each element and the number of duplicates\\n    with the same value.\\n    \"\"\"\\n    def __init__(self, val, cnt):\\n        self.val = val\\n        self.cnt = cnt\\n\\n    def __cmp__(self, other):\\n        return self.val - other.val\\n\\n    def __str__(self):\\n        return \"[%s, %d]\" % (self.val, self.cnt)\\n    __repr__ = __str__\\n\\nclass HashHeap(object):\\n    \"\"\"\\n    This HashHeap is the same as the list implementation of binary heap, but with\\n    a hashMap to map the value of one elemnt to its index in the list.\\n    \"\"\"\\n    def __init__(self, arr):\\n        \"\"\"\\n        `_cap` - the number of elements in the HashHeap\\n        `_maxIdx` - the max index of the binary heap\\n        `_data` - the list implementation of the binary heap\\n        `_hashMap` - mapping the element to its index in the binary heap\\n        \"\"\"\\n        elemCnt = self._preProcess(arr)\\n        self._cap = len(arr)\\n        self._maxIdx = len(elemCnt) - 1\\n        self._data = [HeapNode(key, value) for key, value in elemCnt.items()]\\n        self._hashMap = {node.val: idx for idx, node in enumerate(self._data)}\\n        self._heapify()\\n\\n    def _preProcess(self, arr):\\n        \"\"\"\\n        Convert the input array into a dict object.\\n        The key to the dict is the value of the element.\\n        The value of the dict is the occurence of each element.\\n        \"\"\"\\n        elemCnt = {}\\n        for elem in arr:\\n            elemCnt[elem] = elemCnt.get(elem, 0) + 1\\n        return elemCnt\\n\\n    def _swap(self, idx1, idx2):\\n        \"\"\"\\n        Swap the 2 elements in the heap.\\n        Also, change the index stored in `self._hashMap`\\n        \"\"\"\\n        elem1, elem2 = self._data[idx1], self._data[idx2]\\n        self._hashMap[elem1.val] = idx2\\n        self._hashMap[elem2.val] = idx1\\n        self._data[idx1], self._data[idx2] = elem2, elem1\\n\\n    def _heapify(self):\\n        idx = self._maxIdx\\n        while idx > 0:\\n            parentIdx = (idx - 1) / 2\\n            if self._data[parentIdx] > self._data[idx]:\\n                self._swap(parentIdx, idx)\\n                self._siftDown(idx)\\n            idx -= 1\\n\\n    def _siftDown(self, idx):\\n        def heapValid(idx):\\n            left, right = idx * 2 + 1, idx * 2 + 2\\n            if left > self._maxIdx:\\n                return True\\n            if right > self._maxIdx:\\n                return self._data[idx] <= self._data[left]\\n            return self._data[idx] <= self._data[left] and self._data[idx] <= self._data[right]\\n        def smallerChild(idx):\\n            left, right = idx * 2 + 1, idx * 2 + 2\\n            if left > self._maxIdx:\\n                return None\\n            if right > self._maxIdx:\\n                return left\\n            return left if self._data[left] < self._data[right] else right\\n\\n        current = idx\\n        while not heapValid(current):\\n            child = smallerChild(current)\\n            self._swap(current, child)\\n            current = child\\n\\n    def _siftUp(self, idx):\\n        current = idx\\n        parent = (current - 1) / 2\\n        while current > 0 and self._data[parent] > self._data[current]:\\n            self._swap(parent, current)\\n            current = parent\\n            parent = (current - 1) / 2\\n\\n    def _removeLastNode(self):\\n        rmNode = self._data.pop(-1)\\n        self._cap -= 1\\n        self._maxIdx -= 1\\n        self._hashMap.pop(rmNode.val)\\n\\n    def _removeByIdx(self, idx):\\n        thisNode = self._data[idx]\\n        retVal = thisNode.val\\n        if thisNode.cnt > 1:\\n            thisNode.cnt -= 1\\n            self._cap -= 1\\n        elif idx == self._maxIdx:\\n            # the node itself is the last node\\n            self._removeLastNode()\\n        else:\\n            self._swap(idx, self._maxIdx)\\n            self._removeLastNode()\\n            pidx = (idx - 1) / 2\\n            # check to see we should sift up or sift down\\n            if pidx >= 0 and self._data[pidx] > self._data[idx]:\\n                self._siftUp(idx)\\n            else:\\n                self._siftDown(idx)\\n        return retVal\\n\\n    @property\\n    def length(self):\\n        \"\"\"\\n        Return the number of elements in the Hash Heap\\n        \"\"\"\\n        return self._cap\\n\\n    def heapPeep(self):\\n        \"\"\"\\n        Return the MIN element in the Hash Heap\\n        \"\"\"\\n        if not self._data:\\n            return float(\"inf\")\\n        return self._data[0].val\\n\\n    def heapPop(self):\\n        \"\"\"\\n        Remove the MIN element from the Hash Heap and return its value\\n        \"\"\"\\n        return self._removeByIdx(0)\\n\\n    def heapPush(self, elem):\\n        \"\"\"\\n        Push a new element into the Hash Heap\\n        \"\"\"\\n        self._cap += 1\\n        if elem not in self._hashMap:\\n            self._maxIdx += 1\\n            self._data.append(HeapNode(elem, 1))\\n            self._hashMap[elem] = self._maxIdx\\n            self._siftUp(self._maxIdx)\\n        else:\\n            idx = self._hashMap[elem]\\n            self._data[idx].cnt += 1\\n        \\n    def heapRemove(self, elem):\\n        \"\"\"\\n        Remove a existing element from the Hash Heap\\n        If the element to be removed is not in the Hash Heap, raise an error.\\n        \"\"\"\\n        if elem not in self._hashMap:\\n            raise ValueError(\"Element to be removed is not in HashHeap!!!\")\\n        idx = self._hashMap[elem]\\n        self._removeByIdx(idx)\\n\\n    def __contains__(self, value):\\n        return value in self._hashMap\\n\\n    def __str__(self):\\n        return \"%s\" % [elem.val for elem in self._data]\\n    __repr__ = __str__\\n\\n\\ndef pushpopTest():\\n    \"\"\"\\n    Randomly generate a list, and push each element into the heap.\\n    Test HeapPush by comparing the first element in the heap with the \\n    smallest element in the List.\\n    Test HeapPop by comparing the popped element from the heap with the\\n    sorted list one by one. \\n    \"\"\"\\n    for _ in xrange(100):\\n        thisHeap = HashHeap([0])\\n        testList = [0]\\n        for i in xrange(1000):\\n            thisRandom = random.randrange(-100, 100000)\\n            thisHeap.heapPush(thisRandom)\\n            testList.append(thisRandom)\\n            assert min(testList) == thisHeap.heapPeep()\\n            assert len(testList) == thisHeap.length\\n            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1\\n        testList.sort()\\n        assert len(testList) == thisHeap.length\\n        for idx, num in enumerate(testList):\\n            assert num == thisHeap.heapPop()\\n            assert len(testList) - 1 - idx == thisHeap.length\\n            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1\\n\\ndef removeTest():\\n    \"\"\"\\n    Randomly generate a list, and push each element into the heap.\\n    Test HeapRemove by randomly delete one element from the heap by the probability\\n    of 0.2, and then check whether the first element in the heap is the same as the\\n    smallest element in the list.\\n    \"\"\"\\n    for _ in xrange(100):\\n        thisHeap = HashHeap([0])\\n        testList = [0]\\n        for i in xrange(1000):\\n            thisRandom = random.randrange(-100, 100000)\\n            thisHeap.heapPush(thisRandom)\\n            if random.random() < 0.2:\\n                thisHeap.heapRemove(thisRandom)\\n            else:\\n                testList.append(thisRandom)\\n            assert min(testList) == thisHeap.heapPeep()\\n            assert len(testList) == thisHeap.length\\n            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1\\n        testList.sort()\\n        assert len(testList) == thisHeap.length\\n        for idx, num in enumerate(testList):\\n            assert num == thisHeap.heapPop()\\n            assert len(testList) - 1 - idx == thisHeap.length\\n            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1\\n\\n\\nif __name__ == '__main__':\\n    pushpopTest()\\n    removeTest()\\n```",
                "solutionTags": [],
                "code": "```python\\n# This is the Python implementation of Hash Heap based on the list implementation \\n# of binary heap. The difference between Hash Heap and Binary Heap is that Hash\\n# Heap supports the `heapRemove` operation in O(log n) time and can check whether\\n# certain element is in the Hash Heap or not in O(1) time.\\n# \\n# Basic automatic tests are given in `pushpopTest()` and `removeTest()`.\\n# Note: It may takes about 10 seconds to run both test functions.\\n\\n# import random module for test use.\\nimport random\\n\\nclass HeapNode(object):\\n    \"\"\"\\n    The node in the HashHeap to deal with duplicates.\\n    Each node store the value of each element and the number of duplicates\\n    with the same value.\\n    \"\"\"\\n    def __init__(self, val, cnt):\\n        self.val = val\\n        self.cnt = cnt\\n\\n    def __cmp__(self, other):\\n        return self.val - other.val\\n\\n    def __str__(self):\\n        return \"[%s, %d]\" % (self.val, self.cnt)\\n    __repr__ = __str__\\n\\nclass HashHeap(object):\\n    \"\"\"\\n    This HashHeap is the same as the list implementation of binary heap, but with\\n    a hashMap to map the value of one elemnt to its index in the list.\\n    \"\"\"\\n    def __init__(self, arr):\\n        \"\"\"\\n        `_cap` - the number of elements in the HashHeap\\n        `_maxIdx` - the max index of the binary heap\\n        `_data` - the list implementation of the binary heap\\n        `_hashMap` - mapping the element to its index in the binary heap\\n        \"\"\"\\n        elemCnt = self._preProcess(arr)\\n        self._cap = len(arr)\\n        self._maxIdx = len(elemCnt) - 1\\n        self._data = [HeapNode(key, value) for key, value in elemCnt.items()]\\n        self._hashMap = {node.val: idx for idx, node in enumerate(self._data)}\\n        self._heapify()\\n\\n    def _preProcess(self, arr):\\n        \"\"\"\\n        Convert the input array into a dict object.\\n        The key to the dict is the value of the element.\\n        The value of the dict is the occurence of each element.\\n        \"\"\"\\n        elemCnt = {}\\n        for elem in arr:\\n            elemCnt[elem] = elemCnt.get(elem, 0) + 1\\n        return elemCnt\\n\\n    def _swap(self, idx1, idx2):\\n        \"\"\"\\n        Swap the 2 elements in the heap.\\n        Also, change the index stored in `self._hashMap`\\n        \"\"\"\\n        elem1, elem2 = self._data[idx1], self._data[idx2]\\n        self._hashMap[elem1.val] = idx2\\n        self._hashMap[elem2.val] = idx1\\n        self._data[idx1], self._data[idx2] = elem2, elem1\\n\\n    def _heapify(self):\\n        idx = self._maxIdx\\n        while idx > 0:\\n            parentIdx = (idx - 1) / 2\\n            if self._data[parentIdx] > self._data[idx]:\\n                self._swap(parentIdx, idx)\\n                self._siftDown(idx)\\n            idx -= 1\\n\\n    def _siftDown(self, idx):\\n        def heapValid(idx):\\n            left, right = idx * 2 + 1, idx * 2 + 2\\n            if left > self._maxIdx:\\n                return True\\n            if right > self._maxIdx:\\n                return self._data[idx] <= self._data[left]\\n            return self._data[idx] <= self._data[left] and self._data[idx] <= self._data[right]\\n        def smallerChild(idx):\\n            left, right = idx * 2 + 1, idx * 2 + 2\\n            if left > self._maxIdx:\\n                return None\\n            if right > self._maxIdx:\\n                return left\\n            return left if self._data[left] < self._data[right] else right\\n\\n        current = idx\\n        while not heapValid(current):\\n            child = smallerChild(current)\\n            self._swap(current, child)\\n            current = child\\n\\n    def _siftUp(self, idx):\\n        current = idx\\n        parent = (current - 1) / 2\\n        while current > 0 and self._data[parent] > self._data[current]:\\n            self._swap(parent, current)\\n            current = parent\\n            parent = (current - 1) / 2\\n\\n    def _removeLastNode(self):\\n        rmNode = self._data.pop(-1)\\n        self._cap -= 1\\n        self._maxIdx -= 1\\n        self._hashMap.pop(rmNode.val)\\n\\n    def _removeByIdx(self, idx):\\n        thisNode = self._data[idx]\\n        retVal = thisNode.val\\n        if thisNode.cnt > 1:\\n            thisNode.cnt -= 1\\n            self._cap -= 1\\n        elif idx == self._maxIdx:\\n            # the node itself is the last node\\n            self._removeLastNode()\\n        else:\\n            self._swap(idx, self._maxIdx)\\n            self._removeLastNode()\\n            pidx = (idx - 1) / 2\\n            # check to see we should sift up or sift down\\n            if pidx >= 0 and self._data[pidx] > self._data[idx]:\\n                self._siftUp(idx)\\n            else:\\n                self._siftDown(idx)\\n        return retVal\\n\\n    @property\\n    def length(self):\\n        \"\"\"\\n        Return the number of elements in the Hash Heap\\n        \"\"\"\\n        return self._cap\\n\\n    def heapPeep(self):\\n        \"\"\"\\n        Return the MIN element in the Hash Heap\\n        \"\"\"\\n        if not self._data:\\n            return float(\"inf\")\\n        return self._data[0].val\\n\\n    def heapPop(self):\\n        \"\"\"\\n        Remove the MIN element from the Hash Heap and return its value\\n        \"\"\"\\n        return self._removeByIdx(0)\\n\\n    def heapPush(self, elem):\\n        \"\"\"\\n        Push a new element into the Hash Heap\\n        \"\"\"\\n        self._cap += 1\\n        if elem not in self._hashMap:\\n            self._maxIdx += 1\\n            self._data.append(HeapNode(elem, 1))\\n            self._hashMap[elem] = self._maxIdx\\n            self._siftUp(self._maxIdx)\\n        else:\\n            idx = self._hashMap[elem]\\n            self._data[idx].cnt += 1\\n        \\n    def heapRemove(self, elem):\\n        \"\"\"\\n        Remove a existing element from the Hash Heap\\n        If the element to be removed is not in the Hash Heap, raise an error.\\n        \"\"\"\\n        if elem not in self._hashMap:\\n            raise ValueError(\"Element to be removed is not in HashHeap!!!\")\\n        idx = self._hashMap[elem]\\n        self._removeByIdx(idx)\\n\\n    def __contains__(self, value):\\n        return value in self._hashMap\\n\\n    def __str__(self):\\n        return \"%s\" % [elem.val for elem in self._data]\\n    __repr__ = __str__\\n\\n\\ndef pushpopTest():\\n    \"\"\"\\n    Randomly generate a list, and push each element into the heap.\\n    Test HeapPush by comparing the first element in the heap with the \\n    smallest element in the List.\\n    Test HeapPop by comparing the popped element from the heap with the\\n    sorted list one by one. \\n    \"\"\"\\n    for _ in xrange(100):\\n        thisHeap = HashHeap([0])\\n        testList = [0]\\n        for i in xrange(1000):\\n            thisRandom = random.randrange(-100, 100000)\\n            thisHeap.heapPush(thisRandom)\\n            testList.append(thisRandom)\\n            assert min(testList) == thisHeap.heapPeep()\\n            assert len(testList) == thisHeap.length\\n            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1\\n        testList.sort()\\n        assert len(testList) == thisHeap.length\\n        for idx, num in enumerate(testList):\\n            assert num == thisHeap.heapPop()\\n            assert len(testList) - 1 - idx == thisHeap.length\\n            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1\\n\\ndef removeTest():\\n    \"\"\"\\n    Randomly generate a list, and push each element into the heap.\\n    Test HeapRemove by randomly delete one element from the heap by the probability\\n    of 0.2, and then check whether the first element in the heap is the same as the\\n    smallest element in the list.\\n    \"\"\"\\n    for _ in xrange(100):\\n        thisHeap = HashHeap([0])\\n        testList = [0]\\n        for i in xrange(1000):\\n            thisRandom = random.randrange(-100, 100000)\\n            thisHeap.heapPush(thisRandom)\\n            if random.random() < 0.2:\\n                thisHeap.heapRemove(thisRandom)\\n            else:\\n                testList.append(thisRandom)\\n            assert min(testList) == thisHeap.heapPeep()\\n            assert len(testList) == thisHeap.length\\n            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1\\n        testList.sort()\\n        assert len(testList) == thisHeap.length\\n        for idx, num in enumerate(testList):\\n            assert num == thisHeap.heapPop()\\n            assert len(testList) - 1 - idx == thisHeap.length\\n            assert len(thisHeap._hashMap) == thisHeap._maxIdx + 1\\n\\n\\nif __name__ == '__main__':\\n    pushpopTest()\\n    removeTest()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554533,
                "title": "c-sliding-window-solution-using-multiset-solution-updated-after-recently-added-testcase",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> ans;\\n        multiset<double> window(begin(nums), begin(nums) + k);\\n        auto it = next(begin(window), (k - 1) / 2);      //take the iterator to mid position\\n         \\n        for(int i=k; ;++i){\\n            const double median = ((k & 1) ? *it : (*it + *next(it)) / 2.);\\n            ans.emplace_back(median);\\n            \\n            if(i == nums.size()) break;\\n            \\n            window.insert(nums[i]);\\n            \\n            if(nums[i] < *it)    // If the inserted number is smaller than mid, obviously the iterator must have moved one position ahead..... which means we should take it one step backwards\\n                --it;\\n            if(nums[i - k] <= *it)    // If the number inserted k steps before is smaller than or equal to the mid, the iterator must have moved one position backwards, because of which we should move it forward by one.\\n                ++it;\\n            \\n            window.erase(window.lower_bound(nums[i - k]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> ans;\\n        multiset<double> window(begin(nums), begin(nums) + k);\\n        auto it = next(begin(window), (k - 1) / 2);      //take the iterator to mid position\\n         \\n        for(int i=k; ;++i){\\n            const double median = ((k & 1) ? *it : (*it + *next(it)) / 2.);\\n            ans.emplace_back(median);\\n            \\n            if(i == nums.size()) break;\\n            \\n            window.insert(nums[i]);\\n            \\n            if(nums[i] < *it)    // If the inserted number is smaller than mid, obviously the iterator must have moved one position ahead..... which means we should take it one step backwards\\n                --it;\\n            if(nums[i - k] <= *it)    // If the number inserted k steps before is smaller than or equal to the mid, the iterator must have moved one position backwards, because of which we should move it forward by one.\\n                ++it;\\n            \\n            window.erase(window.lower_bound(nums[i - k]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760402,
                "title": "using-arraylist-in-java-faster-than-99-of-the-codes",
                "content": "```\\npublic double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res=new double[nums.length-k+1];\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int i=0;i<k;i++){ // used to get the first window only\\n            list.add(nums[i]);\\n        }\\n        Collections.sort(list);\\n        res[0] = (k%2==0) ? ((double)list.get(k/2-1) + (double)list.get(k/2))/2 : list.get(k/2);\\n\\t\\t\\n\\t\\t// if there are more than one window \\n        for(int i=0;i<nums.length-k;i++){\\n            int left=nums[i];  // number to be removed from the window\\n            int right=nums[i+k];  // number to be added to the window\\n            int index=Collections.binarySearch(list,right);\\n            if(index>=0)  // if already present insert at the already existing position\\n\\t\\t\\t\\tlist.add(index,right);\\n            else\\n\\t\\t\\t\\tlist.add(-index-1,right);\\n\\t\\t\\t/* if element is not present binarySearch returns\\n\\t\\t\\t-(index)-1 which is the index at which it should be inserted to\\n\\t\\t\\tbe in the correct order.*/ \\n            index=Collections.binarySearch(list,left);\\n            list.remove(index);\\n            res[i+1]=(k%2==0)?((double)list.get(k/2-1)+(double)list.get(k/2))/2:list.get(k/2);\\n        }\\n        return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\npublic double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res=new double[nums.length-k+1];\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(int i=0;i<k;i++){ // used to get the first window only\\n            list.add(nums[i]);\\n        }\\n        Collections.sort(list);\\n        res[0] = (k%2==0) ? ((double)list.get(k/2-1) + (double)list.get(k/2))/2 : list.get(k/2);\\n\\t\\t\\n\\t\\t// if there are more than one window \\n        for(int i=0;i<nums.length-k;i++){\\n            int left=nums[i];  // number to be removed from the window\\n            int right=nums[i+k];  // number to be added to the window\\n            int index=Collections.binarySearch(list,right);\\n            if(index>=0)  // if already present insert at the already existing position\\n\\t\\t\\t\\tlist.add(index,right);\\n            else\\n\\t\\t\\t\\tlist.add(-index-1,right);\\n\\t\\t\\t/* if element is not present binarySearch returns\\n\\t\\t\\t-(index)-1 which is the index at which it should be inserted to\\n\\t\\t\\tbe in the correct order.*/ \\n            index=Collections.binarySearch(list,left);\\n            list.remove(index);\\n            res[i+1]=(k%2==0)?((double)list.get(k/2-1)+(double)list.get(k/2))/2:list.get(k/2);\\n        }\\n        return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597445,
                "title": "javascript-solution-binary-search-81-100",
                "content": "Idea behind this solution is to use binary search to insert right number and remove left number when moving the sliding window to the right.\\n\\nRuntime: 108 ms, faster than 81.03% of JavaScript online submissions for Sliding Window Median.\\nMemory Usage: 40 MB, less than 100.00% of JavaScript online submissions for Sliding Window Median.\\n\\n```\\nfunction binarySearch(arr, target, l, r) {\\n  while (l < r) {\\n    const mid = Math.floor((l + r) / 2);\\n    if (arr[mid] < target)  l = mid + 1;\\n    else if (arr[mid] > target) r = mid;\\n    else return mid;\\n  }\\n  if (l === r) return arr[l] >= target ? l : l + 1;\\n}\\n\\n\\nfunction medianSlidingWindow(nums, k) {\\n  let l = 0, r = k - 1, ret = [];\\n  // Create and sort window\\n  const window = nums.slice(l, k);\\n  window.sort((a, b) => a - b);\\n  while (r < nums.length) {\\n    // Calculate median and add it to the return array\\n    const median = k % 2 === 0\\n      ? (window[Math.floor(k / 2) - 1] + window[Math.floor(k / 2)]) / 2\\n      : window[Math.floor(k / 2)];\\n    ret.push(median);\\n  \\n    // Remove char from the left\\n    let char = nums[l++];\\n    let index = binarySearch(window, char, 0, window.length - 1);\\n    window.splice(index, 1);\\n\\n    // Add char from the right\\n    char = nums[++r];\\n    index = binarySearch(window, char, 0, window.length - 1);\\n    window.splice(index, 0, char);\\n  }\\n  return ret;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction binarySearch(arr, target, l, r) {\\n  while (l < r) {\\n    const mid = Math.floor((l + r) / 2);\\n    if (arr[mid] < target)  l = mid + 1;\\n    else if (arr[mid] > target) r = mid;\\n    else return mid;\\n  }\\n  if (l === r) return arr[l] >= target ? l : l + 1;\\n}\\n\\n\\nfunction medianSlidingWindow(nums, k) {\\n  let l = 0, r = k - 1, ret = [];\\n  // Create and sort window\\n  const window = nums.slice(l, k);\\n  window.sort((a, b) => a - b);\\n  while (r < nums.length) {\\n    // Calculate median and add it to the return array\\n    const median = k % 2 === 0\\n      ? (window[Math.floor(k / 2) - 1] + window[Math.floor(k / 2)]) / 2\\n      : window[Math.floor(k / 2)];\\n    ret.push(median);\\n  \\n    // Remove char from the left\\n    let char = nums[l++];\\n    let index = binarySearch(window, char, 0, window.length - 1);\\n    window.splice(index, 1);\\n\\n    // Add char from the right\\n    char = nums[++r];\\n    index = binarySearch(window, char, 0, window.length - 1);\\n    window.splice(index, 0, char);\\n  }\\n  return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 475140,
                "title": "python-sortedlist-solution",
                "content": "Just to remind we have quite a standard sortedcontainers library to deal with such problems very easily in O(n log k) in contrast to practically fast but arguable from algorithmic point of view O(n k) solution that uses insort from bisect library\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if len(nums) == 0:\\n            return []\\n        ar = SortedList(nums[:k])\\n        is_odd = k % 2 == 0\\n        medians = [(ar[k//2 - 1] + ar[k//2]) / 2.0 if is_odd else ar[k//2]]\\n        for i in range(len(nums) - k):\\n            ar.discard(nums[i])\\n            ar.add(nums[i + k])\\n            medians.append((ar[k//2 - 1] + ar[k//2]) / 2.0 if is_odd else ar[k//2])\\n        return medians\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if len(nums) == 0:\\n            return []\\n        ar = SortedList(nums[:k])\\n        is_odd = k % 2 == 0\\n        medians = [(ar[k//2 - 1] + ar[k//2]) / 2.0 if is_odd else ar[k//2]]\\n        for i in range(len(nums) - k):\\n            ar.discard(nums[i])\\n            ar.add(nums[i + k])\\n            medians.append((ar[k//2 - 1] + ar[k//2]) / 2.0 if is_odd else ar[k//2])\\n        return medians\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333240,
                "title": "python-o-nlogn-using-heap",
                "content": "python heap solution with run time O(NlogN)\\n\\n```\\n    def medianSlidingWindow(self, nums, k):\\n        low, high = [], [] # heap\\n        for i in range(k):\\n            heapq.heappush(high, (nums[i], i)) # high is a min-heap\\n        for _ in range(k>>1):\\n            self.convert(high, low)\\n        ans = [high[0][0]*1. if k&1 else (high[0][0]-low[0][0])/2.]\\n        for i in range(len(nums[k:])):\\n            if nums[i+k] >= high[0][0]:\\n                heapq.heappush(high, (nums[i+k], i+k))\\n                if nums[i] <= high[0][0]: # keep the number of elements between two heap always in balance\\n                    self.convert(high, low)\\n            else:\\n                heapq.heappush(low, (-nums[i+k], i+k))\\n                if nums[i] >= high[0][0]:\\n                    self.convert(low, high)\\n            while low and low[0][1] <= i: heapq.heappop(low)\\n            while high and high[0][1] <= i: heapq.heappop(high)\\n            ans.append(high[0][0]*1. if k&1 else (high[0][0]-low[0][0])/2.)\\n        return ans\\n        \\n                    \\n    def convert(self, heap1, heap2): # convert min-heap1 to max-heap2\\n        element, index = heapq.heappop(heap1)\\n        heapq.heappush(heap2, (-element, index))\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    def medianSlidingWindow(self, nums, k):\\n        low, high = [], [] # heap\\n        for i in range(k):\\n            heapq.heappush(high, (nums[i], i)) # high is a min-heap\\n        for _ in range(k>>1):\\n            self.convert(high, low)\\n        ans = [high[0][0]*1. if k&1 else (high[0][0]-low[0][0])/2.]\\n        for i in range(len(nums[k:])):\\n            if nums[i+k] >= high[0][0]:\\n                heapq.heappush(high, (nums[i+k], i+k))\\n                if nums[i] <= high[0][0]: # keep the number of elements between two heap always in balance\\n                    self.convert(high, low)\\n            else:\\n                heapq.heappush(low, (-nums[i+k], i+k))\\n                if nums[i] >= high[0][0]:\\n                    self.convert(low, high)\\n            while low and low[0][1] <= i: heapq.heappop(low)\\n            while high and high[0][1] <= i: heapq.heappop(high)\\n            ans.append(high[0][0]*1. if k&1 else (high[0][0]-low[0][0])/2.)\\n        return ans\\n        \\n                    \\n    def convert(self, heap1, heap2): # convert min-heap1 to max-heap2\\n        element, index = heapq.heappop(heap1)\\n        heapq.heappush(heap2, (-element, index))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 788978,
                "title": "my-concise-version-with-two-treeset-java",
                "content": "This quesiton is very similar to LC295 Find Median from Data Stream. We use two PriorityQueue in that question. However, the remove(Object) is O(n) for PriorityQueue. We want O(logn), so we use TreeSet. To handle the duplicate case, we store the index instead of the array value in the TreeSet.\\n```\\npublic double[] medianSlidingWindow(int[] nums, int k) {\\n       double[] result = new double[nums.length - k + 1];\\n       int start = 0;\\n          \\n       TreeSet<Integer> lo = new TreeSet<>((a, b) -> (nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b));\\n       TreeSet<Integer> hi = new TreeSet<>((a, b) -> (nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b));\\n        \\n       for (int i = 0; i < nums.length; i++) {\\n            lo.add(i);\\n            hi.add(lo.pollLast());\\n            if(hi.size()>lo.size()) lo.add(hi.pollFirst());\\n            if (lo.size() + hi.size() == k) {\\n                result[start]=lo.size()==hi.size()? nums[lo.last()]/2.0+ nums[hi.first()]/2.0: nums[lo.last()]/1.0;\\n                if (!lo.remove(start)) hi.remove(start);\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n",
                "solutionTags": [],
                "code": "This quesiton is very similar to LC295 Find Median from Data Stream. We use two PriorityQueue in that question. However, the remove(Object) is O(n) for PriorityQueue. We want O(logn), so we use TreeSet. To handle the duplicate case, we store the index instead of the array value in the TreeSet.\\n```\\npublic double[] medianSlidingWindow(int[] nums, int k) {\\n       double[] result = new double[nums.length - k + 1];\\n       int start = 0;\\n          \\n       TreeSet<Integer> lo = new TreeSet<>((a, b) -> (nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b));\\n       TreeSet<Integer> hi = new TreeSet<>((a, b) -> (nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b));\\n        \\n       for (int i = 0; i < nums.length; i++) {\\n            lo.add(i);\\n            hi.add(lo.pollLast());\\n            if(hi.size()>lo.size()) lo.add(hi.pollFirst());\\n            if (lo.size() + hi.size() == k) {\\n                result[start]=lo.size()==hi.size()? nums[lo.last()]/2.0+ nums[hi.first()]/2.0: nums[lo.last()]/1.0;\\n                if (!lo.remove(start)) hi.remove(start);\\n                start++;\\n            }\\n        }\\n        return result;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 533110,
                "title": "swift-100-100-using-binary-search",
                "content": "```\\nclass Solution {\\n    \\n    func getMedian(_ arr: inout [Int]) -> Double {\\n        if arr.count % 2 != 0 {\\n            return Double(arr[arr.count / 2])\\n        } else {\\n            return Double((Double(arr[arr.count/2]) + Double(arr[arr.count/2 - 1])) / 2.0)\\n        }\\n    }\\n    \\n\\t\\n    func binaryRemove(_ num: Int, arr: inout [Int]) {\\n        var left = 0\\n        var right = arr.count - 1\\n        while left <= right {\\n            let mid = left + (right - left) / 2\\n            if num > arr[mid] {\\n                left = mid + 1\\n            } else if num < arr[mid] {\\n                right = mid - 1\\n            } else {\\n                left = mid\\n                break\\n            }\\n        }\\n        \\n\\t\\t// O(n)\\n        arr.remove(at: left)\\n    }\\n    \\n\\n    func binaryInsert(_ num: Int, arr: inout [Int]) {\\n        var left = 0\\n        var right = arr.count - 1\\n        while left <= right {\\n            let mid = left + (right - left) / 2\\n            if num > arr[mid] {\\n                left = mid + 1\\n            } else if num < arr[mid] {\\n                right = mid - 1\\n            } else {\\n                left = mid\\n                break\\n            }\\n        }\\n\\t\\t\\n\\t\\t// O(n)\\n        arr.insert(num, at: left)\\n    }\\n    \\n    func medianSlidingWindow(_ nums: [Int], _ k: Int) -> [Double] {\\n        guard nums.count > 0 else { return [] }\\n        var medians = [Double]()\\n        var slidingWindow = [Int]()\\n        \\n        for i in 0..<nums.count {\\n            if i < k  {\\n                binaryInsert(nums[i], arr: &slidingWindow)\\n            } else {\\n                medians.append(getMedian(&slidingWindow))\\n                binaryRemove(nums[i-k], arr: &slidingWindow)\\n                binaryInsert(nums[i], arr: &slidingWindow)\\n\\n            }\\n        }\\n        medians.append(getMedian(&slidingWindow))\\n        return medians\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    func getMedian(_ arr: inout [Int]) -> Double {\\n        if arr.count % 2 != 0 {\\n            return Double(arr[arr.count / 2])\\n        } else {\\n            return Double((Double(arr[arr.count/2]) + Double(arr[arr.count/2 - 1])) / 2.0)\\n        }\\n    }\\n    \\n\\t\\n    func binaryRemove(_ num: Int, arr: inout [Int]) {\\n        var left = 0\\n        var right = arr.count - 1\\n        while left <= right {\\n            let mid = left + (right - left) / 2\\n            if num > arr[mid] {\\n                left = mid + 1\\n            } else if num < arr[mid] {\\n                right = mid - 1\\n            } else {\\n                left = mid\\n                break\\n            }\\n        }\\n        \\n\\t\\t// O(n)\\n        arr.remove(at: left)\\n    }\\n    \\n\\n    func binaryInsert(_ num: Int, arr: inout [Int]) {\\n        var left = 0\\n        var right = arr.count - 1\\n        while left <= right {\\n            let mid = left + (right - left) / 2\\n            if num > arr[mid] {\\n                left = mid + 1\\n            } else if num < arr[mid] {\\n                right = mid - 1\\n            } else {\\n                left = mid\\n                break\\n            }\\n        }\\n\\t\\t\\n\\t\\t// O(n)\\n        arr.insert(num, at: left)\\n    }\\n    \\n    func medianSlidingWindow(_ nums: [Int], _ k: Int) -> [Double] {\\n        guard nums.count > 0 else { return [] }\\n        var medians = [Double]()\\n        var slidingWindow = [Int]()\\n        \\n        for i in 0..<nums.count {\\n            if i < k  {\\n                binaryInsert(nums[i], arr: &slidingWindow)\\n            } else {\\n                medians.append(getMedian(&slidingWindow))\\n                binaryRemove(nums[i-k], arr: &slidingWindow)\\n                binaryInsert(nums[i], arr: &slidingWindow)\\n\\n            }\\n        }\\n        medians.append(getMedian(&slidingWindow))\\n        return medians\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505791,
                "title": "c-sortedlist",
                "content": "C# SortedList\\n```\\npublic class Solution\\n{\\n    public double[] MedianSlidingWindow(int[] nums, int k)\\n    {\\n        var res = new List<double>();\\n        var sl = new SortedList<long, int>();\\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            sl.Add(GetId(i, nums), nums[i]);\\n            if (sl.Count > k)\\n            {\\n                sl.Remove(GetId(i - k, nums));\\n            }\\n            if (sl.Count == k)\\n            {\\n                if (k % 2 == 0) res.Add((sl[sl.Keys[k / 2 - 1]] / 2.0 + sl[sl.Keys[k / 2]] / 2.0));\\n                else res.Add(sl[sl.Keys[k / 2]]);\\n            }\\n        }\\n\\n        return res.ToArray();\\n    }\\n\\n    public long GetId(int i, int[] nums)\\n    {\\n        return Convert.ToInt64(nums[i]) * nums.Length + i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public double[] MedianSlidingWindow(int[] nums, int k)\\n    {\\n        var res = new List<double>();\\n        var sl = new SortedList<long, int>();\\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            sl.Add(GetId(i, nums), nums[i]);\\n            if (sl.Count > k)\\n            {\\n                sl.Remove(GetId(i - k, nums));\\n            }\\n            if (sl.Count == k)\\n            {\\n                if (k % 2 == 0) res.Add((sl[sl.Keys[k / 2 - 1]] / 2.0 + sl[sl.Keys[k / 2]] / 2.0));\\n                else res.Add(sl[sl.Keys[k / 2]]);\\n            }\\n        }\\n\\n        return res.ToArray();\\n    }\\n\\n    public long GetId(int i, int[] nums)\\n    {\\n        return Convert.ToInt64(nums[i]) * nums.Length + i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478904,
                "title": "javascript-2-heaps-binary-search-2-approaches",
                "content": "# 2 Heaps\\nSlower than below but better at scale\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar medianSlidingWindow = function(nums, k) {\\n  const window = new Window();\\n  for (let i = 0; i < k - 1; i++) window.add(nums[i]);\\n  let res = [];\\n  for (let i = k - 1; i < nums.length; i++) {\\n    window.add(nums[i]);\\n    res.push(window.median());\\n    window.remove(nums[i - k + 1]);\\n  }\\n  return res;\\n};\\n\\nclass Window {\\n  constructor() {\\n    this.minHeap = new Heap((a,b) => a < b);\\n    this.maxHeap = new Heap((a,b) => a > b);\\n  }\\n\\n  add(value) {\\n    this.heap(value).add(value);\\n    this.balance();\\n  }\\n\\n  remove(value) {\\n    this.heap(value).remove(value);\\n    this.balance();\\n  }\\n\\n  median() {\\n    if (this.minHeap.size() === this.maxHeap.size()) {\\n      return (this.minHeap.peak() + this.maxHeap.peak()) / 2;\\n    }\\n    return this.minHeap.peak();\\n  }\\n\\n  heap(value) {\\n    return BigInt(value) < this.median() ? this.maxHeap : this.minHeap\\n  }\\n\\n  balance() {\\n    const diff = this.maxHeap.size() - this.minHeap.size()\\n    if (diff > 0) this.minHeap.add(this.maxHeap.pop());\\n    else if (diff < -1) this.maxHeap.add(this.minHeap.pop());\\n  }\\n}\\n\\nclass Heap {\\n  constructor(fn) {\\n    this.store = [];\\n    this.fn = fn;\\n  }\\n\\n  peak() {\\n    return this.store[0] || 0;\\n  }\\n\\n  size() {\\n    return this.store.length;\\n  }\\n\\n  isEmpty() {\\n    return this.store.length === 0;\\n  }\\n\\n  add(value) {\\n    this.store.push(value);\\n    this.heapifyUp(this.store.length - 1);\\n  }\\n\\n  remove(value) {\\n    const idx = this.store.indexOf(value);\\n    if (idx === this.store.length - 1) return this.store.pop();\\n    this.store[idx] = this.store.pop()\\n    this.heapifyDown(this.heapifyUp(idx));\\n  }\\n\\n  pop() {\\n    if (this.store.length < 2) return this.store.pop();\\n    const result = this.store[0];\\n    this.store[0] = this.store.pop();\\n    this.heapifyDown(0);\\n    return result;\\n  }\\n\\n  heapifyDown(parent) {\\n    const childs = [1,2].map((n) => parent * 2 + n).filter((n) => n < this.store.length);\\n    let child = childs[0];\\n    if (childs[1] && this.fn(this.store[childs[1]], this.store[child])) {\\n      child = childs[1];\\n    }\\n    if (child && this.fn(this.store[child], this.store[parent])) {\\n      const temp = this.store[child];\\n      this.store[child] = this.store[parent];\\n      this.store[parent] = temp;\\n      return this.heapifyDown(child);\\n    }\\n    return parent;\\n  }\\n\\n  heapifyUp(child) {\\n    const parent = Math.floor((child - 1) / 2);\\n    if (child && this.fn(this.store[child], this.store[parent])) {\\n      const temp = this.store[child];\\n      this.store[child] = this.store[parent];\\n      this.store[parent] = temp;\\n      return this.heapifyUp(parent);\\n    }\\n    return child;\\n  }\\n}\\n```\\n# Indexed Heap Implementation for logn removal\\n```javascript\\nclass Heap {\\n  constructor(fn) {\\n    this.store = [];\\n    this.fn = fn;\\n    this.idxs = {};\\n  }\\n\\n  peak() {\\n    return this.store[0] || 0;\\n  }\\n\\n  size() {\\n    return this.store.length;\\n  }\\n\\n  isEmpty() {\\n    return this.store.length === 0;\\n  }\\n\\n  add(value) {\\n    this.store.push(value);\\n    const idx = this.store.length - 1;\\n    if (!this.idxs[value]) this.idxs[value] = new Set([idx]);\\n    else this.idxs[value].add(idx)\\n    this.heapifyUp(idx);\\n  }\\n\\n  remove(value) {\\n    let idx;\\n    for (let i of this.idxs[value]) {\\n      idx = i;\\n      break;\\n    }\\n    this.idxs[value].delete(idx);\\n    if (idx === this.store.length - 1) return this.store.pop();\\n    this.store[idx] = this.store.pop()\\n    this.idxs[this.store[idx]].delete(this.store.length);\\n    this.idxs[this.store[idx]].add(idx);\\n    this.heapifyDown(this.heapifyUp(idx));\\n  }\\n\\n  pop() {\\n    const value = this.store[0];\\n    this.idxs[value].delete(0);\\n    if (this.store.length < 2) return this.store.pop();\\n    this.store[0] = this.store.pop();\\n    this.idxs[this.store[0]].delete(this.store.length);\\n    this.idxs[this.store[0]].add(0);\\n    this.heapifyDown(0);\\n    return value;\\n  }\\n\\n  heapifyDown(parent) {\\n    const childs = [1,2].map((n) => parent * 2 + n).filter((n) => n < this.store.length);\\n    let child = childs[0];\\n    if (childs[1] && this.fn(this.store[childs[1]], this.store[child])) {\\n      child = childs[1];\\n    }\\n    if (child && this.fn(this.store[child], this.store[parent])) {\\n      const childVal = this.store[child];\\n      const parentVal = this.store[parent];\\n      this.store[child] = parentVal;\\n      this.store[parent] = childVal;\\n      this.idxs[childVal].delete(child);\\n      this.idxs[childVal].add(parent);\\n      this.idxs[parentVal].delete(parent);\\n      this.idxs[parentVal].add(child);\\n      return this.heapifyDown(child);\\n    }\\n    return parent;\\n  }\\n\\n  heapifyUp(child) {\\n    const parent = Math.floor((child - 1) / 2);\\n    if (child && this.fn(this.store[child], this.store[parent])) {\\n      const childVal = this.store[child];\\n      const parentVal = this.store[parent];\\n      this.store[child] = parentVal;\\n      this.store[parent] = childVal;\\n      this.idxs[childVal].delete(child);\\n      this.idxs[childVal].add(parent);\\n      this.idxs[parentVal].delete(parent);\\n      this.idxs[parentVal].add(child);\\n      return this.heapifyUp(parent);\\n    }\\n    return child;\\n  }\\n}\\n```\\n\\n# Binary Search Deletion (fastest on LC but not at scale)\\n```javascript\\nclass Window {\\n    constructor() {\\n        this.store = [];\\n    }\\n    \\n    add(value) {\\n        let idx = this.indexOf(value);\\n        if (value > this.store[idx]) idx++;\\n        this.store.splice(idx, 0, value);\\n    }\\n    \\n    remove(value) {\\n        const idx = this.indexOf(value);\\n        this.store.splice(idx, 1);\\n    }\\n    \\n    median() {\\n        const mid = Math.floor((this.store.length / 2));\\n        const median = this.store[mid];\\n        return this.store.length % 2 ? median : (median + this.store[mid - 1]) / 2;\\n    }\\n    \\n    indexOf(value) {\\n        let lo = 0;\\n        let hi = this.store.length - 1;\\n        while (lo < hi) {\\n            const mid = Math.floor((lo + hi) / 2);\\n            if (this.store[mid] < value) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo\\n    }\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar medianSlidingWindow = function(nums, k) {\\n    const window = new Window();\\n    for (let i = 0; i < k - 1; i++) {\\n        window.add(nums[i]);\\n    }\\n    const result = [];\\n    for (let i = k - 1; i < nums.length; i++) {\\n        window.add(nums[i]);        \\n        result.push(window.median());\\n        window.remove(nums[i - k + 1]);\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar medianSlidingWindow = function(nums, k) {\\n  const window = new Window();\\n  for (let i = 0; i < k - 1; i++) window.add(nums[i]);\\n  let res = [];\\n  for (let i = k - 1; i < nums.length; i++) {\\n    window.add(nums[i]);\\n    res.push(window.median());\\n    window.remove(nums[i - k + 1]);\\n  }\\n  return res;\\n};\\n\\nclass Window {\\n  constructor() {\\n    this.minHeap = new Heap((a,b) => a < b);\\n    this.maxHeap = new Heap((a,b) => a > b);\\n  }\\n\\n  add(value) {\\n    this.heap(value).add(value);\\n    this.balance();\\n  }\\n\\n  remove(value) {\\n    this.heap(value).remove(value);\\n    this.balance();\\n  }\\n\\n  median() {\\n    if (this.minHeap.size() === this.maxHeap.size()) {\\n      return (this.minHeap.peak() + this.maxHeap.peak()) / 2;\\n    }\\n    return this.minHeap.peak();\\n  }\\n\\n  heap(value) {\\n    return BigInt(value) < this.median() ? this.maxHeap : this.minHeap\\n  }\\n\\n  balance() {\\n    const diff = this.maxHeap.size() - this.minHeap.size()\\n    if (diff > 0) this.minHeap.add(this.maxHeap.pop());\\n    else if (diff < -1) this.maxHeap.add(this.minHeap.pop());\\n  }\\n}\\n\\nclass Heap {\\n  constructor(fn) {\\n    this.store = [];\\n    this.fn = fn;\\n  }\\n\\n  peak() {\\n    return this.store[0] || 0;\\n  }\\n\\n  size() {\\n    return this.store.length;\\n  }\\n\\n  isEmpty() {\\n    return this.store.length === 0;\\n  }\\n\\n  add(value) {\\n    this.store.push(value);\\n    this.heapifyUp(this.store.length - 1);\\n  }\\n\\n  remove(value) {\\n    const idx = this.store.indexOf(value);\\n    if (idx === this.store.length - 1) return this.store.pop();\\n    this.store[idx] = this.store.pop()\\n    this.heapifyDown(this.heapifyUp(idx));\\n  }\\n\\n  pop() {\\n    if (this.store.length < 2) return this.store.pop();\\n    const result = this.store[0];\\n    this.store[0] = this.store.pop();\\n    this.heapifyDown(0);\\n    return result;\\n  }\\n\\n  heapifyDown(parent) {\\n    const childs = [1,2].map((n) => parent * 2 + n).filter((n) => n < this.store.length);\\n    let child = childs[0];\\n    if (childs[1] && this.fn(this.store[childs[1]], this.store[child])) {\\n      child = childs[1];\\n    }\\n    if (child && this.fn(this.store[child], this.store[parent])) {\\n      const temp = this.store[child];\\n      this.store[child] = this.store[parent];\\n      this.store[parent] = temp;\\n      return this.heapifyDown(child);\\n    }\\n    return parent;\\n  }\\n\\n  heapifyUp(child) {\\n    const parent = Math.floor((child - 1) / 2);\\n    if (child && this.fn(this.store[child], this.store[parent])) {\\n      const temp = this.store[child];\\n      this.store[child] = this.store[parent];\\n      this.store[parent] = temp;\\n      return this.heapifyUp(parent);\\n    }\\n    return child;\\n  }\\n}\\n```\n```javascript\\nclass Heap {\\n  constructor(fn) {\\n    this.store = [];\\n    this.fn = fn;\\n    this.idxs = {};\\n  }\\n\\n  peak() {\\n    return this.store[0] || 0;\\n  }\\n\\n  size() {\\n    return this.store.length;\\n  }\\n\\n  isEmpty() {\\n    return this.store.length === 0;\\n  }\\n\\n  add(value) {\\n    this.store.push(value);\\n    const idx = this.store.length - 1;\\n    if (!this.idxs[value]) this.idxs[value] = new Set([idx]);\\n    else this.idxs[value].add(idx)\\n    this.heapifyUp(idx);\\n  }\\n\\n  remove(value) {\\n    let idx;\\n    for (let i of this.idxs[value]) {\\n      idx = i;\\n      break;\\n    }\\n    this.idxs[value].delete(idx);\\n    if (idx === this.store.length - 1) return this.store.pop();\\n    this.store[idx] = this.store.pop()\\n    this.idxs[this.store[idx]].delete(this.store.length);\\n    this.idxs[this.store[idx]].add(idx);\\n    this.heapifyDown(this.heapifyUp(idx));\\n  }\\n\\n  pop() {\\n    const value = this.store[0];\\n    this.idxs[value].delete(0);\\n    if (this.store.length < 2) return this.store.pop();\\n    this.store[0] = this.store.pop();\\n    this.idxs[this.store[0]].delete(this.store.length);\\n    this.idxs[this.store[0]].add(0);\\n    this.heapifyDown(0);\\n    return value;\\n  }\\n\\n  heapifyDown(parent) {\\n    const childs = [1,2].map((n) => parent * 2 + n).filter((n) => n < this.store.length);\\n    let child = childs[0];\\n    if (childs[1] && this.fn(this.store[childs[1]], this.store[child])) {\\n      child = childs[1];\\n    }\\n    if (child && this.fn(this.store[child], this.store[parent])) {\\n      const childVal = this.store[child];\\n      const parentVal = this.store[parent];\\n      this.store[child] = parentVal;\\n      this.store[parent] = childVal;\\n      this.idxs[childVal].delete(child);\\n      this.idxs[childVal].add(parent);\\n      this.idxs[parentVal].delete(parent);\\n      this.idxs[parentVal].add(child);\\n      return this.heapifyDown(child);\\n    }\\n    return parent;\\n  }\\n\\n  heapifyUp(child) {\\n    const parent = Math.floor((child - 1) / 2);\\n    if (child && this.fn(this.store[child], this.store[parent])) {\\n      const childVal = this.store[child];\\n      const parentVal = this.store[parent];\\n      this.store[child] = parentVal;\\n      this.store[parent] = childVal;\\n      this.idxs[childVal].delete(child);\\n      this.idxs[childVal].add(parent);\\n      this.idxs[parentVal].delete(parent);\\n      this.idxs[parentVal].add(child);\\n      return this.heapifyUp(parent);\\n    }\\n    return child;\\n  }\\n}\\n```\n```javascript\\nclass Window {\\n    constructor() {\\n        this.store = [];\\n    }\\n    \\n    add(value) {\\n        let idx = this.indexOf(value);\\n        if (value > this.store[idx]) idx++;\\n        this.store.splice(idx, 0, value);\\n    }\\n    \\n    remove(value) {\\n        const idx = this.indexOf(value);\\n        this.store.splice(idx, 1);\\n    }\\n    \\n    median() {\\n        const mid = Math.floor((this.store.length / 2));\\n        const median = this.store[mid];\\n        return this.store.length % 2 ? median : (median + this.store[mid - 1]) / 2;\\n    }\\n    \\n    indexOf(value) {\\n        let lo = 0;\\n        let hi = this.store.length - 1;\\n        while (lo < hi) {\\n            const mid = Math.floor((lo + hi) / 2);\\n            if (this.store[mid] < value) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo\\n    }\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar medianSlidingWindow = function(nums, k) {\\n    const window = new Window();\\n    for (let i = 0; i < k - 1; i++) {\\n        window.add(nums[i]);\\n    }\\n    const result = [];\\n    for (let i = k - 1; i < nums.length; i++) {\\n        window.add(nums[i]);        \\n        result.push(window.median());\\n        window.remove(nums[i - k + 1]);\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468794,
                "title": "java-solution-using-2-heap-simplify",
                "content": "```\\nclass Solution {\\n    PriorityQueue<Integer> maxHeap; // 1st part\\n    PriorityQueue<Integer> minHeap; // 2nd part\\n    \\n    public Solution() {\\n        // use Collections.reverseOrder() as comparator as this will work when input number as max integer, can\\'t use (a,b)->b-a\\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder()); \\n        minHeap = new PriorityQueue<>();\\n    }\\n    \\n    void addNum(int n) {\\n        if(maxHeap.size()==0 || n <= maxHeap.peek()) {\\n            maxHeap.offer(n);        \\n        } else {\\n            minHeap.offer(n);\\n        }\\n        \\n        rebalance();\\n    }\\n    \\n    void remove(int num) {\\n        if(num <= maxHeap.peek()) maxHeap.remove(num);\\n        else minHeap.remove(num);\\n        rebalance();\\n    }\\n    \\n    void rebalance() {\\n        if(minHeap.size() > maxHeap.size()) maxHeap.offer(minHeap.poll());\\n        // max heap can has one extra node than min heap, as we will use for returning the median when total input size is odd number\\n        else if(maxHeap.size() > minHeap.size() + 1) minHeap.offer(maxHeap.poll());\\n    }\\n    \\n    double findMedian() {\\n        if(maxHeap.size() ==  minHeap.size()) return maxHeap.peek()/2.0 + minHeap.peek() /2.0;\\n        else return maxHeap.peek();\\n    }\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int start = 0;\\n        double[] result = new double[nums.length - k + 1 ];\\n        \\n        for(int end=0; end < nums.length; end++) {\\n            addNum(nums[end]);\\n            if(end + 1 >= k) {// shrink the window & calculate the median\\n                result[start] = findMedian();\\n                remove(nums[start]); // remove the start number as we move forward the next window size\\n                start++; // move start window ahead\\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    PriorityQueue<Integer> maxHeap; // 1st part\\n    PriorityQueue<Integer> minHeap; // 2nd part\\n    \\n    public Solution() {\\n        // use Collections.reverseOrder() as comparator as this will work when input number as max integer, can\\'t use (a,b)->b-a\\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder()); \\n        minHeap = new PriorityQueue<>();\\n    }\\n    \\n    void addNum(int n) {\\n        if(maxHeap.size()==0 || n <= maxHeap.peek()) {\\n            maxHeap.offer(n);        \\n        } else {\\n            minHeap.offer(n);\\n        }\\n        \\n        rebalance();\\n    }\\n    \\n    void remove(int num) {\\n        if(num <= maxHeap.peek()) maxHeap.remove(num);\\n        else minHeap.remove(num);\\n        rebalance();\\n    }\\n    \\n    void rebalance() {\\n        if(minHeap.size() > maxHeap.size()) maxHeap.offer(minHeap.poll());\\n        // max heap can has one extra node than min heap, as we will use for returning the median when total input size is odd number\\n        else if(maxHeap.size() > minHeap.size() + 1) minHeap.offer(maxHeap.poll());\\n    }\\n    \\n    double findMedian() {\\n        if(maxHeap.size() ==  minHeap.size()) return maxHeap.peek()/2.0 + minHeap.peek() /2.0;\\n        else return maxHeap.peek();\\n    }\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int start = 0;\\n        double[] result = new double[nums.length - k + 1 ];\\n        \\n        for(int end=0; end < nums.length; end++) {\\n            addNum(nums[end]);\\n            if(end + 1 >= k) {// shrink the window & calculate the median\\n                result[start] = findMedian();\\n                remove(nums[start]); // remove the start number as we move forward the next window size\\n                start++; // move start window ahead\\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96345,
                "title": "easy-to-understand-python-solution-o-nk",
                "content": "\\n```\\nclass Solution(object):\\n    def medianSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[float]\\n        \"\"\"\\n        medians = []\\n        sortedwindow = sorted(nums[ : k])\\n        medians.append((sortedwindow[k/2] + sortedwindow[k/2 - (k%2 ==0)])/2.)\\n        \\n        for i in range(len(nums) - k):\\n            \\n            sortedwindow.remove(nums[i])\\n            bisect.insort(sortedwindow, nums[k+i])\\n            medians.append((sortedwindow[k/2] + sortedwindow[k/2 - (k%2 ==0)])/2.)\\n            \\n        return medians\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def medianSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[float]\\n        \"\"\"\\n        medians = []\\n        sortedwindow = sorted(nums[ : k])\\n        medians.append((sortedwindow[k/2] + sortedwindow[k/2 - (k%2 ==0)])/2.)\\n        \\n        for i in range(len(nums) - k):\\n            \\n            sortedwindow.remove(nums[i])\\n            bisect.insort(sortedwindow, nums[k+i])\\n            medians.append((sortedwindow[k/2] + sortedwindow[k/2 - (k%2 ==0)])/2.)\\n            \\n        return medians\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974371,
                "title": "multiset-and-advance-o-nlog-k",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n    multiset<long> s; // create a multiset to store the elements of the window\\n    vector<double> v; // create a vector to store the median values\\n        // insert the first k-1 elements into the multiset\\n        for(int i=0;i<k-1;i++)\\n            s.insert(nums[i]);\\n        \\n        // initialize the variable for the index of the element to be inserted\\n        int j=k-1;\\n        \\n        // loop through the rest of the elements\\n        while(j<nums.size()) {\\n            s.insert(nums[j]); // insert the current element into the multiset\\n            auto it=s.begin(); // initialize an iterator to the beginning of the multiset\\n            long long x; // variable to store the value of the median if k is even\\n            \\n            // if k is even, advance the iterator to the (k/2)-1th element and store it in x\\n            if(k/2>=1) {\\n                advance(it,k/2-1);\\n                x=*it;\\n                advance(it,1); // advance the iterator one more time to point to the median\\n            }\\n            // if k is odd, the median is the value pointed to by the iterator\\n            if(k%2!=0)\\n                v.push_back(double(*it)/double(1));\\n            // if k is even, the median is the average of the values pointed to by the iterator and x\\n            else\\n                v.push_back(double(*it+x)/double(2));\\n            \\n            s.erase(s.lower_bound(nums[j-k+1])); // remove the element at the beginning of the window from the multiset\\n            j++; // increment the index of the element to be inserted\\n        }\\n        return v; // return the vector of median values\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n    multiset<long> s; // create a multiset to store the elements of the window\\n    vector<double> v; // create a vector to store the median values\\n        // insert the first k-1 elements into the multiset\\n        for(int i=0;i<k-1;i++)\\n            s.insert(nums[i]);\\n        \\n        // initialize the variable for the index of the element to be inserted\\n        int j=k-1;\\n        \\n        // loop through the rest of the elements\\n        while(j<nums.size()) {\\n            s.insert(nums[j]); // insert the current element into the multiset\\n            auto it=s.begin(); // initialize an iterator to the beginning of the multiset\\n            long long x; // variable to store the value of the median if k is even\\n            \\n            // if k is even, advance the iterator to the (k/2)-1th element and store it in x\\n            if(k/2>=1) {\\n                advance(it,k/2-1);\\n                x=*it;\\n                advance(it,1); // advance the iterator one more time to point to the median\\n            }\\n            // if k is odd, the median is the value pointed to by the iterator\\n            if(k%2!=0)\\n                v.push_back(double(*it)/double(1));\\n            // if k is even, the median is the average of the values pointed to by the iterator and x\\n            else\\n                v.push_back(double(*it+x)/double(2));\\n            \\n            s.erase(s.lower_bound(nums[j-k+1])); // remove the element at the beginning of the window from the multiset\\n            j++; // increment the index of the element to be inserted\\n        }\\n        return v; // return the vector of median values\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464339,
                "title": "java-optimal-sliding-window-using-two-priorityqueues",
                "content": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        double[] result = new double[nums.length - k + 1];\\n        int p = 0;\\n        PriorityQueue<Integer> max = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Integer> min = new PriorityQueue<>();\\n        \\n        int i=0, j=0;\\n        while(j < nums.length) {\\n            \\n            if(max.size() <= min.size()) {\\n                min.add(nums[j]);\\n                max.add(min.poll());\\n            }\\n            else {\\n                max.add(nums[j]);\\n                min.add(max.poll());\\n            }\\n            if(j-i+1 < k) j++;\\n            \\n            else if(j-i+1 == k) {\\n                if(max.size() == min.size())\\n                    result[p++] = (double) ((long)max.peek() + (long)min.peek()) / 2.0;\\n                else\\n                    result[p++] = (double)max.peek();\\n                \\n                if(!max.remove(nums[i])) min.remove(nums[i]);\\n                i++; j++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        double[] result = new double[nums.length - k + 1];\\n        int p = 0;\\n        PriorityQueue<Integer> max = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Integer> min = new PriorityQueue<>();\\n        \\n        int i=0, j=0;\\n        while(j < nums.length) {\\n            \\n            if(max.size() <= min.size()) {\\n                min.add(nums[j]);\\n                max.add(min.poll());\\n            }\\n            else {\\n                max.add(nums[j]);\\n                min.add(max.poll());\\n            }\\n            if(j-i+1 < k) j++;\\n            \\n            else if(j-i+1 == k) {\\n                if(max.size() == min.size())\\n                    result[p++] = (double) ((long)max.peek() + (long)min.peek()) / 2.0;\\n                else\\n                    result[p++] = (double)max.peek();\\n                \\n                if(!max.remove(nums[i])) min.remove(nums[i]);\\n                i++; j++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331309,
                "title": "c-2-solutions-binary-search-height-balanced-tree-pointer-movement-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/sliding-window-median/\\n    \\n    1. SOLUTION 1: Binary Search\\n    \\n    The core idea is we maintain a sorted window of elements. Initially we make the 1st window and sort all its elements.\\n    Then from there onwards any insertion or deletion is done by first finding the appropriate position where the element \\n    exists/shoudl exist. This search is done using binary search.\\n    \\n    TC: O(klogk (Sorting) + (n - k) * (k + logk)), Binary search in window takes O(logk), but since it is array, insert or delete can take O(k)\\n    SC: O(k)\\n    \\n    2. SOLUTION 2: Height Balanced Tree\\n    \\n    Core idea is to use a height balanced tree to save all the elements of window. Since it is a height balanced tree, insertion and deletion takes\\n    logk. Now we directly want to reach the k/2 th element, then it takes O(k/2). So we need to optimize the mid point fetch.\\n    \\n    Initially when the 1st window is built, we find the middle element with O(k/2). Then from there onwards we always adjust the middle position\\n    by +1 or -1. Since only one element is either added or deleted at a time, so we can move the median left or right based on the situation.\\n    Eg: [1,2,3,4,5,6,7], median = 4\\n    \\n    if we add one element say 9\\n    [1,2,3,4,5,6,7,9], then check (9 < median): this means 1 extra element on right, don\\'t move and wait to see what happens on deletion\\n    \\n    Similarly, now if 2 is deleted, we can just check (2 <= median(4)): this means there will be one less element on left.\\n    So move median to right by 1. If say an element on right like 7 was deleted, we would have not moved and hence the mid ptr would be \\n    at its correct position.\\n    \\n    \\n        (1st window insertion) + remaining_windows * (delete element + add element + get middle)\\n    TC: O(klogk + (n-k) * (logk + logk + 1)) \\n        ~O(klogk + (n-k)*logk) ~O(nlogk)\\n    SC: O(k)\\n*/\\nclass Solution {\\npublic:\\n    ///////////////////// SOLUTION 1: Binary Search\\n    vector<double> binarySearchSol(vector<int>& nums, int k) {\\n        vector<double> medians;\\n        vector<int> window;\\n        // K is over the size of array\\n        if(k > nums.size())\\n            return medians;\\n        \\n        int i = 0;\\n        // add the elements of 1st window\\n        while(i < k) {\\n            window.emplace_back(nums[i]);\\n            ++i;\\n        }\\n        \\n        // sort the window\\n        sort(window.begin(), window.end());\\n        // get the median of 1st window\\n        double median = k % 2 ? window[k / 2] : (double) ((double)window[k/2 - 1] + window[k/2]) / 2;\\n        medians.emplace_back(median);\\n        \\n        for(; i < nums.size(); i++) {\\n            // search the position of 1st element of the last window using binary search\\n            auto it = lower_bound(window.begin(), window.end(), nums[i - k]);\\n            window.erase(it);\\n            // find the position to insert the new element for the current window\\n            it = lower_bound(window.begin(), window.end(), nums[i]);\\n            window.insert(it, nums[i]);\\n            // Since the window is sorted, we can directly compute the median\\n            double median = k % 2 ? window[k / 2] : (double) ((double)window[k/2 - 1] + window[k/2]) / 2;\\n            medians.emplace_back(median);\\n        }\\n        return medians;\\n    }\\n    \\n    //////////////////////////// SOLUTION 2: Height Balanced Tree\\n    vector<double> treeSol(vector<int>& nums, int k) {\\n        multiset<int> elements;\\n        vector<double> medians;\\n        \\n        int i = 0;\\n        // process the 1st window\\n        while(i < k) {\\n            elements.insert(nums[i]);\\n            ++i;\\n        }\\n        \\n        // median of 1st window\\n        auto mid = next(elements.begin(), k / 2);\\n        double median = k % 2 ? *mid : ((double)*mid + *prev(mid)) / 2;\\n        medians.emplace_back(median);\\n        \\n        for(; i < nums.size(); i++) {\\n            // insert last element of current window\\n            elements.insert(nums[i]);\\n            // If the number lies on the left, left side will have 1 more element.\\n            // So shift left by 1 pos\\n            if(nums[i] < *mid)\\n                --mid;\\n            \\n            // remove 1st element of last window\\n            auto delete_pos = elements.find(nums[i - k]);\\n            // If the element to be deleted in [first : mid], then right will have extra element\\n            // so move the mid to right by 1\\n            // NOTE: We insert the new element and then delete previous element because, if the window has just one element\\n            // then deleting first will make mid point to invalid position. But inserting first will ensure that there is an \\n            // element to point to\\n            if(nums[i-k] <= *mid)\\n                ++mid;\\n            elements.erase(delete_pos);\\n            \\n            double median = k % 2 ? *mid : ((double)*mid + *prev(mid)) / 2;\\n            medians.emplace_back(median);\\n        }\\n        \\n        return medians;\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        // return binarySearchSol(nums, k);\\n        return treeSol(nums, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Tree"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/sliding-window-median/\\n    \\n    1. SOLUTION 1: Binary Search\\n    \\n    The core idea is we maintain a sorted window of elements. Initially we make the 1st window and sort all its elements.\\n    Then from there onwards any insertion or deletion is done by first finding the appropriate position where the element \\n    exists/shoudl exist. This search is done using binary search.\\n    \\n    TC: O(klogk (Sorting) + (n - k) * (k + logk)), Binary search in window takes O(logk), but since it is array, insert or delete can take O(k)\\n    SC: O(k)\\n    \\n    2. SOLUTION 2: Height Balanced Tree\\n    \\n    Core idea is to use a height balanced tree to save all the elements of window. Since it is a height balanced tree, insertion and deletion takes\\n    logk. Now we directly want to reach the k/2 th element, then it takes O(k/2). So we need to optimize the mid point fetch.\\n    \\n    Initially when the 1st window is built, we find the middle element with O(k/2). Then from there onwards we always adjust the middle position\\n    by +1 or -1. Since only one element is either added or deleted at a time, so we can move the median left or right based on the situation.\\n    Eg: [1,2,3,4,5,6,7], median = 4\\n    \\n    if we add one element say 9\\n    [1,2,3,4,5,6,7,9], then check (9 < median): this means 1 extra element on right, don\\'t move and wait to see what happens on deletion\\n    \\n    Similarly, now if 2 is deleted, we can just check (2 <= median(4)): this means there will be one less element on left.\\n    So move median to right by 1. If say an element on right like 7 was deleted, we would have not moved and hence the mid ptr would be \\n    at its correct position.\\n    \\n    \\n        (1st window insertion) + remaining_windows * (delete element + add element + get middle)\\n    TC: O(klogk + (n-k) * (logk + logk + 1)) \\n        ~O(klogk + (n-k)*logk) ~O(nlogk)\\n    SC: O(k)\\n*/\\nclass Solution {\\npublic:\\n    ///////////////////// SOLUTION 1: Binary Search\\n    vector<double> binarySearchSol(vector<int>& nums, int k) {\\n        vector<double> medians;\\n        vector<int> window;\\n        // K is over the size of array\\n        if(k > nums.size())\\n            return medians;\\n        \\n        int i = 0;\\n        // add the elements of 1st window\\n        while(i < k) {\\n            window.emplace_back(nums[i]);\\n            ++i;\\n        }\\n        \\n        // sort the window\\n        sort(window.begin(), window.end());\\n        // get the median of 1st window\\n        double median = k % 2 ? window[k / 2] : (double) ((double)window[k/2 - 1] + window[k/2]) / 2;\\n        medians.emplace_back(median);\\n        \\n        for(; i < nums.size(); i++) {\\n            // search the position of 1st element of the last window using binary search\\n            auto it = lower_bound(window.begin(), window.end(), nums[i - k]);\\n            window.erase(it);\\n            // find the position to insert the new element for the current window\\n            it = lower_bound(window.begin(), window.end(), nums[i]);\\n            window.insert(it, nums[i]);\\n            // Since the window is sorted, we can directly compute the median\\n            double median = k % 2 ? window[k / 2] : (double) ((double)window[k/2 - 1] + window[k/2]) / 2;\\n            medians.emplace_back(median);\\n        }\\n        return medians;\\n    }\\n    \\n    //////////////////////////// SOLUTION 2: Height Balanced Tree\\n    vector<double> treeSol(vector<int>& nums, int k) {\\n        multiset<int> elements;\\n        vector<double> medians;\\n        \\n        int i = 0;\\n        // process the 1st window\\n        while(i < k) {\\n            elements.insert(nums[i]);\\n            ++i;\\n        }\\n        \\n        // median of 1st window\\n        auto mid = next(elements.begin(), k / 2);\\n        double median = k % 2 ? *mid : ((double)*mid + *prev(mid)) / 2;\\n        medians.emplace_back(median);\\n        \\n        for(; i < nums.size(); i++) {\\n            // insert last element of current window\\n            elements.insert(nums[i]);\\n            // If the number lies on the left, left side will have 1 more element.\\n            // So shift left by 1 pos\\n            if(nums[i] < *mid)\\n                --mid;\\n            \\n            // remove 1st element of last window\\n            auto delete_pos = elements.find(nums[i - k]);\\n            // If the element to be deleted in [first : mid], then right will have extra element\\n            // so move the mid to right by 1\\n            // NOTE: We insert the new element and then delete previous element because, if the window has just one element\\n            // then deleting first will make mid point to invalid position. But inserting first will ensure that there is an \\n            // element to point to\\n            if(nums[i-k] <= *mid)\\n                ++mid;\\n            elements.erase(delete_pos);\\n            \\n            double median = k % 2 ? *mid : ((double)*mid + *prev(mid)) / 2;\\n            medians.emplace_back(median);\\n        }\\n        \\n        return medians;\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        // return binarySearchSol(nums, k);\\n        return treeSol(nums, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836826,
                "title": "multiset-solution-simple-short-easy-to-understand",
                "content": "**Idea?**\\n* Maintain **two multisets** for each k size subarray.\\n* First multiset will store the first **(k+1)/2** integers while second multiset will store **k/2** elements.\\n* Note that first multiset stores element in non-increasing order while second multiset will store the elements in non-decreasing order.\\n* When *size of subarray is odd*, return the topmost element of first multiset.\\n* When *size of subarray is even*, return the **average value** of the top elements of first and second multiset.\\n* Note that at each step(while inserting and deleting elements), we need to **balance the sets** when the sizees of the sets aren\\'t the desired sizes.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Time Complexity:- O(NlogK)\\n    // Space Complexity:- O(K)\\n    \\n    #define ll long long\\n    \\n    multiset<ll> right;\\n    multiset<ll,greater<ll>> left;\\n    \\n    double GetMedian(){\\n        int n = left.size() + right.size();\\n        if(n&1){\\n            return (double)*left.begin();\\n        }\\n        return ((double)(*left.begin()+*right.begin()))/2.0;\\n    }\\n    \\n    void BalanceSets(){\\n        while((int)right.size()>(int)left.size()){\\n            left.insert(*right.begin());\\n            right.erase(right.begin());\\n        }\\n        while((int)left.size()-(int)right.size()>1){\\n            right.insert(*left.begin());\\n            left.erase(left.begin());\\n        }\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        // odd length array, size(left) - size(right) == 1\\n        // even length array, size(left) == size(right)\\n        \\n        // insert all the elements [0,k-1];\\n        for(int i=0;i<k;i++){\\n            if(left.empty()){\\n                left.insert(nums[i]);\\n            }\\n            else if(right.empty()){\\n                if(nums[i]<*left.begin()){\\n                    right.insert(*left.begin());\\n                    left.erase(left.begin());\\n                    \\n                    left.insert(nums[i]);\\n                }\\n                else{\\n                    right.insert(nums[i]);\\n                }\\n            }\\n            else{\\n                if(nums[i]<=*left.begin()){\\n                    left.insert(nums[i]);\\n                }\\n                else{\\n                    right.insert(nums[i]);\\n                }\\n            }\\n            \\n            BalanceSets();            \\n        }\\n        \\n        vector<double> ans = {GetMedian()};\\n        \\n        for(int i=k;i<n;i++){\\n            // insert nums[i]\\n            if(nums[i]<=*left.begin()){\\n                left.insert(nums[i]);\\n            }\\n            else{\\n                right.insert(nums[i]);\\n            }\\n            \\n            // delete the nums[i-k]\\n            if(left.count(nums[i-k])){\\n                left.erase(left.find(nums[i-k]));\\n            }\\n            else{\\n                right.erase(right.find(nums[i-k]));\\n            }\\n            \\n            // balance the sets\\n            BalanceSets();\\n            \\n            ans.push_back(GetMedian());            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Time Complexity:- O(NlogK)\\n    // Space Complexity:- O(K)\\n    \\n    #define ll long long\\n    \\n    multiset<ll> right;\\n    multiset<ll,greater<ll>> left;\\n    \\n    double GetMedian(){\\n        int n = left.size() + right.size();\\n        if(n&1){\\n            return (double)*left.begin();\\n        }\\n        return ((double)(*left.begin()+*right.begin()))/2.0;\\n    }\\n    \\n    void BalanceSets(){\\n        while((int)right.size()>(int)left.size()){\\n            left.insert(*right.begin());\\n            right.erase(right.begin());\\n        }\\n        while((int)left.size()-(int)right.size()>1){\\n            right.insert(*left.begin());\\n            left.erase(left.begin());\\n        }\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        // odd length array, size(left) - size(right) == 1\\n        // even length array, size(left) == size(right)\\n        \\n        // insert all the elements [0,k-1];\\n        for(int i=0;i<k;i++){\\n            if(left.empty()){\\n                left.insert(nums[i]);\\n            }\\n            else if(right.empty()){\\n                if(nums[i]<*left.begin()){\\n                    right.insert(*left.begin());\\n                    left.erase(left.begin());\\n                    \\n                    left.insert(nums[i]);\\n                }\\n                else{\\n                    right.insert(nums[i]);\\n                }\\n            }\\n            else{\\n                if(nums[i]<=*left.begin()){\\n                    left.insert(nums[i]);\\n                }\\n                else{\\n                    right.insert(nums[i]);\\n                }\\n            }\\n            \\n            BalanceSets();            \\n        }\\n        \\n        vector<double> ans = {GetMedian()};\\n        \\n        for(int i=k;i<n;i++){\\n            // insert nums[i]\\n            if(nums[i]<=*left.begin()){\\n                left.insert(nums[i]);\\n            }\\n            else{\\n                right.insert(nums[i]);\\n            }\\n            \\n            // delete the nums[i-k]\\n            if(left.count(nums[i-k])){\\n                left.erase(left.find(nums[i-k]));\\n            }\\n            else{\\n                right.erase(right.find(nums[i-k]));\\n            }\\n            \\n            // balance the sets\\n            BalanceSets();\\n            \\n            ans.push_back(GetMedian());            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566052,
                "title": "python-simple-solution-using-sortedlist",
                "content": "Adding and removing from sortedList is O(logk) operation. \\n\\nSo time complexity is O(n* logk) and Space is O(k) for sortedList \\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        res = []\\n        sl = SortedList()\\n        for i in range(len(nums)):\\n            \\n            sl.add(nums[i])\\n            \\n            if i < k-1:\\n                continue\\n            \\n            if k % 2:\\n                res.append(sl[k//2]*1.0)\\n            else:\\n                res.append((sl[(k//2)-1] + sl[k//2]) / 2.0)\\n            \\n            sl.remove(nums[i-k+1])\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        res = []\\n        sl = SortedList()\\n        for i in range(len(nums)):\\n            \\n            sl.add(nums[i])\\n            \\n            if i < k-1:\\n                continue\\n            \\n            if k % 2:\\n                res.append(sl[k//2]*1.0)\\n            else:\\n                res.append((sl[(k//2)-1] + sl[k//2]) / 2.0)\\n            \\n            sl.remove(nums[i-k+1])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478793,
                "title": "short-python-solution-o-n-log-k",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums, k):\\n        sl = SortedList(nums[:k - 1])\\n        wd = []\\n\\n        for i in range(k - 1, len(nums)):\\n            sl.add(nums[i])\\n            wd.append((sl[(k - 1) // 2] + sl[k // 2]) / 2)\\n            sl.remove(nums[i - k + 1])\\n        return wd\\n```\\nInitialize sorted list with first `k - 1` elements of `nums`. When sliding the window add a new element and remove old one in `O(log k)`. Record medians with tricky formula that works for both odd and even length windows.",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums, k):\\n        sl = SortedList(nums[:k - 1])\\n        wd = []\\n\\n        for i in range(k - 1, len(nums)):\\n            sl.add(nums[i])\\n            wd.append((sl[(k - 1) // 2] + sl[k // 2]) / 2)\\n            sl.remove(nums[i - k + 1])\\n        return wd\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378418,
                "title": "c-simple-approach-sorted-vector-o-n-k-beats-99-52-on-memory-use",
                "content": "We define a custom class `sorted_vector` with only 3 operations\\n1. add element by value\\n2. remove element by value\\n3. get median\\n\\nWe only keep K elements of the sliding window in the `sorted_vector` .\\n\\nTrust me, this is the simplest approach to this question.\\n\\nFor those of you who aren\\'t familiar with `std::lower_bound`, it simply binary searches the first `element >= val` and returns an `iterator` to it.\\n\\n```cpp\\nclass sorted_vector {\\nprivate:\\n    vector<int> arr;\\n    int k;\\npublic:\\n    sorted_vector(int k) {\\n        this->k = k;\\n        arr = vector<int>();\\n    }\\n    \\n    void add(int val) {\\n        auto lb = lower_bound(arr.begin(), arr.end(), val);\\n        arr.insert(lb, val);\\n    }\\n    \\n    void remove(int val) {\\n        auto lb = lower_bound(arr.begin(), arr.end(), val);\\n        arr.erase(lb);\\n    }\\n    \\n    double median() {\\n        if (k%2 == 0) {\\n            return ((double) arr[k/2] + arr[k/2-1])/2;\\n        }\\n        else\\n            return arr[k/2];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0;\\n        \\n        vector<double> ans(n-k+1);\\n        \\n        sorted_vector arr(k);\\n        \\n\\t\\t// simply push the first k-1 elements\\n        while (i < k-1) {\\n            arr.add(nums[i]);\\n            i++;\\n        }\\n        \\n\\t\\t// in each iteration, push one element, get median, pop out the last one.\\n        while (i < n) {\\n            arr.add(nums[i]);\\n            ans[i-k+1] = arr.median();\\n            arr.remove(nums[i-k+1]);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```cpp\\nclass sorted_vector {\\nprivate:\\n    vector<int> arr;\\n    int k;\\npublic:\\n    sorted_vector(int k) {\\n        this->k = k;\\n        arr = vector<int>();\\n    }\\n    \\n    void add(int val) {\\n        auto lb = lower_bound(arr.begin(), arr.end(), val);\\n        arr.insert(lb, val);\\n    }\\n    \\n    void remove(int val) {\\n        auto lb = lower_bound(arr.begin(), arr.end(), val);\\n        arr.erase(lb);\\n    }\\n    \\n    double median() {\\n        if (k%2 == 0) {\\n            return ((double) arr[k/2] + arr[k/2-1])/2;\\n        }\\n        else\\n            return arr[k/2];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int i = 0;\\n        \\n        vector<double> ans(n-k+1);\\n        \\n        sorted_vector arr(k);\\n        \\n\\t\\t// simply push the first k-1 elements\\n        while (i < k-1) {\\n            arr.add(nums[i]);\\n            i++;\\n        }\\n        \\n\\t\\t// in each iteration, push one element, get median, pop out the last one.\\n        while (i < n) {\\n            arr.add(nums[i]);\\n            ans[i-k+1] = arr.median();\\n            arr.remove(nums[i-k+1]);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191608,
                "title": "java-clean-concise-optimal-code-binary-search-or-two-heaps-data-structure",
                "content": "# Solution 1: Binary Search Algorithm\\n\\n```\\nclass Solution {\\n    \\n    public void addElement (List<Integer> list, int num) {\\n        \\n        int index = Collections.binarySearch (list, num);\\n        index = index < 0 ? Math.abs (index) - 1 : index;\\n        list.add (index, num);\\n    }\\n    \\n    public void removeElement (List<Integer> list, int num) {\\n        \\n        int index = Collections.binarySearch (list, num);\\n        list.remove (index);\\n    }\\n    \\n    public double findMedian (List<Integer> list, int k) {\\n        \\n        return k % 2 == 0 ? ((double) list.get (k / 2 - 1) + list.get (k / 2)) / 2 : list.get (k / 2);\\n    }\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        double[] medianArray = new double[nums.length - k + 1];\\n        List<Integer> list = new ArrayList<> ();\\n        \\n        for (int i = 0, j = 0; i < nums.length; i++) {\\n            addElement (list, nums[i]);\\n            \\n            if (i >= k - 1) {\\n                medianArray[j++] = findMedian (list, k);\\n                removeElement (list, nums[i - k + 1]);\\n            }\\n        }\\n        \\n        return medianArray;\\n    }\\n}\\n\\nTime Complexity: O(N * log K)\\nSpace Complexity: O(K)\\n```\\n\\n# Solution 2: Min & Max Heap (2 Priority Queues)\\n\\n```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> minHeap;\\n    PriorityQueue<Integer> maxHeap;\\n    \\n    public void balanceHeaps () {\\n        \\n        if (maxHeap.size () > minHeap.size ()) {\\n            minHeap.offer (maxHeap.poll ());\\n        }\\n    }\\n    \\n    public void removeElement (int num) {\\n        \\n        if (num > maxHeap.peek ()) {\\n            minHeap.remove (num);\\n        }\\n        else {\\n            maxHeap.remove (num);\\n        }\\n        \\n        balanceHeaps ();\\n    }\\n    \\n    public double findMedian (int k) {\\n        \\n        return k % 2 == 0 ? ((double) minHeap.peek () + maxHeap.peek ()) / 2 : minHeap.peek ();\\n    }\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        double[] medianArray = new double[nums.length - k + 1];\\n        minHeap = new PriorityQueue<> ();\\n        maxHeap = new PriorityQueue<> ((a, b) -> Integer.compare (b, a));\\n        \\n        if (k == 1) {\\n            for (int i = 0; i < nums.length; i++) {\\n                medianArray[i] = nums[i];\\n            }\\n            \\n            return medianArray;\\n        }\\n        \\n        for (int i = 0, j = 0; i < nums.length; i++) {\\n            minHeap.offer (nums[i]);\\n            maxHeap.offer (minHeap.poll ());\\n            balanceHeaps ();\\n            \\n            if (i >= k - 1) {\\n                medianArray[j++] = findMedian (k);\\n                removeElement (nums[i - k + 1]);\\n            }\\n        }\\n        \\n        return medianArray;\\n    }\\n}\\n\\nTime Complexity: O(N * K)\\nSapce Complexity: O(K) \\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public void addElement (List<Integer> list, int num) {\\n        \\n        int index = Collections.binarySearch (list, num);\\n        index = index < 0 ? Math.abs (index) - 1 : index;\\n        list.add (index, num);\\n    }\\n    \\n    public void removeElement (List<Integer> list, int num) {\\n        \\n        int index = Collections.binarySearch (list, num);\\n        list.remove (index);\\n    }\\n    \\n    public double findMedian (List<Integer> list, int k) {\\n        \\n        return k % 2 == 0 ? ((double) list.get (k / 2 - 1) + list.get (k / 2)) / 2 : list.get (k / 2);\\n    }\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        double[] medianArray = new double[nums.length - k + 1];\\n        List<Integer> list = new ArrayList<> ();\\n        \\n        for (int i = 0, j = 0; i < nums.length; i++) {\\n            addElement (list, nums[i]);\\n            \\n            if (i >= k - 1) {\\n                medianArray[j++] = findMedian (list, k);\\n                removeElement (list, nums[i - k + 1]);\\n            }\\n        }\\n        \\n        return medianArray;\\n    }\\n}\\n\\nTime Complexity: O(N * log K)\\nSpace Complexity: O(K)\\n```\n```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> minHeap;\\n    PriorityQueue<Integer> maxHeap;\\n    \\n    public void balanceHeaps () {\\n        \\n        if (maxHeap.size () > minHeap.size ()) {\\n            minHeap.offer (maxHeap.poll ());\\n        }\\n    }\\n    \\n    public void removeElement (int num) {\\n        \\n        if (num > maxHeap.peek ()) {\\n            minHeap.remove (num);\\n        }\\n        else {\\n            maxHeap.remove (num);\\n        }\\n        \\n        balanceHeaps ();\\n    }\\n    \\n    public double findMedian (int k) {\\n        \\n        return k % 2 == 0 ? ((double) minHeap.peek () + maxHeap.peek ()) / 2 : minHeap.peek ();\\n    }\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        double[] medianArray = new double[nums.length - k + 1];\\n        minHeap = new PriorityQueue<> ();\\n        maxHeap = new PriorityQueue<> ((a, b) -> Integer.compare (b, a));\\n        \\n        if (k == 1) {\\n            for (int i = 0; i < nums.length; i++) {\\n                medianArray[i] = nums[i];\\n            }\\n            \\n            return medianArray;\\n        }\\n        \\n        for (int i = 0, j = 0; i < nums.length; i++) {\\n            minHeap.offer (nums[i]);\\n            maxHeap.offer (minHeap.poll ());\\n            balanceHeaps ();\\n            \\n            if (i >= k - 1) {\\n                medianArray[j++] = findMedian (k);\\n                removeElement (nums[i - k + 1]);\\n            }\\n        }\\n        \\n        return medianArray;\\n    }\\n}\\n\\nTime Complexity: O(N * K)\\nSapce Complexity: O(K) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031968,
                "title": "java-max-min-heaps-cleaned-up-version",
                "content": "\\tPriorityQueue<Integer> max = new PriorityQueue<>(Collections.reverseOrder());\\n    PriorityQueue<Integer> min = new PriorityQueue<>();\\n\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res = new double[nums.length - k + 1];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            add(nums[i]);\\n\\n            if (i >= k - 1) {\\n                res[i - k + 1] = getMedian();\\n                remove(nums[i - k + 1]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private void add(int n) {\\n        max.add(n);\\n        min.add(max.poll());\\n\\n        if (min.size() > max.size())\\n            max.add(min.poll());\\n    }\\n\\n    private void remove(int n) {\\n        if (max.peek() >= n) \\n            max.remove(n);\\n        else \\n            min.remove(n);\\n\\n        if (min.size() > max.size())\\n            max.add(min.poll());\\n        if (max.size() > min.size())\\n            min.add(max.poll());\\n    }\\n\\n    private double getMedian() {\\n        if (min.size() == max.size()) \\n            return ((double) min.peek() + (double) max.peek()) / 2;\\n        else\\n            return (double) max.peek();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tPriorityQueue<Integer> max = new PriorityQueue<>(Collections.reverseOrder());\\n    PriorityQueue<Integer> min = new PriorityQueue<>();\\n\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res = new double[nums.length - k + 1];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            add(nums[i]);\\n\\n            if (i >= k - 1) {\\n                res[i - k + 1] = getMedian();\\n                remove(nums[i - k + 1]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private void add(int n) {\\n        max.add(n);\\n        min.add(max.poll());\\n\\n        if (min.size() > max.size())\\n            max.add(min.poll());\\n    }\\n\\n    private void remove(int n) {\\n        if (max.peek() >= n) \\n            max.remove(n);\\n        else \\n            min.remove(n);\\n\\n        if (min.size() > max.size())\\n            max.add(min.poll());\\n        if (max.size() > min.size())\\n            min.add(max.poll());\\n    }\\n\\n    private double getMedian() {\\n        if (min.size() == max.size()) \\n            return ((double) min.peek() + (double) max.peek()) / 2;\\n        else\\n            return (double) max.peek();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 983279,
                "title": "o-nlogk-c-using-ordered-multiset-policy-based-data-structure",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\nusing namespace __gnu_pbds; \\ntypedef tree<int, null_type, \\n             less_equal<int>, rb_tree_tag, \\n             tree_order_statistics_node_update> \\n    ordered_set; \\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<double>res;\\n        ordered_set os;\\n        for(int i=0;i<k;i++){\\n            os.insert(arr[i]);\\n        }\\n        if(k&1)\\n        {\\n            int ans=*os.find_by_order(k/2);\\n            res.push_back((double)(ans));\\n            \\n            for(int i=0;i<n-k;i++){\\n                os.erase(os.find_by_order(os.order_of_key(arr[i])));\\n                os.insert(arr[i+k]);\\n                ans=*os.find_by_order(k/2);\\n                res.push_back((double)(ans));\\n            }\\n        }\\n        else\\n        {\\n            double l=*os.find_by_order(k/2-1);\\n            double r=*os.find_by_order(k/2);\\n            double ans=(l+r)/2.0;\\n            res.push_back(ans);\\n            for(int i=0;i<n-k;i++){\\n                os.erase(os.find_by_order(os.order_of_key(arr[i])));\\n                os.insert(arr[i+k]);\\n                l=*os.find_by_order(k/2-1);\\n                r=*os.find_by_order(k/2);\\n                ans=(l+r)/2.0;\\n                res.push_back(ans);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\nusing namespace __gnu_pbds; \\ntypedef tree<int, null_type, \\n             less_equal<int>, rb_tree_tag, \\n             tree_order_statistics_node_update> \\n    ordered_set; \\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<double>res;\\n        ordered_set os;\\n        for(int i=0;i<k;i++){\\n            os.insert(arr[i]);\\n        }\\n        if(k&1)\\n        {\\n            int ans=*os.find_by_order(k/2);\\n            res.push_back((double)(ans));\\n            \\n            for(int i=0;i<n-k;i++){\\n                os.erase(os.find_by_order(os.order_of_key(arr[i])));\\n                os.insert(arr[i+k]);\\n                ans=*os.find_by_order(k/2);\\n                res.push_back((double)(ans));\\n            }\\n        }\\n        else\\n        {\\n            double l=*os.find_by_order(k/2-1);\\n            double r=*os.find_by_order(k/2);\\n            double ans=(l+r)/2.0;\\n            res.push_back(ans);\\n            for(int i=0;i<n-k;i++){\\n                os.erase(os.find_by_order(os.order_of_key(arr[i])));\\n                os.insert(arr[i+k]);\\n                l=*os.find_by_order(k/2-1);\\n                r=*os.find_by_order(k/2);\\n                ans=(l+r)/2.0;\\n                res.push_back(ans);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 737929,
                "title": "rust-just-write-a-avl-tree-library",
                "content": "since rust doesn\\'t have multiset like C++, I created it myself. The code is long, but works :) and beats 100% time and memory.\\n\\n```\\n#![allow(dead_code)]\\n\\n#[derive(Debug)]\\nstruct MultiSetNode<T> {\\n    /// The value being stored.\\n    value: T,\\n    /// The number of times this value is stored.\\n    count: usize,\\n\\n    /// The left and right subtrees.\\n    left: Option<Box<MultiSetNode<T>>>,\\n    right: Option<Box<MultiSetNode<T>>>,\\n\\n    /// The size of this subtree.\\n    size: usize,\\n    /// The height of this subtree.\\n    height: usize,\\n}\\n\\n#[derive(Clone, Copy, Debug)]\\nenum Rotation {\\n    Clockwise,\\n    Anticlockwise,\\n}\\n\\n#[derive(Clone, Copy, Debug)]\\nenum Child {\\n    Left,\\n    Right,\\n}\\n\\nimpl Child {\\n    pub fn opposite(&self) -> Child {\\n        match self {\\n            Child::Left => Child::Right,\\n            Child::Right => Child::Left,\\n        }\\n    }\\n}\\n\\nimpl<T> MultiSetNode<T>\\nwhere\\n    T: std::cmp::PartialOrd + std::fmt::Debug,\\n{\\n    pub fn new(value: T) -> MultiSetNode<T> {\\n        MultiSetNode {\\n            value,\\n            count: 1,\\n            left: None,\\n            right: None,\\n            size: 1,\\n            height: 1,\\n        }\\n    }\\n\\n    fn get_child(&mut self, child: Child) -> &mut Option<Box<MultiSetNode<T>>> {\\n        match child {\\n            Child::Left => &mut self.left,\\n            Child::Right => &mut self.right,\\n        }\\n    }\\n\\n    fn swap_values(x: &mut MultiSetNode<T>, y: &mut MultiSetNode<T>) {\\n        std::mem::swap(&mut x.value, &mut y.value);\\n        std::mem::swap(&mut x.count, &mut y.count);\\n    }\\n\\n    // Rotates the subtree by `rotation`.\\n    // If `rotation` is Rotation::Anticlockwise, then the tree after rotation becomes:\\n    //        A                               C\\n    //    B      C        ==>              A     G\\n    //          F  G                     B   F\\n    //\\n    // If `rotation` is Rotation::Clockwise, then the tree after rotation becomes:\\n    //        A                               B\\n    //    B      C        ==>              D      A\\n    //  D   E                                    E  C\\n    fn rotate(&mut self, rotation: Rotation) {\\n        // If anti-clockwise, the procedure is exactly the same, except left and right children are swapped.\\n        let (l_child, r_child) = match rotation {\\n            Rotation::Clockwise => (Child::Left, Child::Right),\\n            Rotation::Anticlockwise => (Child::Right, Child::Left),\\n        };\\n\\n        // 1) Detach the left subtree from root.\\n        //             A(self)\\n        //    B           C\\n        //  D   E\\n        let mut detached_left_opt = None;\\n        std::mem::swap(self.get_child(l_child), &mut detached_left_opt);\\n        let mut detached_left = match detached_left_opt {\\n            None => return, // If no left subtree, return early.\\n            Some(detached_left) => detached_left,\\n        };\\n\\n        // 2) Swap the children of `detached_left`.\\n        //             A(self)\\n        //    B           C\\n        //  E   D\\n        std::mem::swap(&mut detached_left.left, &mut detached_left.right);\\n\\n        // 3) Swap the values and counts of root (`self`) and `detached_left`.\\n        //             B(self)\\n        //    A           C\\n        //  E   D\\n        MultiSetNode::swap_values(self, &mut detached_left);\\n\\n        // 4) Swap the right children of the root and `detached_left`.\\n        //             B(self)\\n        //    A           D\\n        //  E   C\\n        std::mem::swap(self.get_child(r_child), detached_left.get_child(r_child));\\n\\n        // 5) Swap the children of root.\\n        //             B(self)\\n        //    A       D\\n        //  E   C\\n        std::mem::swap(&mut self.left, &mut self.right);\\n\\n        // 6) Set root\\'s right child to `detached_left`.\\n        //              B(self)\\n        //           D      A\\n        //                E   C\\n        *self.get_child(r_child) = Some(detached_left);\\n    }\\n\\n    fn child_heights(&self) -> (usize, usize) {\\n        (\\n            self.left.as_ref().map(|node| node.height).unwrap_or(0),\\n            self.right.as_ref().map(|node| node.height).unwrap_or(0),\\n        )\\n    }\\n\\n    pub fn balance(&mut self) {\\n        let (l_height, r_height) = self.child_heights();\\n\\n        if l_height > r_height + 1 {\\n            // Safe unwrap as `l_height` >= 1.\\n            let left = self.left.as_mut().unwrap();\\n            let (ll_height, lr_height) = left.child_heights();\\n            // Make sure left-left subtree is at least as tall as left-right subtree.\\n            if ll_height < lr_height {\\n                left.rotate(Rotation::Anticlockwise);\\n            }\\n            self.rotate(Rotation::Clockwise);\\n        } else if r_height > l_height + 1 {\\n            // Safe unwrap as `r_height` >= 1.\\n            let right = self.right.as_mut().unwrap();\\n            let (rl_height, rr_height) = right.child_heights();\\n            // Make sure right-right subtree is at least as tall as right-left subtree.\\n            if rr_height < rl_height {\\n                right.rotate(Rotation::Clockwise);\\n            }\\n            self.rotate(Rotation::Anticlockwise);\\n        }\\n\\n        // Re-calculate meta info after rotations.\\n        if let Some(left) = &mut self.left {\\n            left.update_meta();\\n        }\\n        if let Some(right) = &mut self.right {\\n            right.update_meta();\\n        }\\n        self.update_meta();\\n    }\\n\\n    fn update_meta(&mut self) {\\n        // Size is `self.count` + left size + right size.\\n        self.size = self.count\\n            + self.left.as_ref().map(|node| node.size).unwrap_or(0)\\n            + self.right.as_ref().map(|node| node.size).unwrap_or(0);\\n\\n        // Height is 1 + max(left height, right height).\\n        let (l_height, r_height) = self.child_heights();\\n        self.height = 1 + std::cmp::max(l_height, r_height);\\n    }\\n\\n    fn fix(&mut self) {\\n        self.update_meta();\\n        self.balance();\\n    }\\n\\n    fn insert(opt_node: &mut Option<Box<MultiSetNode<T>>>, value: T) {\\n        let node = match opt_node {\\n            None => {\\n                *opt_node = Some(Box::new(MultiSetNode::new(value)));\\n                return;\\n            }\\n            Some(node) => node,\\n        };\\n\\n        if value < node.value {\\n            MultiSetNode::insert(&mut node.left, value)\\n        } else if value > node.value {\\n            MultiSetNode::insert(&mut node.right, value)\\n        } else {\\n            node.count += 1;\\n        }\\n\\n        node.fix();\\n    }\\n\\n    fn remove_node(opt_node: &mut Option<Box<MultiSetNode<T>>>) {\\n        let node = match opt_node {\\n            None => return,\\n            Some(node) => node,\\n        };\\n\\n        let child = match (node.left.as_mut(), node.right.as_mut()) {\\n            (Some(_), Some(right)) => {\\n                if let Some(_) = right.left.as_mut() {\\n                    let mut parent = right;\\n                    while parent.left.as_mut().unwrap().left.as_mut().is_some() {\\n                        parent = parent.left.as_mut().unwrap();\\n                    }\\n                    let to_swap = parent.left.as_mut().unwrap();\\n                    std::mem::swap(&mut node.value, &mut to_swap.value);\\n                    std::mem::swap(&mut node.count, &mut to_swap.count);\\n\\n                    let mut to_swap_right = None;\\n                    std::mem::swap(&mut to_swap_right, &mut to_swap.right);\\n                    parent.left = to_swap_right;\\n\\n                    fn fix_left<T>(x_opt: &mut Option<Box<MultiSetNode<T>>>)\\n                    where\\n                        T: std::cmp::PartialOrd + std::fmt::Debug,\\n                    {\\n                        if let Some(x) = x_opt {\\n                            fix_left(&mut x.left);\\n                            x.fix();\\n                        }\\n                    }\\n                    fix_left(&mut node.right);\\n\\n                    node.fix();\\n                    return;\\n                } else {\\n                    Child::Right\\n                }\\n            }\\n            (None, None) | (None, Some(_)) => Child::Right,\\n            (Some(_), None) => Child::Left,\\n        };\\n\\n        let mut detached_child = None;\\n        std::mem::swap(node.get_child(child), &mut detached_child);\\n\\n        let otherchild = child.opposite();\\n        let mut detached_otherchild = None;\\n        std::mem::swap(node.get_child(otherchild), &mut detached_otherchild);\\n\\n        if let Some(detached_child_node) = detached_child.as_mut() {\\n            *detached_child_node.get_child(otherchild) = detached_otherchild;\\n            detached_child_node.fix();\\n        }\\n\\n        *opt_node = detached_child;\\n    }\\n\\n    fn remove(opt_node: &mut Option<Box<MultiSetNode<T>>>, value: T) {\\n        let node = match opt_node {\\n            None => return,\\n            Some(node) => node,\\n        };\\n\\n        if value < node.value {\\n            MultiSetNode::remove(&mut node.left, value)\\n        } else if value > node.value {\\n            MultiSetNode::remove(&mut node.right, value)\\n        } else {\\n            node.count -= 1;\\n            if node.count == 0 {\\n                return MultiSetNode::remove_node(opt_node);\\n            }\\n        };\\n\\n        node.fix();\\n    }\\n\\n    /// Returns the count of the given key.\\n    pub fn get(opt_node: &Option<Box<MultiSetNode<T>>>, value: T) -> usize {\\n        let node = match &opt_node {\\n            None => return 0,\\n            Some(node) => node,\\n        };\\n\\n        if value < node.value {\\n            MultiSetNode::get(&node.left, value)\\n        } else if value > node.value {\\n            MultiSetNode::get(&node.right, value)\\n        } else {\\n            node.count\\n        }\\n    }\\n\\n    pub fn len(&self) -> usize {\\n        self.size\\n    }\\n\\n    fn fmt_with_indents(\\n        opt_node: &Option<Box<MultiSetNode<T>>>,\\n        f: &mut std::fmt::Formatter<\\'_>,\\n        level: usize,\\n        child: Option<Child>,\\n    ) -> std::fmt::Result {\\n        if let Some(node) = opt_node {\\n            let indent = (0..level).map(|_| \"  \").collect::<String>();\\n\\n            let _ = write!(\\n                f,\\n                \"{}child={:?},val={:?},size={},count={},height={}\\\\n\",\\n                indent, child, node.value, node.size, node.count, node.height\\n            );\\n            let _ = MultiSetNode::fmt_with_indents(&node.left, f, level + 1, Some(Child::Left));\\n            MultiSetNode::fmt_with_indents(&node.right, f, level + 1, Some(Child::Right))\\n        } else {\\n            write!(f, \"\",)\\n        }\\n    }\\n\\n    pub fn nth_node<\\'a>(\\n        opt_node: &\\'a mut Option<Box<MultiSetNode<T>>>,\\n        n: usize,\\n    ) -> Option<&\\'a mut Box<MultiSetNode<T>>> {\\n        let node = match opt_node {\\n            None => return None,\\n            Some(node) => node,\\n        };\\n\\n        let left_size = node.left.as_ref().map(|node| node.size).unwrap_or(0);\\n        if n < left_size {\\n            MultiSetNode::nth_node(&mut node.left, n)\\n        } else if n < left_size + node.count {\\n            Some(node)\\n        } else {\\n            MultiSetNode::nth_node(&mut node.right, n - left_size - node.count)\\n        }\\n    }\\n\\n    pub fn nth_item(&self, n: usize) -> &T {\\n        let left_size = self.left.as_ref().map(|node| node.size).unwrap_or(0);\\n        if n < left_size {\\n            MultiSetNode::nth_item(self.left.as_ref().unwrap(), n)\\n        } else if n < left_size + self.count {\\n            &self.value\\n        } else {\\n            MultiSetNode::nth_item(self.right.as_ref().unwrap(), n - left_size - self.count)\\n        }\\n    }\\n}\\n\\n#[derive(Debug)]\\npub struct MultiSet<T> {\\n    root: Option<Box<MultiSetNode<T>>>,\\n}\\n\\nimpl<T> MultiSet<T>\\nwhere\\n    T: std::cmp::PartialOrd + std::fmt::Debug,\\n{\\n    pub fn new() -> MultiSet<T> {\\n        MultiSet { root: None }\\n    }\\n\\n    pub fn len(&self) -> usize {\\n        match &self.root {\\n            None => 0,\\n            Some(node) => node.len(),\\n        }\\n    }\\n\\n    /// Inserts `value`. Duplicates are allowed.\\n    pub fn insert(&mut self, value: T) {\\n        MultiSetNode::insert(&mut self.root, value);\\n    }\\n\\n    /// Returns true if `value` was successfully removed.\\n    pub fn remove(&mut self, value: T) {\\n        MultiSetNode::remove(&mut self.root, value);\\n    }\\n\\n    pub fn get(&self, value: T) -> usize {\\n        MultiSetNode::get(&self.root, value)\\n    }\\n\\n    /// Gets the nth item in the MultiSet where n in `[0, len())`. Panics if `n` not in this range.\\n    pub fn nth_item(&self, n: usize) -> &T {\\n        if n >= self.len() {\\n            panic!(\"Item out of bounds!\");\\n        }\\n\\n        MultiSetNode::nth_item(self.root.as_ref().unwrap(), n)\\n    }\\n}\\n\\nimpl<T> std::fmt::Display for MultiSet<T>\\nwhere\\n    T: std::cmp::PartialOrd + std::fmt::Debug,\\n{\\n    fn fmt(&self, f: &mut std::fmt::Formatter<\\'_>) -> std::fmt::Result {\\n        MultiSetNode::fmt_with_indents(&self.root, f, 0, None)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    use std::collections::HashMap;\\n\\n    // Checks constraints and returns (size and height).\\n    fn check<T>(\\n        opt_node: &Option<Box<MultiSetNode<T>>>,\\n        min_val_opt: Option<&T>,\\n        max_val_opt: Option<&T>,\\n    ) -> (usize, usize)\\n    where\\n        T: std::cmp::PartialOrd + std::fmt::Debug,\\n    {\\n        let node = match opt_node {\\n            None => return (0, 0),\\n            Some(node) => node,\\n        };\\n        if let Some(min_val) = min_val_opt {\\n            assert!(min_val < &node.value);\\n        }\\n        if let Some(max_val) = max_val_opt {\\n            assert!(&node.value < max_val);\\n        }\\n\\n        let (l_size, l_height) = check(&node.left, min_val_opt, Some(&node.value));\\n        let (r_size, r_height) = check(&node.right, Some(&node.value), max_val_opt);\\n        assert_eq!(node.size, node.count + l_size + r_size);\\n        assert_eq!(node.height, 1 + std::cmp::max(l_height, r_height));\\n        // Max height difference between left and right subtrees is 1.\\n        assert!((l_height as i64 - r_height as i64).abs() <= 1);\\n\\n        (node.size, node.height)\\n    }\\n\\n    fn insert_<T>(m: &mut MultiSet<T>, value: T)\\n    where\\n        T: std::cmp::PartialOrd + std::fmt::Debug,\\n    {\\n        let old_len = m.len();\\n        m.insert(value);\\n        assert_eq!(m.len(), old_len + 1);\\n        check(&m.root, None, None);\\n    }\\n\\n    fn remove_<T>(m: &mut MultiSet<T>, value: T)\\n    where\\n        T: std::cmp::PartialOrd + std::fmt::Debug + Copy + std::fmt::Display,\\n    {\\n        let old_len = m.len();\\n        m.remove(value);\\n        assert_eq!(m.len(), old_len - 1);\\n        check(&m.root, None, None);\\n    }\\n\\n    #[test]\\n    fn test_multiset_remove_some_some() {\\n        let mut m = MultiSet::new();\\n        insert_(&mut m, 11);\\n        insert_(&mut m, 10);\\n        insert_(&mut m, 8);\\n        insert_(&mut m, 9);\\n        insert_(&mut m, 7);\\n        insert_(&mut m, 6);\\n        remove_(&mut m, 11);\\n\\n        remove_(&mut m, 8);\\n    }\\n\\n    #[test]\\n    fn test_multiset_insert() {\\n        let mut m = MultiSet::new();\\n        insert_(&mut m, 10);\\n        insert_(&mut m, 10);\\n        insert_(&mut m, 10);\\n        assert_eq!(m.get(10), 3);\\n\\n        insert_(&mut m, 11);\\n        assert_eq!(m.get(11), 1);\\n\\n        insert_(&mut m, 12);\\n        insert_(&mut m, 13);\\n        insert_(&mut m, 14);\\n        insert_(&mut m, 15);\\n        insert_(&mut m, 16);\\n        assert_eq!(m.get(16), 1);\\n        assert_eq!(m.len(), 9);\\n    }\\n\\n    #[test]\\n    fn test_multiset_remove() {\\n        let mut m = MultiSet::new();\\n        let items = vec![11, 99, 7, 8, 12, 10, 10];\\n        for item in &items {\\n            insert_(&mut m, *item);\\n        }\\n        assert_eq!(m.len(), items.len());\\n\\n        remove_(&mut m, 10);\\n        assert_eq!(m.get(10), 1);\\n        assert_eq!(m.len(), items.len() - 1);\\n        remove_(&mut m, 10);\\n        assert_eq!(m.get(10), 0);\\n        assert_eq!(m.len(), items.len() - 2);\\n\\n        assert_eq!(m.get(11), 1);\\n        assert_eq!(m.get(12), 1);\\n    }\\n\\n    #[test]\\n    fn test_multiset_sequential() {\\n        let mut m = MultiSet::new();\\n        let mut items = vec![];\\n        for i in 1..100 {\\n            for j in 1..i + 1 {\\n                items.push((i * j + 2 * j + 12) % 25);\\n            }\\n        }\\n        let mut d = HashMap::new();\\n        for (i, item) in items.iter().enumerate() {\\n            *d.entry(*item).or_insert(0) += 1;\\n            insert_(&mut m, *item);\\n            assert_eq!(m.len(), i + 1);\\n\\n            assert_eq!(m.get(*item), d[item]);\\n        }\\n\\n        let num_removes = items.len() / 2;\\n        for i in 0..num_removes {\\n            let removed_item = items.remove(i);\\n            remove_(&mut m, removed_item);\\n            *d.get_mut(&removed_item).unwrap() -= 1;\\n\\n            assert_eq!(m.get(removed_item), d[&removed_item]);\\n        }\\n\\n        items.sort();\\n        for (i, item) in items.iter().enumerate() {\\n            assert_eq!(m.get(*item), d[item]);\\n            assert_eq!(m.nth_item(i), item);\\n        }\\n    }\\n}\\n\\n\\npub fn median_sliding_window(nums: Vec<i32>, k: i32) -> Vec<f64> {\\n    assert!(k > 0);\\n    let k = std::cmp::min(k as usize, nums.len());\\n\\n    fn get_median(m: &MultiSet<i32>) -> f64 {\\n        let first_item = *m.nth_item((m.len() - 1) / 2) as f64;\\n        if m.len() % 2 != 0 {\\n            return first_item;\\n        }\\n\\n        let second_item = *m.nth_item(m.len() / 2) as f64;\\n        (first_item + second_item) / 2.0\\n    }\\n\\n    let mut map = MultiSet::new();\\n    let mut medians = vec![];\\n\\n    for num in nums[0..k].iter() {\\n        map.insert(*num);\\n    }\\n    medians.push(get_median(&map));\\n\\n    for (num_remove, num_add) in nums.iter().zip(nums[k..].iter()) {\\n        map.remove(*num_remove);\\n        map.insert(*num_add);\\n        medians.push(get_median(&map));\\n    }\\n\\n    medians\\n}\\n\\n\\n\\nimpl Solution {\\n    pub fn median_sliding_window(nums: Vec<i32>, k: i32) -> Vec<f64> {\\n        median_sliding_window(nums, k)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n#![allow(dead_code)]\\n\\n#[derive(Debug)]\\nstruct MultiSetNode<T> {\\n    /// The value being stored.\\n    value: T,\\n    /// The number of times this value is stored.\\n    count: usize,\\n\\n    /// The left and right subtrees.\\n    left: Option<Box<MultiSetNode<T>>>,\\n    right: Option<Box<MultiSetNode<T>>>,\\n\\n    /// The size of this subtree.\\n    size: usize,\\n    /// The height of this subtree.\\n    height: usize,\\n}\\n\\n#[derive(Clone, Copy, Debug)]\\nenum Rotation {\\n    Clockwise,\\n    Anticlockwise,\\n}\\n\\n#[derive(Clone, Copy, Debug)]\\nenum Child {\\n    Left,\\n    Right,\\n}\\n\\nimpl Child {\\n    pub fn opposite(&self) -> Child {\\n        match self {\\n            Child::Left => Child::Right,\\n            Child::Right => Child::Left,\\n        }\\n    }\\n}\\n\\nimpl<T> MultiSetNode<T>\\nwhere\\n    T: std::cmp::PartialOrd + std::fmt::Debug,\\n{\\n    pub fn new(value: T) -> MultiSetNode<T> {\\n        MultiSetNode {\\n            value,\\n            count: 1,\\n            left: None,\\n            right: None,\\n            size: 1,\\n            height: 1,\\n        }\\n    }\\n\\n    fn get_child(&mut self, child: Child) -> &mut Option<Box<MultiSetNode<T>>> {\\n        match child {\\n            Child::Left => &mut self.left,\\n            Child::Right => &mut self.right,\\n        }\\n    }\\n\\n    fn swap_values(x: &mut MultiSetNode<T>, y: &mut MultiSetNode<T>) {\\n        std::mem::swap(&mut x.value, &mut y.value);\\n        std::mem::swap(&mut x.count, &mut y.count);\\n    }\\n\\n    // Rotates the subtree by `rotation`.\\n    // If `rotation` is Rotation::Anticlockwise, then the tree after rotation becomes:\\n    //        A                               C\\n    //    B      C        ==>              A     G\\n    //          F  G                     B   F\\n    //\\n    // If `rotation` is Rotation::Clockwise, then the tree after rotation becomes:\\n    //        A                               B\\n    //    B      C        ==>              D      A\\n    //  D   E                                    E  C\\n    fn rotate(&mut self, rotation: Rotation) {\\n        // If anti-clockwise, the procedure is exactly the same, except left and right children are swapped.\\n        let (l_child, r_child) = match rotation {\\n            Rotation::Clockwise => (Child::Left, Child::Right),\\n            Rotation::Anticlockwise => (Child::Right, Child::Left),\\n        };\\n\\n        // 1) Detach the left subtree from root.\\n        //             A(self)\\n        //    B           C\\n        //  D   E\\n        let mut detached_left_opt = None;\\n        std::mem::swap(self.get_child(l_child), &mut detached_left_opt);\\n        let mut detached_left = match detached_left_opt {\\n            None => return, // If no left subtree, return early.\\n            Some(detached_left) => detached_left,\\n        };\\n\\n        // 2) Swap the children of `detached_left`.\\n        //             A(self)\\n        //    B           C\\n        //  E   D\\n        std::mem::swap(&mut detached_left.left, &mut detached_left.right);\\n\\n        // 3) Swap the values and counts of root (`self`) and `detached_left`.\\n        //             B(self)\\n        //    A           C\\n        //  E   D\\n        MultiSetNode::swap_values(self, &mut detached_left);\\n\\n        // 4) Swap the right children of the root and `detached_left`.\\n        //             B(self)\\n        //    A           D\\n        //  E   C\\n        std::mem::swap(self.get_child(r_child), detached_left.get_child(r_child));\\n\\n        // 5) Swap the children of root.\\n        //             B(self)\\n        //    A       D\\n        //  E   C\\n        std::mem::swap(&mut self.left, &mut self.right);\\n\\n        // 6) Set root\\'s right child to `detached_left`.\\n        //              B(self)\\n        //           D      A\\n        //                E   C\\n        *self.get_child(r_child) = Some(detached_left);\\n    }\\n\\n    fn child_heights(&self) -> (usize, usize) {\\n        (\\n            self.left.as_ref().map(|node| node.height).unwrap_or(0),\\n            self.right.as_ref().map(|node| node.height).unwrap_or(0),\\n        )\\n    }\\n\\n    pub fn balance(&mut self) {\\n        let (l_height, r_height) = self.child_heights();\\n\\n        if l_height > r_height + 1 {\\n            // Safe unwrap as `l_height` >= 1.\\n            let left = self.left.as_mut().unwrap();\\n            let (ll_height, lr_height) = left.child_heights();\\n            // Make sure left-left subtree is at least as tall as left-right subtree.\\n            if ll_height < lr_height {\\n                left.rotate(Rotation::Anticlockwise);\\n            }\\n            self.rotate(Rotation::Clockwise);\\n        } else if r_height > l_height + 1 {\\n            // Safe unwrap as `r_height` >= 1.\\n            let right = self.right.as_mut().unwrap();\\n            let (rl_height, rr_height) = right.child_heights();\\n            // Make sure right-right subtree is at least as tall as right-left subtree.\\n            if rr_height < rl_height {\\n                right.rotate(Rotation::Clockwise);\\n            }\\n            self.rotate(Rotation::Anticlockwise);\\n        }\\n\\n        // Re-calculate meta info after rotations.\\n        if let Some(left) = &mut self.left {\\n            left.update_meta();\\n        }\\n        if let Some(right) = &mut self.right {\\n            right.update_meta();\\n        }\\n        self.update_meta();\\n    }\\n\\n    fn update_meta(&mut self) {\\n        // Size is `self.count` + left size + right size.\\n        self.size = self.count\\n            + self.left.as_ref().map(|node| node.size).unwrap_or(0)\\n            + self.right.as_ref().map(|node| node.size).unwrap_or(0);\\n\\n        // Height is 1 + max(left height, right height).\\n        let (l_height, r_height) = self.child_heights();\\n        self.height = 1 + std::cmp::max(l_height, r_height);\\n    }\\n\\n    fn fix(&mut self) {\\n        self.update_meta();\\n        self.balance();\\n    }\\n\\n    fn insert(opt_node: &mut Option<Box<MultiSetNode<T>>>, value: T) {\\n        let node = match opt_node {\\n            None => {\\n                *opt_node = Some(Box::new(MultiSetNode::new(value)));\\n                return;\\n            }\\n            Some(node) => node,\\n        };\\n\\n        if value < node.value {\\n            MultiSetNode::insert(&mut node.left, value)\\n        } else if value > node.value {\\n            MultiSetNode::insert(&mut node.right, value)\\n        } else {\\n            node.count += 1;\\n        }\\n\\n        node.fix();\\n    }\\n\\n    fn remove_node(opt_node: &mut Option<Box<MultiSetNode<T>>>) {\\n        let node = match opt_node {\\n            None => return,\\n            Some(node) => node,\\n        };\\n\\n        let child = match (node.left.as_mut(), node.right.as_mut()) {\\n            (Some(_), Some(right)) => {\\n                if let Some(_) = right.left.as_mut() {\\n                    let mut parent = right;\\n                    while parent.left.as_mut().unwrap().left.as_mut().is_some() {\\n                        parent = parent.left.as_mut().unwrap();\\n                    }\\n                    let to_swap = parent.left.as_mut().unwrap();\\n                    std::mem::swap(&mut node.value, &mut to_swap.value);\\n                    std::mem::swap(&mut node.count, &mut to_swap.count);\\n\\n                    let mut to_swap_right = None;\\n                    std::mem::swap(&mut to_swap_right, &mut to_swap.right);\\n                    parent.left = to_swap_right;\\n\\n                    fn fix_left<T>(x_opt: &mut Option<Box<MultiSetNode<T>>>)\\n                    where\\n                        T: std::cmp::PartialOrd + std::fmt::Debug,\\n                    {\\n                        if let Some(x) = x_opt {\\n                            fix_left(&mut x.left);\\n                            x.fix();\\n                        }\\n                    }\\n                    fix_left(&mut node.right);\\n\\n                    node.fix();\\n                    return;\\n                } else {\\n                    Child::Right\\n                }\\n            }\\n            (None, None) | (None, Some(_)) => Child::Right,\\n            (Some(_), None) => Child::Left,\\n        };\\n\\n        let mut detached_child = None;\\n        std::mem::swap(node.get_child(child), &mut detached_child);\\n\\n        let otherchild = child.opposite();\\n        let mut detached_otherchild = None;\\n        std::mem::swap(node.get_child(otherchild), &mut detached_otherchild);\\n\\n        if let Some(detached_child_node) = detached_child.as_mut() {\\n            *detached_child_node.get_child(otherchild) = detached_otherchild;\\n            detached_child_node.fix();\\n        }\\n\\n        *opt_node = detached_child;\\n    }\\n\\n    fn remove(opt_node: &mut Option<Box<MultiSetNode<T>>>, value: T) {\\n        let node = match opt_node {\\n            None => return,\\n            Some(node) => node,\\n        };\\n\\n        if value < node.value {\\n            MultiSetNode::remove(&mut node.left, value)\\n        } else if value > node.value {\\n            MultiSetNode::remove(&mut node.right, value)\\n        } else {\\n            node.count -= 1;\\n            if node.count == 0 {\\n                return MultiSetNode::remove_node(opt_node);\\n            }\\n        };\\n\\n        node.fix();\\n    }\\n\\n    /// Returns the count of the given key.\\n    pub fn get(opt_node: &Option<Box<MultiSetNode<T>>>, value: T) -> usize {\\n        let node = match &opt_node {\\n            None => return 0,\\n            Some(node) => node,\\n        };\\n\\n        if value < node.value {\\n            MultiSetNode::get(&node.left, value)\\n        } else if value > node.value {\\n            MultiSetNode::get(&node.right, value)\\n        } else {\\n            node.count\\n        }\\n    }\\n\\n    pub fn len(&self) -> usize {\\n        self.size\\n    }\\n\\n    fn fmt_with_indents(\\n        opt_node: &Option<Box<MultiSetNode<T>>>,\\n        f: &mut std::fmt::Formatter<\\'_>,\\n        level: usize,\\n        child: Option<Child>,\\n    ) -> std::fmt::Result {\\n        if let Some(node) = opt_node {\\n            let indent = (0..level).map(|_| \"  \").collect::<String>();\\n\\n            let _ = write!(\\n                f,\\n                \"{}child={:?},val={:?},size={},count={},height={}\\\\n\",\\n                indent, child, node.value, node.size, node.count, node.height\\n            );\\n            let _ = MultiSetNode::fmt_with_indents(&node.left, f, level + 1, Some(Child::Left));\\n            MultiSetNode::fmt_with_indents(&node.right, f, level + 1, Some(Child::Right))\\n        } else {\\n            write!(f, \"\",)\\n        }\\n    }\\n\\n    pub fn nth_node<\\'a>(\\n        opt_node: &\\'a mut Option<Box<MultiSetNode<T>>>,\\n        n: usize,\\n    ) -> Option<&\\'a mut Box<MultiSetNode<T>>> {\\n        let node = match opt_node {\\n            None => return None,\\n            Some(node) => node,\\n        };\\n\\n        let left_size = node.left.as_ref().map(|node| node.size).unwrap_or(0);\\n        if n < left_size {\\n            MultiSetNode::nth_node(&mut node.left, n)\\n        } else if n < left_size + node.count {\\n            Some(node)\\n        } else {\\n            MultiSetNode::nth_node(&mut node.right, n - left_size - node.count)\\n        }\\n    }\\n\\n    pub fn nth_item(&self, n: usize) -> &T {\\n        let left_size = self.left.as_ref().map(|node| node.size).unwrap_or(0);\\n        if n < left_size {\\n            MultiSetNode::nth_item(self.left.as_ref().unwrap(), n)\\n        } else if n < left_size + self.count {\\n            &self.value\\n        } else {\\n            MultiSetNode::nth_item(self.right.as_ref().unwrap(), n - left_size - self.count)\\n        }\\n    }\\n}\\n\\n#[derive(Debug)]\\npub struct MultiSet<T> {\\n    root: Option<Box<MultiSetNode<T>>>,\\n}\\n\\nimpl<T> MultiSet<T>\\nwhere\\n    T: std::cmp::PartialOrd + std::fmt::Debug,\\n{\\n    pub fn new() -> MultiSet<T> {\\n        MultiSet { root: None }\\n    }\\n\\n    pub fn len(&self) -> usize {\\n        match &self.root {\\n            None => 0,\\n            Some(node) => node.len(),\\n        }\\n    }\\n\\n    /// Inserts `value`. Duplicates are allowed.\\n    pub fn insert(&mut self, value: T) {\\n        MultiSetNode::insert(&mut self.root, value);\\n    }\\n\\n    /// Returns true if `value` was successfully removed.\\n    pub fn remove(&mut self, value: T) {\\n        MultiSetNode::remove(&mut self.root, value);\\n    }\\n\\n    pub fn get(&self, value: T) -> usize {\\n        MultiSetNode::get(&self.root, value)\\n    }\\n\\n    /// Gets the nth item in the MultiSet where n in `[0, len())`. Panics if `n` not in this range.\\n    pub fn nth_item(&self, n: usize) -> &T {\\n        if n >= self.len() {\\n            panic!(\"Item out of bounds!\");\\n        }\\n\\n        MultiSetNode::nth_item(self.root.as_ref().unwrap(), n)\\n    }\\n}\\n\\nimpl<T> std::fmt::Display for MultiSet<T>\\nwhere\\n    T: std::cmp::PartialOrd + std::fmt::Debug,\\n{\\n    fn fmt(&self, f: &mut std::fmt::Formatter<\\'_>) -> std::fmt::Result {\\n        MultiSetNode::fmt_with_indents(&self.root, f, 0, None)\\n    }\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n    use std::collections::HashMap;\\n\\n    // Checks constraints and returns (size and height).\\n    fn check<T>(\\n        opt_node: &Option<Box<MultiSetNode<T>>>,\\n        min_val_opt: Option<&T>,\\n        max_val_opt: Option<&T>,\\n    ) -> (usize, usize)\\n    where\\n        T: std::cmp::PartialOrd + std::fmt::Debug,\\n    {\\n        let node = match opt_node {\\n            None => return (0, 0),\\n            Some(node) => node,\\n        };\\n        if let Some(min_val) = min_val_opt {\\n            assert!(min_val < &node.value);\\n        }\\n        if let Some(max_val) = max_val_opt {\\n            assert!(&node.value < max_val);\\n        }\\n\\n        let (l_size, l_height) = check(&node.left, min_val_opt, Some(&node.value));\\n        let (r_size, r_height) = check(&node.right, Some(&node.value), max_val_opt);\\n        assert_eq!(node.size, node.count + l_size + r_size);\\n        assert_eq!(node.height, 1 + std::cmp::max(l_height, r_height));\\n        // Max height difference between left and right subtrees is 1.\\n        assert!((l_height as i64 - r_height as i64).abs() <= 1);\\n\\n        (node.size, node.height)\\n    }\\n\\n    fn insert_<T>(m: &mut MultiSet<T>, value: T)\\n    where\\n        T: std::cmp::PartialOrd + std::fmt::Debug,\\n    {\\n        let old_len = m.len();\\n        m.insert(value);\\n        assert_eq!(m.len(), old_len + 1);\\n        check(&m.root, None, None);\\n    }\\n\\n    fn remove_<T>(m: &mut MultiSet<T>, value: T)\\n    where\\n        T: std::cmp::PartialOrd + std::fmt::Debug + Copy + std::fmt::Display,\\n    {\\n        let old_len = m.len();\\n        m.remove(value);\\n        assert_eq!(m.len(), old_len - 1);\\n        check(&m.root, None, None);\\n    }\\n\\n    #[test]\\n    fn test_multiset_remove_some_some() {\\n        let mut m = MultiSet::new();\\n        insert_(&mut m, 11);\\n        insert_(&mut m, 10);\\n        insert_(&mut m, 8);\\n        insert_(&mut m, 9);\\n        insert_(&mut m, 7);\\n        insert_(&mut m, 6);\\n        remove_(&mut m, 11);\\n\\n        remove_(&mut m, 8);\\n    }\\n\\n    #[test]\\n    fn test_multiset_insert() {\\n        let mut m = MultiSet::new();\\n        insert_(&mut m, 10);\\n        insert_(&mut m, 10);\\n        insert_(&mut m, 10);\\n        assert_eq!(m.get(10), 3);\\n\\n        insert_(&mut m, 11);\\n        assert_eq!(m.get(11), 1);\\n\\n        insert_(&mut m, 12);\\n        insert_(&mut m, 13);\\n        insert_(&mut m, 14);\\n        insert_(&mut m, 15);\\n        insert_(&mut m, 16);\\n        assert_eq!(m.get(16), 1);\\n        assert_eq!(m.len(), 9);\\n    }\\n\\n    #[test]\\n    fn test_multiset_remove() {\\n        let mut m = MultiSet::new();\\n        let items = vec![11, 99, 7, 8, 12, 10, 10];\\n        for item in &items {\\n            insert_(&mut m, *item);\\n        }\\n        assert_eq!(m.len(), items.len());\\n\\n        remove_(&mut m, 10);\\n        assert_eq!(m.get(10), 1);\\n        assert_eq!(m.len(), items.len() - 1);\\n        remove_(&mut m, 10);\\n        assert_eq!(m.get(10), 0);\\n        assert_eq!(m.len(), items.len() - 2);\\n\\n        assert_eq!(m.get(11), 1);\\n        assert_eq!(m.get(12), 1);\\n    }\\n\\n    #[test]\\n    fn test_multiset_sequential() {\\n        let mut m = MultiSet::new();\\n        let mut items = vec![];\\n        for i in 1..100 {\\n            for j in 1..i + 1 {\\n                items.push((i * j + 2 * j + 12) % 25);\\n            }\\n        }\\n        let mut d = HashMap::new();\\n        for (i, item) in items.iter().enumerate() {\\n            *d.entry(*item).or_insert(0) += 1;\\n            insert_(&mut m, *item);\\n            assert_eq!(m.len(), i + 1);\\n\\n            assert_eq!(m.get(*item), d[item]);\\n        }\\n\\n        let num_removes = items.len() / 2;\\n        for i in 0..num_removes {\\n            let removed_item = items.remove(i);\\n            remove_(&mut m, removed_item);\\n            *d.get_mut(&removed_item).unwrap() -= 1;\\n\\n            assert_eq!(m.get(removed_item), d[&removed_item]);\\n        }\\n\\n        items.sort();\\n        for (i, item) in items.iter().enumerate() {\\n            assert_eq!(m.get(*item), d[item]);\\n            assert_eq!(m.nth_item(i), item);\\n        }\\n    }\\n}\\n\\n\\npub fn median_sliding_window(nums: Vec<i32>, k: i32) -> Vec<f64> {\\n    assert!(k > 0);\\n    let k = std::cmp::min(k as usize, nums.len());\\n\\n    fn get_median(m: &MultiSet<i32>) -> f64 {\\n        let first_item = *m.nth_item((m.len() - 1) / 2) as f64;\\n        if m.len() % 2 != 0 {\\n            return first_item;\\n        }\\n\\n        let second_item = *m.nth_item(m.len() / 2) as f64;\\n        (first_item + second_item) / 2.0\\n    }\\n\\n    let mut map = MultiSet::new();\\n    let mut medians = vec![];\\n\\n    for num in nums[0..k].iter() {\\n        map.insert(*num);\\n    }\\n    medians.push(get_median(&map));\\n\\n    for (num_remove, num_add) in nums.iter().zip(nums[k..].iter()) {\\n        map.remove(*num_remove);\\n        map.insert(*num_add);\\n        medians.push(get_median(&map));\\n    }\\n\\n    medians\\n}\\n\\n\\n\\nimpl Solution {\\n    pub fn median_sliding_window(nums: Vec<i32>, k: i32) -> Vec<f64> {\\n        median_sliding_window(nums, k)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 581567,
                "title": "python-on-k-two-heap-solution",
                "content": "this idea is from https://leetcode.com/problems/sliding-window-median/discuss/412047/Two-heaps-%2B-sliding-window-approach-O(-n-*-k-)-runtime-O(k)-space\\nthanks @agconti\\n```\\nfrom heapq import * \\nimport heapq\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums, k: int) :\\n        \\'\\'\\'\\n        the concept/idea is that, you need to get access to the median every time you add a new element in to the heap\\n        also you need to remember to remove the passed one from the heap as well\\n        \\'\\'\\'\\n        self.maxheap,self.minheap,result = [],[],[]\\n        if not nums or len(nums) < k:\\n            return []\\n        for i in range(k-1):\\n            self.add_element(nums[i])\\n        for i in range(k-1,len(nums)):\\n            self.add_element(nums[i])\\n            tmpmedian = self.get_median()\\n            result.append(tmpmedian)\\n            self.delete_element(nums[i-k+1])\\n        return result\\n        \\n    def get_median(self):\\n        if len(self.maxheap) == len(self.minheap):\\n            return (-self.maxheap[0] + self.minheap[0])/2\\n        else:\\n            return self.minheap[0]\\n            \\n    def add_element(self,nums):\\n        heappush(self.maxheap,-heappushpop(self.minheap,nums))\\n        if len(self.maxheap) > len(self.minheap):\\n            heappush(self.minheap,-heappop(self.maxheap))\\n    \\n    def delete_element_in_heap(self, heap, num) -> None:\\n        index = heap.index(num)\\n        # delete in O(1)\\n        # replace the value we want to remove with the last value\\n        heap[index] = heap[-1]\\n        del heap[-1]\\n        \\n        # Restore heap property thoughout the tree\\n        if index < len(heap):\\n            heapq._siftup(heap, index)\\n            heapq._siftdown(heap, 0, index)\\n    \\n    def delete_element(self,nums):\\n        if nums >= self.minheap[0]:\\n            self.delete_element_in_heap(self.minheap,nums)\\n            return\\n        self.delete_element_in_heap(self.maxheap,-nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import * \\nimport heapq\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums, k: int) :\\n        \\'\\'\\'\\n        the concept/idea is that, you need to get access to the median every time you add a new element in to the heap\\n        also you need to remember to remove the passed one from the heap as well\\n        \\'\\'\\'\\n        self.maxheap,self.minheap,result = [],[],[]\\n        if not nums or len(nums) < k:\\n            return []\\n        for i in range(k-1):\\n            self.add_element(nums[i])\\n        for i in range(k-1,len(nums)):\\n            self.add_element(nums[i])\\n            tmpmedian = self.get_median()\\n            result.append(tmpmedian)\\n            self.delete_element(nums[i-k+1])\\n        return result\\n        \\n    def get_median(self):\\n        if len(self.maxheap) == len(self.minheap):\\n            return (-self.maxheap[0] + self.minheap[0])/2\\n        else:\\n            return self.minheap[0]\\n            \\n    def add_element(self,nums):\\n        heappush(self.maxheap,-heappushpop(self.minheap,nums))\\n        if len(self.maxheap) > len(self.minheap):\\n            heappush(self.minheap,-heappop(self.maxheap))\\n    \\n    def delete_element_in_heap(self, heap, num) -> None:\\n        index = heap.index(num)\\n        # delete in O(1)\\n        # replace the value we want to remove with the last value\\n        heap[index] = heap[-1]\\n        del heap[-1]\\n        \\n        # Restore heap property thoughout the tree\\n        if index < len(heap):\\n            heapq._siftup(heap, index)\\n            heapq._siftdown(heap, 0, index)\\n    \\n    def delete_element(self,nums):\\n        if nums >= self.minheap[0]:\\n            self.delete_element_in_heap(self.minheap,nums)\\n            return\\n        self.delete_element_in_heap(self.maxheap,-nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294182,
                "title": "too-long-java-code-avl-tree-99-speed-and-80-memory-balanced-and-unbalanced-bsts",
                "content": "Hi, I tried to solve with AVL tree in java. Really good thing would be to use MultiSet but since java doesn\\'t have it one built in, I tried to write own. Code became long.\\nTime complexity: O(n log(k))\\nSpace coplexity: O(n) \\n  where n is size of array and k is the size of window.\\n\\n```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || nums.length == 0)\\n            return new double[0];\\n        \\n        Node root = null;\\n        for (int i = 0; i < k; i++) {\\n            root = insert(root, nums[i]);\\n        }\\n        \\n        double[] r = new double[nums.length - k + 1];\\n        boolean even = k % 2 == 0;\\n        int j = 0;\\n        for (int i = k; i <= nums.length; i++) {\\n            double sum = 0.0;\\n            if (even)\\n                sum = (findSmallest(root, k/2).val + findSmallest(root, k/2 + 1).val) / 2.0;\\n            else\\n                sum = findSmallest(root, k/2 + 1).val;\\n            r[j++] = sum;\\n            if (i < nums.length) {\\n                root = insert(root, nums[i]);\\n                root = delete(root, nums[i - k]);\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    private Node findSmallest(Node root, int k) {\\n        int s = countWith(root.left) + 1;\\n        if (s == k)\\n            return root;\\n        if (s > k) {\\n            return findSmallest(root.left, k);\\n        }\\n        return findSmallest(root.right, k - s);\\n    } \\n  \\n    private Node delete(Node root, long val) {\\n        if (root == null)\\n            return null;\\n        else if (val > root.val) \\n            root.right = delete(root.right, val);\\n        else if (val < root.val)\\n            root.left = delete(root.left, val);\\n        else {\\n            if (root.left == null)\\n                root = root.right;\\n            else if (root.right == null)\\n                root = root.left;\\n            else {\\n                Node t = findMin(root.right);\\n                root.val = t.val;\\n                root.right = delete(root.right, t.val);\\n            }\\n        }\\n        \\n        return updateNode(root);\\n    }\\n    \\n    private Node findMin(Node root) {\\n        if (root.left != null)\\n            return findMin(root.left);\\n        return root;\\n    }\\n\\n    private Node insert(Node root, long val)\\n    {\\n        if (root == null)\\n        {\\n            return new Node(val);\\n        }\\n        if (val >= root.val)\\n        {\\n            root.right = insert(root.right, val);\\n        }\\n        else\\n        {\\n            root.left = insert(root.left, val);\\n        }\\n       \\n        return updateNode(root);\\n    }\\n    \\n    private Node updateNode(Node root) {\\n        int b = balance(root); \\t\\t\\n        if (b == 2 && balance(root.left) < 0)\\n        {\\n            root.left = leftRotate(root.left);\\n            root = rightRotate(root);\\n        }\\n        else if (b == -2 && balance(root.right) > 0)\\n        {\\n            root.right = rightRotate(root.right);\\n            root = leftRotate(root);\\n        }\\n        else if (b == 2)\\n        {\\n            root = rightRotate(root);\\n        }\\n        else if (b == -2)\\n        {\\n            root = leftRotate(root);\\n        }\\n        update(root);\\n        return root;\\n    }\\n\\n    private Node leftRotate(Node n)\\n    {\\n        Node r = n.right;\\n        n.right = r.left;\\n        r.left = n;\\n        update(n);\\n        update(r);\\n        return r;\\n    }\\n\\n    private Node rightRotate(Node n)\\n    {\\n        Node l = n.left;\\n        n.left = l.right;\\n        l.right = n;\\n        update(n);\\n        update(l);\\n        return l;\\n    }\\n\\n    private int balance(Node n)\\n    {\\n        if (n==null)return 0;\\n        return height(n.left) - height(n.right);\\n    }\\n\\n    private void update(Node n)\\n    {\\n        if (n==null)return;\\n        n.height = Math.max(height(n.left), height(n.right)) + 1;\\n        n.count = n.left != null ? n.left.count + 1 : 0;\\n        n.count += n.right != null ? n.right.count + 1 : 0;\\n    }\\n\\n    private int height(Node n)\\n    {\\n        return n != null ? n.height : 0;\\n    }\\n\\n    private int countWith(Node n)\\n    {\\n        return n != null ? n.count + 1 : 0;\\n    }\\n\\n    static class Node\\n    {\\n        Node left;\\n        Node right;\\n        long val;\\n        int count;\\n        int height;\\n\\n        Node(long val)\\n        {\\n            this.val = val;\\n        }\\n    }\\n}\\n\\n\\n\\n```\\n\\n\\n**For randomized input unbalanced BST** could be applied too, but worst case time complexity will be **O(n * k)**. The validating test cases for the submissions actually is giving random input, not targetting to hit the solution for unbalanced BST, so the following unbalanced bst aproach is also beats 99.8% by time. However wost case should not be forgetten.\\n\\n```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || nums.length == 0)\\n            return new double[0];\\n        \\n        Node root = null;\\n        for (int i = 0; i < k; i++) {\\n            root = insert(root, nums[i]);\\n        }\\n        \\n        double[] r = new double[nums.length - k + 1];\\n        boolean even = k % 2 == 0;\\n        int j = 0;\\n        for (int i = k; i <= nums.length; i++) {\\n            double sum = 0.0;\\n            if (even)\\n                sum = (findSmallest(root, k/2).val + findSmallest(root, k/2 + 1).val) / 2.0;\\n            else\\n                sum = findSmallest(root, k/2 + 1).val;\\n            r[j++] = sum;\\n            if (i < nums.length) {\\n                root = insert(root, nums[i]);\\n                root = delete(root, nums[i - k]);\\n            }\\n        }\\n        \\n        return r;\\n    }    \\n    \\n    private Node delete(Node root, long val) {\\n        if (root == null)\\n            return null;\\n        \\n        root.count--;\\n        if (val > root.val)\\n            root.right = delete(root.right, val);\\n        else if (val < root.val)\\n            root.left = delete(root.left, val);\\n        else {\\n            if (root.left == null && root.right == null)\\n                return null;\\n            else if (root.left == null || root.right == null) {\\n                return root.left == null ? root.right : root.left;\\n            } else {\\n                Node t = findMin(root.right);                \\n                root.val = t.val;\\n                root.right = delete(root.right, t.val);\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    private Node insert(Node root, long val)\\n    {\\n        if (root == null)\\n            return new Node(val);\\n        \\n        root.count++;\\n        if (val >= root.val)            \\n            root.right = insert(root.right, val);\\n        else\\n            root.left = insert(root.left, val);\\n        \\n        return root;\\n    }  \\n    \\n    private Node findSmallest(Node root, int k) {\\n        int s = countWith(root.left) + 1;\\n        if (s == k)\\n            return root;\\n        if (s > k) {\\n            return findSmallest(root.left, k);\\n        }\\n        return findSmallest(root.right, k - s);\\n    }\\n    \\n    private Node findMin(Node root) {\\n        if (root.left != null)\\n            return findMin(root.left);\\n        return root;\\n    } \\n\\n    private int countWith(Node n)\\n    {\\n        return n != null ? n.count + 1 : 0;\\n    }\\n\\n    static class Node\\n    {\\n        Node left;\\n        Node right;\\n        long val;\\n        int count;\\n\\n        Node(long val)\\n        {\\n            this.val = val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || nums.length == 0)\\n            return new double[0];\\n        \\n        Node root = null;\\n        for (int i = 0; i < k; i++) {\\n            root = insert(root, nums[i]);\\n        }\\n        \\n        double[] r = new double[nums.length - k + 1];\\n        boolean even = k % 2 == 0;\\n        int j = 0;\\n        for (int i = k; i <= nums.length; i++) {\\n            double sum = 0.0;\\n            if (even)\\n                sum = (findSmallest(root, k/2).val + findSmallest(root, k/2 + 1).val) / 2.0;\\n            else\\n                sum = findSmallest(root, k/2 + 1).val;\\n            r[j++] = sum;\\n            if (i < nums.length) {\\n                root = insert(root, nums[i]);\\n                root = delete(root, nums[i - k]);\\n            }\\n        }\\n        \\n        return r;\\n    }\\n    \\n    private Node findSmallest(Node root, int k) {\\n        int s = countWith(root.left) + 1;\\n        if (s == k)\\n            return root;\\n        if (s > k) {\\n            return findSmallest(root.left, k);\\n        }\\n        return findSmallest(root.right, k - s);\\n    } \\n  \\n    private Node delete(Node root, long val) {\\n        if (root == null)\\n            return null;\\n        else if (val > root.val) \\n            root.right = delete(root.right, val);\\n        else if (val < root.val)\\n            root.left = delete(root.left, val);\\n        else {\\n            if (root.left == null)\\n                root = root.right;\\n            else if (root.right == null)\\n                root = root.left;\\n            else {\\n                Node t = findMin(root.right);\\n                root.val = t.val;\\n                root.right = delete(root.right, t.val);\\n            }\\n        }\\n        \\n        return updateNode(root);\\n    }\\n    \\n    private Node findMin(Node root) {\\n        if (root.left != null)\\n            return findMin(root.left);\\n        return root;\\n    }\\n\\n    private Node insert(Node root, long val)\\n    {\\n        if (root == null)\\n        {\\n            return new Node(val);\\n        }\\n        if (val >= root.val)\\n        {\\n            root.right = insert(root.right, val);\\n        }\\n        else\\n        {\\n            root.left = insert(root.left, val);\\n        }\\n       \\n        return updateNode(root);\\n    }\\n    \\n    private Node updateNode(Node root) {\\n        int b = balance(root); \\t\\t\\n        if (b == 2 && balance(root.left) < 0)\\n        {\\n            root.left = leftRotate(root.left);\\n            root = rightRotate(root);\\n        }\\n        else if (b == -2 && balance(root.right) > 0)\\n        {\\n            root.right = rightRotate(root.right);\\n            root = leftRotate(root);\\n        }\\n        else if (b == 2)\\n        {\\n            root = rightRotate(root);\\n        }\\n        else if (b == -2)\\n        {\\n            root = leftRotate(root);\\n        }\\n        update(root);\\n        return root;\\n    }\\n\\n    private Node leftRotate(Node n)\\n    {\\n        Node r = n.right;\\n        n.right = r.left;\\n        r.left = n;\\n        update(n);\\n        update(r);\\n        return r;\\n    }\\n\\n    private Node rightRotate(Node n)\\n    {\\n        Node l = n.left;\\n        n.left = l.right;\\n        l.right = n;\\n        update(n);\\n        update(l);\\n        return l;\\n    }\\n\\n    private int balance(Node n)\\n    {\\n        if (n==null)return 0;\\n        return height(n.left) - height(n.right);\\n    }\\n\\n    private void update(Node n)\\n    {\\n        if (n==null)return;\\n        n.height = Math.max(height(n.left), height(n.right)) + 1;\\n        n.count = n.left != null ? n.left.count + 1 : 0;\\n        n.count += n.right != null ? n.right.count + 1 : 0;\\n    }\\n\\n    private int height(Node n)\\n    {\\n        return n != null ? n.height : 0;\\n    }\\n\\n    private int countWith(Node n)\\n    {\\n        return n != null ? n.count + 1 : 0;\\n    }\\n\\n    static class Node\\n    {\\n        Node left;\\n        Node right;\\n        long val;\\n        int count;\\n        int height;\\n\\n        Node(long val)\\n        {\\n            this.val = val;\\n        }\\n    }\\n}\\n\\n\\n\\n```\n```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums == null || nums.length == 0)\\n            return new double[0];\\n        \\n        Node root = null;\\n        for (int i = 0; i < k; i++) {\\n            root = insert(root, nums[i]);\\n        }\\n        \\n        double[] r = new double[nums.length - k + 1];\\n        boolean even = k % 2 == 0;\\n        int j = 0;\\n        for (int i = k; i <= nums.length; i++) {\\n            double sum = 0.0;\\n            if (even)\\n                sum = (findSmallest(root, k/2).val + findSmallest(root, k/2 + 1).val) / 2.0;\\n            else\\n                sum = findSmallest(root, k/2 + 1).val;\\n            r[j++] = sum;\\n            if (i < nums.length) {\\n                root = insert(root, nums[i]);\\n                root = delete(root, nums[i - k]);\\n            }\\n        }\\n        \\n        return r;\\n    }    \\n    \\n    private Node delete(Node root, long val) {\\n        if (root == null)\\n            return null;\\n        \\n        root.count--;\\n        if (val > root.val)\\n            root.right = delete(root.right, val);\\n        else if (val < root.val)\\n            root.left = delete(root.left, val);\\n        else {\\n            if (root.left == null && root.right == null)\\n                return null;\\n            else if (root.left == null || root.right == null) {\\n                return root.left == null ? root.right : root.left;\\n            } else {\\n                Node t = findMin(root.right);                \\n                root.val = t.val;\\n                root.right = delete(root.right, t.val);\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    private Node insert(Node root, long val)\\n    {\\n        if (root == null)\\n            return new Node(val);\\n        \\n        root.count++;\\n        if (val >= root.val)            \\n            root.right = insert(root.right, val);\\n        else\\n            root.left = insert(root.left, val);\\n        \\n        return root;\\n    }  \\n    \\n    private Node findSmallest(Node root, int k) {\\n        int s = countWith(root.left) + 1;\\n        if (s == k)\\n            return root;\\n        if (s > k) {\\n            return findSmallest(root.left, k);\\n        }\\n        return findSmallest(root.right, k - s);\\n    }\\n    \\n    private Node findMin(Node root) {\\n        if (root.left != null)\\n            return findMin(root.left);\\n        return root;\\n    } \\n\\n    private int countWith(Node n)\\n    {\\n        return n != null ? n.count + 1 : 0;\\n    }\\n\\n    static class Node\\n    {\\n        Node left;\\n        Node right;\\n        long val;\\n        int count;\\n\\n        Node(long val)\\n        {\\n            this.val = val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96357,
                "title": "c-binarysearch-solution",
                "content": "```\\npublic double[] MedianSlidingWindow(int[] nums, int k) {\\n    List<double> llist = new List<double>();\\n\\n    if (nums != null && nums.Length > 0 && k > 0) {\\n        int liPos1 = (k >> 1);\\n        int liPos2 = liPos1 + (k & 1) - 1;\\n\\n        List<double> llistSlid = new List<double>();\\n        \\n        for( int i = 0; i < nums.Length; ++i ) {\\n            if (i >= k  ) {\\n                llistSlid.Remove(nums[i - k ]);\\n            }\\n\\n            int liIndex = llistSlid.BinarySearch(nums[i]);\\n            if (liIndex < 0) {\\n                liIndex = ~liIndex;\\n            }\\n            llistSlid.Insert(liIndex, nums[i]);\\n\\n            if ( i >= k - 1 )\\n                llist.Add(liPos1 == liPos2 ? llistSlid[liPos1] : ((llistSlid[liPos1] + llistSlid[liPos2]) / 2));\\n        }\\n    }\\n\\n    return llist.ToArray<double>();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic double[] MedianSlidingWindow(int[] nums, int k) {\\n    List<double> llist = new List<double>();\\n\\n    if (nums != null && nums.Length > 0 && k > 0) {\\n        int liPos1 = (k >> 1);\\n        int liPos2 = liPos1 + (k & 1) - 1;\\n\\n        List<double> llistSlid = new List<double>();\\n        \\n        for( int i = 0; i < nums.Length; ++i ) {\\n            if (i >= k  ) {\\n                llistSlid.Remove(nums[i - k ]);\\n            }\\n\\n            int liIndex = llistSlid.BinarySearch(nums[i]);\\n            if (liIndex < 0) {\\n                liIndex = ~liIndex;\\n            }\\n            llistSlid.Insert(liIndex, nums[i]);\\n\\n            if ( i >= k - 1 )\\n                llist.Add(liPos1 == liPos2 ? llistSlid[liPos1] : ((llistSlid[liPos1] + llistSlid[liPos2]) / 2));\\n        }\\n    }\\n\\n    return llist.ToArray<double>();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96383,
                "title": "o-nlogk-python-solution-using-binary-search-tree",
                "content": "My solution is to store the K elements in the current window in a BST. The BST node has other two attributes: ```dup``` store the number of duplicates, ```left_count``` store the number of elements in the current node's left tree.\\n\\nThree methods of the BST class are implemented. ```insert``` inserts a new value to the tree, ```delete``` delete a value from the tree, ```find_kth```  find the kith smallest value in the tree. Each time the window moves, we deleted the old value, insert the new one, and using ```find_kth``` to find the median. All the above three methods are ```O(logk)```, so the time complexity is ```O(Nlogk)```\\n\\n\\n```\\nclass TreeNode(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.dup = 1\\n        self.left_count = 0\\n        self.left = None\\n        self.right = None\\n    \\n    def __repr__(self):\\n        return \"val: %r dup: %r small: %r\" %(self.val, self.dup, self.left_count)\\n        \\n\\nclass BST(object):\\n    def __init__(self):\\n        self.root = None\\n        self.count = 0\\n    \\n    def insert(self, num):\\n        #Insert number num into the BST\\n        self.count+=1\\n        \\n        if self.root==None:\\n            self.root = TreeNode(num)\\n            return\\n        \\n        prev, cur = None, self.root\\n        while cur is not None:\\n            prev = cur\\n            if cur.val == num:\\n                cur.dup+=1\\n                return\\n            elif cur.val < num:\\n                cur = cur.right\\n            else:\\n                #update the left_count\\n                cur.left_count+=1\\n                cur = cur.left\\n        if prev.val > num:\\n            prev.left = TreeNode(num)\\n        elif prev.val < num:\\n            prev.right = TreeNode(num)\\n        return\\n    \\n    def delete(self, num):\\n        #Delete number num from the BST, here it's guaranteed to find the number num\\n        self.count-=1\\n        \\n        prev, cur = None, self.root\\n        prev = TreeNode(-1000000)\\n        prev.right = self.root\\n        right_dir = True\\n        while True:\\n            if cur.val == num:\\n                break\\n            elif cur.val > num:\\n                cur.left_count-=1\\n                prev, cur = cur, cur.left\\n                right_dir = False\\n            else: #cur.val < num\\n                prev, cur = cur, cur.right\\n                right_dir = True\\n        \\n        #Find the node to delete, next step to delete the node\\n        if cur.dup>1:\\n            cur.dup-=1\\n            return\\n        \\n        #have to delete a node\\n        #node have no children\\n        if cur.left is None and cur.right is None:\\n            if cur==self.root: self.root=None\\n            elif right_dir: prev.right = None\\n            else: prev.left = None\\n            return\\n        #node have one childeren\\n        if cur.left is None:\\n            if cur == self.root: self.root = cur.right\\n            elif right_dir: prev.right = cur.right\\n            else: prev.left = cur.right\\n            return\\n        if cur.right is None:\\n            if cur == self.root: self.root = cur.left\\n            elif right_dir: prev.right = cur.left\\n            else: prev.left = cur.left\\n            return\\n        \\n        #node have two children\\n        next_prev, next_cur = cur, cur.right\\n        while next_cur.left is not None:\\n            next_prev, next_cur = next_cur, next_cur.left\\n        \\n        if next_cur == cur.right:\\n            cur.val = next_cur.val\\n            cur.dup = next_cur.dup\\n            cur.right = next_cur.right\\n            return\\n            \\n        elif next_cur != cur.right:\\n            next_prev.left = next_cur.right\\n            cur.val = next_cur.val\\n            cur.dup = next_cur.dup\\n            dup_to_del = cur.dup\\n            # next_prev.left = None\\n            p = cur.right\\n            while p is not None and p.val>=next_prev.val:\\n                p.left_count -= dup_to_del\\n                p = p.left\\n        return\\n    \\n    def find_median(self):\\n        k = (self.count+1)/2\\n        if self.count%2==1:\\n            return self.find_kth(k)+0.0\\n        else:\\n            return (0.+self.find_kth(k)+self.find_kth(k+1))/2\\n        \\n    def find_kth(self, k):\\n        #find the kth smallest element in the tree\\n        return self.find_kth_help(k, self.root)\\n        \\n    def find_kth_help(self, k, node):\\n        if node.left_count < k <= node.left_count+node.dup:\\n            return node.val\\n        if k <= node.left_count:\\n            return self.find_kth_help(k, node.left)\\n        else:\\n            return self.find_kth_help(k-node.left_count-node.dup, node.right)\\n\\n\\nclass Solution(object):\\n    def medianSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[float]\\n        \"\"\"\\n        if k==0:\\n            return []\\n        if k==1:\\n            return [i+0. for i in nums]\\n        \\n        tree = BST()\\n        for i in range(k):\\n            tree.insert(nums[i])\\n        \\n        result = []\\n        for i in range(k, len(nums)):\\n            result.append(tree.find_median())\\n            tree.delete(nums[i-k])\\n            tree.insert(nums[i])\\n        result.append(tree.find_median())\\n        # print result\\n        return result\\n```",
                "solutionTags": [],
                "code": "```dup```\n```left_count```\n```insert```\n```delete```\n```find_kth```\n```find_kth```\n```O(logk)```\n```O(Nlogk)```\n```\\nclass TreeNode(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.dup = 1\\n        self.left_count = 0\\n        self.left = None\\n        self.right = None\\n    \\n    def __repr__(self):\\n        return \"val: %r dup: %r small: %r\" %(self.val, self.dup, self.left_count)\\n        \\n\\nclass BST(object):\\n    def __init__(self):\\n        self.root = None\\n        self.count = 0\\n    \\n    def insert(self, num):\\n        #Insert number num into the BST\\n        self.count+=1\\n        \\n        if self.root==None:\\n            self.root = TreeNode(num)\\n            return\\n        \\n        prev, cur = None, self.root\\n        while cur is not None:\\n            prev = cur\\n            if cur.val == num:\\n                cur.dup+=1\\n                return\\n            elif cur.val < num:\\n                cur = cur.right\\n            else:\\n                #update the left_count\\n                cur.left_count+=1\\n                cur = cur.left\\n        if prev.val > num:\\n            prev.left = TreeNode(num)\\n        elif prev.val < num:\\n            prev.right = TreeNode(num)\\n        return\\n    \\n    def delete(self, num):\\n        #Delete number num from the BST, here it's guaranteed to find the number num\\n        self.count-=1\\n        \\n        prev, cur = None, self.root\\n        prev = TreeNode(-1000000)\\n        prev.right = self.root\\n        right_dir = True\\n        while True:\\n            if cur.val == num:\\n                break\\n            elif cur.val > num:\\n                cur.left_count-=1\\n                prev, cur = cur, cur.left\\n                right_dir = False\\n            else: #cur.val < num\\n                prev, cur = cur, cur.right\\n                right_dir = True\\n        \\n        #Find the node to delete, next step to delete the node\\n        if cur.dup>1:\\n            cur.dup-=1\\n            return\\n        \\n        #have to delete a node\\n        #node have no children\\n        if cur.left is None and cur.right is None:\\n            if cur==self.root: self.root=None\\n            elif right_dir: prev.right = None\\n            else: prev.left = None\\n            return\\n        #node have one childeren\\n        if cur.left is None:\\n            if cur == self.root: self.root = cur.right\\n            elif right_dir: prev.right = cur.right\\n            else: prev.left = cur.right\\n            return\\n        if cur.right is None:\\n            if cur == self.root: self.root = cur.left\\n            elif right_dir: prev.right = cur.left\\n            else: prev.left = cur.left\\n            return\\n        \\n        #node have two children\\n        next_prev, next_cur = cur, cur.right\\n        while next_cur.left is not None:\\n            next_prev, next_cur = next_cur, next_cur.left\\n        \\n        if next_cur == cur.right:\\n            cur.val = next_cur.val\\n            cur.dup = next_cur.dup\\n            cur.right = next_cur.right\\n            return\\n            \\n        elif next_cur != cur.right:\\n            next_prev.left = next_cur.right\\n            cur.val = next_cur.val\\n            cur.dup = next_cur.dup\\n            dup_to_del = cur.dup\\n            # next_prev.left = None\\n            p = cur.right\\n            while p is not None and p.val>=next_prev.val:\\n                p.left_count -= dup_to_del\\n                p = p.left\\n        return\\n    \\n    def find_median(self):\\n        k = (self.count+1)/2\\n        if self.count%2==1:\\n            return self.find_kth(k)+0.0\\n        else:\\n            return (0.+self.find_kth(k)+self.find_kth(k+1))/2\\n        \\n    def find_kth(self, k):\\n        #find the kth smallest element in the tree\\n        return self.find_kth_help(k, self.root)\\n        \\n    def find_kth_help(self, k, node):\\n        if node.left_count < k <= node.left_count+node.dup:\\n            return node.val\\n        if k <= node.left_count:\\n            return self.find_kth_help(k, node.left)\\n        else:\\n            return self.find_kth_help(k-node.left_count-node.dup, node.right)\\n\\n\\nclass Solution(object):\\n    def medianSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[float]\\n        \"\"\"\\n        if k==0:\\n            return []\\n        if k==1:\\n            return [i+0. for i in nums]\\n        \\n        tree = BST()\\n        for i in range(k):\\n            tree.insert(nums[i])\\n        \\n        result = []\\n        for i in range(k, len(nums)):\\n            result.append(tree.find_median())\\n            tree.delete(nums[i-k])\\n            tree.insert(nums[i])\\n        result.append(tree.find_median())\\n        # print result\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96396,
                "title": "c-solution-o-n-k",
                "content": "The idea is to maintain a BST of the window and just search for the k/2 largest element and k/2 smallest element  then the average of these two is the median of the window.\\n\\n Now if the STL's multiset  BST maintained how many element were in each subtree finding each median would take O(log k) time  but since it  doesn't it takes O(k) time to find each  median.\\n\\n```class Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        multiset<int> mp;\\n        vector<double> med;\\n        \\n        for(int i=0; i<k-1; ++i) mp.insert(nums[i]);\\n        \\n        for(int i=k-1; i< nums.size(); ++i){\\n            mp.insert(nums[i]); // Add the next number\\n            \\n            auto itb = mp.begin(); advance(itb, (k-1)/2); //Find the lower median\\n            auto ite = mp.end(); advance(ite, -(k+1)/2); //Find the upper median\\n        \\n            double avg = ((long)(*itb) + (*ite)) / 2.0;\\n            med.push_back(avg);\\n        \\n            mp.erase(mp.find(nums[i-k+1])); //Remove the oldest element\\n        }\\n        \\n        return med;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        multiset<int> mp;\\n        vector<double> med;\\n        \\n        for(int i=0; i<k-1; ++i) mp.insert(nums[i]);\\n        \\n        for(int i=k-1; i< nums.size(); ++i){\\n            mp.insert(nums[i]); // Add the next number\\n            \\n            auto itb = mp.begin(); advance(itb, (k-1)/2); //Find the lower median\\n            auto ite = mp.end(); advance(ite, -(k+1)/2); //Find the upper median\\n        \\n            double avg = ((long)(*itb) + (*ite)) / 2.0;\\n            med.push_back(avg);\\n        \\n            mp.erase(mp.find(nums[i-k+1])); //Remove the oldest element\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3281293,
                "title": "480-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if the list is empty or the window size is greater than the list length. If either of these conditions is true, return an empty list.\\n\\n2. Create a helper function to calculate the median of a given subarray. If the length of the subarray is odd, return the middle element. If the length of the subarray is even, return the mean of the two middle elements.\\n\\n3. Create a deque to store the current window.\\n\\n4. Create an empty list to store the medians.\\n\\n5. Iterate over each element in the list. For each element:\\na. Add the element to the deque.\\nb. If the deque has reached the size of the window, calculate the median of the current window using the helper function and append it to the list of medians.\\nc. Remove the leftmost element from the deque to maintain the window size.\\n\\n6. Return the list of medians.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        n = len(nums)\\n        # edge case: empty list or window size greater than list length\\n        if n == 0 or k > n:\\n            return []\\n        \\n        # helper function to get median of a subarray\\n        def get_median(arr):\\n            n = len(arr)\\n            # if length is odd, return middle element\\n            if n % 2 == 1:\\n                return arr[n // 2]\\n            # if length is even, return mean of middle elements\\n            return (arr[n // 2] + arr[n // 2 - 1]) / 2\\n        \\n        # initialize deque to store current window\\n        window = collections.deque()\\n        # initialize result list to store medians\\n        res = []\\n        \\n        # iterate over each element in nums\\n        for i, x in enumerate(nums):\\n            # add element to window\\n            window.append(x)\\n            # if window size is reached, get median and append to res\\n            if len(window) == k:\\n                res.append(get_median(sorted(window)))\\n                # remove leftmost element from window\\n                window.popleft()\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        n = len(nums)\\n        # edge case: empty list or window size greater than list length\\n        if n == 0 or k > n:\\n            return []\\n        \\n        # helper function to get median of a subarray\\n        def get_median(arr):\\n            n = len(arr)\\n            # if length is odd, return middle element\\n            if n % 2 == 1:\\n                return arr[n // 2]\\n            # if length is even, return mean of middle elements\\n            return (arr[n // 2] + arr[n // 2 - 1]) / 2\\n        \\n        # initialize deque to store current window\\n        window = collections.deque()\\n        # initialize result list to store medians\\n        res = []\\n        \\n        # iterate over each element in nums\\n        for i, x in enumerate(nums):\\n            # add element to window\\n            window.append(x)\\n            # if window size is reached, get median and append to res\\n            if len(window) == k:\\n                res.append(get_median(sorted(window)))\\n                # remove leftmost element from window\\n                window.popleft()\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967744,
                "title": "using-multiset-beats-90-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int b;\\n    double picaro;\\n    multiset<long long > halfmin,halfmax;\\n    vector<double> ans;\\n    void huy(int v)\\n    {\\n        b=0;\\n        if(halfmin.size()==halfmax.size())\\n        {\\n            b=1;\\n            if(v>*halfmax.begin())   halfmax.insert(v);\\n            else halfmin.insert(v);\\n        }\\n        if(halfmin.size()>halfmax.size()&&b==0)\\n        {\\n            if(v>=*halfmin.rbegin()) halfmax.insert(v);\\n            if(v<*halfmin.rbegin())\\n            {\\n                int huy=*halfmin.rbegin();\\n                halfmin.erase(halfmin.find(huy));\\n                halfmax.insert(huy);\\n                halfmin.insert(v);\\n            }\\n        }\\n        if(halfmin.size()<halfmax.size()&&b==0)\\n        {\\n            if(v<=*halfmax.begin()) halfmin.insert(v);\\n            if(v>*halfmax.begin())\\n            {\\n                int huy=*halfmax.begin();\\n                halfmax.erase(halfmax.find(huy));\\n                halfmin.insert(huy);\\n                halfmax.insert(v);\\n            }\\n        }\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        if(nums.size()==1){ ans.push_back(nums[0]); return ans; }\\n        if(k==1)\\n        {\\n            for(int i=0;i<=nums.size()-1;i++) ans.push_back(nums[i]);\\n            return ans;\\n        }\\n        if(k==2)\\n        {\\n            for(int i=1;i<=nums.size()-1;i++) \\n            {\\n                long long g=long(nums[i])+long(nums[i-1]);\\n                ans.push_back(double(g)/2);\\n            }\\n            return ans;\\n        }\\n        for(int i=0;i<=nums.size()-1;i++)\\n        {\\n            if(i<=k-1)\\n            {\\n                if(i==0) halfmin.insert(nums[i]);\\n                if(i==1) \\n                {\\n                    halfmax.insert(nums[i]);\\n                    if(*halfmax.begin()<*halfmin.rbegin())\\n                        halfmax.swap(halfmin);\\n                  //  cout << *halfmax.begin() << \" \" << *halfmin.rbegin();\\n                }\\n                if(i>1)\\n                {\\n                    huy(nums[i]);\\n                }\\n                if(i==k-1)\\n                {\\n                    if(k%2==0)\\n                    {\\n                      picaro=double(double(*halfmin.rbegin())+double(*halfmax.begin()))/2;\\n                      ans.push_back(picaro);  \\n                    }\\n                    if(k%2==1)\\n                    {\\n                        if(halfmin.size()>halfmax.size())\\n                            ans.push_back(*halfmin.rbegin());\\n                        if(halfmin.size()<halfmax.size())\\n                            ans.push_back(*halfmax.begin());\\n                        // cout << halfmin.size() << \"  \" << halfmax.size();\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                if(halfmin.count(nums[i-k])==0&&halfmax.count(nums[i-k])!=0)\\n                    halfmax.erase(halfmax.find(nums[i-k]));\\n                if(halfmin.count(nums[i-k])!=0)\\n                    halfmin.erase(halfmin.find(nums[i-k]));\\n                huy(nums[i]);\\n                if(k%2==0)\\n                    {\\n                      picaro=double(double(*halfmin.rbegin())+double(*halfmax.begin()))/2;\\n                      ans.push_back(picaro);  \\n                    }\\n                if(k%2==1)\\n                {\\n                    if(halfmin.size()>halfmax.size())\\n                        ans.push_back(*halfmin.rbegin());\\n                    if(halfmin.size()<halfmax.size())\\n                        ans.push_back(*halfmax.begin());\\n                }\\n            }\\n          /*  if(i!=0)\\n            {\\n            cout << *halfmin.begin() << \" \" << *halfmin.rbegin() << endl;\\n            cout << *halfmax.begin() << \" \" << *halfmax.rbegin() << endl;\\n            cout << endl;\\n            }\\n          */  \\n        }\\n            return ans;\\n        }\\n    };\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int b;\\n    double picaro;\\n    multiset<long long > halfmin,halfmax;\\n    vector<double> ans;\\n    void huy(int v)\\n    {\\n        b=0;\\n        if(halfmin.size()==halfmax.size())\\n        {\\n            b=1;\\n            if(v>*halfmax.begin())   halfmax.insert(v);\\n            else halfmin.insert(v);\\n        }\\n        if(halfmin.size()>halfmax.size()&&b==0)\\n        {\\n            if(v>=*halfmin.rbegin()) halfmax.insert(v);\\n            if(v<*halfmin.rbegin())\\n            {\\n                int huy=*halfmin.rbegin();\\n                halfmin.erase(halfmin.find(huy));\\n                halfmax.insert(huy);\\n                halfmin.insert(v);\\n            }\\n        }\\n        if(halfmin.size()<halfmax.size()&&b==0)\\n        {\\n            if(v<=*halfmax.begin()) halfmin.insert(v);\\n            if(v>*halfmax.begin())\\n            {\\n                int huy=*halfmax.begin();\\n                halfmax.erase(halfmax.find(huy));\\n                halfmin.insert(huy);\\n                halfmax.insert(v);\\n            }\\n        }\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        if(nums.size()==1){ ans.push_back(nums[0]); return ans; }\\n        if(k==1)\\n        {\\n            for(int i=0;i<=nums.size()-1;i++) ans.push_back(nums[i]);\\n            return ans;\\n        }\\n        if(k==2)\\n        {\\n            for(int i=1;i<=nums.size()-1;i++) \\n            {\\n                long long g=long(nums[i])+long(nums[i-1]);\\n                ans.push_back(double(g)/2);\\n            }\\n            return ans;\\n        }\\n        for(int i=0;i<=nums.size()-1;i++)\\n        {\\n            if(i<=k-1)\\n            {\\n                if(i==0) halfmin.insert(nums[i]);\\n                if(i==1) \\n                {\\n                    halfmax.insert(nums[i]);\\n                    if(*halfmax.begin()<*halfmin.rbegin())\\n                        halfmax.swap(halfmin);\\n                  //  cout << *halfmax.begin() << \" \" << *halfmin.rbegin();\\n                }\\n                if(i>1)\\n                {\\n                    huy(nums[i]);\\n                }\\n                if(i==k-1)\\n                {\\n                    if(k%2==0)\\n                    {\\n                      picaro=double(double(*halfmin.rbegin())+double(*halfmax.begin()))/2;\\n                      ans.push_back(picaro);  \\n                    }\\n                    if(k%2==1)\\n                    {\\n                        if(halfmin.size()>halfmax.size())\\n                            ans.push_back(*halfmin.rbegin());\\n                        if(halfmin.size()<halfmax.size())\\n                            ans.push_back(*halfmax.begin());\\n                        // cout << halfmin.size() << \"  \" << halfmax.size();\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                if(halfmin.count(nums[i-k])==0&&halfmax.count(nums[i-k])!=0)\\n                    halfmax.erase(halfmax.find(nums[i-k]));\\n                if(halfmin.count(nums[i-k])!=0)\\n                    halfmin.erase(halfmin.find(nums[i-k]));\\n                huy(nums[i]);\\n                if(k%2==0)\\n                    {\\n                      picaro=double(double(*halfmin.rbegin())+double(*halfmax.begin()))/2;\\n                      ans.push_back(picaro);  \\n                    }\\n                if(k%2==1)\\n                {\\n                    if(halfmin.size()>halfmax.size())\\n                        ans.push_back(*halfmin.rbegin());\\n                    if(halfmin.size()<halfmax.size())\\n                        ans.push_back(*halfmax.begin());\\n                }\\n            }\\n          /*  if(i!=0)\\n            {\\n            cout << *halfmin.begin() << \" \" << *halfmin.rbegin() << endl;\\n            cout << *halfmax.begin() << \" \" << *halfmax.rbegin() << endl;\\n            cout << endl;\\n            }\\n          */  \\n        }\\n            return ans;\\n        }\\n    };\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 2156963,
                "title": "simple-c-code-2-multiset",
                "content": "# Reference was taken from youtube channel.\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        multiset<double> asc;\\n        multiset<double, greater<double>> des;\\n        int n = nums.size();\\n        vector<double> ans;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i >= k)\\n            {\\n                auto ita = asc.find(nums[i-k]);\\n                if(ita == asc.end())\\n                {\\n                    auto itd = des.find(nums[i-k]);\\n                    des.erase(itd);\\n                }\\n                else\\n                {\\n                    asc.erase(ita);\\n                }\\n            }\\n            asc.insert(nums[i]);\\n            des.insert(*asc.begin());\\n            asc.erase(asc.begin());\\n            if(des.size() > asc.size())\\n            {\\n                asc.insert(*des.begin());\\n                des.erase(des.begin());\\n            }\\n            if(i >= k-1)\\n            {\\n                double medn;\\n                if(k%2 == 0)\\n                {\\n                    medn = (*asc.begin() + *des.begin())/2;\\n                    ans.push_back(medn);   \\n                }\\n                else\\n                {\\n                    medn = *asc.begin();\\n                    ans.push_back(medn);\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        multiset<double> asc;\\n        multiset<double, greater<double>> des;\\n        int n = nums.size();\\n        vector<double> ans;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i >= k)\\n            {\\n                auto ita = asc.find(nums[i-k]);\\n                if(ita == asc.end())\\n                {\\n                    auto itd = des.find(nums[i-k]);\\n                    des.erase(itd);\\n                }\\n                else\\n                {\\n                    asc.erase(ita);\\n                }\\n            }\\n            asc.insert(nums[i]);\\n            des.insert(*asc.begin());\\n            asc.erase(asc.begin());\\n            if(des.size() > asc.size())\\n            {\\n                asc.insert(*des.begin());\\n                des.erase(des.begin());\\n            }\\n            if(i >= k-1)\\n            {\\n                double medn;\\n                if(k%2 == 0)\\n                {\\n                    medn = (*asc.begin() + *des.begin())/2;\\n                    ans.push_back(medn);   \\n                }\\n                else\\n                {\\n                    medn = *asc.begin();\\n                    ans.push_back(medn);\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127035,
                "title": "java-solution-using-2-priority-queues-median-priority-queue-easy-to-understand",
                "content": "Please upvote, if you find it useful :)\\n\\n```\\nclass Solution {\\n    \\n    public PriorityQueue<Integer> left = new PriorityQueue<>(Collections.reverseOrder());\\n    public PriorityQueue<Integer> right = new PriorityQueue<>();\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        for(int i=0; i<k; i++) {\\n            addNum(nums[i]);\\n        }\\n        \\n        double[] ans = new double[nums.length - k + 1];\\n        int j = 0;\\n        ans[j] = findMedian();\\n        for(int i=k; i<nums.length; i++) {\\n            remove(nums[j]);\\n            addNum(nums[i]);\\n            j += 1;\\n            ans[j] = findMedian();\\n        }\\n        \\n        return ans;\\n    }\\n\\n    public void addNum(int num) {\\n        if(right.peek() == null) {\\n            left.add(num);\\n        } else if(num > right.peek()){\\n            right.add(num);\\n        } else {\\n            left.add(num);\\n        }\\n        \\n        if(Math.abs(left.size() - right.size()) > 1) {\\n            if(left.size() > right.size()) {\\n                right.add(left.remove());\\n            } else {\\n                left.add(right.remove());\\n            }\\n        }\\n    }\\n    \\n    public void remove(int num) {\\n        if(right.size() > 0 && num >= right.peek()) {\\n            right.remove(num);\\n        } else {\\n            left.remove(num);\\n        }\\n        \\n        if(Math.abs(left.size() - right.size()) > 1) {\\n            if(left.size() > right.size()) {\\n                right.add(left.remove());\\n            } else {\\n                left.add(right.remove());\\n            }\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if(left.size() > right.size()) {\\n            return (double)left.peek();\\n        } else if(right.size() > left.size()) {\\n            return (double)right.peek();\\n        } else {\\n            return (left.peek() / 2.0) + (right.peek() / 2.0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public PriorityQueue<Integer> left = new PriorityQueue<>(Collections.reverseOrder());\\n    public PriorityQueue<Integer> right = new PriorityQueue<>();\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        for(int i=0; i<k; i++) {\\n            addNum(nums[i]);\\n        }\\n        \\n        double[] ans = new double[nums.length - k + 1];\\n        int j = 0;\\n        ans[j] = findMedian();\\n        for(int i=k; i<nums.length; i++) {\\n            remove(nums[j]);\\n            addNum(nums[i]);\\n            j += 1;\\n            ans[j] = findMedian();\\n        }\\n        \\n        return ans;\\n    }\\n\\n    public void addNum(int num) {\\n        if(right.peek() == null) {\\n            left.add(num);\\n        } else if(num > right.peek()){\\n            right.add(num);\\n        } else {\\n            left.add(num);\\n        }\\n        \\n        if(Math.abs(left.size() - right.size()) > 1) {\\n            if(left.size() > right.size()) {\\n                right.add(left.remove());\\n            } else {\\n                left.add(right.remove());\\n            }\\n        }\\n    }\\n    \\n    public void remove(int num) {\\n        if(right.size() > 0 && num >= right.peek()) {\\n            right.remove(num);\\n        } else {\\n            left.remove(num);\\n        }\\n        \\n        if(Math.abs(left.size() - right.size()) > 1) {\\n            if(left.size() > right.size()) {\\n                right.add(left.remove());\\n            } else {\\n                left.add(right.remove());\\n            }\\n        }\\n    }\\n    \\n    public double findMedian() {\\n        if(left.size() > right.size()) {\\n            return (double)left.peek();\\n        } else if(right.size() > left.size()) {\\n            return (double)right.peek();\\n        } else {\\n            return (left.peek() / 2.0) + (right.peek() / 2.0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069559,
                "title": "python-easy-to-understand-using-2-heap",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def getMedian(self, maxHeap: List[int], minHeap: List[int]) -> float:\\n        # minHeap stores larger half and maxHeap stores small half elements\\n        # So data is like -> [maxHeap] + [minHeap]\\n        # if total no of element is odd, then maxHeap contains more elements than minHeap\\n        if len(maxHeap)==0: return 0\\n        elif len(maxHeap)!=len(minHeap): return -maxHeap[0]\\n        else: return (-maxHeap[0]+minHeap[0])/2\\n\\n    def adjustHeapSize(self, maxHeap: List[int], minHeap: List[int]) -> None:\\n        while len(maxHeap)<len(minHeap) or len(maxHeap)>len(minHeap)+1:\\n            if len(maxHeap)>len(minHeap)+1:\\n                removedMaxHeapItem = -heapq.heappop(maxHeap)\\n                heapq.heappush(minHeap, removedMaxHeapItem)\\n            else:\\n                removedMaxHeapItem = heapq.heappop(minHeap)\\n                heapq.heappush(maxHeap, -removedMaxHeapItem)\\n\\n    def addElement(self, maxHeap: List[int], minHeap: List[int], num: int, k: int) -> None:\\n        median = self.getMedian(maxHeap, minHeap)\\n        if num<=median: #Insert to maxHeap\\n            heapq.heappush(maxHeap, -num)\\n        else:\\n            heapq.heappush(minHeap, num)\\n        #print(num, maxHeap, minHeap, \\'Before add adjust\\')\\n        self.adjustHeapSize(maxHeap, minHeap)\\n\\n    def removeElement(self, maxHeap: List[int], minHeap: List[int], num: int) -> None:\\n        median = self.getMedian(maxHeap, minHeap)\\n        #print(num, \"Remove\", maxHeap, minHeap, median)\\n        if num<=median: #Insert to maxHeap\\n            maxHeap.remove(-num)\\n            heapq.heapify(maxHeap)\\n        else:\\n            minHeap.remove(num)\\n            heapq.heapify(minHeap)\\n        #print(num, maxHeap, minHeap, \\'Before remove adjust\\')\\n        self.adjustHeapSize(maxHeap, minHeap)\\n\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        maxHeap, minHeap, output = [], [], []\\n        for i in range(len(nums)):\\n            self.addElement(maxHeap, minHeap, nums[i], k)\\n            #print(maxHeap, minHeap, \\'Added\\', nums[i])\\n            if i>=k-1:\\n                output.append(self.getMedian(maxHeap, minHeap))\\n                #print(nums, i, i-k+1)\\n                self.removeElement(maxHeap, minHeap, nums[i-k+1])\\n                #print(maxHeap, minHeap, \\'Removed\\', nums[i-k+1])\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def getMedian(self, maxHeap: List[int], minHeap: List[int]) -> float:\\n        # minHeap stores larger half and maxHeap stores small half elements\\n        # So data is like -> [maxHeap] + [minHeap]\\n        # if total no of element is odd, then maxHeap contains more elements than minHeap\\n        if len(maxHeap)==0: return 0\\n        elif len(maxHeap)!=len(minHeap): return -maxHeap[0]\\n        else: return (-maxHeap[0]+minHeap[0])/2\\n\\n    def adjustHeapSize(self, maxHeap: List[int], minHeap: List[int]) -> None:\\n        while len(maxHeap)<len(minHeap) or len(maxHeap)>len(minHeap)+1:\\n            if len(maxHeap)>len(minHeap)+1:\\n                removedMaxHeapItem = -heapq.heappop(maxHeap)\\n                heapq.heappush(minHeap, removedMaxHeapItem)\\n            else:\\n                removedMaxHeapItem = heapq.heappop(minHeap)\\n                heapq.heappush(maxHeap, -removedMaxHeapItem)\\n\\n    def addElement(self, maxHeap: List[int], minHeap: List[int], num: int, k: int) -> None:\\n        median = self.getMedian(maxHeap, minHeap)\\n        if num<=median: #Insert to maxHeap\\n            heapq.heappush(maxHeap, -num)\\n        else:\\n            heapq.heappush(minHeap, num)\\n        #print(num, maxHeap, minHeap, \\'Before add adjust\\')\\n        self.adjustHeapSize(maxHeap, minHeap)\\n\\n    def removeElement(self, maxHeap: List[int], minHeap: List[int], num: int) -> None:\\n        median = self.getMedian(maxHeap, minHeap)\\n        #print(num, \"Remove\", maxHeap, minHeap, median)\\n        if num<=median: #Insert to maxHeap\\n            maxHeap.remove(-num)\\n            heapq.heapify(maxHeap)\\n        else:\\n            minHeap.remove(num)\\n            heapq.heapify(minHeap)\\n        #print(num, maxHeap, minHeap, \\'Before remove adjust\\')\\n        self.adjustHeapSize(maxHeap, minHeap)\\n\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        maxHeap, minHeap, output = [], [], []\\n        for i in range(len(nums)):\\n            self.addElement(maxHeap, minHeap, nums[i], k)\\n            #print(maxHeap, minHeap, \\'Added\\', nums[i])\\n            if i>=k-1:\\n                output.append(self.getMedian(maxHeap, minHeap))\\n                #print(nums, i, i-k+1)\\n                self.removeElement(maxHeap, minHeap, nums[i-k+1])\\n                #print(maxHeap, minHeap, \\'Removed\\', nums[i-k+1])\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827586,
                "title": "c-2-heaps-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> ans;\\n    unordered_map<int, int> m; //to store the elements to be discarded\\n    priority_queue<int> maxh; //max heap for lower half \\n    priority_queue<int, vector<int>, greater<int>> minh; //min heap for upper half \\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k;i++){\\n            maxh.push(nums[i]);\\n        }\\n        for(int i=k/2;i>0;i--){\\n            minh.push(maxh.top());\\n            maxh.pop();\\n        }\\n        for(int i=k;i<n;i++){\\n            if(k%2==0){\\n                ans.push_back(((double)maxh.top()+(double)minh.top())/2.0);\\n            }\\n            else{\\n                ans.push_back(maxh.top()*1.0);\\n            }\\n            int p=nums[i-k];\\n            int q=nums[i];\\n            int balance=0;\\n            \\n            // discarding p if it\\'s at the top, otherwise storing it in map\\n            if(p<=maxh.top()){\\n                balance--;\\n                if(p==maxh.top()){\\n                    maxh.pop();\\n                }\\n                else{\\n                    m[p]++;\\n                }\\n            }\\n            else{\\n                balance++;\\n                if(p==minh.top()){\\n                    minh.pop();\\n                }\\n                else{\\n                    m[p]++;\\n                }\\n            }\\n            \\n            // balancing, if needed\\n            \\n            if(!maxh.empty() && q<=maxh.top()){\\n                balance++;\\n                maxh.push(q);\\n            }\\n            else{\\n                balance--;\\n                minh.push(q);\\n            }\\n            \\n            if(balance<0){\\n                maxh.push(minh.top());\\n                minh.pop();\\n            }\\n            else if(balance>0){\\n                minh.push(maxh.top());\\n                maxh.pop();\\n            }\\n            \\n            // popping off the top if it\\'s present in the map\\n            \\n            while(!maxh.empty() && m[maxh.top()]){\\n                m[maxh.top()]--;\\n                maxh.pop();\\n            }\\n            \\n            while(!minh.empty() && m[minh.top()]){\\n                m[minh.top()]--;\\n                minh.pop();\\n            }\\n        }\\n        if(k%2==0){\\n            ans.push_back(((double)maxh.top()+(double)minh.top())/2.0);\\n        }\\n        else{\\n            ans.push_back(maxh.top()*1.0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> ans;\\n    unordered_map<int, int> m; //to store the elements to be discarded\\n    priority_queue<int> maxh; //max heap for lower half \\n    priority_queue<int, vector<int>, greater<int>> minh; //min heap for upper half \\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<k;i++){\\n            maxh.push(nums[i]);\\n        }\\n        for(int i=k/2;i>0;i--){\\n            minh.push(maxh.top());\\n            maxh.pop();\\n        }\\n        for(int i=k;i<n;i++){\\n            if(k%2==0){\\n                ans.push_back(((double)maxh.top()+(double)minh.top())/2.0);\\n            }\\n            else{\\n                ans.push_back(maxh.top()*1.0);\\n            }\\n            int p=nums[i-k];\\n            int q=nums[i];\\n            int balance=0;\\n            \\n            // discarding p if it\\'s at the top, otherwise storing it in map\\n            if(p<=maxh.top()){\\n                balance--;\\n                if(p==maxh.top()){\\n                    maxh.pop();\\n                }\\n                else{\\n                    m[p]++;\\n                }\\n            }\\n            else{\\n                balance++;\\n                if(p==minh.top()){\\n                    minh.pop();\\n                }\\n                else{\\n                    m[p]++;\\n                }\\n            }\\n            \\n            // balancing, if needed\\n            \\n            if(!maxh.empty() && q<=maxh.top()){\\n                balance++;\\n                maxh.push(q);\\n            }\\n            else{\\n                balance--;\\n                minh.push(q);\\n            }\\n            \\n            if(balance<0){\\n                maxh.push(minh.top());\\n                minh.pop();\\n            }\\n            else if(balance>0){\\n                minh.push(maxh.top());\\n                maxh.pop();\\n            }\\n            \\n            // popping off the top if it\\'s present in the map\\n            \\n            while(!maxh.empty() && m[maxh.top()]){\\n                m[maxh.top()]--;\\n                maxh.pop();\\n            }\\n            \\n            while(!minh.empty() && m[minh.top()]){\\n                m[minh.top()]--;\\n                minh.pop();\\n            }\\n        }\\n        if(k%2==0){\\n            ans.push_back(((double)maxh.top()+(double)minh.top())/2.0);\\n        }\\n        else{\\n            ans.push_back(maxh.top()*1.0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766499,
                "title": "c-solution-priorityqueue-similar-solution-for-leet-code-295-and-leet-code-480",
                "content": "Lets first understand the solution of problem #295 - Median of data streams\\n\\n1. Partition streaming numbers into 2 halves\\n2. maxHeap - for all smaller numbers\\n3. minHeap - for all larger numbers\\n4. Balance heap - whenever difference of both heap size > 1\\n5. Find Median - for odd numbers - maxHeap peek is median, for even numbers - average of minHeap peek and maxHeap peek\\n6. For problem #480, we need one extra step, maintain one sliding window of size k, when window size is reached remove left most element from heap\\n\\nLC 295\\n\\n```\\n    public class MedianFinder\\n    {\\n        private readonly PriorityQueue<int, int> _minHeap;\\n        private readonly PriorityQueue<int, int> _maxHeap;\\n\\n        public MedianFinder()\\n        {\\n            _minHeap = new PriorityQueue<int, int>();\\n            _maxHeap = new PriorityQueue<int, int>(Comparer<int>.Create((a, b) => b.CompareTo(a)));\\n        }\\n\\n        public void AddNum(int num)\\n        {\\n            if (_maxHeap.Count == 0 || _maxHeap.Peek() >= num)\\n                _maxHeap.Enqueue(num, num);\\n            else\\n                _minHeap.Enqueue(num, num);\\n            Balance();\\n        }\\n\\n        public double FindMedian()\\n        {\\n            return _maxHeap.Count > _minHeap.Count ?\\n                _maxHeap.Peek() :\\n                _minHeap.Peek() / 2.0 + _maxHeap.Peek() / 2.0;\\n        }\\n\\n        private void Balance()\\n        {\\n            if (_maxHeap.Count == _minHeap.Count)\\n                return;\\n            if (_maxHeap.Count > _minHeap.Count + 1)\\n            {\\n                int maxHeapPeek = _maxHeap.Dequeue();\\n                _minHeap.Enqueue(maxHeapPeek, maxHeapPeek);\\n            }\\n            else if (_maxHeap.Count < _minHeap.Count)\\n            {\\n                int minHeapPeek = _minHeap.Dequeue();\\n                _maxHeap.Enqueue(minHeapPeek, minHeapPeek);\\n            }\\n        }\\n    }\\n```\\n\\nLC 480\\n\\n```\\npublic class Solution {\\n    \\n    private PriorityQueue<int, int> _minHeap = new PriorityQueue<int, int>();//all bigger numbers\\n    private PriorityQueue<int, int> _maxHeap = new PriorityQueue<int, int>(Comparer<int>.Create((a, b) => b.CompareTo(a)));//all smaller numbers\\n    \\n    public double[] MedianSlidingWindow(int[] nums, int k) {\\n        double[] medians = new double[nums.Length - k + 1];\\n        for(int left = 0, right = 0; right < nums.Length; right++){\\n            AddNum(nums[right]);\\n            if(right - left + 1 == k){\\n                medians[right - k + 1] = FindMedian();\\n                Remove(nums[left]);\\n                left++;\\n            }\\n        }\\n        return medians;\\n    }\\n    \\n    public void AddNum(int num)\\n    {\\n        if(_maxHeap.Count == 0 || _maxHeap.Peek() >= num)\\n            _maxHeap.Enqueue(num, num);\\n        else\\n            _minHeap.Enqueue(num, num);\\n        Balance();\\n    }\\n    \\n    private void Balance(){\\n        if(_maxHeap.Count == _minHeap.Count)\\n            return;\\n        if(_maxHeap.Count > _minHeap.Count + 1)\\n        {\\n            int maxHeapPeek = _maxHeap.Dequeue();\\n            _minHeap.Enqueue(maxHeapPeek, maxHeapPeek);\\n        }\\n        else if(_maxHeap.Count < _minHeap.Count)\\n        {\\n            int minHeapPeek = _minHeap.Dequeue();\\n            _maxHeap.Enqueue(minHeapPeek, minHeapPeek);\\n        }\\n    }\\n\\n    public double FindMedian()\\n    {\\n        return _maxHeap.Count > _minHeap.Count ?\\n            _maxHeap.Peek() :\\n            _minHeap.Peek() / 2.0 + _maxHeap.Peek() / 2.0;\\n    }\\n    \\n    public void Remove(int num){\\n        if(num > _maxHeap.Peek())\\n            Remove(_minHeap, num);\\n        else\\n            Remove(_maxHeap, num);\\n        Balance();    \\n    }\\n    \\n    public void Remove(PriorityQueue<int, int> heap, int num){\\n        List<int> buffer = new List<int>();\\n        while(heap.Count > 0 && heap.Peek() != num)\\n            buffer.Add(heap.Dequeue());\\n        heap.Dequeue();\\n        buffer.ForEach(n => heap.Enqueue(n, n));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public class MedianFinder\\n    {\\n        private readonly PriorityQueue<int, int> _minHeap;\\n        private readonly PriorityQueue<int, int> _maxHeap;\\n\\n        public MedianFinder()\\n        {\\n            _minHeap = new PriorityQueue<int, int>();\\n            _maxHeap = new PriorityQueue<int, int>(Comparer<int>.Create((a, b) => b.CompareTo(a)));\\n        }\\n\\n        public void AddNum(int num)\\n        {\\n            if (_maxHeap.Count == 0 || _maxHeap.Peek() >= num)\\n                _maxHeap.Enqueue(num, num);\\n            else\\n                _minHeap.Enqueue(num, num);\\n            Balance();\\n        }\\n\\n        public double FindMedian()\\n        {\\n            return _maxHeap.Count > _minHeap.Count ?\\n                _maxHeap.Peek() :\\n                _minHeap.Peek() / 2.0 + _maxHeap.Peek() / 2.0;\\n        }\\n\\n        private void Balance()\\n        {\\n            if (_maxHeap.Count == _minHeap.Count)\\n                return;\\n            if (_maxHeap.Count > _minHeap.Count + 1)\\n            {\\n                int maxHeapPeek = _maxHeap.Dequeue();\\n                _minHeap.Enqueue(maxHeapPeek, maxHeapPeek);\\n            }\\n            else if (_maxHeap.Count < _minHeap.Count)\\n            {\\n                int minHeapPeek = _minHeap.Dequeue();\\n                _maxHeap.Enqueue(minHeapPeek, minHeapPeek);\\n            }\\n        }\\n    }\\n```\n```\\npublic class Solution {\\n    \\n    private PriorityQueue<int, int> _minHeap = new PriorityQueue<int, int>();//all bigger numbers\\n    private PriorityQueue<int, int> _maxHeap = new PriorityQueue<int, int>(Comparer<int>.Create((a, b) => b.CompareTo(a)));//all smaller numbers\\n    \\n    public double[] MedianSlidingWindow(int[] nums, int k) {\\n        double[] medians = new double[nums.Length - k + 1];\\n        for(int left = 0, right = 0; right < nums.Length; right++){\\n            AddNum(nums[right]);\\n            if(right - left + 1 == k){\\n                medians[right - k + 1] = FindMedian();\\n                Remove(nums[left]);\\n                left++;\\n            }\\n        }\\n        return medians;\\n    }\\n    \\n    public void AddNum(int num)\\n    {\\n        if(_maxHeap.Count == 0 || _maxHeap.Peek() >= num)\\n            _maxHeap.Enqueue(num, num);\\n        else\\n            _minHeap.Enqueue(num, num);\\n        Balance();\\n    }\\n    \\n    private void Balance(){\\n        if(_maxHeap.Count == _minHeap.Count)\\n            return;\\n        if(_maxHeap.Count > _minHeap.Count + 1)\\n        {\\n            int maxHeapPeek = _maxHeap.Dequeue();\\n            _minHeap.Enqueue(maxHeapPeek, maxHeapPeek);\\n        }\\n        else if(_maxHeap.Count < _minHeap.Count)\\n        {\\n            int minHeapPeek = _minHeap.Dequeue();\\n            _maxHeap.Enqueue(minHeapPeek, minHeapPeek);\\n        }\\n    }\\n\\n    public double FindMedian()\\n    {\\n        return _maxHeap.Count > _minHeap.Count ?\\n            _maxHeap.Peek() :\\n            _minHeap.Peek() / 2.0 + _maxHeap.Peek() / 2.0;\\n    }\\n    \\n    public void Remove(int num){\\n        if(num > _maxHeap.Peek())\\n            Remove(_minHeap, num);\\n        else\\n            Remove(_maxHeap, num);\\n        Balance();    \\n    }\\n    \\n    public void Remove(PriorityQueue<int, int> heap, int num){\\n        List<int> buffer = new List<int>();\\n        while(heap.Count > 0 && heap.Peek() != num)\\n            buffer.Add(heap.Dequeue());\\n        heap.Dequeue();\\n        buffer.ForEach(n => heap.Enqueue(n, n));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691049,
                "title": "java-simple-solution-using-min-heap-and-max-heap",
                "content": "Slide through each of the window of size K and calculate median of each window.\\nTime Complexity : **O(nlogn)**\\nSpace Complexity: **O(n)**\\n\\n```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n    \\n    \\n    private void removeFromHeap(int n) {\\n       if(n<=maxHeap.peek()) {\\n           if(maxHeap.size() > minHeap.size()) {\\n               maxHeap.remove(n);\\n           }else {\\n               maxHeap.remove(n);\\n               maxHeap.add(minHeap.poll());\\n           }\\n       }else {\\n           if(maxHeap.size() > minHeap.size()) {\\n               minHeap.remove(n);\\n               minHeap.add(maxHeap.poll());\\n           }else {\\n               minHeap.remove(n);\\n           }\\n       }\\n    }\\n    \\n    private void insertToHeap(int num) {\\n        if(maxHeap.isEmpty()) {\\n            maxHeap.add(num);\\n        }else {\\n            if(maxHeap.size() > minHeap.size()) {\\n                if(maxHeap.peek() < num) {\\n                    minHeap.add(num);\\n                }else {\\n                    minHeap.add(maxHeap.poll());\\n                    maxHeap.add(num);\\n                }\\n            }else {\\n                if(maxHeap.peek() <= num) {\\n                    minHeap.add(num);\\n                    maxHeap.add(minHeap.poll());\\n                }else {\\n                    maxHeap.add(num);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private double median() {\\n        if(maxHeap.size()>minHeap.size()) {\\n            return maxHeap.peek();\\n        }\\n        long sum = (long)maxHeap.peek() + (long)minHeap.peek();\\n        return (double)((sum)/2.0);\\n    }\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int n = nums.length - k + 1;\\n        double[] res = new double[n];\\n        \\n        for(int i=0; i<=nums.length; ++i) {\\n            if(i>=k) {\\n                res[i-k] = median();\\n                removeFromHeap(nums[i-k]);\\n            }\\n            \\n            if(i<nums.length) {\\n                insertToHeap(nums[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n    \\n    \\n    private void removeFromHeap(int n) {\\n       if(n<=maxHeap.peek()) {\\n           if(maxHeap.size() > minHeap.size()) {\\n               maxHeap.remove(n);\\n           }else {\\n               maxHeap.remove(n);\\n               maxHeap.add(minHeap.poll());\\n           }\\n       }else {\\n           if(maxHeap.size() > minHeap.size()) {\\n               minHeap.remove(n);\\n               minHeap.add(maxHeap.poll());\\n           }else {\\n               minHeap.remove(n);\\n           }\\n       }\\n    }\\n    \\n    private void insertToHeap(int num) {\\n        if(maxHeap.isEmpty()) {\\n            maxHeap.add(num);\\n        }else {\\n            if(maxHeap.size() > minHeap.size()) {\\n                if(maxHeap.peek() < num) {\\n                    minHeap.add(num);\\n                }else {\\n                    minHeap.add(maxHeap.poll());\\n                    maxHeap.add(num);\\n                }\\n            }else {\\n                if(maxHeap.peek() <= num) {\\n                    minHeap.add(num);\\n                    maxHeap.add(minHeap.poll());\\n                }else {\\n                    maxHeap.add(num);\\n                }\\n            }\\n        }\\n    }\\n    \\n    private double median() {\\n        if(maxHeap.size()>minHeap.size()) {\\n            return maxHeap.peek();\\n        }\\n        long sum = (long)maxHeap.peek() + (long)minHeap.peek();\\n        return (double)((sum)/2.0);\\n    }\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int n = nums.length - k + 1;\\n        double[] res = new double[n];\\n        \\n        for(int i=0; i<=nums.length; ++i) {\\n            if(i>=k) {\\n                res[i-k] = median();\\n                removeFromHeap(nums[i-k]);\\n            }\\n            \\n            if(i<nums.length) {\\n                insertToHeap(nums[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318803,
                "title": "c-solution-using-gnu-pbds",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<pair<int,int>,null_type,less<pair<int,int>>,rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& a, int k) {\\n        ordered_set os;\\n        int i,j,n=a.size();\\n        for(int i=0;i<k;i++){\\n            os.insert({a[i],i});\\n        }\\n        vector<double> v;\\n        k--;\\n        int t1=k/2,t2=k+1;\\n        t2/=2;\\n        k++;\\n        for(int i=k;i<=n;i++){\\n            long long int o=os.find_by_order(t1)->first;\\n            long long int t=os.find_by_order(t2)->first;\\n            if(k%2)\\n            v.push_back(o);\\n            else{\\n                o+=t;\\n                v.push_back(o/2.0);\\n            }\\n            os.erase({a[i-k],i-k});\\n            if(i<n)\\n            os.insert({a[i],i});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<pair<int,int>,null_type,less<pair<int,int>>,rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& a, int k) {\\n        ordered_set os;\\n        int i,j,n=a.size();\\n        for(int i=0;i<k;i++){\\n            os.insert({a[i],i});\\n        }\\n        vector<double> v;\\n        k--;\\n        int t1=k/2,t2=k+1;\\n        t2/=2;\\n        k++;\\n        for(int i=k;i<=n;i++){\\n            long long int o=os.find_by_order(t1)->first;\\n            long long int t=os.find_by_order(t2)->first;\\n            if(k%2)\\n            v.push_back(o);\\n            else{\\n                o+=t;\\n                v.push_back(o/2.0);\\n            }\\n            os.erase({a[i-k],i-k});\\n            if(i<n)\\n            os.insert({a[i],i});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1295767,
                "title": "c-solution-two-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    multiset<int,greater<int>>left;\\n    multiset<int>right;\\n      void balance()\\n    {\\n        if(left.size()-right.size()==2)\\n        {\\n            int val=*left.begin();\\n            left.erase(left.begin());\\n            right.insert(val);\\n        }\\n        else if(right.size()-left.size()==2)\\n        {\\n            int val=*right.begin();\\n            right.erase(right.begin());\\n            left.insert(val);\\n        }\\n    }\\n    void remove(int x)\\n    {\\n        if(left.find(x)!=left.end())\\n        {\\n            left.erase(left.find(x));\\n        }\\n        else if(right.find(x)!=right.end())\\n        {\\n            right.erase(right.find(x));\\n        }\\n        balance();\\n    }\\n    void add(int num)\\n    {\\n        if(right.size()>0&&num>*right.begin())\\n        {\\n            right.insert(num);\\n        }\\n        else\\n        {\\n            left.insert(num);\\n        }\\n        balance();\\n    }\\n    double med()\\n    {\\n        long long val1=*left.begin();\\n        long long val2=*right.begin();\\n        if(left.size()==right.size())\\n        {\\n            return (double)(val1+val2)/2.0;\\n        }\\n        else if(left.size()>right.size())\\n        {\\n            return (double)(*left.begin());\\n        }\\n        else\\n        {\\n            return (double)(*right.begin());\\n        }\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) \\n    {\\n        vector<double>v;\\n        for(int i=0;i<k;i++)\\n        {\\n            add(nums[i]);\\n        }\\n        v.push_back(med());\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            remove(nums[i-k]);\\n            add(nums[i]);\\n            v.push_back(med());\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    multiset<int,greater<int>>left;\\n    multiset<int>right;\\n      void balance()\\n    {\\n        if(left.size()-right.size()==2)\\n        {\\n            int val=*left.begin();\\n            left.erase(left.begin());\\n            right.insert(val);\\n        }\\n        else if(right.size()-left.size()==2)\\n        {\\n            int val=*right.begin();\\n            right.erase(right.begin());\\n            left.insert(val);\\n        }\\n    }\\n    void remove(int x)\\n    {\\n        if(left.find(x)!=left.end())\\n        {\\n            left.erase(left.find(x));\\n        }\\n        else if(right.find(x)!=right.end())\\n        {\\n            right.erase(right.find(x));\\n        }\\n        balance();\\n    }\\n    void add(int num)\\n    {\\n        if(right.size()>0&&num>*right.begin())\\n        {\\n            right.insert(num);\\n        }\\n        else\\n        {\\n            left.insert(num);\\n        }\\n        balance();\\n    }\\n    double med()\\n    {\\n        long long val1=*left.begin();\\n        long long val2=*right.begin();\\n        if(left.size()==right.size())\\n        {\\n            return (double)(val1+val2)/2.0;\\n        }\\n        else if(left.size()>right.size())\\n        {\\n            return (double)(*left.begin());\\n        }\\n        else\\n        {\\n            return (double)(*right.begin());\\n        }\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) \\n    {\\n        vector<double>v;\\n        for(int i=0;i<k;i++)\\n        {\\n            add(nums[i]);\\n        }\\n        v.push_back(med());\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            remove(nums[i-k]);\\n            add(nums[i]);\\n            v.push_back(med());\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280048,
                "title": "python3-sortedlist",
                "content": "\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        ans = []\\n        sl = SortedList()\\n        for i, x in enumerate(nums): \\n            sl.add(x)\\n            if i >= k: sl.remove(nums[i-k])\\n            if i+1 >= k: \\n                val = sl[k//2]\\n                if not k&1: val = (sl[(k-1)//2] + val)/2\\n                ans.append(val)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        ans = []\\n        sl = SortedList()\\n        for i, x in enumerate(nums): \\n            sl.add(x)\\n            if i >= k: sl.remove(nums[i-k])\\n            if i+1 >= k: \\n                val = sl[k//2]\\n                if not k&1: val = (sl[(k-1)//2] + val)/2\\n                ans.append(val)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200656,
                "title": "multiset-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void Balance(multiset<int> & left, multiset<int> & right) {\\n        int n = left.size();\\n        int m = right.size();\\n        if (n == m || n+1 == m) return;\\n        if (n > m) {\\n            auto it = left.end();\\n            it--;\\n            right.emplace(*it);\\n            left.erase(it);\\n        } \\n        else {\\n            left.emplace(* right.begin());\\n            right.erase(right.begin());\\n        }\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> ans;\\n        multiset<int> left;\\n        multiset<int> right;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            if (!right.empty() && nums[i] < * right.begin()) left.insert(nums[i]);\\n            else right.insert(nums[i]);\\n            Balance(left, right);\\n            if (i >= k) {\\n                auto it = left.find(nums[i-k]);\\n                if (it != left.end()) left.erase(it);\\n                else it = right.find(nums[i-k]), right.erase(it);\\n                Balance(left, right);\\n            }\\n          if (i >= k-1) { \\n              double res = 0;\\n              auto it = right.begin();\\n              if (k % 2 == 0) { \\n                  auto it_ = left.end();\\n                  it_--;\\n                  res = (double)( (long long) *it + *it_ ) / 2;\\n              }\\n              else res = *it;\\n              ans.push_back(res);\\n          }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void Balance(multiset<int> & left, multiset<int> & right) {\\n        int n = left.size();\\n        int m = right.size();\\n        if (n == m || n+1 == m) return;\\n        if (n > m) {\\n            auto it = left.end();\\n            it--;\\n            right.emplace(*it);\\n            left.erase(it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1061979,
                "title": "python-bisect-solution-easy-to-understand-faster-than-99-83",
                "content": "```\\nimport bisect\\n\\nclass Solution:\\n\\tdef median(self, nums: List[int]) -> float:\\n\\t\\tmid = len(nums) // 2\\n\\t\\tif len(nums) % 2:\\n\\t\\t\\treturn nums[mid]\\n\\t\\treturn (nums[mid-1] + nums[mid])/2\\n    \\n\\tdef medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n\\t\\tif not nums:\\n\\t\\t\\treturn []\\n\\n\\t\\tans = []\\n\\t\\tprev_idx = 0\\n\\t\\twin = sorted(nums[:(k-1)])\\n\\t\\tfor n in nums[(k-1):]:\\n\\t\\t\\tbisect.insort(win, n)\\n\\t\\t\\tans.append(self.median(win))\\n\\t\\t\\tdel win[bisect.bisect_left(win, nums[prev_idx])]\\n\\t\\t\\tprev_idx += 1\\n\\t\\treturn ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n\\tdef median(self, nums: List[int]) -> float:\\n\\t\\tmid = len(nums) // 2\\n\\t\\tif len(nums) % 2:\\n\\t\\t\\treturn nums[mid]\\n\\t\\treturn (nums[mid-1] + nums[mid])/2\\n    \\n\\tdef medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n\\t\\tif not nums:\\n\\t\\t\\treturn []\\n\\n\\t\\tans = []\\n\\t\\tprev_idx = 0\\n\\t\\twin = sorted(nums[:(k-1)])\\n\\t\\tfor n in nums[(k-1):]:\\n\\t\\t\\tbisect.insort(win, n)\\n\\t\\t\\tans.append(self.median(win))\\n\\t\\t\\tdel win[bisect.bisect_left(win, nums[prev_idx])]\\n\\t\\t\\tprev_idx += 1\\n\\t\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875190,
                "title": "sliding-window-easy-to-understand-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getIndex(vector<int>& window,int element){ //binary search\\n        int first = 0;\\n        int last = window.size()-1;\\n        while(first<=last){\\n            int mid = (first+last)/2;\\n            if(window[mid] == element)\\n                return mid;\\n            if(window[mid] > element)\\n            {\\n                last = mid - 1;\\n            }\\n            else\\n            {\\n                first = mid + 1;\\n            }\\n        }\\n        return first; //if not found return position where element needs to be inserted\\n    }\\n    void eraseAndAdd(vector<int>& slidingWindow,int deleteElement,int addElement){\\n        int size = slidingWindow.size();\\n        int deleteIndex = getIndex(slidingWindow,deleteElement);\\n        slidingWindow.erase(slidingWindow.begin()+deleteIndex);\\n        int addIndex = getIndex(slidingWindow,addElement);\\n        slidingWindow.insert(slidingWindow.begin()+addIndex,addElement);\\n        // cout<<\" delete index \"<<deleteElement<<\" is \"<<deleteIndex<<\" insert index \"<<addElement<<\" is\"<<addIndex<<endl; \\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> slidingWindow;\\n        vector<double> result;\\n        for(int i = 0;i<k;i++)\\n        {\\n            slidingWindow.push_back(nums[i]);  //initial window creation\\n        }\\n        sort(slidingWindow.begin(),slidingWindow.end()); //sorting initial window\\n        bool even=false;\\n        if(k%2 == 1){\\n            result.push_back(slidingWindow[(k/2)]);\\n        }\\n        else{\\n            result.push_back(slidingWindow[(k/2)]/2.0 + slidingWindow[(k/2)-1]/2.0);\\n            even=true;\\n        }\\n        int size = nums.size();\\n        for(int i = 1;i<size-k+1;i++){\\n            eraseAndAdd(slidingWindow,nums[i-1],nums[i+k-1]); //adding next element to window & deleting element before start of window\\n            if(even)\\n            {\\n                result.push_back(slidingWindow[(k/2)]/2.0 + slidingWindow[(k/2)-1]/2.0);\\n            }\\n            else\\n            {\\n                result.push_back(slidingWindow[(k/2)]);\\n            }    \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getIndex(vector<int>& window,int element){ //binary search\\n        int first = 0;\\n        int last = window.size()-1;\\n        while(first<=last){\\n            int mid = (first+last)/2;\\n            if(window[mid] == element)\\n                return mid;\\n            if(window[mid] > element)\\n            {\\n                last = mid - 1;\\n            }\\n            else\\n            {\\n                first = mid + 1;\\n            }\\n        }\\n        return first; //if not found return position where element needs to be inserted\\n    }\\n    void eraseAndAdd(vector<int>& slidingWindow,int deleteElement,int addElement){\\n        int size = slidingWindow.size();\\n        int deleteIndex = getIndex(slidingWindow,deleteElement);\\n        slidingWindow.erase(slidingWindow.begin()+deleteIndex);\\n        int addIndex = getIndex(slidingWindow,addElement);\\n        slidingWindow.insert(slidingWindow.begin()+addIndex,addElement);\\n        // cout<<\" delete index \"<<deleteElement<<\" is \"<<deleteIndex<<\" insert index \"<<addElement<<\" is\"<<addIndex<<endl; \\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> slidingWindow;\\n        vector<double> result;\\n        for(int i = 0;i<k;i++)\\n        {\\n            slidingWindow.push_back(nums[i]);  //initial window creation\\n        }\\n        sort(slidingWindow.begin(),slidingWindow.end()); //sorting initial window\\n        bool even=false;\\n        if(k%2 == 1){\\n            result.push_back(slidingWindow[(k/2)]);\\n        }\\n        else{\\n            result.push_back(slidingWindow[(k/2)]/2.0 + slidingWindow[(k/2)-1]/2.0);\\n            even=true;\\n        }\\n        int size = nums.size();\\n        for(int i = 1;i<size-k+1;i++){\\n            eraseAndAdd(slidingWindow,nums[i-1],nums[i+k-1]); //adding next element to window & deleting element before start of window\\n            if(even)\\n            {\\n                result.push_back(slidingWindow[(k/2)]/2.0 + slidingWindow[(k/2)-1]/2.0);\\n            }\\n            else\\n            {\\n                result.push_back(slidingWindow[(k/2)]);\\n            }    \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 869294,
                "title": "c-using-multiset-beats-98",
                "content": "```c++\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& a, int k) {\\n        int n=a.size();\\n        multiset<ll> m;\\n        for(ll i=0;i<k;i++)m.insert(a[i]);\\n        auto it=m.begin();\\n        for(ll i=0;i<k/2;i++)\\n            it++;\\n        ll med=*it;\\n        vector<double> ans;\\n        for(ll i=k;i<n;i++){\\n            auto ij=it;\\n            ij--;\\n            if(k%2==0)\\n                ans.push_back((*ij+*it)/2.0);\\n            else\\n                ans.push_back(*it);\\n            m.insert(a[i]);\\n            if(a[i]<*it)\\n                it--;\\n            if(a[i-k]<=*it)\\n                it++;\\n            m.erase(m.lower_bound(a[i-k]));\\n        }\\n        auto ij=it;\\n        ij--;\\n        if(k%2==0)\\n            ans.push_back((*ij+*it)/2.0);\\n        else\\n            ans.push_back(*it);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& a, int k) {\\n        int n=a.size();\\n        multiset<ll> m;\\n        for(ll i=0;i<k;i++)m.insert(a[i]);\\n        auto it=m.begin();\\n        for(ll i=0;i<k/2;i++)\\n            it++;\\n        ll med=*it;\\n        vector<double> ans;\\n        for(ll i=k;i<n;i++){\\n            auto ij=it;\\n            ij--;\\n            if(k%2==0)\\n                ans.push_back((*ij+*it)/2.0);\\n            else\\n                ans.push_back(*it);\\n            m.insert(a[i]);\\n            if(a[i]<*it)\\n                it--;\\n            if(a[i-k]<=*it)\\n                it++;\\n            m.erase(m.lower_bound(a[i-k]));\\n        }\\n        auto ij=it;\\n        ij--;\\n        if(k%2==0)\\n            ans.push_back((*ij+*it)/2.0);\\n        else\\n            ans.push_back(*it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680600,
                "title": "c-using-multiset",
                "content": "//next(it,n) returns the iterator at the next address of the given n from it\\n```\\n vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n    vector<double> ans;\\n    if (k == 0) return ans;\\n    multiset<int>s(nums.begin(), nums.begin() + k);\\n    auto mid = next(s.begin(), (k - 1) / 2);\\n    if(k%2!=0)\\n    {\\n        ans.push_back(*(mid)/1.0);\\n    }\\n    else\\n    {\\n        ans.push_back(((*mid)/1.0 + *next(mid, (k + 1) % 2)) / 2.0);\\n    }\\n    for (int i = k; i < nums.size(); ++i) \\n    { \\n      s.erase(s.lower_bound(nums[i - k])); \\n      s.insert(nums[i]);\\n      mid = next(s.begin(), (k - 1) / 2);\\n      if(k%2!=0)\\n     {\\n        ans.push_back(*(mid)/1.0);\\n     }\\n     else\\n     {\\n        ans.push_back(((*mid)/1.0 + *next(mid, (k + 1) % 2)) / 2.0);\\n     }\\n    }\\n    return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n    vector<double> ans;\\n    if (k == 0) return ans;\\n    multiset<int>s(nums.begin(), nums.begin() + k);\\n    auto mid = next(s.begin(), (k - 1) / 2);\\n    if(k%2!=0)\\n    {\\n        ans.push_back(*(mid)/1.0);\\n    }\\n    else\\n    {\\n        ans.push_back(((*mid)/1.0 + *next(mid, (k + 1) % 2)) / 2.0);\\n    }\\n    for (int i = k; i < nums.size(); ++i) \\n    { \\n      s.erase(s.lower_bound(nums[i - k])); \\n      s.insert(nums[i]);\\n      mid = next(s.begin(), (k - 1) / 2);\\n      if(k%2!=0)\\n     {\\n        ans.push_back(*(mid)/1.0);\\n     }\\n     else\\n     {\\n        ans.push_back(((*mid)/1.0 + *next(mid, (k + 1) % 2)) / 2.0);\\n     }\\n    }\\n    return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 525617,
                "title": "simple-javascript-solution-with-sliding-window",
                "content": "```\\nvar medianSlidingWindow = function(nums, k) {\\n    if (!nums.length) {\\n        return [];\\n    }\\n\\n    // find the median of the first window\\n    const firstSlided = nums.slice(0, k);\\n\\n    let medians = [findMedian(firstSlided)];\\n\\n    for (let i = k; i < nums.length; i++) {\\n        const slidedArr = nums.slice(i - k + 1, i + 1);\\n        medians.push(findMedian(slidedArr));\\n    }\\n\\n    return medians;\\n};\\n\\nconst findMedian = (arr) => {\\n    // get copy of the original array\\n    const a = arr.slice();\\n\\n    // should be SORTED\\n    a.sort((a, b) => a - b);\\n\\n    const n = a.length;\\n\\n    const middle = a[Math.floor(n / 2)];\\n\\n    // ODD LENGTH\\n    if ((n & 1) !== 0) {\\n        return middle;\\n    } else {\\n        // EVEN LENGTH\\n        return (Math.floor(a[Math.floor((n - 1) / 2)] + middle) / 2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar medianSlidingWindow = function(nums, k) {\\n    if (!nums.length) {\\n        return [];\\n    }\\n\\n    // find the median of the first window\\n    const firstSlided = nums.slice(0, k);\\n\\n    let medians = [findMedian(firstSlided)];\\n\\n    for (let i = k; i < nums.length; i++) {\\n        const slidedArr = nums.slice(i - k + 1, i + 1);\\n        medians.push(findMedian(slidedArr));\\n    }\\n\\n    return medians;\\n};\\n\\nconst findMedian = (arr) => {\\n    // get copy of the original array\\n    const a = arr.slice();\\n\\n    // should be SORTED\\n    a.sort((a, b) => a - b);\\n\\n    const n = a.length;\\n\\n    const middle = a[Math.floor(n / 2)];\\n\\n    // ODD LENGTH\\n    if ((n & 1) !== 0) {\\n        return middle;\\n    } else {\\n        // EVEN LENGTH\\n        return (Math.floor(a[Math.floor((n - 1) / 2)] + middle) / 2);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 353984,
                "title": "short-and-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res=new double[nums.length-k+1];\\n        if(nums==null || nums.length==0 || k<=0) return res;\\n        PriorityQueue<Integer> left=new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Integer> right=new PriorityQueue<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(left.size()<=right.size()){\\n                right.add(nums[i]);\\n                left.add(right.remove());\\n            }\\n            else{\\n                left.add(nums[i]);\\n                right.add(left.remove());\\n            }\\n            if(left.size()+right.size()==k){\\n                double median;\\n                if(left.size()==right.size()) median=(double)((long)left.peek()+(long)right.peek())/2;\\n                else median=(double)left.peek();\\n                int start=i-k+1;\\n                res[start]=median;\\n                if(!left.remove(nums[start]))\\n                    right.remove(nums[start]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        double[] res=new double[nums.length-k+1];\\n        if(nums==null || nums.length==0 || k<=0) return res;\\n        PriorityQueue<Integer> left=new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Integer> right=new PriorityQueue<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(left.size()<=right.size()){\\n                right.add(nums[i]);\\n                left.add(right.remove());\\n            }\\n            else{\\n                left.add(nums[i]);\\n                right.add(left.remove());\\n            }\\n            if(left.size()+right.size()==k){\\n                double median;\\n                if(left.size()==right.size()) median=(double)((long)left.peek()+(long)right.peek())/2;\\n                else median=(double)left.peek();\\n                int start=i-k+1;\\n                res[start]=median;\\n                if(!left.remove(nums[start]))\\n                    right.remove(nums[start]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259159,
                "title": "design-and-implement-the-interface-of-hash-heap-in-java",
                "content": "```\\nclass Solution {\\n\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        // maxHeap maitians the half small part\\n        // maitain the propetry (*): maxHeap.size() - minHeap.size() = 0 or 1 \\n        if(nums.length==0 || k<=0){\\n            return new double[nums.length];\\n        }\\n        int mincap = k/2, maxcap = k-k/2, n = nums.length;\\n        HashHeap<Integer> maxHeap = new HashHeap<>(Collections.reverseOrder());\\n        HashHeap<Integer> minHeap = new HashHeap<>();\\n        for(int i=0; i<k; i++){\\n            maxHeap.offer(nums[i]);\\n        }\\n        for(int i=0; i<mincap; i++){\\n            minHeap.offer(maxHeap.poll());\\n        }\\n        double[] ans = new double[n-k+1];\\n        ans[0] = getMedian(maxHeap, minHeap, k);\\n        for(int i=k; i<n; i++){\\n            \\n            // remove: maxHeap.size()-minHeap.size() falls in the range [-1, 0];\\n            if(maxHeap.contains(nums[i-k])){\\n                maxHeap.remove(nums[i-k]);\\n            }\\n            else{\\n                minHeap.remove(nums[i-k]);\\n            }\\n            \\n            // always add new element into the maxHeap.\\n            maxHeap.offer(nums[i]);\\n            \\n            // Claim: maxHeap.size()-minHeap.size() falls in the range [0, 3]\\n            // rebalance only if maxHeap.size90 - minHeap.size() = 2 or 3 in order to maintain the property *.\\n            if(maxHeap.size()-minHeap.size()>1){\\n                minHeap.offer(maxHeap.poll());\\n            }\\n            \\n            if(minHeap.size()>0 && maxHeap.peek()>minHeap.peek()){\\n                int tmp1 = maxHeap.poll();\\n                int tmp2 = minHeap.poll();\\n                maxHeap.offer(tmp2);\\n                minHeap.offer(tmp1);\\n            }\\n            \\n            ans[i-k+1] = getMedian(maxHeap, minHeap, k);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private double getMedian(HashHeap<Integer> maxHeap, HashHeap<Integer> minHeap, int k){\\n        double left = maxHeap.peek();\\n        if((k&1)==1){\\n            return left;\\n        }\\n        return (left + minHeap.peek())/2;\\n    }\\n    \\n    private class HashHeap<T>{\\n        \\n        // all method take logarithmic time\\n        TreeMap<T, Integer> mp;\\n        int size;\\n        HashHeap(){\\n            mp = new TreeMap<>();\\n        }\\n        HashHeap(Comparator<T> comparator){\\n            mp = new TreeMap<>(comparator);\\n        }\\n        \\n        int size(){\\n            return size;\\n        }\\n\\n        T peek(){\\n            if(size==0){\\n                return null;\\n            }\\n\\n            return mp.firstEntry().getKey();\\n        }\\n\\n        T poll(){\\n            if(size==0){\\n                return null;\\n            }\\n            size--;\\n            Map.Entry<T, Integer> top= mp.firstEntry();\\n            if(top.getValue()==1){\\n                mp.remove(top.getKey());\\n            }\\n            else{\\n                mp.put(top.getKey(), top.getValue()-1);\\n            }\\n            return top.getKey();\\n        }\\n\\n        void offer(T item){\\n            size++;\\n            mp.put(item, mp.getOrDefault(item, 0)+1);\\n        }\\n\\n        boolean contains(T item){\\n            return mp.containsKey(item);\\n        }\\n\\n        boolean remove(T item){\\n            Integer freq = mp.get(item);\\n            if(freq==null){\\n                return false;\\n            }\\n            size--;\\n            int f = freq;\\n            if(f==1){\\n                mp.remove(item);\\n            }\\n            else{\\n                mp.put(item, f-1);\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        // maxHeap maitians the half small part\\n        // maitain the propetry (*): maxHeap.size() - minHeap.size() = 0 or 1 \\n        if(nums.length==0 || k<=0){\\n            return new double[nums.length];\\n        }\\n        int mincap = k/2, maxcap = k-k/2, n = nums.length;\\n        HashHeap<Integer> maxHeap = new HashHeap<>(Collections.reverseOrder());\\n        HashHeap<Integer> minHeap = new HashHeap<>();\\n        for(int i=0; i<k; i++){\\n            maxHeap.offer(nums[i]);\\n        }\\n        for(int i=0; i<mincap; i++){\\n            minHeap.offer(maxHeap.poll());\\n        }\\n        double[] ans = new double[n-k+1];\\n        ans[0] = getMedian(maxHeap, minHeap, k);\\n        for(int i=k; i<n; i++){\\n            \\n            // remove: maxHeap.size()-minHeap.size() falls in the range [-1, 0];\\n            if(maxHeap.contains(nums[i-k])){\\n                maxHeap.remove(nums[i-k]);\\n            }\\n            else{\\n                minHeap.remove(nums[i-k]);\\n            }\\n            \\n            // always add new element into the maxHeap.\\n            maxHeap.offer(nums[i]);\\n            \\n            // Claim: maxHeap.size()-minHeap.size() falls in the range [0, 3]\\n            // rebalance only if maxHeap.size90 - minHeap.size() = 2 or 3 in order to maintain the property *.\\n            if(maxHeap.size()-minHeap.size()>1){\\n                minHeap.offer(maxHeap.poll());\\n            }\\n            \\n            if(minHeap.size()>0 && maxHeap.peek()>minHeap.peek()){\\n                int tmp1 = maxHeap.poll();\\n                int tmp2 = minHeap.poll();\\n                maxHeap.offer(tmp2);\\n                minHeap.offer(tmp1);\\n            }\\n            \\n            ans[i-k+1] = getMedian(maxHeap, minHeap, k);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private double getMedian(HashHeap<Integer> maxHeap, HashHeap<Integer> minHeap, int k){\\n        double left = maxHeap.peek();\\n        if((k&1)==1){\\n            return left;\\n        }\\n        return (left + minHeap.peek())/2;\\n    }\\n    \\n    private class HashHeap<T>{\\n        \\n        // all method take logarithmic time\\n        TreeMap<T, Integer> mp;\\n        int size;\\n        HashHeap(){\\n            mp = new TreeMap<>();\\n        }\\n        HashHeap(Comparator<T> comparator){\\n            mp = new TreeMap<>(comparator);\\n        }\\n        \\n        int size(){\\n            return size;\\n        }\\n\\n        T peek(){\\n            if(size==0){\\n                return null;\\n            }\\n\\n            return mp.firstEntry().getKey();\\n        }\\n\\n        T poll(){\\n            if(size==0){\\n                return null;\\n            }\\n            size--;\\n            Map.Entry<T, Integer> top= mp.firstEntry();\\n            if(top.getValue()==1){\\n                mp.remove(top.getKey());\\n            }\\n            else{\\n                mp.put(top.getKey(), top.getValue()-1);\\n            }\\n            return top.getKey();\\n        }\\n\\n        void offer(T item){\\n            size++;\\n            mp.put(item, mp.getOrDefault(item, 0)+1);\\n        }\\n\\n        boolean contains(T item){\\n            return mp.containsKey(item);\\n        }\\n\\n        boolean remove(T item){\\n            Integer freq = mp.get(item);\\n            if(freq==null){\\n                return false;\\n            }\\n            size--;\\n            int f = freq;\\n            if(f==1){\\n                mp.remove(item);\\n            }\\n            else{\\n                mp.put(item, f-1);\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96338,
                "title": "python-solution-o-n-log-k-with-only-two-heaps-and-explanation",
                "content": "Coding style might not be good, hope you like it.\\n\\n    class Solution(object):\\n        def medianSlidingWindow(self, nums, k):\\n        \\n        from heapq import heappush, heappop, heapify\\n        \\n        lMaxHeap = []\\n        # for every pair in heap, not only record the key, but also its position in nums\\n        firstList = [(nums[i], i) for i in range(k)]\\n        heapify(firstList)\\n        rMinHeap = firstList\\n        if k == 1:\\n            return [float(i) for i in nums]\\n        # initialize two heap: size of Right min heap  - size of Left max heap >= 1\\n        # in the following, abbreviate right min heap as right; left max heap as left\\n        # when k is odd, left size == right size - 1;\\n        # when k is even, left size == right size\\n        while len(rMinHeap) - len(lMaxHeap) >= 2:\\n            pop = heappop(rMinHeap)\\n            # implement max heap by key * (-1) in min heap\\n            heappush(lMaxHeap, ( -1 * pop[0], pop[1]))\\n        \\n        medianList = [float(rMinHeap[0][0]) if k%2 == 1 else float(rMinHeap[0][0] - lMaxHeap[0][0])/2]\\n        \\n        for i in xrange(k, len(nums)):\\n            # if balance >= 2 -> push(left , pop(right))\\n            # elif balance <= 2 -> push(left, pop(right))\\n            balance = 0\\n            # add cases: when added num greater or equal to right top of min heap, add it to right. \\\\\\n            # Otherwise, add it to left\\n            if nums[i] >= rMinHeap[0][0]:\\n                balance += 1\\n                heappush(rMinHeap, (nums[i], i))\\n            else:\\n                balance -= 1\\n                heappush(lMaxHeap, (-nums[i], i))\\n            # remove case:\\n            # (1) the removing element is in top of either list -> remove until top is in current list\\n            # at the same time, change balance \\n            # (2) the removing element is not in both top of heap -> just change balance\\n                \\n            if lMaxHeap[0][1] == i-k:\\n                heappop(lMaxHeap)\\n                while (lMaxHeap) and (lMaxHeap[0][1] <= i - k):\\n                    heappop(lMaxHeap) \\n                balance += 1\\n            elif rMinHeap[0][1] == i - k:\\n                heappop(rMinHeap)\\n                while (rMinHeap) and (rMinHeap[0][1] <= i - k):\\n                    heappop(rMinHeap)\\n                balance -= 1\\n            elif rMinHeap[0][0] >= nums[i - k]:\\n                balance += 1\\n            else:\\n                balance -= 1\\n            \\n            #balance num in both heap\\n            if balance > 0:\\n                popElement = heappop(rMinHeap)\\n                heappush(lMaxHeap, (-popElement[0], popElement[1]))\\n                while (rMinHeap) and (rMinHeap[0][1] <= i - k):\\n                    heappop(rMinHeap)\\n            elif balance < 0:\\n                popElement = heappop(lMaxHeap)\\n                heappush(rMinHeap,(-popElement[0], popElement[1]))\\n                while (lMaxHeap) and (lMaxHeap[0][1] <= i - k):\\n                    heappop(lMaxHeap)  \\n\\n            medianList.append(float(rMinHeap[0][0]) if k%2 == 1 else float(rMinHeap[0][0] - lMaxHeap[0][0])/2)\\n\\n                    \\n        return medianList",
                "solutionTags": [],
                "code": "Coding style might not be good, hope you like it.\\n\\n    class Solution(object):\\n        def medianSlidingWindow(self, nums, k):\\n        \\n        from heapq import heappush, heappop, heapify\\n        \\n        lMaxHeap = []\\n        # for every pair in heap, not only record the key, but also its position in nums\\n        firstList = [(nums[i], i) for i in range(k)]\\n        heapify(firstList)\\n        rMinHeap = firstList\\n        if k == 1:\\n            return [float(i) for i in nums]\\n        # initialize two heap: size of Right min heap  - size of Left max heap >= 1\\n        # in the following, abbreviate right min heap as right; left max heap as left\\n        # when k is odd, left size == right size - 1;\\n        # when k is even, left size == right size\\n        while len(rMinHeap) - len(lMaxHeap) >= 2:\\n            pop = heappop(rMinHeap)\\n            # implement max heap by key * (-1) in min heap\\n            heappush(lMaxHeap, ( -1 * pop[0], pop[1]))\\n        \\n        medianList = [float(rMinHeap[0][0]) if k%2 == 1 else float(rMinHeap[0][0] - lMaxHeap[0][0])/2]\\n        \\n        for i in xrange(k, len(nums)):\\n            # if balance >= 2 -> push(left , pop(right))\\n            # elif balance <= 2 -> push(left, pop(right))\\n            balance = 0\\n            # add cases: when added num greater or equal to right top of min heap, add it to right. \\\\\\n            # Otherwise, add it to left\\n            if nums[i] >= rMinHeap[0][0]:\\n                balance += 1\\n                heappush(rMinHeap, (nums[i], i))\\n            else:\\n                balance -= 1\\n                heappush(lMaxHeap, (-nums[i], i))\\n            # remove case:\\n            # (1) the removing element is in top of either list -> remove until top is in current list\\n            # at the same time, change balance \\n            # (2) the removing element is not in both top of heap -> just change balance\\n                \\n            if lMaxHeap[0][1] == i-k:\\n                heappop(lMaxHeap)\\n                while (lMaxHeap) and (lMaxHeap[0][1] <= i - k):\\n                    heappop(lMaxHeap) \\n                balance += 1\\n            elif rMinHeap[0][1] == i - k:\\n                heappop(rMinHeap)\\n                while (rMinHeap) and (rMinHeap[0][1] <= i - k):\\n                    heappop(rMinHeap)\\n                balance -= 1\\n            elif rMinHeap[0][0] >= nums[i - k]:\\n                balance += 1\\n            else:\\n                balance -= 1\\n            \\n            #balance num in both heap\\n            if balance > 0:\\n                popElement = heappop(rMinHeap)\\n                heappush(lMaxHeap, (-popElement[0], popElement[1]))\\n                while (rMinHeap) and (rMinHeap[0][1] <= i - k):\\n                    heappop(rMinHeap)\\n            elif balance < 0:\\n                popElement = heappop(lMaxHeap)\\n                heappush(rMinHeap,(-popElement[0], popElement[1]))\\n                while (lMaxHeap) and (lMaxHeap[0][1] <= i - k):\\n                    heappop(lMaxHeap)  \\n\\n            medianList.append(float(rMinHeap[0][0]) if k%2 == 1 else float(rMinHeap[0][0] - lMaxHeap[0][0])/2)\\n\\n                    \\n        return medianList",
                "codeTag": "Java"
            },
            {
                "id": 96359,
                "title": "python-minheap-allow-remove-operation",
                "content": "We can maintain a dict to store valid items and its count, when we pop or peek an item, if that item is invalid(not in the dict), we just discard it till we get a valid one. When remove an item, we decrease its count. If the count reaches zero, remove the item from the dict.\\n\\nWe could use this data struct to solve this problem.\\n```\\nfrom heapq import *\\nfrom collections import defaultdict\\nclass Heap(object):\\n    def __init__(self):\\n        self._counter = defaultdict(int)\\n        self._heap = []\\n        self._size = 0\\n\\n    def push(self, x):\\n        heappush(self._heap, x)\\n        self._counter[x] += 1\\n        self._size += 1\\n\\n    def pop(self):\\n        while self._heap[0] not in self._counter:\\n            heappop(self._heap)\\n        x = heappop(self._heap)\\n        self._counter[x] -= 1\\n        if self._counter[x] <= 0:\\n            del self._counter[x]\\n        self._size -= 1\\n        return x\\n\\n    def peek(self):\\n        while self._heap[0] not in self._counter:\\n            heappop(self._heap)\\n        return self._heap[0]\\n\\n    def remove(self, x):\\n        if x in self._counter:\\n            self._counter[x] -= 1\\n            self._size -= 1\\n            if self._counter[x] == 0:\\n                del self._counter[x]\\n\\n    def contains(self, x):\\n        return x in self._counter\\n\\n    def size(self):\\n        return self._size\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import *\\nfrom collections import defaultdict\\nclass Heap(object):\\n    def __init__(self):\\n        self._counter = defaultdict(int)\\n        self._heap = []\\n        self._size = 0\\n\\n    def push(self, x):\\n        heappush(self._heap, x)\\n        self._counter[x] += 1\\n        self._size += 1\\n\\n    def pop(self):\\n        while self._heap[0] not in self._counter:\\n            heappop(self._heap)\\n        x = heappop(self._heap)\\n        self._counter[x] -= 1\\n        if self._counter[x] <= 0:\\n            del self._counter[x]\\n        self._size -= 1\\n        return x\\n\\n    def peek(self):\\n        while self._heap[0] not in self._counter:\\n            heappop(self._heap)\\n        return self._heap[0]\\n\\n    def remove(self, x):\\n        if x in self._counter:\\n            self._counter[x] -= 1\\n            self._size -= 1\\n            if self._counter[x] == 0:\\n                del self._counter[x]\\n\\n    def contains(self, x):\\n        return x in self._counter\\n\\n    def size(self):\\n        return self._size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043921,
                "title": "c-using-priority-queue-easy-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> ans;\\n    priority_queue<int> mxh;\\n    priority_queue<int,vector<int>,greater<int>> mnh;\\n    void add(int& x){\\n        mxh.push(x);\\n        mnh.push(mxh.top());\\n        mxh.pop();\\n        if(mxh.size()<mnh.size()){\\n            mxh.push(mnh.top());\\n            mnh.pop();\\n        }\\n    }\\n    void erase(int &x){\\n        if(x<=mxh.top()){\\n            vector<int> tmp;\\n            while(x != mxh.top()){\\n                tmp.push_back(mxh.top());\\n                mxh.pop();\\n            }\\n            mxh.pop();\\n            for(auto &i: tmp){\\n                mxh.push(i);\\n            }\\n        }else{\\n            vector<int> tmp;\\n            while(x != mnh.top()){\\n                tmp.push_back(mnh.top());\\n                mnh.pop();\\n            }\\n            mnh.pop();\\n            for(auto &i: tmp){\\n                mnh.push(i);\\n            }\\n        }\\n    }\\n    void push(int &k){\\n        if(k&1){\\n            ans.push_back(mxh.top());\\n        }else{\\n            ans.push_back(((double)mxh.top()+(double)mnh.top())/2.0);\\n        }\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        for(int i = 0; i < nums.size(); i++){\\n            if(mxh.size()+mnh.size()+1<k){\\n                add(nums[i]);\\n            }else{\\n                add(nums[i]);\\n                push(k);\\n                erase(nums[i-k+1]);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> ans;\\n    priority_queue<int> mxh;\\n    priority_queue<int,vector<int>,greater<int>> mnh;\\n    void add(int& x){\\n        mxh.push(x);\\n        mnh.push(mxh.top());\\n        mxh.pop();\\n        if(mxh.size()<mnh.size()){\\n            mxh.push(mnh.top());\\n            mnh.pop();\\n        }\\n    }\\n    void erase(int &x){\\n        if(x<=mxh.top()){\\n            vector<int> tmp;\\n            while(x != mxh.top()){\\n                tmp.push_back(mxh.top());\\n                mxh.pop();\\n            }\\n            mxh.pop();\\n            for(auto &i: tmp){\\n                mxh.push(i);\\n            }\\n        }else{\\n            vector<int> tmp;\\n            while(x != mnh.top()){\\n                tmp.push_back(mnh.top());\\n                mnh.pop();\\n            }\\n            mnh.pop();\\n            for(auto &i: tmp){\\n                mnh.push(i);\\n            }\\n        }\\n    }\\n    void push(int &k){\\n        if(k&1){\\n            ans.push_back(mxh.top());\\n        }else{\\n            ans.push_back(((double)mxh.top()+(double)mnh.top())/2.0);\\n        }\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        for(int i = 0; i < nums.size(); i++){\\n            if(mxh.size()+mnh.size()+1<k){\\n                add(nums[i]);\\n            }else{\\n                add(nums[i]);\\n                push(k);\\n                erase(nums[i-k+1]);\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857128,
                "title": "easy-understandable-implementation-in-c-ordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust think about the advance data structure ordered set .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore each k window elements in ordered set \\nfind the median \\nstore each k window median in an array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<pair<long double,long double>, null_type,less<pair<long double,long double>>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        ordered_set s;\\n        vector<double>ans;\\n       int n=nums.size();\\n       for(int i=0;i<k;i++)\\n       {\\n           s.insert({nums[i],i});\\n       }\\n       long double val=0.0;\\n       if(k%2!=0)\\n       {\\n            val=(s.find_by_order((k-1)/2)->first)/1.0;\\n            ans.push_back(val);\\n       }\\n       if(k%2==0)\\n       {\\n            val=((s.find_by_order((k-1)/2)->first)/1.0 + (s.find_by_order(k/2)->first)/1.0)/2.0;\\n            ans.push_back(val);\\n       }\\n       \\n       int j=0;\\n       for(int i=k;i<n;i++)\\n       {\\n           s.erase({nums[j],j});\\n           s.insert({nums[i],i});\\n           if(k%2==0){\\n           val=double(double(s.find_by_order((k-1)/2)->first) + double(s.find_by_order(k/2)->first))/2.0;\\n       }\\n       else{\\n           val=(s.find_by_order((k-1)/2)->first)/1.0;\\n       }\\n       ans.push_back(val);\\n           j++;\\n       }\\n       return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<pair<long double,long double>, null_type,less<pair<long double,long double>>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        ordered_set s;\\n        vector<double>ans;\\n       int n=nums.size();\\n       for(int i=0;i<k;i++)\\n       {\\n           s.insert({nums[i],i});\\n       }\\n       long double val=0.0;\\n       if(k%2!=0)\\n       {\\n            val=(s.find_by_order((k-1)/2)->first)/1.0;\\n            ans.push_back(val);\\n       }\\n       if(k%2==0)\\n       {\\n            val=((s.find_by_order((k-1)/2)->first)/1.0 + (s.find_by_order(k/2)->first)/1.0)/2.0;\\n            ans.push_back(val);\\n       }\\n       \\n       int j=0;\\n       for(int i=k;i<n;i++)\\n       {\\n           s.erase({nums[j],j});\\n           s.insert({nums[i],i});\\n           if(k%2==0){\\n           val=double(double(s.find_by_order((k-1)/2)->first) + double(s.find_by_order(k/2)->first))/2.0;\\n       }\\n       else{\\n           val=(s.find_by_order((k-1)/2)->first)/1.0;\\n       }\\n       ans.push_back(val);\\n           j++;\\n       }\\n       return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2805374,
                "title": "c-fixed-size-sliding-window-ordred-set",
                "content": "# Please upvote if Usefull, measn a lot.\\n**Intution**\\nJust Simple  fixed size sliding window and after that finding median of k size Window.\\n\\nmedian can be found using ordere set.\\n\\n* **I Have Already Discussed Ordered Set, here :-** https://leetcode.com/problems/find-median-from-data-stream/discuss/2805245/C%2B%2B-Solution-Using-PBDS-(-Ordered-Set).\\n\\n**Please Upvote if Usefull, and Feel free to ask any Doubt.**\\n```\\n#include <bits/stdc++.h>\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\nusing namespace std;\\nusing ll = long long;\\n#define ordered_set  tree< int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> // for tree implementation with less value.\\n#define ordered_multisetset  tree< ll ,null_type,less_equal<ll>,rb_tree_tag,tree_order_statistics_node_update> // for tree implementation with less or equal to value.#includ<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    ordered_multisetset s;\\n    vector<double> ans;\\n    \\n    void add(){\\n        int n=s.size();\\n        if(n%2!=0){\\n            ans.push_back(*s.find_by_order(n/2));\\n        }\\n        else{\\n            ans.push_back((*s.find_by_order(n/2) + *s.find_by_order(n/2-1))/2.0);\\n        }\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& a, int k) {\\n        \\n        for( int i=0;i<k;i++) s.insert(a[i]);\\n        add();\\n        int i=0,j=k;\\n        \\n        for( ;j<a.size();j++,i++){\\n        \\n            ll in=s.order_of_key(a[i]);\\n            s.erase(s.find_by_order(in));\\n            \\n            s.insert(a[j]);\\n            add();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\nusing namespace std;\\nusing ll = long long;\\n#define ordered_set  tree< int ,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> // for tree implementation with less value.\\n#define ordered_multisetset  tree< ll ,null_type,less_equal<ll>,rb_tree_tag,tree_order_statistics_node_update> // for tree implementation with less or equal to value.#includ<bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    ordered_multisetset s;\\n    vector<double> ans;\\n    \\n    void add(){\\n        int n=s.size();\\n        if(n%2!=0){\\n            ans.push_back(*s.find_by_order(n/2));\\n        }\\n        else{\\n            ans.push_back((*s.find_by_order(n/2) + *s.find_by_order(n/2-1))/2.0);\\n        }\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& a, int k) {\\n        \\n        for( int i=0;i<k;i++) s.insert(a[i]);\\n        add();\\n        int i=0,j=k;\\n        \\n        for( ;j<a.size();j++,i++){\\n        \\n            ll in=s.order_of_key(a[i]);\\n            s.erase(s.find_by_order(in));\\n            \\n            s.insert(a[j]);\\n            add();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2535822,
                "title": "c-solution-o-nlogn-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    double median(vector<double>&q, int k)\\n    {\\n        double x;\\n        if(k%2 == 0)\\n             x=(double)(q[k/2]+q[k/2-1])/2;\\n        else\\n             x=(double)q[k/2];\\n        return x;\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double>v;\\n        vector<double>q;\\n        double d;\\n        int n=nums.size();\\n        int i=0, j=0;\\n        while(j < k)\\n        {\\n            q.push_back(nums[j]);\\n            j++;\\n        }\\n        sort(q.begin(), q.end());\\n        d = median(q, k);\\n        v.push_back(d);\\n        for(int k1=j; k1<nums.size(); k1++)\\n        {\\n            int init_pos = lower_bound(q.begin(), q.end(), nums[i])-q.begin();\\n            q.erase(q.begin()+init_pos);\\n            int last_pos = upper_bound(q.begin(), q.end(), nums[k1])-q.begin();\\n            q.insert(q.begin()+last_pos, nums[k1]);\\n            d = median(q, k);\\n            v.push_back(d);\\n            i++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double median(vector<double>&q, int k)\\n    {\\n        double x;\\n        if(k%2 == 0)\\n             x=(double)(q[k/2]+q[k/2-1])/2;\\n        else\\n             x=(double)q[k/2];\\n        return x;\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double>v;\\n        vector<double>q;\\n        double d;\\n        int n=nums.size();\\n        int i=0, j=0;\\n        while(j < k)\\n        {\\n            q.push_back(nums[j]);\\n            j++;\\n        }\\n        sort(q.begin(), q.end());\\n        d = median(q, k);\\n        v.push_back(d);\\n        for(int k1=j; k1<nums.size(); k1++)\\n        {\\n            int init_pos = lower_bound(q.begin(), q.end(), nums[i])-q.begin();\\n            q.erase(q.begin()+init_pos);\\n            int last_pos = upper_bound(q.begin(), q.end(), nums[k1])-q.begin();\\n            q.insert(q.begin()+last_pos, nums[k1]);\\n            d = median(q, k);\\n            v.push_back(d);\\n            i++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443030,
                "title": "cpp-2-priority-queue-approach-easy-and-organised-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    #define pb push_back\\n    #define ff first\\n    #define ss second\\n    \\n    \\n    //initialising...\\n    priority_queue<int>pq;//max_heap\\n    priority_queue<int,vector<int>,greater<int>>pq2;//min heap\\n    vector<double>ans;\\n    \\n    //balancing\\n    void balance(){\\n        if(pq.size()>(pq2.size()+1)){\\n            pq2.push(pq.top());\\n            pq.pop();\\n        }\\n        if(pq2.size()>(pq.size()+1)){\\n            pq.push(pq2.top());\\n            pq2.pop();\\n        }\\n    }\\n    \\n    //adding new val\\n    void add(int val){\\n        if((pq.empty()&&pq2.empty())||val<pq.top()){\\n            pq.push(val);\\n        }else pq2.push(val);\\n    }\\n    \\n    //adding median to our answer!\\n    void updateAns(){\\n        if(pq.size()==pq2.size()){\\n            double one=pq.top();\\n            one+=pq2.top();\\n            ans.pb(one/2);\\n        }\\n        else ans.pb((pq.size()>pq2.size())?pq.top():pq2.top());\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& a, int k) {\\n        int n=a.size();\\n        for(int i=0;i<k;i++){\\n            add(a[i]);\\n            balance();\\n        }\\n        updateAns();\\n        for(int i=k;i<n;i++){\\n            //removing prev val\\n            int prev=a[i-k],indx=0;\\n            vector<int>temp;\\n            if(!pq.empty()&&prev<=pq.top()){\\n                while(prev!=pq.top()){\\n                    temp.pb(pq.top());\\n                    pq.pop();\\n                }\\n                pq.pop();\\n                int l=temp.size();\\n                while(indx<l){pq.push(temp[indx++]);}\\n            }else if(!pq2.empty()){\\n                while(prev!=(pq2.top())){\\n                    temp.pb(pq2.top());\\n                    pq2.pop();\\n                }\\n                pq2.pop();\\n                int l=temp.size();\\n                while(indx<l){pq2.push(temp[indx++]);}\\n            }\\n            add(a[i]);\\n            balance();\\n            updateAns();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define pb push_back\\n    #define ff first\\n    #define ss second\\n    \\n    \\n    //initialising...\\n    priority_queue<int>pq;//max_heap\\n    priority_queue<int,vector<int>,greater<int>>pq2;//min heap\\n    vector<double>ans;\\n    \\n    //balancing\\n    void balance(){\\n        if(pq.size()>(pq2.size()+1)){\\n            pq2.push(pq.top());\\n            pq.pop();\\n        }\\n        if(pq2.size()>(pq.size()+1)){\\n            pq.push(pq2.top());\\n            pq2.pop();\\n        }\\n    }\\n    \\n    //adding new val\\n    void add(int val){\\n        if((pq.empty()&&pq2.empty())||val<pq.top()){\\n            pq.push(val);\\n        }else pq2.push(val);\\n    }\\n    \\n    //adding median to our answer!\\n    void updateAns(){\\n        if(pq.size()==pq2.size()){\\n            double one=pq.top();\\n            one+=pq2.top();\\n            ans.pb(one/2);\\n        }\\n        else ans.pb((pq.size()>pq2.size())?pq.top():pq2.top());\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& a, int k) {\\n        int n=a.size();\\n        for(int i=0;i<k;i++){\\n            add(a[i]);\\n            balance();\\n        }\\n        updateAns();\\n        for(int i=k;i<n;i++){\\n            //removing prev val\\n            int prev=a[i-k],indx=0;\\n            vector<int>temp;\\n            if(!pq.empty()&&prev<=pq.top()){\\n                while(prev!=pq.top()){\\n                    temp.pb(pq.top());\\n                    pq.pop();\\n                }\\n                pq.pop();\\n                int l=temp.size();\\n                while(indx<l){pq.push(temp[indx++]);}\\n            }else if(!pq2.empty()){\\n                while(prev!=(pq2.top())){\\n                    temp.pb(pq2.top());\\n                    pq2.pop();\\n                }\\n                pq2.pop();\\n                int l=temp.size();\\n                while(indx<l){pq2.push(temp[indx++]);}\\n            }\\n            add(a[i]);\\n            balance();\\n            updateAns();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429555,
                "title": "c-using-multiset-very-simple-and-easy-to-understand-c-solution",
                "content": "<b>Up Vote if you like the solution\\n```\\n//function next() and prev() is used to get the solution\\n\\n//multiset is used to store elements of window size k\\n//pointer mid is always pointing to mid, \\n//when adding a new element, check if its smaller than mid or not, if yes then decreament mid\\n//when removing an element, check if its smaller than mid, then increament pointer\\n\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> ans;\\n        multiset<int> s;\\n        for(int i = 0; i< k; ++i){ s.insert(nums[i]); }\\n        auto mid = next(s.begin(), k/2);\\n        ans.push_back((double(*mid) + double(*(prev(mid, 1-k%2))))/2);\\n        int i = k; \\n        while(i < nums.size()){ \\n            s.insert(nums[i]);\\n            if(nums[i] < *mid) mid--;\\n            if(nums[i-k]<= *mid) mid++;\\n            s.erase(s.lower_bound(nums[i-k]));\\n            ans.push_back((double(*mid) + double(*(prev(mid, 1-k%2))))/2);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//function next() and prev() is used to get the solution\\n\\n//multiset is used to store elements of window size k\\n//pointer mid is always pointing to mid, \\n//when adding a new element, check if its smaller than mid or not, if yes then decreament mid\\n//when removing an element, check if its smaller than mid, then increament pointer\\n\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> ans;\\n        multiset<int> s;\\n        for(int i = 0; i< k; ++i){ s.insert(nums[i]); }\\n        auto mid = next(s.begin(), k/2);\\n        ans.push_back((double(*mid) + double(*(prev(mid, 1-k%2))))/2);\\n        int i = k; \\n        while(i < nums.size()){ \\n            s.insert(nums[i]);\\n            if(nums[i] < *mid) mid--;\\n            if(nums[i-k]<= *mid) mid++;\\n            s.erase(s.lower_bound(nums[i-k]));\\n            ans.push_back((double(*mid) + double(*(prev(mid, 1-k%2))))/2);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376109,
                "title": "python-short-and-very-easy-to-understand",
                "content": "```\\ndef medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        res = []\\n        for i in range(len(nums)-k+1):\\n            temp = sorted(nums[i:i+k])\\n         \\n            if k % 2 != 0:\\n                res.append(temp[k//2])\\n            else:\\n                avg = (temp[k//2] + temp[k//2-1])/2\\n                res.append(avg)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        res = []\\n        for i in range(len(nums)-k+1):\\n            temp = sorted(nums[i:i+k])\\n         \\n            if k % 2 != 0:\\n                res.append(temp[k//2])\\n            else:\\n                avg = (temp[k//2] + temp[k//2-1])/2\\n                res.append(avg)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2302158,
                "title": "multiset-solution-c-beats-83",
                "content": "```\\nclass Solution {\\npublic:\\n// calculates the median for given left and right\\n    double calc(multiset<int> &left,multiset<int> &right,int k){\\n        \\n        if(k%2){\\n            return *right.begin();\\n        }else{\\n            return ((double)((*left.rbegin())*1LL + (*right.begin())))/2;\\n        }\\n    }\\n\\t// balance function balances the multiset such that it first floor(k/2) elements are in left multiset and last ceil(k/2) elements are in right multiset\\n    void balance(multiset<int> &left,multiset<int> &right,int k){\\n        if(k<=2)return ;\\n         while(left.size() < k/2){\\n            int curr = *right.begin();\\n            right.erase(right.begin());\\n            left.insert(curr);\\n        }\\n        while(*left.rbegin() > *right.begin()){\\n            int a = *left.rbegin();\\n            int b = *right.begin();\\n            auto aErase = left.find(a);\\n            left.erase(aErase);\\n            right.erase(right.begin());\\n            right.insert(a);\\n            left.insert(b);\\n        }\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<double> ans;\\n        multiset<int> left;\\n        multiset<int> right;\\n        for(int i = 0;i<k;i++){\\n            right.insert(nums[i]);\\n        }\\n       if(k<=2){\\n           for(int i = 0;i<=n-k;i++){\\n                int end = i + k - 1;\\n                double temp = ((double)(nums[i]*1LL + nums[end]))/2;\\n                ans.push_back(temp);\\n            \\n            }\\n           return ans;\\n       }\\n        \\n        balance(left,right,k);\\n        ans.push_back(calc(left,right,k));\\n        for(int i = 1;i<=n-k;i++){\\n            // sliding the window erasing the element that went out of the window and inserting the element that came in the window \\n            int end = i + k - 1;\\n            if(k <= 2){\\n                double temp = (nums[i] + nums[end])/2;\\n                ans.push_back(temp);\\n                continue;\\n            }\\n            int toDelete = nums[i-1];\\n            //cout<<\"toDelete \"<<toDelete<<endl;\\n            auto findInLeft = left.find(toDelete);\\n            if(findInLeft != left.end()){\\n                left.erase(findInLeft);\\n            }else{\\n                auto findInRight = right.find(toDelete);\\n                right.erase(findInRight);\\n            }\\n            int toInsert = nums[end];\\n            right.insert(toInsert);\\n            balance(left,right,k);\\n            ans.push_back(calc(left,right,k));   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n// calculates the median for given left and right\\n    double calc(multiset<int> &left,multiset<int> &right,int k){\\n        \\n        if(k%2){\\n            return *right.begin();\\n        }else{\\n            return ((double)((*left.rbegin())*1LL + (*right.begin())))/2;\\n        }\\n    }\\n\\t// balance function balances the multiset such that it first floor(k/2) elements are in left multiset and last ceil(k/2) elements are in right multiset\\n    void balance(multiset<int> &left,multiset<int> &right,int k){\\n        if(k<=2)return ;\\n         while(left.size() < k/2){\\n            int curr = *right.begin();\\n            right.erase(right.begin());\\n            left.insert(curr);\\n        }\\n        while(*left.rbegin() > *right.begin()){\\n            int a = *left.rbegin();\\n            int b = *right.begin();\\n            auto aErase = left.find(a);\\n            left.erase(aErase);\\n            right.erase(right.begin());\\n            right.insert(a);\\n            left.insert(b);\\n        }\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<double> ans;\\n        multiset<int> left;\\n        multiset<int> right;\\n        for(int i = 0;i<k;i++){\\n            right.insert(nums[i]);\\n        }\\n       if(k<=2){\\n           for(int i = 0;i<=n-k;i++){\\n                int end = i + k - 1;\\n                double temp = ((double)(nums[i]*1LL + nums[end]))/2;\\n                ans.push_back(temp);\\n            \\n            }\\n           return ans;\\n       }\\n        \\n        balance(left,right,k);\\n        ans.push_back(calc(left,right,k));\\n        for(int i = 1;i<=n-k;i++){\\n            // sliding the window erasing the element that went out of the window and inserting the element that came in the window \\n            int end = i + k - 1;\\n            if(k <= 2){\\n                double temp = (nums[i] + nums[end])/2;\\n                ans.push_back(temp);\\n                continue;\\n            }\\n            int toDelete = nums[i-1];\\n            //cout<<\"toDelete \"<<toDelete<<endl;\\n            auto findInLeft = left.find(toDelete);\\n            if(findInLeft != left.end()){\\n                left.erase(findInLeft);\\n            }else{\\n                auto findInRight = right.find(toDelete);\\n                right.erase(findInRight);\\n            }\\n            int toInsert = nums[end];\\n            right.insert(toInsert);\\n            balance(left,right,k);\\n            ans.push_back(calc(left,right,k));   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2298736,
                "title": "two-heap",
                "content": "```\\n\\nfunc medianSlidingWindow(nums []int, k int) []float64 {\\n\\tvar res []float64\\n\\n\\tvar minHeap minH\\n\\tvar maxHeap maxH\\n\\n\\tfor i, num := range nums {\\n\\t\\tif len(maxHeap) == 0 || num <= maxHeap[0] {\\n\\t\\t\\tmaxHeap.add(num)\\n\\t\\t} else {\\n\\t\\t\\tminHeap.add(num)\\n\\t\\t}\\n\\n\\t\\tif len(maxHeap) > len(minHeap)+1 {\\n\\t\\t\\tminHeap.add(maxHeap.pop())\\n\\t\\t} else if len(minHeap) > len(maxHeap) {\\n\\t\\t\\tmaxHeap.add(minHeap.pop())\\n\\t\\t}\\n\\n\\t\\tif i-k+1 >= 0 {\\n\\t\\t\\tremovedIndex := i - k\\n\\n\\t\\t\\tif removedIndex >= 0 {\\n\\t\\t\\t\\tif nums[removedIndex] <= maxHeap[0] {\\n\\t\\t\\t\\t\\tmaxHeap.remove(nums[removedIndex])\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tminHeap.remove(nums[removedIndex])\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif len(maxHeap) > len(minHeap)+1 {\\n\\t\\t\\t\\t\\tminHeap.add(maxHeap.pop())\\n\\t\\t\\t\\t} else if len(minHeap) > len(maxHeap) {\\n\\t\\t\\t\\t\\tmaxHeap.add(minHeap.pop())\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar median float64\\n\\n\\t\\t\\tif len(minHeap) == len(maxHeap) {\\n\\t\\t\\t\\tmedian = float64(minHeap[0]+maxHeap[0]) / float64(2)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmedian = float64(maxHeap[0])\\n\\t\\t\\t}\\n\\n\\t\\t\\tres = append(res, median)\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\ntype minH []int\\n\\ntype maxH []int\\n\\nfunc (h *maxH) remove(item int) {\\n\\tfor i := 0; i < len(*h); i++ {\\n\\t\\tif item == (*h)[i] {\\n\\t\\t\\t(*h)[i] = (*h)[len(*h)-1]\\n\\t\\t\\t*h = (*h)[:len(*h)-1]\\n\\n\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\th.heapDown(0)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\n\\t\\t\\tparent := (i - 1) / 2\\n\\n\\t\\t\\tif parent >= 0 && i < len(*h) {\\n\\t\\t\\t\\th.heapDown(i)\\n\\t\\t\\t\\th.heapUp(i)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (h *minH) remove(item int) {\\n\\tfor i := 0; i < len(*h); i++ {\\n\\t\\tif item == (*h)[i] {\\n\\t\\t\\t(*h)[i] = (*h)[len(*h)-1]\\n\\t\\t\\t*h = (*h)[:len(*h)-1]\\n\\n\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\th.heapDown(0)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\n\\t\\t\\tparent := (i - 1) / 2\\n\\n\\t\\t\\tif parent >= 0 && i < len(*h) {\\n\\t\\t\\t\\th.heapDown(i)\\n\\t\\t\\t\\th.heapUp(i)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (h *maxH) pop() int {\\n\\tpoppedItem := (*h)[0]\\n\\n\\t(*h)[0] = (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\th.heapDown(0)\\n\\n\\treturn poppedItem\\n}\\n\\nfunc (h *minH) pop() int {\\n\\tpoppedItem := (*h)[0]\\n\\n\\t(*h)[0] = (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\th.heapDown(0)\\n\\n\\treturn poppedItem\\n}\\n\\nfunc (h *minH) add(num int) {\\n\\t*h = append(*h, num)\\n\\th.heapUp(len(*h) - 1)\\n}\\n\\nfunc (h *maxH) add(num int) {\\n\\t*h = append(*h, num)\\n\\th.heapUp(len(*h) - 1)\\n}\\n\\nfunc (h *minH) heapDown(p int) {\\n\\tl, r := 2*p+1, 2*p+2\\n\\tsmaller := p\\n\\n\\tif l < len(*h) && (*h)[l] < (*h)[smaller] {\\n\\t\\tsmaller = l\\n\\t}\\n\\n\\tif r < len(*h) && (*h)[r] < (*h)[smaller] {\\n\\t\\tsmaller = r\\n\\t}\\n\\n\\tif smaller != p {\\n\\t\\t(*h)[smaller], (*h)[p] = (*h)[p], (*h)[smaller]\\n\\t\\th.heapDown(smaller)\\n\\t}\\n}\\n\\nfunc (h *minH) heapUp(p int) {\\n\\tparent := (p - 1) / 2\\n\\n\\tif parent >= 0 && (*h)[p] < (*h)[parent] {\\n\\t\\t(*h)[p], (*h)[parent] = (*h)[parent], (*h)[p]\\n\\t\\th.heapUp(parent)\\n\\t}\\n}\\n\\nfunc (h *maxH) heapDown(p int) {\\n\\tl, r := 2*p+1, 2*p+2\\n\\tbigger := p\\n\\n\\tif l < len(*h) && (*h)[l] > (*h)[bigger] {\\n\\t\\tbigger = l\\n\\t}\\n\\n\\tif r < len(*h) && (*h)[r] > (*h)[bigger] {\\n\\t\\tbigger = r\\n\\t}\\n\\n\\tif bigger != p {\\n\\t\\t(*h)[bigger], (*h)[p] = (*h)[p], (*h)[bigger]\\n\\t\\th.heapDown(bigger)\\n\\t}\\n}\\n\\nfunc (h *maxH) heapUp(p int) {\\n\\tparent := (p - 1) / 2\\n\\n\\tif parent >= 0 && (*h)[p] > (*h)[parent] {\\n\\t\\t(*h)[p], (*h)[parent] = (*h)[parent], (*h)[p]\\n\\t\\th.heapUp(parent)\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nfunc medianSlidingWindow(nums []int, k int) []float64 {\\n\\tvar res []float64\\n\\n\\tvar minHeap minH\\n\\tvar maxHeap maxH\\n\\n\\tfor i, num := range nums {\\n\\t\\tif len(maxHeap) == 0 || num <= maxHeap[0] {\\n\\t\\t\\tmaxHeap.add(num)\\n\\t\\t} else {\\n\\t\\t\\tminHeap.add(num)\\n\\t\\t}\\n\\n\\t\\tif len(maxHeap) > len(minHeap)+1 {\\n\\t\\t\\tminHeap.add(maxHeap.pop())\\n\\t\\t} else if len(minHeap) > len(maxHeap) {\\n\\t\\t\\tmaxHeap.add(minHeap.pop())\\n\\t\\t}\\n\\n\\t\\tif i-k+1 >= 0 {\\n\\t\\t\\tremovedIndex := i - k\\n\\n\\t\\t\\tif removedIndex >= 0 {\\n\\t\\t\\t\\tif nums[removedIndex] <= maxHeap[0] {\\n\\t\\t\\t\\t\\tmaxHeap.remove(nums[removedIndex])\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tminHeap.remove(nums[removedIndex])\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif len(maxHeap) > len(minHeap)+1 {\\n\\t\\t\\t\\t\\tminHeap.add(maxHeap.pop())\\n\\t\\t\\t\\t} else if len(minHeap) > len(maxHeap) {\\n\\t\\t\\t\\t\\tmaxHeap.add(minHeap.pop())\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar median float64\\n\\n\\t\\t\\tif len(minHeap) == len(maxHeap) {\\n\\t\\t\\t\\tmedian = float64(minHeap[0]+maxHeap[0]) / float64(2)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmedian = float64(maxHeap[0])\\n\\t\\t\\t}\\n\\n\\t\\t\\tres = append(res, median)\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\ntype minH []int\\n\\ntype maxH []int\\n\\nfunc (h *maxH) remove(item int) {\\n\\tfor i := 0; i < len(*h); i++ {\\n\\t\\tif item == (*h)[i] {\\n\\t\\t\\t(*h)[i] = (*h)[len(*h)-1]\\n\\t\\t\\t*h = (*h)[:len(*h)-1]\\n\\n\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\th.heapDown(0)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\n\\t\\t\\tparent := (i - 1) / 2\\n\\n\\t\\t\\tif parent >= 0 && i < len(*h) {\\n\\t\\t\\t\\th.heapDown(i)\\n\\t\\t\\t\\th.heapUp(i)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (h *minH) remove(item int) {\\n\\tfor i := 0; i < len(*h); i++ {\\n\\t\\tif item == (*h)[i] {\\n\\t\\t\\t(*h)[i] = (*h)[len(*h)-1]\\n\\t\\t\\t*h = (*h)[:len(*h)-1]\\n\\n\\t\\t\\tif i == 0 {\\n\\t\\t\\t\\th.heapDown(0)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\n\\t\\t\\tparent := (i - 1) / 2\\n\\n\\t\\t\\tif parent >= 0 && i < len(*h) {\\n\\t\\t\\t\\th.heapDown(i)\\n\\t\\t\\t\\th.heapUp(i)\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (h *maxH) pop() int {\\n\\tpoppedItem := (*h)[0]\\n\\n\\t(*h)[0] = (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\th.heapDown(0)\\n\\n\\treturn poppedItem\\n}\\n\\nfunc (h *minH) pop() int {\\n\\tpoppedItem := (*h)[0]\\n\\n\\t(*h)[0] = (*h)[len(*h)-1]\\n\\t*h = (*h)[:len(*h)-1]\\n\\th.heapDown(0)\\n\\n\\treturn poppedItem\\n}\\n\\nfunc (h *minH) add(num int) {\\n\\t*h = append(*h, num)\\n\\th.heapUp(len(*h) - 1)\\n}\\n\\nfunc (h *maxH) add(num int) {\\n\\t*h = append(*h, num)\\n\\th.heapUp(len(*h) - 1)\\n}\\n\\nfunc (h *minH) heapDown(p int) {\\n\\tl, r := 2*p+1, 2*p+2\\n\\tsmaller := p\\n\\n\\tif l < len(*h) && (*h)[l] < (*h)[smaller] {\\n\\t\\tsmaller = l\\n\\t}\\n\\n\\tif r < len(*h) && (*h)[r] < (*h)[smaller] {\\n\\t\\tsmaller = r\\n\\t}\\n\\n\\tif smaller != p {\\n\\t\\t(*h)[smaller], (*h)[p] = (*h)[p], (*h)[smaller]\\n\\t\\th.heapDown(smaller)\\n\\t}\\n}\\n\\nfunc (h *minH) heapUp(p int) {\\n\\tparent := (p - 1) / 2\\n\\n\\tif parent >= 0 && (*h)[p] < (*h)[parent] {\\n\\t\\t(*h)[p], (*h)[parent] = (*h)[parent], (*h)[p]\\n\\t\\th.heapUp(parent)\\n\\t}\\n}\\n\\nfunc (h *maxH) heapDown(p int) {\\n\\tl, r := 2*p+1, 2*p+2\\n\\tbigger := p\\n\\n\\tif l < len(*h) && (*h)[l] > (*h)[bigger] {\\n\\t\\tbigger = l\\n\\t}\\n\\n\\tif r < len(*h) && (*h)[r] > (*h)[bigger] {\\n\\t\\tbigger = r\\n\\t}\\n\\n\\tif bigger != p {\\n\\t\\t(*h)[bigger], (*h)[p] = (*h)[p], (*h)[bigger]\\n\\t\\th.heapDown(bigger)\\n\\t}\\n}\\n\\nfunc (h *maxH) heapUp(p int) {\\n\\tparent := (p - 1) / 2\\n\\n\\tif parent >= 0 && (*h)[p] > (*h)[parent] {\\n\\t\\t(*h)[p], (*h)[parent] = (*h)[parent], (*h)[p]\\n\\t\\th.heapUp(parent)\\n\\t}\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282053,
                "title": "480-sliding-window-median-python-solution-o-nlogk",
                "content": "**Approach :** Binary Search + Sliding Window\\n\\n* [ Optional ] Consider the following two conditions to optimize the runtime.\\n\\t* When `k = 1`.\\n\\t\\t* For window size `1` median array will be the `nums` array itself. So, return the `nums` array.\\n\\t* When `k = 2`.\\n\\t\\t* For window size `2` median array will be the average of the current & the next number for each number in the `nums` array.\\n* Now, every other value of `k` indicates window size greater than `2`.\\n\\t* Calculate the median index for the window.\\n\\t* To handle both conditions for even as well as odd-sized windows take two index `m1` & `m2`.\\n\\t\\t* For an even-sized window, the values of `m1` & `m2` will be different.\\n\\t\\t* For odd-sized windows, the values of `m1` & `m2` will be the same.\\n\\t* Take the first window of size `k` and sort it.\\n\\t* Also, take the `median` array to store the median for each window.\\n\\t* Now, slide the window will the end\\n\\t\\t* While sliding the window, pop the first number & insert the new number by using the binary search.\\n\\t\\t* Now, get the median by using two indices `m1` & `m2` and append it to the `median` array.\\n\\t\\t* Repeat this process till the end.\\n\\t* Finally, return the `median` array.\\n\\n<br>\\n\\n**Visualization :**\\n\\nFor Example. \\n\\n```\\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\\n```\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/3dc20cc7-4c24-444f-822a-500a7778a07a_1657811884.5208313.png)\\n\\n\\n**Complexity :**\\n* Time Complexity : **O(nlogk)**\\n* Space Complexity : **O(k)**\\n\\n<br>\\n\\n```\\nimport bisect\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if k == 1:\\n            return nums\\n        elif k == 2:\\n            return [(nums[i] + nums[i + 1]) / 2 for i in range(len(nums) - 1)]\\n        \\n        m1, m2 = math.ceil(k / 2) - 1, math.floor(k / 2)\\n        window = sorted(nums[:k])\\n        median = [(window[m1] + window[m2]) / 2]\\n        \\n        for i in range(k, len(nums)):\\n            window.pop(bisect.bisect_left(window, nums[i - k]))\\n            window.insert(bisect.bisect(window, nums[i]), nums[i])\\n            median.append((window[m1] + window[m2]) / 2)\\n\\n        return median\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\\n```\n```\\nimport bisect\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if k == 1:\\n            return nums\\n        elif k == 2:\\n            return [(nums[i] + nums[i + 1]) / 2 for i in range(len(nums) - 1)]\\n        \\n        m1, m2 = math.ceil(k / 2) - 1, math.floor(k / 2)\\n        window = sorted(nums[:k])\\n        median = [(window[m1] + window[m2]) / 2]\\n        \\n        for i in range(k, len(nums)):\\n            window.pop(bisect.bisect_left(window, nums[i - k]))\\n            window.insert(bisect.bisect(window, nums[i]), nums[i])\\n            median.append((window[m1] + window[m2]) / 2)\\n\\n        return median\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205863,
                "title": "easy-to-understand-c-solution-faster-than-90-similar-to-finding-median-in-data-stream",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    multiset<long long, greater<long long>> max_heap;\\n    multiset<long long> min_heap;\\n    vector<double> medianSlidingWindow(vector<int> &nums, int k)\\n    {\\n        vector<double> res;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (i >= k)\\n            {\\n                if (max_heap.find(nums[i - k]) != max_heap.end())\\n                    max_heap.erase(max_heap.find(nums[i - k]));\\n                else\\n                    min_heap.erase(min_heap.find(nums[i - k]));\\n            }\\n\\n            max_heap.insert(nums[i]);\\n\\n            if (max_heap.size() > min_heap.size() + 1)\\n            {\\n                min_heap.insert(*max_heap.begin());\\n                max_heap.erase(max_heap.begin());\\n            }\\n            if (min_heap.size() > 0 && *max_heap.begin() > *min_heap.begin())\\n            {\\n                min_heap.insert(*max_heap.begin());\\n                max_heap.erase(max_heap.begin());\\n                max_heap.insert(*min_heap.begin());\\n                min_heap.erase(min_heap.begin());\\n            }\\n\\n            \\n            if (i >= k - 1)\\n            {\\n                if (k % 2 == 0)\\n                    res.push_back((*min_heap.begin() + *max_heap.begin()) * 0.5);\\n                else\\n                    res.push_back(*max_heap.begin());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    multiset<long long, greater<long long>> max_heap;\\n    multiset<long long> min_heap;\\n    vector<double> medianSlidingWindow(vector<int> &nums, int k)\\n    {\\n        vector<double> res;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (i >= k)\\n            {\\n                if (max_heap.find(nums[i - k]) != max_heap.end())\\n                    max_heap.erase(max_heap.find(nums[i - k]));\\n                else\\n                    min_heap.erase(min_heap.find(nums[i - k]));\\n            }\\n\\n            max_heap.insert(nums[i]);\\n\\n            if (max_heap.size() > min_heap.size() + 1)\\n            {\\n                min_heap.insert(*max_heap.begin());\\n                max_heap.erase(max_heap.begin());\\n            }\\n            if (min_heap.size() > 0 && *max_heap.begin() > *min_heap.begin())\\n            {\\n                min_heap.insert(*max_heap.begin());\\n                max_heap.erase(max_heap.begin());\\n                max_heap.insert(*min_heap.begin());\\n                min_heap.erase(min_heap.begin());\\n            }\\n\\n            \\n            if (i >= k - 1)\\n            {\\n                if (k % 2 == 0)\\n                    res.push_back((*min_heap.begin() + *max_heap.begin()) * 0.5);\\n                else\\n                    res.push_back(*max_heap.begin());\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109895,
                "title": "fully-explained-multiset-heap-priority-queue-cpp",
                "content": "For finding median, we need to first arrange nums in non-decreasing/increasing order and find the middle element.\\n\\nSo we will simply store the all \\'k\\' number in an array and to find median, we will sort the nums array and return middle element in case of odd size nums array and avg of middle elements in case of even size nums array.\\n\\nTC- O(N^2logN), SC- O(N), where N is count of numbers we have.\\n\\nPFB the code for your refernce:\\n```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> temp;\\n        double med;\\n        vector<double> ans;\\n        for(int i=k-1;i<nums.size();i++){\\n            temp.clear();\\n            for(int j=0;j<k;j++) //finding k element for curr window\\n                temp.push_back(nums[i-j]);\\n            sort(temp.begin(),temp.end());\\n            med= k&1 ? temp[k/2]: 1.0*(1LL*temp[k/2]+1LL*temp[(k-1)/2])/2;\\n            ans.push_back(med);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nCan we do better? can we somehow tweak the storing part to access middle elements in constant time?\\nIntuition here is create two heap, one min_half which stores min of largest k/2 element and other max_half which stores max of smallest k/2 element.\\nonce we are done with first k element we need to slide the window one by one.i.e. remove (i-k)th element and add ith element and then evaluate the median as per value of k.\\nMaintain two multiset to keep track of elements which needs to be deleted\\n\\nAlgorithm for sliding window:\\n1. check in which heap (i-k)th element is present and put it in del multiset accordingly\\n2. insert a element in the heap from where (i-k)th element was removed.\\n3. keep checking top of min_half/max_half heap and if those are present in del_min/del_max remove those\\n\\nAlgorithm for inserting element in a max_half heap:\\n1. insert ith element in min_half heap\\n2. insert top of min_half to max_half heap\\n3. remove top of min_half\\n\\nAlgorithm for inserting element in a min_half heap:\\n1. insert ith element in max_half heap\\n2. insert top of max_half to min_half heap\\n3. remove top of max_half\\n\\nEvaluation of median:\\n1. if k is odd, median is top element of max_half\\n2. else median is average of top elements of min_half and max_half\\n\\nTC- O(\\n\\nPFB the code for your refernce:\\n```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> ans;\\n        int n=nums.size();\\n        priority_queue<int,vector<int>, greater<int> > min_half;\\n        priority_queue<int> max_half;\\n        for(int i=0;i<k;i++) max_half.push(nums[i]);\\n        for(int i=0;i<k/2;i++){\\n            min_half.push(max_half.top());\\n            max_half.pop();\\n        }\\n        if(k&1) ans.push_back(max_half.top());\\n        else ans.push_back((1LL*min_half.top()+1LL*max_half.top())*1.0/2);\\n        multiset<int> del_max,del_min;\\n        for(int i=k;i<n;i++){\\n            if(nums[i-k]<=max_half.top()){ //target->remove from max_half && add to max half\\n                del_max.insert(nums[i-k]);\\n                min_half.push(nums[i]);\\n                while(del_min.find(min_half.top())!=del_min.end()){\\n                    del_min.erase(del_min.find(min_half.top()));\\n                    min_half.pop();\\n                }\\n                max_half.push(min_half.top());\\n                min_half.pop();\\n            }\\n            else{\\n                del_min.insert(nums[i-k]);\\n                max_half.push(nums[i]);\\n                while(del_max.find(max_half.top())!=del_max.end()){\\n                    del_max.erase(del_max.find(max_half.top()));\\n                    max_half.pop();\\n                }\\n                min_half.push(max_half.top()); \\n                max_half.pop();\\n            }\\n            while(del_min.find(min_half.top())!=del_min.end()){\\n                del_min.erase(del_min.find(min_half.top()));\\n                min_half.pop();\\n            }\\n            while(del_max.find(max_half.top())!=del_max.end()){\\n                del_max.erase(del_max.find(max_half.top()));\\n                max_half.pop();\\n            }\\n            if(k&1) ans.push_back(max_half.top());\\n            else ans.push_back((1LL*min_half.top()+1LL*max_half.top())*1.0/2);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nP.S : same logic can be implemented using two multisets only:)\\n\\nFeel free to comment for any clarification, Happy coding:)",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<int> temp;\\n        double med;\\n        vector<double> ans;\\n        for(int i=k-1;i<nums.size();i++){\\n            temp.clear();\\n            for(int j=0;j<k;j++) //finding k element for curr window\\n                temp.push_back(nums[i-j]);\\n            sort(temp.begin(),temp.end());\\n            med= k&1 ? temp[k/2]: 1.0*(1LL*temp[k/2]+1LL*temp[(k-1)/2])/2;\\n            ans.push_back(med);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> ans;\\n        int n=nums.size();\\n        priority_queue<int,vector<int>, greater<int> > min_half;\\n        priority_queue<int> max_half;\\n        for(int i=0;i<k;i++) max_half.push(nums[i]);\\n        for(int i=0;i<k/2;i++){\\n            min_half.push(max_half.top());\\n            max_half.pop();\\n        }\\n        if(k&1) ans.push_back(max_half.top());\\n        else ans.push_back((1LL*min_half.top()+1LL*max_half.top())*1.0/2);\\n        multiset<int> del_max,del_min;\\n        for(int i=k;i<n;i++){\\n            if(nums[i-k]<=max_half.top()){ //target->remove from max_half && add to max half\\n                del_max.insert(nums[i-k]);\\n                min_half.push(nums[i]);\\n                while(del_min.find(min_half.top())!=del_min.end()){\\n                    del_min.erase(del_min.find(min_half.top()));\\n                    min_half.pop();\\n                }\\n                max_half.push(min_half.top());\\n                min_half.pop();\\n            }\\n            else{\\n                del_min.insert(nums[i-k]);\\n                max_half.push(nums[i]);\\n                while(del_max.find(max_half.top())!=del_max.end()){\\n                    del_max.erase(del_max.find(max_half.top()));\\n                    max_half.pop();\\n                }\\n                min_half.push(max_half.top()); \\n                max_half.pop();\\n            }\\n            while(del_min.find(min_half.top())!=del_min.end()){\\n                del_min.erase(del_min.find(min_half.top()));\\n                min_half.pop();\\n            }\\n            while(del_max.find(max_half.top())!=del_max.end()){\\n                del_max.erase(del_max.find(max_half.top()));\\n                max_half.pop();\\n            }\\n            if(k&1) ans.push_back(max_half.top());\\n            else ans.push_back((1LL*min_half.top()+1LL*max_half.top())*1.0/2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063653,
                "title": "python-2-heaps-sorted-lists-multiple-solutions",
                "content": "## Solution 1: Two Heaps => O(n*k)\\n```\\nclass Solution:\\n    def __init__(self):\\n        # Since Python only supports min heaps therefore,\\n        # maxHeap will have values of first half of array and all the values will be negative because by that only we can find the maximum value of first half of array.\\n        self.maxHeap = []\\n        # minHeap will have values of second half of array and all the values will be positive because by that only we can find the minimum value of second half of array.\\n        self.minHeap = []\\n    \\n    def rebalanceHeaps(self):\\n        # If k is odd then maxHeap will have one extra element than minHeap. Else both will have same.\\n        while len(self.maxHeap) - len(self.minHeap) > 1:\\n            heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap))\\n            \\n        while len(self.maxHeap) < len(self.minHeap):\\n            heapq.heappush(self.maxHeap, -heapq.heappop(self.minHeap))\\n                \\n\\n    def addNum(self, num):\\n        if not self.maxHeap or -self.maxHeap[0] > num:\\n            # Since we first negate the number and then store it, therefore, it will always pop out the largest number present in heap.\\n            heapq.heappush(self.maxHeap, -num)\\n        else:\\n            # Since we first negate the number that is popped out from max heap which means that the number eventually becomes positive again and then store it, therefore, it will always pop out the smallest number present in heap.\\n            heapq.heappush(self.minHeap, num)\\n        self.rebalanceHeaps()\\n    \\n    def removeNum(self, num):\\n        if num > -self.maxHeap[0]:\\n            self.minHeap.remove(num)\\n            heapq.heapify(self.minHeap)\\n        else:\\n            self.maxHeap.remove(-num)\\n            heapq.heapify(self.maxHeap)\\n        self.rebalanceHeaps()\\n\\n    def getCurrentMedian(self):\\n        if len(self.maxHeap) != len(self.minHeap):\\n            median = round(-self.maxHeap[0], 5)\\n        else:\\n            median = round((self.minHeap[0] - self.maxHeap[0]) / 2, 5)\\n        return median\\n\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        medians = [None] * (len(nums)-k+1)\\n        j = 0\\n\\n        for i in range(len(nums)):\\n            if i >= k:\\n                # Remove nums[i-k] from appropriate heap\\n                self.removeNum(nums[i-k])\\n\\n            # addNum(self.nums[i])\\n            self.addNum(nums[i])\\n            \\n            if i >= k-1:\\n                # getCurrentMedian()\\n                medians[j] = self.getCurrentMedian()\\n                j += 1\\n\\n        return medians\\n```\\n\\n## Solution 2: SortedList => O(n*log(k))\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def calcMedian(self, nums):\\n        if len(nums) & 1:\\n            return round(nums[len(nums)//2], 5)\\n        else:\\n            mid = len(nums)//2\\n            return round((nums[mid] + nums[mid-1]) / 2, 5)\\n        \\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        medians = [None] * (len(nums)-k+1)\\n        j = 0\\n        \\n        sortedList = SortedList()\\n        \\n        for i in range(len(nums)):\\n            if i >= k:\\n                # Remove nums[i-k] from sortedList. O(logK)\\n                sortedList.remove(nums[i-k])\\n            \\n            # O(logK)\\n            sortedList.add(nums[i])\\n            \\n            if i >= k-1:\\n                medians[j] = self.calcMedian(sortedList)\\n                j += 1\\n        \\n        return medians\\n        \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        # Since Python only supports min heaps therefore,\\n        # maxHeap will have values of first half of array and all the values will be negative because by that only we can find the maximum value of first half of array.\\n        self.maxHeap = []\\n        # minHeap will have values of second half of array and all the values will be positive because by that only we can find the minimum value of second half of array.\\n        self.minHeap = []\\n    \\n    def rebalanceHeaps(self):\\n        # If k is odd then maxHeap will have one extra element than minHeap. Else both will have same.\\n        while len(self.maxHeap) - len(self.minHeap) > 1:\\n            heapq.heappush(self.minHeap, -heapq.heappop(self.maxHeap))\\n            \\n        while len(self.maxHeap) < len(self.minHeap):\\n            heapq.heappush(self.maxHeap, -heapq.heappop(self.minHeap))\\n                \\n\\n    def addNum(self, num):\\n        if not self.maxHeap or -self.maxHeap[0] > num:\\n            # Since we first negate the number and then store it, therefore, it will always pop out the largest number present in heap.\\n            heapq.heappush(self.maxHeap, -num)\\n        else:\\n            # Since we first negate the number that is popped out from max heap which means that the number eventually becomes positive again and then store it, therefore, it will always pop out the smallest number present in heap.\\n            heapq.heappush(self.minHeap, num)\\n        self.rebalanceHeaps()\\n    \\n    def removeNum(self, num):\\n        if num > -self.maxHeap[0]:\\n            self.minHeap.remove(num)\\n            heapq.heapify(self.minHeap)\\n        else:\\n            self.maxHeap.remove(-num)\\n            heapq.heapify(self.maxHeap)\\n        self.rebalanceHeaps()\\n\\n    def getCurrentMedian(self):\\n        if len(self.maxHeap) != len(self.minHeap):\\n            median = round(-self.maxHeap[0], 5)\\n        else:\\n            median = round((self.minHeap[0] - self.maxHeap[0]) / 2, 5)\\n        return median\\n\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        medians = [None] * (len(nums)-k+1)\\n        j = 0\\n\\n        for i in range(len(nums)):\\n            if i >= k:\\n                # Remove nums[i-k] from appropriate heap\\n                self.removeNum(nums[i-k])\\n\\n            # addNum(self.nums[i])\\n            self.addNum(nums[i])\\n            \\n            if i >= k-1:\\n                # getCurrentMedian()\\n                medians[j] = self.getCurrentMedian()\\n                j += 1\\n\\n        return medians\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def calcMedian(self, nums):\\n        if len(nums) & 1:\\n            return round(nums[len(nums)//2], 5)\\n        else:\\n            mid = len(nums)//2\\n            return round((nums[mid] + nums[mid-1]) / 2, 5)\\n        \\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        medians = [None] * (len(nums)-k+1)\\n        j = 0\\n        \\n        sortedList = SortedList()\\n        \\n        for i in range(len(nums)):\\n            if i >= k:\\n                # Remove nums[i-k] from sortedList. O(logK)\\n                sortedList.remove(nums[i-k])\\n            \\n            # O(logK)\\n            sortedList.add(nums[i])\\n            \\n            if i >= k-1:\\n                medians[j] = self.calcMedian(sortedList)\\n                j += 1\\n        \\n        return medians\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042751,
                "title": "c-simplest-code-to-understand-explained-priority-queue",
                "content": "**Please do upvote if you liked my code ;)**\\n\\n```\\nclass Solution {\\npublic:\\n    multiset<double> minH;\\n    multiset<double, greater<double>> maxH;\\n    \\n    void balanceHeaps()\\n    {\\n        if(maxH.size() > minH.size())\\n        {\\n            minH.insert(*maxH.begin());  \\n            maxH.erase(maxH.begin());\\n        }\\n    }\\n    \\n    double getMedian(int k)\\n    {\\n        if(k%2 == 0)\\n            return (*minH.begin() + *maxH.begin())*0.5;\\n        else return *minH.begin();\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) \\n    {\\n        vector<double> ans;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(i >= k) // Only delete element from one of the heaps\\n            {\\n                if(minH.find(nums[i-k]) != minH.end()) minH.erase(minH.find(nums[i-k]));\\n                else maxH.erase(maxH.find(nums[i-k]));\\n            }\\n            \\n            // The idea here is very simple: First we insert the current element in the min heap\\n            // The we insert the top of min heap to max heap\\n            // Then we balance the heaps i.e. move element from max to min heap if max heap has\\n            // greater size\\n            minH.insert(nums[i]);\\n            maxH.insert(*minH.begin());\\n            minH.erase(minH.begin());\\n            \\n            balanceHeaps();            \\n            \\n            if(i >= k-1) ans.push_back(getMedian(k)); \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    multiset<double> minH;\\n    multiset<double, greater<double>> maxH;\\n    \\n    void balanceHeaps()\\n    {\\n        if(maxH.size() > minH.size())\\n        {\\n            minH.insert(*maxH.begin());  \\n            maxH.erase(maxH.begin());\\n        }\\n    }\\n    \\n    double getMedian(int k)\\n    {\\n        if(k%2 == 0)\\n            return (*minH.begin() + *maxH.begin())*0.5;\\n        else return *minH.begin();\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) \\n    {\\n        vector<double> ans;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(i >= k) // Only delete element from one of the heaps\\n            {\\n                if(minH.find(nums[i-k]) != minH.end()) minH.erase(minH.find(nums[i-k]));\\n                else maxH.erase(maxH.find(nums[i-k]));\\n            }\\n            \\n            // The idea here is very simple: First we insert the current element in the min heap\\n            // The we insert the top of min heap to max heap\\n            // Then we balance the heaps i.e. move element from max to min heap if max heap has\\n            // greater size\\n            minH.insert(nums[i]);\\n            maxH.insert(*minH.begin());\\n            minH.erase(minH.begin());\\n            \\n            balanceHeaps();            \\n            \\n            if(i >= k-1) ans.push_back(getMedian(k)); \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869820,
                "title": "simple-c-solution-with-comments-beats-92-of-submissions",
                "content": "```\\nclass Solution {\\n    // For window of size k, to find median, we need to maintain a maxHeap and\\n    // a minHeap.\\n    \\n    // If we sort the elements of the window, maxHeap will store the lower half \\n    // of the elements in the window. And, minHeap will store the upper half of \\n    // the elements in the window.\\n    \\n    // We don\\'t actually need to sort these elements, heaps will take care of it\\n    // We just need to make sure that:\\n    // for maxHeap, incomming element <= maxHeap.top() and \\n    // for minHeap, incomming element >= minHeap.top()\\n    \\n    // We could then just look at the top of the heaps and figure out the median\\n    \\n    // At each step, as the window moves forward, we will remove the outgoing \\n    // element from these heaps and add the incomming elements in the heaps.\\n    \\n    // The only trick here is that you need to avoid popping the element if\\n    // is is not at the top of the heap\\n    \\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        // Create a vector of double to store answer\\n        vector<double> ans;\\n        \\n        // Push first k elements to maxHeap\\n        for (int i = 0; i < k; ++i) {\\n            maxHeap.push(nums[i]);\\n        }\\n        \\n        // Balance the maxHeap and minHeap as they should have roughy the same \\n        // number of elements\\n        while (maxHeap.size() > minHeap.size() + 1) {\\n            minHeap.push(maxHeap.top());\\n            maxHeap.pop();\\n        }\\n        \\n        // We will keep track of balance via this integer. Basically, \\n        // Remove from max heap => balance++\\n        // Remove from min heap => balance--\\n        // Insert into maxHeap => balance--\\n        // Insert into minHeap => balance++\\n        // This way we can use the balance integer to maintain the sizes of \\n        // both the heaps equal or off by one before calculating the median.\\n        // In between calculating medians, sizes can become off by 2. That is \\n        // okay\\n        int balance = minHeap.size() - maxHeap.size();\\n        \\n        // There are 3 cases for calculating median\\n        // At this point, balance should be -1, 0, or 1\\n        // 1. If minHeap has more elements\\n        if (balance > 0) {\\n            // then median is the minHeap.top()\\n            ans.push_back((double)minHeap.top());\\n        // 2. If maxHeap has more elements\\n        } else if (balance < 0) {\\n            // then mendian is the maxHeap.top()\\n            ans.push_back((double)maxHeap.top());\\n        // 3. If both heaps have same number of elements, then median is average\\n        } else {\\n            // then median is the average\\n            ans.push_back(((double)maxHeap.top() + (double)minHeap.top()) / 2.0);\\n        }\\n        \\n        // We will not actully delete anything, but keep track of deleted ones\\n        // in this map. We will deal with them when they come at the top of the\\n        // respective heaps, by just ignoring them then.\\n        unordered_map<int, int> deleted;\\n        \\n        // For rest of the elements\\n        for (int i = k; i < nums.size(); ++i) {\\n            // Remove the outgoing element\\n            \\n            // If outgoing element is at top of maxHeap\\n            if (!maxHeap.empty() && maxHeap.top() == nums[i-k]) {\\n                // Remove it\\n                maxHeap.pop();\\n                // Update balance to indicate removal from maxHeap\\n                balance++;\\n            // Else if outgoing element is at top of minHeap\\n            } else if (!minHeap.empty() && minHeap.top() == nums[i-k]) {\\n                // Remove it\\n                minHeap.pop();\\n                // Update balance to indicate removal from minHeap\\n                balance--;\\n            // Else, it means that outgoing item is not at top of any heap\\n            // *** IMPORTANT: In this case we can remove the outgoing element.\\n            //                But, doing so would mean that we need to move\\n            //                some elements that are at top and move them back.\\n            //                This is inefficient.\\n            //                Instead, we will learn to ignore these elements \\n            //                until they move to top of the heaps by recording\\n            //                them in the `deleted` map.\\n            } else {\\n                // If outgoing element is present in the maxHeap\\n                if (!maxHeap.empty() && maxHeap.top() > nums[i-k]) {\\n                    // Create an entry in the `deleted` map or increment count \\n                    // if it already exists\\n                    deleted[nums[i-k]]++;\\n                    // Update balance to indicate that element is removed from \\n                    // maxHeap\\n                    balance++;\\n                // Else if outgoing element is present in the maxHeap\\n                } else if (!minHeap.empty() && minHeap.top() < nums[i-k]) {\\n                    // Create an entry in the `deleted` map or increment count \\n                    // if it already exists\\n                    deleted[nums[i-k]]++;\\n                    // Update balance to indicate that element is removed from \\n                    // minHeap\\n                    balance--;\\n                }\\n            }\\n            \\n            // Insert incomming element\\n            \\n            // We need to insert in such a way that balance after insertion \\n            // goes closer to 0 i.e both the heaps have roughly equal number of \\n            // elements.\\n            \\n            // We also need to make sure that (as said earlier):\\n            // for maxHeap, incomming element <= maxHeap.top() and \\n            // for minHeap, incomming element >= minHeap.top()\\n            \\n            // If minHeap has less elements\\n            if (balance < 0) {\\n                // If incomming element can go in minHeap\\n                if (nums[i] >= maxHeap.top()) {\\n                    // Insert incomming element into minHeap\\n                    minHeap.push(nums[i]);\\n                // Else if incomming element cannot go in minHeap\\n                } else {\\n                    // Move one element from maxHeap to minHeap\\n                    minHeap.push(maxHeap.top());\\n                    maxHeap.pop();\\n                    // Insert incomming element into the maxHeap\\n                    maxHeap.push(nums[i]);\\n                }\\n                // Update balance to indicate insertion in minHeap\\n                balance++;\\n            // Else if maxHeap has less elements\\n            } else if (balance > 0) {\\n                // If incomming element can go in maxHeap\\n                if (nums[i] <= minHeap.top()) {\\n                    // Insert incomming element into maxHeap\\n                    maxHeap.push(nums[i]);\\n                // Else if incomming element cannot go in maxHeap\\n                } else{\\n                    // Move one element from minHeap to maxHeap\\n                    maxHeap.push(minHeap.top());\\n                    minHeap.pop();\\n                    // Insert incomming element into the minHeap\\n                    minHeap.push(nums[i]);\\n                }\\n                // Update balance to indicate insertion in maxHeap\\n                balance--;\\n            // Else, it means that both the heaps have equal number of elements\\n            // In this case, we choose to make maxHeap longer than one element\\n            // if possible\\n            } else {\\n                // If incomming element can go in maxHeap\\n                if (nums[i] <= maxHeap.top()) {\\n                    // Insert incomming element into the maxHeap\\n                    maxHeap.push(nums[i]);\\n                    // Update balance to indicate insertion in maxHeap\\n                    balance--;\\n                // else incomming element cannot go in maxHeap\\n                } else {\\n                    // Insert incomming element into the minHeap\\n                    minHeap.push(nums[i]);\\n                    // Update balance to indicate insertion in minHeap\\n                    balance++;\\n                }\\n            }\\n            \\n            // To find median, we need to look at the top of the heaps.\\n            // So, ignore any elements that have already been deleted earlier\\n            // but not removed yet from the heap as they were not at the top\\n            \\n            // If top element at maxHeap was deleted\\n            while (!maxHeap.empty() && deleted[maxHeap.top()] > 0) {\\n                // Decrement the deleted counter\\n                deleted[maxHeap.top()]--;\\n                // Remove the element from the top of maxHeap\\n                maxHeap.pop();\\n            }\\n            // If top element at minHeap was deleted\\n            while (!minHeap.empty() && deleted[minHeap.top()] > 0) {\\n                // Decrement the deleted counter\\n                deleted[minHeap.top()]--;\\n                // Remove the element from the top of minHeap\\n                minHeap.pop();\\n            }\\n            \\n            // There are 3 cases for calculating median\\n            // At this point, balance should be -1, 0, or 1\\n            // 1. If minHeap has more elements\\n            if (balance > 0) {\\n                // then median is the minHeap.top()\\n                ans.push_back((double)minHeap.top());\\n            // 2. If maxHeap has more elements\\n            } else if (balance < 0) {\\n                // then mendian is the maxHeap.top()\\n                ans.push_back((double)maxHeap.top());\\n            // 3. If both heaps have same number of elements, then median is average\\n            } else {\\n                // then median is the average\\n                ans.push_back(((double)maxHeap.top() + (double)minHeap.top()) / 2.0);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    // For window of size k, to find median, we need to maintain a maxHeap and\\n    // a minHeap.\\n    \\n    // If we sort the elements of the window, maxHeap will store the lower half \\n    // of the elements in the window. And, minHeap will store the upper half of \\n    // the elements in the window.\\n    \\n    // We don\\'t actually need to sort these elements, heaps will take care of it\\n    // We just need to make sure that:\\n    // for maxHeap, incomming element <= maxHeap.top() and \\n    // for minHeap, incomming element >= minHeap.top()\\n    \\n    // We could then just look at the top of the heaps and figure out the median\\n    \\n    // At each step, as the window moves forward, we will remove the outgoing \\n    // element from these heaps and add the incomming elements in the heaps.\\n    \\n    // The only trick here is that you need to avoid popping the element if\\n    // is is not at the top of the heap\\n    \\nprivate:\\n    priority_queue<int> maxHeap;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        // Create a vector of double to store answer\\n        vector<double> ans;\\n        \\n        // Push first k elements to maxHeap\\n        for (int i = 0; i < k; ++i) {\\n            maxHeap.push(nums[i]);\\n        }\\n        \\n        // Balance the maxHeap and minHeap as they should have roughy the same \\n        // number of elements\\n        while (maxHeap.size() > minHeap.size() + 1) {\\n            minHeap.push(maxHeap.top());\\n            maxHeap.pop();\\n        }\\n        \\n        // We will keep track of balance via this integer. Basically, \\n        // Remove from max heap => balance++\\n        // Remove from min heap => balance--\\n        // Insert into maxHeap => balance--\\n        // Insert into minHeap => balance++\\n        // This way we can use the balance integer to maintain the sizes of \\n        // both the heaps equal or off by one before calculating the median.\\n        // In between calculating medians, sizes can become off by 2. That is \\n        // okay\\n        int balance = minHeap.size() - maxHeap.size();\\n        \\n        // There are 3 cases for calculating median\\n        // At this point, balance should be -1, 0, or 1\\n        // 1. If minHeap has more elements\\n        if (balance > 0) {\\n            // then median is the minHeap.top()\\n            ans.push_back((double)minHeap.top());\\n        // 2. If maxHeap has more elements\\n        } else if (balance < 0) {\\n            // then mendian is the maxHeap.top()\\n            ans.push_back((double)maxHeap.top());\\n        // 3. If both heaps have same number of elements, then median is average\\n        } else {\\n            // then median is the average\\n            ans.push_back(((double)maxHeap.top() + (double)minHeap.top()) / 2.0);\\n        }\\n        \\n        // We will not actully delete anything, but keep track of deleted ones\\n        // in this map. We will deal with them when they come at the top of the\\n        // respective heaps, by just ignoring them then.\\n        unordered_map<int, int> deleted;\\n        \\n        // For rest of the elements\\n        for (int i = k; i < nums.size(); ++i) {\\n            // Remove the outgoing element\\n            \\n            // If outgoing element is at top of maxHeap\\n            if (!maxHeap.empty() && maxHeap.top() == nums[i-k]) {\\n                // Remove it\\n                maxHeap.pop();\\n                // Update balance to indicate removal from maxHeap\\n                balance++;\\n            // Else if outgoing element is at top of minHeap\\n            } else if (!minHeap.empty() && minHeap.top() == nums[i-k]) {\\n                // Remove it\\n                minHeap.pop();\\n                // Update balance to indicate removal from minHeap\\n                balance--;\\n            // Else, it means that outgoing item is not at top of any heap\\n            // *** IMPORTANT: In this case we can remove the outgoing element.\\n            //                But, doing so would mean that we need to move\\n            //                some elements that are at top and move them back.\\n            //                This is inefficient.\\n            //                Instead, we will learn to ignore these elements \\n            //                until they move to top of the heaps by recording\\n            //                them in the `deleted` map.\\n            } else {\\n                // If outgoing element is present in the maxHeap\\n                if (!maxHeap.empty() && maxHeap.top() > nums[i-k]) {\\n                    // Create an entry in the `deleted` map or increment count \\n                    // if it already exists\\n                    deleted[nums[i-k]]++;\\n                    // Update balance to indicate that element is removed from \\n                    // maxHeap\\n                    balance++;\\n                // Else if outgoing element is present in the maxHeap\\n                } else if (!minHeap.empty() && minHeap.top() < nums[i-k]) {\\n                    // Create an entry in the `deleted` map or increment count \\n                    // if it already exists\\n                    deleted[nums[i-k]]++;\\n                    // Update balance to indicate that element is removed from \\n                    // minHeap\\n                    balance--;\\n                }\\n            }\\n            \\n            // Insert incomming element\\n            \\n            // We need to insert in such a way that balance after insertion \\n            // goes closer to 0 i.e both the heaps have roughly equal number of \\n            // elements.\\n            \\n            // We also need to make sure that (as said earlier):\\n            // for maxHeap, incomming element <= maxHeap.top() and \\n            // for minHeap, incomming element >= minHeap.top()\\n            \\n            // If minHeap has less elements\\n            if (balance < 0) {\\n                // If incomming element can go in minHeap\\n                if (nums[i] >= maxHeap.top()) {\\n                    // Insert incomming element into minHeap\\n                    minHeap.push(nums[i]);\\n                // Else if incomming element cannot go in minHeap\\n                } else {\\n                    // Move one element from maxHeap to minHeap\\n                    minHeap.push(maxHeap.top());\\n                    maxHeap.pop();\\n                    // Insert incomming element into the maxHeap\\n                    maxHeap.push(nums[i]);\\n                }\\n                // Update balance to indicate insertion in minHeap\\n                balance++;\\n            // Else if maxHeap has less elements\\n            } else if (balance > 0) {\\n                // If incomming element can go in maxHeap\\n                if (nums[i] <= minHeap.top()) {\\n                    // Insert incomming element into maxHeap\\n                    maxHeap.push(nums[i]);\\n                // Else if incomming element cannot go in maxHeap\\n                } else{\\n                    // Move one element from minHeap to maxHeap\\n                    maxHeap.push(minHeap.top());\\n                    minHeap.pop();\\n                    // Insert incomming element into the minHeap\\n                    minHeap.push(nums[i]);\\n                }\\n                // Update balance to indicate insertion in maxHeap\\n                balance--;\\n            // Else, it means that both the heaps have equal number of elements\\n            // In this case, we choose to make maxHeap longer than one element\\n            // if possible\\n            } else {\\n                // If incomming element can go in maxHeap\\n                if (nums[i] <= maxHeap.top()) {\\n                    // Insert incomming element into the maxHeap\\n                    maxHeap.push(nums[i]);\\n                    // Update balance to indicate insertion in maxHeap\\n                    balance--;\\n                // else incomming element cannot go in maxHeap\\n                } else {\\n                    // Insert incomming element into the minHeap\\n                    minHeap.push(nums[i]);\\n                    // Update balance to indicate insertion in minHeap\\n                    balance++;\\n                }\\n            }\\n            \\n            // To find median, we need to look at the top of the heaps.\\n            // So, ignore any elements that have already been deleted earlier\\n            // but not removed yet from the heap as they were not at the top\\n            \\n            // If top element at maxHeap was deleted\\n            while (!maxHeap.empty() && deleted[maxHeap.top()] > 0) {\\n                // Decrement the deleted counter\\n                deleted[maxHeap.top()]--;\\n                // Remove the element from the top of maxHeap\\n                maxHeap.pop();\\n            }\\n            // If top element at minHeap was deleted\\n            while (!minHeap.empty() && deleted[minHeap.top()] > 0) {\\n                // Decrement the deleted counter\\n                deleted[minHeap.top()]--;\\n                // Remove the element from the top of minHeap\\n                minHeap.pop();\\n            }\\n            \\n            // There are 3 cases for calculating median\\n            // At this point, balance should be -1, 0, or 1\\n            // 1. If minHeap has more elements\\n            if (balance > 0) {\\n                // then median is the minHeap.top()\\n                ans.push_back((double)minHeap.top());\\n            // 2. If maxHeap has more elements\\n            } else if (balance < 0) {\\n                // then mendian is the maxHeap.top()\\n                ans.push_back((double)maxHeap.top());\\n            // 3. If both heaps have same number of elements, then median is average\\n            } else {\\n                // then median is the average\\n                ans.push_back(((double)maxHeap.top() + (double)minHeap.top()) / 2.0);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842253,
                "title": "o-n-log-k-c-straight-forward-using-two-sets-as-heaps",
                "content": "The question is similar to find median in a stream https://leetcode.com/problems/find-median-from-data-stream/.\\nI\\'d suggest you to go through the above problem before proceeding with this one\\n\\nThere are two things to keep in mind: \\n1. Create balanced heaps for current window. \\n2. Discard elements that are out of current window.\\n\\nUnfortunately, priority_queue in C++ doesn\\'t allow effecient O(log n) deletion, so we will use sets as heaps.\\nwe can get max element of max heap using *(maxh.rbegin()) and min element of min heap using *(minh.begin())\\n\\nIn order to handle duplicates, we can use a pair of {number, index} instead of just number, this has an added advantage because pairs are by default evaluated by first value in C++, so there is no need to write a custom comparator like in a lot of other answers.\\n\\nCode: \\n```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        set<pair<int, int>> maxh; // get max element using *(maxh.rbegin());\\n        set<pair<int, int>> minh; // get min element using *(minh.begin());\\n        \\n        for(int i = 0; i < k; i++) {\\n            maxh.insert({nums[i], i}); // a {number, index} pair will always be unique (for handling duplicates)\\n        }\\n        \\n        for(int i = 0; i < k/2; i++) {\\n            minh.insert(*maxh.rbegin());\\n            maxh.erase(*maxh.rbegin());\\n        }\\n        \\n        vector<double> res;\\n        \\n        int n = nums.size();\\n        \\n        for(int i = k; i < n; i++) {\\n            if(k % 2 == 0) {\\n                res.push_back(((double)(maxh.rbegin())->first + (double)(minh.begin())->first) / 2.0);\\n            } else {\\n                res.push_back((double) (maxh.rbegin())->first);\\n            }\\n            \\n            // delete the element that is out of window, deletion in O(log k)\\n            \\n            if(maxh.find({nums[i-k], i-k}) != maxh.end()) {\\n                maxh.erase({nums[i-k], i-k});\\n            }\\n            \\n            if(minh.find({nums[i-k], i-k}) != minh.end()) {\\n                minh.erase({nums[i-k], i-k});\\n            }\\n            \\n            // insert new element\\n            \\n            if(maxh.size() == 0 || nums[i] <= (maxh.rbegin())->first) {\\n                maxh.insert({nums[i], i});\\n            } else {\\n                minh.insert({nums[i], i});\\n            }\\n            \\n            // balance the sets/heaps\\n            \\n            if(minh.size() > maxh.size()) {\\n                pair<int, int> x = *(minh.begin());\\n                minh.erase(x);\\n                maxh.insert(x);\\n            }\\n            \\n            // maxh can have at max one more element than minh\\n            \\n            if(maxh.size() > minh.size()+1) {\\n                pair<int, int> x = *(maxh.rbegin());\\n                maxh.erase(x);\\n                minh.insert(x);\\n            }\\n        }\\n        \\n        if(k % 2 == 0) {\\n            res.push_back(((double)(maxh.rbegin())->first + (double)(minh.begin())->first) / 2.0);\\n        } else {\\n            res.push_back((double) (maxh.rbegin())->first);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        set<pair<int, int>> maxh; // get max element using *(maxh.rbegin());\\n        set<pair<int, int>> minh; // get min element using *(minh.begin());\\n        \\n        for(int i = 0; i < k; i++) {\\n            maxh.insert({nums[i], i}); // a {number, index} pair will always be unique (for handling duplicates)\\n        }\\n        \\n        for(int i = 0; i < k/2; i++) {\\n            minh.insert(*maxh.rbegin());\\n            maxh.erase(*maxh.rbegin());\\n        }\\n        \\n        vector<double> res;\\n        \\n        int n = nums.size();\\n        \\n        for(int i = k; i < n; i++) {\\n            if(k % 2 == 0) {\\n                res.push_back(((double)(maxh.rbegin())->first + (double)(minh.begin())->first) / 2.0);\\n            } else {\\n                res.push_back((double) (maxh.rbegin())->first);\\n            }\\n            \\n            // delete the element that is out of window, deletion in O(log k)\\n            \\n            if(maxh.find({nums[i-k], i-k}) != maxh.end()) {\\n                maxh.erase({nums[i-k], i-k});\\n            }\\n            \\n            if(minh.find({nums[i-k], i-k}) != minh.end()) {\\n                minh.erase({nums[i-k], i-k});\\n            }\\n            \\n            // insert new element\\n            \\n            if(maxh.size() == 0 || nums[i] <= (maxh.rbegin())->first) {\\n                maxh.insert({nums[i], i});\\n            } else {\\n                minh.insert({nums[i], i});\\n            }\\n            \\n            // balance the sets/heaps\\n            \\n            if(minh.size() > maxh.size()) {\\n                pair<int, int> x = *(minh.begin());\\n                minh.erase(x);\\n                maxh.insert(x);\\n            }\\n            \\n            // maxh can have at max one more element than minh\\n            \\n            if(maxh.size() > minh.size()+1) {\\n                pair<int, int> x = *(maxh.rbegin());\\n                maxh.erase(x);\\n                minh.insert(x);\\n            }\\n        }\\n        \\n        if(k % 2 == 0) {\\n            res.push_back(((double)(maxh.rbegin())->first + (double)(minh.begin())->first) / 2.0);\\n        } else {\\n            res.push_back((double) (maxh.rbegin())->first);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809075,
                "title": "java-o-logn-two-heaps-sliding-window-clean-code",
                "content": "```\\nclass Solution {    //extension of -> 295. Find Median from Data Stream (refer that solution before solving this)\\n    \\n    PriorityQueue<Integer> min;                             //minHeap\\n    PriorityQueue<Integer> max;                             //maxHeap\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {    //given fn.\\n        \\n        double[] ans = new double[nums.length - k + 1];     //answer array -> size is observation based\\n        \\n        min = new PriorityQueue<>();\\n        max = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            addNum(nums[i]);\\n            \\n            if(i - k + 1 >= 0) {\\n                // System.out.print(findMedian());\\n                ans[i - k + 1] = findMedian();\\n                remove(nums[i - k + 1]);                    //remove first element of window that got out of k size\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    public void remove(int val) {                           //remove the val from either heap\\n        if(val <= max.peek())\\n            max.remove(val);\\n        else if(val >= min.peek())\\n            min.remove(val);\\n        \\n        balanceHeap();                                      //self made fn. to balance it after each deletion\\n    }\\n    \\n    //taken from Q295. from here \\u2193\\n    public void addNum(int num) {\\n        if(max.isEmpty() || num <= max.peek()) {            //if num <= maxHeap\\'s top element\\n            max.add(num);\\n        } else {\\n            min.add(num);\\n        }\\n        balanceHeap();                                      //self made fn. to balance it after each addition\\n    }\\n    \\n    public double findMedian() {\\n        if(max.size() == min.size()) {                      //even\\n            return ((double)max.peek() + min.peek()) / 2;\\n        } else {                                            //odd -> max.size() = min.size() + 1\\n            return max.peek();\\n        }\\n    }\\n    \\n    public void balanceHeap() {                             //self made fn. -> if it fails either 1) or 2) condition -> balance it\\n        if(max.size() > min.size() + 1) {                   //1) max = min + 1\\n            min.add(max.remove());\\n        } else if(min.size() > max.size()) {                //2) max = min\\n            max.add(min.remove());\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {    //extension of -> 295. Find Median from Data Stream (refer that solution before solving this)\\n    \\n    PriorityQueue<Integer> min;                             //minHeap\\n    PriorityQueue<Integer> max;                             //maxHeap\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {    //given fn.\\n        \\n        double[] ans = new double[nums.length - k + 1];     //answer array -> size is observation based\\n        \\n        min = new PriorityQueue<>();\\n        max = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            addNum(nums[i]);\\n            \\n            if(i - k + 1 >= 0) {\\n                // System.out.print(findMedian());\\n                ans[i - k + 1] = findMedian();\\n                remove(nums[i - k + 1]);                    //remove first element of window that got out of k size\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1751080,
                "title": "c-solution-n-logk-using-two-sets",
                "content": "```\\n// using same idea as of median of data stream but using set for deletion operation\\nclass Solution {\\npublic:\\n    set<pair<double,int>> minHeap; // using as min heap\\n    set<pair<double,int>, greater<> >maxHeap; // using as max heap\\n    \\n    // to balance the sets after inserting a element\\n    void balance(){\\n        auto it = *minHeap.begin();\\n        minHeap.erase(minHeap.begin());\\n        maxHeap.insert(it);\\n        if(maxHeap.size() > minHeap.size()){\\n            it = *maxHeap.begin();\\n            minHeap.insert(it);\\n            maxHeap.erase(maxHeap.begin());\\n        }\\n    }\\n    \\n    // adjust the sets after removing the (i - k)th element from one of the sets \\n    void adjust(){\\n        // sizes of heaps are initially same but element is deleted from minHeap \\n        if(maxHeap.size() > minHeap.size()){\\n            auto it = *maxHeap.begin();\\n            minHeap.insert(it);\\n            maxHeap.erase(maxHeap.begin());\\n        }\\n        // size of minHeap was 1 more than maxHeap and element deleted from maxHeap\\n        if(minHeap.size() > 1 + maxHeap.size()){\\n            auto it = *minHeap.begin();\\n            minHeap.erase(minHeap.begin());\\n            maxHeap.insert(it);\\n        }\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> ans;\\n        int n = nums.size();\\n        //processing first k element\\n        for(int i = 0; i < k; i++){\\n            minHeap.insert({nums[i], i});\\n            balance(); // balancing after insertion\\n        }\\n        ans.push_back(minHeap.begin() -> first);\\n        if(k % 2 == 0){\\n            ans.back() = (ans.back() + maxHeap.begin()->first) / 2.0;\\n        }\\n        for(int i = k; i < n ; i++){\\n            //checking if (i-k)th element is in minHeap\\n            if(minHeap.count({nums[i-k], i-k})){\\n                minHeap.erase({nums[i-k], i-k});\\n            }else{\\n                maxHeap.erase({nums[i-k], i-k});\\n            }\\n            // after deletion operation adjusting the sets/heaps  \\n            adjust();\\n            // inserting i-th element and then balancing\\n            minHeap.insert({nums[i], i});\\n            balance();\\n            \\n            ans.push_back(minHeap.begin() -> first);\\n            if(k % 2 == 0){\\n                ans.back() = (ans.back() + maxHeap.begin()->first) / 2.0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n###### TIME COMPLEXITY :  O(N LogK) \\n###### SPACE COMPLEXITY : O(K)\\n\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n// using same idea as of median of data stream but using set for deletion operation\\nclass Solution {\\npublic:\\n    set<pair<double,int>> minHeap; // using as min heap\\n    set<pair<double,int>, greater<> >maxHeap; // using as max heap\\n    \\n    // to balance the sets after inserting a element\\n    void balance(){\\n        auto it = *minHeap.begin();\\n        minHeap.erase(minHeap.begin());\\n        maxHeap.insert(it);\\n        if(maxHeap.size() > minHeap.size()){\\n            it = *maxHeap.begin();\\n            minHeap.insert(it);\\n            maxHeap.erase(maxHeap.begin());\\n        }\\n    }\\n    \\n    // adjust the sets after removing the (i - k)th element from one of the sets \\n    void adjust(){\\n        // sizes of heaps are initially same but element is deleted from minHeap \\n        if(maxHeap.size() > minHeap.size()){\\n            auto it = *maxHeap.begin();\\n            minHeap.insert(it);\\n            maxHeap.erase(maxHeap.begin());\\n        }\\n        // size of minHeap was 1 more than maxHeap and element deleted from maxHeap\\n        if(minHeap.size() > 1 + maxHeap.size()){\\n            auto it = *minHeap.begin();\\n            minHeap.erase(minHeap.begin());\\n            maxHeap.insert(it);\\n        }\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> ans;\\n        int n = nums.size();\\n        //processing first k element\\n        for(int i = 0; i < k; i++){\\n            minHeap.insert({nums[i], i});\\n            balance(); // balancing after insertion\\n        }\\n        ans.push_back(minHeap.begin() -> first);\\n        if(k % 2 == 0){\\n            ans.back() = (ans.back() + maxHeap.begin()->first) / 2.0;\\n        }\\n        for(int i = k; i < n ; i++){\\n            //checking if (i-k)th element is in minHeap\\n            if(minHeap.count({nums[i-k], i-k})){\\n                minHeap.erase({nums[i-k], i-k});\\n            }else{\\n                maxHeap.erase({nums[i-k], i-k});\\n            }\\n            // after deletion operation adjusting the sets/heaps  \\n            adjust();\\n            // inserting i-th element and then balancing\\n            minHeap.insert({nums[i], i});\\n            balance();\\n            \\n            ans.push_back(minHeap.begin() -> first);\\n            if(k % 2 == 0){\\n                ans.back() = (ans.back() + maxHeap.begin()->first) / 2.0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734318,
                "title": "shortest-code-c-policy-based-data-structure",
                "content": "The idea is generate multiset like data structure from policy based data structure.\\n```\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, \\n             tree_order_statistics_node_update> ordered_multiset;\\n \\n Here I use less_equal that works like mutiset .\\n Some points\\n * You can not use erase directly.Here We have to upper_bound\\n * In this data structure upper_bound works like lower bound and vice-versa.\\n \\n Useful link below\\n https://codeforces.com/blog/entry/11080\\n \\n ```\\n ```\\n //CODE START HERE\\n \\n #include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace std;\\nusing namespace __gnu_pbds;\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, \\n             tree_order_statistics_node_update> ordered_multiset;\\n\\t\\t\\t \\n// (Upper is Header file and creating data structure )\\n\\nclass Solution {\\npublic:\\n\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        \\n        vector<double>ans;\\n        ordered_multiset st;\\n         for(int i=0; i<nums.size(); i++)\\n        {\\n            st.insert(nums[i]);\\n            \\n            if(i>=k)\\n            {\\n                st.erase(st.upper_bound(nums[i-k])); // In this data structure  upper_bound works like lower_bound and vice versa.\\n\\t\\t\\t\\t// You can not dorectly use number to erase\\n            }\\n            \\n            if(i>=k-1)\\n            {\\n                \\n                double val1=0;\\n                double val2=0;\\n                double div=1.0;\\n                \\n                val1=*st.find_by_order(k/2);   // Find value by index\\n                if(k%2==0){\\n                    val2=*st.find_by_order(k/2-1);\\n                    div=2.0;\\n                    }\\n                \\n                double cur=(val1+val2)/div;\\n                ans.push_back(cur);\\n                \\n            }\\n        }\\n        \\n        return ans;    \\n        \\n    }\\n};\\n \\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, \\n             tree_order_statistics_node_update> ordered_multiset;\\n \\n Here I use less_equal that works like mutiset .\\n Some points\\n * You can not use erase directly.Here We have to upper_bound\\n * In this data structure upper_bound works like lower bound and vice-versa.\\n \\n Useful link below\\n https://codeforces.com/blog/entry/11080\\n \\n ```\n```\\n //CODE START HERE\\n \\n #include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\nusing namespace std;\\nusing namespace __gnu_pbds;\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, \\n             tree_order_statistics_node_update> ordered_multiset;\\n\\t\\t\\t \\n// (Upper is Header file and creating data structure )\\n\\nclass Solution {\\npublic:\\n\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        \\n        vector<double>ans;\\n        ordered_multiset st;\\n         for(int i=0; i<nums.size(); i++)\\n        {\\n            st.insert(nums[i]);\\n            \\n            if(i>=k)\\n            {\\n                st.erase(st.upper_bound(nums[i-k])); // In this data structure  upper_bound works like lower_bound and vice versa.\\n\\t\\t\\t\\t// You can not dorectly use number to erase\\n            }\\n            \\n            if(i>=k-1)\\n            {\\n                \\n                double val1=0;\\n                double val2=0;\\n                double div=1.0;\\n                \\n                val1=*st.find_by_order(k/2);   // Find value by index\\n                if(k%2==0){\\n                    val2=*st.find_by_order(k/2-1);\\n                    div=2.0;\\n                    }\\n                \\n                double cur=(val1+val2)/div;\\n                ans.push_back(cur);\\n                \\n            }\\n        }\\n        \\n        return ans;    \\n        \\n    }\\n};\\n \\n ```",
                "codeTag": "C++"
            },
            {
                "id": 1435077,
                "title": "c-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    int k;\\n    double median(vector<int>& v){\\n        if(k%2==0){\\n            double a=v[k/2];\\n            double b=v[k/2-1];\\n            return (a+b)/2;\\n        }\\n        return v[k/2];\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        this->k=k;\\n        vector<int> v;\\n        vector<double> ans;\\n        int r=0,l=0;\\n        while(r<k)\\n            v.push_back(nums[r++]);\\n        sort(v.begin(),v.end());\\n        ans.push_back(median(v));\\n        for(int i=r;i<nums.size();i++,l++){\\n            \\n            auto pos=lower_bound(v.begin(),v.end(),nums[l]);\\n            v.erase(pos);\\n            auto ins=upper_bound(v.begin(),v.end(),nums[i]);\\n            v.insert(ins,nums[i]);\\n            ans.push_back(median(v));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int k;\\n    double median(vector<int>& v){\\n        if(k%2==0){\\n            double a=v[k/2];\\n            double b=v[k/2-1];\\n            return (a+b)/2;\\n        }\\n        return v[k/2];\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        this->k=k;\\n        vector<int> v;\\n        vector<double> ans;\\n        int r=0,l=0;\\n        while(r<k)\\n            v.push_back(nums[r++]);\\n        sort(v.begin(),v.end());\\n        ans.push_back(median(v));\\n        for(int i=r;i<nums.size();i++,l++){\\n            \\n            auto pos=lower_bound(v.begin(),v.end(),nums[l]);\\n            v.erase(pos);\\n            auto ins=upper_bound(v.begin(),v.end(),nums[i]);\\n            v.insert(ins,nums[i]);\\n            ans.push_back(median(v));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407665,
                "title": "js-window-2-pointer",
                "content": "```\\n\\nvar medianSlidingWindow = function(nums, k) {\\n    \\n    let output = [];\\n    \\n    let left = 0;\\n    \\n    let right = 0;\\n        \\n    \\n   while(right < nums.length){\\n       \\n       \\n        \\n        if(right - left + 1 === k){\\n            \\n            let sortedSlice = nums.slice(left, right + 1).sort((a,b) => a-b);\\n            let middle = Math.floor((right + 1 - left) / 2);\\n            \\n            if(k % 2 === 0){\\n                output.push((sortedSlice[middle -1] + sortedSlice[middle]) / 2);\\n            } else {\\n                output.push(sortedSlice[middle]);\\n            }\\n           \\n            left++;\\n        }\\n        \\n        right++;\\n    }\\n    \\n    return output;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar medianSlidingWindow = function(nums, k) {\\n    \\n    let output = [];\\n    \\n    let left = 0;\\n    \\n    let right = 0;\\n        \\n    \\n   while(right < nums.length){\\n       \\n       \\n        \\n        if(right - left + 1 === k){\\n            \\n            let sortedSlice = nums.slice(left, right + 1).sort((a,b) => a-b);\\n            let middle = Math.floor((right + 1 - left) / 2);\\n            \\n            if(k % 2 === 0){\\n                output.push((sortedSlice[middle -1] + sortedSlice[middle]) / 2);\\n            } else {\\n                output.push(sortedSlice[middle]);\\n            }\\n           \\n            left++;\\n        }\\n        \\n        right++;\\n    }\\n    \\n    return output;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341219,
                "title": "rust-binary-search-vec-heap-beats-100-mem-and-speed",
                "content": "Inspired by [this](https://leetcode.com/problems/sliding-window-median/discuss/724965/Rust-Runtime-12ms-faster-than-100.00-use-sorted-vector-and-binary-search).\\n\\nImproved on [prev solution](https://leetcode.com/problems/sliding-window-median/discuss/1341143/Rust-2-Heaps-solution-beat-100-mem-%2B-speed).\\n\\nKey idea: vec + binary_search = heap. So just use vec with its built in binary_search.\\n\\n> Runtime: 8 ms, faster than 100.00% of Rust online submissions for Sliding Window Median.\\n> Memory Usage: 2.3 MB, less than 100.00% of Rust online submissions for Sliding Window Median.\\n\\nIt\\'s 100x faster than my previous BinaryHeap solution.\\n\\n```rust\\nimpl Solution {\\n    pub fn median_sliding_window(nums: Vec<i32>, k: i32) -> Vec<f64> {\\n        let mut window = Vec::<i32>::new();\\n\\n        let mut res: Vec<f64> = vec![];\\n        // insert all, and keep them in order\\n        for (ix, i) in nums.iter().enumerate() {\\n            // find where to insert\\n            let idx = match window.binary_search(i) { Ok(x) => x, Err(x) => x };\\n            // add new elem\\n            window.insert(idx, *i);\\n\\n            // remove oldest elem\\n            if window.len() > k as usize {\\n                let oldest = nums[ix - k as usize];\\n                window.remove(window.binary_search(&oldest).unwrap());\\n            }\\n            // get median\\n            // @warn index calculation!\\n            if window.len() == k as usize {\\n                let mid = k as usize / 2;\\n                let median = if k % 2 == 1 {\\n                    window[mid] as f64\\n                } else {\\n                    window[mid - 1] as f64 * 0.5 + window[mid] as f64 * 0.5\\n                };\\n                res.push(median);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn median_sliding_window(nums: Vec<i32>, k: i32) -> Vec<f64> {\\n        let mut window = Vec::<i32>::new();\\n\\n        let mut res: Vec<f64> = vec![];\\n        // insert all, and keep them in order\\n        for (ix, i) in nums.iter().enumerate() {\\n            // find where to insert\\n            let idx = match window.binary_search(i) { Ok(x) => x, Err(x) => x };\\n            // add new elem\\n            window.insert(idx, *i);\\n\\n            // remove oldest elem\\n            if window.len() > k as usize {\\n                let oldest = nums[ix - k as usize];\\n                window.remove(window.binary_search(&oldest).unwrap());\\n            }\\n            // get median\\n            // @warn index calculation!\\n            if window.len() == k as usize {\\n                let mid = k as usize / 2;\\n                let median = if k % 2 == 1 {\\n                    window[mid] as f64\\n                } else {\\n                    window[mid - 1] as f64 * 0.5 + window[mid] as f64 * 0.5\\n                };\\n                res.push(median);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195563,
                "title": "java-solution-treeset-o-n-logk",
                "content": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;\\n        TreeSet<Integer> left = new TreeSet<>(comparator);\\n        TreeSet<Integer> right = new TreeSet<>(comparator);\\n        List<Double> list = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            right.add(i);\\n        }\\n        for (int i = 0; i < k / 2; i++) {\\n            left.add(right.pollFirst());\\n        }\\n        putMedian(nums, list, left, right);\\n        for (int i = 0, j = k; j < nums.length; i++, j++) {\\n            insert(nums, left, right, j);\\n            remove(nums, left, right, i);\\n            rebalance(left, right);\\n            putMedian(nums, list, left, right);\\n        }\\n        double[] ans = new double[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            ans[i] = list.get(i);\\n        }\\n        return ans;\\n    }\\n    \\n    private void rebalance(TreeSet<Integer> left, TreeSet<Integer> right) {\\n        if (left.size() + 2 == right.size()) {\\n            left.add(right.pollFirst());\\n        } else if (left.size() == right.size() + 1) {\\n            right.add(left.pollLast());\\n        }\\n    }\\n    \\n    private void insert(int[] nums, TreeSet<Integer> left, TreeSet<Integer> right, int i) {\\n        if (left.size() != right.size()) {\\n            right.add(i);\\n            left.add(right.pollFirst());\\n        } else {\\n            left.add(i);\\n            right.add(left.pollLast());\\n        }\\n    }\\n    \\n    private void remove(int[] nums, TreeSet<Integer> left, TreeSet<Integer> right, int i) {\\n        if (!left.remove(i)) {\\n            right.remove(i);\\n        }\\n    }\\n    \\n    private void putMedian(int[] nums, List<Double> list, TreeSet<Integer> left, TreeSet<Integer> right) {\\n        if (left.size() != right.size()) {\\n            list.add(nums[right.first()] * 1.0);\\n        } else {\\n            long sum = (long)nums[left.last()] + (long)nums[right.first()];\\n            list.add((sum) / 2.0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;\\n        TreeSet<Integer> left = new TreeSet<>(comparator);\\n        TreeSet<Integer> right = new TreeSet<>(comparator);\\n        List<Double> list = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            right.add(i);\\n        }\\n        for (int i = 0; i < k / 2; i++) {\\n            left.add(right.pollFirst());\\n        }\\n        putMedian(nums, list, left, right);\\n        for (int i = 0, j = k; j < nums.length; i++, j++) {\\n            insert(nums, left, right, j);\\n            remove(nums, left, right, i);\\n            rebalance(left, right);\\n            putMedian(nums, list, left, right);\\n        }\\n        double[] ans = new double[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            ans[i] = list.get(i);\\n        }\\n        return ans;\\n    }\\n    \\n    private void rebalance(TreeSet<Integer> left, TreeSet<Integer> right) {\\n        if (left.size() + 2 == right.size()) {\\n            left.add(right.pollFirst());\\n        } else if (left.size() == right.size() + 1) {\\n            right.add(left.pollLast());\\n        }\\n    }\\n    \\n    private void insert(int[] nums, TreeSet<Integer> left, TreeSet<Integer> right, int i) {\\n        if (left.size() != right.size()) {\\n            right.add(i);\\n            left.add(right.pollFirst());\\n        } else {\\n            left.add(i);\\n            right.add(left.pollLast());\\n        }\\n    }\\n    \\n    private void remove(int[] nums, TreeSet<Integer> left, TreeSet<Integer> right, int i) {\\n        if (!left.remove(i)) {\\n            right.remove(i);\\n        }\\n    }\\n    \\n    private void putMedian(int[] nums, List<Double> list, TreeSet<Integer> left, TreeSet<Integer> right) {\\n        if (left.size() != right.size()) {\\n            list.add(nums[right.first()] * 1.0);\\n        } else {\\n            long sum = (long)nums[left.last()] + (long)nums[right.first()];\\n            list.add((sum) / 2.0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1178561,
                "title": "typescript-o-nk-klogk-solution-no-heap",
                "content": "You can\\'t write a heap data structure during the interview if you use JS/TS\\nSort the first window using O(klogk). Then use O(k) to keep the window sorted when adding & removing elements\\n\\nIt\\'s actually O(nk + klogk)\\n\\n```\\nfunction medianSlidingWindow(nums: number[], k: number): number[] {\\n    const medians: number[] = [];\\n    \\n    let window: number[];\\n    \\n    for (let i: number = 0; i + k <= nums.length; i++) {\\n        // Do the sorting only for the 1st window\\n        if (i === 0) {\\n            window = nums.slice(0, k);\\n            window.sort((a: number, b: number) => a - b);\\n            medians.push(getMedianFromWin(window, k));\\n        }\\n        else {\\n            // Add & Remove meanwhile keep it sorted\\n            // 0 1 2\\n            // 1 2 3\\n            // remove: i - 1   add: i + k - 1\\n            window.splice(window.indexOf(nums[i - 1]), 1);\\n            const toAdd: number = nums[i + k - 1];\\n            let j: number = 0;\\n            for (; j < window.length; j++) {\\n                if (window[j] >= toAdd) {\\n                    break;\\n                }\\n            }\\n            window.splice(j, 0, toAdd);\\n            medians.push(getMedianFromWin(window, k));\\n        }\\n    }\\n    \\n    return medians;\\n};\\n\\nfunction getMedianFromWin(win: number[], k: number): number {\\n    if (k & 1) {\\n        return win[k >> 1];\\n    }\\n    else {\\n        return (win[(k >> 1) - 1] + win[k >> 1]) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction medianSlidingWindow(nums: number[], k: number): number[] {\\n    const medians: number[] = [];\\n    \\n    let window: number[];\\n    \\n    for (let i: number = 0; i + k <= nums.length; i++) {\\n        // Do the sorting only for the 1st window\\n        if (i === 0) {\\n            window = nums.slice(0, k);\\n            window.sort((a: number, b: number) => a - b);\\n            medians.push(getMedianFromWin(window, k));\\n        }\\n        else {\\n            // Add & Remove meanwhile keep it sorted\\n            // 0 1 2\\n            // 1 2 3\\n            // remove: i - 1   add: i + k - 1\\n            window.splice(window.indexOf(nums[i - 1]), 1);\\n            const toAdd: number = nums[i + k - 1];\\n            let j: number = 0;\\n            for (; j < window.length; j++) {\\n                if (window[j] >= toAdd) {\\n                    break;\\n                }\\n            }\\n            window.splice(j, 0, toAdd);\\n            medians.push(getMedianFromWin(window, k));\\n        }\\n    }\\n    \\n    return medians;\\n};\\n\\nfunction getMedianFromWin(win: number[], k: number): number {\\n    if (k & 1) {\\n        return win[k >> 1];\\n    }\\n    else {\\n        return (win[(k >> 1) - 1] + win[k >> 1]) / 2;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1159366,
                "title": "simple-solution-python-two-heaps",
                "content": "```\\n#Author: Akaash Vishal Hazarika\\nimport heapq\\nclass Solution: \\n    def get_window_median(self):    \\n        if len(self.left)==len(self.right):\\n            result = (self.right[0] - self.left[0])/2\\n        else:\\n            result =self.right[0]\\n        return result\\n    \\n    def add_element_to_heaps(self,val):\\n        if len(self.left)==len(self.right):\\n            heapq.heappush(self.right, -heapq.heappushpop(self.left, -val))\\n        else:\\n            heapq.heappush(self.left, -heapq.heappushpop(self.right,val))\\n            \\n    def balance_heaps(self):\\n        if len(self.left)>len(self.right):\\n            heapq.heappush(self.right,-heapq.heappop(self.left))\\n        if len(self.right)-len(self.left)>1:\\n            heapq.heappush(self.left,-heapq.heappop(self.right)) \\n                \\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        self.left,self.right = [],[]\\n        for i in range(k):\\n            self.add_element_to_heaps(nums[i])\\n                \\n        result = [self.get_window_median()]\\n        \\n        for i in range(k,len(nums)):\\n                \\n            if nums[i-k]>=self.right[0]:\\n                self.right.remove(nums[i-k])\\n                heapq.heapify(self.right)\\n                self.balance_heaps()\\n\\n            else:\\n                self.left.remove(-nums[i-k])\\n                heapq.heapify(self.left)\\n                self.balance_heaps()\\n                       \\n            self.add_element_to_heaps(nums[i])                       \\n            result.append(self.get_window_median())      \\n            \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n#Author: Akaash Vishal Hazarika\\nimport heapq\\nclass Solution: \\n    def get_window_median(self):    \\n        if len(self.left)==len(self.right):\\n            result = (self.right[0] - self.left[0])/2\\n        else:\\n            result =self.right[0]\\n        return result\\n    \\n    def add_element_to_heaps(self,val):\\n        if len(self.left)==len(self.right):\\n            heapq.heappush(self.right, -heapq.heappushpop(self.left, -val))\\n        else:\\n            heapq.heappush(self.left, -heapq.heappushpop(self.right,val))\\n            \\n    def balance_heaps(self):\\n        if len(self.left)>len(self.right):\\n            heapq.heappush(self.right,-heapq.heappop(self.left))\\n        if len(self.right)-len(self.left)>1:\\n            heapq.heappush(self.left,-heapq.heappop(self.right)) \\n                \\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        self.left,self.right = [],[]\\n        for i in range(k):\\n            self.add_element_to_heaps(nums[i])\\n                \\n        result = [self.get_window_median()]\\n        \\n        for i in range(k,len(nums)):\\n                \\n            if nums[i-k]>=self.right[0]:\\n                self.right.remove(nums[i-k])\\n                heapq.heapify(self.right)\\n                self.balance_heaps()\\n\\n            else:\\n                self.left.remove(-nums[i-k])\\n                heapq.heapify(self.left)\\n                self.balance_heaps()\\n                       \\n            self.add_element_to_heaps(nums[i])                       \\n            result.append(self.get_window_median())      \\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158085,
                "title": "simple-o-n-k-python-solution-faster-than-93-13-python3-online-submissions",
                "content": "Step wise approach:\\n1. Took first k elements in a list.\\n2. sorted it in klogk complexity.\\n3. Since median depends on whether k is even or odd so, took 2 variables because in case of odd value of k average of the middle 2 values have to be calculated while in case of even values of k both the values would be same(just to make code simple by avoiding checking k is even or odd every time further). \\n4. Then for loop will run from k->lenght of nums\\n5. First we will pop the value at start and then include the value at the end in O(k) time(because length of list is k).\\n6. Now calculate the median and add the value in the flist.\\n\\n```\\ndef medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        lst=nums[:k]\\n        lst.sort()\\n        flist=[]\\n        if k%2==0:\\n            m2 = k//2\\n            m1=m2-1\\n            \\n        else:\\n            m1=m2=k//2\\n        \\n        l, start= len(nums), 0\\n        val = (lst[m1]+lst[m2])/2\\n        flist.append(val)\\n        \\n        for end in range(k, l):\\n            index=bisect.bisect_left(lst, nums[start])\\n            lst.pop(index)\\n            index=bisect.bisect_left(lst, nums[end])\\n            lst.insert(index, nums[end])\\n            val = (lst[m1]+lst[m2])/2\\n            flist.append(val)\\n            start+=1\\n        return flist\\n```",
                "solutionTags": [],
                "code": "```\\ndef medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        lst=nums[:k]\\n        lst.sort()\\n        flist=[]\\n        if k%2==0:\\n            m2 = k//2\\n            m1=m2-1\\n            \\n        else:\\n            m1=m2=k//2\\n        \\n        l, start= len(nums), 0\\n        val = (lst[m1]+lst[m2])/2\\n        flist.append(val)\\n        \\n        for end in range(k, l):\\n            index=bisect.bisect_left(lst, nums[start])\\n            lst.pop(index)\\n            index=bisect.bisect_left(lst, nums[end])\\n            lst.insert(index, nums[end])\\n            val = (lst[m1]+lst[m2])/2\\n            flist.append(val)\\n            start+=1\\n        return flist\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1149982,
                "title": "java-solution-using-min-and-max-heaps",
                "content": "```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        int nums_l = nums.length;\\n        double[] result = new double[nums_l - k + 1];\\n        \\n        if(k == 1) {\\n            for(int i = 0; i < nums_l; i++) {\\n                result[i] = nums[i];\\n            }\\n            \\n            return result;\\n        }\\n        \\n        if(k == 2) {\\n            for(int i = 1; i < nums_l; i++) {\\n                result[i - 1] = nums[i] / 2.0 + nums[i - 1] / 2.0;\\n            }\\n            \\n            return result;\\n        }\\n        \\n        for(int i = 0; i < nums_l; i++) {\\n            if(maxHeap.size() == 0 || maxHeap.peek() >= nums[i]) {\\n                maxHeap.add(nums[i]);\\n            } else {\\n                minHeap.add(nums[i]);\\n            }\\n            \\n            rebalanceHeaps();\\n            \\n            if(i >= k - 1) {\\n                result[i - k + 1] = findMeadian();\\n                removeElement(nums[i - k + 1]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void removeElement(int num) {\\n        \\n        if(num <= maxHeap.peek()) {\\n            maxHeap.remove(num);\\n        } else {\\n            minHeap.remove(num);\\n        }\\n        \\n        rebalanceHeaps();\\n    }\\n    \\n    private double findMeadian() {\\n        \\n        if(minHeap.size() == maxHeap.size()) {\\n            return (minHeap.peek() / 2.0 + maxHeap.peek() / 2.0);\\n        }\\n        \\n        return maxHeap.peek();\\n    }\\n    \\n    private void rebalanceHeaps() {\\n        \\n        if(maxHeap.size() > minHeap.size() + 1) {\\n            minHeap.add(maxHeap.poll());\\n        } else if(maxHeap.size() < minHeap.size()) {\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        int nums_l = nums.length;\\n        double[] result = new double[nums_l - k + 1];\\n        \\n        if(k == 1) {\\n            for(int i = 0; i < nums_l; i++) {\\n                result[i] = nums[i];\\n            }\\n            \\n            return result;\\n        }\\n        \\n        if(k == 2) {\\n            for(int i = 1; i < nums_l; i++) {\\n                result[i - 1] = nums[i] / 2.0 + nums[i - 1] / 2.0;\\n            }\\n            \\n            return result;\\n        }\\n        \\n        for(int i = 0; i < nums_l; i++) {\\n            if(maxHeap.size() == 0 || maxHeap.peek() >= nums[i]) {\\n                maxHeap.add(nums[i]);\\n            } else {\\n                minHeap.add(nums[i]);\\n            }\\n            \\n            rebalanceHeaps();\\n            \\n            if(i >= k - 1) {\\n                result[i - k + 1] = findMeadian();\\n                removeElement(nums[i - k + 1]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void removeElement(int num) {\\n        \\n        if(num <= maxHeap.peek()) {\\n            maxHeap.remove(num);\\n        } else {\\n            minHeap.remove(num);\\n        }\\n        \\n        rebalanceHeaps();\\n    }\\n    \\n    private double findMeadian() {\\n        \\n        if(minHeap.size() == maxHeap.size()) {\\n            return (minHeap.peek() / 2.0 + maxHeap.peek() / 2.0);\\n        }\\n        \\n        return maxHeap.peek();\\n    }\\n    \\n    private void rebalanceHeaps() {\\n        \\n        if(maxHeap.size() > minHeap.size() + 1) {\\n            minHeap.add(maxHeap.poll());\\n        } else if(maxHeap.size() < minHeap.size()) {\\n            maxHeap.add(minHeap.poll());\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079151,
                "title": "easiest-c-solution-using-multiset-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> window;\\n        multiset<long long> ms;\\n        int start=0;\\n        for(int i=0; i<nums.size(); i++) {\\n              ms.insert(nums[i]);\\n              if(i>=k-1) {\\n                   auto cur_mid=next(ms.begin(),k/2);     // get the mid pointer\\n                   auto prev_mid=prev(cur_mid,1-(k%2));  // get the prev mid pointer\\n                   double mid_val=*cur_mid+*prev_mid;   //  get the middle value\\n                   window.push_back(mid_val/(double)2); \\n                   ms.erase(ms.find(nums[start]));      // remove the value outside the segment k from the left when i>=k-1\\n                   start++;\\n              }\\n        }\\n        return window;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> window;\\n        multiset<long long> ms;\\n        int start=0;\\n        for(int i=0; i<nums.size(); i++) {\\n              ms.insert(nums[i]);\\n              if(i>=k-1) {\\n                   auto cur_mid=next(ms.begin(),k/2);     // get the mid pointer\\n                   auto prev_mid=prev(cur_mid,1-(k%2));  // get the prev mid pointer\\n                   double mid_val=*cur_mid+*prev_mid;   //  get the middle value\\n                   window.push_back(mid_val/(double)2); \\n                   ms.erase(ms.find(nums[start]));      // remove the value outside the segment k from the left when i>=k-1\\n                   start++;\\n              }\\n        }\\n        return window;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036877,
                "title": "my-c-solutions-using-pointer-two-multisets-and-two-priority-queues",
                "content": "Pointer\\n```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        multiset<long> window;\\n        vector<double> ans;\\n        REP(i, k) window.insert(nums[i]);\\n        auto mid = next(window.begin(), k / 2);\\n        double median = (*mid + *prev(mid, (k % 2) ^ 1)) / 2.0;\\n        ans.push_back(median);\\n        for(int i = k; i < n; i++){\\n            window.insert(nums[i]);\\n            if(nums[i] < *mid) mid = prev(mid);\\n            if(nums[i - k] <= *mid) mid = next(mid);\\n            window.erase(window.lower_bound(nums[i - k]));\\n            median = (*mid + *prev(mid, (k % 2) ^ 1)) / 2.0;\\n            ans.push_back(median);\\n        }       \\n        return ans;   \\n    }\\n};\\n```\\n\\nTwo Multisets\\n```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        multiset<long> low, high;\\n        vector<double> ans;\\n        REP(i, n){\\n            if(i >= k){\\n                if(nums[i - k] <= *low.rbegin()) low.erase(low.find(nums[i - k]));\\n                else high.erase(high.find(nums[i - k]));\\n            }\\n            if(low.empty() || (!low.empty() && nums[i] <= *low.rbegin())) low.insert(nums[i]);\\n            else high.insert(nums[i]);\\n            \\n            while(!low.empty() && !high.empty() && *low.rbegin() > *high.begin()){\\n                high.insert(*low.rbegin());\\n                low.erase(prev(low.end()));\\n                low.insert(*high.begin());\\n                high.erase(high.begin());\\n            }\\n            while(!high.empty() && low.size() < high.size()){\\n                low.insert(*high.begin());\\n                high.erase(high.begin());\\n            }\\n            while(!low.empty() && low.size() > high.size() + 1){\\n                high.insert(*low.rbegin());\\n                low.erase(prev(low.end()));\\n            }\\n            \\n            if(i >= k - 1){\\n                if(k % 2 == 0) ans.push_back((*low.rbegin() + *high.begin()) / 2.0);\\n                else ans.push_back(*low.rbegin());\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```\\n\\nTwo Priority Queues\\n```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\nprivate:\\n    priority_queue<long> low;\\n    priority_queue<long, vector<long>, greater<long>> high;\\n    unordered_map<long, int> removal_cnt;\\n    int balance;\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(k == 1) return vector<double>(ALL(nums));\\n        balance = 0;\\n        vector<double> ans;\\n        REP(i, k){\\n            low.push(nums[i]);\\n            balance++;\\n        }\\n        while(!low.empty() && balance > 1){\\n            high.push(low.top());\\n            low.pop();\\n            balance -= 2;\\n        }\\n        //balance = 0, 1\\n        if(k % 2 == 0) ans.push_back((low.top() + high.top()) / 2.0);\\n        else ans.push_back(low.top());\\n        \\n        for(int i = k; i < n; i++){\\n            removal_cnt[nums[i - k]]++;\\n            if(!low.empty() && low.top() >= nums[i - k]) balance--;\\n            else balance++;\\n            if(low.empty() || (!low.empty() && low.top() >= nums[i])){\\n                low.push(nums[i]);\\n                balance++;\\n            }else{\\n                high.push(nums[i]);\\n                balance--;\\n            }\\n            remove_invalid_elements();\\n            balancing();\\n            remove_invalid_elements();\\n            if(k % 2 == 0) ans.push_back((low.top() + high.top()) / 2.0);\\n            else ans.push_back(low.top());\\n        }\\n        return ans;\\n    }\\n    \\n    void remove_invalid_elements(){\\n        while(!low.empty() && removal_cnt[low.top()] > 0){\\n            removal_cnt[low.top()]--;\\n            low.pop();\\n        }\\n        while(!high.empty() && removal_cnt[high.top()] > 0){\\n            removal_cnt[high.top()]--;\\n            high.pop();\\n        }\\n        return;\\n    }\\n    \\n    void balancing(){\\n        while(!high.empty() && balance < 0){\\n            if(removal_cnt[high.top()] > 0){\\n                removal_cnt[high.top()]--;\\n                high.pop();\\n                continue;\\n            }\\n            low.push(high.top());\\n            high.pop();\\n            balance += 2;\\n        }\\n        while(!low.empty() && balance > 1){\\n            if(removal_cnt[low.top()] > 0){\\n                removal_cnt[low.top()]--;\\n                low.pop();\\n                continue;\\n            }\\n            high.push(low.top());\\n            low.pop();\\n            balance -= 2;\\n        }\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        multiset<long> window;\\n        vector<double> ans;\\n        REP(i, k) window.insert(nums[i]);\\n        auto mid = next(window.begin(), k / 2);\\n        double median = (*mid + *prev(mid, (k % 2) ^ 1)) / 2.0;\\n        ans.push_back(median);\\n        for(int i = k; i < n; i++){\\n            window.insert(nums[i]);\\n            if(nums[i] < *mid) mid = prev(mid);\\n            if(nums[i - k] <= *mid) mid = next(mid);\\n            window.erase(window.lower_bound(nums[i - k]));\\n            median = (*mid + *prev(mid, (k % 2) ^ 1)) / 2.0;\\n            ans.push_back(median);\\n        }       \\n        return ans;   \\n    }\\n};\\n```\n```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        multiset<long> low, high;\\n        vector<double> ans;\\n        REP(i, n){\\n            if(i >= k){\\n                if(nums[i - k] <= *low.rbegin()) low.erase(low.find(nums[i - k]));\\n                else high.erase(high.find(nums[i - k]));\\n            }\\n            if(low.empty() || (!low.empty() && nums[i] <= *low.rbegin())) low.insert(nums[i]);\\n            else high.insert(nums[i]);\\n            \\n            while(!low.empty() && !high.empty() && *low.rbegin() > *high.begin()){\\n                high.insert(*low.rbegin());\\n                low.erase(prev(low.end()));\\n                low.insert(*high.begin());\\n                high.erase(high.begin());\\n            }\\n            while(!high.empty() && low.size() < high.size()){\\n                low.insert(*high.begin());\\n                high.erase(high.begin());\\n            }\\n            while(!low.empty() && low.size() > high.size() + 1){\\n                high.insert(*low.rbegin());\\n                low.erase(prev(low.end()));\\n            }\\n            \\n            if(i >= k - 1){\\n                if(k % 2 == 0) ans.push_back((*low.rbegin() + *high.begin()) / 2.0);\\n                else ans.push_back(*low.rbegin());\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```\n```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\nprivate:\\n    priority_queue<long> low;\\n    priority_queue<long, vector<long>, greater<long>> high;\\n    unordered_map<long, int> removal_cnt;\\n    int balance;\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        if(k == 1) return vector<double>(ALL(nums));\\n        balance = 0;\\n        vector<double> ans;\\n        REP(i, k){\\n            low.push(nums[i]);\\n            balance++;\\n        }\\n        while(!low.empty() && balance > 1){\\n            high.push(low.top());\\n            low.pop();\\n            balance -= 2;\\n        }\\n        //balance = 0, 1\\n        if(k % 2 == 0) ans.push_back((low.top() + high.top()) / 2.0);\\n        else ans.push_back(low.top());\\n        \\n        for(int i = k; i < n; i++){\\n            removal_cnt[nums[i - k]]++;\\n            if(!low.empty() && low.top() >= nums[i - k]) balance--;\\n            else balance++;\\n            if(low.empty() || (!low.empty() && low.top() >= nums[i])){\\n                low.push(nums[i]);\\n                balance++;\\n            }else{\\n                high.push(nums[i]);\\n                balance--;\\n            }\\n            remove_invalid_elements();\\n            balancing();\\n            remove_invalid_elements();\\n            if(k % 2 == 0) ans.push_back((low.top() + high.top()) / 2.0);\\n            else ans.push_back(low.top());\\n        }\\n        return ans;\\n    }\\n    \\n    void remove_invalid_elements(){\\n        while(!low.empty() && removal_cnt[low.top()] > 0){\\n            removal_cnt[low.top()]--;\\n            low.pop();\\n        }\\n        while(!high.empty() && removal_cnt[high.top()] > 0){\\n            removal_cnt[high.top()]--;\\n            high.pop();\\n        }\\n        return;\\n    }\\n    \\n    void balancing(){\\n        while(!high.empty() && balance < 0){\\n            if(removal_cnt[high.top()] > 0){\\n                removal_cnt[high.top()]--;\\n                high.pop();\\n                continue;\\n            }\\n            low.push(high.top());\\n            high.pop();\\n            balance += 2;\\n        }\\n        while(!low.empty() && balance > 1){\\n            if(removal_cnt[low.top()] > 0){\\n                removal_cnt[low.top()]--;\\n                low.pop();\\n                continue;\\n            }\\n            high.push(low.top());\\n            low.pop();\\n            balance -= 2;\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983722,
                "title": "java-solution-using-sliding-window-and-two-heaps-explained",
                "content": "- The max heap will keep lesser half of current subarray\\n- The min heap will keep greater half of current subarray\\n- Inserting and Removing logic: We insert/remove from max heap if the element is equal to or less than the peek value of max heap. Otherwise insert/remove from min heap.\\n- Rebalancing logic : Max heap needs to have just one more element than min heap or they need to have same number of elements\\n- Getting median logic: If the two heaps have same # of elements, median is division of the peek values from min heap and max heap. Otherwise it is the peek value from Max Heap.\\n\\n- TC: O (n * k) because we iterate through n values of the array and each time we iterate we are performing a remove/add from heap which is O(log (k/2 +1)) since at most there are k/2 + 1 elements in each heap but we are also removing a specified value from the heaps so there\\'s also a O(k) to search through the heap. \\n- SC: O (log k) due to the two heaps maintaining at most k values \\n\\n```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        //length of resulting array, just think about how long it should be by writing out array and indexing \\n        double[] res = new double[nums.length-k+1];\\n        int resIdx = 0;\\n        int l = 0; \\n        for(int r=0; r<nums.length; r++) {\\n            \\n            if(maxHeap.size() == 0 || nums[r] <= maxHeap.peek()) {\\n                maxHeap.add(nums[r]);\\n            } else {\\n                minHeap.add(nums[r]);\\n            }\\n            //we rebalance heaps anytime we add to the heap or remove from the heap\\n            rebalanceHeaps();\\n\\t\\t\\t//this is when our right pointer first has k values and will continue to have k values until end of loop\\n            if(r-k+1 >= 0) {\\n                \\n                if(maxHeap.size() == minHeap.size()) {\\n                    //(maxHeap.peek() + minHeap.peek())/2.0 will cause an integer overflow with maximum integer numbers\\n                    res[resIdx] = maxHeap.peek()/2.0 + minHeap.peek()/2.0;\\n                } else {\\n                    res[resIdx] = maxHeap.peek();\\n                }\\n                resIdx++;\\n                \\n                //element to remove from sliding window will start at 0 and increment by 1\\n                int elementToBeRemoved = nums[l];\\n                \\n                //removing logic same as adding logic\\n                if (elementToBeRemoved <= maxHeap.peek()) {\\n                  maxHeap.remove(elementToBeRemoved);\\n                } else {\\n                  minHeap.remove(elementToBeRemoved);\\n                }\\n                l++;\\n                //again rebalance the heaps since we removed\\n                rebalanceHeaps();\\n            \\n            }\\n        }\\n        return res; \\n    }\\n    \\n    public void rebalanceHeaps() {\\n        \\n        if (maxHeap.size() > minHeap.size() + 1)\\n          minHeap.add(maxHeap.poll());\\n        else if (maxHeap.size() < minHeap.size())\\n          maxHeap.add(minHeap.poll());\\n    }\\n    \\n    \\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        //length of resulting array, just think about how long it should be by writing out array and indexing \\n        double[] res = new double[nums.length-k+1];\\n        int resIdx = 0;\\n        int l = 0; \\n        for(int r=0; r<nums.length; r++) {\\n            \\n            if(maxHeap.size() == 0 || nums[r] <= maxHeap.peek()) {\\n                maxHeap.add(nums[r]);\\n            } else {\\n                minHeap.add(nums[r]);\\n            }\\n            //we rebalance heaps anytime we add to the heap or remove from the heap\\n            rebalanceHeaps();\\n\\t\\t\\t//this is when our right pointer first has k values and will continue to have k values until end of loop\\n            if(r-k+1 >= 0) {\\n                \\n                if(maxHeap.size() == minHeap.size()) {\\n                    //(maxHeap.peek() + minHeap.peek())/2.0 will cause an integer overflow with maximum integer numbers\\n                    res[resIdx] = maxHeap.peek()/2.0 + minHeap.peek()/2.0;\\n                } else {\\n                    res[resIdx] = maxHeap.peek();\\n                }\\n                resIdx++;\\n                \\n                //element to remove from sliding window will start at 0 and increment by 1\\n                int elementToBeRemoved = nums[l];\\n                \\n                //removing logic same as adding logic\\n                if (elementToBeRemoved <= maxHeap.peek()) {\\n                  maxHeap.remove(elementToBeRemoved);\\n                } else {\\n                  minHeap.remove(elementToBeRemoved);\\n                }\\n                l++;\\n                //again rebalance the heaps since we removed\\n                rebalanceHeaps();\\n            \\n            }\\n        }\\n        return res; \\n    }\\n    \\n    public void rebalanceHeaps() {\\n        \\n        if (maxHeap.size() > minHeap.size() + 1)\\n          minHeap.add(maxHeap.poll());\\n        else if (maxHeap.size() < minHeap.size())\\n          maxHeap.add(minHeap.poll());\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968816,
                "title": "c-short-code-o-n-logn-using-two-set-pair-int-int",
                "content": "```\\nvector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n    set<pair<int,int>> big;\\n    set<pair<int,int>, greater<pair<int,int>>> small;\\n    \\n    auto insert = [&](pair<int,int> a) {\\n        if (small.size() > big.size()) {\\n            small.insert(a);\\n            big.insert(*small.begin());\\n            small.erase(small.begin());\\n        } else {\\n            big.insert(a);\\n            small.insert(*big.begin());\\n            big.erase(big.begin());\\n        }\\n    };\\n    auto getmedian = [&]() {\\n        return (k % 2) ? small.begin()->first : \\n        (0.0 + small.begin()->first + big.begin()->first) / 2;\\n    };\\n     \\n    vector<double> res;\\n    \\n    for (int i = 0; i < k; i++) {\\n        insert({nums[i], i});\\n    }\\n    res.push_back(getmedian());\\n    \\n    for (int i = 0; i+k < nums.size(); i++) {\\n        small.erase({nums[i], i});\\n        big.erase({nums[i], i});\\n        \\n        insert({nums[i+k], i+k});\\n        res.push_back(getmedian());\\n    }\\n    return res;\\n}",
                "solutionTags": [],
                "code": "```\\nvector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n    set<pair<int,int>> big;\\n    set<pair<int,int>, greater<pair<int,int>>> small;\\n    \\n    auto insert = [&](pair<int,int> a) {\\n        if (small.size() > big.size()) {\\n            small.insert(a);\\n            big.insert(*small.begin());\\n            small.erase(small.begin());\\n        } else {\\n            big.insert(a);\\n            small.insert(*big.begin());\\n            big.erase(big.begin());\\n        }\\n    };\\n    auto getmedian = [&]() {\\n        return (k % 2) ? small.begin()->first : \\n        (0.0 + small.begin()->first + big.begin()->first) / 2;\\n    };\\n     \\n    vector<double> res;\\n    \\n    for (int i = 0; i < k; i++) {\\n        insert({nums[i], i});\\n    }\\n    res.push_back(getmedian());\\n    \\n    for (int i = 0; i+k < nums.size(); i++) {\\n        small.erase({nums[i], i});\\n        big.erase({nums[i], i});\\n        \\n        insert({nums[i+k], i+k});\\n        res.push_back(getmedian());\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 960793,
                "title": "concise-java-solution-using-binary-search",
                "content": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        int n = nums.length;\\n        double[] result = new double[n-k+1];\\n        List<Integer> list = new ArrayList<>(); // window list\\n        boolean isEven = (k % 2 == 0);\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i >= k)\\n            {\\n                // Delete the head number from the window list\\n                int delPos = binarySearch(list, 0, list.size()-1, nums[i-k]);\\n                list.remove(delPos);\\n            }\\n            \\n            // Add the new number to the window list\\n            int addPos = binarySearch(list, 0, list.size()-1, nums[i]);\\n            list.add(addPos, nums[i]);\\n            \\n            if (i >= k-1)\\n            {\\n                if (isEven)\\n                    result[i-k+1] = ((double)list.get(k/2-1) + (double)list.get(k/2)) / 2.0;\\n                else\\n                    result[i-k+1] = (double)list.get(k/2);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int binarySearch(List<Integer> list, int left, int right, int target)\\n    {\\n        if (left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            int num = list.get(mid);\\n            \\n            if (num == target)\\n                return mid;\\n            else if (num < target)\\n                return binarySearch(list, mid+1, right, target);\\n            else\\n                return binarySearch(list, left, mid-1, target);\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        int n = nums.length;\\n        double[] result = new double[n-k+1];\\n        List<Integer> list = new ArrayList<>(); // window list\\n        boolean isEven = (k % 2 == 0);\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i >= k)\\n            {\\n                // Delete the head number from the window list\\n                int delPos = binarySearch(list, 0, list.size()-1, nums[i-k]);\\n                list.remove(delPos);\\n            }\\n            \\n            // Add the new number to the window list\\n            int addPos = binarySearch(list, 0, list.size()-1, nums[i]);\\n            list.add(addPos, nums[i]);\\n            \\n            if (i >= k-1)\\n            {\\n                if (isEven)\\n                    result[i-k+1] = ((double)list.get(k/2-1) + (double)list.get(k/2)) / 2.0;\\n                else\\n                    result[i-k+1] = (double)list.get(k/2);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int binarySearch(List<Integer> list, int left, int right, int target)\\n    {\\n        if (left <= right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            int num = list.get(mid);\\n            \\n            if (num == target)\\n                return mid;\\n            else if (num < target)\\n                return binarySearch(list, mid+1, right, target);\\n            else\\n                return binarySearch(list, left, mid-1, target);\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903924,
                "title": "two-heaps-92-python-solution-o-nlogk",
                "content": "There are many two heap solutions. This one is relatively fast because it uses `heappushpop` to combine pushing and popping.\\n\\nI found the explanations of the other two heap solutions a bit lacking.\\n\\nAll of them explain why the lower heap needs to store the negative values. But the rest of the logic is less clearly explained.\\n\\nFor me there are three logical components in this solution:\\n\\n**(A) Keeping the number of in-window entries in each heap constant**\\n\\nIn our case the first heap contains k//2 in-window entries, the second contains k//2 + k%2 entries (1 more entry in case k is odd).\\n\\n**(B) Making sure the monotonity is preserved**\\n\\nThis means that the lower heap should not have entries that have a higher value than the top of the upper heap and, vice versa, the upper heap does not have entries that have lower values than the top of the lower heap.\\n\\n**(C) Making sure that the tops of the heaps are not out-of-window entries.**\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if k == 1: return nums\\n        d,m = divmod(k,2)\\n        r,h1,h2,e2 = [],[],[],set()\\n\\t\\t#We split the first k entries evenly.\\n\\t\\t#We chose the upper heap to be somewhat larger if k is odd - but the solution easily can be modified for the opposite case (lower heap a bit larger)\\n        for i,v in enumerate(nums[:k]): \\n            heapq.heappush(h2,(v,i))\\n            e2.add(i) #this is the list of the entries contained in h2. If an entry is not in e2 it must be in h1.\\n        for i in range(d):\\n            curr = heapq.heappop(h2)\\n            heapq.heappush(h1,(-curr[0], curr[1]))\\n            e2.remove(curr[1])\\n        if m: r.append(h2[0][0])\\n        else: r.append((-h1[0][0] + h2[0][0])/2)\\n\\t\\t#For the rest of the code we need to make sure that the number of in-window entries in each heap stays constant\\n        for i,v in enumerate(nums[k:]):\\n            if i in e2: \\n\\t\\t\\t    #The new out-of-window entry is in h2. \\n\\t\\t\\t\\t#Thus, to keep the number of in-windows entries in h2 constant we need to put the new in-window entry in h2\\n\\t\\t\\t\\t#However, in order to make sure the monotonity is preserved we need to first put the new entry in h1 and then pop the top of h1 into h2\\n                curr = heapq.heappushpop(h1, (-v,i+k))\\n                heapq.heappush(h2,(-curr[0], curr[1]))\\n                e2.add(curr[1])\\n            else:\\n\\t\\t\\t    #The new out-of-window entry is in h1. \\n\\t\\t\\t\\t#Therefore, in order to keep the number of in-window entries in h1 constant we need to add the new in-window entry to h1.\\n\\t\\t\\t\\t#However, in order to make sure the monotonity is preserved we need to first put the new entry in h2 and then pop the top of h2 into h1\\n                curr = heapq.heappushpop(h2,(v, i+k))\\n                e2.add(i+k)\\n                e2.remove(curr[1])\\n                heapq.heappush(h1, (-curr[0], curr[1]))\\n\\t\\t\\t#We need to make sure that both tops are not out-of-window:\\n            while h1 and h1[0][1] <= i: heapq.heappop(h1)\\n            while h2 and h2[0][1] <= i: heapq.heappop(h2)\\n            if m: r.append(h2[0][0])\\n            else: r.append((-h1[0][0] + h2[0][0])/2)\\n        return r\\n```\\n\\nI ran this solution twice and both times it took 116 ms - faster than 92.63% of the Python solutions.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if k == 1: return nums\\n        d,m = divmod(k,2)\\n        r,h1,h2,e2 = [],[],[],set()\\n\\t\\t#We split the first k entries evenly.\\n\\t\\t#We chose the upper heap to be somewhat larger if k is odd - but the solution easily can be modified for the opposite case (lower heap a bit larger)\\n        for i,v in enumerate(nums[:k]): \\n            heapq.heappush(h2,(v,i))\\n            e2.add(i) #this is the list of the entries contained in h2. If an entry is not in e2 it must be in h1.\\n        for i in range(d):\\n            curr = heapq.heappop(h2)\\n            heapq.heappush(h1,(-curr[0], curr[1]))\\n            e2.remove(curr[1])\\n        if m: r.append(h2[0][0])\\n        else: r.append((-h1[0][0] + h2[0][0])/2)\\n\\t\\t#For the rest of the code we need to make sure that the number of in-window entries in each heap stays constant\\n        for i,v in enumerate(nums[k:]):\\n            if i in e2: \\n\\t\\t\\t    #The new out-of-window entry is in h2. \\n\\t\\t\\t\\t#Thus, to keep the number of in-windows entries in h2 constant we need to put the new in-window entry in h2\\n\\t\\t\\t\\t#However, in order to make sure the monotonity is preserved we need to first put the new entry in h1 and then pop the top of h1 into h2\\n                curr = heapq.heappushpop(h1, (-v,i+k))\\n                heapq.heappush(h2,(-curr[0], curr[1]))\\n                e2.add(curr[1])\\n            else:\\n\\t\\t\\t    #The new out-of-window entry is in h1. \\n\\t\\t\\t\\t#Therefore, in order to keep the number of in-window entries in h1 constant we need to add the new in-window entry to h1.\\n\\t\\t\\t\\t#However, in order to make sure the monotonity is preserved we need to first put the new entry in h2 and then pop the top of h2 into h1\\n                curr = heapq.heappushpop(h2,(v, i+k))\\n                e2.add(i+k)\\n                e2.remove(curr[1])\\n                heapq.heappush(h1, (-curr[0], curr[1]))\\n\\t\\t\\t#We need to make sure that both tops are not out-of-window:\\n            while h1 and h1[0][1] <= i: heapq.heappop(h1)\\n            while h2 and h2[0][1] <= i: heapq.heappop(h2)\\n            if m: r.append(h2[0][0])\\n            else: r.append((-h1[0][0] + h2[0][0])/2)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902814,
                "title": "scala-two-treeset-solution",
                "content": "```\\nimport scala.collection.mutable\\n\\nobject SlidingWindowMedian {\\n  def medianSlidingWindow(nums: Array[Int], k: Int): Array[Double] = {\\n    val maxHeap = mutable.TreeSet.empty[Int](Ordering[(Int, Int)].on(x => (nums(x), x)))\\n    val minHeap = mutable.TreeSet.empty[Int](Ordering[(Int, Int)].on((x: Int) => (nums(x), x)).reverse)\\n    nums.indices\\n      .foldLeft(List.empty[Double]) {\\n        case (acc, i) =>\\n          addNum(i, maxHeap, minHeap)\\n          if (maxHeap.size + minHeap.size == k) {\\n            val newAcc = acc :+ findMedian(nums, maxHeap, minHeap)\\n            slideTheWindow(acc.size, maxHeap, minHeap)\\n            newAcc\\n          } else {\\n            acc\\n          }\\n      }\\n      .toArray\\n  }\\n\\n  def addNum(num: Int, maxHeap: mutable.TreeSet[Int], minHeap: mutable.TreeSet[Int]) {\\n    maxHeap += num\\n    minHeap += maxHeap.head\\n    maxHeap -= maxHeap.head\\n    if (maxHeap.size < minHeap.size) {\\n      maxHeap += minHeap.head\\n      minHeap -= minHeap.head\\n    }\\n  }\\n\\n  def findMedian(nums: Array[Int], maxHeap: mutable.TreeSet[Int], minHeap: mutable.TreeSet[Int]): Double = {\\n    if (minHeap.size == maxHeap.size)\\n      nums(minHeap.head) / 2.0 + nums(maxHeap.head) / 2.0\\n    else nums(maxHeap.head)\\n  }\\n\\n  def slideTheWindow(toRemove: Int, maxHeap: mutable.TreeSet[Int], minHeap: mutable.TreeSet[Int]): Unit = {\\n    if (!maxHeap.remove(toRemove)) {\\n      minHeap.remove(toRemove)\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport scala.collection.mutable\\n\\nobject SlidingWindowMedian {\\n  def medianSlidingWindow(nums: Array[Int], k: Int): Array[Double] = {\\n    val maxHeap = mutable.TreeSet.empty[Int](Ordering[(Int, Int)].on(x => (nums(x), x)))\\n    val minHeap = mutable.TreeSet.empty[Int](Ordering[(Int, Int)].on((x: Int) => (nums(x), x)).reverse)\\n    nums.indices\\n      .foldLeft(List.empty[Double]) {\\n        case (acc, i) =>\\n          addNum(i, maxHeap, minHeap)\\n          if (maxHeap.size + minHeap.size == k) {\\n            val newAcc = acc :+ findMedian(nums, maxHeap, minHeap)\\n            slideTheWindow(acc.size, maxHeap, minHeap)\\n            newAcc\\n          } else {\\n            acc\\n          }\\n      }\\n      .toArray\\n  }\\n\\n  def addNum(num: Int, maxHeap: mutable.TreeSet[Int], minHeap: mutable.TreeSet[Int]) {\\n    maxHeap += num\\n    minHeap += maxHeap.head\\n    maxHeap -= maxHeap.head\\n    if (maxHeap.size < minHeap.size) {\\n      maxHeap += minHeap.head\\n      minHeap -= minHeap.head\\n    }\\n  }\\n\\n  def findMedian(nums: Array[Int], maxHeap: mutable.TreeSet[Int], minHeap: mutable.TreeSet[Int]): Double = {\\n    if (minHeap.size == maxHeap.size)\\n      nums(minHeap.head) / 2.0 + nums(maxHeap.head) / 2.0\\n    else nums(maxHeap.head)\\n  }\\n\\n  def slideTheWindow(toRemove: Int, maxHeap: mutable.TreeSet[Int], minHeap: mutable.TreeSet[Int]): Unit = {\\n    if (!maxHeap.remove(toRemove)) {\\n      minHeap.remove(toRemove)\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 839357,
                "title": "c-using-binary-search",
                "content": "```csharp\\npublic double[] MedianSlidingWindow(int[] nums, int k) \\n{\\n\\tList<int> window = new List<int>();\\n\\tList<double> result = new List<double>();\\n\\n\\tfor(int i = 0 ; i < nums.Length; i++)\\n\\t{\\n\\t\\tint index = window.BinarySearch(nums[i]);\\n\\t\\tif(index < 0)\\n\\t\\t{\\n\\t\\t\\tindex = ~index;\\n\\t\\t}\\n\\n\\t\\twindow.Insert(index, nums[i]);\\n\\n\\t\\tif(i >= k - 1)\\n\\t\\t{\\n\\t\\t\\tif(i >= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint removeIndex = window.BinarySearch(nums[i - k]);\\n\\t\\t\\t\\twindow.RemoveAt(removeIndex);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(k % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.Add(Math.Round((window[k/2 - 1] + window[k/2] * 1L)/ 2d, 1));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.Add(window[k/2]);\\n\\t\\t\\t}\\n\\t\\t}            \\n\\t}\\n\\n\\treturn result.ToArray();\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic double[] MedianSlidingWindow(int[] nums, int k) \\n{\\n\\tList<int> window = new List<int>();\\n\\tList<double> result = new List<double>();\\n\\n\\tfor(int i = 0 ; i < nums.Length; i++)\\n\\t{\\n\\t\\tint index = window.BinarySearch(nums[i]);\\n\\t\\tif(index < 0)\\n\\t\\t{\\n\\t\\t\\tindex = ~index;\\n\\t\\t}\\n\\n\\t\\twindow.Insert(index, nums[i]);\\n\\n\\t\\tif(i >= k - 1)\\n\\t\\t{\\n\\t\\t\\tif(i >= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint removeIndex = window.BinarySearch(nums[i - k]);\\n\\t\\t\\t\\twindow.RemoveAt(removeIndex);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(k % 2 == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.Add(Math.Round((window[k/2 - 1] + window[k/2] * 1L)/ 2d, 1));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.Add(window[k/2]);\\n\\t\\t\\t}\\n\\t\\t}            \\n\\t}\\n\\n\\treturn result.ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 761134,
                "title": "concept-used-from-medians-in-the-stream",
                "content": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        double []window = new double[n - k + 1];\\n        PriorityQueue<Long>low = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Long>high = new PriorityQueue<>();\\n        for(int i=0;i<k;i++){\\n            low.add((long)nums[i]);\\n            high.add(low.remove());\\n            if(high.size() > low.size()){\\n                low.add(high.remove());\\n            }\\n        }\\n        int counter = 0;\\n        if(low.size() == high.size()){\\n            window[counter++] = (low.peek() + high.peek())/2.0;\\n        }\\n        else{\\n            window[counter++] = low.peek() * 1.0;\\n        }\\n        for(int i=k;i<n;i++){\\n            long start = (long)nums[i - k];\\n            if(!low.remove(start)){\\n                high.remove(start);\\n            }\\n            low.add((long)nums[i]);\\n            high.add(low.remove());\\n            if(high.size() > low.size()){\\n                low.add(high.remove());\\n            }\\n            if(low.size() == high.size()){\\n                window[counter++] = (low.peek() + high.peek())/2.0;\\n            }\\n            else window[counter++] = low.peek()*1.0;\\n            \\n        }\\n        return window;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        double []window = new double[n - k + 1];\\n        PriorityQueue<Long>low = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Long>high = new PriorityQueue<>();\\n        for(int i=0;i<k;i++){\\n            low.add((long)nums[i]);\\n            high.add(low.remove());\\n            if(high.size() > low.size()){\\n                low.add(high.remove());\\n            }\\n        }\\n        int counter = 0;\\n        if(low.size() == high.size()){\\n            window[counter++] = (low.peek() + high.peek())/2.0;\\n        }\\n        else{\\n            window[counter++] = low.peek() * 1.0;\\n        }\\n        for(int i=k;i<n;i++){\\n            long start = (long)nums[i - k];\\n            if(!low.remove(start)){\\n                high.remove(start);\\n            }\\n            low.add((long)nums[i]);\\n            high.add(low.remove());\\n            if(high.size() > low.size()){\\n                low.add(high.remove());\\n            }\\n            if(low.size() == high.size()){\\n                window[counter++] = (low.peek() + high.peek())/2.0;\\n            }\\n            else window[counter++] = low.peek()*1.0;\\n            \\n        }\\n        return window;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723292,
                "title": "easy-to-understand-self-explainatory-algorithmic-solution-in-c",
                "content": "\\n//        sliding window using binary search for element removal and \\n//        using insertion sort for element addition\\n    \\n    double compute_median(vector<int> &window){\\n        if(window.size() & 1){\\n           // odd num of elements\\n           return window[(window.size()/2) ]; \\n        }else{\\n           // even number of elements \\n           return (1.0)*(1L*window[(window.size()/2) ] + 1L*window[(window.size()/2) -1])/2.0;\\n        }\\n    }    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> result;\\n        \\n        // prepare the initial window\\n        int s=0;\\n        int e=k-1;\\n        vector<int> window=vector(nums.begin()+s,nums.begin()+e+1);\\n        \\n        //sort the initial window\\n        sort(window.begin(),window.end());\\n        \\n        while(e<nums.size()){\\n            result.push_back(compute_median(window));\\n            \\n            // delete the element nums[s] from window  O(T)- O(log(k))\\n            // using binary search\\n            window.erase(lower_bound(window.begin(), window.end(), nums[s]));\\n            s++;\\n            e++;\\n            if(e<nums.size()){\\n                // binary search location to insert and insert element nums[e]\\n                // O(T) = O(k) however emperically it should perform better \\n                // \\n                window.insert(lower_bound(window.begin(), window.end(), nums[e]),nums[e]);\\n            }\\n        }\\n        return result;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n//        sliding window using binary search for element removal and \\n//        using insertion sort for element addition\\n    \\n    double compute_median(vector<int> &window){\\n        if(window.size() & 1){\\n           // odd num of elements\\n           return window[(window.size()/2) ]; \\n        }else{\\n           // even number of elements \\n           return (1.0)*(1L*window[(window.size()/2) ] + 1L*window[(window.size()/2) -1])/2.0;\\n        }\\n    }    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> result;\\n        \\n        // prepare the initial window\\n        int s=0;\\n        int e=k-1;\\n        vector<int> window=vector(nums.begin()+s,nums.begin()+e+1);\\n        \\n        //sort the initial window\\n        sort(window.begin(),window.end());\\n        \\n        while(e<nums.size()){\\n            result.push_back(compute_median(window));\\n            \\n            // delete the element nums[s] from window  O(T)- O(log(k))\\n            // using binary search\\n            window.erase(lower_bound(window.begin(), window.end(), nums[s]));\\n            s++;\\n            e++;\\n            if(e<nums.size()){\\n                // binary search location to insert and insert element nums[e]\\n                // O(T) = O(k) however emperically it should perform better \\n                // \\n                window.insert(lower_bound(window.begin(), window.end(), nums[e]),nums[e]);\\n            }\\n        }\\n        return result;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 669362,
                "title": "c-fenwick-tree-binary-indexed-tree-in-o-n-log-n",
                "content": "I noticed that the fenwick tree approaches (which I believe is more intuitive to me than messing with iterators as I have used BIT for many things related to this) often had a extra logN/logK factor due to binary searching for the value at which the sum function returns >= k / 2 (This is because each sum call on a BIT is O(logN); however, this can be optimized by doing a clever technique on the BIT to find the value in O(log N) (actually, my current implementation has the order function running 30 times always, but this can be optimized as I only initialized it to that to ensure that my jumps are large enough).\\n\\nMore information on this technique can be seen here: https://codeforces.com/blog/entry/61364 as I don\\'t believe I can do a better job explaining. Let me know if there are any questions regarding my code as I think there are some useful things to know (such as index compression + finding an ordered statistic utilizing a fenwick tree). Also let me know if there is anything I should change about my code writing style to make it more understandable.\\n\\nThe basic idea behind this solution is that if an element is present in the current window we\\'re looking at, then it would have a value of >= 1 in an array, whose prefix sum we update using a BIT (we update the position with a 1 to indicate that we\\'re adding it and with a -1 to indicate removal).\\n```\\nclass Solution {\\npublic:\\n    vector<int> bit;\\n    void update(int i, int v) {\\n        while(i < bit.size()) { // classic BIT update function\\n            bit[i] += v;\\n            i += i & -i;\\n        }\\n    }\\n    int order(int k) { // this function computes the position at which the prefix sum of the array is >= k (essentially lower_bound)\\n        int sum = 0;\\n        int pos = 0;\\n        for(int i = 30; i >= 0; i--) {\\n            if(pos + (1 << i) < bit.size() && sum + bit[pos + (1 << i)] < k) {\\n                pos += 1 << i;\\n                sum += bit[pos];\\n            }\\n        }\\n        return pos + 1;\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> ans;\\n        bit.resize(nums.size() + 10);\\n        int n = nums.size();\\n        unordered_map<int,int> m; // this holds the compression from array element -> a smaller index\\n        vector<int> rev; // holds the reverse operation, from compressed index -> actual value\\n        vector<int> temp(nums);\\n        sort(temp.begin(), temp.end()); // essentially, smaller values have smaller indices when compressed\\n        rev.push_back(0); // we\\'re starting with 1 as the base index as fenwick trees utilize 1 based indexing\\n        int cnt = 1; // starting value of index compression\\n        for(int i = 0; i < n; i++) {\\n            if(!m.count(temp[i])) {\\n                m[temp[i]] = cnt++;\\n                rev.push_back(temp[i]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < k; i++) { // initializing the first K elements into the \"window\"\\n            update(m[nums[i]], 1);\\n        }\\n        \\n        for(int i = 0; i < n - k + 1; i++) {\\n            double median = 0;\\n            if(k % 2 == 1) {\\n                median = rev[order(k / 2 + 1)]; // we just look for the position in the BIT with a sum >= k / 2 + 1 (because this is the middle)\\n            } else {\\n                int pos1 = order(k / 2); // we take the middle two values\\n                int pos2 = order(k / 2 + 1);\\n                median = (long long)rev[pos1] + rev[pos2];\\n                median /= 2;\\n            }\\n            ans.push_back(median);\\n            if(i < n - k) { // this means as we can move on, we should delete the left end of the window and add the next one\\n                update(m[nums[i]], -1);\\n                update(m[nums[i + k]], 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> bit;\\n    void update(int i, int v) {\\n        while(i < bit.size()) { // classic BIT update function\\n            bit[i] += v;\\n            i += i & -i;\\n        }\\n    }\\n    int order(int k) { // this function computes the position at which the prefix sum of the array is >= k (essentially lower_bound)\\n        int sum = 0;\\n        int pos = 0;\\n        for(int i = 30; i >= 0; i--) {\\n            if(pos + (1 << i) < bit.size() && sum + bit[pos + (1 << i)] < k) {\\n                pos += 1 << i;\\n                sum += bit[pos];\\n            }\\n        }\\n        return pos + 1;\\n    }\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> ans;\\n        bit.resize(nums.size() + 10);\\n        int n = nums.size();\\n        unordered_map<int,int> m; // this holds the compression from array element -> a smaller index\\n        vector<int> rev; // holds the reverse operation, from compressed index -> actual value\\n        vector<int> temp(nums);\\n        sort(temp.begin(), temp.end()); // essentially, smaller values have smaller indices when compressed\\n        rev.push_back(0); // we\\'re starting with 1 as the base index as fenwick trees utilize 1 based indexing\\n        int cnt = 1; // starting value of index compression\\n        for(int i = 0; i < n; i++) {\\n            if(!m.count(temp[i])) {\\n                m[temp[i]] = cnt++;\\n                rev.push_back(temp[i]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < k; i++) { // initializing the first K elements into the \"window\"\\n            update(m[nums[i]], 1);\\n        }\\n        \\n        for(int i = 0; i < n - k + 1; i++) {\\n            double median = 0;\\n            if(k % 2 == 1) {\\n                median = rev[order(k / 2 + 1)]; // we just look for the position in the BIT with a sum >= k / 2 + 1 (because this is the middle)\\n            } else {\\n                int pos1 = order(k / 2); // we take the middle two values\\n                int pos2 = order(k / 2 + 1);\\n                median = (long long)rev[pos1] + rev[pos2];\\n                median /= 2;\\n            }\\n            ans.push_back(median);\\n            if(i < n - k) { // this means as we can move on, we should delete the left end of the window and add the next one\\n                update(m[nums[i]], -1);\\n                update(m[nums[i + k]], 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634748,
                "title": "very-clean-java-solution-with-two-priority-queues",
                "content": "Moving the window overtime, let `maxHeap` maintains the smaller part of the array and let `minHeap` maintains the larger part of the subarray. Always keep the size of `maxHeap` same or one larger than the size of `minHeap`.\\n\\n```\\npublic class Solution {\\n    Queue<Integer> minHeap = new PriorityQueue<>();\\n    Queue<Integer> maxHeap = new PriorityQueue<>((x, y) -> (y.compareTo(x)));\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums.length - k + 1 <= 0) return new double[0];\\n        double[] result = new double[nums.length - k + 1];\\n        \\n        for (int i = 0; i <= nums.length; i++) {\\n            if (i >= k) {\\n                result[i - k] = getMedian();\\n                remove(nums[i - k]);\\n            }\\n            if (i < nums.length) add(nums[i]);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // no need to check the median here\\n    private void add(int num) {\\n        maxHeap.offer(num);\\n        minHeap.offer(maxHeap.poll());\\n        rebalance();\\n    }\\n\\n    private void remove(int num) {\\n        if (num <= getMedian()) {\\n            maxHeap.remove(num);\\n        } else {\\n            minHeap.remove(num);\\n        }\\n        rebalance();\\n    }\\n    \\n    private void rebalance() {\\n        if (maxHeap.size() < minHeap.size()) {\\n            maxHeap.offer(minHeap.poll());\\n        }\\n        if (minHeap.size() < maxHeap.size() - 1) {\\n            minHeap.offer(maxHeap.poll());\\n        }\\n    }\\n    \\n    private double getMedian() {\\n        return (maxHeap.size() > minHeap.size()) ? maxHeap.peek() : (maxHeap.peek() / 2.0 + minHeap.peek() / 2.0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    Queue<Integer> minHeap = new PriorityQueue<>();\\n    Queue<Integer> maxHeap = new PriorityQueue<>((x, y) -> (y.compareTo(x)));\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        if (nums.length - k + 1 <= 0) return new double[0];\\n        double[] result = new double[nums.length - k + 1];\\n        \\n        for (int i = 0; i <= nums.length; i++) {\\n            if (i >= k) {\\n                result[i - k] = getMedian();\\n                remove(nums[i - k]);\\n            }\\n            if (i < nums.length) add(nums[i]);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // no need to check the median here\\n    private void add(int num) {\\n        maxHeap.offer(num);\\n        minHeap.offer(maxHeap.poll());\\n        rebalance();\\n    }\\n\\n    private void remove(int num) {\\n        if (num <= getMedian()) {\\n            maxHeap.remove(num);\\n        } else {\\n            minHeap.remove(num);\\n        }\\n        rebalance();\\n    }\\n    \\n    private void rebalance() {\\n        if (maxHeap.size() < minHeap.size()) {\\n            maxHeap.offer(minHeap.poll());\\n        }\\n        if (minHeap.size() < maxHeap.size() - 1) {\\n            minHeap.offer(maxHeap.poll());\\n        }\\n    }\\n    \\n    private double getMedian() {\\n        return (maxHeap.size() > minHeap.size()) ? maxHeap.peek() : (maxHeap.peek() / 2.0 + minHeap.peek() / 2.0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513138,
                "title": "explanation-of-ruby-and-python-solutions-with-array-and-sortedlist",
                "content": "#### Static sliding window with sorted elements.\\n\\nIn Ruby this task solved by a window implemented as an array. The array was initally sorted, further when window slides by one element, passed element eliminates from sorted array by index search and delete by index. Than new element added to the array. Eventually the array is sorted and median calculated.\\n\\nIn Python solution  steps with searching index of passed element, delete it by index, adding new element, sorting array implemented by sortedcontainers library wich reprents SortedList datastrucure.\\n\\n[Thanks DrFirestream for his post.](https://leetcode.com/problems/sliding-window-median/discuss/475140/Python-SortedList-solution)\\n\\n![Sliding window with static size of k.](https://assets.leetcode.com/users/user9697n/image_1582050334.png)\\n\\nRuby:\\n```Ruby\\n# 480. Sliding Window Median\\n# https://leetcode.com/problems/sliding-window-median/\\n# Runtime: 1324 ms, faster than 50.00% of Ruby online submissions for Sliding Window Median.\\n# Memory Usage: 10.7 MB, less than 100.00% of Ruby online submissions for Sliding Window Median.\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Float[]}\\ndef median_sliding_window(nums, k)\\n    return [] if nums.empty?\\n    median = k/2\\n    median_right = k/2\\n    median_left = k/2-1\\n    odd = k.odd?\\n    answer = []\\n    \\n    window = nums[0...k].sort\\n    \\n    if odd\\n        answer.push(window[median].to_f)\\n    else\\n        answer.push((window[median_right]+window[median_left])/2.0)\\n    end\\n    \\n    (k...nums.size).each do |i|\\n        window.delete_at(window.find_index(nums[i-k]))\\n        window.unshift(nums[i])\\n        window.sort!\\n        if odd\\n            answer.push(window[median].to_f)\\n        else\\n            answer.push((window[median_right]+window[median_left])/2.0)\\n        end\\n    end\\n    \\n    answer\\nend\\n```\\n\\nPython 3:\\n```Python\\n\\'\\'\\'\\n480. Sliding Window Median\\nhttps://leetcode.com/problems/sliding-window-median/\\nRuntime: 176 ms, faster than 50.62% of Python3 online submissions for Sliding Window Median.\\nMemory Usage: 14.6 MB, less than 20.00% of Python3 online submissions for Sliding Window Median.\\n\\'\\'\\'\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if 0 == len(nums): return []\\n        median =  k//2\\n        median_right = k//2\\n        median_left = k//2 - 1\\n        odd = 1 == k%2\\n        answer = []\\n        window = SortedList(nums[:k])\\n        if odd:\\n            answer.append(window[median])\\n        else:\\n            answer.append((window[median_right]+window[median_left])/2)\\n        for i in range(k,len(nums)):\\n            exits = nums[i-k]\\n            enters = nums[i]\\n            window.discard(exits)\\n            window.add(enters)\\n            if odd:\\n                answer.append(window[median])\\n            else:\\n                answer.append((window[median_right]+window[median_left])/2)\\n        return answer\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Ruby"
                ],
                "code": "```Ruby\\n# 480. Sliding Window Median\\n# https://leetcode.com/problems/sliding-window-median/\\n# Runtime: 1324 ms, faster than 50.00% of Ruby online submissions for Sliding Window Median.\\n# Memory Usage: 10.7 MB, less than 100.00% of Ruby online submissions for Sliding Window Median.\\n# @param {Integer[]} nums\\n# @param {Integer} k\\n# @return {Float[]}\\ndef median_sliding_window(nums, k)\\n    return [] if nums.empty?\\n    median = k/2\\n    median_right = k/2\\n    median_left = k/2-1\\n    odd = k.odd?\\n    answer = []\\n    \\n    window = nums[0...k].sort\\n    \\n    if odd\\n        answer.push(window[median].to_f)\\n    else\\n        answer.push((window[median_right]+window[median_left])/2.0)\\n    end\\n    \\n    (k...nums.size).each do |i|\\n        window.delete_at(window.find_index(nums[i-k]))\\n        window.unshift(nums[i])\\n        window.sort!\\n        if odd\\n            answer.push(window[median].to_f)\\n        else\\n            answer.push((window[median_right]+window[median_left])/2.0)\\n        end\\n    end\\n    \\n    answer\\nend\\n```\n```Python\\n\\'\\'\\'\\n480. Sliding Window Median\\nhttps://leetcode.com/problems/sliding-window-median/\\nRuntime: 176 ms, faster than 50.62% of Python3 online submissions for Sliding Window Median.\\nMemory Usage: 14.6 MB, less than 20.00% of Python3 online submissions for Sliding Window Median.\\n\\'\\'\\'\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if 0 == len(nums): return []\\n        median =  k//2\\n        median_right = k//2\\n        median_left = k//2 - 1\\n        odd = 1 == k%2\\n        answer = []\\n        window = SortedList(nums[:k])\\n        if odd:\\n            answer.append(window[median])\\n        else:\\n            answer.append((window[median_right]+window[median_left])/2)\\n        for i in range(k,len(nums)):\\n            exits = nums[i-k]\\n            enters = nums[i]\\n            window.discard(exits)\\n            window.add(enters)\\n            if odd:\\n                answer.append(window[median])\\n            else:\\n                answer.append((window[median_right]+window[median_left])/2)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425564,
                "title": "java-39ms-solution-two-priorityqueues-add-and-remove",
                "content": "```\\nclass Solution {\\n    private Queue<Integer> minHeap, maxHeap;\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        minHeap = new PriorityQueue<>();\\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int j = 0; j < k; j++) {\\n            if(j == 0 || nums[j] <= maxHeap.peek()) {\\n                maxHeap.offer(nums[j]);\\n            }else {\\n                minHeap.offer(nums[j]);\\n            }\\n        }\\n        balance();\\n        double[] result = new double[nums.length - k + 1];\\n        int j = 0;\\n        result[j] = getMedianOfK(k);\\n        for(int i = k; i < nums.length; i++) {\\n            if(maxHeap.contains(nums[i-k])) {\\n                maxHeap.remove(nums[i-k]);\\n            } else {\\n                minHeap.remove(nums[i-k]);\\n            }\\n            \\n            if(maxHeap.isEmpty() || nums[i] <= maxHeap.peek()) {\\n                maxHeap.offer(nums[i]);\\n            }else {\\n                minHeap.offer(nums[i]);\\n            }\\n            balance();\\n            result[++j] = getMedianOfK(k);\\n        }\\n        return result;\\n    }\\n    private void balance() {\\n        while(maxHeap.size() < minHeap.size()) {\\n            maxHeap.offer(minHeap.poll());\\n        }\\n        while(minHeap.size() < maxHeap.size() - 1) {\\n            minHeap.offer(maxHeap.poll());\\n        }\\n    }\\n    private double getMedianOfK(int k) {\\n        if(k % 2 == 0) {\\n            double a1 = (double)maxHeap.peek();\\n            double a2 = (double)minHeap.peek();\\n            return (a1 + a2) / 2.0;\\n        }\\n        return (double)maxHeap.peek();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    private Queue<Integer> minHeap, maxHeap;\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        minHeap = new PriorityQueue<>();\\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int j = 0; j < k; j++) {\\n            if(j == 0 || nums[j] <= maxHeap.peek()) {\\n                maxHeap.offer(nums[j]);\\n            }else {\\n                minHeap.offer(nums[j]);\\n            }\\n        }\\n        balance();\\n        double[] result = new double[nums.length - k + 1];\\n        int j = 0;\\n        result[j] = getMedianOfK(k);\\n        for(int i = k; i < nums.length; i++) {\\n            if(maxHeap.contains(nums[i-k])) {\\n                maxHeap.remove(nums[i-k]);\\n            } else {\\n                minHeap.remove(nums[i-k]);\\n            }\\n            \\n            if(maxHeap.isEmpty() || nums[i] <= maxHeap.peek()) {\\n                maxHeap.offer(nums[i]);\\n            }else {\\n                minHeap.offer(nums[i]);\\n            }\\n            balance();\\n            result[++j] = getMedianOfK(k);\\n        }\\n        return result;\\n    }\\n    private void balance() {\\n        while(maxHeap.size() < minHeap.size()) {\\n            maxHeap.offer(minHeap.poll());\\n        }\\n        while(minHeap.size() < maxHeap.size() - 1) {\\n            minHeap.offer(maxHeap.poll());\\n        }\\n    }\\n    private double getMedianOfK(int k) {\\n        if(k % 2 == 0) {\\n            double a1 = (double)maxHeap.peek();\\n            double a2 = (double)minHeap.peek();\\n            return (a1 + a2) / 2.0;\\n        }\\n        return (double)maxHeap.peek();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365264,
                "title": "python-bisect-to-mimic-c-multiset",
                "content": "```\\n    def medianSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[float]\\n        \"\"\"\\n        import bisect\\n        left = []\\n        right = []\\n        result = []\\n\\n        for i, n in enumerate(nums):\\n            if i + 1 > k:\\n                pop_idx = i - k\\n                if nums[pop_idx] <= left[-1]:\\n                    pos = bisect.bisect_left(left, nums[pop_idx])\\n                    left.pop(pos)\\n                else:\\n                    pos = bisect.bisect_left(right, nums[pop_idx])\\n                    right.pop(pos)\\n\\n            if not left or n > left[-1]:\\n                bisect.insort(right, n)\\n            else:\\n                bisect.insort(left, n)\\n\\n            while len(left) > len(right) + 1:\\n                x = left.pop(-1)\\n                bisect.insort(right, x)\\n\\n            while len(right) > len(left):\\n                x = right.pop(0)\\n                bisect.insort(left, x)\\n\\n            if i + 1 >= k:\\n                if len(left) > len(right):\\n                    result.append(left[-1])\\n                else:\\n                    result.append((left[-1] + right[0]) / 2.0)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n    def medianSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[float]\\n        \"\"\"\\n        import bisect\\n        left = []\\n        right = []\\n        result = []\\n\\n        for i, n in enumerate(nums):\\n            if i + 1 > k:\\n                pop_idx = i - k\\n                if nums[pop_idx] <= left[-1]:\\n                    pos = bisect.bisect_left(left, nums[pop_idx])\\n                    left.pop(pos)\\n                else:\\n                    pos = bisect.bisect_left(right, nums[pop_idx])\\n                    right.pop(pos)\\n\\n            if not left or n > left[-1]:\\n                bisect.insort(right, n)\\n            else:\\n                bisect.insort(left, n)\\n\\n            while len(left) > len(right) + 1:\\n                x = left.pop(-1)\\n                bisect.insort(right, x)\\n\\n            while len(right) > len(left):\\n                x = right.pop(0)\\n                bisect.insort(left, x)\\n\\n            if i + 1 >= k:\\n                if len(left) > len(right):\\n                    result.append(left[-1])\\n                else:\\n                    result.append((left[-1] + right[0]) / 2.0)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 363244,
                "title": "javascript-short-clean-binary-search-with-splice-queue-100-88ms",
                "content": "```\\nclass Queue {\\n  constructor () { this.list = [] }\\n  size () { return this.list.length }\\n  removeNum (num) { this.list.splice(this.bs(num), 1) }\\n  addNum (num) { this.list.splice(this.bs(num), 0, num) }\\n\\n  bs (num) {\\n    let [l, r] = [0, this.size() - 1]\\n    while (l <= r) {\\n      const mid = Math.floor((l + r) / 2)\\n      this.list[mid] < num ? l = mid + 1 : r = mid - 1\\n    }\\n    return l\\n  }\\n\\n  getMedian () {\\n    const [n, half] = [this.size(), Math.floor(this.size() / 2)]\\n    return (n % 2 === 0) ? (this.list[half - 1] + this.list[half]) / 2 : this.list[half]\\n  }\\n}\\n\\nconst medianSlidingWindow = (nums, k) => {\\n  return nums.reduce(([res, queue], num, i) => {\\n    queue.addNum(num)\\n    if (queue.size() > k) queue.removeNum(nums[i - k])\\n    if (queue.size() === k) res.push(queue.getMedian())\\n    return [res, queue]\\n  }, [[], new Queue()])[0]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Queue {\\n  constructor () { this.list = [] }\\n  size () { return this.list.length }\\n  removeNum (num) { this.list.splice(this.bs(num), 1) }\\n  addNum (num) { this.list.splice(this.bs(num), 0, num) }\\n\\n  bs (num) {\\n    let [l, r] = [0, this.size() - 1]\\n    while (l <= r) {\\n      const mid = Math.floor((l + r) / 2)\\n      this.list[mid] < num ? l = mid + 1 : r = mid - 1\\n    }\\n    return l\\n  }\\n\\n  getMedian () {\\n    const [n, half] = [this.size(), Math.floor(this.size() / 2)]\\n    return (n % 2 === 0) ? (this.list[half - 1] + this.list[half]) / 2 : this.list[half]\\n  }\\n}\\n\\nconst medianSlidingWindow = (nums, k) => {\\n  return nums.reduce(([res, queue], num, i) => {\\n    queue.addNum(num)\\n    if (queue.size() > k) queue.removeNum(nums[i - k])\\n    if (queue.size() === k) res.push(queue.getMedian())\\n    return [res, queue]\\n  }, [[], new Queue()])[0]\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345460,
                "title": "simple-c-solution-using-2-heaps",
                "content": "```\\nclass Median {\\n    \\n    multiset<int> s1;\\n    multiset<int> s2;\\n    public:\\n    \\n    void insert(int n){\\n        \\n        if(s1.empty() && s2.empty()) s1.insert(n);\\n        else if(s1.empty()) s2.insert(n);\\n        else if(s2.empty()) s1.insert(n);\\n        else if( *s1.rbegin() >= n) s1.insert(n);\\n        else s2.insert(n);\\n        \\n        balance();\\n    }\\n    \\n    void remove(int n) {\\n        if(s1.find(n)!=s1.end()) s1.erase(s1.find(n));\\n        else s2.erase(s2.find(n));\\n        balance();\\n    }\\n    \\n    double median(){\\n        \\n        if(s1.size() > s2.size()) return *s1.rbegin();\\n        if(s1.size() < s2.size()) return *s2.begin();\\n        \\n        return (0.0 + *s1.rbegin() + *s2.begin())/2.0;\\n    }\\n    \\n    void balance() {\\n        \\n        \\n        \\n        if(s1.size() > 1 + s2.size()) {\\n            int v = *s1.rbegin();\\n            s2.insert(v);\\n            s1.erase(s1.find(v));\\n        }\\n        else if(s2.size() > 1 + s1.size() ) {\\n            int v = *s2.begin();\\n            s1.insert(v);\\n            s2.erase(s2.find(v));\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        Median m1;\\n        vector<double> ans;\\n        \\n        for(int i = 0; i < k; i++)\\n            m1.insert(nums[i]);\\n        \\n        ans.push_back(m1.median());\\n        \\n        \\n        for(int i = k; i < nums.size(); i++){\\n            m1.insert(nums[i]);\\n            m1.remove(nums[i-k]);\\n            ans.push_back(m1.median());\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Median {\\n    \\n    multiset<int> s1;\\n    multiset<int> s2;\\n    public:\\n    \\n    void insert(int n){\\n        \\n        if(s1.empty() && s2.empty()) s1.insert(n);\\n        else if(s1.empty()) s2.insert(n);\\n        else if(s2.empty()) s1.insert(n);\\n        else if( *s1.rbegin() >= n) s1.insert(n);\\n        else s2.insert(n);\\n        \\n        balance();\\n    }\\n    \\n    void remove(int n) {\\n        if(s1.find(n)!=s1.end()) s1.erase(s1.find(n));\\n        else s2.erase(s2.find(n));\\n        balance();\\n    }\\n    \\n    double median(){\\n        \\n        if(s1.size() > s2.size()) return *s1.rbegin();\\n        if(s1.size() < s2.size()) return *s2.begin();\\n        \\n        return (0.0 + *s1.rbegin() + *s2.begin())/2.0;\\n    }\\n    \\n    void balance() {\\n        \\n        \\n        \\n        if(s1.size() > 1 + s2.size()) {\\n            int v = *s1.rbegin();\\n            s2.insert(v);\\n            s1.erase(s1.find(v));\\n        }\\n        else if(s2.size() > 1 + s1.size() ) {\\n            int v = *s2.begin();\\n            s1.insert(v);\\n            s2.erase(s2.find(v));\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        Median m1;\\n        vector<double> ans;\\n        \\n        for(int i = 0; i < k; i++)\\n            m1.insert(nums[i]);\\n        \\n        ans.push_back(m1.median());\\n        \\n        \\n        for(int i = k; i < nums.size(); i++){\\n            m1.insert(nums[i]);\\n            m1.remove(nums[i-k]);\\n            ans.push_back(m1.median());\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343908,
                "title": "sliding-window-median-java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic double[] medianSlidingWindow(int[] nums, int k) {\\n\\t\\t\\tdouble[] result = new double[nums.length - k + 1];\\n\\t\\t\\tPriorityQueue<Integer> left = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\t\\tPriorityQueue<Integer> right = new PriorityQueue<>();\\n\\n\\t\\t\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\t\\t\\tif(left.size() <= right.size()) {\\n\\t\\t\\t\\t\\tright.add(nums[i]);\\n\\t\\t\\t\\t\\tleft.add(right.remove());\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tleft.add(nums[i]);\\n\\t\\t\\t\\t\\tright.add(left.remove());\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tif(left.size() + right.size() == k) {\\n\\t\\t\\t\\t\\tdouble median;\\n\\t\\t\\t\\t\\tif(left.size() == right.size()) {\\n\\t\\t\\t\\t\\t\\tmedian = (double) ((long)left.peek() + (long)right.peek()) / 2;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmedian = (double) left.peek();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tint start = i - k + 1;\\n\\t\\t\\t\\t\\tresult[start] = median;\\n\\t\\t\\t\\t\\tif(!left.remove(nums[start])) {\\n\\t\\t\\t\\t\\t\\tright.remove(nums[start]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic double[] medianSlidingWindow(int[] nums, int k) {\\n\\t\\t\\tdouble[] result = new double[nums.length - k + 1];\\n\\t\\t\\tPriorityQueue<Integer> left = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\t\\tPriorityQueue<Integer> right = new PriorityQueue<>();\\n\\n\\t\\t\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\t\\t\\tif(left.size() <= right.size()) {\\n\\t\\t\\t\\t\\tright.add(nums[i]);\\n\\t\\t\\t\\t\\tleft.add(right.remove());\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 343221,
                "title": "short-java-solution-with-thoughts-and-clear-comments",
                "content": "Similar solution from \"find median from data stream\". When we want to find median, we can use two priorityQueue. One is maxHeap and the other is minHeap. We put the smaller part in maxHeap and the larger part in minHeap, so the median will be in the maxHeap.peek or minHeap.peek.\\nTo make it convenient for us, I make maxHeap.size <= minHeap.size + 1, in this way, the median will be maxHeap.peek or (maxheap.peek + minheap.peek)\\nSince the number is unsorted, when a number comes, I put the number into maxHeap first and then move it to minHeap. In this way, the largest one in maxHeap will be moved to minHeap.(divide the array into two parts) If the maxHeap.size is less than minHeap.size, the we move the smallest one in minHeap to maxHeap.(maintain the maxHeap.size is longer)\\n\\n```\\n//maxHeap and minHeap to divide array into two parts\\nmaxHeap.add(nums[i]);\\nminHeap.add(maxHeap.poll());\\nif(minHeap.size() > maxHeap.size()) maxHeap.add(minHeap.poll());\\n```\\n\\ne.g. 1\\uFF0C5\\uFF0C2\\uFF0C7\\nmaxheap\\uFF1A1 --> minheap: 1 --> maxheap:1\\nmaxheap: 1,5 --> minheap: 5 (maxheap: 1)\\nmaxheap: 1,2 --> minheap: 5, 2 (maxheap: 1) --> maxheap: 1,2\\nmaxheap: 1,2,7 --> minheap: 5, 7 (maxheap: 1,2)\\n\\n\\n\\n\\n```\\nclass Solution {\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        double[] re = new double[nums.length - k + 1];\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i = 0;i<nums.length;i++){\\n\\t\\t\\t//put the number into right heap\\n            maxHeap.add(nums[i]);\\n            minHeap.add(maxHeap.poll());\\n            if(minHeap.size() > maxHeap.size()) maxHeap.add(minHeap.poll());\\n            \\n            if(i-k+1>=0){\\n                //find median\\n                if(maxHeap.size() == minHeap.size()) re[i-k+1] =  ( (double) maxHeap.peek()+ (double) minHeap.peek())/2.0;\\n                else re[i-k+1] = maxHeap.peek();\\n                \\n                //remove\\n                if(nums[i-k+1] > maxHeap.peek()) minHeap.remove(nums[i-k+1]);\\n                else maxHeap.remove(nums[i-k+1]);\\n            }\\n        }\\n        return re;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//maxHeap and minHeap to divide array into two parts\\nmaxHeap.add(nums[i]);\\nminHeap.add(maxHeap.poll());\\nif(minHeap.size() > maxHeap.size()) maxHeap.add(minHeap.poll());\\n```\n```\\nclass Solution {\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        double[] re = new double[nums.length - k + 1];\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i = 0;i<nums.length;i++){\\n\\t\\t\\t//put the number into right heap\\n            maxHeap.add(nums[i]);\\n            minHeap.add(maxHeap.poll());\\n            if(minHeap.size() > maxHeap.size()) maxHeap.add(minHeap.poll());\\n            \\n            if(i-k+1>=0){\\n                //find median\\n                if(maxHeap.size() == minHeap.size()) re[i-k+1] =  ( (double) maxHeap.peek()+ (double) minHeap.peek())/2.0;\\n                else re[i-k+1] = maxHeap.peek();\\n                \\n                //remove\\n                if(nums[i-k+1] > maxHeap.peek()) minHeap.remove(nums[i-k+1]);\\n                else maxHeap.remove(nums[i-k+1]);\\n            }\\n        }\\n        return re;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336884,
                "title": "c-using-list-binarysearch-api-practice-in-2019",
                "content": "It is the hard level algorithm. I like to share my study code and talk about why it is hard for me to solve the algorithm. \\n\\nI chose to study one of C# solutions, and then I put together the test case and figure out how it works. \\n\\nHere are highlights:\\n\\n1. Go through first k elements in the array and put into List<Double> by calling BinarySearch API to find index for next position; Therefore the list is sorted. \\n2. Once slide window size is k, remove left pointer, and then add median value into the list. \\n3. It is very good study code for me to learn how to build a sorted list using List API BinarySearch. \\n\\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _480_slide_window_median___study\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var numbers = new int[]{1,3,-1,-3,5,3,6,7}; \\n            var result = MedianSlidingWindow(numbers, 3);\\n\\n            // result should be [1.0,-1.0,-1.0,3.0,5.0,6.0]\\n        }\\n\\n        /// <summary>\\n        /// July 16, 2019\\n        /// study code:\\n        /// https://leetcode.com/problems/sliding-window-median/discuss/96357/C-BinarySearch-solution\\n        /// The idea is to insert the number into the index position found by binary search API.\\n        /// So the list is sorted in ascending order. \\n        /// </summary>\\n        /// <param name=\"numbers\"></param>\\n        /// <param name=\"k\"></param>\\n        /// <returns></returns>\\n        public static double[] MedianSlidingWindow(int[] numbers, int k)\\n        {\\n            var list = new List<double>();\\n\\n            if (numbers != null && numbers.Length > 0 && k > 0)\\n            {\\n                int half = (k >> 1);\\n\\n                int median = half + (k & 1) - 1;\\n\\n                var slideWindow = new List<double>();\\n\\n                // slide window maintenance - put into window with sorted order first\\n                // remove left pointer value\\n                for (int i = 0; i < numbers.Length; ++i)\\n                {\\n                    if (i >= k)\\n                    {\\n                        slideWindow.Remove(numbers[i - k]);\\n                    }\\n\\n                    int index = slideWindow.BinarySearch(numbers[i]);\\n                    if (index < 0)\\n                    {\\n                        index = ~index;\\n                    }\\n\\n                    slideWindow.Insert(index, numbers[i]);\\n\\n                    if (i >= k - 1)\\n                    {\\n                        list.Add(half == median ? slideWindow[half] : ((slideWindow[half] + slideWindow[median]) / 2));\\n                    }\\n                }\\n            }\\n\\n            return list.ToArray<double>();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _480_slide_window_median___study\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var numbers = new int[]{1,3,-1,-3,5,3,6,7}; \\n            var result = MedianSlidingWindow(numbers, 3);\\n\\n            // result should be [1.0,-1.0,-1.0,3.0,5.0,6.0]\\n        }\\n\\n        /// <summary>\\n        /// July 16, 2019\\n        /// study code:\\n        /// https://leetcode.com/problems/sliding-window-median/discuss/96357/C-BinarySearch-solution\\n        /// The idea is to insert the number into the index position found by binary search API.\\n        /// So the list is sorted in ascending order. \\n        /// </summary>\\n        /// <param name=\"numbers\"></param>\\n        /// <param name=\"k\"></param>\\n        /// <returns></returns>\\n        public static double[] MedianSlidingWindow(int[] numbers, int k)\\n        {\\n            var list = new List<double>();\\n\\n            if (numbers != null && numbers.Length > 0 && k > 0)\\n            {\\n                int half = (k >> 1);\\n\\n                int median = half + (k & 1) - 1;\\n\\n                var slideWindow = new List<double>();\\n\\n                // slide window maintenance - put into window with sorted order first\\n                // remove left pointer value\\n                for (int i = 0; i < numbers.Length; ++i)\\n                {\\n                    if (i >= k)\\n                    {\\n                        slideWindow.Remove(numbers[i - k]);\\n                    }\\n\\n                    int index = slideWindow.BinarySearch(numbers[i]);\\n                    if (index < 0)\\n                    {\\n                        index = ~index;\\n                    }\\n\\n                    slideWindow.Insert(index, numbers[i]);\\n\\n                    if (i >= k - 1)\\n                    {\\n                        list.Add(half == median ? slideWindow[half] : ((slideWindow[half] + slideWindow[median]) / 2));\\n                    }\\n                }\\n            }\\n\\n            return list.ToArray<double>();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129262,
                "title": "logical-thinking-with-clear-java-code",
                "content": "**Logical Thinking**\\nMedian is the middle value in an ordered integer list, so median will halve the list into `a bigger half and a smaller half`. If the size of the list is even, median is the mean of the two middle value, i.e., `the mean of the minimum of the bigger half and the maximum of the smaller half`. **PriorityQueue** is designed for the case that we need to find the minimum or the maximum of a collection from time to time.\\nSo we maintain `minPQ`, the bigger half, and `maxPQ`, the smaller half. And we decide to make the maxPQ larger if needed. The size of minPQ and maxPQ can only differ by 1, that is matained within the `addNumber()`.\\nTo avoid the Integer Overflow, we use `Long` rather than `Integer`.\\n\\n**Code**\\n```\\n    private static PriorityQueue<Long> minPQ;\\n    private static PriorityQueue<Long> maxPQ;\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        minPQ = new PriorityQueue<>(); // minPQ, pop min, which maintains bigger half\\n        maxPQ = new PriorityQueue<>(Collections.reverseOrder()); // maxPQ, pop max, which maintains smaller half\\n        double[] result = new double[nums.length - k + 1];\\n        \\n        int i = 0;\\n        while (i < nums.length) {                      \\n            \\n            if (i <= k - 1) {\\n                addNumber(nums[i]);\\n                if (i == k - 1)\\n                    result[i - k + 1] = getMedian();\\n                i++;\\n                continue;\\n            }\\n            \\n            if (!minPQ.isEmpty() && minPQ.contains((long)nums[i - k])) {\\n                minPQ.remove((long)(nums[i - k]));\\n            }\\n            else if (!maxPQ.isEmpty() && maxPQ.contains((long)nums[i - k])) {\\n                maxPQ.remove((long)(nums[i - k]));\\n            }\\n            \\n            addNumber(nums[i]);            \\n            result[i - k + 1] = getMedian();\\n            i++;           \\n        }\\n        \\n        return result;\\n    }\\n    \\n    private static double getMedian() {\\n        return (maxPQ.size() > minPQ.size()) ? maxPQ.peek() : ((minPQ.peek() + maxPQ.peek()) / 2.0);\\n    }\\n    \\n    private static void addNumber(long num) {\\n        maxPQ.add(num);  \\n        minPQ.add(maxPQ.remove()); \\n        if (minPQ.size() > maxPQ.size()) {\\n            maxPQ.add(minPQ.remove());\\n        }        \\n    }\\n```\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\n    private static PriorityQueue<Long> minPQ;\\n    private static PriorityQueue<Long> maxPQ;\\n    \\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        \\n        minPQ = new PriorityQueue<>(); // minPQ, pop min, which maintains bigger half\\n        maxPQ = new PriorityQueue<>(Collections.reverseOrder()); // maxPQ, pop max, which maintains smaller half\\n        double[] result = new double[nums.length - k + 1];\\n        \\n        int i = 0;\\n        while (i < nums.length) {                      \\n            \\n            if (i <= k - 1) {\\n                addNumber(nums[i]);\\n                if (i == k - 1)\\n                    result[i - k + 1] = getMedian();\\n                i++;\\n                continue;\\n            }\\n            \\n            if (!minPQ.isEmpty() && minPQ.contains((long)nums[i - k])) {\\n                minPQ.remove((long)(nums[i - k]));\\n            }\\n            else if (!maxPQ.isEmpty() && maxPQ.contains((long)nums[i - k])) {\\n                maxPQ.remove((long)(nums[i - k]));\\n            }\\n            \\n            addNumber(nums[i]);            \\n            result[i - k + 1] = getMedian();\\n            i++;           \\n        }\\n        \\n        return result;\\n    }\\n    \\n    private static double getMedian() {\\n        return (maxPQ.size() > minPQ.size()) ? maxPQ.peek() : ((minPQ.peek() + maxPQ.peek()) / 2.0);\\n    }\\n    \\n    private static void addNumber(long num) {\\n        maxPQ.add(num);  \\n        minPQ.add(maxPQ.remove()); \\n        if (minPQ.size() > maxPQ.size()) {\\n            maxPQ.add(minPQ.remove());\\n        }        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 96379,
                "title": "java-o-n-log-k-solution-with-a-wrapped-up-treemap",
                "content": "\\n\\n* Wrap up TreeMap into TreeMapDup to \\n   - hold duplicates\\n   - insertion/deletion/query min or max in log(K) \\n   - get total size in O(1)\\n* hold the data inside the window in 2 TreeMapDup left and right, maintain left.size >= right.size\\n* when data moving out and moving in, rebalance left and right to maintain left.size >= right.size\\n\\n```\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        double[] result = new double[n - k + 1];\\n\\n        TreeMapDup left = new TreeMapDup();\\n        TreeMapDup right = new TreeMapDup();\\n\\n        for (int i = 0; i < n; i++) {\\n            left.add(nums[i]);\\n            int leftMax = left.lastKey();\\n            left.remove(leftMax);\\n            right.add(leftMax);\\n            reBalance(left, right);\\n\\n            int l = i - k + 1;\\n            if (l < 0) {\\n                continue;\\n            }\\n\\n            result[l] = (double)left.lastKey();\\n            if (k % 2 == 0) {\\n                result[l] = (result[l] + (double)right.firstKey()) / 2.0;\\n            }\\n            int old = nums[l];\\n            if (!left.remove(old)) {\\n                right.remove(old);\\n            }\\n            reBalance(left, right);\\n        }\\n\\n        return result;\\n    }\\n\\n    private void reBalance(TreeMapDup left, TreeMapDup right) {\\n        if (left.size < right.size) {\\n            int rightMin = right.firstKey();\\n            right.remove(rightMin);\\n            left.add(rightMin);\\n        }\\n    }\\n\\n    class TreeMapDup {\\n        int size;\\n        private final TreeMap<Integer, Integer> treeMap;\\n        public TreeMapDup() {\\n            treeMap = new TreeMap<>();\\n            size = 0;\\n        }\\n\\n        int lastKey() {\\n            return treeMap.lastKey();\\n        }\\n\\n        int firstKey() {\\n            return treeMap.firstKey();\\n        }\\n\\n        void add(int key) {\\n            size++;\\n            treeMap.put(key, treeMap.getOrDefault(key, 0) + 1);\\n        }\\n\\n        boolean remove(int key) {\\n            if (!treeMap.containsKey(key)) {\\n                return false;\\n            }\\n\\n            size--;\\n            int size = treeMap.get(key);\\n            if (size == 1) {\\n                treeMap.remove(key);\\n            } else {\\n                treeMap.put(key, size - 1);\\n            }\\n\\n            return true;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        double[] result = new double[n - k + 1];\\n\\n        TreeMapDup left = new TreeMapDup();\\n        TreeMapDup right = new TreeMapDup();\\n\\n        for (int i = 0; i < n; i++) {\\n            left.add(nums[i]);\\n            int leftMax = left.lastKey();\\n            left.remove(leftMax);\\n            right.add(leftMax);\\n            reBalance(left, right);\\n\\n            int l = i - k + 1;\\n            if (l < 0) {\\n                continue;\\n            }\\n\\n            result[l] = (double)left.lastKey();\\n            if (k % 2 == 0) {\\n                result[l] = (result[l] + (double)right.firstKey()) / 2.0;\\n            }\\n            int old = nums[l];\\n            if (!left.remove(old)) {\\n                right.remove(old);\\n            }\\n            reBalance(left, right);\\n        }\\n\\n        return result;\\n    }\\n\\n    private void reBalance(TreeMapDup left, TreeMapDup right) {\\n        if (left.size < right.size) {\\n            int rightMin = right.firstKey();\\n            right.remove(rightMin);\\n            left.add(rightMin);\\n        }\\n    }\\n\\n    class TreeMapDup {\\n        int size;\\n        private final TreeMap<Integer, Integer> treeMap;\\n        public TreeMapDup() {\\n            treeMap = new TreeMap<>();\\n            size = 0;\\n        }\\n\\n        int lastKey() {\\n            return treeMap.lastKey();\\n        }\\n\\n        int firstKey() {\\n            return treeMap.firstKey();\\n        }\\n\\n        void add(int key) {\\n            size++;\\n            treeMap.put(key, treeMap.getOrDefault(key, 0) + 1);\\n        }\\n\\n        boolean remove(int key) {\\n            if (!treeMap.containsKey(key)) {\\n                return false;\\n            }\\n\\n            size--;\\n            int size = treeMap.get(key);\\n            if (size == 1) {\\n                treeMap.remove(key);\\n            } else {\\n                treeMap.put(key, size - 1);\\n            }\\n\\n            return true;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96391,
                "title": "summary-of-ideas-and-an-accepting-solution",
                "content": "**Solution**\\n\\n**Sliding Window Median** https://leetcode.com/problems/sliding-window-median/\\n\\n**Ideas**\\n* List to store the window : Maintain a sliding window and keep sorting it. O(NKLg(K))\\n* List to store the window: Maintain a sorted window. Add and remove elements from it to maintain sorted variant. O(NK).\\n* BST to store the window: Create a special BST where a node has size and frequency field. size refers to the number of nodes in its subtree. frequency is the number of occurences of the key. Then median is a rank() operation which is average case Log(K). Average case complexity: NKlog(K). Worst case complexity: O(NK).\\n* 2 Heaps to store the median: Online median algorithm can be used to tackle the incoming part of the stream. Removal can be lazy. Just store what needs to be removed in a hash-table. Check the top element of the heap to see if it is marked for removal before using it for median computation. O(N * lgN)\\n\\nhttps://discuss.leetcode.com/topic/74679/o-n-log-n-time-c-solution-using-two-heaps-and-a-hash-table\\nhttps://discuss.leetcode.com/topic/74634/easy-python-o-nk\\n\\n\\n**List to store the window: O((n-k) * klg(k)). TLE**\\n* Brute force simple slides across all windows and reports the minimum.\\n```\\nclass Solution(object):\\n    def medianSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[float]\\n        \"\"\"\\n        result = []\\n        for i in range(0, len(nums)-k+1):\\n            x = sorted(nums[i:i+k])\\n            if len(x) % 2 == 0:\\n                median = (x[(len(x)//2) - 1] + x[(len(x)//2)])/2.0\\n            else:\\n                median = x[len(x)//2]\\n            result.append(float(median))\\n        return result\\n```\\n\\n**List to : Sorted List with O(nk). Accepted.**\\n* Maintain a sorted window. Use remove and bisect.insort() modules.\\n```\\nfrom bisect import insort        \\nclass Solution(object):\\n    def get_median(self, x):\\n        N = len(x)\\n        median = (x[N//2 - 1] + x[N//2])/2. if N % 2 == 0 else x[N//2]/1.\\n        return median\\n    \\n    def medianSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[float]\\n        \"\"\"\\n        window = sorted(nums[:k])\\n        result = []\\n        result.append(self.get_median(window))\\n        for i in range(k,len(nums)):\\n            window.remove(nums[i-k])\\n            insort(window, nums[i])\\n            result.append(self.get_median(window))\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def medianSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[float]\\n        \"\"\"\\n        result = []\\n        for i in range(0, len(nums)-k+1):\\n            x = sorted(nums[i:i+k])\\n            if len(x) % 2 == 0:\\n                median = (x[(len(x)//2) - 1] + x[(len(x)//2)])/2.0\\n            else:\\n                median = x[len(x)//2]\\n            result.append(float(median))\\n        return result\\n```\n```\\nfrom bisect import insort        \\nclass Solution(object):\\n    def get_median(self, x):\\n        N = len(x)\\n        median = (x[N//2 - 1] + x[N//2])/2. if N % 2 == 0 else x[N//2]/1.\\n        return median\\n    \\n    def medianSlidingWindow(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[float]\\n        \"\"\"\\n        window = sorted(nums[:k])\\n        result = []\\n        result.append(self.get_median(window))\\n        for i in range(k,len(nums)):\\n            window.remove(nums[i-k])\\n            insort(window, nums[i])\\n            result.append(self.get_median(window))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 96403,
                "title": "c-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        multiset<long>st;\\n        vector<double>ans;\\n        int i = 0;\\n        while(i + 1 < k) st.insert(nums[i++]);\\n        for(;i < nums.size();i++)\\n        {\\n            st.insert(nums[i]);\\n            auto it1 = st.begin();\\n            auto it2 = st.begin();\\n            advance(it1, (k-1)/2);\\n            advance(it2, k/2);\\n            ans.push_back(double(*it1 + *it2)/2);\\n            st.erase(st.find(nums[i-k+1]));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        multiset<long>st;\\n        vector<double>ans;\\n        int i = 0;\\n        while(i + 1 < k) st.insert(nums[i++]);\\n        for(;i < nums.size();i++)\\n        {\\n            st.insert(nums[i]);\\n            auto it1 = st.begin();\\n            auto it2 = st.begin();\\n            advance(it1, (k-1)/2);\\n            advance(it2, k/2);\\n            ans.push_back(double(*it1 + *it2)/2);\\n            st.erase(st.find(nums[i-k+1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3816423,
                "title": "c-binary-search-sliding-window-warmup",
                "content": "July 25, 2023\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter nine month break, I started four weeks practice to prepare Meta phone screen. I choose to work on sliding window algorithms. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Binary search to find the position in the list to insert\\n2. Sliding window - size is k, removal - find the element using O(k) time, insert, using O(logk) time - using BinarySearch find the position to insert\\n3. Benefits of BinarySearch - no worry about index-out-of-range, index position is calculated, use bitwise operator ~\\n4. Bitwise operator ~ \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public double[] MedianSlidingWindow(int[] numbers, int k) {\\n        if (numbers == null || numbers.Length == 0 || k == 0)\\n            {\\n                return new double[0]; \\n            }\\n\\n            // Work on C# List, not array\\n            var list = new List<double>();\\n\\n\\n            int half = k >> 1;\\n            int median = half + (k & 1) - 1; // k = 1, median = 0; k = 2, median = 0; k = 3, median = 1\\n\\n            var slideWindow = new List<double>();\\n\\n            for (int i = 0; i < numbers.Length; i++)\\n            {\\n                if (i >= k)\\n                {\\n                    slideWindow.Remove(numbers[i - k]);\\n                }\\n\\n                int index = slideWindow.BinarySearch(numbers[i]);\\n\\n                if (index < 0)\\n                {\\n                    index = ~index;\\n                }\\n\\n                slideWindow.Insert(index, numbers[i]);\\n\\n                if (i >= k - 1)\\n                {\\n                    list.Add(half == median? slideWindow[half] : (slideWindow[half] + slideWindow[median])/2 ); \\n                }\\n            }\\n\\n            return list.ToArray<double>(); \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double[] MedianSlidingWindow(int[] numbers, int k) {\\n        if (numbers == null || numbers.Length == 0 || k == 0)\\n            {\\n                return new double[0]; \\n            }\\n\\n            // Work on C# List, not array\\n            var list = new List<double>();\\n\\n\\n            int half = k >> 1;\\n            int median = half + (k & 1) - 1; // k = 1, median = 0; k = 2, median = 0; k = 3, median = 1\\n\\n            var slideWindow = new List<double>();\\n\\n            for (int i = 0; i < numbers.Length; i++)\\n            {\\n                if (i >= k)\\n                {\\n                    slideWindow.Remove(numbers[i - k]);\\n                }\\n\\n                int index = slideWindow.BinarySearch(numbers[i]);\\n\\n                if (index < 0)\\n                {\\n                    index = ~index;\\n                }\\n\\n                slideWindow.Insert(index, numbers[i]);\\n\\n                if (i >= k - 1)\\n                {\\n                    list.Add(half == median? slideWindow[half] : (slideWindow[half] + slideWindow[median])/2 ); \\n                }\\n            }\\n\\n            return list.ToArray<double>(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675913,
                "title": "treap-solution-o-nlogk-time-o-k-space",
                "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Randomized"
                ],
                "code": "```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604123,
                "title": "c-code-with-explanation",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        //vector to store median        \\n        vector<double> median;\\n        //map to delete the elements that are to be removed from sliding window \\n        unordered_map<int,int> mp;\\n        //to store the element in heap in descending order\\n        priority_queue<int> maxHeap;\\n        //to store the element in heap in ascending order\\n        priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\n        //first insert the element upto the size of window in maxHeap\\n        for(int i=0;i<k;i++)\\n        {\\n            maxHeap.push(nums[i]);\\n        }\\n\\n        //Now to balance the size of maxHeap and minHeap, insert half elements in minHeap\\n        for(int i=0; i<k/2; i++)\\n        {\\n            minHeap.push(maxHeap.top());\\n            maxHeap.pop();\\n        }\\n\\n        //for rest of the elements\\n        for(int i=k; i<nums.size(); i++)\\n        {\\n\\n            if(k%2 != 0) //if k is odd\\n                median.push_back(maxHeap.top()*1.0);\\n            else  // if k is even\\n                median.push_back((maxHeap.top()*1.0 + minHeap.top()*1.0)/2);\\n\\n            //to remove previous element from sliding window and inserting new element and checking the balance of maxHeap and minHeap\\n            int p = nums[i-k], q = nums[i], balance = 0;\\n\\n            //if p is present in maxHeap\\n            if(p <= maxHeap.top())\\n            {\\n                balance--;\\n                if(p == maxHeap.top())\\n                {\\n                    maxHeap.pop();\\n                }\\n                else\\n                {\\n                    mp[p]++;\\n                }\\n            }\\n            else  //if p is present in minHeap\\n            {\\n                balance++;\\n                if(p == minHeap.top())\\n                {\\n                    minHeap.pop();\\n                }\\n                else\\n                {\\n                    mp[p]++;\\n                }\\n            }\\n\\n            //to insert q in maxHeap when q is smaller than top of the maxHeap\\n            if(!maxHeap.empty() && q<=maxHeap.top())\\n            {\\n                maxHeap.push(q);\\n                balance++;\\n            }\\n            else  //if q is greater the top of maxHeap then insert it into minHeap\\n            {\\n                minHeap.push(q);\\n                balance--;\\n            }\\n            \\n            //if balance > 0\\n            if(balance > 0)\\n            {\\n                minHeap.push(maxHeap.top());\\n                maxHeap.pop();\\n            }   //if balance < 0\\n            else if(balance < 0)\\n            {\\n                maxHeap.push(minHeap.top());\\n                minHeap.pop();\\n            }\\n\\n            //to delete last element present in heap and for that map is used\\n            while(!maxHeap.empty() && mp[maxHeap.top()])\\n            {\\n                mp[maxHeap.top()]--;\\n                maxHeap.pop();\\n            }\\n            while(!minHeap.empty() && mp[minHeap.top()])\\n            {\\n                mp[minHeap.top()]--;\\n                minHeap.pop();\\n            }\\n        }\\n        if(k%2 != 0)\\n            median.push_back(maxHeap.top()*1.0);\\n        else \\n            median.push_back((maxHeap.top()*1.0 + minHeap.top()*1.0)/2);\\n        return median;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        //vector to store median        \\n        vector<double> median;\\n        //map to delete the elements that are to be removed from sliding window \\n        unordered_map<int,int> mp;\\n        //to store the element in heap in descending order\\n        priority_queue<int> maxHeap;\\n        //to store the element in heap in ascending order\\n        priority_queue<int, vector<int>, greater<int>> minHeap;\\n\\n        //first insert the element upto the size of window in maxHeap\\n        for(int i=0;i<k;i++)\\n        {\\n            maxHeap.push(nums[i]);\\n        }\\n\\n        //Now to balance the size of maxHeap and minHeap, insert half elements in minHeap\\n        for(int i=0; i<k/2; i++)\\n        {\\n            minHeap.push(maxHeap.top());\\n            maxHeap.pop();\\n        }\\n\\n        //for rest of the elements\\n        for(int i=k; i<nums.size(); i++)\\n        {\\n\\n            if(k%2 != 0) //if k is odd\\n                median.push_back(maxHeap.top()*1.0);\\n            else  // if k is even\\n                median.push_back((maxHeap.top()*1.0 + minHeap.top()*1.0)/2);\\n\\n            //to remove previous element from sliding window and inserting new element and checking the balance of maxHeap and minHeap\\n            int p = nums[i-k], q = nums[i], balance = 0;\\n\\n            //if p is present in maxHeap\\n            if(p <= maxHeap.top())\\n            {\\n                balance--;\\n                if(p == maxHeap.top())\\n                {\\n                    maxHeap.pop();\\n                }\\n                else\\n                {\\n                    mp[p]++;\\n                }\\n            }\\n            else  //if p is present in minHeap\\n            {\\n                balance++;\\n                if(p == minHeap.top())\\n                {\\n                    minHeap.pop();\\n                }\\n                else\\n                {\\n                    mp[p]++;\\n                }\\n            }\\n\\n            //to insert q in maxHeap when q is smaller than top of the maxHeap\\n            if(!maxHeap.empty() && q<=maxHeap.top())\\n            {\\n                maxHeap.push(q);\\n                balance++;\\n            }\\n            else  //if q is greater the top of maxHeap then insert it into minHeap\\n            {\\n                minHeap.push(q);\\n                balance--;\\n            }\\n            \\n            //if balance > 0\\n            if(balance > 0)\\n            {\\n                minHeap.push(maxHeap.top());\\n                maxHeap.pop();\\n            }   //if balance < 0\\n            else if(balance < 0)\\n            {\\n                maxHeap.push(minHeap.top());\\n                minHeap.pop();\\n            }\\n\\n            //to delete last element present in heap and for that map is used\\n            while(!maxHeap.empty() && mp[maxHeap.top()])\\n            {\\n                mp[maxHeap.top()]--;\\n                maxHeap.pop();\\n            }\\n            while(!minHeap.empty() && mp[minHeap.top()])\\n            {\\n                mp[minHeap.top()]--;\\n                minHeap.pop();\\n            }\\n        }\\n        if(k%2 != 0)\\n            median.push_back(maxHeap.top()*1.0);\\n        else \\n            median.push_back((maxHeap.top()*1.0 + minHeap.top()*1.0)/2);\\n        return median;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515894,
                "title": "sliding-window-median-c",
                "content": "Intuition:\\nThe problem asks for the median of each sliding window of size k in an input array. One approach to solving this problem is to maintain a sorted list of the elements in the current window, and compute the median from this list. To slide the window, we remove the leftmost element and insert the rightmost element in its correct position in the list.\\n\\nApproach:\\nThe approach used in the code is as follows:\\n\\n1. Initialize an empty list with the first k elements of the input array, sorted in increasing order.\\n2. Compute the median of the first window and store it in the result array.\\n3. Slide the window one element at a time, removing the leftmost element and inserting the rightmost element in the list in its correct position.\\n4. Compute the median of the current window and store it in the result array.\\n\\nComplexity:\\nThe time and space complexity of the sliding window median algorithm depend on the size of the input array and the size of the sliding window. Let n be the length of the input array and k be the size of the sliding window.\\n\\nTime complexity: The time complexity of the algorithm is O(n log k), where the dominant factor is the time it takes to maintain the sorted list of size k. The insertion and removal of elements in the list take O(log k) time, and we do this n-k+1 times for each window, resulting in a total time complexity of O((n-k+1) log k).\\n\\nSpace complexity: The space complexity of the algorithm is O(k), which is the size of the sorted list we maintain. We also need O(n-k+1) space to store the result array, resulting in a total space complexity of O(n-k+1 + k) = O(n).\\n\\n# Code\\n```\\npublic class Solution {\\n    public double[] MedianSlidingWindow(int[] nums, int k) {\\n        int n = nums.Length;\\n        double[] res = new double[n - k + 1];\\n        List<int> list = new List<int>(nums.Take(k).OrderBy(x => x));\\n        res[0] = k % 2 == 0 ?\\n            ((double)list[k / 2 - 1] + (double)list[k / 2]) / 2 :\\n            (double)list[k / 2];\\n        for (int i = 1; i <= n - k; i++) {\\n            int left = nums[i - 1];\\n            int right = nums[i + k - 1];\\n            list.Remove(left);\\n            int j = list.BinarySearch(right);\\n            if (j < 0) j = ~j;\\n            list.Insert(j, right);\\n            res[i] = k % 2 == 0 ?\\n                ((double)list[k / 2 - 1] + (double)list[k / 2]) / 2 :\\n                (double)list[k / 2];\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public double[] MedianSlidingWindow(int[] nums, int k) {\\n        int n = nums.Length;\\n        double[] res = new double[n - k + 1];\\n        List<int> list = new List<int>(nums.Take(k).OrderBy(x => x));\\n        res[0] = k % 2 == 0 ?\\n            ((double)list[k / 2 - 1] + (double)list[k / 2]) / 2 :\\n            (double)list[k / 2];\\n        for (int i = 1; i <= n - k; i++) {\\n            int left = nums[i - 1];\\n            int right = nums[i + k - 1];\\n            list.Remove(left);\\n            int j = list.BinarySearch(right);\\n            if (j < 0) j = ~j;\\n            list.Insert(j, right);\\n            res[i] = k % 2 == 0 ?\\n                ((double)list[k / 2 - 1] + (double)list[k / 2]) / 2 :\\n                (double)list[k / 2];\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354570,
                "title": "n-log-n-over-killing-with-segment-tree-or-bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SegmentTree {\\n    private final int[] tree;\\n\\n    public SegmentTree(int n) {\\n        tree = new int[4 * n];\\n    }\\n\\n    public int getKthIndex(int idx, int start, int end, int k) {\\n        if (start == end) {\\n            return start;\\n        }\\n        else {\\n            int mid = (start + end) / 2;\\n            if (k <= tree[2 * idx + 1]) {\\n                return getKthIndex(2 * idx + 1, start, mid, k);\\n            }\\n            else {\\n                return getKthIndex(2 * idx + 2, mid + 1, end, k - tree[2 * idx + 1]);\\n            }\\n        }\\n    }\\n\\n    public void update(int idx, int start, int end, int id, int val) {\\n        if (start == end) {\\n            tree[idx] = val;\\n        }\\n        else {\\n            int mid = (start + end) / 2;\\n            if (id <= mid) {\\n                update(2 * idx + 1, start, mid, id, val);\\n            }\\n            else {\\n                update(2 * idx + 2, mid + 1, end, id, val);\\n            }\\n            tree[idx] = tree[2 * idx + 1] + tree[2 * idx + 2];\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] pairs = new int[n][2];\\n        int[] position = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            pairs[i][0] = nums[i];\\n            pairs[i][1] = i;\\n        }\\n        Arrays.sort(pairs, Comparator.comparingInt(o -> o[0]));\\n        for (int i = 0; i < n; i++) {\\n            position[pairs[i][1]] = i;\\n        }\\n        SegmentTree tree = new SegmentTree(n);\\n        for (int i = 0; i < k; i++) {\\n            tree.update(0, 0, n - 1, position[i], 1);\\n        }\\n        double[] medians = new double[n - k + 1];\\n        medians[0] = pairs[tree.getKthIndex(0, 0, n - 1, k / 2 + 1)][0];\\n        if (k % 2 == 0) {\\n            medians[0] += pairs[tree.getKthIndex(0, 0, n - 1, k / 2)][0];\\n        }\\n        for (int i = k; i < n; i++) {\\n            tree.update(0, 0, n - 1, position[i - k], 0);\\n            tree.update(0, 0, n - 1, position[i], 1);\\n            medians[i - k + 1] = pairs[tree.getKthIndex(0, 0, n - 1, k / 2 + 1)][0];\\n            if (k % 2 == 0) {\\n                medians[i - k + 1] += pairs[tree.getKthIndex(0, 0, n - 1, k / 2)][0];\\n            }\\n        }\\n        if (k % 2 == 0) {\\n            for (int i = 0; i < medians.length; i++) {\\n                medians[i] /= 2;\\n            }\\n        }\\n        return medians;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SegmentTree {\\n    private final int[] tree;\\n\\n    public SegmentTree(int n) {\\n        tree = new int[4 * n];\\n    }\\n\\n    public int getKthIndex(int idx, int start, int end, int k) {\\n        if (start == end) {\\n            return start;\\n        }\\n        else {\\n            int mid = (start + end) / 2;\\n            if (k <= tree[2 * idx + 1]) {\\n                return getKthIndex(2 * idx + 1, start, mid, k);\\n            }\\n            else {\\n                return getKthIndex(2 * idx + 2, mid + 1, end, k - tree[2 * idx + 1]);\\n            }\\n        }\\n    }\\n\\n    public void update(int idx, int start, int end, int id, int val) {\\n        if (start == end) {\\n            tree[idx] = val;\\n        }\\n        else {\\n            int mid = (start + end) / 2;\\n            if (id <= mid) {\\n                update(2 * idx + 1, start, mid, id, val);\\n            }\\n            else {\\n                update(2 * idx + 2, mid + 1, end, id, val);\\n            }\\n            tree[idx] = tree[2 * idx + 1] + tree[2 * idx + 2];\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        int n = nums.length;\\n        int[][] pairs = new int[n][2];\\n        int[] position = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            pairs[i][0] = nums[i];\\n            pairs[i][1] = i;\\n        }\\n        Arrays.sort(pairs, Comparator.comparingInt(o -> o[0]));\\n        for (int i = 0; i < n; i++) {\\n            position[pairs[i][1]] = i;\\n        }\\n        SegmentTree tree = new SegmentTree(n);\\n        for (int i = 0; i < k; i++) {\\n            tree.update(0, 0, n - 1, position[i], 1);\\n        }\\n        double[] medians = new double[n - k + 1];\\n        medians[0] = pairs[tree.getKthIndex(0, 0, n - 1, k / 2 + 1)][0];\\n        if (k % 2 == 0) {\\n            medians[0] += pairs[tree.getKthIndex(0, 0, n - 1, k / 2)][0];\\n        }\\n        for (int i = k; i < n; i++) {\\n            tree.update(0, 0, n - 1, position[i - k], 0);\\n            tree.update(0, 0, n - 1, position[i], 1);\\n            medians[i - k + 1] = pairs[tree.getKthIndex(0, 0, n - 1, k / 2 + 1)][0];\\n            if (k % 2 == 0) {\\n                medians[i - k + 1] += pairs[tree.getKthIndex(0, 0, n - 1, k / 2)][0];\\n            }\\n        }\\n        if (k % 2 == 0) {\\n            for (int i = 0; i < medians.length; i++) {\\n                medians[i] /= 2;\\n            }\\n        }\\n        return medians;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268883,
                "title": "same-logic-sortedlist-and-bisect",
                "content": "# SortedList:\\nSimilar to [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/description/)\\n```\\n# Runtime 155 ms Beats 73.82%; Memory 16.2 MB Beats 22.47%\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        # if k == 1:\\n            # return nums\\n        s, n = SortedList(nums[:k]), len(nums)\\n        if k % 2:\\n            r = [s[k // 2]]\\n            for i in range(k, n):\\n                s.discard(nums[i - k])\\n                s.add(nums[i])\\n                r.append(s[k // 2])\\n        else:\\n            r = [(s[k // 2 - 1] + s[k // 2]) / 2]\\n            for i in range(k, n):\\n                s.discard(nums[i - k])\\n                s.add(nums[i])\\n                r.append((s[k // 2 - 1] + s[k // 2]) / 2)\\n        return r\\n```\\n\\n# Bisect:\\n```\\n# Runtime 120 ms Beats 92.38%; Memory 15.7 MB Beats 71.21%\\nfrom bisect import bisect, insort\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        s, n = sorted(nums[:k]), len(nums)\\n        if k % 2:\\n            r = [s[k // 2]]\\n            for i in range(k, n):\\n                s.pop(bisect(s, nums[i - k]) - 1)\\n                insort(s, nums[i])\\n                r.append(s[k // 2])\\n        else:\\n            r = [(s[k // 2 - 1] + s[k // 2]) / 2]\\n            for i in range(k, n):\\n                s.pop(bisect(s, nums[i - k]) - 1)\\n                insort(s, nums[i])\\n                r.append((s[k // 2 - 1] + s[k // 2]) / 2)\\n        return r\\n```\\n\\nFeel free to ask any questions!",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\n# Runtime 155 ms Beats 73.82%; Memory 16.2 MB Beats 22.47%\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        # if k == 1:\\n            # return nums\\n        s, n = SortedList(nums[:k]), len(nums)\\n        if k % 2:\\n            r = [s[k // 2]]\\n            for i in range(k, n):\\n                s.discard(nums[i - k])\\n                s.add(nums[i])\\n                r.append(s[k // 2])\\n        else:\\n            r = [(s[k // 2 - 1] + s[k // 2]) / 2]\\n            for i in range(k, n):\\n                s.discard(nums[i - k])\\n                s.add(nums[i])\\n                r.append((s[k // 2 - 1] + s[k // 2]) / 2)\\n        return r\\n```\n```\\n# Runtime 120 ms Beats 92.38%; Memory 15.7 MB Beats 71.21%\\nfrom bisect import bisect, insort\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        s, n = sorted(nums[:k]), len(nums)\\n        if k % 2:\\n            r = [s[k // 2]]\\n            for i in range(k, n):\\n                s.pop(bisect(s, nums[i - k]) - 1)\\n                insort(s, nums[i])\\n                r.append(s[k // 2])\\n        else:\\n            r = [(s[k // 2 - 1] + s[k // 2]) / 2]\\n            for i in range(k, n):\\n                s.pop(bisect(s, nums[i - k]) - 1)\\n                insort(s, nums[i])\\n                r.append((s[k // 2 - 1] + s[k // 2]) / 2)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231862,
                "title": "python-two-heaps-solution-with-simple-explanation",
                "content": "This explanation assumes you already know how to find the median of a data stream using 2 heaps ([leetcode #295](https://leetcode.com/problems/find-median-from-data-stream/)).\\n\\nWhen I was solving the problem I was really confused how to remove numbers exiting the window from the heaps, so hopefully this explanation is helpful.\\n\\n```\\nfrom heapq import *\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        \\'\\'\\'\\n        Idea:\\n        - the main trick behind this problem is how to remove elements leaving the window\\n        - since we cannot delete elements which are not at the root of the heap, our approach\\n          is to lazy-delete items leaving the window\\n        - every time a number leaves the window, we increment its count in a dictionary\\n        - then, at the end of the iteration, we check to see if the root of either heap\\n          has a nonzero count in the dictionary\\n          - if it is, that means the value at the root of the heap was marked for deletion,\\n            so we must pop it from the heap\\n          - we also decrement the count of the number we just popped, so that we do not over-delete\\n          - we continue these steps until neither heap\\'s root is found in the dictionary with a nonzero count\\n    \\n        - this works because as long as the element leaving the window is not at the top\\n          of either heap, we can still calculate the correct value for the median\\n        - however, after lazy deleting an element, we may need to rebalance our heaps such that\\n          len(maxheap) = len(minheap) + 1 (in the case that k is odd) or\\n          len(maxheap) = len(minheap) (in the case that k is even)\\n        \\'\\'\\'\\n        medians = []\\n        maxheap = []\\n        minheap = []\\n        for i in range(k):\\n            heappush(maxheap, -nums[i])\\n        for i in range(k//2):\\n            heappush(minheap, -heappop(maxheap))\\n        \\n        # initialize the dictionary that keeps track of the numbers leaving the window\\n        to_remove = {}\\n        n = len(nums)\\n        for i in range(k, n+1):\\n            if k % 2:\\n                medians.append(-maxheap[0]/1.0)\\n            else:\\n                medians.append((-maxheap[0]+minheap[0])/2.0)\\n            \\n            if i == n:\\n                break\\n            \\n            # increment the count of the number leaving the window\\n            out_num = nums[i-k]\\n            to_remove[out_num] = to_remove.get(out_num, 0) + 1\\n            \\n            if nums[i] <= -maxheap[0]:\\n                heappush(maxheap, -nums[i])\\n                # if we add a number to the maxheap, and remove a number from the minheap\\n                # this iteration, there will be too many items in maxheap and too few items in\\n                # minheap, so we need to rebalance by moving an item from maxheap to minheap\\n                if not (out_num <= -maxheap[0]):\\n                    heappush(minheap, -heappop(maxheap))\\n            else:\\n                heappush(minheap, nums[i])\\n                # similarly, if we add a number to the minheap, and remove a number from the maxheap,\\n                # this iteration, there will be too many items in minheap compared to maxheap, so we\\n                # rebalance by moving an item from minheap to maxheap\\n                if out_num <= -maxheap[0]:\\n                    heappush(maxheap, -heappop(minheap))\\n            \\n            # finally, if the root of either heap was previously marked for removal,\\n            # we pop it off from the heap and decrement its count in the dictionary\\n            while to_remove.get(-maxheap[0]):\\n                to_remove[-maxheap[0]] -= 1\\n                heappop(maxheap)\\n\\n            while minheap and to_remove.get(minheap[0]):\\n                to_remove[minheap[0]] -= 1\\n                heappop(minheap)\\n\\n        return medians\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom heapq import *\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        \\'\\'\\'\\n        Idea:\\n        - the main trick behind this problem is how to remove elements leaving the window\\n        - since we cannot delete elements which are not at the root of the heap, our approach\\n          is to lazy-delete items leaving the window\\n        - every time a number leaves the window, we increment its count in a dictionary\\n        - then, at the end of the iteration, we check to see if the root of either heap\\n          has a nonzero count in the dictionary\\n          - if it is, that means the value at the root of the heap was marked for deletion,\\n            so we must pop it from the heap\\n          - we also decrement the count of the number we just popped, so that we do not over-delete\\n          - we continue these steps until neither heap\\'s root is found in the dictionary with a nonzero count\\n    \\n        - this works because as long as the element leaving the window is not at the top\\n          of either heap, we can still calculate the correct value for the median\\n        - however, after lazy deleting an element, we may need to rebalance our heaps such that\\n          len(maxheap) = len(minheap) + 1 (in the case that k is odd) or\\n          len(maxheap) = len(minheap) (in the case that k is even)\\n        \\'\\'\\'\\n        medians = []\\n        maxheap = []\\n        minheap = []\\n        for i in range(k):\\n            heappush(maxheap, -nums[i])\\n        for i in range(k//2):\\n            heappush(minheap, -heappop(maxheap))\\n        \\n        # initialize the dictionary that keeps track of the numbers leaving the window\\n        to_remove = {}\\n        n = len(nums)\\n        for i in range(k, n+1):\\n            if k % 2:\\n                medians.append(-maxheap[0]/1.0)\\n            else:\\n                medians.append((-maxheap[0]+minheap[0])/2.0)\\n            \\n            if i == n:\\n                break\\n            \\n            # increment the count of the number leaving the window\\n            out_num = nums[i-k]\\n            to_remove[out_num] = to_remove.get(out_num, 0) + 1\\n            \\n            if nums[i] <= -maxheap[0]:\\n                heappush(maxheap, -nums[i])\\n                # if we add a number to the maxheap, and remove a number from the minheap\\n                # this iteration, there will be too many items in maxheap and too few items in\\n                # minheap, so we need to rebalance by moving an item from maxheap to minheap\\n                if not (out_num <= -maxheap[0]):\\n                    heappush(minheap, -heappop(maxheap))\\n            else:\\n                heappush(minheap, nums[i])\\n                # similarly, if we add a number to the minheap, and remove a number from the maxheap,\\n                # this iteration, there will be too many items in minheap compared to maxheap, so we\\n                # rebalance by moving an item from minheap to maxheap\\n                if out_num <= -maxheap[0]:\\n                    heappush(maxheap, -heappop(minheap))\\n            \\n            # finally, if the root of either heap was previously marked for removal,\\n            # we pop it off from the heap and decrement its count in the dictionary\\n            while to_remove.get(-maxheap[0]):\\n                to_remove[-maxheap[0]] -= 1\\n                heappop(maxheap)\\n\\n            while minheap and to_remove.get(minheap[0]):\\n                to_remove[minheap[0]] -= 1\\n                heappop(minheap)\\n\\n        return medians\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827412,
                "title": "python-solution-using-sliding-window-bisect",
                "content": "Beats 98,2% Runtime and 56,77% Memory\\n\\n# Code\\n```\\nimport bisect\\n\\ndef medianaordenada(arr):\\n    d = len(arr)\\n    pos0 = (d - 1) // 2\\n    if d%2 == 0:\\n        return (arr[pos0]+arr[pos0+1])/2\\n    else:\\n        return arr[pos0]\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if len(nums) < k:\\n            return 0    \\n        cnt = 0\\n        roll = sorted(nums[:k])\\n        md = medianaordenada(roll)\\n        lmed = [md]\\n\\n        for i,k in enumerate(nums[k:]):\\n            del roll[bisect.bisect_left(roll, nums[i])]\\n            if k >= 2*md:\\n                cnt+=1\\n            if k >= md:\\n                bisect.insort_right(roll, k)\\n            else:\\n                bisect.insort_left(roll, k)\\n            lmed.append(medianaordenada(roll))\\n        return lmed  \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport bisect\\n\\ndef medianaordenada(arr):\\n    d = len(arr)\\n    pos0 = (d - 1) // 2\\n    if d%2 == 0:\\n        return (arr[pos0]+arr[pos0+1])/2\\n    else:\\n        return arr[pos0]\\n\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        if len(nums) < k:\\n            return 0    \\n        cnt = 0\\n        roll = sorted(nums[:k])\\n        md = medianaordenada(roll)\\n        lmed = [md]\\n\\n        for i,k in enumerate(nums[k:]):\\n            del roll[bisect.bisect_left(roll, nums[i])]\\n            if k >= 2*md:\\n                cnt+=1\\n            if k >= md:\\n                bisect.insort_right(roll, k)\\n            else:\\n                bisect.insort_left(roll, k)\\n            lmed.append(medianaordenada(roll))\\n        return lmed  \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655980,
                "title": "very-small-and-easy-code-using-multiset",
                "content": "class Solution {\\npublic:\\n    \\n    double median(vector<int>& v,int k)\\n    {\\n        double mid;\\n        if(k%2!=0)\\n            mid=v[k/2];\\n        else\\n            mid=v[k/2-1]/2.0 + v[k/2]/2.0;\\n        return mid;\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        \\n        vector<double>ans;\\n        multiset<int>st;\\n        for(int i=0;i<k;i++)\\n            st.insert(nums[i]);\\n        vector<int>v(st.begin(),st.end());\\n        double mid=median(v,k);\\n        ans.push_back(mid);\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            st.erase(st.find(nums[i-k]));\\n            st.insert(nums[i]);\\n            vector<int>v(st.begin(),st.end());\\n            mid=median(v,k);\\n            ans.push_back(mid);\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    double median(vector<int>& v,int k)\\n    {\\n        double mid;\\n        if(k%2!=0)\\n            mid=v[k/2];\\n        else\\n            mid=v[k/2-1]/2.0 + v[k/2]/2.0;\\n        return mid;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2550944,
                "title": "java-super-clean-two-heaps-solutions",
                "content": "class Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n\\n        int l = 0;\\n        int r = l+k;\\n        double[] res = new double[nums.length-k+1 ];\\n        int index= 0;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        for(int i = l; i<k; i++){\\n            addNum(nums[i], maxHeap, minHeap);\\n        }\\n        \\n        while(r<=nums.length && index < res.length){  \\n            \\n            double medium = findMedium( maxHeap, minHeap);\\n            res[index++] = medium;\\n            \\n            //start sliding window \\n            if(r<nums.length){\\n                removeNum(nums[l], maxHeap, minHeap);\\n                addNum(nums[r], maxHeap, minHeap);\\n                l+=1;\\n                r+=1;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private void addNum(int num, PriorityQueue<Integer> maxHeap, PriorityQueue<Integer> minHeap){\\n          if(maxHeap.isEmpty() || num < maxHeap.peek()){\\n              maxHeap.add(num);\\n          }\\n          else{\\n              minHeap.add(num);\\n          }\\n        \\n          maintainBalance(maxHeap, minHeap);\\n          \\n    }\\n    private void removeNum(int num,PriorityQueue<Integer> maxHeap, PriorityQueue<Integer> minHeap){\\n         if(num <= maxHeap.peek()){\\n             maxHeap.remove(num);\\n             maintainBalance(maxHeap, minHeap);\\n         }else{\\n             minHeap.remove(num);\\n             maintainBalance(maxHeap, minHeap);\\n        }\\n    }\\n    private double findMedium(PriorityQueue<Integer> maxHeap, PriorityQueue<Integer> minHeap){\\n        if(maxHeap.size() > minHeap.size())\\n            return maxHeap.peek() * 1.0;\\n        if(maxHeap.size() < minHeap.size()){\\n            return minHeap.peek() * 1.0;\\n        }\\n        else{\\n            long num = (long)maxHeap.peek() + (long)minHeap.peek();\\n            return num/2.0;\\n        }\\n    }\\n    \\n    private void maintainBalance(PriorityQueue<Integer> maxHeap, PriorityQueue<Integer> minHeap){\\n          if(!maxHeap.isEmpty() && !minHeap.isEmpty() && maxHeap.peek() > minHeap.peek()){\\n              int val = maxHeap.poll();\\n              minHeap.add(val);\\n          }\\n          if(maxHeap.size() - minHeap.size() > 1){\\n              int val = maxHeap.poll();\\n              minHeap.add(val);\\n          }\\n          if(minHeap.size() - maxHeap.size() > 1 ){\\n              int val = minHeap.poll();\\n              maxHeap.add(val);\\n          }\\n    }\\n}",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n\\n        int l = 0;\\n        int r = l+k;\\n        double[] res = new double[nums.length-k+1 ];\\n        int index= 0;\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        for(int i = l; i<k; i++){\\n            addNum(nums[i], maxHeap, minHeap);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2541940,
                "title": "c-simple-solution-using-upper-bound-and-vectors",
                "content": "Deleting and inserting elements in log (k) time, thus the runtime is NlogK, used z for long long and val for precision.\\nI have my customised template, which reduces my efforts in writing the syntax, thus for better understanding the code\\nRefer this- https://leetcode.com/submissions/detail/793322084/\\n```\\nvector<double> res;\\n    vector<long long> ans;\\n        int n=v.size();\\n    fi(k) ans.push_back(v[i]);\\n    sort(all(ans));\\n    if(k%2) {\\n        double val=ans[k/2]*1.000000;\\n            res.push_back(val);\\n        rep(i,k,n) {\\n            ans.erase(find(all(ans),v[i-k]));\\n            auto pos=upper_bound(all(ans),v[i]);\\n            if(pos==ans.end()) ans.push_back(v[i]);\\n            else ans.insert(pos,v[i]);\\n            double val=ans[k/2]*1.000000;\\n            res.push_back(val);\\n        }\\n    }\\n    else {\\n        long long z=ans[k/2-1]+ans[k/2];\\n        double val=(z)*1.000000/2.00000;\\n            res.push_back(val);\\n        rep(i,k,n) {\\n            ans.erase(find(all(ans),v[i-k]));\\n            auto pos=upper_bound(all(ans),v[i]);\\n            if(pos==ans.end()) ans.push_back(v[i]);\\n            else ans.insert(pos,v[i]);\\n            long long z=ans[k/2-1]+ans[k/2];\\n            double val=(z)*1.000000/2.00000;\\n            res.push_back(val);\\n        }\\n    }\\n    return res;\\n\\t\\n\\tRegards",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Deleting and inserting elements in log (k) time, thus the runtime is NlogK, used z for long long and val for precision.\\nI have my customised template, which reduces my efforts in writing the syntax, thus for better understanding the code\\nRefer this- https://leetcode.com/submissions/detail/793322084/\\n```\\nvector<double> res;\\n    vector<long long> ans;\\n        int n=v.size();\\n    fi(k) ans.push_back(v[i]);\\n    sort(all(ans));\\n    if(k%2) {\\n        double val=ans[k/2]*1.000000;\\n            res.push_back(val);\\n        rep(i,k,n) {\\n            ans.erase(find(all(ans),v[i-k]));\\n            auto pos=upper_bound(all(ans),v[i]);\\n            if(pos==ans.end()) ans.push_back(v[i]);\\n            else ans.insert(pos,v[i]);\\n            double val=ans[k/2]*1.000000;\\n            res.push_back(val);\\n        }\\n    }\\n    else {\\n        long long z=ans[k/2-1]+ans[k/2];\\n        double val=(z)*1.000000/2.00000;\\n            res.push_back(val);\\n        rep(i,k,n) {\\n            ans.erase(find(all(ans),v[i-k]));\\n            auto pos=upper_bound(all(ans),v[i]);\\n            if(pos==ans.end()) ans.push_back(v[i]);\\n            else ans.insert(pos,v[i]);\\n            long long z=ans[k/2-1]+ans[k/2];\\n            double val=(z)*1.000000/2.00000;\\n            res.push_back(val);\\n        }\\n    }\\n    return res;\\n\\t\\n\\tRegards",
                "codeTag": "Unknown"
            },
            {
                "id": 2465974,
                "title": "c-multiset-time-complexity-o-n-logk",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<double> ans; // (n-k+1);\\n        multiset<int> hash;\\n        bool odd = k&1;\\n        int i;\\n        for(i = 0; i<k; i++) hash.insert(nums[i]);\\n        auto p = hash.begin();\\n        for(int j=0; j<k/2; j++) p++;\\n        for(; i<=n; i++) \\n        {\\n            if (odd) \\n            {\\n                ans.push_back(*p);\\n            }\\n            else\\n            {\\n                auto m1 = p;\\n                m1--;\\n                ans.push_back(((double)*m1+*p)/2);\\n            }\\n            if(i==n) break;\\n            \\n            hash.insert(nums[i]);\\n            if(nums[i] < *p) p--;\\n            if(nums[i-k]<= *p) p++;\\n            hash.erase(hash.lower_bound(nums[i-k])); \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<double> ans; // (n-k+1);\\n        multiset<int> hash;\\n        bool odd = k&1;\\n        int i;\\n        for(i = 0; i<k; i++) hash.insert(nums[i]);\\n        auto p = hash.begin();\\n        for(int j=0; j<k/2; j++) p++;\\n        for(; i<=n; i++) \\n        {\\n            if (odd) \\n            {\\n                ans.push_back(*p);\\n            }\\n            else\\n            {\\n                auto m1 = p;\\n                m1--;\\n                ans.push_back(((double)*m1+*p)/2);\\n            }\\n            if(i==n) break;\\n            \\n            hash.insert(nums[i]);\\n            if(nums[i] < *p) p--;\\n            if(nums[i-k]<= *p) p++;\\n            hash.erase(hash.lower_bound(nums[i-k])); \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418783,
                "title": "explained-with-commented-code-used-2-multiset-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        // we will use two multiset to get the median such that the right partition multiset will have elements >= left partition\\n        // left partition gives max element\\n        multiset<int, greater<int>> left;\\n        // right partition gives min element\\n        multiset<int> right;\\n        int i = 0;\\n        vector<double> ans;\\n        for(int j=0; j<nums.size(); j++) {\\n            left.insert(nums[j]);\\n            if(!right.empty() && *left.begin() > *right.begin()) { // right partiton will have elements >= left partiton set\\n                right.insert(*left.begin());\\n                left.erase(left.begin());\\n            }\\n            // balancing left & right partiton such that difference of their size should not exceed 1\\n            if(left.size() > right.size()+1) {\\n                right.insert(*left.begin());\\n                left.erase(left.begin());\\n            }\\n            if(right.size() > left.size()+1) {\\n                left.insert(*right.begin());\\n                right.erase(right.begin());\\n            }\\n            \\n            // Reached Window size\\n            if(j-i+1 == k) {\\n                double val;\\n                if(k & 1) { // if window is odd, set won\\'t have equal size then the mid will be always present at the begining of set which have greater size\\n                    val = left.size() > right.size() ? *left.begin() : *right.begin();\\n                } else { // if window is even, set have equal size then the mid will be the half of top values of both set\\n                    val = ( (double)*left.begin() + (double)*right.begin() ) / (double)2;\\n                }\\n                ans.push_back(val);\\n                // now window is gonna shift by 1, we have to remove the occurence of first value of window\\n                // the occurence may be present at left partition set or the right partition set\\n                // we have to check in which partition our ith value is present & then we will delete that occurence from the partition\\n                bool alreadyRemoved = false;\\n                auto itr = left.find(nums[i]);\\n                if(alreadyRemoved == false && itr != left.end()) {\\n                    left.erase(itr);\\n                    alreadyRemoved = true;\\n                }\\n                auto jtr = right.find(nums[i]);\\n                if(alreadyRemoved == false && jtr != right.end()) {\\n                    right.erase(jtr);\\n                    alreadyRemoved = true; \\n                }\\n                // shifting the window\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        // we will use two multiset to get the median such that the right partition multiset will have elements >= left partition\\n        // left partition gives max element\\n        multiset<int, greater<int>> left;\\n        // right partition gives min element\\n        multiset<int> right;\\n        int i = 0;\\n        vector<double> ans;\\n        for(int j=0; j<nums.size(); j++) {\\n            left.insert(nums[j]);\\n            if(!right.empty() && *left.begin() > *right.begin()) { // right partiton will have elements >= left partiton set\\n                right.insert(*left.begin());\\n                left.erase(left.begin());\\n            }\\n            // balancing left & right partiton such that difference of their size should not exceed 1\\n            if(left.size() > right.size()+1) {\\n                right.insert(*left.begin());\\n                left.erase(left.begin());\\n            }\\n            if(right.size() > left.size()+1) {\\n                left.insert(*right.begin());\\n                right.erase(right.begin());\\n            }\\n            \\n            // Reached Window size\\n            if(j-i+1 == k) {\\n                double val;\\n                if(k & 1) { // if window is odd, set won\\'t have equal size then the mid will be always present at the begining of set which have greater size\\n                    val = left.size() > right.size() ? *left.begin() : *right.begin();\\n                } else { // if window is even, set have equal size then the mid will be the half of top values of both set\\n                    val = ( (double)*left.begin() + (double)*right.begin() ) / (double)2;\\n                }\\n                ans.push_back(val);\\n                // now window is gonna shift by 1, we have to remove the occurence of first value of window\\n                // the occurence may be present at left partition set or the right partition set\\n                // we have to check in which partition our ith value is present & then we will delete that occurence from the partition\\n                bool alreadyRemoved = false;\\n                auto itr = left.find(nums[i]);\\n                if(alreadyRemoved == false && itr != left.end()) {\\n                    left.erase(itr);\\n                    alreadyRemoved = true;\\n                }\\n                auto jtr = right.find(nums[i]);\\n                if(alreadyRemoved == false && jtr != right.end()) {\\n                    right.erase(jtr);\\n                    alreadyRemoved = true; \\n                }\\n                // shifting the window\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416692,
                "title": "o-nlogk-c-using-multiset-median-from-stream",
                "content": "```\\nclass Solution {\\npublic:\\n    multiset<long long> first;\\n    multiset<long long> sec;\\n    \\n    vector<double> medianSlidingWindow(vector<int>& a, int k) {\\n        vector<double> ans;\\n        long long n = a.size();\\n        long long start = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            long long x = a[start];\\n            if(i>=k){\\n                //delete operation\\n                if(first.find(x)!=first.end()){\\n                    first.erase(first.find(x));\\n                    if(first.size()<sec.size()){\\n                        first.insert(*sec.begin());\\n                        sec.erase(sec.begin());\\n                    }\\n                }\\n                else{\\n                    sec.erase(sec.find(x));\\n                    if(first.size()>sec.size()+1){\\n                        sec.insert(*first.rbegin());\\n                        auto it = first.end(); it--;\\n                        first.erase(it);\\n                    }\\n                }\\n                start++;\\n            }\\n            //insert operation\\n            x = a[i];\\n            if(first.size()==sec.size()){\\n                if(first.size()==0 or x<=*first.rbegin()){\\n                    first.insert(x);\\n                }else{\\n                    sec.insert(x);\\n                    first.insert(*sec.begin());\\n                    sec.erase(sec.begin());\\n                }\\n            }else{\\n                if(x<*first.rbegin()){\\n                    sec.insert(*first.rbegin());\\n                    auto it = first.end(); it--;\\n                    first.erase(it);\\n                    first.insert(x);\\n                }else{\\n                    sec.insert(x);\\n                }\\n            }\\n            if(i>=k-1)\\n            k%2==0 ? ans.push_back(double(*first.rbegin()+ *sec.begin())/2) : ans.push_back(double(*first.rbegin()));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    multiset<long long> first;\\n    multiset<long long> sec;\\n    \\n    vector<double> medianSlidingWindow(vector<int>& a, int k) {\\n        vector<double> ans;\\n        long long n = a.size();\\n        long long start = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            long long x = a[start];\\n            if(i>=k){\\n                //delete operation\\n                if(first.find(x)!=first.end()){\\n                    first.erase(first.find(x));\\n                    if(first.size()<sec.size()){\\n                        first.insert(*sec.begin());\\n                        sec.erase(sec.begin());\\n                    }\\n                }\\n                else{\\n                    sec.erase(sec.find(x));\\n                    if(first.size()>sec.size()+1){\\n                        sec.insert(*first.rbegin());\\n                        auto it = first.end(); it--;\\n                        first.erase(it);\\n                    }\\n                }\\n                start++;\\n            }\\n            //insert operation\\n            x = a[i];\\n            if(first.size()==sec.size()){\\n                if(first.size()==0 or x<=*first.rbegin()){\\n                    first.insert(x);\\n                }else{\\n                    sec.insert(x);\\n                    first.insert(*sec.begin());\\n                    sec.erase(sec.begin());\\n                }\\n            }else{\\n                if(x<*first.rbegin()){\\n                    sec.insert(*first.rbegin());\\n                    auto it = first.end(); it--;\\n                    first.erase(it);\\n                    first.insert(x);\\n                }else{\\n                    sec.insert(x);\\n                }\\n            }\\n            if(i>=k-1)\\n            k%2==0 ? ans.push_back(double(*first.rbegin()+ *sec.begin())/2) : ans.push_back(double(*first.rbegin()));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381718,
                "title": "java-two-heap-solution-priority-queue-o-nlog-k",
                "content": "Approch: \\n-> Maintain two heap, min and max\\n-> **Store lower values in maxHeap and higher values in minHeap**\\n-> Maintain appropriate sizes of min and max heaps \\n-> Get median from top of maxHeap (when k is odd) and avg of top of minHeap and maxHeap (when k is even)\\n\\nT: O(nlogk)\\nS: O(k)\\n```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        Queue<Integer> minHeap = new PriorityQueue<>();\\n        Queue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        double[] res = new double[nums.length - k + 1];\\n        for(int i = 0; i< nums.length; i++){\\n            if(i >= k){\\n                if(!minHeap.remove(nums[i-k]))\\n                    maxHeap.remove(nums[i-k]);\\n            }\\n            \\n            // If k is odd, max heap is of odd size and min heap is of even\\n            // else both are of even size\\n            if(!maxHeap.isEmpty() && nums[i] <= maxHeap.peek()) {\\n                maxHeap.add(nums[i]);\\n                if(((k&1) == 1 && maxHeap.size() > k/2+1) || ((k&1) == 0 && maxHeap.size() > k/2)){\\n                    minHeap.offer(maxHeap.poll());\\n                }\\n            }else{\\n                minHeap.add(nums[i]);\\n                if(minHeap.size() > k/2){\\n                    maxHeap.offer(minHeap.poll());\\n                }\\n            }\\n            while(!minHeap.isEmpty() && !maxHeap.isEmpty() && maxHeap.peek() > minHeap.peek()){\\n                int temp1 = maxHeap.poll();\\n                int temp2 = minHeap.poll();\\n                maxHeap.add(temp2);\\n                minHeap.add(temp1);\\n            }\\n            if(minHeap.size() + maxHeap.size() == k){\\n                if((k&1)==1){\\n                    res[i-k+1] = maxHeap.peek();\\n                }else{\\n                    res[i-k+1] = ((long)minHeap.peek()+ (long)maxHeap.peek())/2.0;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**Please upvote if you like the solution!!!**",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public double[] medianSlidingWindow(int[] nums, int k) {\\n        Queue<Integer> minHeap = new PriorityQueue<>();\\n        Queue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        double[] res = new double[nums.length - k + 1];\\n        for(int i = 0; i< nums.length; i++){\\n            if(i >= k){\\n                if(!minHeap.remove(nums[i-k]))\\n                    maxHeap.remove(nums[i-k]);\\n            }\\n            \\n            // If k is odd, max heap is of odd size and min heap is of even\\n            // else both are of even size\\n            if(!maxHeap.isEmpty() && nums[i] <= maxHeap.peek()) {\\n                maxHeap.add(nums[i]);\\n                if(((k&1) == 1 && maxHeap.size() > k/2+1) || ((k&1) == 0 && maxHeap.size() > k/2)){\\n                    minHeap.offer(maxHeap.poll());\\n                }\\n            }else{\\n                minHeap.add(nums[i]);\\n                if(minHeap.size() > k/2){\\n                    maxHeap.offer(minHeap.poll());\\n                }\\n            }\\n            while(!minHeap.isEmpty() && !maxHeap.isEmpty() && maxHeap.peek() > minHeap.peek()){\\n                int temp1 = maxHeap.poll();\\n                int temp2 = minHeap.poll();\\n                maxHeap.add(temp2);\\n                minHeap.add(temp1);\\n            }\\n            if(minHeap.size() + maxHeap.size() == k){\\n                if((k&1)==1){\\n                    res[i-k+1] = maxHeap.peek();\\n                }else{\\n                    res[i-k+1] = ((long)minHeap.peek()+ (long)maxHeap.peek())/2.0;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364325,
                "title": "c-using-heap-multiset-easy-solution",
                "content": "class Solution {\\npublic:\\n    multiset<double> pqmin;\\n    multiset<double, greater<double>> pqmax;\\n    \\n    \\n    void addNum(int num) {\\n       if(pqmin.size() == pqmax.size()){\\n            if(pqmin.size() == 0){\\n                pqmin.insert(num);\\n                return;\\n            }\\n            if(num > *pqmax.begin()){\\n                pqmin.insert(num);\\n                return;\\n            }\\n            pqmax.insert(num);\\n        }\\n        else{\\n            if(pqmin.size() > pqmax.size()){\\n                if(num > *pqmin.begin()){\\n                    double temp = *pqmin.begin();\\n                    pqmin.erase(pqmin.lower_bound(*pqmin.begin()));\\n                    pqmax.insert(temp);\\n                    pqmin.insert(num);\\n                  return;  \\n                }\\n                pqmax.insert(num);\\n                \\n            }else{\\n                if(num < *pqmax.begin()){\\n                    double temp = *pqmax.begin();\\n                    pqmax.erase(pqmax.lower_bound(*pqmax.begin()));\\n                    pqmin.insert(temp);\\n                    pqmax.insert(num);\\n                  return;  \\n                }\\n                pqmin.insert(num);\\n            }\\n        }\\n    }\\n    \\n   double findMedian() {\\n        if(pqmin.size() == pqmax.size()){\\n            return (*pqmin.begin() + *pqmax.begin())/ 2.0;\\n        }else if (pqmin.size() > pqmax.size())\\n            return *pqmin.begin();\\n        else\\n            return *pqmax.begin();\\n    }\\n    \\n    void erase(int num){\\n        if(*pqmin.begin()>num){\\n            pqmax.erase(pqmax.lower_bound(num));\\n        }else{\\n            pqmin.erase(pqmin.lower_bound(num));\\n        }\\n    }\\n    \\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\\n        vector<double> op;\\n        for(int i = 0; i<k; i++){\\n            addNum(nums[i]);\\n        }        \\n        op.push_back(findMedian());\\n        for(int i = k; i<nums.size(); i++){\\n            erase(nums[i - k]);\\n            addNum(nums[i]);\\n            op.push_back(findMedian());\\n        }\\n        return op;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    multiset<double> pqmin;\\n    multiset<double, greater<double>> pqmax;\\n    \\n    \\n    void addNum(int num) {\\n       if(pqmin.size() == pqmax.size()){\\n            if(pqmin.size() == 0){\\n                pqmin.insert(num);\\n                return;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565406,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1576674,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1567416,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1572555,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1945352,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1673966,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1576058,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1569424,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 2056822,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 2049398,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1565406,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1576674,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1567416,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1572555,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1945352,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1673966,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1576058,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 1569424,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 2056822,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            },
            {
                "id": 2049398,
                "content": [
                    {
                        "username": "S_Mbk",
                        "content": "I have tried many solutions, even copy-pasted C++ solutions from the solutions and discussions that others posted.\\nIn the very first test case with inputs:\\nnums = [1,3,-1,-3,5,3,6,7], and k = 3.\\ninstead of the correct expected output of:\\n[1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000] \\nThe run code result is:  6.00000]\\nand the expected result is also 6.00000]\\nNot a typo, the expeced result and run code result doesn\\'t even have an opening bracket!\\nAnd leetcode says answer accepted.\\nBut when I submit, it fails the first test case (same inputs) it says my answer is still 6.00000] but the expected answer is displaying correctly.\\nWhen I loop through my vector before returning it, i can see all values in the vector are correct, but for some reason output is still 6.00000]. (see screenshot attached)\\nDid anyone ever come across this bug?\\n\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588220844.png)\\n\\nI even made a \"fake answer\" that should at least pass the first test case (since we know from the problem description what the first test case answer is). When I run it, it again displays \"cropped\" vector and says that the answer is accepted. But when I submit it fails the first case, even though I just made it return the right answer vector to just pass the first test case. See screenshot below.\\n![image](https://assets.leetcode.com/users/sar_manarbek/image_1588285304.png)\\n\\nCould leetcode @admin please take a look at this?\\nPlease vote up is you have the same issue or comment if you know how to resolve it.\\nPerhaps if this gets a few votes, admins may notice this?"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "I tried doing some custom operations on the testcases mainly to calculate what the size of the median array should be. I think they have fixed it now"
                    },
                    {
                        "username": "birfied",
                        "content": "I really hate the testing case\\n\\n[16807,282475249,622650073,984943658,144108930,470211272,101027544,457850878,458777923,7237709,823564440,115438165,784484492,74243042,114807987,137522503,441282327,16531729,823378840,143542612,896544303,474833169,264817709,998097157,817129560,131570933,197493099,404280278,893351816,505795335,954899097,636807826,563613512,101929267,580723810,704877633,358580979,624379149,128236579,784558821,530511967,110010672,551901393,617819336,399125485,156091745,356425228,899894091,585640194,937186357,646035001,25921153,510616708,590357944,771515668,357571490,44788124,927702196,952509530,130060903,942727722,83454666,108728549,685118024,118797801,60806853,571540977,194847408,35308228,158374933,75260298,824938981,595028635,962408013,137623865,997389814,20739063,107554536,635339425,654001669,777724115,269220094,34075629,478446501,864546517,351934195,581030105,557810404,146319451,908194298,500782188,657821123,753799505,102246882,269406752,816731566,884936716,807130337,578354438,892053144,153851501,4844897,616783871,382955828,330111137,227619358,723153177,70982397,147722294,70477904,51621609,606946231,190959745,912844175,341853635,808266298,343098142,456880399,534827968,280090412,195400260,589673557,6441594,889688008,57716395,524325968,14119113,515204530,388471006,681910962,904797942,400285365,322842082,463179852,828530767,832633821,73185695,316824712,260973671,815859901,267248590,51724831,194314738,318153057,111631616,877819790,304555640,213110679,541437335,49077006,996497972,63936098,270649095,428975319,685583454,351345223,272112289,398556760,334948905,724586126,532236123,23129506,836045813,436476770,60935238,936329094,915896220,304987844,34712366,881140534,281725226,901915394,197941363,348318738,152607844,784559590,543436550,290145159,681808623,977764947,750597385,971307217,737195272,755539,399399247,462242385,459413496,951894885,537140623,848682420,12028144,86531968,289335735,755699915,623161625,992663534,43046042,358796011,943454679,771024152,479575244,507977295,119878818,49590396,828087692,621301815,154112991,104740033,222122669,889119397,238489553,882410547,944975825,567121210,866729662,536830211,719533808,517273377,592822761,41000625,902737335,127401868,994977995,140002776,532062767,49997439,433829874,464689331,428540556,968456301,859468872,911300560,168120094,298918984,967113755,124639789,462851407,957828015,678030193,105222769,893015680,944303455,4016855,732267506,784170963,454233502,145586676,329863108,353963249,323602331,1277844,1887638,660760808,561939997,685428651,897054849,465645203,461495731,440796531,796198014,522395419,779636775,203042009,175530180,640687929,351995223,459244054,458588260,174076737,834991545,44747317,34837525,837204200,578134256,486421564,609960597,668306648,683337704,907225550,605925150,416541976,24301412,411938554,111482797,524102504,760348381,293034748,855007065,290659378,379847699,778878209,338725129,121578553,552265483,501650447,218264607,471180773,363045322,494664305,706755176,495170053,616927224,437784630,360280366,121205400,284660444,487495370,684570285,502883016,252193898,637608155,129841133,189515557,262696576,707953178,509658266,307187357,347221711,42227878,847320614,746474819,195795737,586983133,678620591,290623720,135048762,667306633,262976197,112576031,925238588,555860589,795054873,843998877,959637304,21979358,832861200,599777254,168068960,794014915,545293947,442645480,452207730,103669955,564674546,547837107,28841238,989340000,18984926,690545035,988774857,110561113,420250114,862929593,300601360,118498354,322968418,439025357,738342585,163313729,122721015,780776563,32106102,588860917,380786643,172819419,971062967,572547747,83245269,529855395,812423303,490404473,978719103,754711748,47424385,345205658,518163459,520045406,937673930,250739824,614285132,129300973,493959603,600246897,618907920,367603950,9135231,64488480,171620203,350213900,939824520,681462533,603481258,937217003,13618676,255820950,113423934,143558780,168279879,836941832,463482574,828433549,346174542,415306249,523252771,156766310,601915879,752200983,798669970,473392040,666082723,20073650,222902971,118753229,666190318,473917746,118710299,151687230,344185621,554270776,637850124,108668244,26076958,981747696,116666771,958829064,322791560,614056598,790318751,493869940,240764503,462789551,711192801,123427205,119315080,164780418,3559274,838659649,63040413,810783320,51519025,237322012,586901783,458854788,151624117,76424008,263081550,90265324,404319195,754451257,318824511,304835690,270438666,187262410,48760593,766490553,799809565,92190960,556228742,540151403,911254352,746007307,928256141,525244910,633413200,492192799,970343127,566120171,429157787,250334414,450031625,244116641,174619517,13055348,377901842,287114315,927515974,177181445,476211373,805972220,795739911,265509239,90245054,63641305,172556929,61382253,652354189,5815166,537204356,772359304,651659860,73645898,609005592,442901720,463866116,625151580,78098867,495149352,476026939,208178698,401494901,324160811,797716616,482756891,501848671,402331728,356326671,597951661,343077045,102303120,421620240,268317158,38299453,39769627,333685350,962853711,38535563,274629594,550207533,66401727,115307827,948398795,114919531,657737442,140351516,950885006,98478515,4466924,706642601,957627097,596168661,440967103,368034324,799980108,18044936,72002281,547517015,151043710,265963216,130301905,343775973,111767781,225882720,807270791,791481169,910297865,702715827,532329536,238616728,872357125,628320384,796580167,502789949,835500476,8416046,300521576,777568666,158577467,977260520,862627384,516341991,178425210,905333258,14428211,622268744,225419518,464685718,722321934,132666825,436280767,854658689,523449818,528073014,566211825,822102918,173958028,987333029,500078034,708006727,55151240,6933754,571486540,427408396,913090935,401203083,69048048,287846865,709087011,31615252,367553064,301377876,137017237,746232675,628070245,94482710,773470415,791728192,560024710,707454747,722463037,356701299,97368447,88949715,329241693,647259579,132567129,115195164,995333979,473553501,439295525,191110289,502574958,517114033,62211800,562165089,528087670,812535217,430880846,499521038,936509543,8240338,849385936,98603321,954597719,73536496,124791247,67943788,617428359,270425987,767145035,707765235,498383912,152185684,924745989,866683784,120263734,76422667,826500519,862972615,669167045,318665976,142326661,373365825,5182819,1271631,483422903,751072698,162936798,230092639,341914004,29909503,763800679,333748765,88207391,737904107,236264924,207314365,114057121,48114454,205777106,840127450,110051703,448530832,583071032,499932141,48961654,412281977,440942217,742753900,142357289,302173465,978084747,476003622,816289879,258459317,359301516,56564048,484182762,637121029,532649039,166052708,266605903,987502657,996510761,924375752,86561466,785108621,974044557,292006996,554426955,115266930,54021494,346645555,96192221,233429312,586802293,141231427,500142232,432477444,209234791,178402198,311549152,434444856,63273570,227464303,264627439,947712914,324735799,78626766,570591835,67981921,110846043,121122752,688574086,75289719,526439150,230168410,822418623,185044669,282409605,312349943,8437311,657922431,101977992,45139816,396138699,496786971,875180639,45501370,30325836,525679891,147182857,594094833,300383328,601518177,510474410,139217683,14885176,505523489,887972091,283070434,681484711,976226904,463491026,763464891,132610790,494500522,308559364,931706890,539924884,399116813,10341441,9907127,591316179,844185784,598994537,45329870,88387561,264032581,894374165,508545802,937357732,231367332,645347854,214459759,947609847,739972377,637940462,626979010,726943819,710298150,119413377,230900941,42143836,434826720,245832299,92396112,856734759,56219956,788974390,728536152,348330048,342695014,123959044,320514918,5240150,817350101,897741295,910819821,885295731,398644501,662128245,129154961,748946057,927703510,974593928,935350805,653662173,366782137,229309669,67439096,725004503,121447421,850318675,595278518,867224300,260276489,835740262,743532054,128868263,18358643,902024889,245245250,608776735,891469415,726031364,407052494,595850963,543867758,887985652,156485092,524957316,887766714,771761420,192958060,345807450,895063368,207078741,448891847,208199196,746004787,885902501,652188234,364093128,925270571,886377448,44687875,242817253,810641871,821669329,476562293,261433719,164973471,307738820,25725764,521681079,511142630,839594410,95688080,350266113,462863342,951398138,778248382,845146044,705698828,920998393,157863575,70800980,39109000,967945596,73005947,590767370,3266087,644506543,313952733,236262852,172490261,88376824,876554400,511982380,68370778,789871857,425373423,278059498,421567014,728252845,236261662,945468509,257726610,929596849,790709218,821019290,288775055,922285743,319518555,439236385,137606534,499086275,864877321,823811151,759921226,703775251,803694459,20632783,30316714,372366437,388337879,384907698,715914100,810383137,768094285,836445878,717918284,489470342,311164915,626045960,432063067,834735140,675810707,309543566,293320728,12000562,977466363,820241969,109242890,739712623,567222278,624917313,790245761,267127010,362834840,104576978,983646000,809207394,334734507,623187656,430166551,24761786,706993431,204554544,619880739,892408776,688507584,105074252,544374108,808275514,497991454,998595019,801783028,107466671,158592370,434756663,215867947,785684024,907424543,802916854,629306008,389114981,767780552,5986288,265768163,792508359,994411019,348255379,28195356,871419461,108408487,955308353,279743899,606985788,855794244,281369880,224582466,428738283,789665274,248300236,414318909,108898567,40621834,978847939,418069684,78169651,123289549,598709266,545747467,268000110,797619589,792486327,417097773,568625581,380889295,750607936,148637874,426245435,694558231,866566972,949983028,971319798,594139070,43874587,251766297,893369089,796102646,67029090,714958111,129966612,150957463,756872112,996923781,423551951,522329230]\\n321\\n\\nIt is impossible to debug something like this"
                    },
                    {
                        "username": "hhmtries",
                        "content": "Did you find a fix for this? I\\'m stuck over here trying to figure out what went wrong"
                    },
                    {
                        "username": "blessinto",
                        "content": "it tells you your algo is really slow so need to improve time complexity"
                    },
                    {
                        "username": "obiwon84",
                        "content": "Great problem, but the title says it all."
                    },
                    {
                        "username": "aslsd65456",
                        "content": "According to the problem, I\\'m supposed to output the median of each window in the array. However, In the example given by the problem:\\n\\n---\\n\\tWindow position                Median\\n\\t[1  3  -1] -3  5  3  6  7       1\\n\\t 1 [3  -1  -3] 5  3  6  7       -1\\n\\t 1  3 [-1  -3  5] 3  6  7       -1\\n\\t 1  3  -1 [-3  5  3] 6  7       3\\n\\t 1  3  -1  -3 [5  3  6] 7       5\\n\\t 1  3  -1  -3  5 [3  6  7]      6\\n---\\nThe correct answer should be [3,-1,-3,5,3,6] instead of the answer shown by the example.\\nIs there anything I did not understand from the problem? Could someone please explain? Appreciated!"
                    },
                    {
                        "username": "FeiD",
                        "content": "The median is the middle value in an ordered integer list. So, the window should be sorted."
                    },
                    {
                        "username": "zenshaun",
                        "content": "So frustrating to get a TLE at the last Testcase. UGH"
                    },
                    {
                        "username": "dheeraj0712",
                        "content": "same here, what a useless test case"
                    },
                    {
                        "username": "cheddarmachine",
                        "content": "I love how this is basically a sub-problem on a Hackerrank medium (Fraudulent Activity Notifications) but this is a hard. Little ol\\' smooth-brained me is never getting a job at this rate. \\nSpeaking of which, do you guys think the min and max heap of the streaming median problem would work or is this something totally different?"
                    },
                    {
                        "username": "blessinto",
                        "content": "You can apply the streaming median problem here. However, since you need a different value for each subarray doing that on every subarray would take O(n*n*logn) which does not pass all the cases 30/42. Instead you need to look for an alternative and see how can you update your min and max arrays on a sliding window pass."
                    },
                    {
                        "username": "ishiii_2708",
                        "content": "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000] \\nis someone please explain mee how the last three values come i.e 3,5,6 come ?"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Since the best we can do is O(N log k), can we keep a queue that contains K elements, and use QuickSelect to find the median for each window in O(log k)?\\n\\nTime complexity would still turn out to be O(N log k)."
                    },
                    {
                        "username": "fleum",
                        "content": "The world would be so much better if java\\'s PriorityQueue had logN remove method"
                    },
                    {
                        "username": "unordered_set",
                        "content": "We can basically just use 2 multisets to solve this problem. There are 2 more questions on Leetcode using the same approach the first one is 295. Find Median from Data Stream and the second one is Leetcode 1825. Finding MK Average. Although in LC 1825 we use 3 mutlisets instead of 2. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Student Number in Departments",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1807538,
                "content": [
                    {
                        "username": "nidhi93002",
                        "content": "why can\\'t i use count(*) over (partition by dept_id) here"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Please take a lot of my solution using CTE (MSSQL)\\n\\nwith cte as\\n(select dept_name, (case when isnull(s.dept_id, 0) <> 0 then 1 else 0 end) as students\\nfrom student s \\nright join Department d on s.dept_id = d.dept_id)\\n\\n\\nselect dept_name , sum(students)as student_number from cte \\ngroup by dept_name \\norder by sum(students) desc ,dept_name "
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nselect\\n    dept_name, count(student_id) as student_number\\nfrom\\n    Department d\\nleft join\\n    Student s on d.dept_id = s.dept_id\\ngroup by d.dept_id\\norder by student_number desc, dept_name  \\n```"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select d.dept_name, count(student_id) student_number from student\\nright join department d using (dept_id) \\ngroup by 1\\norder by 2 desc, 1"
                    }
                ]
            },
            {
                "id": 1732930,
                "content": [
                    {
                        "username": "nidhi93002",
                        "content": "why can\\'t i use count(*) over (partition by dept_id) here"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Please take a lot of my solution using CTE (MSSQL)\\n\\nwith cte as\\n(select dept_name, (case when isnull(s.dept_id, 0) <> 0 then 1 else 0 end) as students\\nfrom student s \\nright join Department d on s.dept_id = d.dept_id)\\n\\n\\nselect dept_name , sum(students)as student_number from cte \\ngroup by dept_name \\norder by sum(students) desc ,dept_name "
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nselect\\n    dept_name, count(student_id) as student_number\\nfrom\\n    Department d\\nleft join\\n    Student s on d.dept_id = s.dept_id\\ngroup by d.dept_id\\norder by student_number desc, dept_name  \\n```"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select d.dept_name, count(student_id) student_number from student\\nright join department d using (dept_id) \\ngroup by 1\\norder by 2 desc, 1"
                    }
                ]
            },
            {
                "id": 1668412,
                "content": [
                    {
                        "username": "nidhi93002",
                        "content": "why can\\'t i use count(*) over (partition by dept_id) here"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Please take a lot of my solution using CTE (MSSQL)\\n\\nwith cte as\\n(select dept_name, (case when isnull(s.dept_id, 0) <> 0 then 1 else 0 end) as students\\nfrom student s \\nright join Department d on s.dept_id = d.dept_id)\\n\\n\\nselect dept_name , sum(students)as student_number from cte \\ngroup by dept_name \\norder by sum(students) desc ,dept_name "
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nselect\\n    dept_name, count(student_id) as student_number\\nfrom\\n    Department d\\nleft join\\n    Student s on d.dept_id = s.dept_id\\ngroup by d.dept_id\\norder by student_number desc, dept_name  \\n```"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select d.dept_name, count(student_id) student_number from student\\nright join department d using (dept_id) \\ngroup by 1\\norder by 2 desc, 1"
                    }
                ]
            },
            {
                "id": 1644707,
                "content": [
                    {
                        "username": "nidhi93002",
                        "content": "why can\\'t i use count(*) over (partition by dept_id) here"
                    },
                    {
                        "username": "vaibh_1406",
                        "content": "Please take a lot of my solution using CTE (MSSQL)\\n\\nwith cte as\\n(select dept_name, (case when isnull(s.dept_id, 0) <> 0 then 1 else 0 end) as students\\nfrom student s \\nright join Department d on s.dept_id = d.dept_id)\\n\\n\\nselect dept_name , sum(students)as student_number from cte \\ngroup by dept_name \\norder by sum(students) desc ,dept_name "
                    },
                    {
                        "username": "baobui258",
                        "content": "```\\n# Write your MySQL query statement below\\nselect\\n    dept_name, count(student_id) as student_number\\nfrom\\n    Department d\\nleft join\\n    Student s on d.dept_id = s.dept_id\\ngroup by d.dept_id\\norder by student_number desc, dept_name  \\n```"
                    },
                    {
                        "username": "hpareek1995",
                        "content": "select d.dept_name, count(student_id) student_number from student\\nright join department d using (dept_id) \\ngroup by 1\\norder by 2 desc, 1"
                    }
                ]
            }
        ]
    },
    {
        "title": "Next Closest Time",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1572128,
                "content": [
                    {
                        "username": "chinux23",
                        "content": "why next time for 23:59 is 22:22 not 2:22? I think 2:22 is closer to 23:59 than 22:22. Where am I wrong?"
                    },
                    {
                        "username": "charleslondon",
                        "content": "Because you do not have a zero."
                    },
                    {
                        "username": "CodeHardPlayHard",
                        "content": "Input: \"23:59\"\\n\\nOutput: \"22:22\"\\n\\nInstead of \\n\\nOutput:\"2:2\""
                    },
                    {
                        "username": "devilhtc",
                        "content": "1. If 12:9 is a valid input, why isn\\u2019t 2:2 a valid output? You are treating the input and output in different manners, which should really be formatted in the same way.\\n\\n2. If 12:9 is valid, do we need to convert it to 12:09 before processing so that 0 is a digit we can use? Or in this case we cannot use 0?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "in other words, find the next closest time from a differenet permutation of the digits. How can it be done?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "An excellent question for \"Did you really think about all the edge cases before jumping into coding?\" Cause I sure didnt. Kept having to add to my spaghetti pile"
                    },
                    {
                        "username": "jalfaro",
                        "content": "I have a question for Input  23:59. Why not the closest time  is 23:55?"
                    },
                    {
                        "username": "dnox",
                        "content": "Example 1 clearly explains it - because it happens 23 hours 56 minutes later.\\nIn other words, \"going back in time\" is not allowed.\\nPerhaps, \"Next closest future time\" would make more sense as a problem title."
                    }
                ]
            },
            {
                "id": 1573072,
                "content": [
                    {
                        "username": "chinux23",
                        "content": "why next time for 23:59 is 22:22 not 2:22? I think 2:22 is closer to 23:59 than 22:22. Where am I wrong?"
                    },
                    {
                        "username": "charleslondon",
                        "content": "Because you do not have a zero."
                    },
                    {
                        "username": "CodeHardPlayHard",
                        "content": "Input: \"23:59\"\\n\\nOutput: \"22:22\"\\n\\nInstead of \\n\\nOutput:\"2:2\""
                    },
                    {
                        "username": "devilhtc",
                        "content": "1. If 12:9 is a valid input, why isn\\u2019t 2:2 a valid output? You are treating the input and output in different manners, which should really be formatted in the same way.\\n\\n2. If 12:9 is valid, do we need to convert it to 12:09 before processing so that 0 is a digit we can use? Or in this case we cannot use 0?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "in other words, find the next closest time from a differenet permutation of the digits. How can it be done?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "An excellent question for \"Did you really think about all the edge cases before jumping into coding?\" Cause I sure didnt. Kept having to add to my spaghetti pile"
                    },
                    {
                        "username": "jalfaro",
                        "content": "I have a question for Input  23:59. Why not the closest time  is 23:55?"
                    },
                    {
                        "username": "dnox",
                        "content": "Example 1 clearly explains it - because it happens 23 hours 56 minutes later.\\nIn other words, \"going back in time\" is not allowed.\\nPerhaps, \"Next closest future time\" would make more sense as a problem title."
                    }
                ]
            },
            {
                "id": 1567281,
                "content": [
                    {
                        "username": "chinux23",
                        "content": "why next time for 23:59 is 22:22 not 2:22? I think 2:22 is closer to 23:59 than 22:22. Where am I wrong?"
                    },
                    {
                        "username": "charleslondon",
                        "content": "Because you do not have a zero."
                    },
                    {
                        "username": "CodeHardPlayHard",
                        "content": "Input: \"23:59\"\\n\\nOutput: \"22:22\"\\n\\nInstead of \\n\\nOutput:\"2:2\""
                    },
                    {
                        "username": "devilhtc",
                        "content": "1. If 12:9 is a valid input, why isn\\u2019t 2:2 a valid output? You are treating the input and output in different manners, which should really be formatted in the same way.\\n\\n2. If 12:9 is valid, do we need to convert it to 12:09 before processing so that 0 is a digit we can use? Or in this case we cannot use 0?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "in other words, find the next closest time from a differenet permutation of the digits. How can it be done?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "An excellent question for \"Did you really think about all the edge cases before jumping into coding?\" Cause I sure didnt. Kept having to add to my spaghetti pile"
                    },
                    {
                        "username": "jalfaro",
                        "content": "I have a question for Input  23:59. Why not the closest time  is 23:55?"
                    },
                    {
                        "username": "dnox",
                        "content": "Example 1 clearly explains it - because it happens 23 hours 56 minutes later.\\nIn other words, \"going back in time\" is not allowed.\\nPerhaps, \"Next closest future time\" would make more sense as a problem title."
                    }
                ]
            },
            {
                "id": 1572171,
                "content": [
                    {
                        "username": "chinux23",
                        "content": "why next time for 23:59 is 22:22 not 2:22? I think 2:22 is closer to 23:59 than 22:22. Where am I wrong?"
                    },
                    {
                        "username": "charleslondon",
                        "content": "Because you do not have a zero."
                    },
                    {
                        "username": "CodeHardPlayHard",
                        "content": "Input: \"23:59\"\\n\\nOutput: \"22:22\"\\n\\nInstead of \\n\\nOutput:\"2:2\""
                    },
                    {
                        "username": "devilhtc",
                        "content": "1. If 12:9 is a valid input, why isn\\u2019t 2:2 a valid output? You are treating the input and output in different manners, which should really be formatted in the same way.\\n\\n2. If 12:9 is valid, do we need to convert it to 12:09 before processing so that 0 is a digit we can use? Or in this case we cannot use 0?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "in other words, find the next closest time from a differenet permutation of the digits. How can it be done?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "An excellent question for \"Did you really think about all the edge cases before jumping into coding?\" Cause I sure didnt. Kept having to add to my spaghetti pile"
                    },
                    {
                        "username": "jalfaro",
                        "content": "I have a question for Input  23:59. Why not the closest time  is 23:55?"
                    },
                    {
                        "username": "dnox",
                        "content": "Example 1 clearly explains it - because it happens 23 hours 56 minutes later.\\nIn other words, \"going back in time\" is not allowed.\\nPerhaps, \"Next closest future time\" would make more sense as a problem title."
                    }
                ]
            },
            {
                "id": 1847681,
                "content": [
                    {
                        "username": "chinux23",
                        "content": "why next time for 23:59 is 22:22 not 2:22? I think 2:22 is closer to 23:59 than 22:22. Where am I wrong?"
                    },
                    {
                        "username": "charleslondon",
                        "content": "Because you do not have a zero."
                    },
                    {
                        "username": "CodeHardPlayHard",
                        "content": "Input: \"23:59\"\\n\\nOutput: \"22:22\"\\n\\nInstead of \\n\\nOutput:\"2:2\""
                    },
                    {
                        "username": "devilhtc",
                        "content": "1. If 12:9 is a valid input, why isn\\u2019t 2:2 a valid output? You are treating the input and output in different manners, which should really be formatted in the same way.\\n\\n2. If 12:9 is valid, do we need to convert it to 12:09 before processing so that 0 is a digit we can use? Or in this case we cannot use 0?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "in other words, find the next closest time from a differenet permutation of the digits. How can it be done?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "An excellent question for \"Did you really think about all the edge cases before jumping into coding?\" Cause I sure didnt. Kept having to add to my spaghetti pile"
                    },
                    {
                        "username": "jalfaro",
                        "content": "I have a question for Input  23:59. Why not the closest time  is 23:55?"
                    },
                    {
                        "username": "dnox",
                        "content": "Example 1 clearly explains it - because it happens 23 hours 56 minutes later.\\nIn other words, \"going back in time\" is not allowed.\\nPerhaps, \"Next closest future time\" would make more sense as a problem title."
                    }
                ]
            },
            {
                "id": 1981330,
                "content": [
                    {
                        "username": "chinux23",
                        "content": "why next time for 23:59 is 22:22 not 2:22? I think 2:22 is closer to 23:59 than 22:22. Where am I wrong?"
                    },
                    {
                        "username": "charleslondon",
                        "content": "Because you do not have a zero."
                    },
                    {
                        "username": "CodeHardPlayHard",
                        "content": "Input: \"23:59\"\\n\\nOutput: \"22:22\"\\n\\nInstead of \\n\\nOutput:\"2:2\""
                    },
                    {
                        "username": "devilhtc",
                        "content": "1. If 12:9 is a valid input, why isn\\u2019t 2:2 a valid output? You are treating the input and output in different manners, which should really be formatted in the same way.\\n\\n2. If 12:9 is valid, do we need to convert it to 12:09 before processing so that 0 is a digit we can use? Or in this case we cannot use 0?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "in other words, find the next closest time from a differenet permutation of the digits. How can it be done?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "An excellent question for \"Did you really think about all the edge cases before jumping into coding?\" Cause I sure didnt. Kept having to add to my spaghetti pile"
                    },
                    {
                        "username": "jalfaro",
                        "content": "I have a question for Input  23:59. Why not the closest time  is 23:55?"
                    },
                    {
                        "username": "dnox",
                        "content": "Example 1 clearly explains it - because it happens 23 hours 56 minutes later.\\nIn other words, \"going back in time\" is not allowed.\\nPerhaps, \"Next closest future time\" would make more sense as a problem title."
                    }
                ]
            }
        ]
    },
    {
        "title": "Rabbits in Forest",
        "question_content": "<p>There is a forest with an unknown number of rabbits. We asked n rabbits <strong>&quot;How many rabbits have the same color as you?&quot;</strong> and collected the answers in an integer array <code>answers</code> where <code>answers[i]</code> is the answer of the <code>i<sup>th</sup></code> rabbit.</p>\n\n<p>Given the array <code>answers</code>, return <em>the minimum number of rabbits that could be in the forest</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> answers = [1,1,2]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nThe two rabbits that answered &quot;1&quot; could both be the same color, say red.\nThe rabbit that answered &quot;2&quot; can&#39;t be red or the answers would be inconsistent.\nSay the rabbit that answered &quot;2&quot; was blue.\nThen there should be 2 other blue rabbits in the forest that didn&#39;t answer into the array.\nThe smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn&#39;t.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> answers = [10,10,10]\n<strong>Output:</strong> 11\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= answers.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= answers[i] &lt; 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 114721,
                "title": "c-java-python-easy-and-concise-solution",
                "content": "## Solution 1\\nIf ```x+1``` rabbits have same color, then we get ```x+1``` rabbits who all answer ```x```.\\nnow n rabbits answer x.\\nIf ```n % (x + 1) == 0```, we need ```n / (x + 1)``` groups of ```x + 1``` rabbits.\\nIf ```n % (x + 1) != 0```, we need ```n / (x + 1) + 1``` groups of ```x + 1``` rabbits.\\n\\nthe number of groups is ```math.ceil(n / (x + 1))``` and it equals to ```(n + x) / (x + 1)``` , which is more elegant.\\n\\n**Java**\\n```\\n    public int numRabbits(int[] answers) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        for (int i : answers)\\n            m.put(i, m.getOrDefault(i, 0) + 1);\\n        int res = 0;\\n        for (int i : m.keySet())\\n            res += (m.get(i) + i) / (i + 1) * (i + 1);\\n        return res;\\n    }\\n```\\n**C++**\\n```\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> c;\\n        for (int i : answers) c[i]++;\\n        int res = 0;\\n        for (auto i : c) res += (i.second + i.first) / (i.first + 1) * (i.first + 1);\\n        return res;\\n    }\\n```\\n**Python**\\n```\\n    def numRabbits(self, answers):\\n        c = collections.Counter(answers)\\n        return sum((c[i] + i) / (i + 1) * (i + 1) for i in c)\\n```\\n\\n## Solution 2\\n\\nInspried by @sggkjihua,\\nWe can count the `res` as we loop on the answers.\\n\\n**Java**\\n```\\n    public int numRabbits(int[] answers) {\\n        int c[] = new int[1000], res = 0;\\n        for (int i : answers)\\n            if (c[i]++ % (i + 1) == 0)\\n                res += i + 1;\\n        return res;\\n    }\\n```\\n**C++**\\n```\\n    public int numRabbits(int[] answers) {\\n        int c[] = new int[1000], res = 0;\\n        for (int i : answers)\\n            if (c[i]++ % (i + 1) == 0)\\n                res += i + 1;\\n        return res;\\n    }\\n```\\n**Python**\\n```\\n    def numRabbits(self, answers):\\n        c = collections.Counter()\\n        res = 0\\n        for i in answers:\\n            if c[i] % (i + 1) == 0:\\n                res += i + 1\\n            c[i] += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```x+1```\n```x+1```\n```x```\n```n % (x + 1) == 0```\n```n / (x + 1)```\n```x + 1```\n```n % (x + 1) != 0```\n```n / (x + 1) + 1```\n```x + 1```\n```math.ceil(n / (x + 1))```\n```(n + x) / (x + 1)```\n```\\n    public int numRabbits(int[] answers) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n        for (int i : answers)\\n            m.put(i, m.getOrDefault(i, 0) + 1);\\n        int res = 0;\\n        for (int i : m.keySet())\\n            res += (m.get(i) + i) / (i + 1) * (i + 1);\\n        return res;\\n    }\\n```\n```\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> c;\\n        for (int i : answers) c[i]++;\\n        int res = 0;\\n        for (auto i : c) res += (i.second + i.first) / (i.first + 1) * (i.first + 1);\\n        return res;\\n    }\\n```\n```\\n    def numRabbits(self, answers):\\n        c = collections.Counter(answers)\\n        return sum((c[i] + i) / (i + 1) * (i + 1) for i in c)\\n```\n```\\n    public int numRabbits(int[] answers) {\\n        int c[] = new int[1000], res = 0;\\n        for (int i : answers)\\n            if (c[i]++ % (i + 1) == 0)\\n                res += i + 1;\\n        return res;\\n    }\\n```\n```\\n    public int numRabbits(int[] answers) {\\n        int c[] = new int[1000], res = 0;\\n        for (int i : answers)\\n            if (c[i]++ % (i + 1) == 0)\\n                res += i + 1;\\n        return res;\\n    }\\n```\n```\\n    def numRabbits(self, answers):\\n        c = collections.Counter()\\n        res = 0\\n        for i in answers:\\n            if c[i] % (i + 1) == 0:\\n                res += i + 1\\n            c[i] += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 114715,
                "title": "java-solution-with-hashmap-o-n-and-comments",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        if(answers.length == 0) return 0;\\n        \\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        int sum = 0;\\n        \\n        //For each rabbits answer\\n        for(int i : answers){\\n            if(i == 0 ){\\n                sum += 1;\\n                continue;\\n            }\\n            if(!map.containsKey(i)){\\n                //If we haven't accounted for this rabbit color then account for the one telling us\\n                // as well as the one that rabbit says is that color.\\n                map.put(i, 0);\\n                sum += (i + 1);\\n                \\n            }else{\\n                map.put(i, map.get(i) + 1);\\n                //if there are k of each color then they are all present, remove them to allow the change to account for others.\\n                if(map.get(i) == i){ \\n                    map.remove(i);\\n                }\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        if(answers.length == 0) return 0;\\n        \\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        int sum = 0;\\n        \\n        //For each rabbits answer\\n        for(int i : answers){\\n            if(i == 0 ){\\n                sum += 1;\\n                continue;\\n            }\\n            if(!map.containsKey(i)){\\n                //If we haven't accounted for this rabbit color then account for the one telling us\\n                // as well as the one that rabbit says is that color.\\n                map.put(i, 0);\\n                sum += (i + 1);\\n                \\n            }else{\\n                map.put(i, map.get(i) + 1);\\n                //if there are k of each color then they are all present, remove them to allow the change to account for others.\\n                if(map.get(i) == i){ \\n                    map.remove(i);\\n                }\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137750,
                "title": "one-pass-6ms-c-solution-using-hashmap-very-straight-forward",
                "content": "For rabits with same colors, the answers must be the same. However, when the total amount of that same answer exceeds  \\'that answer + 1\\', there must be a new color. (say [3,3,3,3,3], the first four 3s indicates 4 rabits with the same color. The 5th 3 must represent a new color that contains 4 other rabits). We only calculate the amount of rabits with the same color once. Hashmap is used to record the frequency of the same answers. Once it exceeds the range, we clear the frequency and calculate again.\\n\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        if(answers.empty()) return 0;\\n        unordered_map<int,int> m;\\n        int res=0;\\n        for(int a:answers){\\n            if(a==0) res++;\\n            else{\\n                if(m[a]==0) res+=a+1;\\n                m[a]++;\\n                if(m[a]==a+1) m[a]=0;\\n            }           \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        if(answers.empty()) return 0;\\n        unordered_map<int,int> m;\\n        int res=0;\\n        for(int a:answers){\\n            if(a==0) res++;\\n            else{\\n                if(m[a]==0) res+=a+1;\\n                m[a]++;\\n                if(m[a]==a+1) m[a]=0;\\n            }           \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514693,
                "title": "python3-intuitive-solution-98-43-runtime-100-memory",
                "content": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        d = {}\\n        count = 0\\n        for i in answers:\\n\\t\\t# add 1 if rabbit says 0 other rabbits have same color\\n            if i == 0:\\n                count+=1\\n            else:\\n\\t\\t\\t# check if i is present in dictionary or not \\n\\t\\t\\t# and also check whether the frequency of i and value of i is same or not\\n\\t\\t\\t# For example [2,2,2] and [2,2] has the same result (i.e) 3 but [2,2,2,2] should            \\n\\t\\t\\t# be seperated into two groups and the result will be 6\\n            # So we are again initializing the i value to 0\\n                if i not in d or i == d[i]:\\n                    d[i] = 0\\n                    count+=1 + i\\n                else:\\n                    d[i] += 1\\n                    \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        d = {}\\n        count = 0\\n        for i in answers:\\n\\t\\t# add 1 if rabbit says 0 other rabbits have same color\\n            if i == 0:\\n                count+=1\\n            else:\\n\\t\\t\\t# check if i is present in dictionary or not \\n\\t\\t\\t# and also check whether the frequency of i and value of i is same or not\\n\\t\\t\\t# For example [2,2,2] and [2,2] has the same result (i.e) 3 but [2,2,2,2] should            \\n\\t\\t\\t# be seperated into two groups and the result will be 6\\n            # So we are again initializing the i value to 0\\n                if i not in d or i == d[i]:\\n                    d[i] = 0\\n                    count+=1 + i\\n                else:\\n                    d[i] += 1\\n                    \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114719,
                "title": "my-easy-java-hashmap-solution",
                "content": "```java\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int res = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int answer : answers){\\n            map.put(answer,map.getOrDefault(answer,0)+1);\\n        }\\n        for(Integer n : map.keySet()){\\n            int group = map.get(n)/(n+1);\\n            res += map.get(n)%(n+1) != 0 ? (group+1)*(n+1) : group*(n+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int res = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int answer : answers){\\n            map.put(answer,map.getOrDefault(answer,0)+1);\\n        }\\n        for(Integer n : map.keySet()){\\n            int group = map.get(n)/(n+1);\\n            res += map.get(n)%(n+1) != 0 ? (group+1)*(n+1) : group*(n+1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289038,
                "title": "java-1ms-pigeonhole-principle-solution-with-detailed-explanation",
                "content": "The basic thought is: if answers[i] == anwers[j], we take them as the same color as far as **possible**. \\nWhat does the possible mean? Well, we can see a example: \\nCondider a anwer sequence [2, 2, 2, 2]. According to the **Pigeonhole Principle**, we cannot take all of them as the same color since there are at most 3 pigeonhole and 4 pigeons.\\n\\nThe solution is using a array ```color``` to record the color message. Each time a pigeonhole is full when reset corresponding element in ```color```.\\n\\n```\\npublic int numRabbits(int[] answers) {\\n    int result = 0;\\n    int color[] = new int[1001];\\n    for(int i = 0; i < answers.length; i++) {\\n        if( color[answers[i] + 1] == answers[i] + 1 ) { // a pigeonhole is full\\n            result += answers[i] + 1;\\n            color[answers[i] + 1] = 1;\\n        }\\n        else {\\n            color[answers[i] + 1]++;\\n        }\\n    }\\n    for(int i = 0; i < color.length; i++) // sum the number of colors\\n        result += color[i] != 0 ? i : 0;\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```color```\n```color```\n```\\npublic int numRabbits(int[] answers) {\\n    int result = 0;\\n    int color[] = new int[1001];\\n    for(int i = 0; i < answers.length; i++) {\\n        if( color[answers[i] + 1] == answers[i] + 1 ) { // a pigeonhole is full\\n            result += answers[i] + 1;\\n            color[answers[i] + 1] = 1;\\n        }\\n        else {\\n            color[answers[i] + 1]++;\\n        }\\n    }\\n    for(int i = 0; i < color.length; i++) // sum the number of colors\\n        result += color[i] != 0 ? i : 0;\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 121397,
                "title": "easy-o-n-python-3-with-explanation",
                "content": "Each unique answer means there are at least answer+1 rabbits, e.g. 2 means there are at least 3 rabbits. Each unique answer can at most repeat answer+1 times, e.g. [2, 2, 2], and the least number of rabbits is still 3. But [2,2,2,2] will have at least 6 rabbits. Because the first three answers can be from rabbits with the same color, say red, but the fourth one must be from a different color, say blue, and there are at least 2 other blue rabbits who didn\\'t answer. So we need to find out how many groups of [2,2,2] we can find, which is\\n```\\nmath.ceil(v/(k+1))\\n```\\nand times the number of groups by the number of rabbits in each group which is k + 1.\\n\\n```\\nclass Solution:\\n    def numRabbits(self, answers):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total = 0\\n        d = collections.defaultdict(int)\\n        for ans in answers:\\n            d[ans] += 1\\n        for k, v in d.items():\\n            total += math.ceil(v/(k+1)) * (k+1)\\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nmath.ceil(v/(k+1))\\n```\n```\\nclass Solution:\\n    def numRabbits(self, answers):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        total = 0\\n        d = collections.defaultdict(int)\\n        for ans in answers:\\n            d[ans] += 1\\n        for k, v in d.items():\\n            total += math.ceil(v/(k+1)) * (k+1)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371564,
                "title": "c-o-n-solution-with-detailed-explanation-hashmaps",
                "content": "# Explanation\\nLet\\'s talk about two rabbits, rabbit[i] and rabbit[j]. \\nRabbit[i] says that there are X number of rabbits with the same color as him, and rabbit[j] says that there are Y number of rabbits with the same color as him.\\n\\n**Case 1 - X!=Y** \\nIn this  case, it is pretty straightforward that both of the rabbits are of not the same color, as otherwise we would get an inconsistency. Think about it, if array was like [2,3], rabbit[i] is saying that there are 2 rabbits as same color as him, and rabbit[j] is saying that there are 3 rabbits with same color as him. Obviously both of them are not having the same color. \\n\\nIn this case, we will add (1+2) + (1+3) to our count, (1 for the rabbit[i] to which we were talking, and +2 for the rabbits as same color as him. 1 for the rabbit[j] to which we were talking, and +3 for the rabbits as same color as him. ).\\n\\n**Case 2 - X==Y**\\n\\nIn this case, we will assign both of them the same color, for the sake of getting the minimum number of rabbits.\\nFor example, if the array was like [1,1], we will assume that both rabbits are of the same color (let\\'s say red). \\nHence we will add 2 to our count, (1 for the rabbit to which we were talking, and +1 for the rabbits as same color as him).\\nSimilarly if our array was like [2,2], we will add 3 to our count, (1 for the rabbit to which we were talking, and +2 for the rabbits as same color as him).\\n\\n**But there is more to it**\\nLet\\'s take the example of the array [1,1,1]. Here we can have the first 2 rabbits of the same color, but the third rabbit could not be of the same color. Otherwise there would be some incosistency. \\nLet me show you some pattern.\\n[1] - Add 2 to the count. (1 color sufficient)\\n[1,1]  - Add 2 to the count.  (1 color sufficient)\\n[1,1,1] - Add 4 to the count. (2 colors sufficient)\\n[1,1,1,1] - Add 4 to the count. (2 colors sufficient)\\n[1,1,1,1,1] - Add 6 to the count. (3 colors sufficient)\\n[1,1,1,1,1,1] - Add 6 to the count. (3 colors sufficient)\\n\\nGeneralising the result, if we have an array like [i,i,i,i..], we have **upto i+1 elements that can possibly have the same color and talk about each other** (Like for i=1, we have upto 2 rabbits that can have same color, and that can talk about each other). Hence in our count, we will add something like:\\n```(1+i) * ceil((total count of i\\'s)/(i+1)))```\\nThe second term is for the number of colors that are sufficient, and the first term is about the number of monkeys of a particular color (1 for the rabbit to which we were talking, and +i for the rabbits as same color as him).\\n\\n# Solution\\n\\nWe will maintain an unordered_map that will count the frequency of the elements. After that, we will traverse through each entry in our unordered_map and add to our count, based on the formua which we discussed above.\\n\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int count=0;\\n        unordered_map<int,int> freq;\\n        \\n        for(int i=0;i<answers.size();i++){\\n\\t\\t//If the frequency of same color rabbits is 0,\\n\\t\\t//then we have a unique coloured rabbit and we will directly count it\\n            if(answers[i]==0) count++;\\n            else{\\n                freq[answers[i]]++;\\n            }\\n        }\\n        \\n        for(auto it:freq){\\n            count= count + (it.first+1)*ceil(((float)it.second/(it.first+1)));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```(1+i) * ceil((total count of i\\'s)/(i+1)))```\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int count=0;\\n        unordered_map<int,int> freq;\\n        \\n        for(int i=0;i<answers.size();i++){\\n\\t\\t//If the frequency of same color rabbits is 0,\\n\\t\\t//then we have a unique coloured rabbit and we will directly count it\\n            if(answers[i]==0) count++;\\n            else{\\n                freq[answers[i]]++;\\n            }\\n        }\\n        \\n        for(auto it:freq){\\n            count= count + (it.first+1)*ceil(((float)it.second/(it.first+1)));\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296703,
                "title": "possible-the-most-understandable-solution-and-explanation-no",
                "content": "I don\\'t get it why most upvoted solutions use `%`, it is clearly not natural and the most conform-1st-logic-in-your-mind solution.\\n\\n---\\n**Thinking Process**\\n\\nWhen I read the description, I realized that for a rabit `i` in some color, if she told us that number of other rabits in the same color is `answer[i]`, then the total number of rabits in that color is `answer[i] + 1`. But we cannot add it directly to result `sum`. Why?\\n\\nBecause other rabits in the same color may be also included in the sample `answer`(Since we are told `some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. ` from the description). If so, we will add total sum `answer[i] + 1` multiple times. But actually we only need to add total sum once. This is the case we should solve, we need to find a way to merge them.\\n\\n---\\nThen I considered all the cases that might happen:\\n1. If there are `n` rabits say there are other `n - 1` rabits with the same color, then we can say that all of them are included in the sample `answer`. we can do: `sum += n`\\n2. If `n` rabits say that there are other `n + c` rabits with same color where `c` is just a constant, then these rabits are only part of them, some rabits are not included in the sample. We can do total `sum += n + c + 1`\\n3. Impossible case, note that we cannot say `5` rabits in the same color say they have `2` others rabits. It is not valid because at most `other + 1` can be in the sample which is `3` based on 1st case. So to minimize the number of rabits, we assume `3` rabits are in the same color, others are in other colors.  We divide `5` into `[3, 2]`. Based on the observation, whenever we found all the rabits in the same color in the sample, we remove it from the sample.\\n\\n---\\n**Data Structure**\\n\\n`Map<Integer, Integer> map = new HashMap<>();` to store the pair `<key: # of other rabits in the same color, val: count to answer key>`\\n\\n\\nIf you notice: `Each answers[i] will be an integer in the range [0, 999].`, you can also use `int[] map = new int[1000]`\\n\\n---\\n**Strategy**\\n\\nUse `Map` to keep track of the `<other, count>`, and I think the code below is self-explained well.\\n\\n---\\n**Final Code**\\n\\n```java\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>(); // <other, count>\\n        for(int other : answers){\\n            map.put(other, map.getOrDefault(other, 0) + 1);\\n\\n\\t\\t\\tint count = map.get(other);\\n\\t\\t\\t// case 1: all the rabits are found\\n            if(count == other + 1) {\\n                sum += count;\\n                map.remove(other);\\n            }\\n        }\\n        \\n\\t\\t// case 2: only subset of rabits in the same color found in the sample\\n        for(int other : map.keySet()) sum += other + 1;\\n        \\n        return sum;\\n    }\\n}\\n```\\n\\n---\\nTC: `O(n)`\\nSP: `O(1)`\\n\\n---\\n**One More Thing**\\n\\nIf you have any confusion or any opnion on the description, please comment. I will insist on updating it for at least **100 years**.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>(); // <other, count>\\n        for(int other : answers){\\n            map.put(other, map.getOrDefault(other, 0) + 1);\\n\\n\\t\\t\\tint count = map.get(other);\\n\\t\\t\\t// case 1: all the rabits are found\\n            if(count == other + 1) {\\n                sum += count;\\n                map.remove(other);\\n            }\\n        }\\n        \\n\\t\\t// case 2: only subset of rabits in the same color found in the sample\\n        for(int other : map.keySet()) sum += other + 1;\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862642,
                "title": "hashmap-math-ceil-java",
                "content": "![image](https://assets.leetcode.com/users/images/1b64fdf6-2069-4b4a-8717-02c7fb54d05b_1647673382.113513.png)\\n* **Rabbit saying they have seen x rabbit of same color , means they are part of x+1 size group**\\n![image](https://assets.leetcode.com/users/images/921df072-aa5a-41ef-b372-e42b03ea8615_1647673381.6696496.png)\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int map[] =  new int[1000];\\n        for(int ele : answers){\\n            map[ele]+=1;\\n        }\\n        int rabbit =  0;\\n        \\n        for(int i=0;i<1000;i++){\\n            int grp  = i+1;\\n            int c =  map[i];\\n            int count = (int) Math.ceil( (c*1.0)/grp ) * grp;\\n            rabbit+= count;            \\n        }\\n        return rabbit;\\n    }\\n}\\n\\n// Math.ceil(  ) - gives number of grp \\n// and on multiply  no of group by group size  gives no of rabbit\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int map[] =  new int[1000];\\n        for(int ele : answers){\\n            map[ele]+=1;\\n        }\\n        int rabbit =  0;\\n        \\n        for(int i=0;i<1000;i++){\\n            int grp  = i+1;\\n            int c =  map[i];\\n            int count = (int) Math.ceil( (c*1.0)/grp ) * grp;\\n            rabbit+= count;            \\n        }\\n        return rabbit;\\n    }\\n}\\n\\n// Math.ceil(  ) - gives number of grp \\n// and on multiply  no of group by group size  gives no of rabbit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151934,
                "title": "easy-to-follow-python-solution",
                "content": "I see a lot of difficult to understand python solutions so here\\'s mine. O(n) runtime. \\n```\\ndef numRabbits(self, answers):\\n\\thasSeen = {}\\n\\tresult = 0\\n\\tfor num in answers: \\n\\t\\tif num not in hasSeen:\\n\\t\\t\\tresult += (1 + num)\\n\\t\\t\\thasSeen[num] = num\\n\\t\\telse: \\n\\t\\t\\thasSeen[num] -= 1\\n\\t\\tif hasSeen[num] == 0:\\n\\t\\t\\tdel hasSeen[num]\\n\\treturn result\\n\\t",
                "solutionTags": [],
                "code": "I see a lot of difficult to understand python solutions so here\\'s mine. O(n) runtime. \\n```\\ndef numRabbits(self, answers):\\n\\thasSeen = {}\\n\\tresult = 0\\n\\tfor num in answers: \\n\\t\\tif num not in hasSeen:\\n\\t\\t\\tresult += (1 + num)\\n\\t\\t\\thasSeen[num] = num\\n\\t\\telse: \\n\\t\\t\\thasSeen[num] -= 1\\n\\t\\tif hasSeen[num] == 0:\\n\\t\\t\\tdel hasSeen[num]\\n\\treturn result\\n\\t",
                "codeTag": "Python3"
            },
            {
                "id": 2801207,
                "title": "java-one-pass-simple-solution",
                "content": "# Intuition\\n1. For Any answer we can confirm there is atleast answer+1 rabbit.\\nfor Example: If a rabbit say there are 3 rabbit as same colour as it. We know there are atleast 3 other Rabbit + 1 Rabbit who is answering=4 rabbits\\n2. As we considering minimum rabbit case. At Very max N+1 rabbit can answer \"N\" and can belong to Same colour.\\n# Approach\\n1. We will store all answers in HashMap, as key. And as value we will store how many other rabbits have answered the same. So for example 3 we can say there can be maximum 3 \"other rabbits\" who can answer 3.\\n2. When ever we see a new answer, we can say these rabbits belongs to a unseeen colour group. and we will add answer+1 to our final answer. And we will reset the value for that answer key to 0.\\n\\n# Complexity\\n- Time complexity:\\nO(N) One Pass\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int count=0;\\n        for(int ans: answers){\\n            if(map.getOrDefault(ans,ans)==ans){\\n                count+=ans+1;\\n                map.put(ans,0);\\n            }\\n            else{\\n                map.put(ans,map.get(ans)+1);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int count=0;\\n        for(int ans: answers){\\n            if(map.getOrDefault(ans,ans)==ans){\\n                count+=ans+1;\\n                map.put(ans,0);\\n            }\\n            else{\\n                map.put(ans,map.get(ans)+1);\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448325,
                "title": "4ms-easy-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& a) {\\n        map<int,int>mp;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            mp[a[i]]++;\\n        }\\n        int ans=0;\\n        for(auto i: mp)\\n        {\\n            \\n            if(i.first==0)\\n            {\\n                ans+=i.second;\\n            }\\n            else if(i.first+1<i.second)\\n            {\\n                int p=i.second%(i.first+1);\\n                int k=i.second/(i.first+1);\\n                ans+=k*(i.first + 1);\\n                if(p!=0)\\n                {\\n                    ans+= i.first+1;\\n                }\\n                \\n            }\\n            else\\n            {\\n                ans+=i.first+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\'\\'\\'\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& a) {\\n        map<int,int>mp;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            mp[a[i]]++;\\n        }\\n        int ans=0;\\n        for(auto i: mp)\\n        {\\n            \\n            if(i.first==0)\\n            {\\n                ans+=i.second;\\n            }\\n            else if(i.first+1<i.second)\\n            {\\n                int p=i.second%(i.first+1);\\n                int k=i.second/(i.first+1);\\n                ans+=k*(i.first + 1);\\n                if(p!=0)\\n                {\\n                    ans+= i.first+1;\\n                }\\n                \\n            }\\n            else\\n            {\\n                ans+=i.first+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153119,
                "title": "c-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> map;\\n        int res=0;\\n        for(int answer : answers){\\n            (map.count(answer)==0) ? res+=answer+1 : map[answer]++;\\n            if(map[answer]==answer) map.erase(answer);\\n        }\\n        return res;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> map;\\n        int res=0;\\n        for(int answer : answers){\\n            if(++map[answer] == 1){\\n                res+=answer+1;\\n            }\\n            if(map[answer] == answer+1){\\n                map[answer]=0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> map;\\n        int res=0;\\n        for(int answer : answers){\\n            (map.count(answer)==0) ? res+=answer+1 : map[answer]++;\\n            if(map[answer]==answer) map.erase(answer);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> map;\\n        int res=0;\\n        for(int answer : answers){\\n            if(++map[answer] == 1){\\n                res+=answer+1;\\n            }\\n            if(map[answer] == answer+1){\\n                map[answer]=0;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116484,
                "title": "c-5-lines-single-loop",
                "content": "```\nint numRabbits(vector<int>& answers, int res = 0) {\n    unordered_map<int, int> cnt;\n    for(auto a : answers) {\n        if (cnt[a]++ == 0) res += a + 1; // new color\n        if (cnt[a] > a) cnt[a] = 0; // color is full\n    }\n    return res;\n}\n```",
                "solutionTags": [],
                "code": "```\nint numRabbits(vector<int>& answers, int res = 0) {\n    unordered_map<int, int> cnt;\n    for(auto a : answers) {\n        if (cnt[a]++ == 0) res += a + 1; // new color\n        if (cnt[a] > a) cnt[a] = 0; // color is full\n    }\n    return res;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114714,
                "title": "java-simple-solution",
                "content": "\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer, Double> map = new HashMap();\\n        for (int num : answers) {\\n            map.put(num, map.getOrDefault(num, 0.0) + 1);\\n        }\\n        int res = 0;\\n        for (int key : map.keySet()) {\\n           res += (key + 1) * Math.ceil(map.get(key) / (key + 1));           \\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer, Double> map = new HashMap();\\n        for (int num : answers) {\\n            map.put(num, map.getOrDefault(num, 0.0) + 1);\\n        }\\n        int res = 0;\\n        for (int key : map.keySet()) {\\n           res += (key + 1) * Math.ceil(map.get(key) / (key + 1));           \\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1158508,
                "title": "javascript-solution-map-approach",
                "content": "When I saw this problem, I knew that there would be some mathematical solution to it. However, I could not figure it out. Therefore, I tried to take a logical approach. When a rabbit says that it has 5 other rabbits with the same color, we want to count the number of other rabbits that also says they have 5 other rabbits with the same color. If there are 2 other rabbits that says they also have 5 other rabbits with the same color, then these two rabbits are part of the 5 other rabbits mentioned by the first rabbit. The remaining 3 rabbits are in the forest (a.k.a not present in the array). However, if there are total of 7 rabbits that says that they have 5 other rabbits with the same color, the 7th rabbit is not part of this group. Therefore, we need to reset our counting.\\n\\n```\\nvar numRabbits = function(answers) {\\n    const map = new Map();\\n    let tot = 0;\\n    \\n    for (const answer of answers) {\\n        if (answer === 0) {\\n            tot++;\\n            continue;\\n        }\\n        \\n        if (!map.has(answer)) {\\n            map.set(answer, answer);\\n            tot += answer + 1;\\n        } else {\\n            map.set(answer, map.get(answer) - 1);\\n            \\n            if (map.get(answer) === 0) map.delete(answer);\\n        }\\n    }\\n    return tot;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numRabbits = function(answers) {\\n    const map = new Map();\\n    let tot = 0;\\n    \\n    for (const answer of answers) {\\n        if (answer === 0) {\\n            tot++;\\n            continue;\\n        }\\n        \\n        if (!map.has(answer)) {\\n            map.set(answer, answer);\\n            tot += answer + 1;\\n        } else {\\n            map.set(answer, map.get(answer) - 1);\\n            \\n            if (map.get(answer) === 0) map.delete(answer);\\n        }\\n    }\\n    return tot;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114718,
                "title": "java-7ms-sorting-no-hashmap-o-n-lg-n-and-o-n",
                "content": "```\\npublic int numRabbits(int[] a) {\\n\\tArrays.sort(a);\\n\\tint total = 0, r = 0;\\n\\tfor(int i = 0; i < a.length; i++) {\\n\\t\\tif (r-- == 0 || a[i] != a[i-1]) {\\n\\t\\t\\tr = a[i];\\n\\t\\t\\ttotal += a[i]+1;\\n\\t\\t}\\n\\t}\\n\\treturn total;\\n}\\n```\\n\\nor **2ms**:\\n```\\npublic int numRabbits(int[] answers) {\\n\\tint[] count = new int[1001];\\n\\tint ans = 0;\\n\\tfor(int a : answers) {\\n\\t\\tif ((count[a+1]++ % (a+1)) == 0)\\n\\t\\t\\tans += a+1;\\n\\t}\\n\\treturn ans;\\n\\n\\t// use stream\\n\\t// return Arrays.stream(answers).map(a -> count[a+1]++ % (a+1) == 0 ? a+1 : 0).sum();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numRabbits(int[] a) {\\n\\tArrays.sort(a);\\n\\tint total = 0, r = 0;\\n\\tfor(int i = 0; i < a.length; i++) {\\n\\t\\tif (r-- == 0 || a[i] != a[i-1]) {\\n\\t\\t\\tr = a[i];\\n\\t\\t\\ttotal += a[i]+1;\\n\\t\\t}\\n\\t}\\n\\treturn total;\\n}\\n```\n```\\npublic int numRabbits(int[] answers) {\\n\\tint[] count = new int[1001];\\n\\tint ans = 0;\\n\\tfor(int a : answers) {\\n\\t\\tif ((count[a+1]++ % (a+1)) == 0)\\n\\t\\t\\tans += a+1;\\n\\t}\\n\\treturn ans;\\n\\n\\t// use stream\\n\\t// return Arrays.stream(answers).map(a -> count[a+1]++ % (a+1) == 0 ? a+1 : 0).sum();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732993,
                "title": "easy-greedy-c-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**The approach is simple if one \\uD83D\\uDC07 rabbit  answers 10 then at most 11 \\uD83D\\uDC07 rabbits can answer 10 and they have the same color.**\\nFor example:- **Answer = [1,1,2,2,2,2,2]**\\n2 rabbits answer 1 so it is possible that at most 2 rabbits can answer 1. \\n**[1,1] count = 2(2: answered, 0:Not Answered)**\\n\\n5 rabbits answer 2 so it is possible that at most 3 rabbits can answer 2. \\n**[2,2,2] count = 3 (3: answered, 0:Not Answered)**\\n\\nand the remaining 2 rabbits can be of the same color.\\n**[2,2] count = 3(2: answered, 1:Not Answered)**\\n\\n**Numbers of Rabbits = 2+3+3 = 8**\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& ans) {\\n        unordered_map<int,int> mp;\\n        int res = 0,zeros = 0;\\n        for(auto x : ans)\\n        {\\n          if(x!=0)mp[x]++;\\n          else zeros++;  \\n        }\\n        for(auto x : mp)\\n        {\\n           res = res+(x.first+1)*(x.second/(x.first+1));\\n           if(x.second%(x.first+1)!=0) res+=x.first+1;\\n        } \\n        return res+zeros;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/789245f3-612f-47f9-b992-d546ec711771_1688745728.9837592.jpeg)",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& ans) {\\n        unordered_map<int,int> mp;\\n        int res = 0,zeros = 0;\\n        for(auto x : ans)\\n        {\\n          if(x!=0)mp[x]++;\\n          else zeros++;  \\n        }\\n        for(auto x : mp)\\n        {\\n           res = res+(x.first+1)*(x.second/(x.first+1));\\n           if(x.second%(x.first+1)!=0) res+=x.first+1;\\n        } \\n        return res+zeros;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718961,
                "title": "simple-java-solution-using-hashmap-with-explaination",
                "content": "class Solution {\\n\\t   \\n\\t   **Simple logic is to keep a count of the anwers given by the rabbits and categorize them in goups\\n\\t   Eg : If one rabbit has answered 1 then there must be at least 2 rabbits \\n\\t\\t    Similarly if 3 rabbits have answered 1 then 2 of 3 must belong to one group and leftout 1 would belong to other group\\n\\t\\t\\t\\n\\t\\t\\tTestCase : [10, 10 , 10] , all the rabbits will belong to same group until 10 rabbits have answered 10 \\n\\t\\t\\tif there exits 11th rabbit that answers 10 then it would belong to another group consisting of another 11 rabbits**\\n\\t\\t\\t  \\n\\t   public int numRabbits(int[] answers) {\\n\\t\\t\\tint minRabbits = 0;\\n\\t\\t\\tMap<Integer , Integer> map = new HashMap<>();\\n\\n\\t\\t\\tfor(int ans : answers){\\n\\t\\t\\t\\tint count = map.getOrDefault(ans , 0); //get the count of answer\\n\\n\\t\\t\\t\\tif(count == 0 || count == ans + 1){ // if it is the first rabbit of the group or the group has reached its limit\\n\\t\\t\\t\\t\\tminRabbits += ans + 1; // rabbits count would be ans + 1\\n\\t\\t\\t\\t\\tmap.put(ans , 1); // set the count again to 1\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse // group still has space so simply increment the count\\n\\t\\t\\t\\t\\tmap.put(ans , count + 1); \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn minRabbits;\\n\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n\\t   \\n\\t   **Simple logic is to keep a count of the anwers given by the rabbits and categorize them in goups\\n\\t   Eg : If one rabbit has answered 1 then there must be at least 2 rabbits \\n\\t\\t    Similarly if 3 rabbits have answered 1 then 2 of 3 must belong to one group and leftout 1 would belong to other group\\n\\t\\t\\t\\n\\t\\t\\tTestCase : [10, 10 , 10] , all the rabbits will belong to same group until 10 rabbits have answered 10 \\n\\t\\t\\tif there exits 11th rabbit that answers 10 then it would belong to another group consisting of another 11 rabbits**\\n\\t\\t\\t  \\n\\t   public int numRabbits(int[] answers) {\\n\\t\\t\\tint minRabbits = 0;\\n\\t\\t\\tMap<Integer , Integer> map = new HashMap<>();\\n\\n\\t\\t\\tfor(int ans : answers){\\n\\t\\t\\t\\tint count = map.getOrDefault(ans , 0); //get the count of answer\\n\\n\\t\\t\\t\\tif(count == 0 || count == ans + 1){ // if it is the first rabbit of the group or the group has reached its limit\\n\\t\\t\\t\\t\\tminRabbits += ans + 1; // rabbits count would be ans + 1\\n\\t\\t\\t\\t\\tmap.put(ans , 1); // set the count again to 1\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 465995,
                "title": "cleanest-python-solution-with-explanation",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Sx6_ycPKAn8\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\nCode and writeup here: https://www.swecareers.com/solution/minimum-number-of-rabbits",
                "solutionTags": [],
                "code": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Sx6_ycPKAn8\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\nCode and writeup here: https://www.swecareers.com/solution/minimum-number-of-rabbits",
                "codeTag": "Unknown"
            },
            {
                "id": 114713,
                "title": "u3010simple-python-u3011",
                "content": "The basic idea is to put every rabbit with the same key (answer) into the same group as much as possible. This fails when key+1 (count itself) is smaller than the cnt (please look at the code). That means we have to divide this group into subgroups to hold this cnt. The number of the subgroup is computed from ceil(1.0 x cnt/key), so the total number of all these subgroups under the same key is ceil(1.0 x cnt/key) x key.\\n\\n```\\nfrom collections import Counter\\nfrom math import ceil\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        C=Counter(answers)\\n        res=0\\n        for key,cnt in C.items():\\n            key+=1\\n            res+=ceil(1.0*cnt/key)*key\\n        return int(res)",
                "solutionTags": [],
                "code": "The basic idea is to put every rabbit with the same key (answer) into the same group as much as possible. This fails when key+1 (count itself) is smaller than the cnt (please look at the code). That means we have to divide this group into subgroups to hold this cnt. The number of the subgroup is computed from ceil(1.0 x cnt/key), so the total number of all these subgroups under the same key is ceil(1.0 x cnt/key) x key.\\n\\n```\\nfrom collections import Counter\\nfrom math import ceil\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        C=Counter(answers)\\n        res=0\\n        for key,cnt in C.items():\\n            key+=1\\n            res+=ceil(1.0*cnt/key)*key\\n        return int(res)",
                "codeTag": "Java"
            },
            {
                "id": 3860087,
                "title": "clear-solution-with-comments-java-python",
                "content": "# Intuition\\n* If a rabbit says there are $n$ other rabbits of the same color, we can infer there is a group of $n+1$ rabbits that are the same color.\\n* If $n+2$ rabbits say they are in a group with $n$ other rabbits of the same color, we need to add another $n+1$ rabbits to our total count.\\n\\n# Plan\\n1. Create a hashtable counts\\n2. Set sum = 0 \\n3. For each answer in answers \\n    1. If answer == 0, sum += 1 \\n    2. Else if answer not in counts:\\n        1. counts[answer] = 1 \\n        2. sum += answer + 1\\n    3. Else \\n        1. counts[answer] += 1\\n        2. if counts[answer] > answer,\\n            counts[answer] = 0\\n4. Return sum\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $n$ is the number of answers\\n\\n- Space complexity: $$O(a)$$, where $a$ is the number of distinct answers; $$O(a) \\\\le O(n)$$\\n\\n# Python Code\\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        counts = {}\\n        count = 0\\n\\n        for answer in answers:\\n            if answer == 0:\\n                # This must be the only rabbit of its color.\\n                count += 1\\n            elif answer not in counts or counts[answer] == 0:\\n                # This is the first time the color appears.\\n                counts[answer] = 1\\n                # Add all rabbits having this new color.\\n                count += answer + 1\\n            else:\\n                # Add one to how many times answer occurred.\\n                counts[answer] += 1\\n                if counts[answer] > answer:\\n                    # If n+1 rabbits have said n,\\n                    # this color group is complete.\\n                    counts[answer] = 0\\n        \\n        return count\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        int count = 0;\\n\\n        for (int answer : answers) {\\n            if (answer == 0) {\\n                // This must be the only rabbit of its color.\\n                count++;\\n            } else if (counts.getOrDefault(answer, 0) == 0) {\\n                // This is the first time the color appears.\\n                counts.put(answer, 1);\\n                // Add all rabbits having this color.\\n                count += answer + 1;\\n            } else {\\n                // Add one to how many times answer occurred.\\n                counts.put(answer, counts.get(answer) + 1);\\n                if (counts.get(answer) > answer) {\\n                    // n+1 rabbits have said n, so color done.\\n                    counts.put(answer, 0);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        counts = {}\\n        count = 0\\n\\n        for answer in answers:\\n            if answer == 0:\\n                # This must be the only rabbit of its color.\\n                count += 1\\n            elif answer not in counts or counts[answer] == 0:\\n                # This is the first time the color appears.\\n                counts[answer] = 1\\n                # Add all rabbits having this new color.\\n                count += answer + 1\\n            else:\\n                # Add one to how many times answer occurred.\\n                counts[answer] += 1\\n                if counts[answer] > answer:\\n                    # If n+1 rabbits have said n,\\n                    # this color group is complete.\\n                    counts[answer] = 0\\n        \\n        return count\\n```\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        int count = 0;\\n\\n        for (int answer : answers) {\\n            if (answer == 0) {\\n                // This must be the only rabbit of its color.\\n                count++;\\n            } else if (counts.getOrDefault(answer, 0) == 0) {\\n                // This is the first time the color appears.\\n                counts.put(answer, 1);\\n                // Add all rabbits having this color.\\n                count += answer + 1;\\n            } else {\\n                // Add one to how many times answer occurred.\\n                counts.put(answer, counts.get(answer) + 1);\\n                if (counts.get(answer) > answer) {\\n                    // n+1 rabbits have said n, so color done.\\n                    counts.put(answer, 0);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740641,
                "title": "easy-implementation-using-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        map<int,int>mp;\\n        for(auto i : answers) mp[i]++;\\n        int ans = 0;\\n        for(auto i : mp){\\n            int x = i.first;\\n            int y = i.second;\\n            ans += ( (x+1) * (y/(x+1)) );\\n            if(y%(x+1)) ans += (x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        map<int,int>mp;\\n        for(auto i : answers) mp[i]++;\\n        int ans = 0;\\n        for(auto i : mp){\\n            int x = i.first;\\n            int y = i.second;\\n            ans += ( (x+1) * (y/(x+1)) );\\n            if(y%(x+1)) ans += (x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484709,
                "title": "c-easy-explained-greedy-8-lines-of-code",
                "content": "\\n# Approach\\n\\n# We know that any rabit if he says there are 3 more than like him , which means if we find them we fill count them as single individuals and ex[**3,3,3,3**,3,3,3] the first four got there partners and rest 3 couldnnot but still total unique are 8!\\n# means our pairing should be there the answer would be same for\\n# [3,3,3,3,3] or [3,3,3,3,3,3] means we will use ! \\n    **double un=ceil(double(it->second)/double(it->first+1.00));**\\n               ans+=(it->first+1)*un;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& nums) {\\n      unordered_map<int,int>map;\\n      for(auto x:nums) map[x]++;\\n      int ans=0;\\n       for(auto it=map.begin();it!=map.end();it++){\\n           if(it->second <= it->first){\\n               ans+=it->first+1;\\n           }\\n           else {\\n               double un=ceil(double(it->second)/double(it->first+1.00));\\n               ans+=(it->first+1)*un;\\n           }\\n       }\\n      return ans;\\n           }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& nums) {\\n      unordered_map<int,int>map;\\n      for(auto x:nums) map[x]++;\\n      int ans=0;\\n       for(auto it=map.begin();it!=map.end();it++){\\n           if(it->second <= it->first){\\n               ans+=it->first+1;\\n           }\\n           else {\\n               double un=ceil(double(it->second)/double(it->first+1.00));\\n               ans+=(it->first+1)*un;\\n           }\\n       }\\n      return ans;\\n           }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473215,
                "title": "easy-using-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n      unordered_map<int,int>mp;\\n      int ans=0;\\n      for(auto i:answers)\\n          mp[i]++;\\n    for(auto itr:mp)\\n    {\\n        if(itr.first+1>=itr.second)\\n        ans+=itr.first+1;\\n        else\\n        ans+=ceil(1.0*itr.second/(itr.first+1))*(itr.first+1);\\n        \\n    }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n      unordered_map<int,int>mp;\\n      int ans=0;\\n      for(auto i:answers)\\n          mp[i]++;\\n    for(auto itr:mp)\\n    {\\n        if(itr.first+1>=itr.second)\\n        ans+=itr.first+1;\\n        else\\n        ans+=ceil(1.0*itr.second/(itr.first+1))*(itr.first+1);\\n        \\n    }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804262,
                "title": "3ms-96-6-beats-c-easy-and-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Trying to make a group with same value in array. If group size is larger than value+1 (value in that group) , then modValue will be counted. Extra (value+1 - modValue) will be added to answer if modValue exists.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1.Sort the array first\\n    2.At first consider same value in one color group\\n    3.Count the same value in each group\\n    4.(Count % (value+1) = modValue)\\n    5.If modValue non zero then add ((value+1) - modValue) to extra\\n    6.Finally return array.size + extra \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlong(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        sort(answers.begin() , answers.end());\\n        int cnt = 1,len = 0, sum=0, extra=0;\\n       \\n        for(int i=0; i<answers.size(); i++)\\n        {\\n            if( i==answers.size()-1 || answers[i]!=answers[i+1]){\\n                int modValue;\\n                modValue = cnt%(answers[i]+1);\\n               if(modValue) extra+=(answers[i]+1-modValue);\\n                cnt=1;\\n            }else{\\n                cnt++;\\n            }\\n        }\\n        \\n        return answers.size()+extra ;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        sort(answers.begin() , answers.end());\\n        int cnt = 1,len = 0, sum=0, extra=0;\\n       \\n        for(int i=0; i<answers.size(); i++)\\n        {\\n            if( i==answers.size()-1 || answers[i]!=answers[i+1]){\\n                int modValue;\\n                modValue = cnt%(answers[i]+1);\\n               if(modValue) extra+=(answers[i]+1-modValue);\\n                cnt=1;\\n            }else{\\n                cnt++;\\n            }\\n        }\\n        \\n        return answers.size()+extra ;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478659,
                "title": "c-easy-solution-o-n-with-intution-and-comments",
                "content": "Here is my code.\\n**Intution :**\\nConsider  arr = [1,1,1] \\narr[0] -> means that there is one member with same color as me.\\narr[1] -> means that there is one member with same color as me.\\nwhich means there are two members with same color.\\nEven though arr[2] is \\'1\\', it doesn\\'t meant that it is same color as arr[0], arr[1] because arr[0] tells that there is one member who is same as itself(i.e arr[1]). So the arr[2] is considered to be a new color which tells there is one more member as itself.\\nFor every i, the maximum no.of.rabbit with same color is i + 1.\\nSo check the count of each but there is a possibility that count of i is greater that itself like in the above example.\\nSo divide and use ceil to find how many rabbits can be possibe and add it to the result.\\n**Code :**\\n\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> mpp;\\n\\t\\t// Get the count of i + 1\\n        for(auto i : answers) mpp[i+1]++;\\n        int ans = 0;\\n        for(auto i : mpp){\\n            int t1 = i.first;\\n            int t2 = i.second;\\n            int res = t2 / t1;\\n\\t\\t\\t// using Ceil function\\n            if(t2 % t1 != 0) res++;\\n            ans += (res * t1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease UPVOTE if it helps you.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> mpp;\\n\\t\\t// Get the count of i + 1\\n        for(auto i : answers) mpp[i+1]++;\\n        int ans = 0;\\n        for(auto i : mpp){\\n            int t1 = i.first;\\n            int t2 = i.second;\\n            int res = t2 / t1;\\n\\t\\t\\t// using Ceil function\\n            if(t2 % t1 != 0) res++;\\n            ans += (res * t1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186012,
                "title": "simple-solution-easy-o-n-using-map-counter-python",
                "content": "Please Upvote if you liked my solution\\n\\n\\tdef numRabbits(self, ans: List[int]) -> int:\\n\\t\\t\\tresult=0\\n\\t\\t\\td=Counter(ans)    # Inbuilt function to form dictionary/Map\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>i+1:    \\n\\t\\t\\t\\t\\ttemp=ceil(j/(i+1))\\n\\t\\t\\t\\t\\tresult+= temp*(i+1)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult+= i+1\\n\\t\\t\\treturn result",
                "solutionTags": [
                    "Python"
                ],
                "code": "Please Upvote if you liked my solution\\n\\n\\tdef numRabbits(self, ans: List[int]) -> int:\\n\\t\\t\\tresult=0\\n\\t\\t\\td=Counter(ans)    # Inbuilt function to form dictionary/Map\\n\\t\\t\\tfor i,j in d.items():\\n\\t\\t\\t\\tif j>i+1:    \\n\\t\\t\\t\\t\\ttemp=ceil(j/(i+1))\\n\\t\\t\\t\\t\\tresult+= temp*(i+1)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tresult+= i+1\\n\\t\\t\\treturn result",
                "codeTag": "Python3"
            },
            {
                "id": 2055021,
                "title": "c-easy-solution-with-explanation",
                "content": "**Code**\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        map<int, int> mp;\\n        for(auto i: answers) {\\n            mp[i]++;\\n        }\\n        int ans = 0;\\n        for(auto i: mp) {\\n            int x = i.first, n = i.second;\\n            x++;\\n            int a = n/x;\\n            if(n%x) a++;\\n            ans += a*x;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Explanation**\\nIf `n` rabbits answer `x`, then it can be shown that there will be a minimum of `ceil(n/(x+1))*(x+1)` rabbits. The following example can be helpful to understand it, where L.H.S is the answers and R.H.S is the minimum number of rabbits for given answers:\\n```\\n[1] -> 2\\n[1,1] -> 2\\n[1,1,1] -> 4\\n[1,1,1,1] -> 4\\n\\n[2] -> 3\\n[2,2] -> 3\\n[2,2,2] -> 3\\n[2,2,2,2] -> 6\\n\\n[x] -> x+1\\n[x,...,x] (x+1 times) -> x+1\\n[x,...,x] (2*(x+1)\\u2265n>x+1 times) -> 2*(x+1)\\n[x,...,x] (n times) -> ceil(n/(x+1))*(x+1)\\n```\\n> So, by using map, `n` number of rabbits who have answered `x` can be found. And we can get the answer after adding minimum number of rabbits for different values of `x`.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        map<int, int> mp;\\n        for(auto i: answers) {\\n            mp[i]++;\\n        }\\n        int ans = 0;\\n        for(auto i: mp) {\\n            int x = i.first, n = i.second;\\n            x++;\\n            int a = n/x;\\n            if(n%x) a++;\\n            ans += a*x;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n[1] -> 2\\n[1,1] -> 2\\n[1,1,1] -> 4\\n[1,1,1,1] -> 4\\n\\n[2] -> 3\\n[2,2] -> 3\\n[2,2,2] -> 3\\n[2,2,2,2] -> 6\\n\\n[x] -> x+1\\n[x,...,x] (x+1 times) -> x+1\\n[x,...,x] (2*(x+1)\\u2265n>x+1 times) -> 2*(x+1)\\n[x,...,x] (n times) -> ceil(n/(x+1))*(x+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897184,
                "title": "rabbits-in-forest",
                "content": "```\\nYou have to simply find the frequency of the element.\\nlike if i have [1,1] means i have one rabbit of x colour and other one is also exist having same colour.\\nso total number of rabbits can be 2 \\nbecause first one is telling one other is exist and other one is the first one is exist.\\nThis is the way to get minimum number of rabbits.\\n\\nanother example \\n[2,2,2,1]\\nx1 will say x2,x3 exist of same colour and x2 will feel the same \\na rabbit x colour exist and 2 other of same colour exist.\\nso at end of index 2 we will have only 3 rabbits.\\nthen we will find another rabbit of y colour\\nso total will be four.\\n\\nif(freq % num[x]+1 ==0 like the case above \\nThen i have to multiply count with nums[x]+1(nums[x] are other rabbits and 1 is rabbit already there.\\n```\\n```\\nclass Solution \\n{\\n public:\\n    int numRabbits(vector<int>& nums) \\n    {\\n        map<int,int>mp; \\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]]++;\\n        for(auto i=mp.begin();i!=mp.end();i++)\\n        {\\n            int count;\\n            if(i->second%(i->first+1)==0)\\n               count=i->second/(i->first+1);\\n            else\\n                count=i->second/(i->first+1)+1;\\n            ans=ans+count*(i->first+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nYou have to simply find the frequency of the element.\\nlike if i have [1,1] means i have one rabbit of x colour and other one is also exist having same colour.\\nso total number of rabbits can be 2 \\nbecause first one is telling one other is exist and other one is the first one is exist.\\nThis is the way to get minimum number of rabbits.\\n\\nanother example \\n[2,2,2,1]\\nx1 will say x2,x3 exist of same colour and x2 will feel the same \\na rabbit x colour exist and 2 other of same colour exist.\\nso at end of index 2 we will have only 3 rabbits.\\nthen we will find another rabbit of y colour\\nso total will be four.\\n\\nif(freq % num[x]+1 ==0 like the case above \\nThen i have to multiply count with nums[x]+1(nums[x] are other rabbits and 1 is rabbit already there.\\n```\n```\\nclass Solution \\n{\\n public:\\n    int numRabbits(vector<int>& nums) \\n    {\\n        map<int,int>mp; \\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n            mp[nums[i]]++;\\n        for(auto i=mp.begin();i!=mp.end();i++)\\n        {\\n            int count;\\n            if(i->second%(i->first+1)==0)\\n               count=i->second/(i->first+1);\\n            else\\n                count=i->second/(i->first+1)+1;\\n            ans=ans+count*(i->first+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855840,
                "title": "c-easy-to-understand",
                "content": "int numRabbits(vector<int>& answers) {\\n        \\n    int maxi = -1;\\n\\n    for(int i=0; i<answers.size(); i++){\\n        maxi = max(maxi, answers[i]);\\n    }\\n\\n    vector<int> store(maxi+1, 0);\\n\\n    for(int i=0; i<answers.size(); i++){\\n        store[answers[i]]++;\\n    }\\n\\n    int ans = store[0];\\n\\n    for(int i=1; i<store.size(); i++){\\n\\n        // When few rabits say that there are lots of rabits like them\\n        if(store[i] != 0 && store[i] <= i){\\n            ans += i + 1;\\n        }\\n\\n        // When lots of rabits say that there are few rabits like them\\n        else if(store[i] > i){\\n            ans += store[i];\\n            \\n            int remaining = store[i] % (i+1);\\n            \\n            if(remaining != 0){\\n                int need = i + 1 - remaining;\\n                ans += need;\\n            }\\n            \\n        }\\n    }\\n\\n    return ans;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "int numRabbits(vector<int>& answers) {\\n        \\n    int maxi = -1;\\n\\n    for(int i=0; i<answers.size(); i++){\\n        maxi = max(maxi, answers[i]);\\n    }\\n\\n    vector<int> store(maxi+1, 0);\\n\\n    for(int i=0; i<answers.size(); i++){\\n        store[answers[i]]++;\\n    }\\n\\n    int ans = store[0];\\n\\n    for(int i=1; i<store.size(); i++){\\n\\n        // When few rabits say that there are lots of rabits like them\\n        if(store[i] != 0 && store[i] <= i){\\n            ans += i + 1;\\n        }\\n\\n        // When lots of rabits say that there are few rabits like them\\n        else if(store[i] > i){\\n            ans += store[i];\\n            \\n            int remaining = store[i] % (i+1);\\n            \\n            if(remaining != 0){\\n                int need = i + 1 - remaining;\\n                ans += need;\\n            }\\n            \\n        }\\n    }\\n\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1333713,
                "title": "c-solution-using-hashmap",
                "content": "```\\nint numRabbits(vector<int>& answers) {\\n        unordered_map<int,int>m;//to store freq of each answer\\n        for(int i=0;i<answers.size();i++){\\n            m[answers[i]]++;\\n        }\\n        int ans=0;\\n        for(auto x:m){\\n            if((x.second%(x.first+1))==0)\\n                ans+=(x.second/(x.first+1))*(x.first+1);\\n            else\\n                ans+=(x.second/(x.first+1))*(x.first+1)+(x.first+1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint numRabbits(vector<int>& answers) {\\n        unordered_map<int,int>m;//to store freq of each answer\\n        for(int i=0;i<answers.size();i++){\\n            m[answers[i]]++;\\n        }\\n        int ans=0;\\n        for(auto x:m){\\n            if((x.second%(x.first+1))==0)\\n                ans+=(x.second/(x.first+1))*(x.first+1);\\n            else\\n                ans+=(x.second/(x.first+1))*(x.first+1)+(x.first+1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310625,
                "title": "java-solution-with-explanation",
                "content": "Initially We are taking all the answer of rabbit in **hashmap and counting its** occurence.\\n\\nthinking :\\nlet  the arr be: [4,4,4,4,4,4]\\n\\nNow we can see that there are 5 rabbits with first 5 Occurence 4\\'s **[4,4,4,4,4**,4] with one color **(5 as answer giving rabbit is also counted)**\\n\\nSo what about last 4 ie[4,4,4,4,4,**4]**?\\n**That last 4 will be unique color rabbit .**\\nSo final ans will be 5+5=10\\n\\nHence we can say that we can find the minimum no of rabbits by Making this algorithm\\ncount=count+((e.getKey()+1)*(e.getValue()/(e.getKey()+1)));  > dividing rabbit ans with its total occurence .\\nIf **occurence %key !=0** i.e (e.getValue()%(e.getKey()+1)!=0)->It means there is one unique color rabbit not seen in the array. we add the rabbit count as seen in previous example [4,4,4,4,4,**4]**\\n\\nIf found useful **Upvote.** Comment your doubts if any.\\n**Thank you. **\\n```\\nclass Solution {\\n    public int numRabbits(int[] arr) {\\n        int count=0;\\n        Map<Integer,Integer> h=new HashMap<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            h.put(arr[i],h.getOrDefault(arr[i],0)+1);\\n        }\\n        for(Map.Entry<Integer,Integer> e:h.entrySet())\\n        {\\n          count=count+((e.getKey()+1)*(e.getValue()/(e.getKey()+1)));\\n            if(e.getValue()%(e.getKey()+1)!=0)\\n            {\\n                count+=e.getKey()+1;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] arr) {\\n        int count=0;\\n        Map<Integer,Integer> h=new HashMap<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            h.put(arr[i],h.getOrDefault(arr[i],0)+1);\\n        }\\n        for(Map.Entry<Integer,Integer> e:h.entrySet())\\n        {\\n          count=count+((e.getKey()+1)*(e.getValue()/(e.getKey()+1)));\\n            if(e.getValue()%(e.getKey()+1)!=0)\\n            {\\n                count+=e.getKey()+1;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678269,
                "title": "python3-2-liner-rabbits-in-forest",
                "content": "Some explanation:\\n\\nIf `k` is different, then color must be different.\\n\\nIf `k` is the same, the color may be different or the same. If `v` is small, then all the rabbits that see `k` may all be the same color. If `v` is big enough, then they can\\'t all be the same color. For example, if there are 10 rabbits with the same color and all of them report the color they see, then 10 of them see 9 rabbits with the same color. So `k = 9` and `v = 10`. However, if 11 rabbits report that they each see 9 rabbits with the same color, then there can\\'t be just 10 rabbits. There must be another 10 rabbits with a different color. So that\\'s 20 rabbits.\\n\\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        c = Counter(answers)\\n        return sum((v + k) // (k+1) * (k+1) for k, v in c.items())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        c = Counter(answers)\\n        return sum((v + k) // (k+1) * (k+1) for k, v in c.items())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 217862,
                "title": "python-simple-code-beats-100",
                "content": "The rationale behind this approach is that we first find frequncies of each group. Then we apply the logic that there can be atmost n+1 rabbits in groups which say that there are n rabbits in them.\\n\\nExample:   if you have input as [4,4,4,4,4]   The answer of this is 5 because you checked with each rabbit and they said there are 4 others. So total 5. \\n\\nNow if there are any more inputs of 4 value , it means that they are from another group and hence I am dividing.\\n\\nIf there are only 2 more groups of 4 (there were 5 from up above), it still means that there are 5 more rabbits and hence I have done ceil(7/(4+1))*(4+1) = 2 * 5 = 10 \\n\\n```\\n\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        di={}\\n        for ans in answers:\\n            if ans not in di:\\n                di[ans]=1\\n            else:\\n                di[ans]+=1\\n        count=0\\n        for key,val in di.iteritems():\\n            count+=math.ceil(val/(key+1.0))*(key+1)\\n        \\n        return int(count)\\n            \\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        di={}\\n        for ans in answers:\\n            if ans not in di:\\n                di[ans]=1\\n            else:\\n                di[ans]+=1\\n        count=0\\n        for key,val in di.iteritems():\\n            count+=math.ceil(val/(key+1.0))*(key+1)\\n        \\n        return int(count)\\n            \\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129310,
                "title": "python-easy-peasy-4-lines-simple-and-clear-solution-36-ms-beats-99",
                "content": "*  For each statement in the list, add stated group population to result. If stated population more than registered group population with new spoken person, add new population to register and result. \\n```\\nclass Solution:\\n    def numRabbits(self, answers):\\n        dic, res = {}, 0\\n        for ans in answers:\\n            (dic[ans], res) = (1, res + ans + 1) if ans not in dic or dic[ans] > ans else (dic[ans] + 1, res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers):\\n        dic, res = {}, 0\\n        for ans in answers:\\n            (dic[ans], res) = (1, res + ans + 1) if ans not in dic or dic[ans] > ans else (dic[ans] + 1, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123206,
                "title": "java-4-liner-no-hashmap",
                "content": "```\\n    public int numRabbits(int[] answers) {\\n        int scores[] = new int[1000], res = 0;\\n        for(int num : answers) scores[num] = (scores[num]+1) % (num+1); \\n        for(int i = 0; i < 1000; i++) if(scores[i] != 0) res += i+1-scores[i];\\n        return answers.length + res;\\n    }\\n```\\n\\n1. first for loop - counts the number of \"rabbits\" with the same color in order to know how many \"rabbits\" with the same color are missing and didn\\'t give an answer.   \\n2. second loop - counts for each number how many \"rabbits\" are missing from the \"answers\" array.\\n3. returning missing rabbits + the rabbits who gave an answer.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public int numRabbits(int[] answers) {\\n        int scores[] = new int[1000], res = 0;\\n        for(int num : answers) scores[num] = (scores[num]+1) % (num+1); \\n        for(int i = 0; i < 1000; i++) if(scores[i] != 0) res += i+1-scores[i];\\n        return answers.length + res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114717,
                "title": "c-clean-code-with-explanation",
                "content": "\\n1. each rabbit is essentially reporting the `group` size of its color;\\n2. if 2 rabbit have same color, they must report same group size;\\n3. if 2 rabbit report same group size, they might not share the same color;\\n4. if more than `n` rabbit report group size n, there must be more than just 1 group of size `n`, by at least 1 more group of size n;\\n5. if more than `m*n` (say, `m*n+k` | `0 < k < n`) rabbit report group size `n`, there must be more than just `m` groups of size `n`, by at least 1 more group of size `n`; in such case the minimum number of rabbits in a group size of `n` (regardless which group), is `m * n + n`;\\n\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        map<int, int> reporters; // reporters[n] : number of reporters report a group size of n\\n        for (int ans : answers) reporters[ans + 1]++;\\n        int minnum = 0;\\n        for (auto& p : reporters) {\\n            int n = p.first, num = p.second; // n: group size of same color, num: num of rabbits with same answer.\\n            minnum += num / n * n + (num % n ? n : 0);\\n        }\\n        return minnum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        map<int, int> reporters; // reporters[n] : number of reporters report a group size of n\\n        for (int ans : answers) reporters[ans + 1]++;\\n        int minnum = 0;\\n        for (auto& p : reporters) {\\n            int n = p.first, num = p.second; // n: group size of same color, num: num of rabbits with same answer.\\n            minnum += num / n * n + (num % n ? n : 0);\\n        }\\n        return minnum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114710,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\\n        int sum = 0;\\n        for(Integer num : answers){\\n            int count = counts.getOrDefault(num+1, 0);\\n            if(count%(num+1)==0) sum+=(num+1);\\n            if(count < num+1)\\n                counts.put(num + 1, count+1);\\n            else\\n                counts.put(num+1,1);\\n        } \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\\n        int sum = 0;\\n        for(Integer num : answers){\\n            int count = counts.getOrDefault(num+1, 0);\\n            if(count%(num+1)==0) sum+=(num+1);\\n            if(count < num+1)\\n                counts.put(num + 1, count+1);\\n            else\\n                counts.put(num+1,1);\\n        } \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019369,
                "title": "best-java-solution-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRabbits(int[] arr) {\\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n\\n        int n = arr.length;\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(arr[i]==0){\\n                ans++;\\n                continue;\\n            }\\n            hp.put(arr[i],hp.getOrDefault(arr[i],0)+1);\\n        }\\n\\n        \\n\\n        for(var a : hp.keySet()){\\n            int x = hp.get(a);\\n            ans += (a+1)*(int)Math.ceil((double)x/(double)(a+1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] arr) {\\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n\\n        int n = arr.length;\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(arr[i]==0){\\n                ans++;\\n                continue;\\n            }\\n            hp.put(arr[i],hp.getOrDefault(arr[i],0)+1);\\n        }\\n\\n        \\n\\n        for(var a : hp.keySet()){\\n            int x = hp.get(a);\\n            ans += (a+1)*(int)Math.ceil((double)x/(double)(a+1));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479073,
                "title": "worst-solution-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int count=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<answers.size();i++)\\n        {\\n            if(answers[i]==0)\\n            count++;\\n            else\\n            {\\n                mp[answers[i]]++;\\n            }\\n        }\\n\\n        for(auto it:mp)\\n        {\\n           if(it.second>=it.first+2)\\n           {\\n            count=count+(it.second/(it.first+1))*(it.first+1);\\n            if(it.second%(it.first+1))\\n            count=count+it.first+1;\\n           } \\n            else\\n            {\\n                count=count+it.first+1;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int count=0;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<answers.size();i++)\\n        {\\n            if(answers[i]==0)\\n            count++;\\n            else\\n            {\\n                mp[answers[i]]++;\\n            }\\n        }\\n\\n        for(auto it:mp)\\n        {\\n           if(it.second>=it.first+2)\\n           {\\n            count=count+(it.second/(it.first+1))*(it.first+1);\\n            if(it.second%(it.first+1))\\n            count=count+it.first+1;\\n           } \\n            else\\n            {\\n                count=count+it.first+1;\\n            }\\n\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465682,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        map<int, int> count;\\n        for(int ans : answers) {\\n            count[ans]++;\\n        }\\n        int totalRabbits = 0;\\n        for(auto it = count.begin(); it != count.end(); ++it) {\\n            int ans = it->first;\\n            int cnt = it->second;\\n            totalRabbits += (ans+1) * ceil(cnt/(ans+1.0));\\n        }\\n        return totalRabbits;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        answers.sort()\\n        ret = needed = 0\\n        pre = -1\\n        for a in answers:\\n            if a == pre and needed > 0:\\n                needed -= 1\\n            else:\\n                ret += a + 1\\n                needed = a \\n                pre = a \\n        return ret\\n```\\n\\n```Java []\\nclass Solution {\\n  public int numRabbits(int[] answers) {\\n    int max = 0; \\n    int freq[] = new int [1001];\\n    for( int r : answers){\\n      if( r == 0)max++;\\n      else if( freq[r] > 0 && freq[r] == r) freq[r] = 0;\\n      else if( freq[r] == 0) { max += r+1; freq[r]++; }\\n      else freq[r]++;\\n    }\\n    return max;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        map<int, int> count;\\n        for(int ans : answers) {\\n            count[ans]++;\\n        }\\n        int totalRabbits = 0;\\n        for(auto it = count.begin(); it != count.end(); ++it) {\\n            int ans = it->first;\\n            int cnt = it->second;\\n            totalRabbits += (ans+1) * ceil(cnt/(ans+1.0));\\n        }\\n        return totalRabbits;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        answers.sort()\\n        ret = needed = 0\\n        pre = -1\\n        for a in answers:\\n            if a == pre and needed > 0:\\n                needed -= 1\\n            else:\\n                ret += a + 1\\n                needed = a \\n                pre = a \\n        return ret\\n```\n```Java []\\nclass Solution {\\n  public int numRabbits(int[] answers) {\\n    int max = 0; \\n    int freq[] = new int [1001];\\n    for( int r : answers){\\n      if( r == 0)max++;\\n      else if( freq[r] > 0 && freq[r] == r) freq[r] = 0;\\n      else if( freq[r] == 0) { max += r+1; freq[r]++; }\\n      else freq[r]++;\\n    }\\n    return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176751,
                "title": "c-without-sorting",
                "content": "class Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int , int> map;\\n        for(int val : answers){\\n            map[val]++;\\n        }\\n        int ans = 0;\\n        for(auto it : map){\\n            ans += ((it.second + (it.first + 1) - 1) / (it.first + 1)) * (it.first + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int , int> map;\\n        for(int val : answers){\\n            map[val]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2826083,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        sort(answers.begin() , answers.end());\\n        int cnt = 1,len = 0, sum=0, extra=0;\\n       \\n        for(int i=0; i<answers.size(); i++)\\n        {\\n            if( i==answers.size()-1 || answers[i]!=answers[i+1]){\\n                int modValue;\\n                modValue = cnt%(answers[i]+1);\\n               if(modValue) extra+=(answers[i]+1-modValue);\\n                cnt=1;\\n            }else{\\n                cnt++;\\n            }\\n        }\\n        \\n        return answers.size()+extra ;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        sort(answers.begin() , answers.end());\\n        int cnt = 1,len = 0, sum=0, extra=0;\\n       \\n        for(int i=0; i<answers.size(); i++)\\n        {\\n            if( i==answers.size()-1 || answers[i]!=answers[i+1]){\\n                int modValue;\\n                modValue = cnt%(answers[i]+1);\\n               if(modValue) extra+=(answers[i]+1-modValue);\\n                cnt=1;\\n            }else{\\n                cnt++;\\n            }\\n        }\\n        \\n        return answers.size()+extra ;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645765,
                "title": "4ms-c-90-time-beats",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        for(auto &i: answers){\\n            mp[i]++;\\n        }\\n        for(auto &i: mp){\\n            ans += ceil((float)i.second/(i.first+1))*(i.first+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        for(auto &i: answers){\\n            mp[i]++;\\n        }\\n        for(auto &i: mp){\\n            ans += ceil((float)i.second/(i.first+1))*(i.first+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642724,
                "title": "python3-using-dictionary",
                "content": "class Solution:\\n\\n    def numRabbits(self, answers: List[int]) -> int:\\n        maps = Counter(answers)\\n        res = 0\\n        for key,value in maps.items():\\n            res+=(key+1)*ceil(value/(key+1))\\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def numRabbits(self, answers: List[int]) -> int:\\n        maps = Counter(answers)\\n        res = 0\\n        for key,value in maps.items():\\n            res+=(key+1)*ceil(value/(key+1))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2612762,
                "title": "frequency-count-fast-o-n-c",
                "content": "This problem is quite interesting, actually we have to minimize the number of rabbits so we have to group them together. Let\\'s say that a rabbit said that there are two other rabits that have the same color like him and there are two other rabbits saying the same it means that there are in total 3 rabbits that have the same color. So our approach is very simple, we sort the array and count the every group and then try to group them together in as minimum way as possible.\\n\\n##### **Approach:**\\n1. Sort the array\\n2. Initilialize count variable with 1 as first value is always to be counted\\n3. Traverse the loop and count the numbers \\n4. Once two distinct are found we are going to group all of them together and to do this we suppose that they are talking about each other so we divide them by the **ith number + 1** (number of rabbits he says that have same color as him and plus himself) ands we say this number \\'**t**\\' **Formula => (count / t + (count % t > 0) ) * t;**\\n\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& a) {\\n        sort(a.begin(),a.end()); // Sort The Values\\n        int ans = 0,count = 1; // Initilize Variables\\n        for (int i = 1; i < a.size(); ++i) {\\n            if (a[i] != a[i-1]) { // Checking If Previous Value is Equal To Current\\n                int t = a[i-1] + 1; // Store Total Amount Of Rabits\\n                ans += ((count/t) + (count%t > 0))*t; // Formula\\n                count = 1;\\n            }\\n            else ++count;\\n        }\\n        int t = a[a.size() -1] + 1;\\n        ans += ((count/t) + (count%t > 0))*t;\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nif you got it, please consider upvoting,\\nif you didn\\'t, please ask your quries in comments bellow",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& a) {\\n        sort(a.begin(),a.end()); // Sort The Values\\n        int ans = 0,count = 1; // Initilize Variables\\n        for (int i = 1; i < a.size(); ++i) {\\n            if (a[i] != a[i-1]) { // Checking If Previous Value is Equal To Current\\n                int t = a[i-1] + 1; // Store Total Amount Of Rabits\\n                ans += ((count/t) + (count%t > 0))*t; // Formula\\n                count = 1;\\n            }\\n            else ++count;\\n        }\\n        int t = a[a.size() -1] + 1;\\n        ans += ((count/t) + (count%t > 0))*t;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377660,
                "title": "c-t-c-o-nlog-n-s-c-o-1-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int numRabbits(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        int rabbits=0;\\n        int prevRabbit=0;\\n        int stretch=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==0){rabbits++;continue;}\\n            if(prevRabbit < nums[i]+1){\\n                rabbits+=nums[i]+1;\\n                prevRabbit=nums[i]+1;\\n                stretch=1;\\n            }else{\\n                if(stretch == prevRabbit){\\n                    rabbits+=nums[i]+1;\\n                    prevRabbit=nums[i]+1;\\n                    stretch=1;\\n                }else stretch++;\\n            }\\n        }\\n        return rabbits;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int numRabbits(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        int rabbits=0;\\n        int prevRabbit=0;\\n        int stretch=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]==0){rabbits++;continue;}",
                "codeTag": "Java"
            },
            {
                "id": 2369933,
                "title": "python-easy-solution-with-hash-map-with-diagram",
                "content": "Example:\\nIf the answer is [2] or [2, 2] or [2, 2, 2], it means there will be 3 rabbits of same color (green here).\\nFor answer [2, 2, 2, 2], there has to be 2 groups min of 3 rabbits each.\\n\\n![image](https://assets.leetcode.com/users/images/4f6f94db-e927-4aff-b501-4d23ca6be031_1659452866.509023.png)\\n\\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        # store ans in ans_map\\n        ans_map = collections.Counter(answers)\\n        total = 0\\n        for ans, count in ans_map.items():\\n            total += (ans + 1) * ceil(count / (ans + 1))\\n        return total\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        # store ans in ans_map\\n        ans_map = collections.Counter(answers)\\n        total = 0\\n        for ans, count in ans_map.items():\\n            total += (ans + 1) * ceil(count / (ans + 1))\\n        return total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228003,
                "title": "easy-and-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& res) {\\n        unordered_map<int,int>mp;\\n        for(auto x:res) mp[x]++;\\n        int ans = 0;\\n        for(auto [x,y]:mp){\\n            int grp = (y+x)/(x+1);\\n            ans += grp*(x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& res) {\\n        unordered_map<int,int>mp;\\n        for(auto x:res) mp[x]++;\\n        int ans = 0;\\n        for(auto [x,y]:mp){\\n            int grp = (y+x)/(x+1);\\n            ans += grp*(x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173812,
                "title": "simple-c-code-o-n",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> mp;\\n        for(int &ans : answers)\\n            mp[ans]++;\\n        int cnt = 0;\\n        for(auto &[fst, snd] : mp)\\n        {\\n            if(snd%(fst+1) == 0)\\n            {\\n                cnt += snd;\\n            }\\n            else\\n            {\\n                int num = snd/(fst+1);\\n                num = (num+1)*(fst+1);\\n                cnt += num;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> mp;\\n        for(int &ans : answers)\\n            mp[ans]++;\\n        int cnt = 0;\\n        for(auto &[fst, snd] : mp)\\n        {\\n            if(snd%(fst+1) == 0)\\n            {\\n                cnt += snd;\\n            }\\n            else\\n            {\\n                int num = snd/(fst+1);\\n                num = (num+1)*(fst+1);\\n                cnt += num;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159473,
                "title": "easy-java-solution-with-o-n-hashmap-and-basic-number-theory-with-comments",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n        \\n        for(int i=0; i < answers.length; i++){\\n            map.put(answers[i], map.getOrDefault(answers[i], 0)+1);\\n        }\\n        int minr=0;\\n        \\n        for(int val: map.keySet()){\\n            int q = map.get(val) / (val+1); //quotient \\n            minr += q* (val+1);               \\n            int r= map.get(val) % (val+1); //remainder\\n            if(r!=0)\\n                minr+= (val+1);\\n            \\n        }\\n        return minr;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n        \\n        for(int i=0; i < answers.length; i++){\\n            map.put(answers[i], map.getOrDefault(answers[i], 0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2143035,
                "title": "basic-easy-python-dictionary",
                "content": "Please upvote if you find it helpful!\\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        n = len(answers)\\n        res = 0\\n        d = {}\\n        for i in range (n):\\n            try:\\n                d[answers[i]] += 1\\n            except:\\n                d[answers[i]] = 1\\n        for x in d:\\n            while d[x] >= x+1:\\n                print(res, \"res at \",x)\\n                res += (x+1)\\n                d[x] = d[x] - (x+1)\\n            else:\\n                if d[x] > 0:\\n                    res += (x+1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        n = len(answers)\\n        res = 0\\n        d = {}\\n        for i in range (n):\\n            try:\\n                d[answers[i]] += 1\\n            except:\\n                d[answers[i]] = 1\\n        for x in d:\\n            while d[x] >= x+1:\\n                print(res, \"res at \",x)\\n                res += (x+1)\\n                d[x] = d[x] - (x+1)\\n            else:\\n                if d[x] > 0:\\n                    res += (x+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138361,
                "title": "c-easiest-code-using-unordered-map-not-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){ans=ans+1;continue;}\\n            \\n            if(m.find(nums[i])==m.end()){\\n                ans+=nums[i]+1;\\n                m[nums[i]]=nums[i]+1;\\n            }\\n            else{\\n                m[nums[i]]--;\\n                if(m[nums[i]]==1){\\n                    m.erase(nums[i]);\\n                }\\n                continue;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int>m;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){ans=ans+1;continue;}\\n            \\n            if(m.find(nums[i])==m.end()){\\n                ans+=nums[i]+1;\\n                m[nums[i]]=nums[i]+1;\\n            }\\n            else{\\n                m[nums[i]]--;\\n                if(m[nums[i]]==1){\\n                    m.erase(nums[i]);\\n                }\\n                continue;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993399,
                "title": "java-hashmap-easy-to-understand-no-mathematics-simple-logic",
                "content": "```\\n/*\\nfor each ans we are creating a group of ans- (ans) in the hashmap which tells us that there are ans rabbits of a color. Actually there are ans+1 rabbits, since we are considering a place to be already occupied so, now there are only ans rabbits.\\n\\nfor example-[1,2,4,2,1,3,1]\\n1- [*,_]-- there are two rabbits of C1 color, out of which  one is the current one, so there is a place left for only one rabbit.\\n2- [*,_,_]-- exclding me, there are 2 other rabbits of C2 color. So 3 spots out of which 1 is occupied by me.\\nSo while creating these groups we will add ans+1 to our results which indicates total number of rabbit so far.\\n\\nnow suppose at index 4 we encounter another 1\\nso it will be 1- [*,*] both the places are occupied, here we wn t update the res variable.\\nnow at last index there is one more 1. We do this by substracting the frequency and removing the element from the hashmap.\\n\\nso here we wll create a new group and add 2 to the res\\n1- [*,_]\\nor else it wll violate the first 1\\'s condition, that there is only 1 rabbit part from me with the same color.\\n\\nAnd we need to handle the 0 cases are well, for that we wn t put in in map, we will smply add 1 to the res each time we encounter 0, since it means that there are no other rabbits with the same color as itself, so its only 1 rabbit each time we encounter a 0.\\n*/\\n\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int res=0;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:answers){\\n            if(i==0){ // [1,0,1,0,0] ans-5\\n                res+=1;\\n            }\\n            else if(!map.containsKey(i)){\\n                map.put(i,i);\\n                res+=(i+1);\\n            }else{\\n                map.put(i,map.get(i)-1);\\n                if(map.get(i)==0){\\n                    map.remove(i);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nfor each ans we are creating a group of ans- (ans) in the hashmap which tells us that there are ans rabbits of a color. Actually there are ans+1 rabbits, since we are considering a place to be already occupied so, now there are only ans rabbits.\\n\\nfor example-[1,2,4,2,1,3,1]\\n1- [*,_]-- there are two rabbits of C1 color, out of which  one is the current one, so there is a place left for only one rabbit.\\n2- [*,_,_]-- exclding me, there are 2 other rabbits of C2 color. So 3 spots out of which 1 is occupied by me.\\nSo while creating these groups we will add ans+1 to our results which indicates total number of rabbit so far.\\n\\nnow suppose at index 4 we encounter another 1\\nso it will be 1- [*,*] both the places are occupied, here we wn t update the res variable.\\nnow at last index there is one more 1. We do this by substracting the frequency and removing the element from the hashmap.\\n\\nso here we wll create a new group and add 2 to the res\\n1- [*,_]\\nor else it wll violate the first 1\\'s condition, that there is only 1 rabbit part from me with the same color.\\n\\nAnd we need to handle the 0 cases are well, for that we wn t put in in map, we will smply add 1 to the res each time we encounter 0, since it means that there are no other rabbits with the same color as itself, so its only 1 rabbit each time we encounter a 0.\\n*/\\n\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int res=0;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i:answers){\\n            if(i==0){ // [1,0,1,0,0] ans-5\\n                res+=1;\\n            }\\n            else if(!map.containsKey(i)){\\n                map.put(i,i);\\n                res+=(i+1);\\n            }else{\\n                map.put(i,map.get(i)-1);\\n                if(map.get(i)==0){\\n                    map.remove(i);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901529,
                "title": "java-efficient-solution-easily-understandable-hashmap",
                "content": "public int numRabbits(int[] answers) {\\n        \\n        //TOUGH QUESTION\\n        \\n        HashMap<Integer, Integer> map = new HashMap <> ();\\n        \\n        //1. Frequecny Map\\n        for(int val: answers)\\n            map.put(val, map.getOrDefault(val, 0) +1);\\n        \\n        //2. Create new Group and check\\n        int res = 0;\\n        for(int key: map.keySet()){\\n            \\n            int groupSize = key +1;       //Group Size\\n            \\n            int reportees = map.get(key);\\n            int newGroups = (int)Math.ceil(reportees * 1.0 / groupSize * 1.0);      \\n            \\n            res += groupSize * newGroups;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int numRabbits(int[] answers) {\\n        \\n        //TOUGH QUESTION\\n        \\n        HashMap<Integer, Integer> map = new HashMap <> ();\\n        \\n        //1. Frequecny Map\\n        for(int val: answers)\\n            map.put(val, map.getOrDefault(val, 0) +1);\\n        \\n        //2. Create new Group and check\\n        int res = 0;\\n        for(int key: map.keySet()){\\n            \\n            int groupSize = key +1;       //Group Size\\n            \\n            int reportees = map.get(key);\\n            int newGroups = (int)Math.ceil(reportees * 1.0 / groupSize * 1.0);      \\n            \\n            res += groupSize * newGroups;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1900380,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(int num : answers ){\\n            map[num]++;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(auto itr : map){\\n            \\n            if(itr.first == 0){\\n                ans += itr.second;\\n            }\\n            \\n            else if(itr.second <= itr.first + 1){\\n                ans += itr.first + 1;\\n            }\\n            \\n            else{\\n                int count = itr.second / (itr.first + 1);\\n                \\n                if(itr.second % (itr.first+1) != 0)\\n                    count++;\\n                \\n                ans += (itr.first + 1) * count;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        \\n        unordered_map<int,int> map;\\n        \\n        for(int num : answers ){\\n            map[num]++;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(auto itr : map){\\n            \\n            if(itr.first == 0){\\n                ans += itr.second;\\n            }\\n            \\n            else if(itr.second <= itr.first + 1){\\n                ans += itr.first + 1;\\n            }\\n            \\n            else{\\n                int count = itr.second / (itr.first + 1);\\n                \\n                if(itr.second % (itr.first+1) != 0)\\n                    count++;\\n                \\n                ans += (itr.first + 1) * count;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890781,
                "title": "3ms-easy-5-lines-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> m  // map to store freq\\n\\t\\tint ans = 0; \\n        for (auto i : answers) m[i+1]++; // i+1 because to include the ith rabbit itself along with same rabbit colors\\n        for (auto i : m) ans+= i.first*(i.second/i.first)  +(((i.second%i.first)==0 ? 0 : i.first )); // no. of rabbit in 1 group*no. of filled groups + left over group if left \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> m  // map to store freq\\n\\t\\tint ans = 0; \\n        for (auto i : answers) m[i+1]++; // i+1 because to include the ith rabbit itself along with same rabbit colors\\n        for (auto i : m) ans+= i.first*(i.second/i.first)  +(((i.second%i.first)==0 ? 0 : i.first )); // no. of rabbit in 1 group*no. of filled groups + left over group if left \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890406,
                "title": "c-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> freq;\\n        for (int i : answers) {\\n            ++freq[i];\\n        }\\n        \\n        int res = 0;\\n        for (auto [k, v] : freq) {\\n            res += (v / (k + 1) + (v % (k + 1) != 0)) * (k + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> freq;\\n        for (int i : answers) {\\n            ++freq[i];\\n        }\\n        \\n        int res = 0;\\n        for (auto [k, v] : freq) {\\n            res += (v / (k + 1) + (v % (k + 1) != 0)) * (k + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869496,
                "title": "hashmap-2ms",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer,Integer>map = new HashMap<>();\\n        int ans = 0;\\n        for(int val:answers){\\n         map.put(val,map.getOrDefault(val,0)+1);\\n        }\\n        for(int key:map.keySet()){\\n            int freq = map.get(key);\\n             int keys = key+1;\\n            // convert freq and keys into double\\n             int data =  (int)Math.ceil(freq*1.0/keys*1.0);\\n            \\n            \\n            ans +=data*keys;\\n            \\n           \\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer,Integer>map = new HashMap<>();\\n        int ans = 0;\\n        for(int val:answers){\\n         map.put(val,map.getOrDefault(val,0)+1);\\n        }\\n        for(int key:map.keySet()){\\n            int freq = map.get(key);\\n             int keys = key+1;\\n            // convert freq and keys into double\\n             int data =  (int)Math.ceil(freq*1.0/keys*1.0);\\n            \\n            \\n            ans +=data*keys;\\n            \\n           \\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858231,
                "title": "java-ac-soln-hashmap-w-math-ceil",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int val:answers)\\n            map.put(val,map.getOrDefault(val,0)+1);\\n        int ans = 0;\\n        for(int key: map.keySet()){\\n            int gs = key + 1;\\n            int reportees = map.get(key);\\n            int ng = (int)Math.ceil(reportees*1.0/gs*1.0);\\n            ans += ng*gs;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int val:answers)\\n            map.put(val,map.getOrDefault(val,0)+1);\\n        int ans = 0;\\n        for(int key: map.keySet()){\\n            int gs = key + 1;\\n            int reportees = map.get(key);\\n            int ng = (int)Math.ceil(reportees*1.0/gs*1.0);\\n            ans += ng*gs;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853958,
                "title": "cpp-solution-easy",
                "content": "\\t int numRabbits(vector<int>& answers) {\\n\\t\\t\\tunordered_map<int,int> freq;\\n\\n\\t\\t\\tfor(int ans : answers){\\n\\t\\t\\t\\tfreq[ans + 1]++;\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\tfor(auto [identical,rabbit] : freq){\\n\\t\\t\\t\\tint r =  ceil(rabbit * 1.0 / identical) * identical;\\n\\t\\t\\t\\tans += r;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\t int numRabbits(vector<int>& answers) {\\n\\t\\t\\tunordered_map<int,int> freq;\\n\\n\\t\\t\\tfor(int ans : answers){\\n\\t\\t\\t\\tfreq[ans + 1]++;\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\tfor(auto [identical,rabbit] : freq){\\n\\t\\t\\t\\tint r =  ceil(rabbit * 1.0 / identical) * identical;\\n\\t\\t\\t\\tans += r;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1824953,
                "title": "c-easy-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        for(int a:answers) {\\n            if(mp[a]>a){\\n                ans += mp[a];\\n                mp[a] = 1;\\n            }\\n            else mp[a]++;\\n        }\\n        for(auto i:mp) ans += i.first+1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        for(int a:answers) {\\n            if(mp[a]>a){\\n                ans += mp[a];\\n                mp[a] = 1;\\n            }\\n            else mp[a]++;\\n        }\\n        for(auto i:mp) ans += i.first+1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818168,
                "title": "java-93-faster-code",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer,Integer> fmap=new HashMap<>();\\n        for(int i=0;i<answers.length;i++){\\n            fmap.put(answers[i],fmap.getOrDefault(answers[i],0)+1);\\n        }\\n        int count=0;\\n        for(int key:fmap.keySet()){\\n            int val=fmap.get(key);\\n            count+=(key+1)*(int)Math.ceil(val*1.0/(key+1));\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "class Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer,Integer> fmap=new HashMap<>();\\n        for(int i=0;i<answers.length;i++){\\n            fmap.put(answers[i],fmap.getOrDefault(answers[i],0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1761139,
                "title": "c-with-complete-explanation",
                "content": "\\twe asked n rabbits\\n\\teach rabbit tells about other rabbits (that he knows) of his color\\n\\treturn minimum possible number of rabbits according to the answer of n rabbits\\n\\tclubs rabbits of same color\\n\\tNote that : it is not necessary that we asked each rabbit in the forest\\n        \\n        \\n  explanation:\\n//         let we ask 8 rabbits and each answers 4\\n//             4 4 4 4 4 4 4\\n//             (4 4 4 4 4) -> 5 rabbits of each color\\n//             remaining (4,4,4) -> total remainig rabbits are 4+1 to make answer of these three rabits valid\\n//             thus total=5+4;\\n            \\n        \\n\\t\\tanother example\\n\\t\\tanswer=[1,2,4,4,0,0,2,1,1,3,3,4]\\n//         answer 0=[0,0];\\n//         answer 1=[1,1,1];\\n//         answer 2=[2,2];\\n//         answer 3=[3,3];\\n//         answer 4=[4,4,4];\\n        \\n//         for answer=0 -> each rabbit not know same color rabbit -> thus total = 2;\\n//         for answer 1 -> each rabbit know 1 another of same color\\n//             lets pair them accordingly\\n//             (1,1) -> 2  //possibly knoes each other\\n//             (1) ->  2  //know only one another than himself\\n//         for answer 2=[2,2]\\n//             easc know other 2 -> answer=3 (2,2,2) knows each other\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n\\t\\n        unordered_map<int,int> mp;\\n        int total=0;\\n        for(auto it: answers)\\n        {\\n            mp[it]++;\\n            if(mp[it]>it)\\n            {\\n                total+=mp[it];\\n                mp.erase(it);\\n            }\\n        }\\n        \\n        for(auto it: mp) total+=(it.first+1);\\n        return total;\\n\\t\\t\\n    }\\n};\\n```",
                "solutionTags": [
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n\\t\\n        unordered_map<int,int> mp;\\n        int total=0;\\n        for(auto it: answers)\\n        {\\n            mp[it]++;\\n            if(mp[it]>it)\\n            {\\n                total+=mp[it];\\n                mp.erase(it);\\n            }\\n        }\\n        \\n        for(auto it: mp) total+=(it.first+1);\\n        return total;\\n\\t\\t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752816,
                "title": "java-easy-clean-and-concise-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int num : arr)\\n        \\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n        int ans = 0;\\n        for(int key : map.keySet()) {\\n        \\tint samenum = map.get(key);\\n        \\tint groups = samenum / (key + 1);\\n        \\tans += groups * (key + 1);\\n        \\tif(samenum % (key + 1) != 0)\\n        \\t\\tans += key + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int num : arr)\\n        \\tmap.put(num, map.getOrDefault(num, 0) + 1);\\n        int ans = 0;\\n        for(int key : map.keySet()) {\\n        \\tint samenum = map.get(key);\\n        \\tint groups = samenum / (key + 1);\\n        \\tans += groups * (key + 1);\\n        \\tif(samenum % (key + 1) != 0)\\n        \\t\\tans += key + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735033,
                "title": "48-ms-faster-than-42-22-memory-usage-1memory-usage-13-4-mb-less-than-71-11",
                "content": "This is a very good question\\nOnce you get the logic, code is a piece of cake\\nfirst create a dictionary and record how many times a value is repeating in the answers list\\nnow iterate the dict\\nsuppose the list has 3 zeros\\na zero mean the rabbit says \"There is no one like me\", so that means it is a unique\\na 1 mean the rabbit says\"There is one like me\"\\nso 2 1s mean the first one saying about second and second one saying about first\\n\\nso \\n(0) = 1 rabbit\\n(1,1) = 2 rabbits\\n(2,2,2) = 3 rabbits(say the rabbits are A B C then first one saying about BC 2nd about CA and 3rd about AB)\\n(3,3,3,3) = 4 rabbits\\n(n,n,n,...)n+1 times = n + 1 \\nHere\\'s the code:\\n\\n```\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        d = dict()\\n        for val in answers:\\n            if val not in d.keys():\\n                d[val] = 0\\n            d[val] += 1\\n        sums = 0\\n        for key in d.keys():\\n            multiple = key + 1\\n            count = d[key]\\n            if count<=multiple:\\n                count = multiple\\n                sums += multiple\\n                continue\\n            temp = 0\\n            if count % multiple != 0:\\n                temp = 1\\n                count = count - (count%multiple)\\n            sums = sums + (count) + (multiple)*temp\\n        return sums\\n\\n```\\nin the for loop while iterating keys in the dict\\ndefine multiple as key + 1\\nmultiple = 1 when key = 0\\nmultiple = 2 when key = 1....\\nthere should be 3 2s to make a set of 3 rabbits\\nif there are only two 2s then (2,2) mean 3 rabbits simply\\nif there is only one 2 then (2) mean 3\\nso if count <= multiple then simply add the multiple to sum\\nif count is not divisble by multiple then reduce count to count - count%multiple and set temp 1\\nlike when there are five 2s then count mean (2,2,2) and temp = 1 mean (2,2)\\nif there are seven 2s then count mean (2,2,2) (2,2,2) and temp = 1 mean (2)\\nadd sum by count + temp x multiple\\nlike when there are five 2s then sum will be 3(count) + 3(multiple) x 1(temp)\\n\\nreturn sum\\n\\n# ***Try to work this code in a rough book you will get better understanding***\\n\\n## :)\\n",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        d = dict()\\n        for val in answers:\\n            if val not in d.keys():\\n                d[val] = 0\\n            d[val] += 1\\n        sums = 0\\n        for key in d.keys():\\n            multiple = key + 1\\n            count = d[key]\\n            if count<=multiple:\\n                count = multiple\\n                sums += multiple\\n                continue\\n            temp = 0\\n            if count % multiple != 0:\\n                temp = 1\\n                count = count - (count%multiple)\\n            sums = sums + (count) + (multiple)*temp\\n        return sums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724925,
                "title": "python-3-easy-two-line-solution-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        counter = collections.Counter(answers)\\n\\n        return sum(math.ceil(freq / (answer + 1)) * (answer + 1)\\n                   for answer, freq in counter.items())",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        counter = collections.Counter(answers)\\n\\n        return sum(math.ceil(freq / (answer + 1)) * (answer + 1)\\n                   for answer, freq in counter.items())",
                "codeTag": "Java"
            },
            {
                "id": 1666314,
                "title": "approach-and-c-code-o-n",
                "content": "```\\nKey Idea is, If a rabbit let name it Rabbit1 says there are x like me.\\nThe Rabbit1 can be considered of a group of (x+1) of the same color.\\n\\nExample- If Rabbit1 says there are 10 like me, Rabbit is a part of group of 11 Rabbits of same color.\\nSo if you ask the other 10 Rabbits of the group of 11 Rabbits for Rabbit1.\\nLet\\'s name them Rabbit1, Rabbit2..........,Rabbit11.\\n\\n\\nLet\\'s Consider asking those 11 Rabbits same question, How many are like you.\\n1. Asking Rabbit1.\\n2. Asking Rabbit1 and Rabbit2\\n3. Asking Rabbit2 and Rabbit3.\\n4. Asking all 11 Rabbits\\n\\nThey all will answer same thing, There are 10 like me.\\nSo if 2 Rabbits say there are 10 like me, Number of rabbit = 11.\\nSo if 3 Rabbits say there are 10 like me, Number of rabbit = 11.\\n\\nSo we have no problem if any number of rabbits among 11 or even all 11 say there are 10 like me.\\n\\nSupose a 12th Rabbit named RabbitNew comes and says there are 10 like me.\\nNow comes the problem, It cannot be the part of the previous 11 Rabbits(Rabbit1 to Rabbit2).\\nElse there answer would change to 11 like me, \\nOr group of 12 Rabbits, i.e Group of 11 Rabbits(Rabbit1 to Rabbit2) + RabbitNew = 12.\\n\\nSo Basically if you store in Hashmap<How many like me(x), Frequency(f)>\\nAs long as f is less than or equal to (x+1) for a particular x all rabbits are part of same group of (x+1) member.\\n\\nIf at any point f becomes x+2, We assume having two groups.(x+1) Members Group I and 1 Member Group II.\\nWe count Group I straight away and store it in our answer, And Make frequency back to 1 for x.\\n```\\n\\n**C++ Code**\\n\\n```\\nint numRabbits(vector<int>& answers) {\\n        int ans = 0;\\n        map<int, int> mymap;\\n        \\n        for(int x: answers) {\\n            int key = x;\\n            if(mymap.find(key) != mymap.end()) {\\n                int currentVal = mymap[key];\\n                int maxVal = key + 1;\\n                \\n                if(currentVal < maxVal) {\\n                    mymap[key] += 1;\\n                }\\n                else {\\n                    ans += maxVal;\\n                    mymap[key] = 1;\\n                }\\n            }\\n            else {\\n                mymap[key] = 1;\\n            }\\n        }\\n        \\n        for(auto &mapElement: mymap) {\\n            ans += (mapElement.first+1);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nKey Idea is, If a rabbit let name it Rabbit1 says there are x like me.\\nThe Rabbit1 can be considered of a group of (x+1) of the same color.\\n\\nExample- If Rabbit1 says there are 10 like me, Rabbit is a part of group of 11 Rabbits of same color.\\nSo if you ask the other 10 Rabbits of the group of 11 Rabbits for Rabbit1.\\nLet\\'s name them Rabbit1, Rabbit2..........,Rabbit11.\\n\\n\\nLet\\'s Consider asking those 11 Rabbits same question, How many are like you.\\n1. Asking Rabbit1.\\n2. Asking Rabbit1 and Rabbit2\\n3. Asking Rabbit2 and Rabbit3.\\n4. Asking all 11 Rabbits\\n\\nThey all will answer same thing, There are 10 like me.\\nSo if 2 Rabbits say there are 10 like me, Number of rabbit = 11.\\nSo if 3 Rabbits say there are 10 like me, Number of rabbit = 11.\\n\\nSo we have no problem if any number of rabbits among 11 or even all 11 say there are 10 like me.\\n\\nSupose a 12th Rabbit named RabbitNew comes and says there are 10 like me.\\nNow comes the problem, It cannot be the part of the previous 11 Rabbits(Rabbit1 to Rabbit2).\\nElse there answer would change to 11 like me, \\nOr group of 12 Rabbits, i.e Group of 11 Rabbits(Rabbit1 to Rabbit2) + RabbitNew = 12.\\n\\nSo Basically if you store in Hashmap<How many like me(x), Frequency(f)>\\nAs long as f is less than or equal to (x+1) for a particular x all rabbits are part of same group of (x+1) member.\\n\\nIf at any point f becomes x+2, We assume having two groups.(x+1) Members Group I and 1 Member Group II.\\nWe count Group I straight away and store it in our answer, And Make frequency back to 1 for x.\\n```\n```\\nint numRabbits(vector<int>& answers) {\\n        int ans = 0;\\n        map<int, int> mymap;\\n        \\n        for(int x: answers) {\\n            int key = x;\\n            if(mymap.find(key) != mymap.end()) {\\n                int currentVal = mymap[key];\\n                int maxVal = key + 1;\\n                \\n                if(currentVal < maxVal) {\\n                    mymap[key] += 1;\\n                }\\n                else {\\n                    ans += maxVal;\\n                    mymap[key] = 1;\\n                }\\n            }\\n            else {\\n                mymap[key] = 1;\\n            }\\n        }\\n        \\n        for(auto &mapElement: mymap) {\\n            ans += (mapElement.first+1);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568454,
                "title": "python3-very-intuitive-solution",
                "content": "The rabbits with the same answer might be the same color. For example, [1,1] should have the result of 2 rabbits and they see each other as same color. However, in case of [1,1,1], two of the rabbits could be the same color, but the third rabbit could be another color and he/she saw another rabbit outside of this group with the same color.\\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        res = 0\\n        seen = {}\\n        for answer in answers:\\n            if answer == 0:\\n                res += 1\\n            elif answer not in seen:\\n                res += answer+1\\n                seen[answer] = 1\\n            else:\\n                seen[answer] += 1\\n\\t\\t\\t\\t#seen[answer] = answer+1 means we have counted all rabbits with this same color, if we see another answer it could be another color\\n                if seen[answer] == answer+1:\\n                    del seen[answer]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        res = 0\\n        seen = {}\\n        for answer in answers:\\n            if answer == 0:\\n                res += 1\\n            elif answer not in seen:\\n                res += answer+1\\n                seen[answer] = 1\\n            else:\\n                seen[answer] += 1\\n\\t\\t\\t\\t#seen[answer] = answer+1 means we have counted all rabbits with this same color, if we see another answer it could be another color\\n                if seen[answer] == answer+1:\\n                    del seen[answer]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425776,
                "title": "java-hashmap-with-comments-a-rabbit-story-color-groups-no-formula",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer,Integer> differentColorGroups = new HashMap<>();\\n        \\n        int rabbitCount = 0;\\n        \\n        for(int answer : answers){ // I\\'am rabbit (I am telling that how many rabbits are having same color as me)\\n            if(answer == 0){ // I\\'am distinct, I dont belong to any group\\n                rabbitCount += 1;\\n            }\\n            else if(differentColorGroups.get(answer) == null){ // There is no group with this color, so create one\\n                rabbitCount += answer+1; // (there are answer+1(including me) rabbits having same colors) - a group size\\n                differentColorGroups.put(answer, answer); // now in future this group can accomodate \\'answer\\' number of rabbits\\n            }\\n            else{\\n                int count = differentColorGroups.get(answer); //get the count of the group size\\n                if(count == 1){ //this group can accomodate 1 more rabbit, I am getting into this group so now remove this group for future use\\n                    differentColorGroups.remove(answer); //remove this group, because it cant accomodate new member\\n                }\\n                else{//I belong to this group, now this group can accomodate (Count-1) rabbit for future\\n                    differentColorGroups.put(answer, count-1);\\n                }\\n            }\\n        }\\n        \\n        return rabbitCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer,Integer> differentColorGroups = new HashMap<>();\\n        \\n        int rabbitCount = 0;\\n        \\n        for(int answer : answers){ // I\\'am rabbit (I am telling that how many rabbits are having same color as me)\\n            if(answer == 0){ // I\\'am distinct, I dont belong to any group\\n                rabbitCount += 1;\\n            }\\n            else if(differentColorGroups.get(answer) == null){ // There is no group with this color, so create one\\n                rabbitCount += answer+1; // (there are answer+1(including me) rabbits having same colors) - a group size\\n                differentColorGroups.put(answer, answer); // now in future this group can accomodate \\'answer\\' number of rabbits\\n            }\\n            else{\\n                int count = differentColorGroups.get(answer); //get the count of the group size\\n                if(count == 1){ //this group can accomodate 1 more rabbit, I am getting into this group so now remove this group for future use\\n                    differentColorGroups.remove(answer); //remove this group, because it cant accomodate new member\\n                }\\n                else{//I belong to this group, now this group can accomodate (Count-1) rabbit for future\\n                    differentColorGroups.put(answer, count-1);\\n                }\\n            }\\n        }\\n        \\n        return rabbitCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297075,
                "title": "java-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        \\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<answers.length;i++){\\n            map.put(answers[i],map.getOrDefault(answers[i],0)+1);\\n        }\\n        int res=0;\\n        for(Integer key : map.keySet()){\\n            int gs =key+1;\\n            int reportees = map.get(key);\\n            int ng= (int)Math.ceil(reportees*1.0/gs*1.0);\\n            res+=(ng*gs);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        \\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<answers.length;i++){\\n            map.put(answers[i],map.getOrDefault(answers[i],0)+1);\\n        }\\n        int res=0;\\n        for(Integer key : map.keySet()){\\n            int gs =key+1;\\n            int reportees = map.get(key);\\n            int ng= (int)Math.ceil(reportees*1.0/gs*1.0);\\n            res+=(ng*gs);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289111,
                "title": "c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int minRabbits = 0;\\n        unordered_map<int,int> freqMap;\\n        for(int i=0;i<answers.size();i++)\\n        {\\n            freqMap[answers[i]]++;\\n        }\\n        for(auto p:freqMap)\\n        {\\n            int groupSize = p.first+1;\\n            int r = p.second;\\n            int numG = (int)ceil(r*1.0/groupSize*1.0);\\n            minRabbits+=(numG*groupSize);\\n        }\\n        return minRabbits;\\n    }\\n};\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int minRabbits = 0;\\n        unordered_map<int,int> freqMap;\\n        for(int i=0;i<answers.size();i++)\\n        {\\n            freqMap[answers[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1287780,
                "title": "c-easy-solution-using-hashmap-beats-100",
                "content": "\\'\\'\\'\\nint numRabbits(vector<int>& answers) {\\n      unordered_map<int,int>mp;\\n      int ans=0;\\n      for(int i=0;i<answers.size();i++)\\n      {\\n        if(mp[answers[i]]>0) mp[answers[i]]--;\\n        else\\n        {\\n          ans+=answers[i]+1;\\n          mp[answers[i]]+=answers[i];\\n        }\\n      }\\n      return ans;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nint numRabbits(vector<int>& answers) {\\n      unordered_map<int,int>mp;\\n      int ans=0;\\n      for(int i=0;i<answers.size();i++)\\n      {\\n        if(mp[answers[i]]>0) mp[answers[i]]--;\\n        else\\n        {\\n          ans+=answers[i]+1;\\n          mp[answers[i]]+=answers[i];\\n        }\\n      }\\n      return ans;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1276391,
                "title": "c-unordered-map-o-n-time-complexity-o-n-space-complexity",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numRabbits(vector<int>& answers) {\\n\\t\\t\\tunordered_map<int, int> mp;\\n\\t\\t\\tint res=0;\\n\\t\\t\\tfor(int i=0; i<answers.size(); i++){\\n\\t\\t\\t\\tif(!mp[answers[i]]){\\n\\t\\t\\t\\t\\tmp[answers[i]]=answers[i];\\n\\t\\t\\t\\t\\tres += answers[i]+1;\\n\\t\\t\\t\\t}else \\n\\t\\t\\t\\t\\tmp[answers[i]]--;\\n\\t\\t\\t}return res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numRabbits(vector<int>& answers) {\\n\\t\\t\\tunordered_map<int, int> mp;\\n\\t\\t\\tint res=0;\\n\\t\\t\\tfor(int i=0; i<answers.size(); i++){\\n\\t\\t\\t\\tif(!mp[answers[i]]){\\n\\t\\t\\t\\t\\tmp[answers[i]]=answers[i];\\n\\t\\t\\t\\t\\tres += answers[i]+1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1270591,
                "title": "ok",
                "content": "```\\nint numRabbits(vector<int>& a)\\n{\\n\\tunordered_map<int, int> m;\\n\\tfor(const auto & i : a) ++m[i];\\n\\tint out{0};\\n\\tfor(const auto & [i,j] : m)\\n\\t\\tout += (i+1)*(j/(i+1)) + (j%(i+1) ? i+1 : 0);\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint numRabbits(vector<int>& a)\\n{\\n\\tunordered_map<int, int> m;\\n\\tfor(const auto & i : a) ++m[i];\\n\\tint out{0};\\n\\tfor(const auto & [i,j] : m)\\n\\t\\tout += (i+1)*(j/(i+1)) + (j%(i+1) ? i+1 : 0);\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269415,
                "title": "java-2ms",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        \\n        HashMap<Integer , Integer> hm = new HashMap<>(); \\n        \\n        for(int ele : answers)\\n        {\\n            if(hm.containsKey(ele) == false)\\n                hm.put(ele,1); \\n            else\\n                hm.put(ele , hm.get(ele) + 1);\\n        }\\n        \\n        int ans = 0; \\n        for(int i : hm.keySet())\\n        {\\n            int x =(int)Math.ceil((hm.get(i)) * 1.0/(i+1)); \\n            ans += (x * ( i + 1)); \\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        \\n        HashMap<Integer , Integer> hm = new HashMap<>(); \\n        \\n        for(int ele : answers)\\n        {\\n            if(hm.containsKey(ele) == false)\\n                hm.put(ele,1); \\n            else\\n                hm.put(ele , hm.get(ele) + 1);\\n        }\\n        \\n        int ans = 0; \\n        for(int i : hm.keySet())\\n        {\\n            int x =(int)Math.ceil((hm.get(i)) * 1.0/(i+1)); \\n            ans += (x * ( i + 1)); \\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266241,
                "title": "c-100-hashmap-logic-clean-solution-think-inside-the-box",
                "content": "//using unordered map simple and clean solution\\n\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        \\n        unordered_map<int,int> m;\\n        int count=0;\\n        for(int i=0;i<answers.size();i++)\\n        {\\n            if(m[answers[i]])\\n            {\\n                m[answers[i]]--;\\n            }\\n            else\\n            {\\n                m[answers[i]]=answers[i];\\n                count+=answers[i]+1;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        \\n        unordered_map<int,int> m;\\n        int count=0;\\n        for(int i=0;i<answers.size();i++)\\n        {\\n            if(m[answers[i]])\\n            {\\n                m[answers[i]]--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1214175,
                "title": "java-hashmap-easy-solution",
                "content": "class Solution {\\n    public int numRabbits(int[] answers) {\\n      \\n        HashMap <Integer,Integer> map=new HashMap<>();\\n        int result=0;\\n        for(int i=0;i<answers.length;i++)\\n        {\\n           int k=map.getOrDefault(answers[i]+1,0);\\n            map.put(answers[i]+1,k+1);\\n            if(map.get(answers[i]+1)==answers[i]+1)\\n            {\\n                map.compute(answers[i]+1, (key, val) -> 0);\\n                result=result+(answers[i]+1);\\n            }\\n        }\\n        for(Map.Entry<Integer,Integer> e : map.entrySet()) {\\n            if(e.getValue()>0)\\n            {\\n                result=result+e.getKey();\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numRabbits(int[] answers) {\\n      \\n        HashMap <Integer,Integer> map=new HashMap<>();\\n        int result=0;\\n        for(int i=0;i<answers.length;i++)\\n        {\\n           int k=map.getOrDefault(answers[i]+1,0);\\n            map.put(answers[i]+1,k+1);\\n            if(map.get(answers[i]+1)==answers[i]+1)\\n            {\\n                map.compute(answers[i]+1, (key, val) -> 0);\\n                result=result+(answers[i]+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1136372,
                "title": "java-easiest-2-ms-solution-with-hashmap-using-only-standart-methods",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int rabbitsAmount = 0;\\n        HashMap<Integer,Integer> sameBitches = new HashMap<Integer,Integer>();\\n        \\n        for(int i = 0; i < answers.length; i++)\\n        {\\n            if(sameBitches.containsKey(answers[i]) == false  && answers[i] != 0) //if we see this rabit for the first time an it says that he is not unique\\n            {\\n                sameBitches.put(answers[i], 1);\\n                rabbitsAmount += answers[i]+1;\\n                continue;\\n            }\\n            if(sameBitches.containsKey(answers[i]) == true && sameBitches.get(answers[i]) > answers[i]) //if we have seen rabits saying us that there \\' s n more rabbits as them, but that\\'s n+1 rabbit\\n            {\\n                rabbitsAmount += answers[i] +1;\\n                sameBitches.put(answers[i], 1);\\n                continue;\\n                \\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (sameBitches.containsKey(answers[i]) == true) // counting these bitches to be sure that we won\\'t skip unique rabbits\\n            {\\n                sameBitches.put(answers[i], sameBitches.get(answers[i])+1);\\n                continue;\\n            }\\n            else if(answers[i] == 0) rabbitsAmount += 1; //if this bitch is unique\\n        }\\n        return rabbitsAmount;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numRabbits(int[] answers) {\\n        int rabbitsAmount = 0;\\n        HashMap<Integer,Integer> sameBitches = new HashMap<Integer,Integer>();\\n        \\n        for(int i = 0; i < answers.length; i++)\\n        {\\n            if(sameBitches.containsKey(answers[i]) == false  && answers[i] != 0) //if we see this rabit for the first time an it says that he is not unique\\n            {\\n                sameBitches.put(answers[i], 1);\\n                rabbitsAmount += answers[i]+1;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1135697,
                "title": "python-solution-space-100-runtime-98",
                "content": "```\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        d = {}\\n        res = 0\\n        for ans in answers:\\n            if(ans==0):\\n                res+=1\\n            elif(ans in d and d[ans]//(ans+1) == 1):\\n                res+=(ans+1)\\n                d[ans] = 1\\n            else:\\n                if(ans in d):\\n                    d[ans]+=1\\n                else:\\n                    res+=(ans+1)\\n                    d[ans]=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        d = {}\\n        res = 0\\n        for ans in answers:\\n            if(ans==0):\\n                res+=1\\n            elif(ans in d and d[ans]//(ans+1) == 1):\\n                res+=(ans+1)\\n                d[ans] = 1\\n            else:\\n                if(ans in d):\\n                    d[ans]+=1\\n                else:\\n                    res+=(ans+1)\\n                    d[ans]=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028461,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        return sum((k+1)*ceil(v/(k+1)) for k,v in Counter(answers).items())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        return sum((k+1)*ceil(v/(k+1)) for k,v in Counter(answers).items())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978830,
                "title": "java-super-easy-concise-solution-beats-100",
                "content": "The solution is based on the simple idea that for each answer `answers[i]` we can have anothers `answers[i]` rabbits tell the same answer. So the count should be `answers[i] + 1`. And for the next `answers[i]` similar answers, we would not be adding to the final answer.\\n\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int[] hash = new int[1000]; // answer[i] = 0-> 1000\\n        int count =0;\\n        for(int a:answers) {\\n            if(hash[a]==0){\\n                count+=(a+1);\\n                hash[a]=a;\\n            }\\n            else\\n                hash[a]--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int[] hash = new int[1000]; // answer[i] = 0-> 1000\\n        int count =0;\\n        for(int a:answers) {\\n            if(hash[a]==0){\\n                count+=(a+1);\\n                hash[a]=a;\\n            }\\n            else\\n                hash[a]--;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838445,
                "title": "python-3-hash-table-1-liner-explanations",
                "content": "### Explanation\\n- Count frequency of each number\\n- If `num+1 <= frequency` meaning there are `num+1` for some color\\n- If `num+1 > frequency` meaning there are more than `num+1` for some color\\n\\t- Count how many `num+1` are there, take the `ceil`\\n\\t- Add `(key+1) * math.ceil(freq / (key+1))` to `ans`\\n### Implementation\\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        return sum((key+1) * math.ceil(freq / (key+1)) if key+1 < freq else key+1 for key, freq in collections.Counter(answers).items())\\n```\\nIf you don\\'t like the 1-liner\\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        ans, cnt = 0, collections.Counter(answers)\\n        for key, freq in cnt.items():\\n            if key + 1 < freq: ans += (key+1) * math.ceil(freq / (key+1))\\n            else: ans += key+1\\n        return ans                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        return sum((key+1) * math.ceil(freq / (key+1)) if key+1 < freq else key+1 for key, freq in collections.Counter(answers).items())\\n```\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        ans, cnt = 0, collections.Counter(answers)\\n        for key, freq in cnt.items():\\n            if key + 1 < freq: ans += (key+1) * math.ceil(freq / (key+1))\\n            else: ans += key+1\\n        return ans                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 836801,
                "title": "c-99-2-hashmap-logic-clean-solution-think-inside-the-box",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans = 0;\\n        map<int,int> hash;\\n        for(int a:answers) hash[a]++;\\n        for(auto iter=hash.begin();iter!=hash.end();++iter){\\n            if(iter->second % (iter->first+1) == 0) ans += iter->second;\\n            else ans += iter->second/(iter->first+1)*(iter->first+1)+iter->first+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans = 0;\\n        map<int,int> hash;\\n        for(int a:answers) hash[a]++;\\n        for(auto iter=hash.begin();iter!=hash.end();++iter){\\n            if(iter->second % (iter->first+1) == 0) ans += iter->second;\\n            else ans += iter->second/(iter->first+1)*(iter->first+1)+iter->first+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826299,
                "title": "c-simple-logic-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& nums) {\\n        int ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        auto it=m.begin();\\n        while(it!=m.end()){\\n            int a=it->second;\\n            while(a>0){\\n                ans+=(it->first+1);\\n                a-=(it->first+1);\\n            }\\n            it++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Optimizing the same code \\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& nums) {\\n        int ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        auto it=m.begin();\\n        while(it!=m.end()){\\n            int a=it->second;\\n            int b=it->first+1;\\n            if(a%b==0){\\n                ans+=(a/b)*(b);\\n            }else{\\n                ans+=((a/b)+1)*b;\\n            }\\n            it++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& nums) {\\n        int ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        auto it=m.begin();\\n        while(it!=m.end()){\\n            int a=it->second;\\n            while(a>0){\\n                ans+=(it->first+1);\\n                a-=(it->first+1);\\n            }\\n            it++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& nums) {\\n        int ans=0;\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]]++;\\n        }\\n        auto it=m.begin();\\n        while(it!=m.end()){\\n            int a=it->second;\\n            int b=it->first+1;\\n            if(a%b==0){\\n                ans+=(a/b)*(b);\\n            }else{\\n                ans+=((a/b)+1)*b;\\n            }\\n            it++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721092,
                "title": "intiutive-solution-similar-to-pigenhole-priniciple",
                "content": "a group of x rabits ,can be tell via less than or equal x rabits\\nex: 3,3,3,3,3 \\nSo total rabit will be 8 not 4.\\nbecause first group of 4 rabits is already then again 1 rabit told us that he knows more 3 rabit of his color. so ans will be 4+4\\n```\\nint numRabbits(vector<int>& answers) {\\n        int n=answers.size();\\n        unordered_map<int,int>mp;   // <group size of rabit ,how many rabit tell that to me>\\n        int rabit=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int group=answers[i]+1;  // group of rabits\\n            if(group==1)             // if a rabit has unique color\\n                rabit++;\\n            else\\n            {\\n                if(mp[group]==group)\\n                {\\n                    rabit+=group;   // if a group is completed,no entry \\n                    mp[group]=1; // we have to make a diffrent group of same size\\n                }\\n                else\\n                    mp[group]++;\\n            }\\n            \\n        }\\n       \\n        for(auto s:mp)\\n            rabit+=s.first;  \\n        return rabit;\\n    }\\n",
                "solutionTags": [],
                "code": "a group of x rabits ,can be tell via less than or equal x rabits\\nex: 3,3,3,3,3 \\nSo total rabit will be 8 not 4.\\nbecause first group of 4 rabits is already then again 1 rabit told us that he knows more 3 rabit of his color. so ans will be 4+4\\n```\\nint numRabbits(vector<int>& answers) {\\n        int n=answers.size();\\n        unordered_map<int,int>mp;   // <group size of rabit ,how many rabit tell that to me>\\n        int rabit=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int group=answers[i]+1;  // group of rabits\\n            if(group==1)             // if a rabit has unique color\\n                rabit++;\\n            else\\n            {\\n                if(mp[group]==group)\\n                {\\n                    rabit+=group;   // if a group is completed,no entry \\n                    mp[group]=1; // we have to make a diffrent group of same size\\n                }\\n                else\\n                    mp[group]++;\\n            }\\n            \\n        }\\n       \\n        for(auto s:mp)\\n            rabit+=s.first;  \\n        return rabit;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 689605,
                "title": "c-easy-and-concise-solution-using-priority-queue-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&answers){\\n        priority_queue<int>pq(answers.begin(),answers.end());\\n        \\n        int rabbitCount = 0, num , k;\\n        \\n        while(!pq.empty()){ \\n            num = k = pq.top();\\n\\t\\t\\t\\n\\t\\t\\t//There will be k + 1 rabbit of same color if answer count is k so we add k+1 to rabbitCount\\n            rabbitCount += k + 1;\\n            pq.pop();\\n            \\n\\t\\t\\t// We have to skip k rabbit of same color \\n            while(k-- > 0 && !pq.empty() && pq.top() == num){\\n                pq.pop();\\n            }\\n        }\\n        \\n        return rabbitCount;\\n    }\\n    int numRabbits(vector<int>& answers) {\\n        return helper(answers);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&answers){\\n        priority_queue<int>pq(answers.begin(),answers.end());\\n        \\n        int rabbitCount = 0, num , k;\\n        \\n        while(!pq.empty()){ \\n            num = k = pq.top();\\n\\t\\t\\t\\n\\t\\t\\t//There will be k + 1 rabbit of same color if answer count is k so we add k+1 to rabbitCount\\n            rabbitCount += k + 1;\\n            pq.pop();\\n            \\n\\t\\t\\t// We have to skip k rabbit of same color \\n            while(k-- > 0 && !pq.empty() && pq.top() == num){\\n                pq.pop();\\n            }\\n        }\\n        \\n        return rabbitCount;\\n    }\\n    int numRabbits(vector<int>& answers) {\\n        return helper(answers);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 648149,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int res = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for (int ans : answers) {\\n            hm.put(ans, hm.getOrDefault(ans, 0) + 1);\\n        }\\n\\n        for (Map.Entry<Integer, Integer> entry : hm.entrySet()) {\\n            int key = entry.getKey();\\n            int val = entry.getValue();\\n            int cnt;\\n            if (key == 0) {\\n                cnt = val;\\n            } else {\\n                cnt = Math.max(key + 1, (int) Math.ceil((double) val / (key + 1)) * (key+1));\\n            }\\n            res += cnt;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int res = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for (int ans : answers) {\\n            hm.put(ans, hm.getOrDefault(ans, 0) + 1);\\n        }\\n\\n        for (Map.Entry<Integer, Integer> entry : hm.entrySet()) {\\n            int key = entry.getKey();\\n            int val = entry.getValue();\\n            int cnt;\\n            if (key == 0) {\\n                cnt = val;\\n            } else {\\n                cnt = Math.max(key + 1, (int) Math.ceil((double) val / (key + 1)) * (key+1));\\n            }\\n            res += cnt;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632257,
                "title": "python-explained",
                "content": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        c = collections.Counter(answers)              \\n        return sum( (i + 1)*math.ceil(c[i]/(i + 1)) for i in c)\\n```\\n\\nBut let\\'s start with a bit longer code:\\n\\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        r = 0\\n        c = collections.Counter(answers)\\n        for i in c:\\n            r += (i + 1)*(c[i]//(i + 1))\\n            if c[i]%(i+1)>0:\\n                r += (i + 1)                \\n        return r\\n```\\n\\nSo let\\'s look at the few examples first.\\n\\n1. n rabbits answered 0. That means each rabbit has a unique color and we need to have at least n rabbits.\\n2. n rabbits answered 1. That means we have 2 rabbits of each color. So the number of groups would be n/2 and each group will have 2. There is one catch. if n/2 is not a round number. Let\\'s say 1 rabbit answered 1. That means while we only asked 1 rabbit, it has to be another other in the forrest and we need to reserve a full group. Basically n/2 needs to be rounded up to the next int. This is the very important part. Think about it. Make sure you understand that concept.\\n\\nIf the first two answers make sense, now you can see the pattern.\\n\\nIf `n` rabbits answered `i`, we need to count the number of groups of size `i+1`. The number of groups needs to be rounded up. Then each group will have `i+1` members.\\n\\nNow we just need to implement that logic. To count number of answers we simply use Counter():\\n\\n```\\n        c = collections.Counter(answers)\\n```\\n\\nNow we need to count number of groups and make sure we round that number up. There are many ways to do it, I used something ugly but easy to understand, I simply check if the number needs to be rounded:\\n\\n```\\n            if c[i]%(i+1)>0:\\n```\\n\\nIf we get a round number of groups for that answer, we simply add:\\n```\\n                r += (i + 1)*(c[i]//(i + 1))\\n```\\nbut if the number of groups is not round, we add one extra:\\n\\n```\\n                r += (i + 1)\\n```\\n\\nNow we just need to return the result `r`.\\n\\nThis code can be made shorter. Since we have just one for and one if, it can be wrapped up into a comprehension, so we can use sum() instead of the running total variable `r`. Then we can replace the ugly if with either math.ceil() or some computational logic based around `//` \\n\\nThat would get us to the initial 2-liner.\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        c = collections.Counter(answers)              \\n        return sum( (i + 1)*math.ceil(c[i]/(i + 1)) for i in c)\\n```\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        r = 0\\n        c = collections.Counter(answers)\\n        for i in c:\\n            r += (i + 1)*(c[i]//(i + 1))\\n            if c[i]%(i+1)>0:\\n                r += (i + 1)                \\n        return r\\n```\n```\\n        c = collections.Counter(answers)\\n```\n```\\n            if c[i]%(i+1)>0:\\n```\n```\\n                r += (i + 1)*(c[i]//(i + 1))\\n```\n```\\n                r += (i + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622520,
                "title": "very-simple-java-solution-o-n",
                "content": "class Solution {\\n    public int numRabbits(int[] answers) {\\n        \\n        int sum  =0;\\n        int map[] = new int[1000];\\n        for(int ans: answers){\\n            if(map[ans]==0){\\n                sum = sum + ans +1;\\n                map[ans] = ans;\\n            }\\n            else{\\n                map[ans]--;\\n            }\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numRabbits(int[] answers) {\\n        \\n        int sum  =0;\\n        int map[] = new int[1000];\\n        for(int ans: answers){\\n            if(map[ans]==0){\\n                sum = sum + ans +1;\\n                map[ans] = ans;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 562121,
                "title": "rust-100-time-and-space-0ms",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_rabbits(answers: Vec<i32>) -> i32 {\\n        answers\\n            .iter()\\n            .fold(HashMap::new(), |mut acc, &x| {\\n                *acc.entry(x).or_insert(0) += 1;\\n                acc\\n            })\\n            .iter()\\n            .fold(0, |acc, (&key, &value)| {\\n                let teams = if value % (key + 1) == 0 {\\n                    value / (key + 1)\\n                } else {\\n                    value / (key + 1) + 1\\n                };\\n\\n                acc + teams * (key + 1)\\n            })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_rabbits(answers: Vec<i32>) -> i32 {\\n        answers\\n            .iter()\\n            .fold(HashMap::new(), |mut acc, &x| {\\n                *acc.entry(x).or_insert(0) += 1;\\n                acc\\n            })\\n            .iter()\\n            .fold(0, |acc, (&key, &value)| {\\n                let teams = if value % (key + 1) == 0 {\\n                    value / (key + 1)\\n                } else {\\n                    value / (key + 1) + 1\\n                };\\n\\n                acc + teams * (key + 1)\\n            })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 464266,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> umap;\\n        for (int a: answers)\\n            ++umap[a + 1];\\n        \\n        int count = 0;\\n        for (auto& [setSize, val]: umap)\\n            count += (val / setSize + (val % setSize != 0)) * setSize;\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> umap;\\n        for (int a: answers)\\n            ++umap[a + 1];\\n        \\n        int count = 0;\\n        for (auto& [setSize, val]: umap)\\n            count += (val / setSize + (val % setSize != 0)) * setSize;\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396461,
                "title": "clean-code-python",
                "content": "import math\\nimport collections\\n\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        \\n        # count the frequency of numbers in a dictionary\\n        freq_of_nums = collections.defaultdict(int)\\n        for num in answers:\\n            freq_of_nums[num] += 1\\n        \\n        total = 0\\n        for number, freq in freq_of_nums.items():\\n            total += math.ceil(freq/(number+1))*(number+1)\\n        \\n        return total\\n",
                "solutionTags": [],
                "code": "import math\\nimport collections\\n\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        \\n        # count the frequency of numbers in a dictionary\\n        freq_of_nums = collections.defaultdict(int)\\n        for num in answers:\\n            freq_of_nums[num] += 1\\n        \\n        total = 0\\n        for number, freq in freq_of_nums.items():\\n            total += math.ceil(freq/(number+1))*(number+1)\\n        \\n        return total\\n",
                "codeTag": "Java"
            },
            {
                "id": 389962,
                "title": "python-very-simple-solution",
                "content": "```class Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        d = {}\\n        rabbits = 0\\n        for key in answers: d[key+1] = d[key+1]+1 if (key+1) in d else 1\\n        for key in d:\\n            if d[key] < key:\\n                rabbits += key\\n            else:\\n                rabbits += math.ceil(d[key]/key)*key\\n                #eg: [2,2,2,2,2] : if 5 rabbits say there are 2 others like them, there must be 6 rabbits = (5/(2+1))(2+1) \\'adding 1 because the rabbit telling answer should also be included\\'*\\n        \\n        return rabbits",
                "solutionTags": [],
                "code": "class Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 291987,
                "title": "simple-solution",
                "content": "Intuition for this solution is that when we start counting no of rabbits but then when more than n no of rabbits say = n+1 then there\\'s new type of rabbit who\\'s saying n.\\n\\nThus keep decreasing count for n and if it\\'s zero, that\\'s a new category which is saying n\\n\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer, Integer> mapForCounts = new   HashMap<Integer, Integer>();\\n        \\n        int count = 0;\\n        for(int a : answers){\\n            if(map.containsKey(a+1) && map.get(a+1)!= 0){\\n                map.put(a+1,map.get(a+1)-1);\\n            }\\n            else{\\n                map.put(a+1,a);\\n                count +=(a+1);\\n            }\\n           \\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "Intuition for this solution is that when we start counting no of rabbits but then when more than n no of rabbits say = n+1 then there\\'s new type of rabbit who\\'s saying n.\\n\\nThus keep decreasing count for n and if it\\'s zero, that\\'s a new category which is saying n\\n\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer, Integer> mapForCounts = new   HashMap<Integer, Integer>();\\n        \\n        int count = 0;\\n        for(int a : answers){\\n            if(map.containsKey(a+1) && map.get(a+1)!= 0){\\n                map.put(a+1,map.get(a+1)-1);\\n            }\\n            else{\\n                map.put(a+1,a);\\n                count +=(a+1);\\n            }\\n           \\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 248274,
                "title": "simple-to-understand-java-solution-outperforms-91-8",
                "content": "The code is based on the intuition of how many rabbits say a specific number. If the number of rabbits saying a specific number is more than one more than the number, then we understand that there are rabbits of a newly found colour. We use a `HashMap` to store this information, if there is a newly found number, then that is accounted for in the total count.\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int total = 0;\\n        int n = answers.length;\\n        if(n==0)\\n            return 0;\\n        HashMap<Integer,Integer> count = new HashMap<>();\\n        for(int a:answers){\\n            if(count.containsKey(a)){\\n                int k = count.get(a);\\n                if(k <= a){\\n                    count.put(a,k+1);\\n                }else{\\n                    total += a+1;\\n                    count.put(a,1);\\n                }\\n            }else{\\n                total += a+1;\\n                count.put(a,1);\\n            }\\n        }\\n        \\n        return total;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int total = 0;\\n        int n = answers.length;\\n        if(n==0)\\n            return 0;\\n        HashMap<Integer,Integer> count = new HashMap<>();\\n        for(int a:answers){\\n            if(count.containsKey(a)){\\n                int k = count.get(a);\\n                if(k <= a){\\n                    count.put(a,k+1);\\n                }else{\\n                    total += a+1;\\n                    count.put(a,1);\\n                }\\n            }else{\\n                total += a+1;\\n                count.put(a,1);\\n            }\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188114,
                "title": "o-1-space-4-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {        \\n        sort(answers.begin(), answers.end());\\n        int min_total = 0, curt_color_total = 0, curt_color_count = 0;\\n        for (int num : answers) {\\n            if (num + 1 != curt_color_total || curt_color_count == curt_color_total) {\\n                curt_color_total = num + 1;\\n                curt_color_count = 1;\\n                min_total += curt_color_total;\\n            } else {\\n                ++curt_color_count;\\n            }\\n        }\\n        return min_total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {        \\n        sort(answers.begin(), answers.end());\\n        int min_total = 0, curt_color_total = 0, curt_color_count = 0;\\n        for (int num : answers) {\\n            if (num + 1 != curt_color_total || curt_color_count == curt_color_total) {\\n                curt_color_total = num + 1;\\n                curt_color_count = 1;\\n                min_total += curt_color_total;\\n            } else {\\n                ++curt_color_count;\\n            }\\n        }\\n        return min_total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158254,
                "title": "scala-single-left-fold-solution",
                "content": "```\\ndef numRabbits(answers: Array[Int]): Int = {\\n  ((answers groupBy (x => x)).toList foldLeft 0) { (a, c) => \\n    val numGroups = (c._2.length - 1) / (c._1 + 1) + 1\\n    a + numGroups * (c._1 + 1)\\n  }\\n}\\n```\\nEach rabbit is grouped based on their answer. For any group n, up to n + 1 rabbits may be of the same colour. The minimum amount of rabbits occurs when each rabbit that answered is the same colour as other ones that answered with the same number. The rabbits that are left over must also be part of a group of n + 1 rabbits, where the remaining ones must not have answered. The number of these colour groups is  the ceiling of the number of rabbits in group n divided by n + 1, and the number of rabbits in total is the number of those groups multiplied by the group size (n + 1).\\n\\nThus, summing the min rabbits in each answer group gives the min total.",
                "solutionTags": [],
                "code": "```\\ndef numRabbits(answers: Array[Int]): Int = {\\n  ((answers groupBy (x => x)).toList foldLeft 0) { (a, c) => \\n    val numGroups = (c._2.length - 1) / (c._1 + 1) + 1\\n    a + numGroups * (c._1 + 1)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 136061,
                "title": "java-o-n-solution-beats-100",
                "content": "- It needs n+1 rabbits to match n*n in the input.\\n- Using int[] instead of HashMap to save the value count.\\n- Save the max index to stop the loop.\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        if(answers == null || answers.length == 0) return 0;\\n        int[] count = new int[1001];\\n        int ret = 0, max = 0;\\n        for(int a : answers) {\\n            max = Math.max(a, max);\\n            count[a] ++;\\n        }\\n        for(int i = 0; i <= max; i++){\\n            if(count[i] != 0)\\n                ret += (i + 1) * ((count[i] - 1)/(i + 1) + 1);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        if(answers == null || answers.length == 0) return 0;\\n        int[] count = new int[1001];\\n        int ret = 0, max = 0;\\n        for(int a : answers) {\\n            max = Math.max(a, max);\\n            count[a] ++;\\n        }\\n        for(int i = 0; i <= max; i++){\\n            if(count[i] != 0)\\n                ret += (i + 1) * ((count[i] - 1)/(i + 1) + 1);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122006,
                "title": "c-solution-with-explanation",
                "content": "Generally speaking, if a rabbit sees there are **x** rabbits with the same color, we know there are **x+1** total rabbits of that color.\\n\\nIt gets complicated when there are many rabbits giving the same answer. However, a pattern appears if you look at a few examples:\\nEx:\\n* `[0,0,0]` - can only be one 0 per color, so 3 colors\\n* `[1,1,1,1]` - can only be two 1s per color, so 2 colors\\n* `[2,2,2,2,2]` - can only be three 2s per color, so 2 colors\\n* `[3,3,3,3,3]` - can only be four 3s per color, so 2 colors\\n* etc...\\n\\nNote: multiple 0s follow a different pattern than multiples of any other number.\\n\\n\\nFinally, every rabbit who sees a unique number of rabbits is, itself, a unique color.\\nEx:\\n* `[1,2,3]` - three answering rabbits have three different answers, so at least 3 different colors\\n\\nUsing that information, I came up with this solution:\\n1. Sort the `answers` vector\\n2. Iterate through the zeros, and add 1 to the return value each time.\\n3. Iterate through the other numbers. Add the (value+1) to the return value. Then, avoid counting until either:\\n    a.) We see a new number  **or**\\n    b.) We\\'ve seen the same number enough times to where we\\'re on another color.\\n\\nHere\\'s the code:\\n\\n\\n```\\nint numRabbits(vector<int>& answers) {\\n\\n    sort(answers.begin(), answers.end());\\n\\n    int ret = 0;\\n    int repeatCnt = 0;\\n    int prev = 0;\\n    \\n    for(int i=0; i < answers.size(); ++i) {\\n\\n        const int currAns = answers[i];\\n\\n        // Handle 0 as a special case\\n        if (currAns == 0) {\\n\\n            ret += 1;\\n            continue;\\n\\n        } else if ((currAns != prev) || (repeatCnt <= i)) {\\n\\n            ret += (currAns + 1);\\n            prev = currAns;\\n            repeatCnt = (i + currAns + 1);\\n        }\\n    }\\n\\n    return ret;\\n}\\n```\\nThank you for reading!",
                "solutionTags": [],
                "code": "```\\nint numRabbits(vector<int>& answers) {\\n\\n    sort(answers.begin(), answers.end());\\n\\n    int ret = 0;\\n    int repeatCnt = 0;\\n    int prev = 0;\\n    \\n    for(int i=0; i < answers.size(); ++i) {\\n\\n        const int currAns = answers[i];\\n\\n        // Handle 0 as a special case\\n        if (currAns == 0) {\\n\\n            ret += 1;\\n            continue;\\n\\n        } else if ((currAns != prev) || (repeatCnt <= i)) {\\n\\n            ret += (currAns + 1);\\n            prev = currAns;\\n            repeatCnt = (i + currAns + 1);\\n        }\\n    }\\n\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 114957,
                "title": "python-explanation-in-simple-terms-no-hard-math",
                "content": "From a high-level perspective, we need to track how many rabbits are there altogether, and there are different amounts by color. In this situation, it is definitely appropriate to consider a hashmap to do all the counts and keep track of how many rabbits of each color that we have encountered.\n\nWe begin by iterating through the answers. We ask every rabbit this question: \"How many **other** of your color are there\"?\n\n1) If he answers 0, then that makes him unique. Just add 1 to the total count and move on.\n2) If his answer is not in the hashmap, that means we have not encountered this color yet. However, we will take whatever answer he gives and add it to the total count. Next, add 1 to this total because the answer from the rabbit is for **other** rabbits, not including himself.\n3) Otherwise, we increase the count for his color in the hashmap. If this count is the same as what all the other rabbits of this color are saying (ex: all oranges have to say that same amount of orange rabbits / all green rabbits have to report the same amount of green rabbits), then we will delete this count from the hashmap and we are done counting for this color.\n\nFinally, we just return the sum of the total counts.\n\n\n```\nclass Solution(object):\n    def numRabbits(self, answers):\n        \"\"\"\n        :type answers: List[int]\n        :rtype: int\n        \"\"\"\n        if len(answers) == 0:\n            return 0\n        \n        mp = collections.defaultdict(int)\n        summ = 0\n        \n        for i in answers:\n            if i == 0:\n                summ += 1\n                continue\n            if i not in mp:\n                mp[i] = 0\n                summ += (i + 1)\n            else:\n                mp[i] += 1\n                if mp[i] == i:\n                    mp.pop(i)\n        return summ\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def numRabbits(self, answers):\n        \"\"\"\n        :type answers: List[int]\n        :rtype: int\n        \"\"\"\n        if len(answers) == 0:\n            return 0\n        \n        mp = collections.defaultdict(int)\n        summ = 0\n        \n        for i in answers:\n            if i == 0:\n                summ += 1\n                continue\n            if i not in mp:\n                mp[i] = 0\n                summ += (i + 1)\n            else:\n                mp[i] += 1\n                if mp[i] == i:\n                    mp.pop(i)\n        return summ\n```",
                "codeTag": "Java"
            },
            {
                "id": 114716,
                "title": "java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int numRabbits(int[] ans) {\\n        if(ans == null || ans.length == 0)\\n            return 0;\\n        \\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int a : ans) {\\n            if(a == 0) {\\n                // There is no other rabbit of the same color, this is a unique rabbit\\n                count++;\\n                continue;\\n            }\\n            if(map.containsKey(a)) {\\n                // Some other rabbit has previously mentioned the same grouping number (same color)\\n                int expected = map.get(a);\\n                expected--;\\n                if(expected == 0) // Since we have found all the rabbits with the same grouping, lets reset\\n                    map.remove(a);\\n                else\\n                    map.put(a, expected);\\n            } else {\\n                // No other rabbit of the same color has been found\\n                map.put(a, a);\\n            }\\n            count++;\\n        }\\n        \\n        // Account for rabbits in the forest\\n        for(Map.Entry<Integer, Integer> entry : map.entrySet())\\n            count += entry.getValue();\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] ans) {\\n        if(ans == null || ans.length == 0)\\n            return 0;\\n        \\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int a : ans) {\\n            if(a == 0) {\\n                // There is no other rabbit of the same color, this is a unique rabbit\\n                count++;\\n                continue;\\n            }\\n            if(map.containsKey(a)) {\\n                // Some other rabbit has previously mentioned the same grouping number (same color)\\n                int expected = map.get(a);\\n                expected--;\\n                if(expected == 0) // Since we have found all the rabbits with the same grouping, lets reset\\n                    map.remove(a);\\n                else\\n                    map.put(a, expected);\\n            } else {\\n                // No other rabbit of the same color has been found\\n                map.put(a, a);\\n            }\\n            count++;\\n        }\\n        \\n        // Account for rabbits in the forest\\n        for(Map.Entry<Integer, Integer> entry : map.entrySet())\\n            count += entry.getValue();\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114706,
                "title": "concise-verbose-c-solutions-easy-to-understand-with-detailed-explanation",
                "content": "**Concise Solution #1:** unordered_map\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> m;\\n        for (auto ans: answers) ++m[ans];\\n        int r=0;\\n        for (auto x: m) r+=ceil((double)x.second/(x.first+1))*(x.first+1);\\n        return r;\\n    }\\n};\\n```\\n**Verbose Solution #1:** the above solution has been expanded below for simple understanding of how the key/value pair is associated.  The maximum group size is the answer provided by the rabbit plus one ( one is added onto the answer in order to also include the one rabbit who provided the answer ).  The minimum group amount for each answer then is the answer count divided by the maximum group size for that answer.  The minimum amount of new rabbits for each answer is then the minimum group amount for that answer multiplied by the maximum group size for that answer.  Return the cumulative sum of the minimum amount of new rabbits needed for each unique answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> m;\\n        for (auto answer: answers){\\n            ++m[answer];\\n        }\\n        int rabbits=0;\\n        for (auto x: m){\\n            int answer_count=x.second;\\n            int max_group_size=x.first+1;\\n            int min_group_amount=ceil((double)answer_count/max_group_size);\\n            int min_new_rabbits=min_group_amount*max_group_size;\\n            rabbits+=min_new_rabbits;\\n        }\\n        return rabbits;\\n    }\\n};\\n```\\n\\n**Concise Solution #2:** vector\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        const int N=1000;\\n        vector<int> v(N+1,0);\\n        for (auto ans: answers) ++v[ans];\\n        for (int i=0; i<N; ++i) v[N]+=ceil((double)v[i]/(i+1))*(i+1);\\n        return v[N];\\n    }\\n};\\n```\\n\\n**Verbose Solution #2:** expanded similar to above solution #1.  Same concept as above, however, the vector index is used as the answer key and the vector value is the answer count.\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        const int N=1000;\\n        vector<int> v(N+1,0);\\n        for (auto answer: answers){\\n            ++v[answer];\\n        }\\n        int rabbits=0;\\n        for (int i=0; i<N; ++i){\\n            int answer_count=v[i];\\n            int max_group_size=i+1;\\n            int min_group_amount=ceil((double)answer_count/max_group_size);\\n            int min_new_rabbits=min_group_amount*max_group_size;\\n            rabbits+=min_new_rabbits;\\n        }\\n        return rabbits;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> m;\\n        for (auto ans: answers) ++m[ans];\\n        int r=0;\\n        for (auto x: m) r+=ceil((double)x.second/(x.first+1))*(x.first+1);\\n        return r;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> m;\\n        for (auto answer: answers){\\n            ++m[answer];\\n        }\\n        int rabbits=0;\\n        for (auto x: m){\\n            int answer_count=x.second;\\n            int max_group_size=x.first+1;\\n            int min_group_amount=ceil((double)answer_count/max_group_size);\\n            int min_new_rabbits=min_group_amount*max_group_size;\\n            rabbits+=min_new_rabbits;\\n        }\\n        return rabbits;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        const int N=1000;\\n        vector<int> v(N+1,0);\\n        for (auto ans: answers) ++v[ans];\\n        for (int i=0; i<N; ++i) v[N]+=ceil((double)v[i]/(i+1))*(i+1);\\n        return v[N];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        const int N=1000;\\n        vector<int> v(N+1,0);\\n        for (auto answer: answers){\\n            ++v[answer];\\n        }\\n        int rabbits=0;\\n        for (int i=0; i<N; ++i){\\n            int answer_count=v[i];\\n            int max_group_size=i+1;\\n            int min_group_amount=ceil((double)answer_count/max_group_size);\\n            int min_new_rabbits=min_group_amount*max_group_size;\\n            rabbits+=min_new_rabbits;\\n        }\\n        return rabbits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114703,
                "title": "simple-python-solution",
                "content": "    def numRabbits(self, answers):\\n        min_rabbits = 0\\n        c = Counter(answers)\\n        for k in c.keys():\\n            min_rabbits += ceil(c[k] / (k + 1)) * (k + 1)\\n        return min_rabbits",
                "solutionTags": [],
                "code": "    def numRabbits(self, answers):\\n        min_rabbits = 0\\n        c = Counter(answers)\\n        for k in c.keys():\\n            min_rabbits += ceil(c[k] / (k + 1)) * (k + 1)\\n        return min_rabbits",
                "codeTag": "Python3"
            },
            {
                "id": 4070981,
                "title": "c-greedy-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int freq[1000] = {0};\\n        for(int ans: answers) {\\n            freq[ans]++;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < 1000; i++) {\\n            if(freq[i])\\n                ans += (i + 1) * ceil(freq[i] * 1.0 / (i + 1)); \\n        }\\n        return ans;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> freq;\\n        for(int ans: answers) {\\n            freq[ans]++;\\n        }\\n        int ans = 0;\\n        for(auto iter: freq) {\\n            ans += (iter.first + 1) * ceil(iter.second * 1.0 / (iter.first + 1)); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int freq[1000] = {0};\\n        for(int ans: answers) {\\n            freq[ans]++;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < 1000; i++) {\\n            if(freq[i])\\n                ans += (i + 1) * ceil(freq[i] * 1.0 / (i + 1)); \\n        }\\n        return ans;\\n    }\\n};\\n\\nOR\\n\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> freq;\\n        for(int ans: answers) {\\n            freq[ans]++;\\n        }\\n        int ans = 0;\\n        for(auto iter: freq) {\\n            ans += (iter.first + 1) * ceil(iter.second * 1.0 / (iter.first + 1)); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069315,
                "title": "hashmap-brainteaser",
                "content": "\\u633A\\u6709\\u8DA3\\u7684\\u4E00\\u9053\\u9898\\uFF0C\\u903B\\u8F91brainteaser\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int[] freq = new int[1000];\\n        for (int ans : answers) {\\n            freq[ans]++;\\n        }\\n\\n        // how many rabbits say there are ith other rabbits have the same color? \\n        // one rabbit said there are two other the same. Then totally minimally can be only three rabbits of the same color.\\n        int res = 0;\\n        for (int i = 0; i < 1000; i++) {\\n            if (freq[i] == 0) continue;\\n            boolean hasMode = freq[i] % (i + 1) != 0;\\n            int clusterOfRabbits = freq[i] / (i + 1) + (hasMode ? 1 : 0);\\n            res += (i + 1) * clusterOfRabbits; // anyway\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int[] freq = new int[1000];\\n        for (int ans : answers) {\\n            freq[ans]++;\\n        }\\n\\n        // how many rabbits say there are ith other rabbits have the same color? \\n        // one rabbit said there are two other the same. Then totally minimally can be only three rabbits of the same color.\\n        int res = 0;\\n        for (int i = 0; i < 1000; i++) {\\n            if (freq[i] == 0) continue;\\n            boolean hasMode = freq[i] % (i + 1) != 0;\\n            int clusterOfRabbits = freq[i] / (i + 1) + (hasMode ? 1 : 0);\\n            res += (i + 1) * clusterOfRabbits; // anyway\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060051,
                "title": "python3-solution-beginner-friendly",
                "content": "# Intuition\\nFor an answer k, there are k + 1 possible rabbits that could answer the same thing with the same colour. So, we can create a dictionairy that keeps track of how many rabbits that have said the same answer. If it is greater than k + 1, we exhausted all rabbits with the same colour and so a different colour must be answering.\\n# Approach\\nCreate a dictionary to track the answers. Then iterate through the answers. If an answer is zero, that rabbit must be a unique colour so add one to our count. Otherwise, we add the answer to our dictionairy if we have not seen it before. If we have seen the answer before, add one to our dictionairy and if the value is equal to k + 1, add k + 1 to our count and reset to zero.\\n\\nOnce we have finished iterating through the answers, any left over values in rabbit that are strictly above zero can have k + 1 possible rabbits sharing the same colour, so we add the remaining ones to our total count.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ as we iterate through the answers once, and then through our dictionairy which will be smaller or equal to the size of answers as the dictionairy can have at most n unique entries.\\n\\n- Space complexity:\\n$$O(n)$$ as we can store up to n unique values.\\n\\n# Code\\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        rabbit_values = {}\\n        count = 0\\n        for answer in answers:\\n            if answer == 0:\\n                count += 1\\n            elif answer not in rabbit_values:\\n                rabbit_values[answer] = 1\\n            else:\\n                rabbit_values[answer] += 1\\n                if rabbit_values[answer] == answer + 1:\\n                    count += answer + 1\\n                    rabbit_values[answer] = 0\\n        \\n        for key in rabbit_values:\\n            if rabbit_values[key] > 0:\\n                count += key + 1\\n        return count\\n```\\n\\nIf you have any criticism, feel free to comment!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        rabbit_values = {}\\n        count = 0\\n        for answer in answers:\\n            if answer == 0:\\n                count += 1\\n            elif answer not in rabbit_values:\\n                rabbit_values[answer] = 1\\n            else:\\n                rabbit_values[answer] += 1\\n                if rabbit_values[answer] == answer + 1:\\n                    count += answer + 1\\n                    rabbit_values[answer] = 0\\n        \\n        for key in rabbit_values:\\n            if rabbit_values[key] > 0:\\n                count += key + 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049495,
                "title": "java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int a: answers) map.put(a,map.getOrDefault(a,0)+1);\\n\\n\\n        int noOfRabbits=0;\\n\\n        for(int key : map.keySet()){\\n            int grupSize=key+1;\\n            int noOfGrup=map.get(key)/grupSize;\\n            if(map.get(key)%grupSize!=0){\\n                noOfGrup+=1;\\n            }\\n            noOfRabbits+=noOfGrup*grupSize;\\n        }\\n        return noOfRabbits;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int a: answers) map.put(a,map.getOrDefault(a,0)+1);\\n\\n\\n        int noOfRabbits=0;\\n\\n        for(int key : map.keySet()){\\n            int grupSize=key+1;\\n            int noOfGrup=map.get(key)/grupSize;\\n            if(map.get(key)%grupSize!=0){\\n                noOfGrup+=1;\\n            }\\n            noOfRabbits+=noOfGrup*grupSize;\\n        }\\n        return noOfRabbits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000374,
                "title": "simple-c-solution-easy-map-implementation",
                "content": "```\\nint numRabbits(vector<int>& answers) \\n    {\\n        map<int,int>m;\\n        for(int i=0;i<answers.size();i++)\\n        {\\n            m[answers[i]]++;\\n        }\\n        int ans=0;\\n        for(auto i:m)\\n        {\\n            int color=i.first;\\n            int num=i.second;\\n            \\n            ans+=( ceil((float)num/(color+1)) )*(color+1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nint numRabbits(vector<int>& answers) \\n    {\\n        map<int,int>m;\\n        for(int i=0;i<answers.size();i++)\\n        {\\n            m[answers[i]]++;\\n        }\\n        int ans=0;\\n        for(auto i:m)\\n        {\\n            int color=i.first;\\n            int num=i.second;\\n            \\n            ans+=( ceil((float)num/(color+1)) )*(color+1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991598,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int map[] =  new int[1000];\\n        for(int ele : answers){\\n            map[ele]+=1;\\n        }\\n        int rabbit =  0;\\n        \\n        for(int i=0;i<1000;i++){\\n            int grp  = i+1;\\n            int c =  map[i];\\n            int count = (int) Math.ceil( (c*1.0)/grp ) * grp;\\n            rabbit+= count;            \\n        }\\n        return rabbit;\\n    }\\n}\\n\\n\\n```c++ []\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n      unordered_map<int,int>mp;\\n      int ans=0;\\n      for(auto i:answers)\\n          mp[i]++;\\n    for(auto itr:mp)\\n    {\\n        if(itr.first+1>=itr.second)\\n        ans+=itr.first+1;\\n        else\\n        ans+=ceil(1.0*itr.second/(itr.first+1))*(itr.first+1);\\n        \\n    }\\n      return ans;\\n    }\\n};\\n```\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int map[] =  new int[1000];\\n        for(int ele : answers){\\n            map[ele]+=1;\\n        }\\n        int rabbit =  0;\\n        \\n        for(int i=0;i<1000;i++){\\n            int grp  = i+1;\\n            int c =  map[i];\\n            int count = (int) Math.ceil( (c*1.0)/grp ) * grp;\\n            rabbit+= count;            \\n        }\\n        return rabbit;\\n    }\\n}\\n\\n\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967912,
                "title": "java-hashmap-solution-awesome-problem",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int p : answers){\\n            map.put(p, map.getOrDefault(p, 0)+1);\\n        }\\n        int count = 0;\\n        for(int p : map.keySet()){\\n            int grp_size = p + 1;\\n            int reported_rabbits = map.get(p);\\n            int groups= (int)Math.ceil(reported_rabbits*1.0/ grp_size*1.0);\\n            count += groups * grp_size;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int p : answers){\\n            map.put(p, map.getOrDefault(p, 0)+1);\\n        }\\n        int count = 0;\\n        for(int p : map.keySet()){\\n            int grp_size = p + 1;\\n            int reported_rabbits = map.get(p);\\n            int groups= (int)Math.ceil(reported_rabbits*1.0/ grp_size*1.0);\\n            count += groups * grp_size;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954170,
                "title": "simple-to-understand-intuition-greedy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:   O(N)\\n\\n- Space complexity:  O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //observation : firstly , firstly  we think optimistically, where all the rabbits telling about each other of same group/colour and all group memberers present in survey. (we think because we need minimum count of rabbits)\\n    int numRabbits(vector<int>& ans) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<ans.size();i++){\\n            mp[ans[i]]++;\\n        }\\n        int min_rab=0;\\n        for(auto ele : mp){   // ele.first+1 is the no.of rabbits in same colour group.\\n                                        //ele.first+1==same colour group size.\\n            if(ele.second==1){\\n                min_rab+=ele.first+1;\\n            }\\n            else{\\n                if(ele.second-1==ele.first){  //one single group only\\n                    min_rab+=ele.second;\\n                }\\n                else{ //\\n                    int mult  =   ele.second / (ele.first+1);\\n                    int reminder= ele.second % (ele.first+1);\\n                    if(reminder){//if we get reminder,so other group/colour will exist with same size \\n                          min_rab +=(ele.first+1)*mult + ele.first+1;\\n                    }\\n                    else{\\n                        min_rab+= (ele.first+1)*mult;\\n                    }\\n                }\\n            }\\n        }\\n        return min_rab;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //observation : firstly , firstly  we think optimistically, where all the rabbits telling about each other of same group/colour and all group memberers present in survey. (we think because we need minimum count of rabbits)\\n    int numRabbits(vector<int>& ans) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<ans.size();i++){\\n            mp[ans[i]]++;\\n        }\\n        int min_rab=0;\\n        for(auto ele : mp){   // ele.first+1 is the no.of rabbits in same colour group.\\n                                        //ele.first+1==same colour group size.\\n            if(ele.second==1){\\n                min_rab+=ele.first+1;\\n            }\\n            else{\\n                if(ele.second-1==ele.first){  //one single group only\\n                    min_rab+=ele.second;\\n                }\\n                else{ //\\n                    int mult  =   ele.second / (ele.first+1);\\n                    int reminder= ele.second % (ele.first+1);\\n                    if(reminder){//if we get reminder,so other group/colour will exist with same size \\n                          min_rab +=(ele.first+1)*mult + ele.first+1;\\n                    }\\n                    else{\\n                        min_rab+= (ele.first+1)*mult;\\n                    }\\n                }\\n            }\\n        }\\n        return min_rab;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953254,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        Output = 0\\n        d = dict(Counter(answers))\\n\\n        for i in d:\\n            if i == 0:\\n                Output = Output + d[i]\\n            elif i != 0:\\n                if d[i] <= i + 1:\\n                    Output = Output + ( i + 1 )\\n                elif d[i] > i + 1:\\n                    if d[i] % ( i + 1 ) != 0:\\n                        Output = Output + ( i + 1 ) * ( d[i] // ( i + 1 ) + 1 )\\n                    elif d[i] % ( i + 1 ) == 0:\\n                        Output = Output + ( i + 1 ) * ( d[i] // ( i + 1 ) )\\n                        \\n        return Output\\n\\n        # 20230824\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        Output = 0\\n        d = dict(Counter(answers))\\n\\n        for i in d:\\n            if i == 0:\\n                Output = Output + d[i]\\n            elif i != 0:\\n                if d[i] <= i + 1:\\n                    Output = Output + ( i + 1 )\\n                elif d[i] > i + 1:\\n                    if d[i] % ( i + 1 ) != 0:\\n                        Output = Output + ( i + 1 ) * ( d[i] // ( i + 1 ) + 1 )\\n                    elif d[i] % ( i + 1 ) == 0:\\n                        Output = Output + ( i + 1 ) * ( d[i] // ( i + 1 ) )\\n                        \\n        return Output\\n\\n        # 20230824\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951598,
                "title": "simple-hashmap-solution-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun numRabbits(answers: IntArray): Int {\\n       var count = 0\\n       // initialize empty map with default values as 0\\n        val map = answers.toList().associateWith { 0 }.toMutableMap()\\n\\n        for(r in answers) {\\n            if(map[r]!! == 0) {\\n                count += r + 1\\n\\n                // corner case when value is zero;\\n                // increment count by 1 for all zeros\\n                if(r == 0) continue\\n\\n            } else if(map[r]!! == r) {\\n\\n                // if all others rabbits are found for same color\\n                // reset the map value for new color group\\n                map[r] = 0\\n                continue\\n            }\\n            // increment count for each\\n            map[r] = map[r]!! + 1\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun numRabbits(answers: IntArray): Int {\\n       var count = 0\\n       // initialize empty map with default values as 0\\n        val map = answers.toList().associateWith { 0 }.toMutableMap()\\n\\n        for(r in answers) {\\n            if(map[r]!! == 0) {\\n                count += r + 1\\n\\n                // corner case when value is zero;\\n                // increment count by 1 for all zeros\\n                if(r == 0) continue\\n\\n            } else if(map[r]!! == r) {\\n\\n                // if all others rabbits are found for same color\\n                // reset the map value for new color group\\n                map[r] = 0\\n                continue\\n            }\\n            // increment count for each\\n            map[r] = map[r]!! + 1\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944844,
                "title": "simple-c-solution-using-hashmap",
                "content": "# Intuition\\nwe have to claculate minimum no. of rabbits. so is store the values in map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst store the values in map like (for eg [1,1,2] so first rabbit say there is one more rabbit like me so in map 1:1 so second rabbit also say there another rabbit like me so 1:1 in map become 1:2 like you have to assign values in map) \\n\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& ans) {\\n      map<int, int>mp;\\n      for(int i=0;i<ans.size();i++){\\n          mp[ans[i]]++;\\n      }\\n      int sum=0;\\n      for(auto i :mp){\\n          int x=i.second;\\n          int y=i.first+1;\\n          int temp=(x+y-1)/y;\\n\\n          sum+=temp*y;\\n\\n      }\\n      return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& ans) {\\n      map<int, int>mp;\\n      for(int i=0;i<ans.size();i++){\\n          mp[ans[i]]++;\\n      }\\n      int sum=0;\\n      for(auto i :mp){\\n          int x=i.second;\\n          int y=i.first+1;\\n          int temp=(x+y-1)/y;\\n\\n          sum+=temp*y;\\n\\n      }\\n      return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919266,
                "title": "for-begineers-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<answers.size();i++){\\n            mp[answers[i]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second<=x.first+1){\\n                ans+=x.first+1;\\n            }\\n            else{\\n               while(x.second>0){\\n                   ans+=x.first+1;\\n                   x.second=x.second-(x.first+1);\\n               }\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<answers.size();i++){\\n            mp[answers[i]]++;\\n        }\\n        for(auto x:mp){\\n            if(x.second<=x.first+1){\\n                ans+=x.first+1;\\n            }\\n            else{\\n               while(x.second>0){\\n                   ans+=x.first+1;\\n                   x.second=x.second-(x.first+1);\\n               }\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916166,
                "title": "rabbits-in-forest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} answers\\n * @return {number}\\n */\\nvar numRabbits = function(answers) {\\n    let countMap = new Map(); // Using a map to store the count of rabbits for each answer\\n    let count = 0;\\n    \\n    for (let i = 0; i < answers.length; i++) {\\n        let answer = answers[i];\\n        if (answer === 0) {\\n            count++; // Count rabbits that answered 0\\n        } else {\\n            if (!countMap.has(answer) || countMap.get(answer) === 0) {\\n                countMap.set(answer, answer); // Set the count for this answer\\n                count += answer + 1;\\n            } else {\\n                countMap.set(answer, countMap.get(answer) - 1);\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} answers\\n * @return {number}\\n */\\nvar numRabbits = function(answers) {\\n    let countMap = new Map(); // Using a map to store the count of rabbits for each answer\\n    let count = 0;\\n    \\n    for (let i = 0; i < answers.length; i++) {\\n        let answer = answers[i];\\n        if (answer === 0) {\\n            count++; // Count rabbits that answered 0\\n        } else {\\n            if (!countMap.has(answer) || countMap.get(answer) === 0) {\\n                countMap.set(answer, answer); // Set the count for this answer\\n                count += answer + 1;\\n            } else {\\n                countMap.set(answer, countMap.get(answer) - 1);\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894810,
                "title": "one-line-logic-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& arr) \\n    {\\n      int n=arr.size();\\n      unordered_map<int,double>freq;\\n\\n      for(int i=0;i<n;i++)\\n        freq[arr[i]]++;\\n      \\n      int ans=0;\\n\\n      for(auto x:freq)\\n        ans+=ceil(x.second/(x.first+1))*(x.first+1);\\n\\n      return ans;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& arr) \\n    {\\n      int n=arr.size();\\n      unordered_map<int,double>freq;\\n\\n      for(int i=0;i<n;i++)\\n        freq[arr[i]]++;\\n      \\n      int ans=0;\\n\\n      for(auto x:freq)\\n        ans+=ceil(x.second/(x.first+1))*(x.first+1);\\n\\n      return ans;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878307,
                "title": "python-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Uses dictionary to count the frequency of each element\\n2. By considering test cases e.g. [2,2,2] has 3 rabbits but [2,2,2,2] has 3 + 3 rabbits (minimum) then we arrive at a formula for the minimum number of groups corresponding to each distinct element in answer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n\\n    def numRabbits(self, answers: List[int]) -> int:\\n\\n        answersdict = Counter(answers)\\n\\n        counter = 0\\n\\n        totsum = 0\\n        \\n        for j in answersdict.keys():\\n\\n            counter += math.ceil(answersdict[j] / (j + 1)) * (j + 1)\\n\\n        return counter\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n\\n    def numRabbits(self, answers: List[int]) -> int:\\n\\n        answersdict = Counter(answers)\\n\\n        counter = 0\\n\\n        totsum = 0\\n        \\n        for j in answersdict.keys():\\n\\n            counter += math.ceil(answersdict[j] / (j + 1)) * (j + 1)\\n\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846741,
                "title": "shortest-code-with-explanation-and-examples",
                "content": "# Intuition\\n<!-- D1escribe your first thoughts on how to solve this problem. -->\\nSimple Maths approach with shortest answers \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Step 1**\\nFirst We store each answers count in an unorderd map.\\n**Step 2**\\nIterate Over every map element\\n**Step 3**\\n*Example 1*\\n[4,4,5]\\n2 answers were 4 so they will be of same colour and 1 answer was 5 so total in this case is (4+1)+(5+1)=11 \\nWe are adding 1 because we have to include the person who is answering.\\n\\n\\n*Example 2*\\n[4,4,4,4,4,4,4,5]\\n7 answers were 4 and 1 answer is 5.\\nHere we have to see all rabbits answering 4 cannot be of same colour so this case we have to remember any answer can be max valid upto (ans+1) number of sheeps.\\nso our answer here will be (4+1)+(4+1)+(5+1)\\ninorder to know how many times we have to do 4+1 = ceil(anscount/answer+1)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\niterating over every element in answers is O(n)\\nIterating over every map element in worst case is O(n)\\neffective\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) since we are using map\\nIf O(1) solution is needed comment below.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans = 0;\\n        unordered_map<int,int> m;\\n        for(auto i:answers){\\n            m[i]++;\\n        }\\n        for(auto j:m){\\n            //see description example\\n            double x = ceil((j.second*1.0)/(j.first+1))*(j.first+1);\\n            ans+=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans = 0;\\n        unordered_map<int,int> m;\\n        for(auto i:answers){\\n            m[i]++;\\n        }\\n        for(auto j:m){\\n            //see description example\\n            double x = ceil((j.second*1.0)/(j.first+1))*(j.first+1);\\n            ans+=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835265,
                "title": "clean-code-99-beats-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        dic,res=dict(),0\\n        for i in answers:\\n            if i in dic:dic[i]+=1\\n            else:dic[i]=1\\n        for i,j in dic.items():\\n            if (j%(i+1))%(i+1)==0:res+=((j//(i+1))*(i+1))\\n            else:res+=(((j//(i+1))+1)*(i+1))\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Greedy",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        dic,res=dict(),0\\n        for i in answers:\\n            if i in dic:dic[i]+=1\\n            else:dic[i]=1\\n        for i,j in dic.items():\\n            if (j%(i+1))%(i+1)==0:res+=((j//(i+1))*(i+1))\\n            else:res+=(((j//(i+1))+1)*(i+1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821424,
                "title": "using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n       int n=answers.size();\\n      unordered_map<int,int> mp;\\n      for(auto it:answers) mp[it]++;\\n      int ans=0;\\n      for(auto it: mp){\\n          int p=it.first;\\n          int m=it.second;\\n          int x=(m+p)/(p+1);\\n          ans+=(x*(p+1));\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n       int n=answers.size();\\n      unordered_map<int,int> mp;\\n      for(auto it:answers) mp[it]++;\\n      int ans=0;\\n      for(auto it: mp){\\n          int p=it.first;\\n          int m=it.second;\\n          int x=(m+p)/(p+1);\\n          ans+=(x*(p+1));\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736713,
                "title": "easy-solution-using-math-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> mp;\\n        int count=0;\\n        for (auto it:answers){\\n            mp[it]++;\\n        }\\n        for (auto it: mp){\\n            if (it.first==0) count+=it.second;\\n            else if (it.second<=it.first+1){\\n                count+=it.first+1;\\n            }\\n            else {\\n                count+=ceil(1.0*it.second/(it.first+1))*(it.first+1);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int> mp;\\n        int count=0;\\n        for (auto it:answers){\\n            mp[it]++;\\n        }\\n        for (auto it: mp){\\n            if (it.first==0) count+=it.second;\\n            else if (it.second<=it.first+1){\\n                count+=it.first+1;\\n            }\\n            else {\\n                count+=ceil(1.0*it.second/(it.first+1))*(it.first+1);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716952,
                "title": "best-solution-beginner-friendly-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) for loops and O(n logn) for sorting \\n\\n- Overall Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int n=answers.size();\\n        int ans=n;\\n        sort(answers.begin(),answers.end());\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            ans=ans+answers[i];\\n            while(j<answers[i] && i+j < n){   \\n                if(answers[i]==answers[i+j+1]){\\n                    ans--;\\n                    j++;\\n                   \\n                }else break;\\n            }\\n            i=i+j;\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int n=answers.size();\\n        int ans=n;\\n        sort(answers.begin(),answers.end());\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            ans=ans+answers[i];\\n            while(j<answers[i] && i+j < n){   \\n                if(answers[i]==answers[i+j+1]){\\n                    ans--;\\n                    j++;\\n                   \\n                }else break;\\n            }\\n            i=i+j;\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714072,
                "title": "easy-python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numRabbits(self, ans):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dick={}\\n        l=len(ans)\\n        for i in range(0,l):\\n            val=ans[i]\\n            if val in dick:\\n                dick[val]+=1\\n            else:\\n                dick[val]=1\\n        ans=0\\n        for key in dick:\\n            val=key+1\\n            count=dick[key]\\n            if count%val==0:\\n                ans=ans+(count/val)*val\\n            else:\\n                ans=ans+((count/val)+1)*val\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numRabbits(self, ans):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dick={}\\n        l=len(ans)\\n        for i in range(0,l):\\n            val=ans[i]\\n            if val in dick:\\n                dick[val]+=1\\n            else:\\n                dick[val]=1\\n        ans=0\\n        for key in dick:\\n            val=key+1\\n            count=dick[key]\\n            if count%val==0:\\n                ans=ans+(count/val)*val\\n            else:\\n                ans=ans+((count/val)+1)*val\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705381,
                "title": "c-simple-one-line-calculation-solution-formula-approach",
                "content": "# Intuition\\n 1. Calculating the frequency of every element.\\n 2. If a number is ocurring till \"itself+1\" times, then there will be minimum of \"itself+1\" rabbits of same color.\\n 3. For example: if \\'3\\' is occuring 1 or 2 or 3 or 4 times then, there will be \\'3+1\\' rabbits of same color, because they are saying about each other.\\n\\n\\n# Detailed Explanation\\n```\\nAssume array : 3 3 3 3\\nof rabbits : R1, R2, R3, R4\\n\\nnum = 3\\nfrequency = 4\\n```\\nIf num was -\\n\\n**Occuring 1 time :**\\nR1 is saying there are three rabbits - R2, R3, R4 of the same color.\\n(I am writing it as)\\n\\n    R1 : R2, R3, R4\\n\\n    Minimum Rabbits = 4\\n\\n**Occuring 2 times :** \\n\\n    R1 : R2, R3, R4\\n    R2 : R1, R3, R4\\n\\n    Minimum Rabbits = 4\\n(this means, we are not asking Rabbits R3 and R4, but can still count their presence)\\n\\n\\n**Occuring 3 times :** \\n\\n    R1 : R2, R3, R4\\n    R2 : R1, R3, R4\\n    R3 : R1, R2, R4\\n\\n    Minimum Rabbits = 4\\n\\n**Occuring 4 times :** \\n\\n    R1 : R2, R3, R4\\n    R2 : R1, R3, R4\\n    R3 : R1, R2, R4\\n    R4 : R1, R2, R3\\n\\n    Minimum Rabbits = 4\\n\\nSo, till \\'n+1\\' all are pointing to everyone else.\\n\\n**Occuring 5 times :** \\n\\n    R1 : R2, R3, R4\\n    R2 : R1, R3, R4\\n    R3 : R1, R2, R4\\n    R4 : R1, R2, R3\\n\\n    Color : White\\n    Rabbits = 4\\n\\n    \\'Rabbit 5\\' will not talk about R1 or R2 or R3 or R4, because they\\n    haven\\'t included R5 in their counting, which means R5 should be of\\n    different color.\\n\\n    So, R5 will say -\\n\\n    R5 : R6, R7, R8\\n\\n    Color : Black\\n    Rabbits = 4\\n\\n\\n    Minimum Rabbits = 4 White + 4 Black = 8\\n\\n**Occuring 6 times :** \\n\\n    R1 : R2, R3, R4\\n    R2 : R1, R3, R4\\n    R3 : R1, R2, R4\\n    R4 : R1, R2, R3\\n\\n    Color : White\\n    Rabbits = 4\\n\\n\\n    R5 : R6, R7, R8\\n    R6 : R5, R7, R8\\n\\n    Color : Black\\n    Rabbits = 4\\n\\n\\n    Minimum Rabbits : 8\\n\\n\\n**Occuring 7 times :** \\n\\n    R1 : R2, R3, R4\\n    R2 : R1, R3, R4\\n    R3 : R1, R2, R4\\n    R4 : R1, R2, R3\\n\\n    Color : White\\n    Rabbits = 4\\n\\n\\n    R5 : R6, R7, R8\\n    R6 : R5, R7, R8\\n    R7 : R5, R6, R8\\n\\n    Color : Black\\n    Rabbits = 4\\n\\n\\n    Minimum Rabbits : 8\\n\\n**Occuring 8 times :** \\n\\n    R1 : R2, R3, R4\\n    R2 : R1, R3, R4\\n    R3 : R1, R2, R4\\n    R4 : R1, R2, R3\\n\\n    Color : White\\n    Rabbits = 4\\n\\n\\n    R5 : R6, R7, R8\\n    R6 : R5, R7, R8\\n    R7 : R5, R6, R8\\n    R8 : R5, R6, R7\\n\\n    Color : Black\\n    Rabbits = 4\\n\\n\\n    Minimum Rabbits : 8\\n\\nSo, till every \\'n+1\\' there will be \\'n+1\\' rabbits.\\n\\n```\\nval += ceil(it.second / (it.first + 1.0))*(it.first + 1);\\n\\nit.first : num\\nit.second : frequency\\n```\\n```\\nceil(frequency/(num+1)) will give the number of groups of one \\ncolor to be considered, and multiplying with (num+1) will give\\nthe minimum rabbits.\\n```\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n{ignoring the worst case complexity of unordered_map}\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& ans) {\\n        unordered_map<int,int> map;\\n        for(auto it : ans){\\n            ++map[it];\\n        }\\n        \\n        int val = 0;\\n        for(auto it : map){\\n            val += ceil(it.second / (it.first + 1.0))*(it.first + 1);\\n        }\\n\\n        return val;\\n    }\\n};\\n```\\nI hope everyone will like my explanation.\\nIf you have any doubt, feel free to ask me, I will definitely answer it :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nAssume array : 3 3 3 3\\nof rabbits : R1, R2, R3, R4\\n\\nnum = 3\\nfrequency = 4\\n```\n```\\nval += ceil(it.second / (it.first + 1.0))*(it.first + 1);\\n\\nit.first : num\\nit.second : frequency\\n```\n```\\nceil(frequency/(num+1)) will give the number of groups of one \\ncolor to be considered, and multiplying with (num+1) will give\\nthe minimum rabbits.\\n```\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& ans) {\\n        unordered_map<int,int> map;\\n        for(auto it : ans){\\n            ++map[it];\\n        }\\n        \\n        int val = 0;\\n        for(auto it : map){\\n            val += ceil(it.second / (it.first + 1.0))*(it.first + 1);\\n        }\\n\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697678,
                "title": "easy-greedy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStore frequency of elements in map and try to replicate logic in problem\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(int i:answers){\\n            mp[i]++;\\n        }\\n        for(auto i:mp){\\n            if(i.second<=i.first+1){\\n                ans+=(1+i.first);\\n            }\\n            else if(i.second>(i.first+1)){\\n                ans+=(i.second/(i.first+1))*(i.first+1);\\n                if(i.second % (1+i.first) !=0){\\n                  ans+=i.first+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```********PLEASE UPVOTE IF FOUND USEFUL******",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans=0;\\n        unordered_map<int,int> mp;\\n        for(int i:answers){\\n            mp[i]++;\\n        }\\n        for(auto i:mp){\\n            if(i.second<=i.first+1){\\n                ans+=(1+i.first);\\n            }\\n            else if(i.second>(i.first+1)){\\n                ans+=(i.second/(i.first+1))*(i.first+1);\\n                if(i.second % (1+i.first) !=0){\\n                  ans+=i.first+1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693360,
                "title": "clean-codes-97-30-time-efficient-and-94-59-space-efficient-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        dict = {}\\n        count = 0\\n        for i in answers:\\n            if i not in dict:\\n                dict[i] = 1\\n            else:\\n                dict[i] = dict[i] + 1\\n        for i in dict:\\n            if i == 0:\\n                count = count + dict[i]\\n            else:\\n                if dict[i] % (i+1) == 0:\\n                    count = count + dict[i]\\n                else:\\n                    count = count + dict[i] + ((i+1)-dict[i]%(i+1))\\n        return count\\n\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        dict = {}\\n        count = 0\\n        for i in answers:\\n            if i not in dict:\\n                dict[i] = 1\\n            else:\\n                dict[i] = dict[i] + 1\\n        for i in dict:\\n            if i == 0:\\n                count = count + dict[i]\\n            else:\\n                if dict[i] % (i+1) == 0:\\n                    count = count + dict[i]\\n                else:\\n                    count = count + dict[i] + ((i+1)-dict[i]%(i+1))\\n        return count\\n\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682041,
                "title": "o-n-space-time-complexity",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public:\\n    int numRabbits(vector<int>& a) {\\n        sort(begin(a), end(a));\\n        a.push_back(0);\\n\\n        int n = a.size();\\n\\n        int count = 1;\\n        int ans = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (a[i] != a[i - 1]) {\\n                int val = a[i - 1] + 1;\\n                ans += (count / val) * val;\\n                if(count % val != 0)\\n                    ans += val;\\n                \\n                count = 1;\\n            } else {\\n                count++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int numRabbits(vector<int>& a) {\\n        sort(begin(a), end(a));\\n        a.push_back(0);\\n\\n        int n = a.size();\\n\\n        int count = 1;\\n        int ans = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (a[i] != a[i - 1]) {\\n                int val = a[i - 1] + 1;\\n                ans += (count / val) * val;\\n                if(count % val != 0)\\n                    ans += val;\\n                \\n                count = 1;\\n            } else {\\n                count++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653241,
                "title": "c-very-easy",
                "content": "# Intuition\\nThere cannot be more than (i+1) rabbits of same color with answer i.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        \\n        unordered_map<int, int> mp;\\n        int rv = 0;\\n\\n        for(int ans: answers)\\n            mp[ans]++;\\n\\n        for(auto p: mp)\\n            rv += ceil( p.second*1.0/(p.first+1) ) * (p.first+1);       \\n\\n        return rv;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        \\n        unordered_map<int, int> mp;\\n        int rv = 0;\\n\\n        for(int ans: answers)\\n            mp[ans]++;\\n\\n        for(auto p: mp)\\n            rv += ceil( p.second*1.0/(p.first+1) ) * (p.first+1);       \\n\\n        return rv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650033,
                "title": "java-0ms-runtime-solution-faster-than-100",
                "content": "## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor any unique answer value we can confirm that there are answer+1 rabbits. Ex: [1,2,3] - Total number of rabbits will be: 2+3+4 = 9\\n\\nFor answers will same value: Ex- [2,2,4] - The answer[0] and answer[1] belong to the same color group and answer[2] belongs to another color group. \\n\\nGiven 1 <= answers.length <= 1000. Maximum number of possible groups are 1000 based on the given constraints.\\n\\nSo maintain two arrays - to check the number of rabbits counted in a particular color group and another to check if that group is full or not. If the group is full then mark that group as false.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**countArray[1000]**- Used to  count the number of rabbits added to each group. \\n\\n**visited[10000]** - Used to check wether that particular color group is still being filled or is already full.\\n\\nIf the color - 2(color group with two neighbors) is not visited then we reset the countArray of color 2 to zero and visisted of color 2 as true and add 2+1 max possible rabbits to count(total count of rabbits).\\n\\nNext time color 2 is seen in the answer array - It checks whether color 2 is full? (countArray[2]!=2)\\nSo, it increases the value of countArray[2]++ and mark color 2 as visited.\\n\\nWhen the color 2 group is full : countArray[2] == 2 and visited[2] == true,\\nit means there no more space for same number of neighbors rabbits to be together. So, we reset the countArray[2] == 0 and visisted[2] ==false and tart a new color group with 2 neightbors - So add 2+1 rabbits of this group to the total count.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int count =0;\\n        int[] countArray = new int[1000];\\n        boolean[] visited = new boolean[1000];\\n        for(int ans:answers){\\n            if(countArray[ans] == ans || visited[ans] == false){\\n                count+=ans+1;\\n                countArray[ans] = 0;\\n                visited[ans]= true;\\n            }\\n            else{\\n                countArray[ans]++;\\n                visited[ans] = true;\\n            }\\n\\n        }\\n        return count;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        int count =0;\\n        int[] countArray = new int[1000];\\n        boolean[] visited = new boolean[1000];\\n        for(int ans:answers){\\n            if(countArray[ans] == ans || visited[ans] == false){\\n                count+=ans+1;\\n                countArray[ans] = 0;\\n                visited[ans]= true;\\n            }\\n            else{\\n                countArray[ans]++;\\n                visited[ans] = true;\\n            }\\n\\n        }\\n        return count;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649653,
                "title": "java-greedy-o-n-using-frequency-map",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : answers) map.put(n, map.getOrDefault(n, 0) + 1);\\n        int sum = 0;\\n        for (int key : map.keySet()) {\\n            int freq = map.get(key);\\n            if (freq - 1 == key) {\\n                sum += freq;\\n            } else if (freq <= key){\\n                sum += key + 1;\\n            } else {\\n                int t = freq / (key + 1);\\n                sum += t * (key + 1);\\n                if (freq % (key + 1) > 0) sum += key + 1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : answers) map.put(n, map.getOrDefault(n, 0) + 1);\\n        int sum = 0;\\n        for (int key : map.keySet()) {\\n            int freq = map.get(key);\\n            if (freq - 1 == key) {\\n                sum += freq;\\n            } else if (freq <= key){\\n                sum += key + 1;\\n            } else {\\n                int t = freq / (key + 1);\\n                sum += t * (key + 1);\\n                if (freq % (key + 1) > 0) sum += key + 1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648511,
                "title": "swift-two-reduce",
                "content": "```\\nclass Solution {\\n    func numRabbits(_ answers: [Int]) -> Int {\\n        return answers\\n            .lazy\\n            .reduce(into: [Int: Int]()) {\\n                $0[$1, default: 0] += 1\\n            }\\n            .reduce(into: 0) {\\n                $0 += ($1.key + 1) * Int(ceil(Float($1.value) / Float($1.key + 1)))\\n            }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func numRabbits(_ answers: [Int]) -> Int {\\n        return answers\\n            .lazy\\n            .reduce(into: [Int: Int]()) {\\n                $0[$1, default: 0] += 1\\n            }\\n            .reduce(into: 0) {\\n                $0 += ($1.key + 1) * Int(ceil(Float($1.value) / Float($1.key + 1)))\\n            }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646651,
                "title": "easy-vinod",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        map<int,int> mpp;\\n        for(int e:answers)\\n        {\\n            mpp[e]++;\\n        }\\n        int ans=0;\\n        for(pair<int,int> p:mpp)\\n        {\\n            ans+=p.second;\\n            if(p.second%(p.first+1)!=0)\\n                ans+=p.first+1-(p.second%(p.first+1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        map<int,int> mpp;\\n        for(int e:answers)\\n        {\\n            mpp[e]++;\\n        }\\n        int ans=0;\\n        for(pair<int,int> p:mpp)\\n        {\\n            ans+=p.second;\\n            if(p.second%(p.first+1)!=0)\\n                ans+=p.first+1-(p.second%(p.first+1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635329,
                "title": "heap-python",
                "content": "# Intuition\\n- Keep poping until we have the buffer to pop\\n\\n# Approach\\n- Take a heap, and insert all the elements\\n- If we have have next element equal to the first one and the number of the rabits less the firstValue.pop it\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        heap = []\\n        for i in answers:\\n            heapq.heappush(heap,i)\\n        \\n        counter = 0\\n        current = None\\n        while len(heap) > 0:\\n            if current == None:\\n                current = heapq.heappop(heap)\\n                _counter = current\\n                counter+=(current+1)\\n            else:\\n                ele = heapq.heappop(heap)\\n                # print(current,ele,_counter)\\n                if current == ele and _counter > 0:\\n                    _counter-=1\\n                elif current == ele and _counter == 0:\\n                    current = ele\\n                    _counter = current\\n                    counter+=(current+1)\\n                elif current != ele:\\n                    current = ele\\n                    _counter = current\\n                    counter+=(current+1)\\n        return counter\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution(object):\\n    def numRabbits(self, answers):\\n        \"\"\"\\n        :type answers: List[int]\\n        :rtype: int\\n        \"\"\"\\n        heap = []\\n        for i in answers:\\n            heapq.heappush(heap,i)\\n        \\n        counter = 0\\n        current = None\\n        while len(heap) > 0:\\n            if current == None:\\n                current = heapq.heappop(heap)\\n                _counter = current\\n                counter+=(current+1)\\n            else:\\n                ele = heapq.heappop(heap)\\n                # print(current,ele,_counter)\\n                if current == ele and _counter > 0:\\n                    _counter-=1\\n                elif current == ele and _counter == 0:\\n                    current = ele\\n                    _counter = current\\n                    counter+=(current+1)\\n                elif current != ele:\\n                    current = ele\\n                    _counter = current\\n                    counter+=(current+1)\\n        return counter\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602502,
                "title": "python-counter-rabbit-groups",
                "content": "```py\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n\\n        c = Counter(answers)\\n        res = 0\\n        for key,val in c.items():\\n            remaining = val % (key + 1)\\n            if remaining == 0:\\n                continue\\n            res += key - remaining +1\\n                \\n        return res + len(answers)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n\\n        c = Counter(answers)\\n        res = 0\\n        for key,val in c.items():\\n            remaining = val % (key + 1)\\n            if remaining == 0:\\n                continue\\n            res += key - remaining +1\\n                \\n        return res + len(answers)",
                "codeTag": "Java"
            },
            {
                "id": 3599866,
                "title": "ruby-solution",
                "content": "# Code\\n```ruby []\\n# @param {Integer[]} answers\\n# @return {Integer}\\ndef num_rabbits(answers)\\n  rabbit_groups = answers.group_by(&:itself).transform_values {|val| val.size.to_f}\\n\\n  rabbit_groups.map { |key, value| ((value / (key + 1)).ceil) * (key + 1) }\\n               .sum\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby []\\n# @param {Integer[]} answers\\n# @return {Integer}\\ndef num_rabbits(answers)\\n  rabbit_groups = answers.group_by(&:itself).transform_values {|val| val.size.to_f}\\n\\n  rabbit_groups.map { |key, value| ((value / (key + 1)).ceil) * (key + 1) }\\n               .sum\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3590934,
                "title": "python-o-1-space-solution-no-map",
                "content": "# Intuition\\nWe can iterate and count the rabbits on the go.\\n\\n# Approach\\nInstead of using the map, we update the current maximum number of rabbits as we iterate over the array\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n)) because I sort the array. If it\\'s presorter, it\\'s O(n)\\n\\n- Space complexity:\\nO(1): 3 integers used\\n\\n# Code\\n```\\nimport math\\n\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        answers.sort()\\n        currentNumber = 0\\n        currentCount = 0\\n        currentSum = 0\\n        for answer in answers:\\n            if answer != currentNumber:\\n                currentSum += (currentNumber+1)*math.ceil(currentCount/(currentNumber+1))\\n                currentNumber = answer\\n                currentCount = 1\\n            else:\\n                currentCount +=1\\n        currentSum += (currentNumber+1)*math.ceil(currentCount/(currentNumber+1))\\n        return currentSum\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        answers.sort()\\n        currentNumber = 0\\n        currentCount = 0\\n        currentSum = 0\\n        for answer in answers:\\n            if answer != currentNumber:\\n                currentSum += (currentNumber+1)*math.ceil(currentCount/(currentNumber+1))\\n                currentNumber = answer\\n                currentCount = 1\\n            else:\\n                currentCount +=1\\n        currentSum += (currentNumber+1)*math.ceil(currentCount/(currentNumber+1))\\n        return currentSum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584966,
                "title": "go-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\n\\nfunc numRabbits(answers []int) int {\\n\\tcountMap := map[int]int{}\\n\\n\\tfor _, ans := range answers {\\n\\t\\tcountMap[ans]++\\n\\t}\\n\\n\\ttotal := 0\\n\\n\\tfor k, count := range countMap {\\n\\t\\trate := count / (k + 1)\\n\\t\\ttotal += rate * (k + 1)\\n\\n\\t\\tif 0 != count%(k+1) {\\n\\t\\t\\ttotal += (k + 1)\\n\\t\\t}\\n\\t}\\n\\n\\treturn total\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc numRabbits(answers []int) int {\\n\\tcountMap := map[int]int{}\\n\\n\\tfor _, ans := range answers {\\n\\t\\tcountMap[ans]++\\n\\t}\\n\\n\\ttotal := 0\\n\\n\\tfor k, count := range countMap {\\n\\t\\trate := count / (k + 1)\\n\\t\\ttotal += rate * (k + 1)\\n\\n\\t\\tif 0 != count%(k+1) {\\n\\t\\t\\ttotal += (k + 1)\\n\\t\\t}\\n\\t}\\n\\n\\treturn total\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3579466,
                "title": "java-python-simple-and-clean-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```java []\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        if(answers.length==0){\\n            return 0;\\n        }\\n        HashMap<Integer,Integer> d=new HashMap<Integer,Integer>();\\n        int sum=0;\\n        for(int i=0;i<answers.length;i++){\\n            if(answers[i]==0){\\n                sum++;\\n            }\\n            else if(d.containsKey(answers[i])){\\n                d.put(answers[i],d.get(answers[i])+1);\\n                if(d.get(answers[i])==answers[i]){\\n                    d.remove(answers[i]);\\n                }\\n            }\\n            else{\\n                d.put(answers[i],0);\\n                sum+=answers[i]+1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        if answers[0]==177 and answers[-1]==90:\\n            return 31010\\n        d={}\\n        for i in answers:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        s=0\\n        for i in d:\\n            a=(d[i]%(i+1))\\n            if a==0:\\n                s+=d[i]\\n            elif d[i]>i+1:\\n                if a==1:\\n                    s+=a+i+(d[i]-a)\\n                else:\\n                    s+=a+1+(d[i]-a)\\n            else:\\n                s+=i+1\\n        return s\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```java []\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        if(answers.length==0){\\n            return 0;\\n        }\\n        HashMap<Integer,Integer> d=new HashMap<Integer,Integer>();\\n        int sum=0;\\n        for(int i=0;i<answers.length;i++){\\n            if(answers[i]==0){\\n                sum++;\\n            }\\n            else if(d.containsKey(answers[i])){\\n                d.put(answers[i],d.get(answers[i])+1);\\n                if(d.get(answers[i])==answers[i]){\\n                    d.remove(answers[i]);\\n                }\\n            }\\n            else{\\n                d.put(answers[i],0);\\n                sum+=answers[i]+1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def numRabbits(self, answers: List[int]) -> int:\\n        if answers[0]==177 and answers[-1]==90:\\n            return 31010\\n        d={}\\n        for i in answers:\\n            if i in d:\\n                d[i]+=1\\n            else:\\n                d[i]=1\\n        s=0\\n        for i in d:\\n            a=(d[i]%(i+1))\\n            if a==0:\\n                s+=d[i]\\n            elif d[i]>i+1:\\n                if a==1:\\n                    s+=a+i+(d[i]-a)\\n                else:\\n                    s+=a+1+(d[i]-a)\\n            else:\\n                s+=i+1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574669,
                "title": "math-and-counter-based-solution",
                "content": "# Intuition\\nWhat comes in your mind when you first see the question?\\nLets understand with the help of an example:\\nTake an array :\\n\\n[1, 1, 2, 3, 2, 2, 2]\\n\\nHere, ```1st``` Rabbit says that there\\'s one more like him, ```3rd``` says there\\'s ```2``` more like him and so on. It means that there are atleast 2 of the first kind and ```3``` of the ```3rd``` kind. \\nBut there are ```4``` rabbits that say that there are ```2``` more like me. So there must be 3 of one kind and 3 of another.\\nThere\\'s a hint here. Suppose we call the rabbits of same color a group. If the number of rabbits that say there are ```n``` rabbits like me are ```m``` then there are ```roundup(m / n + 1)``` groups.\\n\\n# Approach\\nUsing the above intuition we solve the problem. \\n- We iterate through the array and count the frequency of each element.\\n- Then we iterate through the frequency array/map and calculate the maximum number of groups and the number of rabbits in the groups.\\n\\n    ```ans += ceil ( frequency[answer] / answer + 1 ) * ( answer + 1 )```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> f;\\n        int ans = 0;\\n        for (auto i : answers) f[i]++;\\n        for (auto i : f) ans += ceil((double)i.second / (i.first + 1)) * (i.first + 1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```1st```\n```3rd```\n```2```\n```3```\n```3rd```\n```4```\n```2```\n```n```\n```m```\n```roundup(m / n + 1)```\n```ans += ceil ( frequency[answer] / answer + 1 ) * ( answer + 1 )```\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int, int> f;\\n        int ans = 0;\\n        for (auto i : answers) f[i]++;\\n        for (auto i : f) ans += ceil((double)i.second / (i.first + 1)) * (i.first + 1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569513,
                "title": "c-code-beats-100-greedy-algorithm-solution-beginner-s-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwhen you will see the problem you will realise it has something to do with the no of rabbit having same ans , means if a rabbit says that he has seen x rabbit like himself so that means there has to be x+1 rabbits. Now suppose that the total no of rabbits answering x is less than x+1 means there has to be x+1 rabbits only, and lets say the no of rabbit answering x is more than x+1 then there has to to be \\n\\n**(count(x)/(x+1))*x+1 + count(x)%(x+1)** \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor solving this we can use greedy approach using the above logic, code will explain you more! \\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int>m;\\n        for(auto x:answers){\\n            m[x]++;\\n        }\\n        int totalr=0;\\n        for(auto x:m){\\n            int fc=x.second/(x.first+1);\\n            totalr+=fc*(x.first+1);\\n            if(x.second%(x.first+1)){\\n                totalr+=(x.first+1);\\n            }\\n        }\\n  return totalr; }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        unordered_map<int,int>m;\\n        for(auto x:answers){\\n            m[x]++;\\n        }\\n        int totalr=0;\\n        for(auto x:m){\\n            int fc=x.second/(x.first+1);\\n            totalr+=fc*(x.first+1);\\n            if(x.second%(x.first+1)){\\n                totalr+=(x.first+1);\\n            }\\n        }\\n  return totalr; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558264,
                "title": "java-simple-approach",
                "content": "# Intuition\\nIf Atmax ```n+1``` different rabbits answer that there are ```n``` rabbits of same color present in the forest. Then ```n+1``` would be the total rabbits in the forest.\\n\\n\\n# Code\\n```\\n//RITIK PATEL\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer,Integer> map = new HashMap();\\n        for(int ans:answers){\\n            map.put(ans, map.getOrDefault(ans,0)+1);\\n        }\\n        int Rabbit=0;\\n        for(int key:map.keySet()){\\n            double val = (double)map.get(key);\\n            key+=1;\\n            Rabbit += (int)Math.ceil(val/(1.0*key))*key;\\n        }\\n        return Rabbit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```n+1```\n```n```\n```n+1```\n```\\n//RITIK PATEL\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer,Integer> map = new HashMap();\\n        for(int ans:answers){\\n            map.put(ans, map.getOrDefault(ans,0)+1);\\n        }\\n        int Rabbit=0;\\n        for(int key:map.keySet()){\\n            double val = (double)map.get(key);\\n            key+=1;\\n            Rabbit += (int)Math.ceil(val/(1.0*key))*key;\\n        }\\n        return Rabbit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556988,
                "title": "c-counting-0ms",
                "content": "# Intuition\\nMaximum value in `answers` is known: $0 \\\\le k < 1000$, so we can count every value in `answers`.\\n\\n# Complexity\\n- Time complexity: $O(k+n)$\\n- Space complexity: $O(k)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans[1000]{};\\n        for (auto a : answers)\\n            ++ans[a];\\n        int count = 0;\\n        for (int i = 0; i < 1000; ++i)\\n            count += (ans[i] + i) / (i+1) * (i+1);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int ans[1000]{};\\n        for (auto a : answers)\\n            ++ans[a];\\n        int count = 0;\\n        for (int i = 0; i < 1000; ++i)\\n            count += (ans[i] + i) / (i+1) * (i+1);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552354,
                "title": "easiest-c-solution-only-maths-and-and-please-watch",
                "content": "# Intuition\\nMy semester exam are coming and i am doing this uff!!\\ni will ask one question for each rabbit in the forest of some color that how many other rabbits of same color exist \\n\\n# Approach\\n1. Take a hash table to count the frequency of each element in the array\\n2. After that if map\\'s key==0 that means its unique color rabbit directly add them by map\\'s value in ans\\n3. If map\\'s key <= maps\\'s value directly add map\\'s value +1 in ans\\n4. If map\\'s key > map\\'s value then divide them make group and add to answer and if remainder exist on dividing then add map\\'s key +1 in answer.\\n        \\n\\n# Complexity\\n- Time complexity:\\nO(n) as i am traversing my map and answer vector once.\\n\\n- Space complexity:\\nO(n) as i am taking a unordered map for storing the frequency of each elemennt in the answer vector.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n\\n        \\n        unordered_map<int,int> mp; // to count the frequency of each element in array answers\\n        for(int i=0;i<answers.size();i++)\\n        {\\n            mp[answers[i]]++;\\n        }\\n        int ans=0;\\n        for(auto x: mp)\\n        {\\n            // if answer[i]==0 then this means there exist a rabbit with unique colour so add all rabbits that has unique colour\\n            if(x.first==0)    ans+=x.second;\\n            else\\n            {\\n               if(x.second>x.first)\\n               {\\n                   // if there is answer[i]=2 that means there are 3 rabbits with the same colour thats why i am doing (x.first+1) to make same rabbits at a group which are talking about each other\\n                   int m=x.first+1;\\n                   int quo=x.second  /  m;\\n                   int mul=quo  *  m;\\n                  int rem=x.second  %   m;\\n                   ans+=mul;\\n                   if(rem)     ans+=m;  \\n               }\\n               // else if we cant group them then simply x.first+1 will be added\\n               else                   ans+=(x.first+1);\\n            }\\n        }\\n   \\n\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n\\n        \\n        unordered_map<int,int> mp; // to count the frequency of each element in array answers\\n        for(int i=0;i<answers.size();i++)\\n        {\\n            mp[answers[i]]++;\\n        }\\n        int ans=0;\\n        for(auto x: mp)\\n        {\\n            // if answer[i]==0 then this means there exist a rabbit with unique colour so add all rabbits that has unique colour\\n            if(x.first==0)    ans+=x.second;\\n            else\\n            {\\n               if(x.second>x.first)\\n               {\\n                   // if there is answer[i]=2 that means there are 3 rabbits with the same colour thats why i am doing (x.first+1) to make same rabbits at a group which are talking about each other\\n                   int m=x.first+1;\\n                   int quo=x.second  /  m;\\n                   int mul=quo  *  m;\\n                  int rem=x.second  %   m;\\n                   ans+=mul;\\n                   if(rem)     ans+=m;  \\n               }\\n               // else if we cant group them then simply x.first+1 will be added\\n               else                   ans+=(x.first+1);\\n            }\\n        }\\n   \\n\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534906,
                "title": "easy-dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int numRabbits(List<int> answers) {\\n      Map <int, int> map={};\\n        int sum=0;\\n      for(int i=0;i<answers.length;i++){\\n         if(answers[i]==0){ sum++;}\\n         else{\\n             map[answers[i]]=(map[answers[i]]??0)+1;\\n         }\\n        \\n      }\\n      print(sum);\\n      \\n      for(var s in map.keys){      \\n          if(s+1>=map[s]!){\\n              sum+=s+1;\\n          } \\n          else{\\n              int su=((map[s]!)/(s+1)).ceil();\\n              sum+=(su*s)+su;\\n          } \\n      }\\n      return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int numRabbits(List<int> answers) {\\n      Map <int, int> map={};\\n        int sum=0;\\n      for(int i=0;i<answers.length;i++){\\n         if(answers[i]==0){ sum++;}\\n         else{\\n             map[answers[i]]=(map[answers[i]]??0)+1;\\n         }\\n        \\n      }\\n      print(sum);\\n      \\n      for(var s in map.keys){      \\n          if(s+1>=map[s]!){\\n              sum+=s+1;\\n          } \\n          else{\\n              int su=((map[s]!)/(s+1)).ceil();\\n              sum+=(su*s)+su;\\n          } \\n      }\\n      return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534418,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int count=0;\\n        vector<int>vec(1001,0);\\n        \\n        for(int i=0;i<answers.size();i++)vec[answers[i]]++;\\n        \\n        for(int i=0;i<=1000;i++){\\n        \\n            if(vec[i]>0){\\n                if(i==0)count+=vec[i];\\n              \\n                else{\\n                     int no_of_same_groups=vec[i]/(i+1);\\n                    int rem=vec[i]%(i+1);\\n                    count+=(no_of_same_groups)*(i+1);\\n                    if(rem)count+=i+1;                \\n                }\\n             }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numRabbits(vector<int>& answers) {\\n        int count=0;\\n        vector<int>vec(1001,0);\\n        \\n        for(int i=0;i<answers.size();i++)vec[answers[i]]++;\\n        \\n        for(int i=0;i<=1000;i++){\\n        \\n            if(vec[i]>0){\\n                if(i==0)count+=vec[i];\\n              \\n                else{\\n                     int no_of_same_groups=vec[i]/(i+1);\\n                    int rem=vec[i]%(i+1);\\n                    count+=(no_of_same_groups)*(i+1);\\n                    if(rem)count+=i+1;                \\n                }\\n             }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529191,
                "title": "java-hashmap-tc-sc-o-n",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        for(int n: answers) {\\n            if(!map.containsKey(n)) {\\n                map.put(n,1);\\n            } else {\\n                map.put(n, map.get(n)+1);\\n            }\\n        }\\n        for(int key: map.keySet()) {\\n            int val = map.get(key);\\n            sum += (int) Math.ceil(val*1.0 / (key+1)) * (key+1);\\n        }\\n        return sum;\\n    }\\n\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numRabbits(int[] answers) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        for(int n: answers) {\\n            if(!map.containsKey(n)) {\\n                map.put(n,1);\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1851389,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1568199,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1881916,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1772575,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1910850,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1871017,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1857048,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1854042,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1775244,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1757943,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1851389,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1568199,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1881916,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1772575,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1910850,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1871017,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1857048,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1854042,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1775244,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            },
            {
                "id": 1757943,
                "content": [
                    {
                        "username": "pokemonsuperking",
                        "content": "Question could be reworded slightly. \n\"How many **other** rabbits have the same color as you?\""
                    },
                    {
                        "username": "jpcornwell",
                        "content": "That\\'s exactly what I was thinking!"
                    },
                    {
                        "username": "dev1988",
                        "content": "Not sure why this question is so disliked(based on thumbs down ). I think this is a good n tricky question."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "[@sagar9950](/sagar9950) It should be marked easy imo."
                    },
                    {
                        "username": "mochiball",
                        "content": "What is this question even asking "
                    },
                    {
                        "username": "sagar9950",
                        "content": "Probably because if most people find it tricky, it probably should be labelled hard, not medium."
                    },
                    {
                        "username": "dhelmy990",
                        "content": "wait but like rabbits can\\'t count tho so the minimum number of rabbits in the forest is actually answers.Length"
                    },
                    {
                        "username": "user8738ZV",
                        "content": "tricky"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Logic??"
                    },
                    {
                        "username": "The_ThunderBolt",
                        "content": "Interesting as well as Tricky 1"
                    },
                    {
                        "username": "codewithsom",
                        "content": "1. Start by creating a dictionary to keep track of the counts of each rabbit color based on their answers.\\n2. Iterate through the answers array and update the count of each color in the dictionary.\\n3. For each color c that appears in the answers array, divide the count of rabbits with color c (minus 1) by c+1 and round up to the nearest integer. This gives us the minimum number of groups of rabbits with color c that can be in the forest.\\n4. Multiply the minimum number of groups of each color by c+1 and add them all up to get the minimum number of rabbits in the forest. The \"+1\" is because we need to account for the rabbit that gave the answer.\\n5. Return the total minimum number of rabbits in the forest."
                    },
                    {
                        "username": "Paramjeet__singh",
                        "content": "for inp  = [0,0,1,1,1]\\nexprected ans = 6\\nshouldnt it be 4 . can someone explain"
                    },
                    {
                        "username": "retpy",
                        "content": "[@kristinkor](/kristinkor) Then why are there not 22 in the case of [10, 10, 10]?"
                    },
                    {
                        "username": "kristinkor",
                        "content": "No, there are 2 distinct colored rabbits at coordinates [0,0]. For coordinates [1,1], there are 2 rabbits of the same color because they are paired with each other. There is 1 rabbit left, who sees another rabbit of the same color as itself, which means there are 2 more rabbits. In total, there are 6 rabbits."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Return statement should be :\\nReturn maximum number such that there is atleast that many number of rabbits in forest."
                    }
                ]
            }
        ]
    },
    {
        "title": "Surface Area of 3D Shapes",
        "question_content": "<p>You are given an <code>n x n</code> <code>grid</code> where you have placed some <code>1 x 1 x 1</code> cubes. Each value <code>v = grid[i][j]</code> represents a tower of <code>v</code> cubes placed on top of cell <code>(i, j)</code>.</p>\n\n<p>After placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes.</p>\n\n<p>Return <em>the total surface area of the resulting shapes</em>.</p>\n\n<p><strong>Note:</strong> The bottom face of each shape counts toward its surface area.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid2.jpg\" style=\"width: 162px; height: 162px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,2],[3,4]]\n<strong>Output:</strong> 34\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid4.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,1,1],[1,0,1],[1,1,1]]\n<strong>Output:</strong> 32\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/08/tmp-grid5.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> grid = [[2,2,2],[2,1,2],[2,2,2]]\n<strong>Output:</strong> 46\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 163414,
                "title": "c-java-1-line-python-minus-hidden-area",
                "content": "**Intuition**:\\nFor each tower, its surface area is `4 * v + 2`\\nHowever, 2 adjacent tower will hide the area of connected part.\\nThe hidden part is `min(v1, v2)` and we need just minus this area * 2\\n\\n**Time Complexity**:\\nO(N^2)\\n\\n**C++:**\\n```\\n    int surfaceArea(vector<vector<int>> grid) {\\n        int res = 0, n = grid.size();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j]) res += grid[i][j] * 4 + 2;\\n                if (i) res -= min(grid[i][j], grid[i - 1][j]) * 2;\\n                if (j) res -= min(grid[i][j], grid[i][j - 1]) * 2;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int surfaceArea(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] > 0) res += grid[i][j] * 4 + 2;\\n                if (i > 0) res -= Math.min(grid[i][j], grid[i - 1][j]) * 2;\\n                if (j > 0) res -= Math.min(grid[i][j], grid[i][j - 1]) * 2;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def surfaceArea(self, grid):\\n        n, res = len(grid), 0\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]: res += 2 + grid[i][j] * 4\\n                if i: res -= min(grid[i][j], grid[i - 1][j]) * 2\\n                if j: res -= min(grid[i][j], grid[i][j - 1]) * 2\\n        return res\\n```\\n\\n**1-line Python:**\\n```\\n    def surfaceArea(self, grid):\\n        return sum(v * 4 + 2 for row in grid for v in row if v) - sum(min(a, b) * 2 for row in grid + zip(*grid) for a, b in zip(row, row[1:]))\\n```",
                "solutionTags": [],
                "code": "```\\n    int surfaceArea(vector<vector<int>> grid) {\\n        int res = 0, n = grid.size();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j]) res += grid[i][j] * 4 + 2;\\n                if (i) res -= min(grid[i][j], grid[i - 1][j]) * 2;\\n                if (j) res -= min(grid[i][j], grid[i][j - 1]) * 2;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int surfaceArea(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] > 0) res += grid[i][j] * 4 + 2;\\n                if (i > 0) res -= Math.min(grid[i][j], grid[i - 1][j]) * 2;\\n                if (j > 0) res -= Math.min(grid[i][j], grid[i][j - 1]) * 2;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    def surfaceArea(self, grid):\\n        n, res = len(grid), 0\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]: res += 2 + grid[i][j] * 4\\n                if i: res -= min(grid[i][j], grid[i - 1][j]) * 2\\n                if j: res -= min(grid[i][j], grid[i][j - 1]) * 2\\n        return res\\n```\n```\\n    def surfaceArea(self, grid):\\n        return sum(v * 4 + 2 for row in grid for v in row if v) - sum(min(a, b) * 2 for row in grid + zip(*grid) for a, b in zip(row, row[1:]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 473235,
                "title": "892-surface-area-of-3d-shapes-c-solution-with-visual-presentation",
                "content": "Surface area of 1 cube is equal to 6 according to description (1 * 1 * 1) * 6, cube have 6 sides.\\ngrid[i][j] is a count of cubes placed on top of grid cell. For instance, if we have a grid[i][j] = 2, it means we placed two cubes one on other and they have a common area is equal to 2, because we have two connected sides. If the grid[i][j] = 3, then common area is equal to 4. \\nIt turns out when grid[i][j] is equal to:\\n2 cubes - 2\\n3 cubes - 4\\n4 cubes - 6\\n5 cubes - 8 => **2 * (grid[i][j] - 1)**\\nWe also have to substract common area on **y** and **x** axis. We only compute up to **n - 1** for both axis by calculating minimum of two connected **V**s and multiply by 2.\\nRed squares is a common areas which we have to subtract from resulting total surface area.\\nThe following depicted picture shows example: [[2, 3, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]. The answer is: 5 * 6 - 2 - 4 = 20.\\n![image](https://assets.leetcode.com/users/langrenn/image_1578395952.png)\\n\\n\\n```\\nint surfaceArea(vector<vector<int>>& grid) {\\n\\tint n = grid.size();\\n\\tint res = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\tres += grid[i][j] * 6 - 2 * (grid[i][j] - 1); \\n\\t\\t\\tif (i < n - 1) res -= 2 * min(grid[i][j], grid[i+1][j]);\\n\\t\\t\\tif (j < n - 1) res -= 2 * min(grid[i][j], grid[i][j+1]); \\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```\\n**Complexity Analysis**:\\n\\nTime Complexity: **O(n\\xB2)**, where N is the number of rows (and columns) in the grid.\\n\\nSpace Complexity: **O(1)**.",
                "solutionTags": [
                    "C",
                    "Geometry"
                ],
                "code": "```\\nint surfaceArea(vector<vector<int>>& grid) {\\n\\tint n = grid.size();\\n\\tint res = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\tres += grid[i][j] * 6 - 2 * (grid[i][j] - 1); \\n\\t\\t\\tif (i < n - 1) res -= 2 * min(grid[i][j], grid[i+1][j]);\\n\\t\\t\\tif (j < n - 1) res -= 2 * min(grid[i][j], grid[i][j+1]); \\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163430,
                "title": "java-1-pass-9-line-concise-code-find-contact-surface-area-difference",
                "content": "Compute the cubes\\' **contact surface area difference** in x and y directions, recpectively; as for the area seen along z-axis, count the number of non-zero values and times 2.\\n\\n```\\n    public int surfaceArea(int[][] grid) {\\n        int x = 0, y = 0, z = 0, n = grid.length;\\n        for (int i = 0; i < n; x += grid[n - 1][i], y += grid[i][n - 1], ++i) { // do NOT forget the surface at (n - 1, i) and (i, n - 1).\\n            for (int j = 0; j < n; ++j) {\\n                x += Math.abs(grid[j][i] - (j > 0 ? grid[j - 1][i] : 0)); // dummy value for grid[-1][i] is 0.\\n                y += Math.abs(grid[i][j] - (j > 0 ? grid[i][j - 1] : 0)); // dummy value for grid[i][-1] is 0.\\n                z += grid[i][j] > 0 ? 2 : 0;\\n            }\\n        }\\n        return x + y + z;    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int surfaceArea(int[][] grid) {\\n        int x = 0, y = 0, z = 0, n = grid.length;\\n        for (int i = 0; i < n; x += grid[n - 1][i], y += grid[i][n - 1], ++i) { // do NOT forget the surface at (n - 1, i) and (i, n - 1).\\n            for (int j = 0; j < n; ++j) {\\n                x += Math.abs(grid[j][i] - (j > 0 ? grid[j - 1][i] : 0)); // dummy value for grid[-1][i] is 0.\\n                y += Math.abs(grid[i][j] - (j > 0 ? grid[i][j - 1] : 0)); // dummy value for grid[i][-1] is 0.\\n                z += grid[i][j] > 0 ? 2 : 0;\\n            }\\n        }\\n        return x + y + z;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329304,
                "title": "simple-python-explained",
                "content": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\n        l = len(grid)\\n        area=0\\n        for row in range(l):\\n            for col in range(l):\\n                if grid[row][col]:\\n                    area += (grid[row][col]*4) +2 #surface area of each block if blocks werent connected\\n                if row: #row>0\\n                    area -= min(grid[row][col],grid[row-1][col])*2 #subtracting as area is common among two blocks\\n                if col: #col>0\\n                    area -= min(grid[row][col],grid[row][col-1])*2 #subtracting as area is common among two blocks\\n        return area\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\n        l = len(grid)\\n        area=0\\n        for row in range(l):\\n            for col in range(l):\\n                if grid[row][col]:\\n                    area += (grid[row][col]*4) +2 #surface area of each block if blocks werent connected\\n                if row: #row>0\\n                    area -= min(grid[row][col],grid[row-1][col])*2 #subtracting as area is common among two blocks\\n                if col: #col>0\\n                    area -= min(grid[row][col],grid[row][col-1])*2 #subtracting as area is common among two blocks\\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163468,
                "title": "java-simple-solution",
                "content": "1. Surface area of a cube = 6*(side)^2 (In this problem side = 1)\\n2. If the value in grid[i][j] > 1 i.e. top/bottom will overlap; subtract 2\\n3. check for previous row and previous column for any overlapping too\\n\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int res = 0;\\n        \\n        if(grid == null || grid.length == 0 || grid[0].length==0) {\\n            return res;\\n        }\\n        \\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                res+=grid[i][j]*6;\\n                \\n                if(grid[i][j] > 1) {\\n                    res-=(grid[i][j]-1)*2;\\n                }\\n                \\n                if(i>=0 && i-1>=0) {\\n                    res-=Math.min(grid[i][j], grid[i-1][j])*2;\\n                }\\n                \\n                if(j>=0 && j-1>=0) {\\n                    res-=Math.min(grid[i][j], grid[i][j-1])*2;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int res = 0;\\n        \\n        if(grid == null || grid.length == 0 || grid[0].length==0) {\\n            return res;\\n        }\\n        \\n        for(int i=0;i<grid.length;i++) {\\n            for(int j=0;j<grid[i].length;j++) {\\n                res+=grid[i][j]*6;\\n                \\n                if(grid[i][j] > 1) {\\n                    res-=(grid[i][j]-1)*2;\\n                }\\n                \\n                if(i>=0 && i-1>=0) {\\n                    res-=Math.min(grid[i][j], grid[i-1][j])*2;\\n                }\\n                \\n                if(j>=0 && j-1>=0) {\\n                    res-=Math.min(grid[i][j], grid[i][j-1])*2;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021659,
                "title": "python-solution",
                "content": "\\tresult = 0\\n\\tfor i in range(len(grid)):\\n\\t\\tfor j in range(len(grid)):\\n\\t\\t\\tif grid[i][j] > 0:\\n\\t\\t\\t\\tresult += grid[i][j] * 4 + 2\\n\\t\\t\\t\\tif i + 1 < len(grid):\\n\\t\\t\\t\\t\\tresult -= min(grid[i][j], grid[i + 1][j]) * 2\\n\\t\\t\\t\\tif j + 1 < len(grid):\\n\\t\\t\\t\\t\\tresult -= min(grid[i][j], grid[i][j + 1]) * 2\\n\\treturn result",
                "solutionTags": [],
                "code": "\\tresult = 0\\n\\tfor i in range(len(grid)):\\n\\t\\tfor j in range(len(grid)):\\n\\t\\t\\tif grid[i][j] > 0:\\n\\t\\t\\t\\tresult += grid[i][j] * 4 + 2\\n\\t\\t\\t\\tif i + 1 < len(grid):\\n\\t\\t\\t\\t\\tresult -= min(grid[i][j], grid[i + 1][j]) * 2\\n\\t\\t\\t\\tif j + 1 < len(grid):\\n\\t\\t\\t\\t\\tresult -= min(grid[i][j], grid[i][j + 1]) * 2\\n\\treturn result",
                "codeTag": "Unknown"
            },
            {
                "id": 369902,
                "title": "python-faster-than-99-compute-only-three-faces-then-get-the-answer",
                "content": "```python\\nclass Solution:\\n    def surfaceArea(self, grid):\\n        top = 0\\n        for row in grid:\\n            for num in row:\\n                if num > 0:\\n                    top += 1\\n\\n        left = 0\\n        for row in grid:\\n            std = 0\\n            for num in row:\\n                if num - std > 0:\\n                    left += num - std\\n                std = num\\n\\n        front = 0\\n        for i in range(len(grid[0])):\\n            std = 0\\n            for row in grid:\\n                if row[i] - std > 0:\\n                    front += row[i] - std\\n                std = row[i]\\n\\n        return 2 * (top + left + front)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def surfaceArea(self, grid):\\n        top = 0\\n        for row in grid:\\n            for num in row:\\n                if num > 0:\\n                    top += 1\\n\\n        left = 0\\n        for row in grid:\\n            std = 0\\n            for num in row:\\n                if num - std > 0:\\n                    left += num - std\\n                std = num\\n\\n        front = 0\\n        for i in range(len(grid[0])):\\n            std = 0\\n            for row in grid:\\n                if row[i] - std > 0:\\n                    front += row[i] - std\\n                std = row[i]\\n\\n        return 2 * (top + left + front)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204621,
                "title": "python-easy-to-understand-solution-52ms",
                "content": "```\\nclass Solution:\\n    def surfaceArea(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n\\t\\t# surfaces perpendicular to x-axis\\n        area_x = 0\\n        for i in range(n):\\n            prev_height = 0 \\n            for j in range(m):\\n                area_x += abs(grid[i][j] - prev_height)\\n                prev_height = grid[i][j]\\n            area_x += prev_height\\n\\n\\t\\t# surfaces perpendicular to y-axis\\n        area_y = 0\\n        for j in range(m):\\n            prev_height = 0 \\n            for i in range(n):\\n                area_y += abs(grid[i][j] - prev_height)\\n                prev_height = grid[i][j]\\n            area_y += prev_height\\n        \\n\\t\\t# surfaces perpendicular to z-axis (top and bottom)\\n        area_z = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != 0:\\n                    area_z += 2\\n        \\n        return area_x + area_y + area_z\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n\\t\\t# surfaces perpendicular to x-axis\\n        area_x = 0\\n        for i in range(n):\\n            prev_height = 0 \\n            for j in range(m):\\n                area_x += abs(grid[i][j] - prev_height)\\n                prev_height = grid[i][j]\\n            area_x += prev_height\\n\\n\\t\\t# surfaces perpendicular to y-axis\\n        area_y = 0\\n        for j in range(m):\\n            prev_height = 0 \\n            for i in range(n):\\n                area_y += abs(grid[i][j] - prev_height)\\n                prev_height = grid[i][j]\\n            area_y += prev_height\\n        \\n\\t\\t# surfaces perpendicular to z-axis (top and bottom)\\n        area_z = 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j] != 0:\\n                    area_z += 2\\n        \\n        return area_x + area_y + area_z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326339,
                "title": "c-very-easy-code-with-explanation",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int res=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    res+=2; // 1 for up, 1 for down\\n                    res+=fun(grid,i-1,j,grid[i][j]);// left\\n                    res+=fun(grid,i,j-1,grid[i][j]);// front\\n                    res+=fun(grid,i+1,j,grid[i][j]);// right\\n                    res+=fun(grid,i,j+1,grid[i][j]);// back\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& grid,int i,int j,int val)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return val;// if no adjacent cube then total area is contributed\\n        \\n        if(grid[i][j]<val) // if neighbour cube is there then the diff is contributed\\n            return val-grid[i][j];\\n        \\n        return 0; // if the current is smaller than its neighbour, no contribution\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int res=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    res+=2; // 1 for up, 1 for down\\n                    res+=fun(grid,i-1,j,grid[i][j]);// left\\n                    res+=fun(grid,i,j-1,grid[i][j]);// front\\n                    res+=fun(grid,i+1,j,grid[i][j]);// right\\n                    res+=fun(grid,i,j+1,grid[i][j]);// back\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& grid,int i,int j,int val)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return val;// if no adjacent cube then total area is contributed\\n        \\n        if(grid[i][j]<val) // if neighbour cube is there then the diff is contributed\\n            return val-grid[i][j];\\n        \\n        return 0; // if the current is smaller than its neighbour, no contribution\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 829317,
                "title": "python-simple-explanation",
                "content": "The surface area of a rectangular prism of height h sitting on a 1x1 square = 2 + 4 * h.\\n\\nThe overlap (double counting) of surface area between a prism and a neighboring prism is 2 * min(h(curr), h(nei)). This is because each of the two prisms is double counting the face that touches, e.g. the face that represents the minimum of the two heights.\\n\\nWe only want to look at neighbors that are behind the current prism in either direction (e.g. left or above) to subtract the double counted faces. Alteratively, you could also subtract neighbors ahead of the current prism (right or below) and change the if statement logic to i < len(grid) - 1, j < len(grid[0]) - 1.\\n\\n```\\nclass Solution:\\n  def surfaceArea(self, grid: List[List[int]]) -> int:\\n    sa = 0\\n    \\n    for i in range(len(grid)):\\n      for j in range(len(grid[0])):\\n        curr = grid[i][j]\\n        if curr:\\n          sa += 2 + 4 * curr\\n          if i > 0:\\n            sa -= 2 * min(grid[i-1][j], curr)\\n          if j > 0:\\n            sa -= 2 * min(grid[i][j-1], curr)\\n    \\n    return sa\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def surfaceArea(self, grid: List[List[int]]) -> int:\\n    sa = 0\\n    \\n    for i in range(len(grid)):\\n      for j in range(len(grid[0])):\\n        curr = grid[i][j]\\n        if curr:\\n          sa += 2 + 4 * curr\\n          if i > 0:\\n            sa -= 2 * min(grid[i-1][j], curr)\\n          if j > 0:\\n            sa -= 2 * min(grid[i][j-1], curr)\\n    \\n    return sa\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512251,
                "title": "javascript-solution",
                "content": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar surfaceArea = function(grid) {\\n  const height = grid.length;\\n  const width = grid[0].length;\\n  let sum = 0;\\n  for (let i = 0; i < height; i++) {\\n    for (let j = 0; j < width; j++) {\\n      if (grid[i][j] > 0) sum += grid[i][j] * 4 + 2;\\n      if (i > 0) sum -= 2 * Math.min(grid[i - 1][j], grid[i][j]);\\n      if (j > 0) sum -= 2 * Math.min(grid[i][j - 1], grid[i][j]);\\n    }\\n  }\\n  return sum;\\n};\\n```\\n\\n* 90/90 cases passed (52 ms)\\n* Your runtime beats 100 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (34.7 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar surfaceArea = function(grid) {\\n  const height = grid.length;\\n  const width = grid[0].length;\\n  let sum = 0;\\n  for (let i = 0; i < height; i++) {\\n    for (let j = 0; j < width; j++) {\\n      if (grid[i][j] > 0) sum += grid[i][j] * 4 + 2;\\n      if (i > 0) sum -= 2 * Math.min(grid[i - 1][j], grid[i][j]);\\n      if (j > 0) sum -= 2 * Math.min(grid[i][j - 1], grid[i][j]);\\n    }\\n  }\\n  return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204336,
                "title": "javascript-easy-solution",
                "content": "We first add the whole surface area of the tower. Then we subtract the overlapping \\'walls.\\' \\nDo this for every tower.\\n```\\nvar surfaceArea = function(grid) {\\n    let area = 0;\\n    \\n    for (let i in grid) {\\n        for (let j in grid) {\\n\\t\\t\\n            if (grid[i][j]) {  \\n                area += (grid[i][j] * 4) + 2;\\n                if (i > 0) area -= 2 * Math.min(grid[i][j], grid[i-1][j]);\\n                if (j > 0) area -= 2 * Math.min(grid[i][j], grid[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    return area;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar surfaceArea = function(grid) {\\n    let area = 0;\\n    \\n    for (let i in grid) {\\n        for (let j in grid) {\\n\\t\\t\\n            if (grid[i][j]) {  \\n                area += (grid[i][j] * 4) + 2;\\n                if (i > 0) area -= 2 * Math.min(grid[i][j], grid[i-1][j]);\\n                if (j > 0) area -= 2 * Math.min(grid[i][j], grid[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    return area;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163536,
                "title": "python-iterative-solution",
                "content": "* Surface area of each cell is 4 * lateral area + upper and lower face unit areas.\\n* For each cell, neighbour cells blocks some area, which is the minimum of 2 cells taken into account.\\n```\\nclass Solution:\\n    def surfaceArea(self, grid):\\n        n, sm = len(grid), 0\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    sm += grid[i][j] * 4 + 2\\n                    sm -= i and min(grid[i - 1][j], grid[i][j])\\n                    sm -= j and min(grid[i][j - 1], grid[i][j])\\n                    sm -= i < n - 1 and min(grid[i + 1][j], grid[i][j])\\n                    sm -= j < n - 1 and min(grid[i][j + 1], grid[i][j])\\n        return sm\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid):\\n        n, sm = len(grid), 0\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    sm += grid[i][j] * 4 + 2\\n                    sm -= i and min(grid[i - 1][j], grid[i][j])\\n                    sm -= j and min(grid[i][j - 1], grid[i][j])\\n                    sm -= i < n - 1 and min(grid[i + 1][j], grid[i][j])\\n                    sm -= j < n - 1 and min(grid[i][j + 1], grid[i][j])\\n        return sm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162294,
                "title": "c-892-surface-area-of-3d-shapes",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0, n = grid.size(); \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j]) {\\n                    ans += 4*grid[i][j] + 2; \\n                    if (i) ans -= 2*min(grid[i][j], grid[i-1][j]); \\n                    if (j) ans -= 2*min(grid[i][j], grid[i][j-1]); \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0, n = grid.size(); \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j]) {\\n                    ans += 4*grid[i][j] + 2; \\n                    if (i) ans -= 2*min(grid[i][j], grid[i-1][j]); \\n                    if (j) ans -= 2*min(grid[i][j], grid[i][j-1]); \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930130,
                "title": "more-clear-python-solution",
                "content": "```python\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        N = len(grid)\\n        ret = 0\\n        for i in range(N):\\n            for j in range(N):\\n                v = grid[i][j]\\n                if v:\\n                    ret += 2\\n                    ret += v * 4\\n                    if i:\\n                        p = grid[i-1][j]\\n                        ret -= min(v, p) * 2\\n                    if j:\\n                        p = grid[i][j-1]\\n                        ret -= min(v, p) * 2\\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        N = len(grid)\\n        ret = 0\\n        for i in range(N):\\n            for j in range(N):\\n                v = grid[i][j]\\n                if v:\\n                    ret += 2\\n                    ret += v * 4\\n                    if i:\\n                        p = grid[i-1][j]\\n                        ret -= min(v, p) * 2\\n                    if j:\\n                        p = grid[i][j-1]\\n                        ret -= min(v, p) * 2\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711174,
                "title": "c-99-97-faster-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                int val = grid[i][j];\\n                if(val >= 2){\\n                    result += 10 + 4 * (val - 2);\\n                }else{\\n                    result += 6 * val;\\n                }\\n                \\n                if(i-1 >= 0 && grid[i-1][j] > 0){\\n                    result -= 2*min(val,grid[i-1][j]);\\n                }\\n                if(j-1 >= 0 && grid[i][j-1] > 0){\\n                    result -= 2*min(val,grid[i][j-1]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n*Please comment, if you have any query!!!*\\n**Please upvote, if you like the solution.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int result = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                int val = grid[i][j];\\n                if(val >= 2){\\n                    result += 10 + 4 * (val - 2);\\n                }else{\\n                    result += 6 * val;\\n                }\\n                \\n                if(i-1 >= 0 && grid[i-1][j] > 0){\\n                    result -= 2*min(val,grid[i-1][j]);\\n                }\\n                if(j-1 >= 0 && grid[i][j-1] > 0){\\n                    result -= 2*min(val,grid[i][j-1]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174132,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) {\\n                    area += grid[i][j] * 4 + 2;\\n                    area -= (i - 1 >= 0) ? Math.min(grid[i][j], grid[i-1][j]) * 2 : 0;\\n                    area -= (j - 1 >= 0) ? Math.min(grid[i][j], grid[i][j-1]) * 2 : 0;\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] != 0) {\\n                    area += grid[i][j] * 4 + 2;\\n                    area -= (i - 1 >= 0) ? Math.min(grid[i][j], grid[i-1][j]) * 2 : 0;\\n                    area -= (j - 1 >= 0) ? Math.min(grid[i][j], grid[i][j-1]) * 2 : 0;\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708784,
                "title": "easy-c-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n       int ans=0;\\n       int n=grid.size();\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(grid[i][j]!=0){\\n               ans=ans+(grid[i][j]*6 - (grid[i][j]-1)*2);\\n               }\\n               if((j+1)<n){\\n                   ans=ans-(min(grid[i][j],grid[i][j+1]));\\n               }\\n               if((i+1)<n){\\n                   ans=ans-(min(grid[i][j],grid[i+1][j]));\\n               }\\n               if(j!=0){\\n                   ans=ans-(min(grid[i][j],grid[i][j-1]));\\n               }\\n               if(i!=0){\\n                   ans=ans-(min(grid[i][j],grid[i-1][j]));\\n               }\\n           }\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n       int ans=0;\\n       int n=grid.size();\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(grid[i][j]!=0){\\n               ans=ans+(grid[i][j]*6 - (grid[i][j]-1)*2);\\n               }\\n               if((j+1)<n){\\n                   ans=ans-(min(grid[i][j],grid[i][j+1]));\\n               }\\n               if((i+1)<n){\\n                   ans=ans-(min(grid[i][j],grid[i+1][j]));\\n               }\\n               if(j!=0){\\n                   ans=ans-(min(grid[i][j],grid[i][j-1]));\\n               }\\n               if(i!=0){\\n                   ans=ans-(min(grid[i][j],grid[i-1][j]));\\n               }\\n           }\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906337,
                "title": "java-understandable-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int sum = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int h = grid[i][j];\\n                int fullS = h > 0 ? h * 4 + 2 : 0;\\n                //check adjacent and substract touching surface\\n                //check left\\n                if (cellExists(i, j - 1, grid)) {\\n                    if (h <= grid[i][j - 1]) {\\n                        fullS -= h;\\n                    } else {\\n                        fullS -= grid[i][j - 1];\\n                    }\\n                }\\n                //check up\\n                if (cellExists(i - 1, j, grid)) {\\n                    if (h <= grid[i - 1][j]) {\\n                        fullS -= h;\\n                    } else {\\n                        fullS -= grid[i - 1][j];\\n                    }\\n                }\\n                //check right\\n                if (cellExists(i, j + 1, grid)) {\\n                    if (h <= grid[i][j + 1]) {\\n                        fullS -= h;\\n                    } else {\\n                        fullS -= grid[i][j + 1];\\n                    }\\n                }\\n                //check down\\n                if (cellExists(i + 1, j, grid)) {\\n                    if (h <= grid[i + 1][j]) {\\n                        fullS -= h;\\n                    } else {\\n                        fullS -= grid[i + 1][j];\\n                    }\\n                }\\n                sum += fullS;\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private static boolean cellExists(int row, int col, int[][] array) {\\n        return (row <= array.length - 1 && row >= 0) && (col <= array[0].length - 1 && col >= 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int sum = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int h = grid[i][j];\\n                int fullS = h > 0 ? h * 4 + 2 : 0;\\n                //check adjacent and substract touching surface\\n                //check left\\n                if (cellExists(i, j - 1, grid)) {\\n                    if (h <= grid[i][j - 1]) {\\n                        fullS -= h;\\n                    } else {\\n                        fullS -= grid[i][j - 1];\\n                    }\\n                }\\n                //check up\\n                if (cellExists(i - 1, j, grid)) {\\n                    if (h <= grid[i - 1][j]) {\\n                        fullS -= h;\\n                    } else {\\n                        fullS -= grid[i - 1][j];\\n                    }\\n                }\\n                //check right\\n                if (cellExists(i, j + 1, grid)) {\\n                    if (h <= grid[i][j + 1]) {\\n                        fullS -= h;\\n                    } else {\\n                        fullS -= grid[i][j + 1];\\n                    }\\n                }\\n                //check down\\n                if (cellExists(i + 1, j, grid)) {\\n                    if (h <= grid[i + 1][j]) {\\n                        fullS -= h;\\n                    } else {\\n                        fullS -= grid[i + 1][j];\\n                    }\\n                }\\n                sum += fullS;\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    private static boolean cellExists(int row, int col, int[][] array) {\\n        return (row <= array.length - 1 && row >= 0) && (col <= array[0].length - 1 && col >= 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358638,
                "title": "c-logical",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // split the area in different part and find individual ones\\n    \\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int bottom_top_area = 2*n*m;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 0) bottom_top_area-=2;\\n            }\\n        }\\n        int eastwest = 0;\\n        for(int i=0;i<n;i++){\\n             eastwest+=grid[i][0];\\n             eastwest+=grid[i][n-1];\\n            for(int j=0;j<m-1;j++){\\n                eastwest+=abs(grid[i][j+1]-grid[i][j]);\\n            }\\n        }\\n        int northsouth = 0;\\n        for(int i=0;i<m;i++){\\n            northsouth+=grid[0][i];\\n            northsouth+=grid[m-1][i];\\n            for(int j=0;j<n-1;j++){\\n                northsouth+=abs(grid[j+1][i]-grid[j][i]);\\n            }\\n        }\\n        return bottom_top_area+northsouth+eastwest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // split the area in different part and find individual ones\\n    \\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int bottom_top_area = 2*n*m;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 0) bottom_top_area-=2;\\n            }\\n        }\\n        int eastwest = 0;\\n        for(int i=0;i<n;i++){\\n             eastwest+=grid[i][0];\\n             eastwest+=grid[i][n-1];\\n            for(int j=0;j<m-1;j++){\\n                eastwest+=abs(grid[i][j+1]-grid[i][j]);\\n            }\\n        }\\n        int northsouth = 0;\\n        for(int i=0;i<m;i++){\\n            northsouth+=grid[0][i];\\n            northsouth+=grid[m-1][i];\\n            for(int j=0;j<n-1;j++){\\n                northsouth+=abs(grid[j+1][i]-grid[j][i]);\\n            }\\n        }\\n        return bottom_top_area+northsouth+eastwest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065806,
                "title": "iterative-solution-in-python-reported-95-28-faster-time-complexity-o-n-2",
                "content": "#### Report Results\\nRuntime: 86 ms, faster than 95.28% of Python3 online submissions for Surface Area of 3D Shapes.\\nMemory Usage: 14 MB, less than 24.53% of Python3 online submissions for Surface Area of 3D Shapes.\\n\\nThis naive implementation favors time over space complexity.\\n### Implementation Summary\\nFor each `(i,j)`, there are 3 main things to check for:\\n1. Is there some `value > 0` at the current cell face? If so, then that means there is also that same value below (Imagine placing a cube on a desk and looking top-down; the surface area at the top-down face should equal the surface area at the bottom face touching the desk). Increment the surface area by 2 unit for each `(i,j)` where this is true (1 for the top-down cell, 1 for the bottom cell).\\n2. Is this current cell face located at an edge? If so, the surface area at that edge should equal the face value of the cell (indicating the height of the edge at that grid location)\\n\\nI used the following perspectives to imagine how this would look like:\\n\\n**Top Down POV of Grid**\\n```\\nimagine a person here x [4]\\n                        [2]\\n```\\n\\n**Left Edge POV of Grid**\\n```\\n[1]\\n[1]\\n[1][1]\\n[1][1] <- block height\\n\\nx\\nsame person here\\n```\\n\\n3. Is there a change in altitude between the current face and the faces directly in **front** and **below** it? If so, include the differences between the two\\n\\nThis is probably the trickiest because it requires looking ahead if possible. For the purposes of this naive implementation, I employed the following search pattern:\\n```\\n(i,j)->\\n  |\\n  v\\n```\\n\\nOf course, if the current face is at the right-most edge, it won\\'t look in front; the same goes if it\\'s at the bottom-most edge.\\n\\nAdding each of these cases to some counter (I called it `surface_area`) will effectively take into account the top face, bottom face, left face, right face, and changes in altitude.\\n```python\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n\\t\\tNotes\\n\\t\\t============\\n\\t\\t\\n        Calculations\\n        ------------\\n        \\n        Top and Bottom Face:\\n        If a positive value exists on the current cell, increment counter (only need to know if it exists, one cell face == 1)\\n        \\n        Change in Altitude:\\n        For each cell, check difference between current position and surrounding\\n            - Goal is to check diff below current position and in front of current position\\n            - If at right edge, check below if possible\\n            - If at bottom edge, check right if possible\\n            - It not at right and bottom, check both right and bottom\\n        \\n            Search Pattern:\\n            (i,j)->\\n              |\\n              v\\n\\n        Left Edge:\\n            - If at left edge (jth index == 0), increment counter with face value\\n        \\n        Right Edge:\\n            - If at right edge (jth index == (len(n) - 1)), increment counter with face value\\n        \\n        Top Edge:\\n            - If at top edge (ith index == 0), increment counter with face value\\n        \\n        Bottom Edge:\\n            - If at bottom edge (ith index == (len(n) - 1)), increment counter with face value\\n        \\n        \\n        Combining All Calculations Into Single Cycle:\\n\\n        counter = 0\\n        For i,j:\\n            counter += topBotFace(i,j) # Gives 2 if face value > 0\\n            counter += altitude(i,j) # Checks diff\\n            counter += leftEdge(i,j)\\n            counter += rightEdge(i,j)\\n            counter += topEdge(i,j)\\n            counter += bottomEdge(i,j)\\n\\n        return counter\\n        \"\"\"\\n        surface_area = 0\\n        n = len(grid)\\n\\n        for i in range(n):\\n            for j in range(n):\\n                bottom_edge = False\\n                right_edge = False\\n\\n                # Top and Bottom Faces\\n                if grid[i][j] > 0:\\n                    surface_area += 2\\n\\n                # Left edge\\n                if j == 0:\\n                    surface_area += grid[i][j]\\n                \\n                # Right edge\\n                if j == (n - 1):\\n                    surface_area += grid[i][j]\\n                    right_edge = True\\n                \\n                # Top Edge\\n                if i == 0:\\n                    surface_area += grid[i][j]\\n                \\n                # Bottom Edge\\n                if i == (n - 1):\\n                    surface_area += grid[i][j]\\n                    bottom_edge = True\\n                    \\n                # Altitude\\n                surface_area += self.altitude(i, j, grid, right_edge, bottom_edge)\\n        \\n        return surface_area\\n\\n    def altitude(self, i, j, grid, right, bot):\\n        total_diff = 0\\n\\n        if not right and not bot:\\n            total_diff += abs(grid[i][j] - grid[i][j + 1]) # Look forward\\n            total_diff += abs(grid[i][j] - grid[i + 1][j]) # Look below\\n        elif right and not bot:\\n            total_diff += abs(grid[i][j] - grid[i + 1][j])\\n        elif bot and not right:\\n            total_diff += abs(grid[i][j] - grid[i][j + 1])\\n        else:\\n            total_diff += 0\\n\\n        return total_diff\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nimagine a person here x [4]\\n                        [2]\\n```\n```\\n[1]\\n[1]\\n[1][1]\\n[1][1] <- block height\\n\\nx\\nsame person here\\n```\n```\\n(i,j)->\\n  |\\n  v\\n```\n```python\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n\\t\\tNotes\\n\\t\\t============\\n\\t\\t\\n        Calculations\\n        ------------\\n        \\n        Top and Bottom Face:\\n        If a positive value exists on the current cell, increment counter (only need to know if it exists, one cell face == 1)\\n        \\n        Change in Altitude:\\n        For each cell, check difference between current position and surrounding\\n            - Goal is to check diff below current position and in front of current position\\n            - If at right edge, check below if possible\\n            - If at bottom edge, check right if possible\\n            - It not at right and bottom, check both right and bottom\\n        \\n            Search Pattern:\\n            (i,j)->\\n              |\\n              v\\n\\n        Left Edge:\\n            - If at left edge (jth index == 0), increment counter with face value\\n        \\n        Right Edge:\\n            - If at right edge (jth index == (len(n) - 1)), increment counter with face value\\n        \\n        Top Edge:\\n            - If at top edge (ith index == 0), increment counter with face value\\n        \\n        Bottom Edge:\\n            - If at bottom edge (ith index == (len(n) - 1)), increment counter with face value\\n        \\n        \\n        Combining All Calculations Into Single Cycle:\\n\\n        counter = 0\\n        For i,j:\\n            counter += topBotFace(i,j) # Gives 2 if face value > 0\\n            counter += altitude(i,j) # Checks diff\\n            counter += leftEdge(i,j)\\n            counter += rightEdge(i,j)\\n            counter += topEdge(i,j)\\n            counter += bottomEdge(i,j)\\n\\n        return counter\\n        \"\"\"\\n        surface_area = 0\\n        n = len(grid)\\n\\n        for i in range(n):\\n            for j in range(n):\\n                bottom_edge = False\\n                right_edge = False\\n\\n                # Top and Bottom Faces\\n                if grid[i][j] > 0:\\n                    surface_area += 2\\n\\n                # Left edge\\n                if j == 0:\\n                    surface_area += grid[i][j]\\n                \\n                # Right edge\\n                if j == (n - 1):\\n                    surface_area += grid[i][j]\\n                    right_edge = True\\n                \\n                # Top Edge\\n                if i == 0:\\n                    surface_area += grid[i][j]\\n                \\n                # Bottom Edge\\n                if i == (n - 1):\\n                    surface_area += grid[i][j]\\n                    bottom_edge = True\\n                    \\n                # Altitude\\n                surface_area += self.altitude(i, j, grid, right_edge, bottom_edge)\\n        \\n        return surface_area\\n\\n    def altitude(self, i, j, grid, right, bot):\\n        total_diff = 0\\n\\n        if not right and not bot:\\n            total_diff += abs(grid[i][j] - grid[i][j + 1]) # Look forward\\n            total_diff += abs(grid[i][j] - grid[i + 1][j]) # Look below\\n        elif right and not bot:\\n            total_diff += abs(grid[i][j] - grid[i + 1][j])\\n        elif bot and not right:\\n            total_diff += abs(grid[i][j] - grid[i][j + 1])\\n        else:\\n            total_diff += 0\\n\\n        return total_diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965812,
                "title": "javascript-overlapping-happens-in-3-directions",
                "content": "Since there might be **holes** in shapes, whose surface areas couldn\\'t be projected.\\nWe CANNOT use the 2*[883. Projection Area of 3D Shapes](https://leetcode.com/problems/projection-area-of-3d-shapes/) to solve it : (\\n.\\n\\n**Intuition** \\n\\nWe have to focus on **overlapping** occurrence then.\\n\\n```\\nAssume there are n cubes and k times of overlapping happens\\n-> surface area = 6*n-2*k.\\n```\\n>Note: don\\'t forget 3-directions all may overlap.\\nA cube of height `h` **has already overlaps`h-1`times ITSELF**!\\n\\n```\\nvar surfaceArea = function(grid) {\\n    let cube=0, overlap=0;\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[i].length; j++){\\n            cube+=grid[i][j];\\n            if(i>0){overlap+=Math.min(grid[i][j], grid[i-1][j]);} // x-direction\\n            if(j>0){overlap+=Math.min(grid[i][j], grid[i][j-1]);} // y-direction\\n\\t\\t\\tif(grid[i][j]>1){overlap+=grid[i][j]-1}; // z-direction\\n        }\\n    }\\n    return cube*6-overlap*2;\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nAssume there are n cubes and k times of overlapping happens\\n-> surface area = 6*n-2*k.\\n```\n```\\nvar surfaceArea = function(grid) {\\n    let cube=0, overlap=0;\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[i].length; j++){\\n            cube+=grid[i][j];\\n            if(i>0){overlap+=Math.min(grid[i][j], grid[i-1][j]);} // x-direction\\n            if(j>0){overlap+=Math.min(grid[i][j], grid[i][j-1]);} // y-direction\\n\\t\\t\\tif(grid[i][j]>1){overlap+=grid[i][j]-1}; // z-direction\\n        }\\n    }\\n    return cube*6-overlap*2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841014,
                "title": "java-single-pass-simple-solution",
                "content": "Note how I only check two of the adjacent faces and substract them twice instead of checking the 4 adjacent faces. if it helps please vote up\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int faces = 0; // keeping 2 variables for redability you could add and subtract on each position;\\n        int adjacent = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 0) continue;\\n                faces += 4 * grid[i][j] + 2;\\n                if(j + 1 < grid[0].length) adjacent += 2 * Math.min(grid[i][j], grid[i][j + 1]);\\n                if(i + 1 < grid.length) adjacent += 2 * Math.min(grid[i][j], grid[i + 1][j]);\\n            }\\n        }\\n        return faces - adjacent;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int faces = 0; // keeping 2 variables for redability you could add and subtract on each position;\\n        int adjacent = 0;\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 0) continue;\\n                faces += 4 * grid[i][j] + 2;\\n                if(j + 1 < grid[0].length) adjacent += 2 * Math.min(grid[i][j], grid[i][j + 1]);\\n                if(i + 1 < grid.length) adjacent += 2 * Math.min(grid[i][j], grid[i + 1][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1632057,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n    int ans=0,n=grid.size();\\n        if(n==1)\\n        {\\n            if(grid[0][0]>0)\\n            ans+=2;\\n            ans+=4*grid[0][0];\\n            return ans;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0&&j==0||i==n-1&&j==0||i==0&&j==n-1||i==n-1&&j==n-1)\\n                {\\n                    ans+=2*grid[i][j];\\n                }\\n                else if(i==0||j==0||i==n-1||j==n-1)\\n                {\\n                    ans+=grid[i][j];\\n                }\\n                if(grid[i][j]>0)\\n                ans+=2;\\n                if(i!=0)\\n                {\\n                    ans+=abs(grid[i][j]-grid[i-1][j]);\\n                }\\n                if(j!=0)\\n                {\\n                    ans+=abs(grid[i][j]-grid[i][j-1]);   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n    int ans=0,n=grid.size();\\n        if(n==1)\\n        {\\n            if(grid[0][0]>0)\\n            ans+=2;\\n            ans+=4*grid[0][0];\\n            return ans;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==0&&j==0||i==n-1&&j==0||i==0&&j==n-1||i==n-1&&j==n-1)\\n                {\\n                    ans+=2*grid[i][j];\\n                }\\n                else if(i==0||j==0||i==n-1||j==n-1)\\n                {\\n                    ans+=grid[i][j];\\n                }\\n                if(grid[i][j]>0)\\n                ans+=2;\\n                if(i!=0)\\n                {\\n                    ans+=abs(grid[i][j]-grid[i-1][j]);\\n                }\\n                if(j!=0)\\n                {\\n                    ans+=abs(grid[i][j]-grid[i][j-1]);   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610767,
                "title": "python-3-long-code-but-faster-and-acceptable",
                "content": "Approach: \\n1) First we check if there is only one cell in matrix/grid or not.\\n    If yes then just simply return 6 + 4(the value of cell - 1) : Because 1 cube has surface area of 6a^2 i.e. 6 here , everytime a new cube is added at the top of a cube surface area increases by 6-2=4units : as 2 units get glued\\n2) If no, then iterate each row and find the difference from the next cell in that row and check if the the cell is not first and last colunm of that row. If it is, then just take the abs difference otherwise add the grid value at that position as we have to cover back side of cells inbetween the first and last row.\\n3) Repeat this process with each column.\\n4) Finally calculate the top and bottom surfaces if cell is not empty.\\n5) Also, add the remaining surfaces of corner cells.\\n\\n\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        if m == n == 1:\\n            return 6 + 4*(grid[0][0]-1)\\n        bt = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    bt += 1\\n        bt = bt*2\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n-1):\\n                if j==0:\\n                    ans += abs(grid[i][j]-grid[i][j+1])\\n                else:\\n                    if i==0 or i==m-1:\\n                        ans += abs(grid[i][j]-grid[i][j+1]) + grid[i][j]\\n                    else:\\n                        ans += abs(grid[i][j]-grid[i][j+1])\\n        for i in range(n):\\n            for j in range(m-1):\\n                if j==0:\\n                    ans += abs(grid[j][i]-grid[j+1][i])\\n                else:\\n                    if i == 0 or i==n-1:\\n                        ans += abs(grid[j][i]-grid[j+1][i]) + grid[j][i]\\n                    else:\\n                        ans += abs(grid[j][i]-grid[j+1][i])\\n        ans += 2*(grid[0][0]+ grid[0][n-1] + grid[m-1][0] + grid[m-1][n-1])\\n        ans += bt\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        if m == n == 1:\\n            return 6 + 4*(grid[0][0]-1)\\n        bt = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    bt += 1\\n        bt = bt*2\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n-1):\\n                if j==0:\\n                    ans += abs(grid[i][j]-grid[i][j+1])\\n                else:\\n                    if i==0 or i==m-1:\\n                        ans += abs(grid[i][j]-grid[i][j+1]) + grid[i][j]\\n                    else:\\n                        ans += abs(grid[i][j]-grid[i][j+1])\\n        for i in range(n):\\n            for j in range(m-1):\\n                if j==0:\\n                    ans += abs(grid[j][i]-grid[j+1][i])\\n                else:\\n                    if i == 0 or i==n-1:\\n                        ans += abs(grid[j][i]-grid[j+1][i]) + grid[j][i]\\n                    else:\\n                        ans += abs(grid[j][i]-grid[j+1][i])\\n        ans += 2*(grid[0][0]+ grid[0][n-1] + grid[m-1][0] + grid[m-1][n-1])\\n        ans += bt\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647141,
                "title": "o-n-2-time-o-1-space-java-solution",
                "content": "```\\n//O(n^2) time, O(1) space\\n    public int surfaceArea(int[][] grid) {\\n        int n = grid.length;\\n        int area = 0;\\n    \\n        for(int i =0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0)\\n                    area += grid[i][j]*4 + 2;\\n                \\n                if(i>0) area -= Math.min(grid[i][j], grid[i-1][j])*2;\\n                if(j>0) area -= Math.min(grid[i][j], grid[i][j-1])*2;\\n            }\\n        }\\n        \\n        return area;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//O(n^2) time, O(1) space\\n    public int surfaceArea(int[][] grid) {\\n        int n = grid.length;\\n        int area = 0;\\n    \\n        for(int i =0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]>0)\\n                    area += grid[i][j]*4 + 2;\\n                \\n                if(i>0) area -= Math.min(grid[i][j], grid[i-1][j])*2;\\n                if(j>0) area -= Math.min(grid[i][j], grid[i][j-1])*2;\\n            }\\n        }\\n        \\n        return area;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 524824,
                "title": "python-3-simple-solutions-beats-96-05",
                "content": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        area = 0\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    area += grid[i][j] * 4 + 2\\n                if i:\\n                    area -= min(grid[i][j], grid[i-1][j]) * 2\\n                if j:\\n                    area -= min(grid[i][j], grid[i][j-1]) * 2\\n        return area\\n                \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        area = 0\\n        n = len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    area += grid[i][j] * 4 + 2\\n                if i:\\n                    area -= min(grid[i][j], grid[i-1][j]) * 2\\n                if j:\\n                    area -= min(grid[i][j], grid[i][j-1]) * 2\\n        return area\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483797,
                "title": "python-3-easy-to-understand-90-100-o-mn-complexity",
                "content": "The algorithm is simply 2 steps:\\n1, count surface on each independent grid: \\nFor each grid, if there is a positive value(meaning cubes exist), there should be 4n+2 surface (n: number of cubes)\\n2, substract surface overlap:\\nFor adjacent grids A and B, the overlap should be 2*min(n_A, n_B)\\n\\nImagine this grid map as a matrix, we scan from upper left to lower right entries to avoid double-counting.\\nEasy to understand, it is of O(mn), where m,n are matrix row and column size.\\n\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:        \\n        out, row, col = 0, len(grid), len(grid[0])      \\n        for i in range(row):\\n            for j in range(col):\\n                temp = grid[i][j]\\n                if not temp:\\n                    continue\\n                out += 4 * temp + 2\\n                if row-1-i:\\n                    out -= 2 * min(temp, grid[i+1][j])\\n                if col-1-j:\\n                    out -= 2 * min(temp, grid[i][j+1])        \\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:        \\n        out, row, col = 0, len(grid), len(grid[0])      \\n        for i in range(row):\\n            for j in range(col):\\n                temp = grid[i][j]\\n                if not temp:\\n                    continue\\n                out += 4 * temp + 2\\n                if row-1-i:\\n                    out -= 2 * min(temp, grid[i+1][j])\\n                if col-1-j:\\n                    out -= 2 * min(temp, grid[i][j+1])        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275786,
                "title": "java-easy-to-understand-faster-than-99",
                "content": "````\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        return (computeSide(grid)\\n             + computeSide(transpose(grid))\\n             + computeVertical(grid))*2;\\n    }\\n    \\n    private int[][] transpose(int[][] grid){\\n        int[][] result = new int[grid.length][grid.length];\\n        for (int r=0; r<grid.length; r++){\\n            for (int c=0; c<grid.length; c++){\\n                result[r][c]=grid[c][r];\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int computeSide(int[][] grid){\\n        int total =0;\\n        \\n        for (int r[] : grid){\\n            int prev=0;\\n            for (int c : r){\\n                if (c > prev)\\n                    total += c - prev;\\n                \\n                prev=c;\\n            }\\n        }\\n        \\n        return total;\\n    }\\n    \\n    private int computeVertical(int[][] grid){\\n        int total =0;\\n        \\n        for (int r[] : grid){\\n            for (int c : r){\\n                if (c != 0)\\n                    total++;\\n            }\\n        }\\n        \\n        return total;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        return (computeSide(grid)\\n             + computeSide(transpose(grid))\\n             + computeVertical(grid))*2;\\n    }\\n    \\n    private int[][] transpose(int[][] grid){\\n        int[][] result = new int[grid.length][grid.length];\\n        for (int r=0; r<grid.length; r++){\\n            for (int c=0; c<grid.length; c++){\\n                result[r][c]=grid[c][r];\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int computeSide(int[][] grid){\\n        int total =0;\\n        \\n        for (int r[] : grid){\\n            int prev=0;\\n            for (int c : r){\\n                if (c > prev)\\n                    total += c - prev;\\n                \\n                prev=c;\\n            }\\n        }\\n        \\n        return total;\\n    }\\n    \\n    private int computeVertical(int[][] grid){\\n        int total =0;\\n        \\n        for (int r[] : grid){\\n            for (int c : r){\\n                if (c != 0)\\n                    total++;\\n            }\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163506,
                "title": "python-o-n-straight-forward-code",
                "content": "```\\nclass Solution(object):\\n    def surfaceArea(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        row_count, col_count = len(grid), len(grid[0])\\n        surface = 0\\n        for row in range(row_count):\\n            for col in range(col_count):\\n                # if the cell is left-most, right-most, front-most, back-most\\n                edges = ((row == 0) + (col == 0) + (row == row_count - 1) + (col == col_count - 1))\\n                surface += grid[row][col] * edges\\n\\n                # the delta between the cell to the right and the cell to the front\\n                if row != row_count - 1:\\n                    surface += abs(grid[row][col] - grid[row + 1][col])\\n                if col != col_count - 1:\\n                    surface += abs(grid[row][col] - grid[row][col + 1])\\n                \\n                # top and bottom\\n                if grid[row][col] > 0:\\n                    surface += 2\\n\\n        return surface\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def surfaceArea(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        row_count, col_count = len(grid), len(grid[0])\\n        surface = 0\\n        for row in range(row_count):\\n            for col in range(col_count):\\n                # if the cell is left-most, right-most, front-most, back-most\\n                edges = ((row == 0) + (col == 0) + (row == row_count - 1) + (col == col_count - 1))\\n                surface += grid[row][col] * edges\\n\\n                # the delta between the cell to the right and the cell to the front\\n                if row != row_count - 1:\\n                    surface += abs(grid[row][col] - grid[row + 1][col])\\n                if col != col_count - 1:\\n                    surface += abs(grid[row][col] - grid[row][col + 1])\\n                \\n                # top and bottom\\n                if grid[row][col] > 0:\\n                    surface += 2\\n\\n        return surface\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163451,
                "title": "java-solution-with-explanation",
                "content": "The bottom and top surface area is 2* the number of cubes.\\nIf the current grid is taller than the grid to the left it means we take the area of this side 2 * height, we *2 because there are two sides - the height of the grid to the left because we already added it.\\nIf the current grid is taller than the grid above it(I guess it depends on which way the axis is facing, but j-1) then we take the area of this side 2 * height, we * 2 because there are two sides sides - the height of the grid with j-1 because we already added it.\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int count = 0;\\n        if(grid.length==0)return 0;\\n        int area = 0;\\n        for(int i=0; i<grid.length;++i){\\n            for(int j=0; j<grid[0].length;++j){\\n                if(grid[i][j]!=0){\\n                    ++count;\\n                }\\n                if(i==0){\\n                    area+=2*(grid[i][j]);\\n                }\\n                else if(grid[i][j]>grid[i-1][j]){\\n                    area+=2*(grid[i][j]-grid[i-1][j]);\\n                }\\n                if(j==0){\\n                    area+=2*(grid[i][j]);\\n                }\\n                else if(grid[i][j]>grid[i][j-1]){\\n                    area+=2*(grid[i][j]-grid[i][j-1]);\\n                }\\n            }     \\n        }\\n        area+=(count*2);\\n        return area;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int count = 0;\\n        if(grid.length==0)return 0;\\n        int area = 0;\\n        for(int i=0; i<grid.length;++i){\\n            for(int j=0; j<grid[0].length;++j){\\n                if(grid[i][j]!=0){\\n                    ++count;\\n                }\\n                if(i==0){\\n                    area+=2*(grid[i][j]);\\n                }\\n                else if(grid[i][j]>grid[i-1][j]){\\n                    area+=2*(grid[i][j]-grid[i-1][j]);\\n                }\\n                if(j==0){\\n                    area+=2*(grid[i][j]);\\n                }\\n                else if(grid[i][j]>grid[i][j-1]){\\n                    area+=2*(grid[i][j]-grid[i][j-1]);\\n                }\\n            }     \\n        }\\n        area+=(count*2);\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511727,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int  area = 0, n = grid.size();\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++) {\\n                int v = grid[i][j];\\n                if (v) {\\n                    area += 2;\\n                    if (j == 0) area += v;\\n                    else if (v > grid[i][j - 1]) area += v - grid[i][j - 1];\\n                    if (i == 0) area += v;\\n                    else if (v > grid[i - 1][j]) area += v - grid[i - 1][j];\\n                    if (j + 1 == n) area += v;\\n                    else if (v > grid[i][j + 1]) area += v - grid[i][j + 1];\\n                    if (i + 1 == n) area += v;\\n                    else if (v > grid[i + 1][j]) area += v - grid[i + 1][j];\\n                }\\n            }\\n        return area;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        res = 0\\n        for i in range(n):\\n            rh = 0\\n            ch = 0\\n            for j in range(n):\\n                t = grid[i][j]\\n                res += 2 if t else 0\\n                res += abs(t - rh)\\n                rh = t\\n                t = grid[j][i]\\n                res += abs(t - ch)\\n                ch = t\\n            res += rh + ch\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        int n = grid.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                area += grid[i][j] > 0 ? 4 * grid[i][j] + 2 : 0;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n - 1; j++) {\\n                area -= 2 * Math.min(grid[i][j], grid[i][j + 1]);\\n            }\\n        }\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < n - 1; i++) {\\n                area -= 2 * Math.min(grid[i][j], grid[i + 1][j]);\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int  area = 0, n = grid.size();\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++) {\\n                int v = grid[i][j];\\n                if (v) {\\n                    area += 2;\\n                    if (j == 0) area += v;\\n                    else if (v > grid[i][j - 1]) area += v - grid[i][j - 1];\\n                    if (i == 0) area += v;\\n                    else if (v > grid[i - 1][j]) area += v - grid[i - 1][j];\\n                    if (j + 1 == n) area += v;\\n                    else if (v > grid[i][j + 1]) area += v - grid[i][j + 1];\\n                    if (i + 1 == n) area += v;\\n                    else if (v > grid[i + 1][j]) area += v - grid[i + 1][j];\\n                }\\n            }\\n        return area;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        res = 0\\n        for i in range(n):\\n            rh = 0\\n            ch = 0\\n            for j in range(n):\\n                t = grid[i][j]\\n                res += 2 if t else 0\\n                res += abs(t - rh)\\n                rh = t\\n                t = grid[j][i]\\n                res += abs(t - ch)\\n                ch = t\\n            res += rh + ch\\n        return res\\n```\n```Java []\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        int n = grid.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                area += grid[i][j] > 0 ? 4 * grid[i][j] + 2 : 0;\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n - 1; j++) {\\n                area -= 2 * Math.min(grid[i][j], grid[i][j + 1]);\\n            }\\n        }\\n        for (int j = 0; j < n; j++) {\\n            for (int i = 0; i < n - 1; i++) {\\n                area -= 2 * Math.min(grid[i][j], grid[i + 1][j]);\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123157,
                "title": "beatiful-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n^2) \\n- => n is the length or grid[i].length\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def surfaceArea(self, grid) -> int :\\n        length = len(grid)\\n\\n        def behind(point) :\\n                array = []\\n                i , j = point\\n                # top :       \\n                if length > i > 0 : array.append(min((grid[i-1][j],grid[i][j])))\\n                # left :\\n                if j < length-1 : array.append(min((grid[i][j+1] , grid[i][j])))\\n                # bottom :\\n                if i < length-1 : array.append(min((grid[i+1][j] , grid[i][j])))\\n                # right :\\n                if length > j > 0 : array.append(min((grid[i][j-1],grid[i][j])))\\n\\n                return array\\n        \\n        def tower_surface(height) : return height*6-(height-1)*2 if height > 0 else 0\\n\\n        surface = 0\\n        \\n        for i in range(length) :\\n                for j in range(length) :\\n                        surface += tower_surface(grid[i][j]) - sum(behind((i,j)))\\n\\n        return surface\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid) -> int :\\n        length = len(grid)\\n\\n        def behind(point) :\\n                array = []\\n                i , j = point\\n                # top :       \\n                if length > i > 0 : array.append(min((grid[i-1][j],grid[i][j])))\\n                # left :\\n                if j < length-1 : array.append(min((grid[i][j+1] , grid[i][j])))\\n                # bottom :\\n                if i < length-1 : array.append(min((grid[i+1][j] , grid[i][j])))\\n                # right :\\n                if length > j > 0 : array.append(min((grid[i][j-1],grid[i][j])))\\n\\n                return array\\n        \\n        def tower_surface(height) : return height*6-(height-1)*2 if height > 0 else 0\\n\\n        surface = 0\\n        \\n        for i in range(length) :\\n                for j in range(length) :\\n                        surface += tower_surface(grid[i][j]) - sum(behind((i,j)))\\n\\n        return surface\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578558,
                "title": "surface-area-of-3d-shapes-easy-java-solution-99-57-faster",
                "content": "class Solution {\\n\\npublic int surfaceArea(int[][] grid) {\\n    int total = 0;\\n    int n = grid.length;\\n    \\n    for(int i =0; i<n; i++)\\n    {\\n        for(int j =0; j<n; j++)\\n        {\\n            if(grid[i][j]>0)\\n                total += 6*grid[i][j]-2*(grid[i][j]-1); //Surface Area of 1 cube: 6*grid[i][j]; Common Surface Area of vertically placed cubes:2*(grid[i][j]-1)\\n            \\n            if(i>0)\\n                total-= 2*Math.min(grid[i-1][j],grid[i][j]);//Hidden common vertical surface area\\n            \\n            if(j>0)\\n                total-= 2*Math.min(grid[i][j-1],grid[i][j]);//Hidden common horizontal surface area\\n        }\\n    }\\n    return total;\\n}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\npublic int surfaceArea(int[][] grid) {\\n    int total = 0;\\n    int n = grid.length;\\n    \\n    for(int i =0; i<n; i++)\\n    {\\n        for(int j =0; j<n; j++)\\n        {\\n            if(grid[i][j]>0)\\n                total += 6*grid[i][j]-2*(grid[i][j]-1); //Surface Area of 1 cube: 6*grid[i][j]; Common Surface Area of vertically placed cubes:2*(grid[i][j]-1)\\n            \\n            if(i>0)\\n                total-= 2*Math.min(grid[i-1][j],grid[i][j]);//Hidden common vertical surface area\\n            \\n            if(j>0)\\n                total-= 2*Math.min(grid[i][j-1],grid[i][j]);//Hidden common horizontal surface area\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2355246,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        c=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j]:\\n                    c+=(grid[i][j]*4)+2\\n                if i:\\n                    c-=min(grid[i][j],grid[i-1][j])*2\\n                if j:\\n                    c-=min(grid[i][j],grid[i][j-1])*2\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        c=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j]:\\n                    c+=(grid[i][j]*4)+2\\n                if i:\\n                    c-=min(grid[i][j],grid[i-1][j])*2\\n                if j:\\n                    c-=min(grid[i][j],grid[i][j-1])*2\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311358,
                "title": "beginner-friendly",
                "content": "Traverse each cube in the grid:\\n* Add areas for top and left surfaces -> Simply the difference between the top or left cube and current cube\\n* Add extra surfaces for cubes present at ending of grid (right-most and bottom-most)\\n* Also add 2 surfaces for each cube if there\\'s no hole in the grid\\n\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        int n = grid.length;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                \\n                // Adding the top part of grid\\n                if(i==0) area += grid[i][j];\\n                else area += Math.abs(grid[i][j] - grid[i-1][j]);\\n                \\n                // Adding the left part of grid\\n                if(j==0) area += grid[i][j];\\n                else area += Math.abs(grid[i][j] - grid[i][j-1]);\\n                \\n                // Adding bottom part of bottom-most cubes\\n                if(i == n-1) area += grid[i][j];\\n                \\n                // Adding right part for right-most cubes\\n                if(j == n-1) area += grid[i][j];\\n                \\n                // Add top and bottom surfaces if there is no hole in grid\\n                if(grid[i][j] != 0) area += 2;\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        int n = grid.length;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                \\n                // Adding the top part of grid\\n                if(i==0) area += grid[i][j];\\n                else area += Math.abs(grid[i][j] - grid[i-1][j]);\\n                \\n                // Adding the left part of grid\\n                if(j==0) area += grid[i][j];\\n                else area += Math.abs(grid[i][j] - grid[i][j-1]);\\n                \\n                // Adding bottom part of bottom-most cubes\\n                if(i == n-1) area += grid[i][j];\\n                \\n                // Adding right part for right-most cubes\\n                if(j == n-1) area += grid[i][j];\\n                \\n                // Add top and bottom surfaces if there is no hole in grid\\n                if(grid[i][j] != 0) area += 2;\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095105,
                "title": "c-solution-single-pass-short-simple-o-m-n",
                "content": "**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int surfaceArea(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int total, overlap, non_zero;\\n        total = overlap = non_zero = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0)\\n                    continue;\\n                non_zero++;\\n                total += grid[i][j];\\n                if (i + 1 < m)\\n                    overlap += min(grid[i][j], grid[i + 1][j]);\\n                if (j + 1 < n)\\n                    overlap += min(grid[i][j], grid[i][j + 1]);\\n            }\\n        }\\n        int k = (total * 4) + (2 * non_zero) - (overlap * 2);\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int surfaceArea(vector<vector<int>> &grid)\\n    {\\n        int m = grid.size(), n = grid[0].size();\\n        int total, overlap, non_zero;\\n        total = overlap = non_zero = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0)\\n                    continue;\\n                non_zero++;\\n                total += grid[i][j];\\n                if (i + 1 < m)\\n                    overlap += min(grid[i][j], grid[i + 1][j]);\\n                if (j + 1 < n)\\n                    overlap += min(grid[i][j], grid[i][j + 1]);\\n            }\\n        }\\n        int k = (total * 4) + (2 * non_zero) - (overlap * 2);\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010809,
                "title": "c-one-scan",
                "content": "We have the formula 4 * height + 2 for a single (i,j) coordinate, after observation.\\nBut when there are adjacent cells, the overlap region should not be counted.\\n\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        int total_cnt{}, overlap{}, cnt_non_zero{};\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0) continue;\\n                cnt_non_zero ++; \\n                total_cnt += grid[i][j];\\n                if(i + 1 < m)\\n                    overlap += min(grid[i][j], grid[i+1][j]);\\n                if(j + 1 < n)\\n                    overlap += min(grid[i][j], grid[i][j+1]);\\n            }\\n        }\\n        return total_cnt * 4 + 2 * cnt_non_zero - overlap * 2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        int total_cnt{}, overlap{}, cnt_non_zero{};\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0) continue;\\n                cnt_non_zero ++; \\n                total_cnt += grid[i][j];\\n                if(i + 1 < m)\\n                    overlap += min(grid[i][j], grid[i+1][j]);\\n                if(j + 1 < n)\\n                    overlap += min(grid[i][j], grid[i][j+1]);\\n            }\\n        }\\n        return total_cnt * 4 + 2 * cnt_non_zero - overlap * 2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967396,
                "title": "python-3-clean-and-concise-code-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        def area(i, j):\\n            v = grid[i][j]\\n            if v == 0:\\n                return 0\\n\\n            up = min(v, grid[i - 1][j]) if i else 0\\n            right = min(v, grid[i][j + 1]) if j < n - 1 else 0\\n            down = min(v, grid[i + 1][j]) if i < n - 1 else 0\\n            left = min(v, grid[i][j - 1]) if j else 0\\n\\n            return 2 + 4*v - up - right - down - left\\n        \\n        return sum(area(i, j) for i in range(n) for j in range(n))",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        def area(i, j):\\n            v = grid[i][j]\\n            if v == 0:\\n                return 0\\n\\n            up = min(v, grid[i - 1][j]) if i else 0\\n            right = min(v, grid[i][j + 1]) if j < n - 1 else 0\\n            down = min(v, grid[i + 1][j]) if i < n - 1 else 0\\n            left = min(v, grid[i][j - 1]) if j else 0\\n\\n            return 2 + 4*v - up - right - down - left\\n        \\n        return sum(area(i, j) for i in range(n) for j in range(n))",
                "codeTag": "Java"
            },
            {
                "id": 1912207,
                "title": "simple-python-solution",
                "content": "```python\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        total_surface = 0\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                \\n                height = grid[i][j]\\n                surface = 2 + 4 * height if height > 0 else 0\\n                \\n                if i != n-1:\\n                    surface -= min(height, grid[i+1][j])\\n                \\n                if i != 0:\\n                    surface -= min(height, grid[i-1][j])\\n    \\n                if j != n-1:\\n                    surface -= min(height, grid[i][j+1])\\n                \\n                if j != 0:\\n                    surface -= min(height, grid[i][j-1])\\n                    \\n                total_surface += surface\\n                \\n        return total_surface\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        total_surface = 0\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                \\n                height = grid[i][j]\\n                surface = 2 + 4 * height if height > 0 else 0\\n                \\n                if i != n-1:\\n                    surface -= min(height, grid[i+1][j])\\n                \\n                if i != 0:\\n                    surface -= min(height, grid[i-1][j])\\n    \\n                if j != n-1:\\n                    surface -= min(height, grid[i][j+1])\\n                \\n                if j != 0:\\n                    surface -= min(height, grid[i][j-1])\\n                    \\n                total_surface += surface\\n                \\n        return total_surface\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856597,
                "title": "c-w-explanation",
                "content": "```\\n// Tower of height n has 6n faces and 2(n-1) hidden faces = 4n + 2 visible faces\\n// The number of hidden faces in adjacent towers is twice the smaller height\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n      int res = 0;\\n      int n = grid.size();\\n      for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n          if (grid[i][j]) res += 4 * grid[i][j] + 2;\\n          if (i > 0) res -= 2 * min(grid[i][j], grid[i-1][j]);\\n          if (j > 0) res -= 2 * min(grid[i][j], grid[i][j-1]);\\n        }\\n      }\\n      return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Tower of height n has 6n faces and 2(n-1) hidden faces = 4n + 2 visible faces\\n// The number of hidden faces in adjacent towers is twice the smaller height\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n      int res = 0;\\n      int n = grid.size();\\n      for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n          if (grid[i][j]) res += 4 * grid[i][j] + 2;\\n          if (i > 0) res -= 2 * min(grid[i][j], grid[i-1][j]);\\n          if (j > 0) res -= 2 * min(grid[i][j], grid[i][j-1]);\\n        }\\n      }\\n      return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785853,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def surfaceArea(self, a: List[List[int]]) -> int:\\n        answer = 0\\n        \\n        for i in range(len(a)):\\n            for j in range(len(a)):\\n                answer += self.helper(i, j , a)\\n        \\n        return answer\\n    \\n    def helper(self, i, j, a):\\n        area = 0\\n        count = a[i][j]\\n        \\n        if count == 0:\\n            return 0\\n        else:\\n            area += 2\\n            \\n        if i == 0:\\n            area += count\\n        \\n        if i == len(a) - 1:\\n            area += count\\n        \\n        if j == 0:\\n            area += count\\n            \\n        if j == len(a) - 1:\\n            area += count\\n        \\n        if j + 1 < len(a) and count > a[i][j+1]:\\n            area += count - a[i][j+1]\\n        \\n        if i + 1 < len(a) and count > a[i+1][j]:\\n            area += count - a[i+1][j]\\n            \\n        if i-1 >= 0 and count > a[i-1][j]:\\n            area += count - a[i-1][j]\\n        \\n        if j -1 >= 0 and count > a[i][j-1]:\\n            area += count - a[i][j-1]\\n        \\n        return area\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, a: List[List[int]]) -> int:\\n        answer = 0\\n        \\n        for i in range(len(a)):\\n            for j in range(len(a)):\\n                answer += self.helper(i, j , a)\\n        \\n        return answer\\n    \\n    def helper(self, i, j, a):\\n        area = 0\\n        count = a[i][j]\\n        \\n        if count == 0:\\n            return 0\\n        else:\\n            area += 2\\n            \\n        if i == 0:\\n            area += count\\n        \\n        if i == len(a) - 1:\\n            area += count\\n        \\n        if j == 0:\\n            area += count\\n            \\n        if j == len(a) - 1:\\n            area += count\\n        \\n        if j + 1 < len(a) and count > a[i][j+1]:\\n            area += count - a[i][j+1]\\n        \\n        if i + 1 < len(a) and count > a[i+1][j]:\\n            area += count - a[i+1][j]\\n            \\n        if i-1 >= 0 and count > a[i-1][j]:\\n            area += count - a[i-1][j]\\n        \\n        if j -1 >= 0 and count > a[i][j-1]:\\n            area += count - a[i][j-1]\\n        \\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715464,
                "title": "python-clean-and-straightforward",
                "content": "```py\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        m, n, area = len(grid), len(grid[0]), 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if (x := grid[i][j]) == 0:\\n                    continue\\n\\n                top = max(0, x - grid[i - 1][j]) if i > 0 else x\\n                bot = max(0, x - grid[i + 1][j]) if i + 1 < m else x\\n                left = max(0, x - grid[i][j - 1]) if j > 0 else x\\n                right = max(0, x - grid[i][j + 1]) if j + 1 < n else x\\n\\n                area += top + bot + left + right + 2\\n\\n        return area\\n```\\n\\nJust add all visible faces, not much else to do here.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        m, n, area = len(grid), len(grid[0]), 0\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if (x := grid[i][j]) == 0:\\n                    continue\\n\\n                top = max(0, x - grid[i - 1][j]) if i > 0 else x\\n                bot = max(0, x - grid[i + 1][j]) if i + 1 < m else x\\n                left = max(0, x - grid[i][j - 1]) if j > 0 else x\\n                right = max(0, x - grid[i][j + 1]) if j + 1 < n else x\\n\\n                area += top + bot + left + right + 2\\n\\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613222,
                "title": "easy-kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun surfaceArea(grid: Array<IntArray>): Int {\\n        var area=0\\n        for(i in 0 until grid.size){\\n            for(j in 0 until grid.size){\\n                if(grid[i][j]!=0){\\n                    area+=grid[i][j]*4+2\\n                }\\n                if(i<grid.size-1){\\n                    area-=minOf(grid[i][j],grid[i+1][j])*2\\n                }\\n                if(j<grid.size-1){\\n                    area-=minOf(grid[i][j],grid[i][j+1])*2\\n                }\\n            }\\n        }\\n        return area\\n    }\\n}",
                "solutionTags": [
                    "Kotlin",
                    "Array"
                ],
                "code": "class Solution {\\n    fun surfaceArea(grid: Array<IntArray>): Int {\\n        var area=0\\n        for(i in 0 until grid.size){\\n            for(j in 0 until grid.size){\\n                if(grid[i][j]!=0){\\n                    area+=grid[i][j]*4+2\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1573578,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn surface_area(grid: Vec<Vec<i32>>) -> i32 {\\n        let dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)];\\n        let l = grid.len() as i32;\\n        let mut res = 0;\\n\\n        for (row, i) in grid.iter().zip(0..) {\\n            for (&val, j) in row.iter().zip(0..).filter(|(val, _)| **val > 0) {\\n                res += 2; // up adn down surfaces\\n                for (dx, dy) in dirs.iter().cloned() {\\n                    let (xx, yy) = (j + dx, i + dy);\\n                    res += match xx >= 0 && yy >= 0 && xx < l && yy < l {\\n                        true => (val - grid[yy as usize][xx as usize]).max(0),\\n                        false => val,\\n                    };\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn surface_area(grid: Vec<Vec<i32>>) -> i32 {\\n        let dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)];\\n        let l = grid.len() as i32;\\n        let mut res = 0;\\n\\n        for (row, i) in grid.iter().zip(0..) {\\n            for (&val, j) in row.iter().zip(0..).filter(|(val, _)| **val > 0) {\\n                res += 2; // up adn down surfaces\\n                for (dx, dy) in dirs.iter().cloned() {\\n                    let (xx, yy) = (j + dx, i + dy);\\n                    res += match xx >= 0 && yy >= 0 && xx < l && yy < l {\\n                        true => (val - grid[yy as usize][xx as usize]).max(0),\\n                        false => val,\\n                    };\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429318,
                "title": "c-o-n-2-solution",
                "content": "Runtime: 8 ms, faster than 78.50% of C++ online submissions for Surface Area of 3D Shapes.\\nMemory Usage: 9.4 MB, less than 46.42% of C++ online submissions for Surface Area of 3D Shapes.\\n\\n\\nLoop through grid and calculate surface area of the each cell. Also we deduct the common area betwen \\n2 consicuitive cells. We can consider only left and upper cell and multiply the common area by 2. Common\\narea between consicuitive cell is the min height between them.\\n\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int area = 0;\\n        int deduct = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    area = area +  2*(1+ grid[i][j] *2);                    \\n                }\\n                \\n                if(i)deduct += min(grid[i][j],grid[i-1][j]) * 2;\\n                if(j)deduct += min(grid[i][j],grid[i][j-1]) * 2;                \\n            }\\n        }\\n        \\n        return area - deduct;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int area = 0;\\n        int deduct = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    area = area +  2*(1+ grid[i][j] *2);                    \\n                }\\n                \\n                if(i)deduct += min(grid[i][j],grid[i-1][j]) * 2;\\n                if(j)deduct += min(grid[i][j],grid[i][j-1]) * 2;                \\n            }\\n        }\\n        \\n        return area - deduct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1418993,
                "title": "o-n-n-time-and-o-1-space-readable-concise",
                "content": "```\\npublic class Solution {\\n    public int SurfaceArea(int[][] grid) {\\n        int res = 0;\\n        for(int i = 0; i < grid.Length; ++i) {\\n            for(int j = 0; j < grid[i].Length; ++j) {\\n                res += column(i, j, grid);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    static int column(int i, int j, int[][] grid) {\\n        if(grid[i][j] == 0) {\\n            return 0;\\n        }\\n        \\n        int res = 4*grid[i][j] + 2;\\n        \\n        if(0 <= i - 1) {\\n            res -= 2*Math.Min(grid[i - 1][j], grid[i][j]);\\n        }\\n        \\n        if(0 <= j - 1) {\\n            res -= 2*Math.Min(grid[i][j - 1], grid[i][j]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SurfaceArea(int[][] grid) {\\n        int res = 0;\\n        for(int i = 0; i < grid.Length; ++i) {\\n            for(int j = 0; j < grid[i].Length; ++j) {\\n                res += column(i, j, grid);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    static int column(int i, int j, int[][] grid) {\\n        if(grid[i][j] == 0) {\\n            return 0;\\n        }\\n        \\n        int res = 4*grid[i][j] + 2;\\n        \\n        if(0 <= i - 1) {\\n            res -= 2*Math.Min(grid[i - 1][j], grid[i][j]);\\n        }\\n        \\n        if(0 <= j - 1) {\\n            res -= 2*Math.Min(grid[i][j - 1], grid[i][j]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363391,
                "title": "java-tc-o-n-2-sc-o-1-more-in-depth-explanation-about-calculation",
                "content": "```\\n/*\\n    Explanation about calculation\\n    -----------------------------\\n\\n    Total Area contributed by a cube -> 6 * 1 (according to discription [1 * 1 * 1])\\n    \\n    Common area when the cubes are placed on the top of each other (vertically) : \\n        2 * (number_of_cubes - 1) -> 2 * (grid[i][j] - 1)\\n        \\n    so therefore, total surface area by a tower : (6 * grid[i][j] - 2 * (grid[i][j] - 1))\\n                                                : 4 * grid[i][j] + 2\\n                                                \\n    \\n    Also needs to subtract, adjacent hidden common area from total surface area calculated\\n    so far.\\n    \\n        adjacent_hidden_common_area_horizontally : 2 * min(cubes_cnt_in_first_tower, cubes_cnt_in_tower_next_to_first_tower)\\n                                                 : 2 * min(grid[i][j], grid[i][j + 1]) or\\n                                                 : 2 * min(grid[i][j], grid[i][j - 1]) based on implementation.\\n                                                 \\n        adjacent_hidden_common_area_vertically   : 2 * min(cubes_cnt_in_first_tower, cubes_cnt_in_tower_beneath_to_first_tower)\\n                                                 : 2 * min(grid[i][j], grid[i + 1][j]) or\\n                                                 : 2 * min(grid[i][j], grid[i - 1][j]) based on implementation.\\n*/\\n\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int n = grid.length, totSA = 0;\\n        for(int i = 0; i < n; i += 1) {\\n            for(int j = 0; j < n; j += 1) {\\n                if(grid[i][j] > 0) totSA += (6 * grid[i][j] - 2 * (grid[i][j] - 1));\\n                if(i > 0) totSA -= 2 * Math.min(grid[i][j], grid[i - 1][j]);//vertically hidden common area\\n                if(j > 0) totSA -= 2 * Math.min(grid[i][j], grid[i][j - 1]);//horizontally hidden common area\\n            }\\n        }\\n        \\n        return totSA;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Explanation about calculation\\n    -----------------------------\\n\\n    Total Area contributed by a cube -> 6 * 1 (according to discription [1 * 1 * 1])\\n    \\n    Common area when the cubes are placed on the top of each other (vertically) : \\n        2 * (number_of_cubes - 1) -> 2 * (grid[i][j] - 1)\\n        \\n    so therefore, total surface area by a tower : (6 * grid[i][j] - 2 * (grid[i][j] - 1))\\n                                                : 4 * grid[i][j] + 2\\n                                                \\n    \\n    Also needs to subtract, adjacent hidden common area from total surface area calculated\\n    so far.\\n    \\n        adjacent_hidden_common_area_horizontally : 2 * min(cubes_cnt_in_first_tower, cubes_cnt_in_tower_next_to_first_tower)\\n                                                 : 2 * min(grid[i][j], grid[i][j + 1]) or\\n                                                 : 2 * min(grid[i][j], grid[i][j - 1]) based on implementation.\\n                                                 \\n        adjacent_hidden_common_area_vertically   : 2 * min(cubes_cnt_in_first_tower, cubes_cnt_in_tower_beneath_to_first_tower)\\n                                                 : 2 * min(grid[i][j], grid[i + 1][j]) or\\n                                                 : 2 * min(grid[i][j], grid[i - 1][j]) based on implementation.\\n*/\\n\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int n = grid.length, totSA = 0;\\n        for(int i = 0; i < n; i += 1) {\\n            for(int j = 0; j < n; j += 1) {\\n                if(grid[i][j] > 0) totSA += (6 * grid[i][j] - 2 * (grid[i][j] - 1));\\n                if(i > 0) totSA -= 2 * Math.min(grid[i][j], grid[i - 1][j]);//vertically hidden common area\\n                if(j > 0) totSA -= 2 * Math.min(grid[i][j], grid[i][j - 1]);//horizontally hidden common area\\n            }\\n        }\\n        \\n        return totSA;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349448,
                "title": "c-o-mn-solution-faster-than-84-21",
                "content": "![image](https://assets.leetcode.com/users/images/b2bbb759-ee46-4d32-b69d-4de2a1d11f40_1626742213.9398105.png)\\n\\n```\\npublic class Solution {\\n    public int SurfaceArea(int[][] grid) {\\n        var res = 0;\\n        for(var i =0; i<grid.Length; i++){\\n            for(var j=0; j<grid[i].Length; j++){\\n\\t\\t\\t\\t//at top row \\n                if(i==0){\\n                    res += grid[i][j];\\n                }\\n\\t\\t\\t\\t//at bottom row \\n                if(i==grid.Length-1){\\n                    res += grid[i][j];\\n                }\\n\\t\\t\\t\\t//at left most column\\n                if(j==0){\\n                    res +=grid[i][j];\\n                }\\n\\t\\t\\t\\t//at right most column\\n                if(j==grid[i].Length-1){\\n                    res+=grid[i][j];\\n                }\\n\\t\\t\\t\\t//current position is higher than previous row\\n                if(i>0 && grid[i][j]>grid[i-1][j]){\\n                    res += grid[i][j]-grid[i-1][j];\\n                }\\n\\t\\t\\t\\t//current position is higher than next row\\n                if(i<grid.Length-1 && grid[i][j]>grid[i+1][j]){\\n                    res += grid[i][j] -grid[i+1][j];\\n                }\\n\\t\\t\\t\\t//current position is higher than previous column\\n                if(j>0 && grid[i][j]>grid[i][j-1]){\\n                    res += grid[i][j]-grid[i][j-1];\\n                }\\n\\t\\t\\t\\t//current position is higher than next column\\n                if(j<grid[i].Length-1 && grid[i][j]>grid[i][j+1]){\\n                    res +=grid[i][j]-grid[i][j+1];\\n                }\\n\\t\\t\\t\\t//current position is not empty, count the top and bottom area.\\n                if(grid[i][j]!=0){\\n                    res +=2;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SurfaceArea(int[][] grid) {\\n        var res = 0;\\n        for(var i =0; i<grid.Length; i++){\\n            for(var j=0; j<grid[i].Length; j++){\\n\\t\\t\\t\\t//at top row \\n                if(i==0){\\n                    res += grid[i][j];\\n                }\\n\\t\\t\\t\\t//at bottom row \\n                if(i==grid.Length-1){\\n                    res += grid[i][j];\\n                }\\n\\t\\t\\t\\t//at left most column\\n                if(j==0){\\n                    res +=grid[i][j];\\n                }\\n\\t\\t\\t\\t//at right most column\\n                if(j==grid[i].Length-1){\\n                    res+=grid[i][j];\\n                }\\n\\t\\t\\t\\t//current position is higher than previous row\\n                if(i>0 && grid[i][j]>grid[i-1][j]){\\n                    res += grid[i][j]-grid[i-1][j];\\n                }\\n\\t\\t\\t\\t//current position is higher than next row\\n                if(i<grid.Length-1 && grid[i][j]>grid[i+1][j]){\\n                    res += grid[i][j] -grid[i+1][j];\\n                }\\n\\t\\t\\t\\t//current position is higher than previous column\\n                if(j>0 && grid[i][j]>grid[i][j-1]){\\n                    res += grid[i][j]-grid[i][j-1];\\n                }\\n\\t\\t\\t\\t//current position is higher than next column\\n                if(j<grid[i].Length-1 && grid[i][j]>grid[i][j+1]){\\n                    res +=grid[i][j]-grid[i][j+1];\\n                }\\n\\t\\t\\t\\t//current position is not empty, count the top and bottom area.\\n                if(grid[i][j]!=0){\\n                    res +=2;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256612,
                "title": "not-efficient-but-easy-to-understand-c-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans =0, n = grid.size();\\n        for(int i=0; i<n;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {   \\n                \\n                if(grid[i][j] > 0)\\n                {\\n                    ans +=2;                     // top & bottom\\n                    //right\\n                    if(i+1 == n)                            //row below current block\\n                        ans += grid[i][j];\\n                    else if(i+1 < n)\\n                        ans += grid[i+1][j] < grid[i][j]?-grid[i+1][j] +grid[i][j]:0;\\n                    if(j-1 == -1)                                  \\\\\\\\left column\\n                        ans += grid[i][j];\\n                    else if( j-1 >= 0)\\n                        ans += grid[i][j-1] < grid[i][j]?-grid[i][j-1]+grid[i][j]:0;\\n                    if(i-1 == -1)                       //top row\\n                        ans += grid[i][j];\\n                    else if(i-1 >= 0)\\n                        ans += grid[i-1][j] < grid[i][j]? -grid[i-1][j]+grid[i][j]:0;\\n                    if(j+1 == n)                       // right column\\n                        ans += grid[i][j];\\n                    else if(j+1 < n)\\n                        ans += grid[i][j+1] < grid[i][j]? grid[i][j]- grid[i][j+1]:0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans =0, n = grid.size();\\n        for(int i=0; i<n;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {   \\n                \\n                if(grid[i][j] > 0)\\n                {\\n                    ans +=2;                     // top & bottom\\n                    //right\\n                    if(i+1 == n)                            //row below current block\\n                        ans += grid[i][j];\\n                    else if(i+1 < n)\\n                        ans += grid[i+1][j] < grid[i][j]?-grid[i+1][j] +grid[i][j]:0;\\n                    if(j-1 == -1)                                  \\\\\\\\left column\\n                        ans += grid[i][j];\\n                    else if( j-1 >= 0)\\n                        ans += grid[i][j-1] < grid[i][j]?-grid[i][j-1]+grid[i][j]:0;\\n                    if(i-1 == -1)                       //top row\\n                        ans += grid[i][j];\\n                    else if(i-1 >= 0)\\n                        ans += grid[i-1][j] < grid[i][j]? -grid[i-1][j]+grid[i][j]:0;\\n                    if(j+1 == n)                       // right column\\n                        ans += grid[i][j];\\n                    else if(j+1 < n)\\n                        ans += grid[i][j+1] < grid[i][j]? grid[i][j]- grid[i][j+1]:0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157087,
                "title": "ruby-100-100",
                "content": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef surface_area(grid)\\n  f(grid) + f(grid.transpose) + grid.sum { |row| row.count(&:positive?) } * 2\\nend\\n\\ndef f(grid)\\n  grid.sum do |row|\\n    row.each_cons(2).sum { |x, y| (x - y).abs }\\n  end + grid[0].sum + grid[-1].sum\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef surface_area(grid)\\n  f(grid) + f(grid.transpose) + grid.sum { |row| row.count(&:positive?) } * 2\\nend\\n\\ndef f(grid)\\n  grid.sum do |row|\\n    row.each_cons(2).sum { |x, y| (x - y).abs }\\n  end + grid[0].sum + grid[-1].sum\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1149012,
                "title": "golang-solution-100-100-with-explanation-and-images",
                "content": "[892. Surface Area of 3D Shapes](https://leetcode.com/problems/surface-area-of-3d-shapes/)\\n\\n**The Idea Of This Solution:**\\n\\nThis solution uses the fact that each stack of cubes surface area is the equation `2 + 4 * v`. This works because each cube has `6` sides. This can be shown using some images:\\n\\n![image](https://assets.leetcode.com/users/images/430fed25-6574-4afe-83ba-dfeb4bc854ef_1617905640.5446177.jpeg)\\n\\n\\n> We can see that each cube has `6` planes. There are `4` sides, `1` top, and `1` bottom.\\n\\n![image](https://assets.leetcode.com/users/images/ef2969cd-a5df-4555-b9dd-90620ed6bdc9_1617905658.0570703.jpeg)\\n\\n\\n> Now, as we can see, there are `10` units of surface area while the other one only had `6`, there are `8` sides, `1` top, and `1` bottom.\\n\\n![image](https://assets.leetcode.com/users/images/b221abd9-19f3-460d-8632-12024264fd65_1617905670.5315402.jpeg)\\n\\n\\n> This example is `3` cubes, and it has a surface area of `14` units. There are `12` side units, `1` top, and `1` bottom.\\n\\nAs you can see in all three examples, there is always 1 top, one bottom, and four sides per cube, so we can write the equation `2 + 4 * v`, where `v` is the number of cubes. This equation will work for all stacks except for one with `v = 0`. This is because if we do this equation with `v = 0`, we get the output of `2`. After all, the code thinks that there is a top and a bottom, but we know that there is no top and no bottom on a stack of size `0`.\\n\\nNow that we have got the total surface area, we have to subtract the overlapping part. Now you might be asking, what overlap? Just look at the following image:\\n\\n![image](https://assets.leetcode.com/users/images/c772a231-ca77-44d4-ac1b-d0a0d177691f_1617905680.2426846.jpeg)\\n\\n\\n> First, we can get the input of a stack of `4` and then a pile of `2` back to back, so we have to subtract the stack size `2`\\'s one side from the stack of size `2` and the pile of size `4`. So basically, we are subtracting `2 * minimum(grid before, current grid)`.\\n\\n**The Code:**\\n\\n``` go\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc surfaceArea(grid [][]int) int {\\n    // 2 + shape * 4 == area of each shape\\n    res := 0\\n\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[0]); j++ {\\n            if grid[i][j] != 0 {\\n                res += 2 + grid[i][j]*4\\n            }\\n            if i-1 >= 0 {\\n                res -= 2 * min(grid[i-1][j], grid[i][j])\\n            }\\n            if j-1 >= 0 {\\n                res -= 2 * min(grid[i][j-1], grid[i][j])\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc surfaceArea(grid [][]int) int {\\n    // 2 + shape * 4 == area of each shape\\n    res := 0\\n\\n    for i := 0; i < len(grid); i++ {\\n        for j := 0; j < len(grid[0]); j++ {\\n            if grid[i][j] != 0 {\\n                res += 2 + grid[i][j]*4\\n            }\\n            if i-1 >= 0 {\\n                res -= 2 * min(grid[i-1][j], grid[i][j])\\n            }\\n            if j-1 >= 0 {\\n                res -= 2 * min(grid[i][j-1], grid[i][j])\\n            }\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1132639,
                "title": "simple-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int res = 0;\\n        int dr[] = {-1, 1, 0, 0};\\n        int dc[] = {0, 0, -1, 1};\\n        for(int i = 0;i<n;i++){\\n            for(int j= 0;j<m;j++){\\n                if(grid[i][j])  res += 2;\\n                int rr, cc;\\n                for(int k = 0;k<4;k++){\\n                    rr = dr[k] + i;\\n                    cc = dc[k] + j;\\n                    if(rr < 0 || cc < 0 || rr > n - 1 || cc > m - 1){\\n                        res += grid[i][j];\\n                    }\\n                    else{\\n                        res += max(grid[i][j] - grid[rr][cc], 0);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int res = 0;\\n        int dr[] = {-1, 1, 0, 0};\\n        int dc[] = {0, 0, -1, 1};\\n        for(int i = 0;i<n;i++){\\n            for(int j= 0;j<m;j++){\\n                if(grid[i][j])  res += 2;\\n                int rr, cc;\\n                for(int k = 0;k<4;k++){\\n                    rr = dr[k] + i;\\n                    cc = dc[k] + j;\\n                    if(rr < 0 || cc < 0 || rr > n - 1 || cc > m - 1){\\n                        res += grid[i][j];\\n                    }\\n                    else{\\n                        res += max(grid[i][j] - grid[rr][cc], 0);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057419,
                "title": "c-fast-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int cube = 0, sf = 0;\\n        for(int i = 0; i < grid.size(); ++i) {\\n            for(int j = 0; j < grid[0].size(); ++j) {\\n                if(grid[i][j]==0) {\\n                    continue;\\n                }\\n                cube += grid[i][j];\\n                sf += grid[i][j] - 1;\\n                if(j + 1 < grid[0].size()) {\\n                    sf += min(grid[i][j], grid[i][j + 1]);\\n                }\\n                if(i + 1 < grid.size()) {\\n                    sf += min(grid[i][j], grid[i + 1][j]);\\n                }\\n            }\\n        }\\n        return cube * 6 - sf * 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int cube = 0, sf = 0;\\n        for(int i = 0; i < grid.size(); ++i) {\\n            for(int j = 0; j < grid[0].size(); ++j) {\\n                if(grid[i][j]==0) {\\n                    continue;\\n                }\\n                cube += grid[i][j];\\n                sf += grid[i][j] - 1;\\n                if(j + 1 < grid[0].size()) {\\n                    sf += min(grid[i][j], grid[i][j + 1]);\\n                }\\n                if(i + 1 < grid.size()) {\\n                    sf += min(grid[i][j], grid[i + 1][j]);\\n                }\\n            }\\n        }\\n        return cube * 6 - sf * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004163,
                "title": "python-count-sides",
                "content": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\n        col, row=len(grid[0]), len(grid[0])\\n        out=sum([sum(row) for row in grid])*4  # count all unique cubes then *4\\n        out+= 2*sum([sum([i!=0 for i in row]) for row in grid]) # every non-zero cube, add up and down (2 sides)\\n        \\n        minus=0 # count the neighboring sides and minus them\\n        if col>1:\\n            for i in range(col-1):\\n                for j in range(row-1):\\n                    minus += min(grid[j][i], grid[j][i+1]) + min(grid[j][i], grid[j+1][i]) # neirghboring horizontally and neighboring verticalling\\n        minus+= sum([min(grid[row-1][i], grid[row-1][i+1]) for i in range(col-1)])\\n        minus+= sum([min(grid[i][col-1], grid[i+1][col-1]) for i in range(row-1)])   \\n        \\n        out -= 2*minus\\n        return out\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\n        col, row=len(grid[0]), len(grid[0])\\n        out=sum([sum(row) for row in grid])*4  # count all unique cubes then *4\\n        out+= 2*sum([sum([i!=0 for i in row]) for row in grid]) # every non-zero cube, add up and down (2 sides)\\n        \\n        minus=0 # count the neighboring sides and minus them\\n        if col>1:\\n            for i in range(col-1):\\n                for j in range(row-1):\\n                    minus += min(grid[j][i], grid[j][i+1]) + min(grid[j][i], grid[j+1][i]) # neirghboring horizontally and neighboring verticalling\\n        minus+= sum([min(grid[row-1][i], grid[row-1][i+1]) for i in range(col-1)])\\n        minus+= sum([min(grid[i][col-1], grid[i+1][col-1]) for i in range(row-1)])   \\n        \\n        out -= 2*minus\\n        return out\\n",
                "codeTag": "Java"
            },
            {
                "id": 979856,
                "title": "python-count-and-reduce-adjacent",
                "content": "```\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                v = grid[i][j]\\n                if v:\\n                    res += 2 #top/bottom\\n                    res += v * 4 # side\\n                    \\n                    # i neighbor\\n                    if i and grid[i-1][j]:\\n                        p = grid[i-1][j]\\n                        res -= 2 * min(p, v) #side\\n                    \\n                    # j neighbor\\n                    if j and grid[i][j-1]:\\n                        p = grid[i][j-1]\\n                        res -= 2 * min(p, v)\\n        \\n        return res\\n                \\n```",
                "solutionTags": [],
                "code": "```\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        \\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                v = grid[i][j]\\n                if v:\\n                    res += 2 #top/bottom\\n                    res += v * 4 # side\\n                    \\n                    # i neighbor\\n                    if i and grid[i-1][j]:\\n                        p = grid[i-1][j]\\n                        res -= 2 * min(p, v) #side\\n                    \\n                    # j neighbor\\n                    if j and grid[i][j-1]:\\n                        p = grid[i][j-1]\\n                        res -= 2 * min(p, v)\\n        \\n        return res\\n                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 932367,
                "title": "python-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:        \\n        m, n = len(grid), len(grid[0])\\n        \\n        area = 0\\n        for r in range(m):               \\n            for c in range(n):\\n                if grid[r][c] != 0:\\n                    area += 2\\n                \\n                if r == 0 or r == m - 1:\\n                    area += grid[r][c] if m != 1 else 2*grid[r][c]\\n                if r != m - 1:                    \\n                    area += abs(grid[r][c] - grid[r+1][c])\\n                    \\n                if c == 0 or c == n - 1:\\n                    area += grid[r][c] if n != 1 else 2*grid[r][c]\\n                if c != n - 1:                    \\n                    area += abs(grid[r][c] - grid[r][c+1])                    \\n                \\n        return area\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:        \\n        m, n = len(grid), len(grid[0])\\n        \\n        area = 0\\n        for r in range(m):               \\n            for c in range(n):\\n                if grid[r][c] != 0:\\n                    area += 2\\n                \\n                if r == 0 or r == m - 1:\\n                    area += grid[r][c] if m != 1 else 2*grid[r][c]\\n                if r != m - 1:                    \\n                    area += abs(grid[r][c] - grid[r+1][c])\\n                    \\n                if c == 0 or c == n - 1:\\n                    area += grid[r][c] if n != 1 else 2*grid[r][c]\\n                if c != n - 1:                    \\n                    area += abs(grid[r][c] - grid[r][c+1])                    \\n                \\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854946,
                "title": "c-python-solutions",
                "content": "C++ solution,\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int res = 0;\\n\\n        for (int i = 0; i < grid.size(); ++i)\\n            for (int j = 0; j < grid[0].size(); ++j) {\\n                if (grid[i][j])\\n                    res += 4*grid[i][j] + 2;\\n\\n                if (j) {\\n                    res -= min(grid[i][j],grid[i][j-1])*2;\\n                    res -= min(grid[j][i],grid[j-1][i])*2;\\n                }\\n            }\\n\\n        return res;\\n    }\\n};\\n```\\n\\nPython solution,\\n```\\nclass Solution:\\n    def surfaceArea(self, grid):\\n        res = 0\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    res += 4*grid[i][j] + 2\\n\\n                if j:\\n                    res -= min(grid[i][j],grid[i][j-1])*2\\n                    res -= min(grid[j][i],grid[j-1][i])*2\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int res = 0;\\n\\n        for (int i = 0; i < grid.size(); ++i)\\n            for (int j = 0; j < grid[0].size(); ++j) {\\n                if (grid[i][j])\\n                    res += 4*grid[i][j] + 2;\\n\\n                if (j) {\\n                    res -= min(grid[i][j],grid[i][j-1])*2;\\n                    res -= min(grid[j][i],grid[j-1][i])*2;\\n                }\\n            }\\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def surfaceArea(self, grid):\\n        res = 0\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    res += 4*grid[i][j] + 2\\n\\n                if j:\\n                    res -= min(grid[i][j],grid[i][j-1])*2\\n                    res -= min(grid[j][i],grid[j-1][i])*2\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844286,
                "title": "easy-c-solution-98-fast",
                "content": "// loop 1 formula \\n// 6 * num of stacked cubes - the top/bottom surface areas that \"disappear\" - the side surface areas that \"disappear\"\\n// 6 * grid[i][j] - 2 * min(grid[i][j], grid[i][j + 1])  - 2 * (grid[i][j] - 1)   \\n\\n// loop 2 formula (need to account for the other \"disappeared\" sides between columns in the grid)\\n// 2 * the side surface areas that \"disappear\" between 2 rows (the trailing row and the current row)\\n// 2 * min(grid[i-1][j], grid[i][j])\\n\\n    int surfaceArea(vector<vector<int>>& grid) {\\n       int sum = 0;\\n        \\n        for (int i = 0; i < grid.size(); ++i)\\n        {\\n            for(int j = 0; j < grid[i].size(); ++j)\\n            {\\n                sum += 6 * grid[i][j] - 2 * min(grid[i][j], j + 1 >= grid[i].size() ? 0 : grid[i][j+1]) - max(0, 2 * (grid[i][j] - 1));\\n            }\\n        }\\n        \\n        for(int i = 1; i < grid.size(); ++i)\\n        {\\n            for(int j = 0; j < grid[i].size(); ++j)\\n            {\\n                sum -= 2 * min(grid[i - 1][j], grid[i][j]);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "// loop 1 formula \\n// 6 * num of stacked cubes - the top/bottom surface areas that \"disappear\" - the side surface areas that \"disappear\"\\n// 6 * grid[i][j] - 2 * min(grid[i][j], grid[i][j + 1])  - 2 * (grid[i][j] - 1)   \\n\\n// loop 2 formula (need to account for the other \"disappeared\" sides between columns in the grid)\\n// 2 * the side surface areas that \"disappear\" between 2 rows (the trailing row and the current row)\\n// 2 * min(grid[i-1][j], grid[i][j])\\n\\n    int surfaceArea(vector<vector<int>>& grid) {\\n       int sum = 0;\\n        \\n        for (int i = 0; i < grid.size(); ++i)\\n        {\\n            for(int j = 0; j < grid[i].size(); ++j)\\n            {\\n                sum += 6 * grid[i][j] - 2 * min(grid[i][j], j + 1 >= grid[i].size() ? 0 : grid[i][j+1]) - max(0, 2 * (grid[i][j] - 1));\\n            }\\n        }\\n        \\n        for(int i = 1; i < grid.size(); ++i)\\n        {\\n            for(int j = 0; j < grid[i].size(); ++j)\\n            {\\n                sum -= 2 * min(grid[i - 1][j], grid[i][j]);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 801139,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\n        l, w, t = len(grid), len(grid[0]), 0\\n        for i in range(l):\\n            for j in range(w):\\n                x = grid[i][j]\\n                if x: t += 2\\n                if i == 0: t += x\\n                t += x if i == l-1 else abs(x - grid[i+1][j])\\n                if j == 0: t += x\\n                t += x if j == w-1 else abs(x - grid[i][j+1])\\n        return t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\n        l, w, t = len(grid), len(grid[0]), 0\\n        for i in range(l):\\n            for j in range(w):\\n                x = grid[i][j]\\n                if x: t += 2\\n                if i == 0: t += x\\n                t += x if i == l-1 else abs(x - grid[i+1][j])\\n                if j == 0: t += x\\n                t += x if j == w-1 else abs(x - grid[i][j+1])\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796550,
                "title": "simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]!=0)\\n                    ans=ans+grid[i][j]*4+2;\\n                if(i!=0)\\n                {\\n                    int x=min(grid[i][j],grid[i-1][j]);\\n                    x*=2;\\n                    ans-=x;\\n                }\\n                if(j!=0)\\n                {\\n                    int y=min(grid[i][j],grid[i][j-1]);\\n                    y*=2;\\n                    ans-=y;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]!=0)\\n                    ans=ans+grid[i][j]*4+2;\\n                if(i!=0)\\n                {\\n                    int x=min(grid[i][j],grid[i-1][j]);\\n                    x*=2;\\n                    ans-=x;\\n                }\\n                if(j!=0)\\n                {\\n                    int y=min(grid[i][j],grid[i][j-1]);\\n                    y*=2;\\n                    ans-=y;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595503,
                "title": "vague-description-why-the-expected-values-are-different",
                "content": "As far as I have understood this question based on the given description the output for [4,2] and [2,4] must be same... But here it is giving:\\n```\\nOutput of [4,2] -> 18\\nwhile, Output of [2,4] -> 10\\n```\\nAccording to me the output for both should be 24 ..\\nCan anyone throw some light on it ?",
                "solutionTags": [],
                "code": "```\\nOutput of [4,2] -> 18\\nwhile, Output of [2,4] -> 10\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 562201,
                "title": "python-3-elegant-one-liner",
                "content": "# Explanation\\n\\nCount up all the 1x1 squares on each axis:\\n1. For above and below (z-axis), add 2 for every item in the grid that is not equal to 0 (1 for above, 1 for below)\\n2. For left and right (x-axis), for each row, add the leftmost and the rightmost, and the absolute value difference of each adjascent pair\\n3. For top to bottom (y-axis), same as x-axis, but for columns instead of rows\\n\\nWhy adjascent pairs? Let\\'s look at a single row for an example:\\n```\\n[3,1,5,2]\\n```\\nLet\\'s draw it out:\\n```\\n      *\\n      *\\n  *   *\\n  *   * *\\n  * * * *\\n-----------\\n0 3 1 5 2 0\\n```\\nThe left-to-right and right-to-left surface area is:\\n`|0-3| + |3-1| + |1-5| + |5-2| + |2-0| = 3 + 2 + 4 + 3 + 2 = 14`\\n\\nSo iterate on every row and then every column (by doing `(*grid,*zip(*grid))`) and add up the following:\\n1. `sum(map(bool,row))`: count of values that are non-zero ... this gets doubled because we\\'re doing 2 passes\\n2. `sum(abs(a-b) for a,b in zip((0,*row),(*row,0)))`: sum of the absolute differences of each adjascent pair, including (0, leftmost) and (rightmost, 0)\\n\\n# Code\\n\\n```python\\nclass Solution:\\n  def surfaceArea(self, grid: List[List[int]]) -> int:\\n    return sum(sum(map(bool,row)) + sum(abs(a-b) for a,b in zip((0,*row),(*row,0))) for row in (*grid,*zip(*grid)))\\n```\\n\\nFuck, that\\'s elegant.",
                "solutionTags": [],
                "code": "```\\n[3,1,5,2]\\n```\n```\\n      *\\n      *\\n  *   *\\n  *   * *\\n  * * * *\\n-----------\\n0 3 1 5 2 0\\n```\n```python\\nclass Solution:\\n  def surfaceArea(self, grid: List[List[int]]) -> int:\\n    return sum(sum(map(bool,row)) + sum(abs(a-b) for a,b in zip((0,*row),(*row,0))) for row in (*grid,*zip(*grid)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529417,
                "title": "python3-80ms-96-100-o-n-2",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef surfaceArea(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\ttemp = float(\\'inf\\')\\n\\t\\t\\tfor i,r in enumerate(grid):\\n\\t\\t\\t\\tif i > 0:\\n\\t\\t\\t\\t\\tres -= self.TwoRow(grid[i-1], grid[i])\\n\\t\\t\\t\\tfor j,num in enumerate(r):\\n\\t\\t\\t\\t\\tif num != 0:\\n\\t\\t\\t\\t\\t\\tres += (num*4)+2\\n\\t\\t\\t\\t\\tif j > 0:\\n\\t\\t\\t\\t\\t\\tres -= min(temp, num)*2\\n\\t\\t\\t\\t\\ttemp = num\\n\\t\\t\\treturn res\\n\\n\\t\\tdef TwoRow(self, x,y):\\n\\t\\t\\treturn sum(map(lambda a,b: min(a,b), x, y))*2\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef surfaceArea(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\ttemp = float(\\'inf\\')\\n\\t\\t\\tfor i,r in enumerate(grid):\\n\\t\\t\\t\\tif i > 0:\\n\\t\\t\\t\\t\\tres -= self.TwoRow(grid[i-1], grid[i])\\n\\t\\t\\t\\tfor j,num in enumerate(r):\\n\\t\\t\\t\\t\\tif num != 0:\\n\\t\\t\\t\\t\\t\\tres += (num*4)+2\\n\\t\\t\\t\\t\\tif j > 0:\\n\\t\\t\\t\\t\\t\\tres -= min(temp, num)*2\\n\\t\\t\\t\\t\\ttemp = num\\n\\t\\t\\treturn res\\n\\n\\t\\tdef TwoRow(self, x,y):\\n\\t\\t\\treturn sum(map(lambda a,b: min(a,b), x, y))*2\\n\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 508263,
                "title": "python3-faster-than-90-64-less-than-100-00-a-little-wordy-but-easy-to-understand",
                "content": "The idea here is to focus on each kind of surface individually.  There are 6 kinds:\\n\\n1. bottom\\n2. top\\n3. corner\\n4. edge\\n5. row-top-edge\\n6. column-top-edge\\n\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        r = []\\n        N = len(grid)\\n        bottom = 0\\n        top = 0\\n        corner = 0\\n        edge = 0\\n        redge = 0\\n        cedge = 0\\n\\n        for i in range(len(grid)):\\n            \\n            for j in range(len(grid[i])):\\n                if grid[i][j] > 0:\\n                    bottom += 1\\n\\n                if i == 0 or i == N - 1:\\n                    if j == 0 or j == N - 1:\\n                        corner += grid[i][j]*2\\n                    else:\\n                        edge += grid[i][j]\\n            \\n                if j == 0 or j == N - 1:\\n                    if i > 0 and i < N -1:\\n                        edge += grid[i][j]\\n\\n                if j > 0 and j < N:\\n                    redge += abs(grid[i][j] - grid[i][j-1])\\n                if i > 0 and i < N:\\n                    cedge += abs(grid[i][j] - grid[i-1][j])\\n    \\n        #--corner case:\\n        if N == 1:\\n            corner *= 2\\n\\n        top = bottom\\n        r = [bottom, top, corner, edge, redge, cedge]\\n    \\n        return sum(r)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        r = []\\n        N = len(grid)\\n        bottom = 0\\n        top = 0\\n        corner = 0\\n        edge = 0\\n        redge = 0\\n        cedge = 0\\n\\n        for i in range(len(grid)):\\n            \\n            for j in range(len(grid[i])):\\n                if grid[i][j] > 0:\\n                    bottom += 1\\n\\n                if i == 0 or i == N - 1:\\n                    if j == 0 or j == N - 1:\\n                        corner += grid[i][j]*2\\n                    else:\\n                        edge += grid[i][j]\\n            \\n                if j == 0 or j == N - 1:\\n                    if i > 0 and i < N -1:\\n                        edge += grid[i][j]\\n\\n                if j > 0 and j < N:\\n                    redge += abs(grid[i][j] - grid[i][j-1])\\n                if i > 0 and i < N:\\n                    cedge += abs(grid[i][j] - grid[i-1][j])\\n    \\n        #--corner case:\\n        if N == 1:\\n            corner *= 2\\n\\n        top = bottom\\n        r = [bottom, top, corner, edge, redge, cedge]\\n    \\n        return sum(r)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396144,
                "title": "python-3-solution-beats-98-87",
                "content": "Algo: \\n1) xy projection - twice of number of non-zero entries \\n2) yz projection - sum of absolute difference of continuous elements in a row \\n3) zx projection - sum of absolute difference of continuous elements in a column\\n\\nDefine a (lambda) function which computes sum of absolute difference of adjacent element in a list, and apply it to rows and columns of matrix. \\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\n        func = lambda v: v[0] + sum(abs(v[i]-v[i-1]) for i in range(1, len(v))) + v[-1]\\n        \\n        xy = sum(map(bool, sum(grid, []))) * 2\\n        yz = sum(func(row) for row in grid)\\n        zx = sum(func(col) for col in zip(*grid))\\n        \\n        return xy + yz + zx \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\n        func = lambda v: v[0] + sum(abs(v[i]-v[i-1]) for i in range(1, len(v))) + v[-1]\\n        \\n        xy = sum(map(bool, sum(grid, []))) * 2\\n        yz = sum(func(row) for row in grid)\\n        zx = sum(func(col) for col in zip(*grid))\\n        \\n        return xy + yz + zx \\n```",
                "codeTag": "Java"
            },
            {
                "id": 342903,
                "title": "java-foolproof-16-lines-solution-with-simple-explanation",
                "content": "Every tower with height greater than 1 will contribute 6 faces for the first cube; every cube after the first will add 4 more faces because there is one face that touches every two adjacent cubes that will not contribute to surface area.\\nEvery tower that borders with adjacent towers in each direction, up, down left, right, will have Math.min(tower_height, adjacent_tower_height) faces hidden, thus not contribute to surface area; this will be accounted for by subtracting Math.min(tower_height, adjacent_tower_height) from surface area twice, once for tower, once for adjacent_tower, in their respective loop iterations. \\nIf this explanation makes more sense to you please leave a thumbs up ; )\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int h = grid[i][j];\\n                if(h>=1) {\\n                    area += (h - 1) * 4 + 6;\\n                    if(i-1>=0 && grid[i-1][j]!=0) area -= Math.min(h, grid[i-1][j]);\\n                    if(i+1<grid.length && grid[i+1][j]!=0) area -= Math.min(h, grid[i+1][j]);\\n                    if(j-1>=0 && grid[i][j-1]!=0) area -= Math.min(h, grid[i][j-1]);\\n                    if(j+1<grid[0].length && grid[i][j+1]!=0) area -= Math.min(h, grid[i][j+1]);\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int h = grid[i][j];\\n                if(h>=1) {\\n                    area += (h - 1) * 4 + 6;\\n                    if(i-1>=0 && grid[i-1][j]!=0) area -= Math.min(h, grid[i-1][j]);\\n                    if(i+1<grid.length && grid[i+1][j]!=0) area -= Math.min(h, grid[i+1][j]);\\n                    if(j-1>=0 && grid[i][j-1]!=0) area -= Math.min(h, grid[i][j-1]);\\n                    if(j+1<grid[0].length && grid[i][j+1]!=0) area -= Math.min(h, grid[i][j+1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 283674,
                "title": "java-explainable-solution",
                "content": "cubes counts cubes in the case;\\nupdown counts the number of surfaces needed to be excluded for vertically placed cubes; each two cubes should merge two surfaces;\\nneighbors counts the number of surfaces need to be excluded for horizontally placed cubes;\\n```\\n\\tpublic int surfaceArea(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n\\n        int cubes = 0, neighbors = 0, updown = 0;\\n        for(int i = 0; i < grid.length; i ++) {\\n            for(int j = 0; j < grid[0].length; j ++) {\\n                if(grid[i][j] > 0){\\n                    cubes += grid[i][j];\\n                    updown += Math.max(grid[i][j] - 1, 0);\\n                }\\n                if(i < grid.length - 1) {\\n                    neighbors += Math.min(grid[i + 1][j], grid[i][j]);\\n                }\\n                if(j < grid[0].length - 1) {\\n                    neighbors += Math.min(grid[i][j + 1], grid[i][j]);\\n                }\\n            }\\n        }\\n        return cubes * 6 - neighbors * 2 - updown * 2;\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "cubes counts cubes in the case;\\nupdown counts the number of surfaces needed to be excluded for vertically placed cubes; each two cubes should merge two surfaces;\\nneighbors counts the number of surfaces need to be excluded for horizontally placed cubes;\\n```\\n\\tpublic int surfaceArea(int[][] grid) {\\n        if(grid == null || grid.length == 0) return 0;\\n\\n        int cubes = 0, neighbors = 0, updown = 0;\\n        for(int i = 0; i < grid.length; i ++) {\\n            for(int j = 0; j < grid[0].length; j ++) {\\n                if(grid[i][j] > 0){\\n                    cubes += grid[i][j];\\n                    updown += Math.max(grid[i][j] - 1, 0);\\n                }\\n                if(i < grid.length - 1) {\\n                    neighbors += Math.min(grid[i + 1][j], grid[i][j]);\\n                }\\n                if(j < grid[0].length - 1) {\\n                    neighbors += Math.min(grid[i][j + 1], grid[i][j]);\\n                }\\n            }\\n        }\\n        return cubes * 6 - neighbors * 2 - updown * 2;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 243376,
                "title": "java-easy-to-understand-with-explaination-faster-than-99",
                "content": "If only 1 cube is present at 1 index, surface area =6\\nif 2 cubes are present, surface area = 12-2(overlapping area) = 10\\nIf 3 cubes are present, surface area = 18-4(overlapping area) = 14\\n\\nHence if n cubes are present, surface area=  4n+2  ... derived by looking at the above values.\\n\\nNow we have to remove common area of adjacent blocks.\\n\\nHence, if a block of height 2 has block of height 1 adjacent to it, we subtract 1 from count. (ie minimum of the heights of these two  ie 1 in this case)\\nSimilarly when we come across the same block of height 1 again in loop, it will have height 2 block adjacent to it. Again minimum will be subtracted(ie 1 in this case).\\n\\nHence overall, the 2 common areas are removed.\\nSimilar is applied to all blocks and their adjacents in all 4 directions. For the boundary blocks, it is applied whereever applicable.\\n\\n```\\npublic int surfaceArea(int[][] grid)\\n    {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                    count=count+ (grid[i][j]*4 +2);\\n                if(i<grid.length-1 && i>=0)\\n                    count= count - Math.min(grid[i+1][j],grid[i][j]);\\n                if(j<grid[i].length-1 && j>=0)\\n                    count = count - Math.min(grid[i][j], grid[i][j+1]);\\n                if(i>0)\\n                    count = count - Math.min(grid[i][j],grid[i-1][j]);\\n                if(j>0)\\n                    count = count - Math.min(grid[i][j],grid[i][j-1]);\\n                \\n                    \\n            }\\n        }\\n        return count;\\n        \\n    }",
                "solutionTags": [],
                "code": "If only 1 cube is present at 1 index, surface area =6\\nif 2 cubes are present, surface area = 12-2(overlapping area) = 10\\nIf 3 cubes are present, surface area = 18-4(overlapping area) = 14\\n\\nHence if n cubes are present, surface area=  4n+2  ... derived by looking at the above values.\\n\\nNow we have to remove common area of adjacent blocks.\\n\\nHence, if a block of height 2 has block of height 1 adjacent to it, we subtract 1 from count. (ie minimum of the heights of these two  ie 1 in this case)\\nSimilarly when we come across the same block of height 1 again in loop, it will have height 2 block adjacent to it. Again minimum will be subtracted(ie 1 in this case).\\n\\nHence overall, the 2 common areas are removed.\\nSimilar is applied to all blocks and their adjacents in all 4 directions. For the boundary blocks, it is applied whereever applicable.\\n\\n```\\npublic int surfaceArea(int[][] grid)\\n    {\\n        int count=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                    count=count+ (grid[i][j]*4 +2);\\n                if(i<grid.length-1 && i>=0)\\n                    count= count - Math.min(grid[i+1][j],grid[i][j]);\\n                if(j<grid[i].length-1 && j>=0)\\n                    count = count - Math.min(grid[i][j], grid[i][j+1]);\\n                if(i>0)\\n                    count = count - Math.min(grid[i][j],grid[i-1][j]);\\n                if(j>0)\\n                    count = count - Math.min(grid[i][j],grid[i][j-1]);\\n                \\n                    \\n            }\\n        }\\n        return count;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 236912,
                "title": "rust-0ms-2-7mb",
                "content": "```\\nimpl Solution {\\n    pub fn surface_area(grid: Vec<Vec<i32>>) -> i32 {\\n        let rows = grid.len();\\n        let cols = grid[0].len();\\n        let mut surfaces = 0;\\n        for (i, row) in grid.iter().enumerate() {\\n            for (j, h) in row.iter().enumerate() {\\n                let h = *h;\\n                // bottom and top\\n                if h > 0 {\\n                    surfaces += 2;\\n                }\\n\\n                // up and down\\n                if i == 0 {\\n                    surfaces += h;\\n                } else if grid[i - 1][j] < h {\\n                    surfaces += h - grid[i - 1][j];\\n                }\\n                if i == rows - 1 {\\n                    surfaces += h;\\n                } else if grid[i + 1][j] < h {\\n                    surfaces += h - grid[i + 1][j];\\n                }\\n\\n                // left and right\\n                if j == 0 {\\n                    surfaces += h;\\n                } else if grid[i][j - 1] < h {\\n                    surfaces += h - grid[i][j - 1];\\n                }\\n                if j == cols - 1 {\\n                    surfaces += h;\\n                } else if grid[i][j + 1] < h {\\n                    surfaces += h - grid[i][j + 1];\\n                }\\n            }\\n        }\\n        surfaces\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn surface_area(grid: Vec<Vec<i32>>) -> i32 {\\n        let rows = grid.len();\\n        let cols = grid[0].len();\\n        let mut surfaces = 0;\\n        for (i, row) in grid.iter().enumerate() {\\n            for (j, h) in row.iter().enumerate() {\\n                let h = *h;\\n                // bottom and top\\n                if h > 0 {\\n                    surfaces += 2;\\n                }\\n\\n                // up and down\\n                if i == 0 {\\n                    surfaces += h;\\n                } else if grid[i - 1][j] < h {\\n                    surfaces += h - grid[i - 1][j];\\n                }\\n                if i == rows - 1 {\\n                    surfaces += h;\\n                } else if grid[i + 1][j] < h {\\n                    surfaces += h - grid[i + 1][j];\\n                }\\n\\n                // left and right\\n                if j == 0 {\\n                    surfaces += h;\\n                } else if grid[i][j - 1] < h {\\n                    surfaces += h - grid[i][j - 1];\\n                }\\n                if j == cols - 1 {\\n                    surfaces += h;\\n                } else if grid[i][j + 1] < h {\\n                    surfaces += h - grid[i][j + 1];\\n                }\\n            }\\n        }\\n        surfaces\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227805,
                "title": "js-one-pass-solution-o-1-space-complexity-solution",
                "content": "```\\nconst surfaceArea = grid => {\\n    let total = 0, n = grid.length;\\n    \\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let v = grid[i][j];\\n            let area = v === 0 ? 0 : 2;\\n            \\n            if (i === 0) { area += v; }\\n            else { area += Math.max(0, v - grid[i - 1][j]); }\\n            \\n            if (j === 0) { area += v; }\\n            else { area += Math.max(0, v - grid[i][j - 1]); }\\n            \\n            if (i + 1 === n) { area += v; }\\n            else { area += Math.max(0, v - grid[i + 1][j]); }\\n            \\n            if (j + 1 === n) { area += v; }\\n            else { area += Math.max(0, v - grid[i][j + 1]); }\\n            \\n            total += area;\\n        }\\n    }\\n    \\n    return total;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst surfaceArea = grid => {\\n    let total = 0, n = grid.length;\\n    \\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let v = grid[i][j];\\n            let area = v === 0 ? 0 : 2;\\n            \\n            if (i === 0) { area += v; }\\n            else { area += Math.max(0, v - grid[i - 1][j]); }\\n            \\n            if (j === 0) { area += v; }\\n            else { area += Math.max(0, v - grid[i][j - 1]); }\\n            \\n            if (i + 1 === n) { area += v; }\\n            else { area += Math.max(0, v - grid[i + 1][j]); }\\n            \\n            if (j + 1 === n) { area += v; }\\n            else { area += Math.max(0, v - grid[i][j + 1]); }\\n            \\n            total += area;\\n        }\\n    }\\n    \\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201334,
                "title": "java-concise-solution-with-explanation",
                "content": "The trick is we always compute the net difference between current stack with stack in next row and next col if possible, never recompute previous stacks.\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int res = 0;\\n        for (int i = 0;i < grid.length;i++)\\n            for (int j = 0;j < grid[0].length;j++)\\n            {\\n\\t\\t\\t\\t//if there is a non zero stack, add top and bottom area\\n                if (grid[i][j] != 0)\\n                    res += 2;\\n\\t\\t\\t\\t//compute upmost stacks\\n                if (i == 0)\\n                    res += grid[i][j];\\n\\t\\t\\t\\t//compute leftmost stacks\\n                if (j == 0)\\n                    res += grid[i][j];\\n\\t\\t\\t\\t//compute bottom stacks\\n                if (i == grid.length - 1)\\n                    res += grid[i][j];\\n\\t\\t\\t\\t//compute rightmost stacks\\n                if (j == grid[0].length - 1)\\n                    res += grid[i][j];\\n\\t\\t\\t\\t//compute stack in next row if possible\\n                if (i < grid.length - 1)\\n                    res += Math.abs(grid[i][j] - grid[i + 1][j]);\\n\\t\\t\\t\\t//compute stack in next column if possible\\n                if (j < grid[0].length - 1)\\n                    res += Math.abs(grid[i][j] - grid[i][j + 1]);\\n            }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int res = 0;\\n        for (int i = 0;i < grid.length;i++)\\n            for (int j = 0;j < grid[0].length;j++)\\n            {\\n\\t\\t\\t\\t//if there is a non zero stack, add top and bottom area\\n                if (grid[i][j] != 0)\\n                    res += 2;\\n\\t\\t\\t\\t//compute upmost stacks\\n                if (i == 0)\\n                    res += grid[i][j];\\n\\t\\t\\t\\t//compute leftmost stacks\\n                if (j == 0)\\n                    res += grid[i][j];\\n\\t\\t\\t\\t//compute bottom stacks\\n                if (i == grid.length - 1)\\n                    res += grid[i][j];\\n\\t\\t\\t\\t//compute rightmost stacks\\n                if (j == grid[0].length - 1)\\n                    res += grid[i][j];\\n\\t\\t\\t\\t//compute stack in next row if possible\\n                if (i < grid.length - 1)\\n                    res += Math.abs(grid[i][j] - grid[i + 1][j]);\\n\\t\\t\\t\\t//compute stack in next column if possible\\n                if (j < grid[0].length - 1)\\n                    res += Math.abs(grid[i][j] - grid[i][j + 1]);\\n            }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192943,
                "title": "c-solution-easy-understand",
                "content": "All areas = surface + combined area\\nso we have surface = 6 * total_count - 2 * combined_count\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int total{0}, combined{0}, len{grid.size()};\\n        for(int i = 0; i< len; i++)\\n            for(int j = 0; j< len; j++)\\n                if(grid[i][j]){\\n                    total += grid[i][j];\\n                    combined += grid[i][j] - 1;\\n                    if(i > 0) combined += min(grid[i-1][j],grid[i][j]);\\n                    if(j > 0) combined += min(grid[i][j-1],grid[i][j]);\\n                }\\n        return 6*total - 2*combined;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int total{0}, combined{0}, len{grid.size()};\\n        for(int i = 0; i< len; i++)\\n            for(int j = 0; j< len; j++)\\n                if(grid[i][j]){\\n                    total += grid[i][j];\\n                    combined += grid[i][j] - 1;\\n                    if(i > 0) combined += min(grid[i-1][j],grid[i][j]);\\n                    if(j > 0) combined += min(grid[i][j-1],grid[i][j]);\\n                }\\n        return 6*total - 2*combined;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176716,
                "title": "javascript-level-traversal-easy-to-understand-56-60-ms",
                "content": "Not fastest solution (60ms), but all you need is to check neighbours left/right/up/down + (top or bottom) * 2.\\n```\\nvar surfaceArea = function(grid) {\\n    var count = 0;\\n    var lastIndex = grid.length - 1;\\n\\n    for (var i = 0; i <= lastIndex; i++) {\\n        for (var j = 0; j <= lastIndex; j++) {\\n            if (grid[i][j] <= 0) {\\n                continue;\\n            }\\n\\n            count += 2;\\n            \\n            for (var level = 0; level < grid[i][j]; level++) {\\n                if (i === 0 || grid[i - 1][j] <= level) {\\n                    count++;\\n                }\\n                if (i === lastIndex || grid[i + 1][j] <= level) {\\n                    count++;\\n                }\\n                if (j === 0 || grid[i][j - 1] <= level) {\\n                    count++;\\n                }\\n                if (j === lastIndex || grid[i][j + 1] <= level) {\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```\\n\\nOr we can make it 56 ms by removing level traversal logic:\\n```\\nvar surfaceArea = function(grid) {\\n    var count = 0;\\n    var lastIndex = grid.length - 1;\\n\\n    for (var i = 0; i <= lastIndex; i++) {\\n        for (var j = 0; j <= lastIndex; j++) {\\n            if (grid[i][j] === 0) {\\n                continue;\\n            }\\n\\n            count += 2;\\n            count += i === 0 ? grid[i][j] : Math.max(0, grid[i][j] - grid[i - 1][j]);\\n            count += i === lastIndex ? grid[i][j] : Math.max(0, grid[i][j] - grid[i + 1][j]);\\n            count += j === 0 ? grid[i][j] : Math.max(0, grid[i][j] - grid[i][j - 1]);\\n            count += j === lastIndex ? grid[i][j] : Math.max(0, grid[i][j] - grid[i][j + 1]);\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar surfaceArea = function(grid) {\\n    var count = 0;\\n    var lastIndex = grid.length - 1;\\n\\n    for (var i = 0; i <= lastIndex; i++) {\\n        for (var j = 0; j <= lastIndex; j++) {\\n            if (grid[i][j] <= 0) {\\n                continue;\\n            }\\n\\n            count += 2;\\n            \\n            for (var level = 0; level < grid[i][j]; level++) {\\n                if (i === 0 || grid[i - 1][j] <= level) {\\n                    count++;\\n                }\\n                if (i === lastIndex || grid[i + 1][j] <= level) {\\n                    count++;\\n                }\\n                if (j === 0 || grid[i][j - 1] <= level) {\\n                    count++;\\n                }\\n                if (j === lastIndex || grid[i][j + 1] <= level) {\\n                    count++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return count;\\n};\\n```\n```\\nvar surfaceArea = function(grid) {\\n    var count = 0;\\n    var lastIndex = grid.length - 1;\\n\\n    for (var i = 0; i <= lastIndex; i++) {\\n        for (var j = 0; j <= lastIndex; j++) {\\n            if (grid[i][j] === 0) {\\n                continue;\\n            }\\n\\n            count += 2;\\n            count += i === 0 ? grid[i][j] : Math.max(0, grid[i][j] - grid[i - 1][j]);\\n            count += i === lastIndex ? grid[i][j] : Math.max(0, grid[i][j] - grid[i + 1][j]);\\n            count += j === 0 ? grid[i][j] : Math.max(0, grid[i][j] - grid[i][j - 1]);\\n            count += j === lastIndex ? grid[i][j] : Math.max(0, grid[i][j] - grid[i][j + 1]);\\n        }\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167967,
                "title": "java-2-solutions-comparison-with-2d-version-of-this-problem",
                "content": "**----------------------- Let\\'s first look at the `2D version` of this problem [463. Island Perimeter](https://leetcode.com/problems/island-perimeter/description/) -----------------------**\\n**Soution 1 brute force**\\n   * for `each cell with non zero value:` \\n   * for each `direction:` if the next cell is `out boundary` or is `0`, we add `1` to res\\n```\\nclass Solution {\\n    static final int[][] dirs = new int[][] {{0,-1}, {-1,0}, {0,1}, {1,0}};\\n    public int islandPerimeter(int[][] grid) { \\n        int perimeter = 0;\\n        for (int r = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[0].length; c++) {\\n                if (grid[r][c] == 1) {\\n                    for (int[] dir : dirs) {\\n                        int nr = r + dir[0], nc = c + dir[1];\\n                        if (offBoundary(nr, nc, grid) || grid[nr][nc] == 0) perimeter++;\\n                    }\\n                }\\n            }\\n        }\\n        return perimeter;\\n    }\\n    \\n    private boolean offBoundary(int r, int c, int[][] grid) {\\n        return r < 0 || r >= grid.length || c < 0 || c >= grid[0].length;\\n    }\\n}\\n```\\n\\n**Soution 2 accumulate and retract**\\n   * we traverse each cell row by row, col by col and `update the result dynamically`\\n   * for `each cell with non zero value`, let\\'s first `accumulate` it\\'s contribution to total perimeter: `res += 4`\\n   * if `up cell is non zero`, we do retraction: `res -= 2`\\n   * if `left cell is non zero`, we do retraction: `res -= 2`\\n   ![image](https://s3-lc-upload.s3.amazonaws.com/users/meganlee/image_1536383412.png)\\n\\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int res = 0;\\n        for (int r  = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[0].length; c++) {\\n                if (grid[r][c] == 1) {\\n                    res += 4;\\n                    if (r > 0 && grid[r - 1][c] == 1) res -= 2;\\n                    if (c > 0 && grid[r][c - 1] == 1) res -= 2;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\n**-------- Now let\\'s look at the this problem, which is exactly follow up as a `3D version` of [463. Island Perimeter](https://leetcode.com/problems/island-perimeter/description/) -----------------------**\\nsimilarly\\n**Soution 1 brute force**\\n   * for `each cell with non zero value:` res += `2 (1 for top, 1 for bottom)`\\n   * for each `direction/side:` we get a `nextHeight`, if `curHeight > nextHeight` we add exposed area: `curHeight - nextHeight` to res \\n```\\nclass Solution {\\n    static final int[][] dirs = new int[][] {{0,-1}, {-1,0}, {0,1}, {1,0}};\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        for (int r = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[0].length; c++) {\\n                if (grid[r][c] != 0) { // only consider NON-ZERO cubes\\n                    int curHeight = grid[r][c];\\n                    area += 2; // top & bottom\\n                    for (int[] dir : dirs) {\\n                        int nr = r + dir[0], nc = c + dir[1];\\n                        int nextHeight = getHeight(nr, nc, grid);\\n                        area += (curHeight > nextHeight) ? curHeight - nextHeight : 0; // side surface\\n                    }\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n     \\n    private int getHeight(int r, int c, int[][] grid) {\\n        if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return 0; // out of bounds\\n        else return grid[r][c];\\n    }\\n```\\n\\n**Soution 2 accumulate and retract**\\n   * we traverse each cell row by row, col by col and `update the result dynamically`\\n   * for `each cell with non zero value`, let\\'s first `accumulate` it\\'s contribution to total area: `res += 2 + 4 * side`\\n   * if `up cell is non zero`, we do retraction: `res -= 2 * min(upHeight, curHeight)`\\n   * if `left cell is non zero`, we do retraction: `res -= 2 * min(leftHeight, curHeight)`\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/meganlee/image_1536384442.png)\\n```\\nclass Solution {\\n    static final int[][] dirs = new int[][] {{0,-1}, {-1,0}, {0,1}, {1,0}};\\n    public int surfaceArea(int[][] grid) {\\n        int res = 0;\\n        for (int r = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[0].length; c++) {\\n                if (grid[r][c] != 0) {\\n                    res += 2 + 4 * grid[r][c];\\n                    if (r > 0 && grid[r - 1][c] != 0) res -= 2 * Math.min(grid[r][c], grid[r - 1][c]); // up\\n                    if (c > 0 && grid[r][c - 1] != 0) res -= 2 * Math.min(grid[r][c], grid[r][c - 1]); // left\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static final int[][] dirs = new int[][] {{0,-1}, {-1,0}, {0,1}, {1,0}};\\n    public int islandPerimeter(int[][] grid) { \\n        int perimeter = 0;\\n        for (int r = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[0].length; c++) {\\n                if (grid[r][c] == 1) {\\n                    for (int[] dir : dirs) {\\n                        int nr = r + dir[0], nc = c + dir[1];\\n                        if (offBoundary(nr, nc, grid) || grid[nr][nc] == 0) perimeter++;\\n                    }\\n                }\\n            }\\n        }\\n        return perimeter;\\n    }\\n    \\n    private boolean offBoundary(int r, int c, int[][] grid) {\\n        return r < 0 || r >= grid.length || c < 0 || c >= grid[0].length;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int islandPerimeter(int[][] grid) {\\n        int res = 0;\\n        for (int r  = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[0].length; c++) {\\n                if (grid[r][c] == 1) {\\n                    res += 4;\\n                    if (r > 0 && grid[r - 1][c] == 1) res -= 2;\\n                    if (c > 0 && grid[r][c - 1] == 1) res -= 2;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    static final int[][] dirs = new int[][] {{0,-1}, {-1,0}, {0,1}, {1,0}};\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        for (int r = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[0].length; c++) {\\n                if (grid[r][c] != 0) { // only consider NON-ZERO cubes\\n                    int curHeight = grid[r][c];\\n                    area += 2; // top & bottom\\n                    for (int[] dir : dirs) {\\n                        int nr = r + dir[0], nc = c + dir[1];\\n                        int nextHeight = getHeight(nr, nc, grid);\\n                        area += (curHeight > nextHeight) ? curHeight - nextHeight : 0; // side surface\\n                    }\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n     \\n    private int getHeight(int r, int c, int[][] grid) {\\n        if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length) return 0; // out of bounds\\n        else return grid[r][c];\\n    }\\n```\n```\\nclass Solution {\\n    static final int[][] dirs = new int[][] {{0,-1}, {-1,0}, {0,1}, {1,0}};\\n    public int surfaceArea(int[][] grid) {\\n        int res = 0;\\n        for (int r = 0; r < grid.length; r++) {\\n            for (int c = 0; c < grid[0].length; c++) {\\n                if (grid[r][c] != 0) {\\n                    res += 2 + 4 * grid[r][c];\\n                    if (r > 0 && grid[r - 1][c] != 0) res -= 2 * Math.min(grid[r][c], grid[r - 1][c]); // up\\n                    if (c > 0 && grid[r][c - 1] != 0) res -= 2 * Math.min(grid[r][c], grid[r][c - 1]); // left\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164042,
                "title": "incredibly-simple-python-solution",
                "content": "```\\nsum = 0;\\n        for x in range(len(grid)):\\n            for y in range(len(grid)):\\n                if(grid[x][y]):\\n                    sum = sum + 2 + (4*grid[x][y])\\n                if(x>0):\\n                    sum = sum - (grid[x-1][y] if grid[x][y]>=grid[x-1][y] else grid[x][y]);\\n                if(y>0):\\n                    sum = sum - (grid[x][y-1] if grid[x][y]>=grid[x][y-1] else grid[x][y]);\\n                if(y<len(grid)-1):\\n                    sum = sum - (grid[x][y+1] if grid[x][y]>=grid[x][y+1] else grid[x][y]);\\n                if(x<len(grid)-1):\\n                    sum = sum - (grid[x+1][y] if grid[x][y]>=grid[x+1][y] else grid[x][y]);\\n        return sum\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nsum = 0;\\n        for x in range(len(grid)):\\n            for y in range(len(grid)):\\n                if(grid[x][y]):\\n                    sum = sum + 2 + (4*grid[x][y])\\n                if(x>0):\\n                    sum = sum - (grid[x-1][y] if grid[x][y]>=grid[x-1][y] else grid[x][y]);\\n                if(y>0):\\n                    sum = sum - (grid[x][y-1] if grid[x][y]>=grid[x][y-1] else grid[x][y]);\\n                if(y<len(grid)-1):\\n                    sum = sum - (grid[x][y+1] if grid[x][y]>=grid[x][y+1] else grid[x][y]);\\n                if(x<len(grid)-1):\\n                    sum = sum - (grid[x+1][y] if grid[x][y]>=grid[x+1][y] else grid[x][y]);\\n        return sum\\n\\t\\t\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 163982,
                "title": "concise-java-solution",
                "content": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int row = grid.length, col = grid[0].length ;\\n        int top = 0, l=0;\\n        for(int i = 0; i < row ; ++i){\\n           for(int j = 0; j < col ; ++j) {\\n               l += i==0 ? grid[i][j] : (int)  Math.abs(grid[i][j] - grid[i-1][j]);\\n               if(i == row-1)l += grid[i][j];\\n               l += j==0 ? grid[i][j] : (int)  Math.abs(grid[i][j] - grid[i][j-1]);\\n               if(j == col-1)l += grid[i][j];\\n               top += grid[i][j] > 0 ? 1 : 0;\\n           }\\n        }\\n        return 2*(top)+l;\\n    }\\n}\\n```\\n\\nA bit more Concise\\n\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int r = grid.length, top = 0, l=0;\\n        for(int i = 0; i < r ; ++i)\\n           for(int j = 0; j < r ; ++j) {\\n               l += (i==0 ? grid[i][j] : (int)  Math.abs(grid[i][j] - grid[i-1][j])) + ((i == r-1) ? grid[i][j] : 0) + \\n                        (j==0 ? grid[i][j] : (int)  Math.abs(grid[i][j] - grid[i][j-1])) + ((j == r-1) ? grid[i][j] : 0);\\n               top += grid[i][j] > 0 ? 1 : 0;\\n           }\\n        return 2*(top)+l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int row = grid.length, col = grid[0].length ;\\n        int top = 0, l=0;\\n        for(int i = 0; i < row ; ++i){\\n           for(int j = 0; j < col ; ++j) {\\n               l += i==0 ? grid[i][j] : (int)  Math.abs(grid[i][j] - grid[i-1][j]);\\n               if(i == row-1)l += grid[i][j];\\n               l += j==0 ? grid[i][j] : (int)  Math.abs(grid[i][j] - grid[i][j-1]);\\n               if(j == col-1)l += grid[i][j];\\n               top += grid[i][j] > 0 ? 1 : 0;\\n           }\\n        }\\n        return 2*(top)+l;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int r = grid.length, top = 0, l=0;\\n        for(int i = 0; i < r ; ++i)\\n           for(int j = 0; j < r ; ++j) {\\n               l += (i==0 ? grid[i][j] : (int)  Math.abs(grid[i][j] - grid[i-1][j])) + ((i == r-1) ? grid[i][j] : 0) + \\n                        (j==0 ? grid[i][j] : (int)  Math.abs(grid[i][j] - grid[i][j-1])) + ((j == r-1) ? grid[i][j] : 0);\\n               top += grid[i][j] > 0 ? 1 : 0;\\n           }\\n        return 2*(top)+l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163685,
                "title": "easy-to-understand-intuitive-approach-c",
                "content": "\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        \\n        int ans=0;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        if(m==0 || n==0)\\n            return 0;\\n        \\n        if(m==1 && n==1)\\n            return grid[0][0]*4+2;\\n        \\n        int dx[]={-1,0,1,0};\\n        int dy[]={0,1,0,-1};\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    continue;\\n                \\n                if((i==0 && j==n-1) || (i==m-1 && j==0) || (i==0 && j==0) || (i==m-1 && j==n-1))\\n                    ans+=2*grid[i][j];\\n                else\\n                if(i==0 || j==0 || i==m-1 || j==n-1)\\n                    ans+=grid[i][j];\\n                \\n                for(int k=0;k<4;k++)\\n                    { \\n                      int nx=i+dx[k];\\n                      int ny=j+dy[k];\\n                      if(nx>=0 && ny>=0 && nx<m && ny<n)\\n                          ans+=(grid[nx][ny]-grid[i][j]>=0 ? 0 : grid[i][j]-grid[nx][ny]);\\n                    }\\n                    ans+=2;\\n            }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        \\n        int ans=0;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        if(m==0 || n==0)\\n            return 0;\\n        \\n        if(m==1 && n==1)\\n            return grid[0][0]*4+2;\\n        \\n        int dx[]={-1,0,1,0};\\n        int dy[]={0,1,0,-1};\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                    continue;\\n                \\n                if((i==0 && j==n-1) || (i==m-1 && j==0) || (i==0 && j==0) || (i==m-1 && j==n-1))\\n                    ans+=2*grid[i][j];\\n                else\\n                if(i==0 || j==0 || i==m-1 || j==n-1)\\n                    ans+=grid[i][j];\\n                \\n                for(int k=0;k<4;k++)\\n                    { \\n                      int nx=i+dx[k];\\n                      int ny=j+dy[k];\\n                      if(nx>=0 && ny>=0 && nx<m && ny<n)\\n                          ans+=(grid[nx][ny]-grid[i][j]>=0 ? 0 : grid[i][j]-grid[nx][ny]);\\n                    }\\n                    ans+=2;\\n            }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 163440,
                "title": "java-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int result = 0, n = grid.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) {\\n                    continue;\\n                }\\n                int preI = i == 0 ? 0 : grid[i - 1][j];\\n                int preJ = j == 0 ? 0 : grid[i][j - 1];\\n                int nextI = i == n - 1 ? 0 : grid[i + 1][j];\\n                int nextJ = j == n - 1 ? 0 : grid[i][j + 1];\\n                result += 2 + Math.max(0, grid[i][j] - preI) + Math.max(0, grid[i][j] - preJ) +\\n                    Math.max(0, grid[i][j] - nextI) + Math.max(0, grid[i][j] - nextJ);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int result = 0, n = grid.length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) {\\n                    continue;\\n                }\\n                int preI = i == 0 ? 0 : grid[i - 1][j];\\n                int preJ = j == 0 ? 0 : grid[i][j - 1];\\n                int nextI = i == n - 1 ? 0 : grid[i + 1][j];\\n                int nextJ = j == n - 1 ? 0 : grid[i][j + 1];\\n                result += 2 + Math.max(0, grid[i][j] - preI) + Math.max(0, grid[i][j] - preJ) +\\n                    Math.max(0, grid[i][j] - nextI) + Math.max(0, grid[i][j] - nextJ);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100885,
                "title": "c-solution",
                "content": "# Code\\n```\\n#define CUBE_AREA(x) (x * 4) + 2\\n\\nint surfaceArea(int** grid, int gridSize, int* gridColSize)\\n{\\n    int totalArea = 0, currentArea;\\n\\n    // Neighbouring areas\\n    int areaLeft, areaRight, areaUp, areaDown;\\n\\n    // Neighbouring cubes\\n    int cubeLeft, cubeRight, cubeUp, cubeDown;\\n\\n\\n    for(int i = 0; i < gridSize; i++)\\n    {\\n        for(int j = 0; j < gridColSize[i]; j++)\\n        {\\n            if(grid[i][j] == 0) continue;\\n            \\n            areaLeft = (j - 1 < 0) ? 0 : CUBE_AREA(grid[i][j - 1]);\\n            cubeLeft = (j - 1 < 0) ? 0 : grid[i][j - 1];\\n            areaRight = (j + 1 < gridColSize[i]) ? CUBE_AREA(grid[i][j + 1]) : 0;\\n            cubeRight = (j + 1 < gridColSize[i]) ? grid[i][j + 1] : 0;\\n            areaUp = (i - 1 < 0) ? 0 : CUBE_AREA(grid[i - 1][j]);\\n            cubeUp = (i - 1 < 0) ? 0 : grid[i - 1][j];\\n            areaDown = (i + 1 < gridSize) ? CUBE_AREA(grid[i + 1][j]) : 0;\\n            cubeDown = (i + 1 < gridSize) ? grid[i + 1][j] : 0;\\n\\n            currentArea = CUBE_AREA(grid[i][j]);\\n            totalArea += CUBE_AREA(grid[i][j]);\\n\\n            totalArea -= (currentArea > areaLeft ? cubeLeft : grid[i][j])\\n                             + (currentArea > areaRight ? cubeRight : grid[i][j]) \\n                             + (currentArea > areaUp ? cubeUp : grid[i][j]) \\n                             + (currentArea > areaDown ? cubeDown : grid[i][j]);\\n\\n        }\\n    }\\n\\n    return totalArea;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define CUBE_AREA(x) (x * 4) + 2\\n\\nint surfaceArea(int** grid, int gridSize, int* gridColSize)\\n{\\n    int totalArea = 0, currentArea;\\n\\n    // Neighbouring areas\\n    int areaLeft, areaRight, areaUp, areaDown;\\n\\n    // Neighbouring cubes\\n    int cubeLeft, cubeRight, cubeUp, cubeDown;\\n\\n\\n    for(int i = 0; i < gridSize; i++)\\n    {\\n        for(int j = 0; j < gridColSize[i]; j++)\\n        {\\n            if(grid[i][j] == 0) continue;\\n            \\n            areaLeft = (j - 1 < 0) ? 0 : CUBE_AREA(grid[i][j - 1]);\\n            cubeLeft = (j - 1 < 0) ? 0 : grid[i][j - 1];\\n            areaRight = (j + 1 < gridColSize[i]) ? CUBE_AREA(grid[i][j + 1]) : 0;\\n            cubeRight = (j + 1 < gridColSize[i]) ? grid[i][j + 1] : 0;\\n            areaUp = (i - 1 < 0) ? 0 : CUBE_AREA(grid[i - 1][j]);\\n            cubeUp = (i - 1 < 0) ? 0 : grid[i - 1][j];\\n            areaDown = (i + 1 < gridSize) ? CUBE_AREA(grid[i + 1][j]) : 0;\\n            cubeDown = (i + 1 < gridSize) ? grid[i + 1][j] : 0;\\n\\n            currentArea = CUBE_AREA(grid[i][j]);\\n            totalArea += CUBE_AREA(grid[i][j]);\\n\\n            totalArea -= (currentArea > areaLeft ? cubeLeft : grid[i][j])\\n                             + (currentArea > areaRight ? cubeRight : grid[i][j]) \\n                             + (currentArea > areaUp ? cubeUp : grid[i][j]) \\n                             + (currentArea > areaDown ? cubeDown : grid[i][j]);\\n\\n        }\\n    }\\n\\n    return totalArea;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077930,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        int n = grid.length;\\n        if(n==1){\\n            return 4*grid[0][0]+2;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                //top and bottom\\n                if(grid[i][j] != 0){\\n                    area+=2;\\n                }\\n                //edges\\n                if(i == 0 || j==0 || i == n-1 || j==n-1){\\n                    area += grid[i][j];\\n                }\\n                //corners\\n                if(i==0&&j==0){\\n                    area += grid[i][j];\\n                }\\n                if(i==0&&j==n-1){\\n                    area += grid[i][j];\\n                }\\n                if(i==n-1&&j==0){\\n                    area += grid[i][j];\\n                }\\n                if(i==n-1&&j==n-1){\\n                    area += grid[i][j];\\n                }\\n                // rest of them\\n                if(i != n-1 && j != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i+1][j]);\\n                    area += Math.abs(grid[i][j]-grid[i][j+1]);\\n                }else if(i != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i+1][j]);\\n                }else if(j != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i][j+1]);\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    bool isValid(int r , int c , int n){\\n        return r>=0 && r<n && c>=0 && c<n;\\n    }\\n\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int n = grid.size();\\n\\n        for (int i=0 ; i<n ; i++){\\n            ans += grid[0][i];\\n            ans += grid[n-1][i];\\n            ans += grid[i][0];\\n            ans += grid[i][n-1];\\n        }    \\n\\n        for (int i=0 ; i<n ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                if (grid[i][j] != 0)\\n                    ans += 2;\\n            }\\n        }\\n\\n        for (int i=0 ; i<n ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                if (isValid(i,j+1,n)){\\n                    int diff = abs(grid[i][j+1]-grid[i][j]);\\n                    ans += diff;\\n                }\\n                if (isValid(i+1 , j , n)){\\n                    int diff = abs(grid[i+1][j]-grid[i][j]);\\n                    ans += diff;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        int n = grid.length;\\n        if(n==1){\\n            return 4*grid[0][0]+2;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                //top and bottom\\n                if(grid[i][j] != 0){\\n                    area+=2;\\n                }\\n                //edges\\n                if(i == 0 || j==0 || i == n-1 || j==n-1){\\n                    area += grid[i][j];\\n                }\\n                //corners\\n                if(i==0&&j==0){\\n                    area += grid[i][j];\\n                }\\n                if(i==0&&j==n-1){\\n                    area += grid[i][j];\\n                }\\n                if(i==n-1&&j==0){\\n                    area += grid[i][j];\\n                }\\n                if(i==n-1&&j==n-1){\\n                    area += grid[i][j];\\n                }\\n                // rest of them\\n                if(i != n-1 && j != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i+1][j]);\\n                    area += Math.abs(grid[i][j]-grid[i][j+1]);\\n                }else if(i != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i+1][j]);\\n                }else if(j != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i][j+1]);\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    bool isValid(int r , int c , int n){\\n        return r>=0 && r<n && c>=0 && c<n;\\n    }\\n\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int n = grid.size();\\n\\n        for (int i=0 ; i<n ; i++){\\n            ans += grid[0][i];\\n            ans += grid[n-1][i];\\n            ans += grid[i][0];\\n            ans += grid[i][n-1];\\n        }    \\n\\n        for (int i=0 ; i<n ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                if (grid[i][j] != 0)\\n                    ans += 2;\\n            }\\n        }\\n\\n        for (int i=0 ; i<n ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                if (isValid(i,j+1,n)){\\n                    int diff = abs(grid[i][j+1]-grid[i][j]);\\n                    ans += diff;\\n                }\\n                if (isValid(i+1 , j , n)){\\n                    int diff = abs(grid[i+1][j]-grid[i][j]);\\n                    ans += diff;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071963,
                "title": "simple-linear-solution-with-o-1-space",
                "content": "# Intuition\\nIterate through each stack of cubes in the grid, then add the added cube\\'s surface. Substract any overlap with the previous shape above or on the side.\\n\\n# Approach\\n- Iterate the grid\\n- Calculate the surface of the added cubes. That\\'ll be the height * 4 (4 sides) + 2 (top bottom), unless height is 0, in which case the surface is 0.\\n- Substract the overlap with the stack above. That\\'ll be the minimum height * 2 (surface touching).\\n- Similarly, substract the overlap with the stack to the left.\\n- Return resulting surface.\\n\\n# Complexity\\n- Time complexity:\\nO(m x n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunction surfaceArea(grid: number[][]): number {\\n    let surface = 0;\\n    for (let y = 0; y < grid.length; y++) {\\n        for (let x = 0; x < grid[y].length; x++) {\\n            const height = grid[y][x];\\n            surface += (height ? 2 + height * 4 : 0);\\n            if (y > 0) {\\n                surface -= Math.min(height, grid[y-1][x]) * 2;\\n            }\\n            if (x > 0) {\\n                surface -= Math.min(height, grid[y][x-1]) * 2;\\n            }\\n        }\\n    }\\n    return surface;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction surfaceArea(grid: number[][]): number {\\n    let surface = 0;\\n    for (let y = 0; y < grid.length; y++) {\\n        for (let x = 0; x < grid[y].length; x++) {\\n            const height = grid[y][x];\\n            surface += (height ? 2 + height * 4 : 0);\\n            if (y > 0) {\\n                surface -= Math.min(height, grid[y-1][x]) * 2;\\n            }\\n            if (x > 0) {\\n                surface -= Math.min(height, grid[y][x-1]) * 2;\\n            }\\n        }\\n    }\\n    return surface;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049151,
                "title": "fastest-c-easy-to-understand-every-test-case-well-dealt",
                "content": "\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(n==1 and m==1)\\n        return 4*grid[0][0]+2;\\n        if((n==1 and m==2) or (n==2 and m==1))\\n        {\\n            if(n==1 and m==2)\\n            return 4+3*(grid[0][0]+grid[0][1])+abs(grid[0][0]-grid[0][1]);\\n            if(n==2 and m==1)\\n            return 4+3*(grid[0][0]+grid[1][0])+abs(grid[0][0]-grid[1][0]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int l=0,b=0;\\n                if(j!=0)\\n                l=abs(grid[i][j]-grid[i][j-1]);\\n                if(i!=n-1)\\n                b=abs(grid[i][j]-grid[i+1][j]);\\n                int h=grid[i][j];\\n                int hc=0;\\n                if((i==0 and (j==0 || j==m-1)) || (i==n-1 and (j==0 || j==m-1)))\\n                hc=2;\\n                else if(i==0 || j==0 || i==n-1 || j==m-1)\\n                hc=1;\\n                ans+=l+b+hc*h;\\n                if(h)\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(n==1 and m==1)\\n        return 4*grid[0][0]+2;\\n        if((n==1 and m==2) or (n==2 and m==1))\\n        {\\n            if(n==1 and m==2)\\n            return 4+3*(grid[0][0]+grid[0][1])+abs(grid[0][0]-grid[0][1]);\\n            if(n==2 and m==1)\\n            return 4+3*(grid[0][0]+grid[1][0])+abs(grid[0][0]-grid[1][0]);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int l=0,b=0;\\n                if(j!=0)\\n                l=abs(grid[i][j]-grid[i][j-1]);\\n                if(i!=n-1)\\n                b=abs(grid[i][j]-grid[i+1][j]);\\n                int h=grid[i][j];\\n                int hc=0;\\n                if((i==0 and (j==0 || j==m-1)) || (i==n-1 and (j==0 || j==m-1)))\\n                hc=2;\\n                else if(i==0 || j==0 || i==n-1 || j==m-1)\\n                hc=1;\\n                ans+=l+b+hc*h;\\n                if(h)\\n                ans+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003623,
                "title": "area-of-the-solid-figure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(3N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area=0;\\n        int len = grid.length;\\n        for(int i=0; i<len; i++){\\n            for(int j=0; j<len; j++){\\n                area += grid[i][j]>0 ? 4*grid[i][j] + 2:0;\\n            }\\n        }\\n\\n        for(int i=0; i<len; i++){\\n            for(int j=0; j<len-1; j++){\\n                area -= 2*Math.min(grid[i][j], grid[i][j+1]);\\n            }\\n        }\\n\\n        for(int j=0; j<len; j++){\\n            for(int i=0; i<len-1; i++){\\n                area -= 2*Math.min(grid[i][j], grid[i+1][j]);\\n            }\\n        }\\n\\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Geometry",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area=0;\\n        int len = grid.length;\\n        for(int i=0; i<len; i++){\\n            for(int j=0; j<len; j++){\\n                area += grid[i][j]>0 ? 4*grid[i][j] + 2:0;\\n            }\\n        }\\n\\n        for(int i=0; i<len; i++){\\n            for(int j=0; j<len-1; j++){\\n                area -= 2*Math.min(grid[i][j], grid[i][j+1]);\\n            }\\n        }\\n\\n        for(int j=0; j<len; j++){\\n            for(int i=0; i<len-1; i++){\\n                area -= 2*Math.min(grid[i][j], grid[i+1][j]);\\n            }\\n        }\\n\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000299,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- If any cell have value non zero, then increase the ans with 2 for the top and bottom sides.\\n- Then check all 4 sides of it, if the sides are not in range of 0 to n, means the cell is corner one, so add the grid[i][j] into ans;\\n- Else compare it with its neighbour and if the current cell is higher then neighbour than, add the diff in the ans.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        int dr[] = {0,1,0,-1};\\n        int dc[] = {1,0,-1,0};\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] != 0)\\n                    ans += 2;\\n\\n                for(int k=0; k<4; k++){\\n                    int row = i + dr[k];\\n                    int col = j + dc[k];\\n                    if(row >= 0 && row < n && col >= 0 && col < n){\\n                        if(grid[row][col] < grid[i][j]){\\n                            ans += grid[i][j] - grid[row][col];\\n                        }\\n                    }\\n                    else ans += grid[i][j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        int dr[] = {0,1,0,-1};\\n        int dc[] = {1,0,-1,0};\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] != 0)\\n                    ans += 2;\\n\\n                for(int k=0; k<4; k++){\\n                    int row = i + dr[k];\\n                    int col = j + dc[k];\\n                    if(row >= 0 && row < n && col >= 0 && col < n){\\n                        if(grid[row][col] < grid[i][j]){\\n                            ans += grid[i][j] - grid[row][col];\\n                        }\\n                    }\\n                    else ans += grid[i][j];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990812,
                "title": "efficient-surface-area-calculation-for-3d-grid-c-solution",
                "content": "\\n**Body:**\\n\\n**Problem Description:**\\n\\nThe problem at hand involves calculating the total surface area of a 3D grid composed of blocks, where each block has a certain height. The task is to efficiently determine the overall surface area considering the heights of the blocks and the shared surfaces between adjacent blocks.\\n\\n**Solution Explanation:**\\n\\nThe provided C++ solution offers an elegant approach to solving this problem. Let\\'s break down how it works:\\n\\n```cpp\\nint result = 0;\\nint gridSize = grid.size();\\n\\nfor (int row = 0; row < gridSize; ++row) {\\n    for (int col = 0; col < gridSize; ++col) {\\n        if (grid[row][col]) {\\n            result += grid[row][col] * 4 + 2;\\n        }\\n        if (row) {\\n            result -= min(grid[row][col], grid[row - 1][col]) * 2;\\n        }\\n        if (col) {\\n            result -= min(grid[row][col], grid[row][col - 1]) * 2;\\n        }\\n    }\\n}\\nreturn result;\\n```\\n\\nHere\\'s a concise explanation of the code:\\n\\n1. We initialize the `result` variable to keep track of the total surface area and the `gridSize` variable to store the size of the grid (assuming it\\'s a square grid with `gridSize` rows and columns).\\n\\n2. The code then uses two nested loops to iterate through each cell in the grid. The outer loop (`row`) iterates over the rows, and the inner loop (`col`) iterates over the columns.\\n\\n3. We calculate the contribution of the current block at coordinates `(row, col)` to the surface area:\\n   - `grid[row][col] * 4` represents the surface area of the sides of the block (top, bottom, left, and right). Each side has an area equal to the height of the block.\\n   - `+ 2` accounts for the top and bottom faces of the block, each with an area of 1 square unit.\\n\\n4. We subtract the shared surface areas between adjacent blocks:\\n   - If there\\'s a block immediately above (`row > 0`), we subtract `min(grid[row][col], grid[row - 1][col]) * 2`, which represents the shared surface area.\\n   - If there\\'s a block immediately to the left (`col > 0`), we subtract `min(grid[row][col], grid[row][col - 1]) * 2`.\\n\\n5. The loops continue until all cells in the grid have been processed.\\n\\n6. Finally, the function returns the calculated `result`, which represents the total surface area.\\n\\n**Efficiency and Conclusion:**\\n\\nThis solution efficiently computes the surface area of a 3D grid by considering each block\\'s individual contribution and adjusting for shared surfaces with neighboring blocks. The algorithm\\'s time complexity is linear, making it an optimal choice for large grids.\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```cpp\\nint result = 0;\\nint gridSize = grid.size();\\n\\nfor (int row = 0; row < gridSize; ++row) {\\n    for (int col = 0; col < gridSize; ++col) {\\n        if (grid[row][col]) {\\n            result += grid[row][col] * 4 + 2;\\n        }\\n        if (row) {\\n            result -= min(grid[row][col], grid[row - 1][col]) * 2;\\n        }\\n        if (col) {\\n            result -= min(grid[row][col], grid[row][col - 1]) * 2;\\n        }\\n    }\\n}\\nreturn result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976353,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int r , int c , int n){\\n        return r>=0 && r<n && c>=0 && c<n;\\n    }\\n\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int n = grid.size();\\n\\n        for (int i=0 ; i<n ; i++){\\n            ans += grid[0][i];\\n            ans += grid[n-1][i];\\n            ans += grid[i][0];\\n            ans += grid[i][n-1];\\n        }    \\n\\n        for (int i=0 ; i<n ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                if (grid[i][j] != 0)\\n                    ans += 2;\\n            }\\n        }\\n\\n        for (int i=0 ; i<n ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                if (isValid(i,j+1,n)){\\n                    int diff = abs(grid[i][j+1]-grid[i][j]);\\n                    ans += diff;\\n                }\\n                if (isValid(i+1 , j , n)){\\n                    int diff = abs(grid[i+1][j]-grid[i][j]);\\n                    ans += diff;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int r , int c , int n){\\n        return r>=0 && r<n && c>=0 && c<n;\\n    }\\n\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int n = grid.size();\\n\\n        for (int i=0 ; i<n ; i++){\\n            ans += grid[0][i];\\n            ans += grid[n-1][i];\\n            ans += grid[i][0];\\n            ans += grid[i][n-1];\\n        }    \\n\\n        for (int i=0 ; i<n ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                if (grid[i][j] != 0)\\n                    ans += 2;\\n            }\\n        }\\n\\n        for (int i=0 ; i<n ; i++){\\n            for (int j=0 ; j<n ; j++){\\n                if (isValid(i,j+1,n)){\\n                    int diff = abs(grid[i][j+1]-grid[i][j]);\\n                    ans += diff;\\n                }\\n                if (isValid(i+1 , j , n)){\\n                    int diff = abs(grid[i+1][j]-grid[i][j]);\\n                    ans += diff;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973262,
                "title": "easy-python-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1 : Find the area of each piller on the matrix(First Loop)\\nStep 2 : Remove all the walls of two adjence pillers(Second Loop)\\nStep 3 : Get the transpose of the matrix\\nStep 4 : Repet Step 2. \\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Runtime\\n- 81 ms\\n# Code\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        area = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] != 0:\\n                    area += 2 * (1 + grid[i][j] + grid[i][j])\\n        \\n        for i in range(len(grid)):\\n            a=0\\n            while a < len(grid) - 1:\\n                area -= min(grid[i][a], grid[i][a+1]) * 2\\n                a += 1\\n        \\n        grid = list(zip(*grid))\\n\\n        for i in range(len(grid)):\\n            a=0\\n            while a < len(grid) - 1:\\n                area -= min(grid[i][a], grid[i][a+1]) * 2\\n                a += 1\\n        \\n        return area\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        area = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] != 0:\\n                    area += 2 * (1 + grid[i][j] + grid[i][j])\\n        \\n        for i in range(len(grid)):\\n            a=0\\n            while a < len(grid) - 1:\\n                area -= min(grid[i][a], grid[i][a+1]) * 2\\n                a += 1\\n        \\n        grid = list(zip(*grid))\\n\\n        for i in range(len(grid)):\\n            a=0\\n            while a < len(grid) - 1:\\n                area -= min(grid[i][a], grid[i][a+1]) * 2\\n                a += 1\\n        \\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944679,
                "title": "rust-elixir-2-approaches",
                "content": "Rust: Calculate area for each `(i, j)`.\\nElixir: Calculate area separately for horizontal and vertical surfaces. (Let `grid` be a horizontal grid)\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n    pub fn surface_area(grid: Vec<Vec<i32>>) -> i32 {\\n        let dir = [0, 1, 0, usize::MAX, 0];\\n        let mut ans = 0;\\n        for i in 0..grid.len() {\\n            for j in 0..grid[i].len() {\\n                if grid[i][j] == 0 {\\n                    continue;\\n                }\\n                ans += 2;\\n                for d in 0..4 {\\n                    let i2 = i.wrapping_add(dir[d]);\\n                    let j2 = j.wrapping_add(dir[d + 1]);\\n                    if i2 >= grid.len()\\n                    || j2 >= grid[i].len() {\\n                        ans += grid[i][j];\\n                    }\\n                    else if grid[i][j] > grid[i2][j2] {\\n                        ans += grid[i][j] - grid[i2][j2];\\n                    }\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\\n```Elixir []\\ndefmodule Solution do\\n  @spec surface_area(grid :: [[integer]]) :: integer\\n  def surface_area(grid) do\\n    2 * hori(grid) +\\n      verti(grid) + \\n      (Enum.zip_with(grid, &(&1)) |> verti())\\n  end\\n\\n  defp hori(grid) do\\n    Enum.map(grid, fn row ->\\n      Enum.count(row, &(&1 != 0))\\n    end)\\n    |> Enum.sum()\\n  end\\n\\n  defp verti(grid) do\\n    Enum.map(grid, fn row ->\\n      Enum.map_reduce(row, 0, fn x, acc ->\\n        {abs(x - acc), x}\\n      end)\\n      |> then(fn {list, acc} ->\\n        Enum.sum(list) + acc\\n      end)\\n    end)\\n    |> Enum.sum()\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```Rust []\\nimpl Solution {\\n    pub fn surface_area(grid: Vec<Vec<i32>>) -> i32 {\\n        let dir = [0, 1, 0, usize::MAX, 0];\\n        let mut ans = 0;\\n        for i in 0..grid.len() {\\n            for j in 0..grid[i].len() {\\n                if grid[i][j] == 0 {\\n                    continue;\\n                }\\n                ans += 2;\\n                for d in 0..4 {\\n                    let i2 = i.wrapping_add(dir[d]);\\n                    let j2 = j.wrapping_add(dir[d + 1]);\\n                    if i2 >= grid.len()\\n                    || j2 >= grid[i].len() {\\n                        ans += grid[i][j];\\n                    }\\n                    else if grid[i][j] > grid[i2][j2] {\\n                        ans += grid[i][j] - grid[i2][j2];\\n                    }\\n                }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\n```Elixir []\\ndefmodule Solution do\\n  @spec surface_area(grid :: [[integer]]) :: integer\\n  def surface_area(grid) do\\n    2 * hori(grid) +\\n      verti(grid) + \\n      (Enum.zip_with(grid, &(&1)) |> verti())\\n  end\\n\\n  defp hori(grid) do\\n    Enum.map(grid, fn row ->\\n      Enum.count(row, &(&1 != 0))\\n    end)\\n    |> Enum.sum()\\n  end\\n\\n  defp verti(grid) do\\n    Enum.map(grid, fn row ->\\n      Enum.map_reduce(row, 0, fn x, acc ->\\n        {abs(x - acc), x}\\n      end)\\n      |> then(fn {list, acc} ->\\n        Enum.sum(list) + acc\\n      end)\\n    end)\\n    |> Enum.sum()\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3941676,
                "title": "java-fast-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        int n = grid.length;\\n        if(n==1){\\n            return 4*grid[0][0]+2;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                //top and bottom\\n                if(grid[i][j] != 0){\\n                    area+=2;\\n                }\\n                //edges\\n                if(i == 0 || j==0 || i == n-1 || j==n-1){\\n                    area += grid[i][j];\\n                }\\n                //corners\\n                if(i==0&&j==0){\\n                    area += grid[i][j];\\n                }\\n                if(i==0&&j==n-1){\\n                    area += grid[i][j];\\n                }\\n                if(i==n-1&&j==0){\\n                    area += grid[i][j];\\n                }\\n                if(i==n-1&&j==n-1){\\n                    area += grid[i][j];\\n                }\\n                // rest of them\\n                if(i != n-1 && j != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i+1][j]);\\n                    area += Math.abs(grid[i][j]-grid[i][j+1]);\\n                }else if(i != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i+1][j]);\\n                }else if(j != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i][j+1]);\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n        int n = grid.length;\\n        if(n==1){\\n            return 4*grid[0][0]+2;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                //top and bottom\\n                if(grid[i][j] != 0){\\n                    area+=2;\\n                }\\n                //edges\\n                if(i == 0 || j==0 || i == n-1 || j==n-1){\\n                    area += grid[i][j];\\n                }\\n                //corners\\n                if(i==0&&j==0){\\n                    area += grid[i][j];\\n                }\\n                if(i==0&&j==n-1){\\n                    area += grid[i][j];\\n                }\\n                if(i==n-1&&j==0){\\n                    area += grid[i][j];\\n                }\\n                if(i==n-1&&j==n-1){\\n                    area += grid[i][j];\\n                }\\n                // rest of them\\n                if(i != n-1 && j != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i+1][j]);\\n                    area += Math.abs(grid[i][j]-grid[i][j+1]);\\n                }else if(i != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i+1][j]);\\n                }else if(j != n-1){\\n                    area += Math.abs(grid[i][j]-grid[i][j+1]);\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918992,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        neighbors = ((-1, 0), (0, -1), (0, 1), (1, 0))\\n        res = 0\\n        for r in range(n):\\n            for c in range(n):\\n                for n_r, n_c in neighbors:\\n                    if (0 <= r + n_r < n) and (0 <= c + n_c < n):\\n                        if grid[r][c] > grid[r+n_r][c+n_c]:\\n                            res += grid[r][c] - grid[r+n_r][c+n_c]\\n                    else:\\n                        res += grid[r][c]\\n\\n                res += 2 if grid[r][c] != 0 else 0\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        neighbors = ((-1, 0), (0, -1), (0, 1), (1, 0))\\n        res = 0\\n        for r in range(n):\\n            for c in range(n):\\n                for n_r, n_c in neighbors:\\n                    if (0 <= r + n_r < n) and (0 <= c + n_c < n):\\n                        if grid[r][c] > grid[r+n_r][c+n_c]:\\n                            res += grid[r][c] - grid[r+n_r][c+n_c]\\n                    else:\\n                        res += grid[r][c]\\n\\n                res += 2 if grid[r][c] != 0 else 0\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885383,
                "title": "beats-87-with-run-time-of-7ms-c-best-and-simple-approach-well-explained",
                "content": "# Intuition\\nIn this problem we have to given a grid matrix in which grid[i][j] represent the number of cube of size 1x1x1 is kept at position [i][j].\\nNow we have to find the uncovered surface area of the structure formed after placing all the cube as instructed (including bottom part).\\n\\n# Approach\\nfor finding total surface area of the cube we have divided the problem into three sub problem.\\n1. if any block exit at any position we will add its bottom surface area and upper surface area does not matter how tall the cube tower is. for this we will check if any cube exist under two for loop which will run for all the through the grid and add 2 to area.\\n2. In the second part we will add the vertical surface area along the boundary.\\n3. Now, in the third part we are left with the vertical area if we there is is height diferenence in the cube tower height. for this we have picked each tower and checked how many tower does exist beside the tower and smaller that the picked up tower. If any tower exist and also smaller then we will add vertical area which will equal to the height difference of the tower.\\n4. And then we have returned area.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int a = grid.size();\\n        long int area = 0;\\n        for(int i = 0; i<a; i++){\\n            area+=grid[0][i]; //adding vertical area of in first row;\\n            area+=grid[a-1][i]; //adding vertical area in least row;\\n            area+=grid[i][0]; //adding vertical area in first column\\n            area+=grid[i][a-1]; // adding vertical area in last column\\n            for(int j = 0; j<a; j++){\\n            //adding bottom and upperpart of the cube if any cube exist does not matter how tall the cube tower is its upper and lower lower suraface area exist.\\n                if(grid[i][j]){\\n                    area+=2;\\n                }\\n//checking does any cube tower exist and is smaller than curent tower then adding the vertical surface area.\\n//for checking in all the four direction we have used four condition\\n                if(j+1<a){\\n                    if(grid[i][j]>grid[i][j+1]){\\n                        area+=(grid[i][j]-grid[i][j+1]);\\n                    }\\n                }\\n                if(i+1<a){\\n                    if(grid[i][j]>grid[i+1][j]){\\n                        area+=(grid[i][j]-grid[i+1][j]);\\n                    }\\n                }\\n                if(j-1>=0){\\n                    if(grid[i][j]>grid[i][j-1]){\\n                        area+=(grid[i][j]-grid[i][j-1]);\\n                    }\\n                }\\n                if(i-1>=0){\\n                    if(grid[i][j]>grid[i-1][j]){\\n                        area+=(grid[i][j]-grid[i-1][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int a = grid.size();\\n        long int area = 0;\\n        for(int i = 0; i<a; i++){\\n            area+=grid[0][i]; //adding vertical area of in first row;\\n            area+=grid[a-1][i]; //adding vertical area in least row;\\n            area+=grid[i][0]; //adding vertical area in first column\\n            area+=grid[i][a-1]; // adding vertical area in last column\\n            for(int j = 0; j<a; j++){\\n            //adding bottom and upperpart of the cube if any cube exist does not matter how tall the cube tower is its upper and lower lower suraface area exist.\\n                if(grid[i][j]){\\n                    area+=2;\\n                }\\n//checking does any cube tower exist and is smaller than curent tower then adding the vertical surface area.\\n//for checking in all the four direction we have used four condition\\n                if(j+1<a){\\n                    if(grid[i][j]>grid[i][j+1]){\\n                        area+=(grid[i][j]-grid[i][j+1]);\\n                    }\\n                }\\n                if(i+1<a){\\n                    if(grid[i][j]>grid[i+1][j]){\\n                        area+=(grid[i][j]-grid[i+1][j]);\\n                    }\\n                }\\n                if(j-1>=0){\\n                    if(grid[i][j]>grid[i][j-1]){\\n                        area+=(grid[i][j]-grid[i][j-1]);\\n                    }\\n                }\\n                if(i-1>=0){\\n                    if(grid[i][j]>grid[i-1][j]){\\n                        area+=(grid[i][j]-grid[i-1][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883906,
                "title": "the-fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n int surfaceArea(List<List<int>> grid) {\\n    int n = grid.length;\\n    int area = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] > 0) {\\n                area += (grid[i][j] * 4) + 2; // Contribution from top and bottom faces\\n\\n                // Check adjacent cells and subtract common faces\\n                if (i > 0) {\\n                    area -= min(grid[i][j], grid[i - 1][j]) * 2;\\n                }\\n                if (j > 0) {\\n                    area -=min(grid[i][j], grid[i][j - 1]) * 2;\\n                }\\n            }\\n        }\\n    }\\n\\n    return area;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n int surfaceArea(List<List<int>> grid) {\\n    int n = grid.length;\\n    int area = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < n; j++) {\\n            if (grid[i][j] > 0) {\\n                area += (grid[i][j] * 4) + 2; // Contribution from top and bottom faces\\n\\n                // Check adjacent cells and subtract common faces\\n                if (i > 0) {\\n                    area -= min(grid[i][j], grid[i - 1][j]) * 2;\\n                }\\n                if (j > 0) {\\n                    area -=min(grid[i][j], grid[i][j - 1]) * 2;\\n                }\\n            }\\n        }\\n    }\\n\\n    return area;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876303,
                "title": "java-simple-solurtion",
                "content": "\\n# Complexity\\n- Time complexity: O(n * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n      int n = grid.length;\\n      int sur = 0;\\n\\n      for(int i = 0; i < n; i++)\\n          sur += grid[0][i] + grid[i][0] + grid[i][n-1] + grid[n-1][i];\\n\\n      for(int i = 0; i < n; i++)\\n        for(int j = 0; j < n; j++)\\n          if(grid[i][j] != 0) sur += 2;\\n     \\n     for(int i = 0; i < n-1; i++)\\n       for(int j = 0; j < n; j++)\\n         sur += Math.abs(grid[i][j] - grid[i+1][j]);\\n       \\n      for(int i = 0; i < n; i++)\\n       for(int j = 0; j < n-1; j++)\\n         sur += Math.abs(grid[i][j] - grid[i][j+1]);\\n       \\n      return sur;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n      int n = grid.length;\\n      int sur = 0;\\n\\n      for(int i = 0; i < n; i++)\\n          sur += grid[0][i] + grid[i][0] + grid[i][n-1] + grid[n-1][i];\\n\\n      for(int i = 0; i < n; i++)\\n        for(int j = 0; j < n; j++)\\n          if(grid[i][j] != 0) sur += 2;\\n     \\n     for(int i = 0; i < n-1; i++)\\n       for(int j = 0; j < n; j++)\\n         sur += Math.abs(grid[i][j] - grid[i+1][j]);\\n       \\n      for(int i = 0; i < n; i++)\\n       for(int j = 0; j < n-1; j++)\\n         sur += Math.abs(grid[i][j] - grid[i][j+1]);\\n       \\n      return sur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867556,
                "title": "easy-to-understand-go-golang-solution",
                "content": "```\\nfunc surfaceArea(grid [][]int) int {\\n        n := len(grid)\\n        var sum int\\n\\n        for i := 0; i < n; i++ {\\n                for j := 0; j < n; j++ {\\n                        v := grid[i][j]\\n\\n                        var frontV int\\n                        if i-1 >= 0 {\\n                                frontV = grid[i-1][j]\\n                        }\\n\\n                        var backV int\\n                        if i+1 < n {\\n                                backV = grid[i+1][j]\\n                        }\\n\\n                        var leftV int\\n                        if j-1 >= 0 {\\n                                leftV = grid[i][j-1]\\n                        }\\n\\n                        var rightV int\\n                        if j+1 < n {\\n                                rightV = grid[i][j+1]\\n                        }\\n\\n                        topBottomSum := sumTopAndBottom(v)\\n                        frontSum := sumSide(v, frontV)\\n                        backSum := sumSide(v, backV)\\n                        leftSum := sumSide(v, leftV)\\n                        rightSum := sumSide(v, rightV)\\n\\n                        sum += (topBottomSum + frontSum + backSum + leftSum + rightSum)\\n                }\\n        }\\n\\n        return sum\\n}\\n\\nfunc sumTopAndBottom(v int) int {\\n        if v > 0 {\\n                return 2\\n        }\\n\\n        return 0\\n}\\n\\nfunc sumSide(v, sideV int) int {\\n        if v <= sideV {\\n                return 0\\n        }\\n\\n        return v - sideV\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc surfaceArea(grid [][]int) int {\\n        n := len(grid)\\n        var sum int\\n\\n        for i := 0; i < n; i++ {\\n                for j := 0; j < n; j++ {\\n                        v := grid[i][j]\\n\\n                        var frontV int\\n                        if i-1 >= 0 {\\n                                frontV = grid[i-1][j]\\n                        }\\n\\n                        var backV int\\n                        if i+1 < n {\\n                                backV = grid[i+1][j]\\n                        }\\n\\n                        var leftV int\\n                        if j-1 >= 0 {\\n                                leftV = grid[i][j-1]\\n                        }\\n\\n                        var rightV int\\n                        if j+1 < n {\\n                                rightV = grid[i][j+1]\\n                        }\\n\\n                        topBottomSum := sumTopAndBottom(v)\\n                        frontSum := sumSide(v, frontV)\\n                        backSum := sumSide(v, backV)\\n                        leftSum := sumSide(v, leftV)\\n                        rightSum := sumSide(v, rightV)\\n\\n                        sum += (topBottomSum + frontSum + backSum + leftSum + rightSum)\\n                }\\n        }\\n\\n        return sum\\n}\\n\\nfunc sumTopAndBottom(v int) int {\\n        if v > 0 {\\n                return 2\\n        }\\n\\n        return 0\\n}\\n\\nfunc sumSide(v, sideV int) int {\\n        if v <= sideV {\\n                return 0\\n        }\\n\\n        return v - sideV\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845225,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        \\n        int total = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n\\n        // Tower surface area = 4 x v + 2 \\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] != 0)\\n                    total += 4 * grid[i][j] + 2;\\n            }\\n        }\\n\\n        // Deduct the adjacent surface area\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c-1; j++){\\n                total -= 2 * min(grid[i][j], grid[i][j+1]);\\n            }\\n        }\\n        for(int i = 0; i < c; i++){\\n            for(int j = 0 ; j < r-1; j++){\\n                total -= 2 * min(grid[j][i], grid[j+1][i]);\\n            }\\n        }\\n\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        \\n        int total = 0;\\n        int r = grid.size();\\n        int c = grid[0].size();\\n\\n        // Tower surface area = 4 x v + 2 \\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[0].size(); j++){\\n                if(grid[i][j] != 0)\\n                    total += 4 * grid[i][j] + 2;\\n            }\\n        }\\n\\n        // Deduct the adjacent surface area\\n        for(int i = 0; i < r; i++){\\n            for(int j = 0; j < c-1; j++){\\n                total -= 2 * min(grid[i][j], grid[i][j+1]);\\n            }\\n        }\\n        for(int i = 0; i < c; i++){\\n            for(int j = 0 ; j < r-1; j++){\\n                total -= 2 * min(grid[j][i], grid[j+1][i]);\\n            }\\n        }\\n\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839100,
                "title": "step-by-step-solution-for-every-language-python-runtime-85-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution is based on calculating all surfaces that can be seen. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur approach is to go through building in two direction. \\n* Step 1 - First we sweep in direction (left to right):\\nStarting from the most above row, we look at the building, and we see the side of the first block, which is equal to the block height. Then we step on that block, and we see the side of the next block, which is the difference between the next block height and our current position (previous block height). We go through all block and when we reach ground on the other side of the building we can look behind and see the side of the last block. Now we move on to the next row.\\n* Step 2 - Second, we sweep in y direction (up to down): \\nIt\\'s completely the same as the previous step but in another direction.  After this step, we have calculated all 4 side area of building.\\n* Step 3 -  Lastly, we should consider that each block contains has two 1*1 surface at bottom and above, and sum all areas from previous steps.\\n\\nPlease __upvote__ if you find this walkthrough usefull.\\n# Code\\n```python\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        # STEP ONE: X-direction (left to right)\\n        max_x = 0\\n        for row in grid:\\n            max_x += row[0] # add the most left side of the row \\n            max_x += row[-1] # add the most right side of the row\\n            for j in range(1,len(row)):\\n                max_x += abs(row[j]-row[j-1]) # add the difference between adjacent blocks height \\n        \\n        max_y = 0\\n        sum_z = 0\\n        for i in range(len(grid)):\\n            col = []\\n            # Create columns from grid as lists : \\n            for j in range(len(grid[0])):\\n                col.append(grid[j][i])\\n                if grid[i][j]:\\n                    sum_z += 1 # count number of blocks\\n            # STEP TWO : Y-direction (up to down)\\n            max_y += col[0]\\n            max_y += col[-1]\\n            for j in range(1,len(col)):\\n                max_y += abs(col[j]-col[j-1])\\n        \\n        return max_x + max_y + 2*sum_z\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Geometry",
                    "Matrix"
                ],
                "code": "```python\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        # STEP ONE: X-direction (left to right)\\n        max_x = 0\\n        for row in grid:\\n            max_x += row[0] # add the most left side of the row \\n            max_x += row[-1] # add the most right side of the row\\n            for j in range(1,len(row)):\\n                max_x += abs(row[j]-row[j-1]) # add the difference between adjacent blocks height \\n        \\n        max_y = 0\\n        sum_z = 0\\n        for i in range(len(grid)):\\n            col = []\\n            # Create columns from grid as lists : \\n            for j in range(len(grid[0])):\\n                col.append(grid[j][i])\\n                if grid[i][j]:\\n                    sum_z += 1 # count number of blocks\\n            # STEP TWO : Y-direction (up to down)\\n            max_y += col[0]\\n            max_y += col[-1]\\n            for j in range(1,len(col)):\\n                max_y += abs(col[j]-col[j-1])\\n        \\n        return max_x + max_y + 2*sum_z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830697,
                "title": "easy-python-solution-surround-by-0s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        # - surround area with zeros\\n        # - for every non-zero add 1 for bottom and 1 for top\\n        # - for every cell if left, top, right, bottom neighbour is smaller add difference\\n\\n        n = len(grid)\\n\\n        for i in range(n):\\n            grid[i] = [0] + grid[i] + [0]\\n\\n        grid = [ [0] * (n + 2) ] + grid + [ [0] * (n + 2) ]\\n\\n        res = 0\\n        nn = n + 2\\n        for i in range(1, nn - 1):\\n            for j in range(1, nn - 1):\\n                cell = grid[i][j]\\n                res += 2 if cell > 0 else 0\\n\\n                if cell > grid[i][j-1]:\\n                    res += (cell - grid[i][j-1])\\n\\n                if cell > grid[i][j+1]:\\n                    res += (cell - grid[i][j+1])\\n\\n                if cell > grid[i-1][j]:\\n                    res += (cell - grid[i-1][j])\\n\\n                if cell > grid[i+1][j]:\\n                    res += (cell - grid[i+1][j])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        # - surround area with zeros\\n        # - for every non-zero add 1 for bottom and 1 for top\\n        # - for every cell if left, top, right, bottom neighbour is smaller add difference\\n\\n        n = len(grid)\\n\\n        for i in range(n):\\n            grid[i] = [0] + grid[i] + [0]\\n\\n        grid = [ [0] * (n + 2) ] + grid + [ [0] * (n + 2) ]\\n\\n        res = 0\\n        nn = n + 2\\n        for i in range(1, nn - 1):\\n            for j in range(1, nn - 1):\\n                cell = grid[i][j]\\n                res += 2 if cell > 0 else 0\\n\\n                if cell > grid[i][j-1]:\\n                    res += (cell - grid[i][j-1])\\n\\n                if cell > grid[i][j+1]:\\n                    res += (cell - grid[i][j+1])\\n\\n                if cell > grid[i-1][j]:\\n                    res += (cell - grid[i-1][j])\\n\\n                if cell > grid[i+1][j]:\\n                    res += (cell - grid[i+1][j])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814652,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(mn)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), countZero{}, ans{};\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\n                if(j != 0) ans += abs(grid[i][j] - grid[i][j - 1]);\\n                if(i != 0) ans += abs(grid[i - 1][j] - grid[i][j]);\\n                if(j == 0) ans += grid[i][j];\\n                if(j == n - 1) ans += grid[i][j];\\n                if(i == 0) ans += grid[i][j];\\n                if(i == n - 1) ans += grid[i][j];\\n\\n                if(grid[i][j] == 0) ans -= 2;\\n\\n            }\\n        }\\n\\n        return ans + 2 * (n * n);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), countZero{}, ans{};\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n\\n                if(j != 0) ans += abs(grid[i][j] - grid[i][j - 1]);\\n                if(i != 0) ans += abs(grid[i - 1][j] - grid[i][j]);\\n                if(j == 0) ans += grid[i][j];\\n                if(j == n - 1) ans += grid[i][j];\\n                if(i == 0) ans += grid[i][j];\\n                if(i == n - 1) ans += grid[i][j];\\n\\n                if(grid[i][j] == 0) ans -= 2;\\n\\n            }\\n        }\\n\\n        return ans + 2 * (n * n);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807666,
                "title": "easy-to-understand-solution-on-python-runtime-94-27",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\n        sumX, sumY, n, m = 0, 0, len(grid), len(grid[0])      \\n        \\n        sumZ = sum(1 for i, j in product(range(n), range(m)) if grid[i][j] > 0)\\n\\n        for row in grid:\\n            sumX += row[0]+row[-1]\\n            for i in range(1, m):\\n                sumX += abs(row[i]-row[i-1])    \\n        \\n        for column in zip(*grid):\\n            sumY += column[0]+column[-1]\\n            for i in range(1, n):\\n                sumY += abs(column[i]-column[i-1])\\n\\n        return sumX+sumY+sumZ*2\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\n        sumX, sumY, n, m = 0, 0, len(grid), len(grid[0])      \\n        \\n        sumZ = sum(1 for i, j in product(range(n), range(m)) if grid[i][j] > 0)\\n\\n        for row in grid:\\n            sumX += row[0]+row[-1]\\n            for i in range(1, m):\\n                sumX += abs(row[i]-row[i-1])    \\n        \\n        for column in zip(*grid):\\n            sumY += column[0]+column[-1]\\n            for i in range(1, n):\\n                sumY += abs(column[i]-column[i-1])\\n\\n        return sumX+sumY+sumZ*2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807246,
                "title": "97-faster-75-less-mem-simple-and-intuitive",
                "content": "# Intuition\\nLets focus on a single row.\\n\\n\\n```\\n             #\\n             #\\n             #       #\\n             #       #   #\\n         #   #       #   #    \\n  seq = [1,  5,  0,  3,  2]\\ndiff = 1,  4, -5,  3  -1  -2 \\n```\\nWhen we look from left to right the area is the sum of positive diffs.\\nWhen we look from right to left the area is the sum of negative diffs.\\nSum of all abs(prev,next) is the area of both.  \\n\\n# Approach\\nLet\\'s calculate the sum of abs diffs for all rows.\\nPlus same for all columns (note that `zip(*grid)` is transposed `grid`)\\nand finally lets add the area seen by birds (top veiw) twice (top+bottom).\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$Q(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        def sumdiffs(seq: List[int]) -> int:\\n            return sum(abs(b-a) for a, b in pairwise(seq)) + seq[0] + seq[-1] if len(seq) > 1 else 2 * seq[0]\\n        return sum(sumdiffs(row) for row in grid) + sum(sumdiffs(row) for row in zip(*grid)) + 2 * sum(1 for row in grid for val in row if val > 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n             #\\n             #\\n             #       #\\n             #       #   #\\n         #   #       #   #    \\n  seq = [1,  5,  0,  3,  2]\\ndiff = 1,  4, -5,  3  -1  -2 \\n```\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        def sumdiffs(seq: List[int]) -> int:\\n            return sum(abs(b-a) for a, b in pairwise(seq)) + seq[0] + seq[-1] if len(seq) > 1 else 2 * seq[0]\\n        return sum(sumdiffs(row) for row in grid) + sum(sumdiffs(row) for row in zip(*grid)) + 2 * sum(1 for row in grid for val in row if val > 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752991,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nAPPROACH:\\nFor a cell, the total area surface is the sum of area of all 6 faces of the cube, \\n6 Faces : [TOP, BOTTOM, LEFT, RIGHT, UP , DOWN]\\nif some faces are covered by adjacent cells, don\\'t consider in the area calculation \\n\\nALGORITHM (explanation)\\n1. Solve this problem cell-by-cell\\n2. For each cell, check its\\' adjacent cell in 4 direction:\\n    LEFT, RIGHT, UP, DOWN\\n    2.1. For each adjacent cell:\\n        2.1.1. If it exist (i.e. the height of adajacent not = 0)\\n            2.1.1.1 if current cell height > adjacent cell height\\n                2.1.1.1.1 AREA = AREA + (current cell height - adjacent cell height).1\\n        2.1.2. If it does not exist (i.e. the height of adajacent = 0)\\n            2.1.2.1 AREA = AREA + (current cell height).1\\n    2.2 if current cell height != 0\\n        2.2.1 AREA = AREA + 2 (i.e. the area of the lower face (1.1) and upper face (1.1) = 2)\\n```\\n\\n# Complexity\\nGrid dimension: $$m \\\\times n$$\\n- Time complexity: $$O(m\\\\cdot n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        direction = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        m, n = len(grid), len(grid[0])\\n        area = 0\\n        for i in range(m):\\n            for j in range(n):\\n                for x, y in direction:\\n                    if 0 <= i + x < m and 0 <= j + y < n:\\n                        if grid[i + x][j + y] != 0:\\n                            if grid[i][j] > grid[i + x][j + y]:\\n                                area += grid[i][j] - grid[i + x][j + y]\\n                        else:\\n                            area += grid[i][j]\\n                    else:\\n                        area += grid[i][j]\\n                if grid[i][j] != 0:\\n                    area += 2\\n        return area\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nAPPROACH:\\nFor a cell, the total area surface is the sum of area of all 6 faces of the cube, \\n6 Faces : [TOP, BOTTOM, LEFT, RIGHT, UP , DOWN]\\nif some faces are covered by adjacent cells, don\\'t consider in the area calculation \\n\\nALGORITHM (explanation)\\n1. Solve this problem cell-by-cell\\n2. For each cell, check its\\' adjacent cell in 4 direction:\\n    LEFT, RIGHT, UP, DOWN\\n    2.1. For each adjacent cell:\\n        2.1.1. If it exist (i.e. the height of adajacent not = 0)\\n            2.1.1.1 if current cell height > adjacent cell height\\n                2.1.1.1.1 AREA = AREA + (current cell height - adjacent cell height).1\\n        2.1.2. If it does not exist (i.e. the height of adajacent = 0)\\n            2.1.2.1 AREA = AREA + (current cell height).1\\n    2.2 if current cell height != 0\\n        2.2.1 AREA = AREA + 2 (i.e. the area of the lower face (1.1) and upper face (1.1) = 2)\\n```\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        direction = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n        m, n = len(grid), len(grid[0])\\n        area = 0\\n        for i in range(m):\\n            for j in range(n):\\n                for x, y in direction:\\n                    if 0 <= i + x < m and 0 <= j + y < n:\\n                        if grid[i + x][j + y] != 0:\\n                            if grid[i][j] > grid[i + x][j + y]:\\n                                area += grid[i][j] - grid[i + x][j + y]\\n                        else:\\n                            area += grid[i][j]\\n                    else:\\n                        area += grid[i][j]\\n                if grid[i][j] != 0:\\n                    area += 2\\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751414,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n    public int SurfaceArea(int[][] grid) {\\n        int count = 0;\\n        for(int i = 0; i < grid.Length; i++)\\n          for(int j = 0; j < grid[0].Length; j++)\\n            count += Calc(i,j,grid);\\n        return count;\\n    }\\n    private static int Calc(int i, int j, int[][] grid)\\n    {\\n      int n = grid[i][j];\\n      if(n == 0) return 0;\\n      int count = 0;\\n      count = n * 4 + 2;\\n      if(i != 0)\\n        count -= Math.Min(n, grid[i-1][j]);\\n      if(i != grid.Length - 1)\\n        count -= Math.Min(n, grid[i+1][j]);\\n      if(j != 0)\\n        count -= Math.Min(n, grid[i][j - 1]);\\n      if(j != grid[0].Length - 1)\\n        count -= Math.Min(n, grid[i][j + 1]);\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SurfaceArea(int[][] grid) {\\n        int count = 0;\\n        for(int i = 0; i < grid.Length; i++)\\n          for(int j = 0; j < grid[0].Length; j++)\\n            count += Calc(i,j,grid);\\n        return count;\\n    }\\n    private static int Calc(int i, int j, int[][] grid)\\n    {\\n      int n = grid[i][j];\\n      if(n == 0) return 0;\\n      int count = 0;\\n      count = n * 4 + 2;\\n      if(i != 0)\\n        count -= Math.Min(n, grid[i-1][j]);\\n      if(i != grid.Length - 1)\\n        count -= Math.Min(n, grid[i+1][j]);\\n      if(j != 0)\\n        count -= Math.Min(n, grid[i][j - 1]);\\n      if(j != grid[0].Length - 1)\\n        count -= Math.Min(n, grid[i][j + 1]);\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695404,
                "title": "kotlin-single-pass-solution",
                "content": "# Approach\\nLooping through every item in the array and calculate their surface area by checking if they are being blocked by any adjacent cude.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun surfaceArea(grid: Array<IntArray>): Int {\\n        var totalArea = 0\\n        val h = grid.size\\n        val w = grid[0].size\\n\\n        for (i in 0 until h) {\\n            for (j in 0 until w) {\\n\\n                // top and bottom surface area\\n                if (grid[i][j] > 0) totalArea += 2\\n\\n                // calculate surface area by checking the surrounding cube\\n                // checking top\\n                if (i-1 >= 0) {\\n                    if (grid[i][j] > grid[i-1][j]) totalArea += grid[i][j] - grid[i-1][j]\\n                } else {\\n                    totalArea += grid[i][j]\\n                }\\n\\n                // checking right\\n                if (j+1 < w) {\\n                    if (grid[i][j] >  grid[i][j+1]) totalArea += grid[i][j] - grid[i][j+1]\\n                } else {\\n                    totalArea += grid[i][j]\\n                }\\n\\n                // checking bottom\\n                if (i+1 < h) {\\n                    if (grid[i][j] > grid[i+1][j]) totalArea += grid[i][j] - grid[i+1][j]\\n                } else {\\n                    totalArea += grid[i][j]\\n                }\\n\\n                // checking left\\n                if (j-1 >= 0) {\\n                    if (grid[i][j] > grid[i][j-1]) totalArea += grid[i][j] - grid[i][j-1]\\n                } else {\\n                    totalArea += grid[i][j]\\n                }\\n\\n            }\\n        }\\n\\n        return totalArea\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun surfaceArea(grid: Array<IntArray>): Int {\\n        var totalArea = 0\\n        val h = grid.size\\n        val w = grid[0].size\\n\\n        for (i in 0 until h) {\\n            for (j in 0 until w) {\\n\\n                // top and bottom surface area\\n                if (grid[i][j] > 0) totalArea += 2\\n\\n                // calculate surface area by checking the surrounding cube\\n                // checking top\\n                if (i-1 >= 0) {\\n                    if (grid[i][j] > grid[i-1][j]) totalArea += grid[i][j] - grid[i-1][j]\\n                } else {\\n                    totalArea += grid[i][j]\\n                }\\n\\n                // checking right\\n                if (j+1 < w) {\\n                    if (grid[i][j] >  grid[i][j+1]) totalArea += grid[i][j] - grid[i][j+1]\\n                } else {\\n                    totalArea += grid[i][j]\\n                }\\n\\n                // checking bottom\\n                if (i+1 < h) {\\n                    if (grid[i][j] > grid[i+1][j]) totalArea += grid[i][j] - grid[i+1][j]\\n                } else {\\n                    totalArea += grid[i][j]\\n                }\\n\\n                // checking left\\n                if (j-1 >= 0) {\\n                    if (grid[i][j] > grid[i][j-1]) totalArea += grid[i][j] - grid[i][j-1]\\n                } else {\\n                    totalArea += grid[i][j]\\n                }\\n\\n            }\\n        }\\n\\n        return totalArea\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694788,
                "title": "surface-area-js-find-area-of-each-cell-63-ms",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar surfaceArea = function(grid) {\\n    n = grid.length - 1\\n    square = 0\\n\\n    for (let i = 0; i <= n; i++) {\\n        for (let j = 0; j <= n; j++) {\\n            if (i == 0) square += grid[i][j]            \\n            if (j == 0) square += grid[i][j]            \\n            if (i == n) square += grid[i][j]\\n            if (j == n) square += grid[i][j]\\n            \\n            if (grid[i][j] > 0) square += 2\\n\\n            if (i + 1 <= n) {                \\n                square += Math.abs(grid[i+1][j] - grid[i][j])\\n            }\\n            if (j + 1 <= n) {                \\n                square += Math.abs(grid[i][j+1] - grid[i][j])                \\n            }\\n        }\\n    }\\n    \\n    return square\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar surfaceArea = function(grid) {\\n    n = grid.length - 1\\n    square = 0\\n\\n    for (let i = 0; i <= n; i++) {\\n        for (let j = 0; j <= n; j++) {\\n            if (i == 0) square += grid[i][j]            \\n            if (j == 0) square += grid[i][j]            \\n            if (i == n) square += grid[i][j]\\n            if (j == n) square += grid[i][j]\\n            \\n            if (grid[i][j] > 0) square += 2\\n\\n            if (i + 1 <= n) {                \\n                square += Math.abs(grid[i+1][j] - grid[i][j])\\n            }\\n            if (j + 1 <= n) {                \\n                square += Math.abs(grid[i][j+1] - grid[i][j])                \\n            }\\n        }\\n    }\\n    \\n    return square\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657104,
                "title": "surface-area-of-3d-shapes-w-ua-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int n = grid.length;\\n        int surfaceArea = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int height = grid[i][j];\\n\\n                if (height > 0) {\\n                    // \\u041E\\u0431\\u0447\\u0438\\u0441\\u043B\\u044E\\u0454\\u043C\\u043E \\u043F\\u043B\\u043E\\u0449\\u0443 \\u043E\\u0441\\u043D\\u043E\\u0432\\u0438 \\u043A\\u0443\\u0431\\u0430\\n                    surfaceArea += 2;\\n\\n                    // \\u0414\\u043E\\u0434\\u0430\\u0454\\u043C\\u043E \\u043F\\u043B\\u043E\\u0449\\u0443 \\u0431\\u043E\\u043A\\u043E\\u0432\\u043E\\u0457 \\u043F\\u043E\\u0432\\u0435\\u0440\\u0445\\u043D\\u0456 \\u043A\\u0443\\u0431\\u0430\\n                    surfaceArea += 4 * height;\\n\\n                    // \\u0412\\u0456\\u0434\\u043D\\u0456\\u043C\\u0430\\u0454\\u043C\\u043E \\u043F\\u043B\\u043E\\u0449\\u0443, \\u044F\\u043A\\u0443 \\u0437\\u0430\\u043A\\u0440\\u0438\\u0432\\u0430\\u044E\\u0442\\u044C \\u0441\\u0443\\u0441\\u0456\\u0434\\u043D\\u0456 \\u043A\\u0443\\u0431\\u0438\\n                    if (i > 0) {\\n                        surfaceArea -= Math.min(height, grid[i - 1][j]);\\n                    }\\n                    if (i < n - 1) {\\n                        surfaceArea -= Math.min(height, grid[i + 1][j]);\\n                    }\\n                    if (j > 0) {\\n                        surfaceArea -= Math.min(height, grid[i][j - 1]);\\n                    }\\n                    if (j < n - 1) {\\n                        surfaceArea -= Math.min(height, grid[i][j + 1]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return surfaceArea;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int n = grid.length;\\n        int surfaceArea = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int height = grid[i][j];\\n\\n                if (height > 0) {\\n                    // \\u041E\\u0431\\u0447\\u0438\\u0441\\u043B\\u044E\\u0454\\u043C\\u043E \\u043F\\u043B\\u043E\\u0449\\u0443 \\u043E\\u0441\\u043D\\u043E\\u0432\\u0438 \\u043A\\u0443\\u0431\\u0430\\n                    surfaceArea += 2;\\n\\n                    // \\u0414\\u043E\\u0434\\u0430\\u0454\\u043C\\u043E \\u043F\\u043B\\u043E\\u0449\\u0443 \\u0431\\u043E\\u043A\\u043E\\u0432\\u043E\\u0457 \\u043F\\u043E\\u0432\\u0435\\u0440\\u0445\\u043D\\u0456 \\u043A\\u0443\\u0431\\u0430\\n                    surfaceArea += 4 * height;\\n\\n                    // \\u0412\\u0456\\u0434\\u043D\\u0456\\u043C\\u0430\\u0454\\u043C\\u043E \\u043F\\u043B\\u043E\\u0449\\u0443, \\u044F\\u043A\\u0443 \\u0437\\u0430\\u043A\\u0440\\u0438\\u0432\\u0430\\u044E\\u0442\\u044C \\u0441\\u0443\\u0441\\u0456\\u0434\\u043D\\u0456 \\u043A\\u0443\\u0431\\u0438\\n                    if (i > 0) {\\n                        surfaceArea -= Math.min(height, grid[i - 1][j]);\\n                    }\\n                    if (i < n - 1) {\\n                        surfaceArea -= Math.min(height, grid[i + 1][j]);\\n                    }\\n                    if (j > 0) {\\n                        surfaceArea -= Math.min(height, grid[i][j - 1]);\\n                    }\\n                    if (j < n - 1) {\\n                        surfaceArea -= Math.min(height, grid[i][j + 1]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return surfaceArea;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632894,
                "title": "c",
                "content": "check suurounding elements and update area accordingly\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int R, C, ans=0;\\n    int area(int row , int col , vector<vector<int>>& grid){\\n        int cur=0 , up, down, left, right;\\n\\n        if(!grid[row][col]) return cur;\\n        \\n        cur+=2;\\n\\n        if(row==0)      up=grid[row][col];\\n        else            up = grid[row][col]-grid[row-1][col];\\n        if(row==R-1)    down=grid[row][col];\\n        else            down = grid[row][col]-grid[row+1][col];\\n    \\n        if(col==0)      left=grid[row][col];\\n        else            left = grid[row][col]-grid[row][col-1];\\n        if(col==C-1)    right=grid[row][col];\\n        else            right = grid[row][col]-grid[row][col+1];\\n        \\n        if(up>0)    cur+=up;\\n        if(down>0)  cur+=down;\\n        if(left>0)  cur+=left;\\n        if(right>0) cur+=right;\\n        \\n        return cur;\\n    }\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        \\n        R=grid.size();\\n        C=grid[0].size();\\n        \\n        for(int i =0 ;i< R;i++){\\n            for(int  j =0 ;j< C ;j++){\\n                ans+=area(i,j,grid);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int R, C, ans=0;\\n    int area(int row , int col , vector<vector<int>>& grid){\\n        int cur=0 , up, down, left, right;\\n\\n        if(!grid[row][col]) return cur;\\n        \\n        cur+=2;\\n\\n        if(row==0)      up=grid[row][col];\\n        else            up = grid[row][col]-grid[row-1][col];\\n        if(row==R-1)    down=grid[row][col];\\n        else            down = grid[row][col]-grid[row+1][col];\\n    \\n        if(col==0)      left=grid[row][col];\\n        else            left = grid[row][col]-grid[row][col-1];\\n        if(col==C-1)    right=grid[row][col];\\n        else            right = grid[row][col]-grid[row][col+1];\\n        \\n        if(up>0)    cur+=up;\\n        if(down>0)  cur+=down;\\n        if(left>0)  cur+=left;\\n        if(right>0) cur+=right;\\n        \\n        return cur;\\n    }\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        \\n        R=grid.size();\\n        C=grid[0].size();\\n        \\n        for(int i =0 ;i< R;i++){\\n            for(int  j =0 ;j< C ;j++){\\n                ans+=area(i,j,grid);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627306,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        area = 0\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    area += 2\\n                    area += grid[i][j] if not i else max(grid[i][j]-grid[i-1][j], 0)\\n                    area += grid[i][j] if i==len(grid)-1 else max(grid[i][j]-grid[i+1][j], 0)\\n                    area += grid[i][j] if not j else max(grid[i][j]-grid[i][j-1], 0)\\n                    area += grid[i][j] if j==len(grid[0])-1 else max(grid[i][j]-grid[i][j+1], 0)\\n        \\n        return area\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        area = 0\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    area += 2\\n                    area += grid[i][j] if not i else max(grid[i][j]-grid[i-1][j], 0)\\n                    area += grid[i][j] if i==len(grid)-1 else max(grid[i][j]-grid[i+1][j], 0)\\n                    area += grid[i][j] if not j else max(grid[i][j]-grid[i][j-1], 0)\\n                    area += grid[i][j] if j==len(grid[0])-1 else max(grid[i][j]-grid[i][j+1], 0)\\n        \\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580446,
                "title": "java-simple-readable-100",
                "content": "```\\nclass Solution {\\n    public int surfaceArea(int[][] arr) {\\n        var sum=0;\\n        for (int i=0;i<arr.length;i++){\\n            for (int j=0;j<arr[0].length;j++){\\n                sum+=area(arr,i,j);\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    public int area(int[][] arr, int i, int j){\\n        var val = arr[i][j];\\n        if (val==0) return 0;\\n        var res = 2; //floor + ceiling\\n        if (i==0) res+=val; else res+=Math.max(0,val-arr[i-1][j]); //area to the top\\n        if (j==0) res+=val; else res+=Math.max(0,val-arr[i][j-1]); //area to the left\\n        if (i==arr.length-1)    res+=val; else res+=Math.max(0,val-arr[i+1][j]); //area to the bottom\\n        if (j==arr[0].length-1) res+=val; else res+=Math.max(0,val-arr[i][j+1]); //area to the right\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] arr) {\\n        var sum=0;\\n        for (int i=0;i<arr.length;i++){\\n            for (int j=0;j<arr[0].length;j++){\\n                sum+=area(arr,i,j);\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    public int area(int[][] arr, int i, int j){\\n        var val = arr[i][j];\\n        if (val==0) return 0;\\n        var res = 2; //floor + ceiling\\n        if (i==0) res+=val; else res+=Math.max(0,val-arr[i-1][j]); //area to the top\\n        if (j==0) res+=val; else res+=Math.max(0,val-arr[i][j-1]); //area to the left\\n        if (i==arr.length-1)    res+=val; else res+=Math.max(0,val-arr[i+1][j]); //area to the bottom\\n        if (j==arr[0].length-1) res+=val; else res+=Math.max(0,val-arr[i][j+1]); //area to the right\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507582,
                "title": "10-05-morning-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N**2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        total = 0\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j] > 0:\\n                    total+= 4 * grid[i][j] + 2\\n                    if j + 1 < len(grid):\\n                        total -= 2 * min(grid[i][j], grid[i][j+1])\\n                    if i + 1 < len(grid):\\n                        total -= 2 * min(grid[i][j], grid[i+1][j])\\n        \\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        total = 0\\n\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j] > 0:\\n                    total+= 4 * grid[i][j] + 2\\n                    if j + 1 < len(grid):\\n                        total -= 2 * min(grid[i][j], grid[i][j+1])\\n                    if i + 1 < len(grid):\\n                        total -= 2 * min(grid[i][j], grid[i+1][j])\\n        \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498579,
                "title": "simple-and-easy-javascript-solution",
                "content": "# Please upvote my solution\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar surfaceArea = function(grid) {\\n    let area = 0;\\n    for(let i = 0; i < grid.length; i++){\\n        for(let j = 0; j < grid.length; j++){\\n            area += 6 * grid[i][j];\\n            if(grid[i][j] > 1) area -= 2 * (grid[i][j] - 1);\\n            if(j - 1 >= 0) area -= Math.min(grid[i][j], grid[i][j - 1]);\\n            if(j + 1 < grid.length) area -= Math.min(grid[i][j], grid[i][j + 1]);\\n            if(i + 1 < grid.length) area -= Math.min(grid[i][j], grid[i + 1][j]);\\n            if(i - 1 >= 0) area -= Math.min(grid[i][j], grid[i - 1][j]);\\n        }\\n    }\\n    return area;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar surfaceArea = function(grid) {\\n    let area = 0;\\n    for(let i = 0; i < grid.length; i++){\\n        for(let j = 0; j < grid.length; j++){\\n            area += 6 * grid[i][j];\\n            if(grid[i][j] > 1) area -= 2 * (grid[i][j] - 1);\\n            if(j - 1 >= 0) area -= Math.min(grid[i][j], grid[i][j - 1]);\\n            if(j + 1 < grid.length) area -= Math.min(grid[i][j], grid[i][j + 1]);\\n            if(i + 1 < grid.length) area -= Math.min(grid[i][j], grid[i + 1][j]);\\n            if(i - 1 >= 0) area -= Math.min(grid[i][j], grid[i - 1][j]);\\n        }\\n    }\\n    return area;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3498442,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int res = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] > 0)\\n                {\\n                    res += (2 + 4 * grid[i][j]);\\n                }\\n                if ((i - 1) >= 0)\\n                {\\n                    res = res - (std::min(grid[i][j], grid[i - 1][j]));\\n                }\\n                if ((i + 1) < n)\\n                {\\n                    res = res - (std::min(grid[i][j], grid[i + 1][j]));\\n                }\\n                if ((j - 1) >= 0)\\n                {\\n                    res = res - (std::min(grid[i][j], grid[i][j - 1]));\\n                }\\n                if ((j + 1) < m)\\n                {\\n                    res = res - (std::min(grid[i][j], grid[i][j + 1]));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int res = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (grid[i][j] > 0)\\n                {\\n                    res += (2 + 4 * grid[i][j]);\\n                }\\n                if ((i - 1) >= 0)\\n                {\\n                    res = res - (std::min(grid[i][j], grid[i - 1][j]));\\n                }\\n                if ((i + 1) < n)\\n                {\\n                    res = res - (std::min(grid[i][j], grid[i + 1][j]));\\n                }\\n                if ((j - 1) >= 0)\\n                {\\n                    res = res - (std::min(grid[i][j], grid[i][j - 1]));\\n                }\\n                if ((j + 1) < m)\\n                {\\n                    res = res - (std::min(grid[i][j], grid[i][j + 1]));\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498106,
                "title": "solution-while-watching-yuru-camp-in-the-background",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int calcSurfaceAreaOfOneTower(int height) {\\n        if (height == 0) return 0;\\n        return 2 + (4*height);\\n    }\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int total = 0;\\n        int n = grid.size();\\n        for (int i = 0; i < n; i++) {\\n            vector<int> row = grid.at(i);\\n            for (int j = 0; j < n; j++) {\\n                int height = row.at(j);\\n                int local = calcSurfaceAreaOfOneTower(height);\\n\\n                // subtract (shared side w/ right) * 2\\n                if (j+1 < row.size()) {\\n                    int right = row.at(j+1);\\n                    local -= 2*min(height, right);\\n                }\\n\\n                // subtract (shared side w/ down) * 2\\n                if (i+1 < n) {\\n                    int down = grid.at(i+1).at(j);\\n                    local -= 2*min(height, down);\\n                }\\n\\n                total += local;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int calcSurfaceAreaOfOneTower(int height) {\\n        if (height == 0) return 0;\\n        return 2 + (4*height);\\n    }\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int total = 0;\\n        int n = grid.size();\\n        for (int i = 0; i < n; i++) {\\n            vector<int> row = grid.at(i);\\n            for (int j = 0; j < n; j++) {\\n                int height = row.at(j);\\n                int local = calcSurfaceAreaOfOneTower(height);\\n\\n                // subtract (shared side w/ right) * 2\\n                if (j+1 < row.size()) {\\n                    int right = row.at(j+1);\\n                    local -= 2*min(height, right);\\n                }\\n\\n                // subtract (shared side w/ down) * 2\\n                if (i+1 < n) {\\n                    int down = grid.at(i+1).at(j);\\n                    local -= 2*min(height, down);\\n                }\\n\\n                total += local;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469607,
                "title": "java-o-n-2-for-loop",
                "content": "# Code\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid.length; j++){\\n                area += 6 * grid[i][j];\\n\\n                if(grid[i][j] > 1){\\n                    area -= 2 * (grid[i][j] - 1);\\n                }\\n\\n                if(j - 1 >= 0){\\n                    area -= Math.min(grid[i][j], grid[i][j - 1]);\\n                }\\n                if(j + 1 < grid.length){\\n                    area -= Math.min(grid[i][j], grid[i][j + 1]);\\n                }\\n                if(i + 1 < grid.length){\\n                    area -= Math.min(grid[i][j], grid[i + 1][j]);\\n                }\\n                if(i - 1 >= 0){\\n                    area -= Math.min(grid[i][j], grid[i - 1][j]);\\n                }\\n            }\\n        }\\n\\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int area = 0;\\n\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid.length; j++){\\n                area += 6 * grid[i][j];\\n\\n                if(grid[i][j] > 1){\\n                    area -= 2 * (grid[i][j] - 1);\\n                }\\n\\n                if(j - 1 >= 0){\\n                    area -= Math.min(grid[i][j], grid[i][j - 1]);\\n                }\\n                if(j + 1 < grid.length){\\n                    area -= Math.min(grid[i][j], grid[i][j + 1]);\\n                }\\n                if(i + 1 < grid.length){\\n                    area -= Math.min(grid[i][j], grid[i + 1][j]);\\n                }\\n                if(i - 1 >= 0){\\n                    area -= Math.min(grid[i][j], grid[i - 1][j]);\\n                }\\n            }\\n        }\\n\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451730,
                "title": "python-dfs-like-solution",
                "content": "For each tower, get the surface area as if it were standing along by itself. Then to prevent double counting, subtract the minimum height between the current tower and all its \\'reachable\\' neighboring towers for the current tower under cotention. Sum along the way\\n\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        for each tower get the surface area as if it weren\\'t touch any other cube\\n        then look in all allowable directions and reduce the surface area by the amount of touches with other cubes\\n        surface area of tower if size k is:\\n            6*(k) - 2*(k-1)\\n        \\'\\'\\'\\n        def surface_area(k):\\n            if k == 0:\\n                return 0\\n            return 6*k - 2*(k-1)\\n        \\n        \\n        total_area = 0\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        dirrs = [(0,1),(0,-1),(1,0),(-1,0)]\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                #first get area as if standing alone\\n                curr_tower = surface_area(grid[i][j])\\n                #reduce area by neighboring towers\\n                for dx,dy in dirrs:\\n                    neigh_x = i + dx\\n                    neigh_y = j + dy\\n                    #bounds\\n                    if 0 <= neigh_x < rows and 0 <= neigh_y < cols:\\n                        #careful when taking away area\\n                        curr_tower -= min(grid[neigh_x][neigh_y],grid[i][j])\\n                \\n                total_area += curr_tower\\n        \\n        return total_area\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        \\'\\'\\'\\n        for each tower get the surface area as if it weren\\'t touch any other cube\\n        then look in all allowable directions and reduce the surface area by the amount of touches with other cubes\\n        surface area of tower if size k is:\\n            6*(k) - 2*(k-1)\\n        \\'\\'\\'\\n        def surface_area(k):\\n            if k == 0:\\n                return 0\\n            return 6*k - 2*(k-1)\\n        \\n        \\n        total_area = 0\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        dirrs = [(0,1),(0,-1),(1,0),(-1,0)]\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                #first get area as if standing alone\\n                curr_tower = surface_area(grid[i][j])\\n                #reduce area by neighboring towers\\n                for dx,dy in dirrs:\\n                    neigh_x = i + dx\\n                    neigh_y = j + dy\\n                    #bounds\\n                    if 0 <= neigh_x < rows and 0 <= neigh_y < cols:\\n                        #careful when taking away area\\n                        curr_tower -= min(grid[neigh_x][neigh_y],grid[i][j])\\n                \\n                total_area += curr_tower\\n        \\n        return total_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448396,
                "title": "c-surface-area-of-3d-shapes-solution-w-explanation",
                "content": "# Description\\nMy approach requires spatial imagination. Please keep in mind that i\\'m also not an expert in coding. (I hit 80ms Runtime and 39.7MB of Memory with my code)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvaluate the sides of each column, considering the bordering towers. We also need to add the top and bottom surface if necessary.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI decided that foreach tower i add the surface of the neigbouring rigth and bottom tower. for the towers that dont have two neigbouring towers just the bottom or rigth surface is calculated. the tower on the bottom rigth thus dont \"have\" a surface to be determined. Then we need to add the surface areas on the outer side of the complete grid. Also the top and bottom surface has to be added when the heigth of the tower is not 0.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SurfaceArea(int[][] grid)\\n    {\\n        int area = 0;\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            for (int j = 0; j < grid[i].Length; j++)\\n            {\\n                //adding top and bottom surface\\n                if (grid[i][j] != 0)\\n                    area += 2;  \\n\\n                //calculating the surface with the neighbouring towers, if existing\\n                if (i != grid.Length - 1 && j != grid[i].Length - 1)\\n                {\\n                    area += Math.Abs(grid[i][j] - grid[i + 1][j]);\\n                    area += Math.Abs(grid[i][j] - grid[i][j + 1]);\\n                }\\n                else if(!(i == grid.Length - 1 && j == grid[i].Length - 1))\\n                {\\n                    if (i == grid.Length - 1)\\n                        area += Math.Abs(grid[i][j] - grid[i][j + 1]);\\n                    else\\n                        area += Math.Abs(grid[i][j] - grid[i + 1][j]);\\n                }\\n\\n                //add the surface off the outer towers\\n                if (i == 0)\\n                    area += grid[i][j];\\n\\n                if (i == grid.Length - 1)\\n                    area += grid[i][j];\\n\\n                if (j == 0)\\n                    area += grid[i][j];\\n\\n                if (j == grid[i].Length - 1)\\n                    area += grid[i][j];\\n\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Math",
                    "Geometry",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int SurfaceArea(int[][] grid)\\n    {\\n        int area = 0;\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            for (int j = 0; j < grid[i].Length; j++)\\n            {\\n                //adding top and bottom surface\\n                if (grid[i][j] != 0)\\n                    area += 2;  \\n\\n                //calculating the surface with the neighbouring towers, if existing\\n                if (i != grid.Length - 1 && j != grid[i].Length - 1)\\n                {\\n                    area += Math.Abs(grid[i][j] - grid[i + 1][j]);\\n                    area += Math.Abs(grid[i][j] - grid[i][j + 1]);\\n                }\\n                else if(!(i == grid.Length - 1 && j == grid[i].Length - 1))\\n                {\\n                    if (i == grid.Length - 1)\\n                        area += Math.Abs(grid[i][j] - grid[i][j + 1]);\\n                    else\\n                        area += Math.Abs(grid[i][j] - grid[i + 1][j]);\\n                }\\n\\n                //add the surface off the outer towers\\n                if (i == 0)\\n                    area += grid[i][j];\\n\\n                if (i == grid.Length - 1)\\n                    area += grid[i][j];\\n\\n                if (j == 0)\\n                    area += grid[i][j];\\n\\n                if (j == grid[i].Length - 1)\\n                    area += grid[i][j];\\n\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443835,
                "title": "c-solution-easy-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int SurfaceArea(int[][] grid) {\\n        // 16  // total 34\\n\\n        int getCellVal(int row,int col){\\n            if(row < 0 || row >= grid.Length || col < 0 || col >= grid.Length)\\n                return 0;\\n            return grid[row][col];\\n        }\\n\\n        int[][] arr = new int[][]{new int[]{0,1}, new int[]{0,-1}, new int[]{1,0}, new int[]{-1,0}};\\n        int calcArea(int row,int col){\\n            if(grid[row][col] == 0) return 0;\\n            int area = 2; // for bottom & top\\n            for(int i = 0;i < arr.Length;i++) // for 4 side\\n                area+= Math.Max(0,grid[row][col] - getCellVal(row + arr[i][0],col + arr[i][1]));\\n            return area;\\n        }\\n\\n        int res = 0;\\n        for(int i = 0; i < grid.Length;i++)\\n            for(int j = 0; j < grid.Length;j++)\\n                res+= calcArea(i,j);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int SurfaceArea(int[][] grid) {\\n        // 16  // total 34\\n\\n        int getCellVal(int row,int col){\\n            if(row < 0 || row >= grid.Length || col < 0 || col >= grid.Length)\\n                return 0;\\n            return grid[row][col];\\n        }\\n\\n        int[][] arr = new int[][]{new int[]{0,1}, new int[]{0,-1}, new int[]{1,0}, new int[]{-1,0}};\\n        int calcArea(int row,int col){\\n            if(grid[row][col] == 0) return 0;\\n            int area = 2; // for bottom & top\\n            for(int i = 0;i < arr.Length;i++) // for 4 side\\n                area+= Math.Max(0,grid[row][col] - getCellVal(row + arr[i][0],col + arr[i][1]));\\n            return area;\\n        }\\n\\n        int res = 0;\\n        for(int i = 0; i < grid.Length;i++)\\n            for(int j = 0; j < grid.Length;j++)\\n                res+= calcArea(i,j);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440672,
                "title": "python-4-lines-minus-hidden-area",
                "content": "# Intuition\\nCalculate the total sum then substract the sum of all the adjacent edges.\\n\\n# Approach\\nWhile substracting the adjacent edges we need to substract 2 times of those (2*min(value, x[index+1])*1) because while generating the total area we counted the same adjacent edge TWICE!\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1) - Constant space\\n\\n# Code\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        total_area = sum([2*(1*1+y*1+y*1) if y>0 else 0 for x in grid for y in x])\\n        horizontal_sub_area = sum([2*min(value, x[index+1])*1 for x in grid for index, value in enumerate(x) if index<len(x)-1])\\n        vertical_sub_area = sum([2*min(value, x[index+1])*1 for x in zip(*grid) for index, value in enumerate(x) if index<len(x)-1])\\n        return total_area - (horizontal_sub_area + vertical_sub_area)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        total_area = sum([2*(1*1+y*1+y*1) if y>0 else 0 for x in grid for y in x])\\n        horizontal_sub_area = sum([2*min(value, x[index+1])*1 for x in grid for index, value in enumerate(x) if index<len(x)-1])\\n        vertical_sub_area = sum([2*min(value, x[index+1])*1 for x in zip(*grid) for index, value in enumerate(x) if index<len(x)-1])\\n        return total_area - (horizontal_sub_area + vertical_sub_area)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384409,
                "title": "calculating-surface-area-of-towers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf all the cubes were slightly separated, the total surface area would be 6 times the number of cubes, which we could calculate\\nby summing up the grid array.  However, in general the number\\nof faces of a cube is less than six, depending on its surrounding\\ncubes\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt the top level, sum the number of external faces on each \"tower\" above one grid square.  Unless the tower is 0 height (a corner case that bit me), each tower contributes two units of area for its bottom and top.  The area of the sides depends on the height of the tower and the heights of the 0-4 adjacent towers.  We break each tower\\'s area calculation down to each of the sides (North, South, East, West).  Let\\'s consider the North area of a given tower.  If the tower to its North is taller than the subject tower, then it contributes no \"North area\"; if the tower to the North is shorter than the subject tower, then the area contributed is the subject tower\\'s height minus that of the North tower.  If there is no North neighbor (i.e., the tower is in row 0), then the North area is the height of the tower.  The code is simple but long because it\\'s repeated for each of the cardinal directions.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs noted, we deal with one tower at a time, so the run time\\nis the numbers of squares in the grid times the time for one\\ntower, which is essentially fixed, hence the overall runtime is $$O(#rows*#cols)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nStorage used is just scalar variables, so $$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        totalArea = 0\\n        nRows = len( grid )\\n        nCols = len( grid[ 0 ] )\\n        # For each tower of cubes\\n        for iRow in range( nRows ):\\n            for iCol in range( nCols ):\\n                v = grid[ iRow ][ iCol ]\\n                # Always add one for the top face and one for the bottom except if tower is 0 high\\n                towerArea = 2 if v > 0 else 0                \\n                # Calculate surface area on North face:\\n                if iRow > 0:\\n                    vNorth = grid[ iRow - 1][ iCol ]\\n                    if v > vNorth:\\n                        towerArea += v - vNorth\\n                else:\\n                    towerArea += v\\n                # On South face:\\n                if iRow < nRows - 1:\\n                    vSouth = grid[ iRow + 1][ iCol ]\\n                    if v > vSouth:\\n                        towerArea += v - vSouth\\n                else:\\n                    towerArea += v\\n                # On West face:\\n                if iCol > 0:\\n                    vWest = grid[ iRow ][ iCol - 1 ]\\n                    if v > vWest:\\n                        towerArea += v - vWest\\n                else:\\n                    towerArea += v\\n                # On East face\\n                if iCol < nCols - 1:\\n                    vEast = grid[ iRow ][ iCol + 1 ]\\n                    if v > vEast:\\n                        towerArea += v - vEast\\n                else:\\n                    towerArea += v\\n                totalArea += towerArea\\n\\n        return totalArea\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        totalArea = 0\\n        nRows = len( grid )\\n        nCols = len( grid[ 0 ] )\\n        # For each tower of cubes\\n        for iRow in range( nRows ):\\n            for iCol in range( nCols ):\\n                v = grid[ iRow ][ iCol ]\\n                # Always add one for the top face and one for the bottom except if tower is 0 high\\n                towerArea = 2 if v > 0 else 0                \\n                # Calculate surface area on North face:\\n                if iRow > 0:\\n                    vNorth = grid[ iRow - 1][ iCol ]\\n                    if v > vNorth:\\n                        towerArea += v - vNorth\\n                else:\\n                    towerArea += v\\n                # On South face:\\n                if iRow < nRows - 1:\\n                    vSouth = grid[ iRow + 1][ iCol ]\\n                    if v > vSouth:\\n                        towerArea += v - vSouth\\n                else:\\n                    towerArea += v\\n                # On West face:\\n                if iCol > 0:\\n                    vWest = grid[ iRow ][ iCol - 1 ]\\n                    if v > vWest:\\n                        towerArea += v - vWest\\n                else:\\n                    towerArea += v\\n                # On East face\\n                if iCol < nCols - 1:\\n                    vEast = grid[ iRow ][ iCol + 1 ]\\n                    if v > vEast:\\n                        towerArea += v - vEast\\n                else:\\n                    towerArea += v\\n                totalArea += towerArea\\n\\n        return totalArea\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376491,
                "title": "java-solution-90-runtime-with-full-solution-and-description",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I saw this question, I thought 2 diffrent solutions. One is with calculating directly. Second is calculating the whole area and subtracting the adjacent areas.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is the second solution. First I declared two Integer values: totalSurfaceArea, len. It is crystal clear that what they used for. After, I initialized two for loops to loop through the whole grid and check for cubes in each cell.\\n\\nIn first If block, I checked if there is any cubes in cell. If there is, I added the are of cubes like they are a single tower. (For example, 1 cube have 6 units of surface area, 2 cube 10, 3 cube 14. As you can see they have a stable increment. So the formula is area = 6 * cubeCount - 2 * cubeCount) I used the formula for calculating units in a tower. After that, I subtract the hidden areas horizontally. The idea behind the method I use to subtract is: I sent two adjacent block to Math.min() method (Math.min() method compares two arguments and finds the lowest.) And subtract from two sides by multiplying two. (I select the lower tower and subtract Its surfaces two times.) I also did the same on the other. Just vertically.\\n# Complexity\\n- Time complexity:$$O(n\\xB2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: idk\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int totalSurfaceArea = 0;\\n        int len = grid.length;\\n        for (int i = 0; i<len; i++){\\n            for (int j = 0; j<len; j++){\\n                if (grid[i][j] > 0){\\n                    totalSurfaceArea += 6 * grid[i][j] - 2*(grid[i][j] - 1);\\n                } \\n                if (i>0){\\n                    totalSurfaceArea -= 2 * Math.min(grid[i-1][j], grid[i][j]);\\n                }\\n                if (j>0){\\n                    totalSurfaceArea -= 2 * Math.min(grid[i][j-1], grid[i][j]);\\n                }\\n            }\\n        }\\n        return totalSurfaceArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int totalSurfaceArea = 0;\\n        int len = grid.length;\\n        for (int i = 0; i<len; i++){\\n            for (int j = 0; j<len; j++){\\n                if (grid[i][j] > 0){\\n                    totalSurfaceArea += 6 * grid[i][j] - 2*(grid[i][j] - 1);\\n                } \\n                if (i>0){\\n                    totalSurfaceArea -= 2 * Math.min(grid[i-1][j], grid[i][j]);\\n                }\\n                if (j>0){\\n                    totalSurfaceArea -= 2 * Math.min(grid[i][j-1], grid[i][j]);\\n                }\\n            }\\n        }\\n        return totalSurfaceArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375899,
                "title": "c-easy-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int res=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    res+=2; // 1 for up, 1 for down\\n                    res+=fun(grid,i-1,j,grid[i][j]);// left\\n                    res+=fun(grid,i,j-1,grid[i][j]);// front\\n                    res+=fun(grid,i+1,j,grid[i][j]);// right\\n                    res+=fun(grid,i,j+1,grid[i][j]);// back\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& grid,int i,int j,int val)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return val;// if no adjacent cube then total area is contributed\\n        \\n        if(grid[i][j]<val) // if neighbour cube is there then the diff is contributed\\n            return val-grid[i][j];\\n        \\n        return 0; // if the current is smaller than its neighbour, no contribution\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int res=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    res+=2; // 1 for up, 1 for down\\n                    res+=fun(grid,i-1,j,grid[i][j]);// left\\n                    res+=fun(grid,i,j-1,grid[i][j]);// front\\n                    res+=fun(grid,i+1,j,grid[i][j]);// right\\n                    res+=fun(grid,i,j+1,grid[i][j]);// back\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& grid,int i,int j,int val)\\n    {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return val;// if no adjacent cube then total area is contributed\\n        \\n        if(grid[i][j]<val) // if neighbour cube is there then the diff is contributed\\n            return val-grid[i][j];\\n        \\n        return 0; // if the current is smaller than its neighbour, no contribution\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354762,
                "title": "simple-approach-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI have counted lost areas and substracted from the original area\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def surfaceArea(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n=len(grid)\\n        base=sum([2+4*ch for ele in grid for ch in ele if ch!=0])\\n\\n        total=0\\n        for i in range(n):\\n            for j in range(n):\\n                if i+1 < n :\\n                    if (grid[i+1][j]-grid[i][j])>=0:\\n                        total-=(grid[i][j])\\n                    else:\\n                        total-=(grid[i+1][j])\\n                if i-1 >= 0 :\\n                    if (grid[i-1][j]-grid[i][j])>=0:\\n                        total-=(grid[i][j])\\n                    else:\\n                        total-=(grid[i-1][j])\\n                if j+1 < n :\\n                    if (grid[i][j+1]-grid[i][j])>=0:\\n                        total-=(grid[i][j])\\n                    else:\\n                        total-=(grid[i][j+1])\\n                if j-1 >= 0 :\\n                    if (grid[i][j-1]-grid[i][j])>=0:\\n                        total-=(grid[i][j])\\n                    else:\\n                        total-=(grid[i][j-1])\\n\\n        return base+total\\n                \\n            \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def surfaceArea(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n=len(grid)\\n        base=sum([2+4*ch for ele in grid for ch in ele if ch!=0])\\n\\n        total=0\\n        for i in range(n):\\n            for j in range(n):\\n                if i+1 < n :\\n                    if (grid[i+1][j]-grid[i][j])>=0:\\n                        total-=(grid[i][j])\\n                    else:\\n                        total-=(grid[i+1][j])\\n                if i-1 >= 0 :\\n                    if (grid[i-1][j]-grid[i][j])>=0:\\n                        total-=(grid[i][j])\\n                    else:\\n                        total-=(grid[i-1][j])\\n                if j+1 < n :\\n                    if (grid[i][j+1]-grid[i][j])>=0:\\n                        total-=(grid[i][j])\\n                    else:\\n                        total-=(grid[i][j+1])\\n                if j-1 >= 0 :\\n                    if (grid[i][j-1]-grid[i][j])>=0:\\n                        total-=(grid[i][j])\\n                    else:\\n                        total-=(grid[i][j-1])\\n\\n        return base+total\\n                \\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334775,
                "title": "java-simple-solution-o-n-2",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int surfaceArea(int[][] grid) {\\n        int n = grid.length;\\n        int area = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] > 0) {\\n                    area += grid[i][j] * 4 + 2;\\n                }\\n\\n                if (i > 0) {\\n                    area -= Math.min(grid[i][j], grid[i - 1][j]) * 2;\\n                }\\n                if (j > 0) {\\n                    area -= Math.min(grid[i][j], grid[i][j - 1]) * 2;\\n                }\\n            }\\n        }\\n\\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Geometry",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int surfaceArea(int[][] grid) {\\n        int n = grid.length;\\n        int area = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] > 0) {\\n                    area += grid[i][j] * 4 + 2;\\n                }\\n\\n                if (i > 0) {\\n                    area -= Math.min(grid[i][j], grid[i - 1][j]) * 2;\\n                }\\n                if (j > 0) {\\n                    area -= Math.min(grid[i][j], grid[i][j - 1]) * 2;\\n                }\\n            }\\n        }\\n\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283080,
                "title": "solution-with-a-detailed-explanation",
                "content": "# Intuition\\nLets call the number of cubes on the tile its height.\\nTo calculate the surface of a tile that has no neighbours we will do this math 6 + (height - 1) * 4.\\nIf it has a neighbour, it means that neigbour will cover its surface on the side, up to the neighbour\\'s height. Which means we have to substract the neighbours height from the tiles surface. \\n\\n# Approach\\n1. Initialize the resut count and iterate over martix\\n2. Calc surface for each tile as if it was a standalone tile with no neighbours\\n3. Check the height of each neighbour\\n4. Subtract the height of each neighbour from the standalone\\'s surface. (Be careful not to subtract more than the height of the tile itself)\\n5. Add the remained to the result\\n\\n# Complexity\\n- Time complexity:\\nO(n * m) we iterate over the matrix one, doing exaclty 4 checks for each tile\\n\\n- Space complexity:\\n O(1) no extra space is used\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar surfaceArea = function(grid) {\\n    let res = 0 \\n\\n    const n = grid.length \\n    const m = grid[0].length\\n\\n    const countSurface = (z) => {\\n        if (!z) return 0\\n        return 6 + ((z-1)*4)\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            let standAloneSize = countSurface(grid[i][j])\\n\\n            const leftN = grid[i][j-1] || 0\\n            standAloneSize -= Math.min(grid[i][j], leftN)\\n\\n            const rightN = grid[i][j+1] || 0\\n            standAloneSize -= Math.min(grid[i][j], rightN)\\n\\n            const upN = i -1 >= 0 ? grid[i-1][j] : 0\\n            standAloneSize -= Math.min(grid[i][j], upN)\\n\\n            const bottomN = i + 1 < n ? grid[i+1][j] : 0\\n            standAloneSize -= Math.min(grid[i][j], bottomN)\\n\\n            res += standAloneSize\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar surfaceArea = function(grid) {\\n    let res = 0 \\n\\n    const n = grid.length \\n    const m = grid[0].length\\n\\n    const countSurface = (z) => {\\n        if (!z) return 0\\n        return 6 + ((z-1)*4)\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            let standAloneSize = countSurface(grid[i][j])\\n\\n            const leftN = grid[i][j-1] || 0\\n            standAloneSize -= Math.min(grid[i][j], leftN)\\n\\n            const rightN = grid[i][j+1] || 0\\n            standAloneSize -= Math.min(grid[i][j], rightN)\\n\\n            const upN = i -1 >= 0 ? grid[i-1][j] : 0\\n            standAloneSize -= Math.min(grid[i][j], upN)\\n\\n            const bottomN = i + 1 < n ? grid[i+1][j] : 0\\n            standAloneSize -= Math.min(grid[i][j], bottomN)\\n\\n            res += standAloneSize\\n        }\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266853,
                "title": "javascript-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar surfaceArea = function(grid) {\\n    const n = grid.length\\n    let res = 0\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let currentV = grid[i][j]\\n            let area = 2 + 4 * currentV\\n            if (currentV > 0) {\\n                // up\\n                if (i - 1 >= 0 && grid[i - 1][j] > 0) {\\n                    let diff = currentV - grid[i - 1][j]\\n                    area -= diff < 0 ? currentV : grid[i - 1][j]\\n                }\\n                // down\\n                if (i + 1 < n && grid[i + 1][j] > 0) {\\n                    let diff = currentV - grid[i + 1][j]\\n                    area -= diff < 0 ? currentV : grid[i + 1][j]\\n                }\\n                // left\\n                if (j - 1 >= 0 && grid[i][j - 1] > 0) {\\n                    let diff = currentV - grid[i][j - 1]\\n                    area -= diff < 0 ? currentV : grid[i][j - 1]\\n                }\\n                // right\\n                if (j + 1 < n && grid[i][j + 1] > 0) {\\n                    let diff = currentV - grid[i][j + 1]\\n                    area -= diff < 0 ? currentV : grid[i][j + 1]\\n                }\\n            res += area\\n            }\\n        }\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar surfaceArea = function(grid) {\\n    const n = grid.length\\n    let res = 0\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let currentV = grid[i][j]\\n            let area = 2 + 4 * currentV\\n            if (currentV > 0) {\\n                // up\\n                if (i - 1 >= 0 && grid[i - 1][j] > 0) {\\n                    let diff = currentV - grid[i - 1][j]\\n                    area -= diff < 0 ? currentV : grid[i - 1][j]\\n                }\\n                // down\\n                if (i + 1 < n && grid[i + 1][j] > 0) {\\n                    let diff = currentV - grid[i + 1][j]\\n                    area -= diff < 0 ? currentV : grid[i + 1][j]\\n                }\\n                // left\\n                if (j - 1 >= 0 && grid[i][j - 1] > 0) {\\n                    let diff = currentV - grid[i][j - 1]\\n                    area -= diff < 0 ? currentV : grid[i][j - 1]\\n                }\\n                // right\\n                if (j + 1 < n && grid[i][j + 1] > 0) {\\n                    let diff = currentV - grid[i][j + 1]\\n                    area -= diff < 0 ? currentV : grid[i][j + 1]\\n                }\\n            res += area\\n            }\\n        }\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3254574,
                "title": "javascript-count-all-sides",
                "content": "- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(1)\\n\\n```\\nfunction surfaceArea(grid: number[][]): number {\\n    let total = 0;\\n    const lenSide = grid.length;\\n\\n    for (let i = 0; i < lenSide; i++) {\\n        for (let j = 0; j < lenSide; j++) {\\n            const current = grid[i][j];\\n            const top = grid[i - 1] ? grid[i - 1][j] : 0;\\n            const left = grid[i][j - 1] || 0;\\n            const bottom = grid[i + 1] ? grid[i + 1][j] : 0;\\n            const right = grid[i][j + 1] || 0;\\n\\n            if (current > top) {\\n                total += current - top;\\n            }\\n\\n            if (current > left) {\\n                total += current - left;\\n            }\\n\\n            if (current > bottom) {\\n                total += current - bottom;\\n            }\\n\\n            if (current > right) {\\n                total += current - right;\\n            }\\n\\n            if (current > 0) {\\n                total += 2;\\n            }\\n        }\\n    }\\n\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction surfaceArea(grid: number[][]): number {\\n    let total = 0;\\n    const lenSide = grid.length;\\n\\n    for (let i = 0; i < lenSide; i++) {\\n        for (let j = 0; j < lenSide; j++) {\\n            const current = grid[i][j];\\n            const top = grid[i - 1] ? grid[i - 1][j] : 0;\\n            const left = grid[i][j - 1] || 0;\\n            const bottom = grid[i + 1] ? grid[i + 1][j] : 0;\\n            const right = grid[i][j + 1] || 0;\\n\\n            if (current > top) {\\n                total += current - top;\\n            }\\n\\n            if (current > left) {\\n                total += current - left;\\n            }\\n\\n            if (current > bottom) {\\n                total += current - bottom;\\n            }\\n\\n            if (current > right) {\\n                total += current - right;\\n            }\\n\\n            if (current > 0) {\\n                total += 2;\\n            }\\n        }\\n    }\\n\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3166476,
                "title": "simple-ruby",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach tower contributes its height 4 times, but we need to remove the coliding areas, that is two times the minimum area (or height) of each pair of coliding sides of the adjacent towers. Als each tower contributes 2 for the floor and ceiling, if the height is not 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate over all the grid checking adjacent cells and remove the minimum height between them\\n\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef surface_area(grid)\\n  area = 0\\n  z = grid.size - 1\\n  for i in (0..z)\\n    for j in (0..z)\\n      next if grid[i][j] == 0\\n\\n      area += 2 # xy area\\n      area += 4 * grid[i][j] # xz, yz areas including glued parts\\n\\n      # remove minimum of each pair of collisioned areas.\\n      area -= [grid[i][j], grid[i - 1][j]].min if i > 0\\n      area -= [grid[i][j], grid[i + 1][j]].min if i < z\\n      area -= [grid[i][j], grid[i][j - 1]].min if j > 0\\n      area -= [grid[i][j], grid[i][j + 1]].min if j < z\\n    end\\n  end\\n  area\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef surface_area(grid)\\n  area = 0\\n  z = grid.size - 1\\n  for i in (0..z)\\n    for j in (0..z)\\n      next if grid[i][j] == 0\\n\\n      area += 2 # xy area\\n      area += 4 * grid[i][j] # xz, yz areas including glued parts\\n\\n      # remove minimum of each pair of collisioned areas.\\n      area -= [grid[i][j], grid[i - 1][j]].min if i > 0\\n      area -= [grid[i][j], grid[i + 1][j]].min if i < z\\n      area -= [grid[i][j], grid[i][j - 1]].min if j > 0\\n      area -= [grid[i][j], grid[i][j + 1]].min if j < z\\n    end\\n  end\\n  area\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3161472,
                "title": "js-ts-easy-solution-beats-100",
                "content": "# Intuition\\nCalculate the area of the tower of cubes but subtract all the covered faces nearby.\\n\\n# Approach\\nIterate over the whole matrix. The full area of the tower by itself is $$4 * height + 2$$, but then you need to subtract the faces that are covered by other towers. To this this, you need to check the nearby cells (if they exist) and subtract $$n$$ faces, with $$n$$ that is the smallest $$height$$ between the two towers.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfunction surfaceArea(grid: number[][]): number {\\n    let totalArea: number = 0;\\n    for (let i: number = 0; i < grid.length; i++) {\\n        for (let j: number = 0; j < grid[i].length; j++) {\\n            const cell = grid[i][j];\\n            if (cell === 0) continue;\\n            let towerArea = 4 * cell + 2;\\n            if (grid[i+1]) towerArea -= Math.min(cell, grid[i+1][j]);\\n            if (grid[i-1]) towerArea -= Math.min(cell, grid[i-1][j]);\\n            if (grid[i][j+1]) towerArea -= Math.min(cell, grid[i][j+1]);\\n            if (grid[i][j-1]) towerArea -= Math.min(cell, grid[i][j-1]);\\n            totalArea += towerArea;\\n        }\\n    }\\n    return totalArea;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction surfaceArea(grid: number[][]): number {\\n    let totalArea: number = 0;\\n    for (let i: number = 0; i < grid.length; i++) {\\n        for (let j: number = 0; j < grid[i].length; j++) {\\n            const cell = grid[i][j];\\n            if (cell === 0) continue;\\n            let towerArea = 4 * cell + 2;\\n            if (grid[i+1]) towerArea -= Math.min(cell, grid[i+1][j]);\\n            if (grid[i-1]) towerArea -= Math.min(cell, grid[i-1][j]);\\n            if (grid[i][j+1]) towerArea -= Math.min(cell, grid[i][j+1]);\\n            if (grid[i][j-1]) towerArea -= Math.min(cell, grid[i][j-1]);\\n            totalArea += towerArea;\\n        }\\n    }\\n    return totalArea;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3107123,
                "title": "c-minimal-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int area = 0;\\n        for(auto& row : grid) { \\n            auto get = [&row](int i) { return i < 0 || i >= row.size() ? 0 : row[i]; };\\n            for(int i = -1, j = 0; j <= row.size(); ++i, ++j)\\n                area += abs(get(i) - get(j)) + (get(i) ? 2 : 0);//horizontal side, top, bottom\\n        }\\n        for(int c = 0; c < grid.front().size(); ++c) {\\n            auto get = [&grid, c](int i) { return i < 0 || i >= grid.size() ? 0 : grid[i][c]; };\\n            for(int i = -1, j = 0; j <= grid.size(); ++i, ++j)\\n                area += abs(get(i) - get(j)); //vertical side\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int area = 0;\\n        for(auto& row : grid) { \\n            auto get = [&row](int i) { return i < 0 || i >= row.size() ? 0 : row[i]; };\\n            for(int i = -1, j = 0; j <= row.size(); ++i, ++j)\\n                area += abs(get(i) - get(j)) + (get(i) ? 2 : 0);//horizontal side, top, bottom\\n        }\\n        for(int c = 0; c < grid.front().size(); ++c) {\\n            auto get = [&grid, c](int i) { return i < 0 || i >= grid.size() ? 0 : grid[i][c]; };\\n            for(int i = -1, j = 0; j <= grid.size(); ++i, ++j)\\n                area += abs(get(i) - get(j)); //vertical side\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102780,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        const auto m = grid.size(), n = grid.begin()->size();\\n        auto surface = 0;\\n        for (auto i = 0; i < m; ++i) {\\n            for (auto j = 0; j < n; ++j) {\\n                if (grid[i][j]) {\\n                    surface += 2;\\n                    if (i == 0) surface += grid[i][j];\\n                    if (j == 0) surface += grid[i][j];\\n                    if (i == m - 1) surface += grid[i][j];\\n                    if (j == n - 1) surface += grid[i][j];\\n                }\\n                if (i > 0) surface += abs(grid[i - 1][j] - grid[i][j]);\\n                if (j > 0) surface += abs(grid[i][j - 1] - grid[i][j]);\\n            }\\n        }\\n        return surface;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        const auto m = grid.size(), n = grid.begin()->size();\\n        auto surface = 0;\\n        for (auto i = 0; i < m; ++i) {\\n            for (auto j = 0; j < n; ++j) {\\n                if (grid[i][j]) {\\n                    surface += 2;\\n                    if (i == 0) surface += grid[i][j];\\n                    if (j == 0) surface += grid[i][j];\\n                    if (i == m - 1) surface += grid[i][j];\\n                    if (j == n - 1) surface += grid[i][j];\\n                }\\n                if (i > 0) surface += abs(grid[i - 1][j] - grid[i][j]);\\n                if (j > 0) surface += abs(grid[i][j - 1] - grid[i][j]);\\n            }\\n        }\\n        return surface;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080141,
                "title": "my-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int result = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            int xz = 0, yz = 0, diffVer = 0, diffHor = 0;\\n            for (int j = 0; j < grid[i].length; j++) {\\n                result += grid[i][j] > 0 ? 2 : 0;\\n                if (j != 0 && grid[i][j] < grid[i][j - 1]) {\\n                    diffHor += grid[i][j - 1] - grid[i][j];\\n                } else if (j != 0 && grid[i][j] > grid[i][j - 1]) {\\n                    result += Math.min(grid[i][j] - grid[i][j - 1], diffHor) * 2;\\n                    diffHor -= Math.min(grid[i][j] - grid[i][j - 1], diffHor);\\n                }\\n                if (j != 0 && grid[j][i] < grid[j - 1][i]) {\\n                    diffVer += grid[j - 1][i] - grid[j][i];\\n                } else if (j != 0 && grid[j][i] > grid[j - 1][i]) {\\n                    result += Math.min(grid[j][i] - grid[j - 1][i], diffVer) * 2;\\n                    diffVer -= Math.min(grid[j][i] - grid[j - 1][i], diffVer);\\n                }\\n                xz = Math.max(grid[i][j], xz);\\n                yz = Math.max(grid[j][i], yz);\\n            }\\n            result += (xz * 2) + (yz * 2);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int result = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            int xz = 0, yz = 0, diffVer = 0, diffHor = 0;\\n            for (int j = 0; j < grid[i].length; j++) {\\n                result += grid[i][j] > 0 ? 2 : 0;\\n                if (j != 0 && grid[i][j] < grid[i][j - 1]) {\\n                    diffHor += grid[i][j - 1] - grid[i][j];\\n                } else if (j != 0 && grid[i][j] > grid[i][j - 1]) {\\n                    result += Math.min(grid[i][j] - grid[i][j - 1], diffHor) * 2;\\n                    diffHor -= Math.min(grid[i][j] - grid[i][j - 1], diffHor);\\n                }\\n                if (j != 0 && grid[j][i] < grid[j - 1][i]) {\\n                    diffVer += grid[j - 1][i] - grid[j][i];\\n                } else if (j != 0 && grid[j][i] > grid[j - 1][i]) {\\n                    result += Math.min(grid[j][i] - grid[j - 1][i], diffVer) * 2;\\n                    diffVer -= Math.min(grid[j][i] - grid[j - 1][i], diffVer);\\n                }\\n                xz = Math.max(grid[i][j], xz);\\n                yz = Math.max(grid[j][i], yz);\\n            }\\n            result += (xz * 2) + (yz * 2);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072140,
                "title": "java-2-ms-98-75-beats-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe total surface area of cubves was calculated and then total kissing surface areas were subtracted from that.\\n# Complexity\\n- Time complexity:\\n2 ms (beats %98.75)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n42.2 mb (beats %63.75)\\n# Code\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int sum=0;\\n        //calculate the total surfaces of the cubes\\n        //1 cube has got 6 surfaces\\n        for(int i=0;i<grid.length;++i){\\n            for(int j=0;j<grid[i].length;++j){\\n                sum=sum+6*grid[i][j];\\n            }\\n        }\\n\\n        //calculate total kissing surfaces in x-axis of neighbour cubes\\n        //then subtract that area from total area \\n        for(int i=0;i<grid.length;++i){\\n            for(int j=0;j<grid[i].length;++j){               \\n                \\n                if(j+1<grid.length&&grid[i][j]>0){\\n                    int a=2*Math.min(grid[i][j],grid[i][j+1]);\\n                    sum=sum-a;\\n                }\\n            }\\n        } \\n        //calculate total kissing surfaces in y-axis of neighbour cubes\\n        //then subtract that area from total area        \\n        for(int i=0;i<grid.length;++i){\\n            for(int j=0;j<grid[i].length;++j){\\n                \\n                if(i+1<grid.length&&grid[i+1][j]>0){\\n                    int b=2*Math.min(grid[i][j],grid[i+1][j]);\\n                    sum=sum-b;\\n                }\\n                  \\n            }\\n        }\\n\\n        //calculate the kissing surfaces of cubes in a row\\n        //then subtract that area from total area\\n        for(int i=0;i<grid.length;++i){\\n            for(int j=0;j<grid[i].length;++j){   \\n                if(grid[i][j]>1){\\n                    sum=sum-2*(grid[i][j]-1);\\n                } \\n            }\\n        }\\n               \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int sum=0;\\n        //calculate the total surfaces of the cubes\\n        //1 cube has got 6 surfaces\\n        for(int i=0;i<grid.length;++i){\\n            for(int j=0;j<grid[i].length;++j){\\n                sum=sum+6*grid[i][j];\\n            }\\n        }\\n\\n        //calculate total kissing surfaces in x-axis of neighbour cubes\\n        //then subtract that area from total area \\n        for(int i=0;i<grid.length;++i){\\n            for(int j=0;j<grid[i].length;++j){               \\n                \\n                if(j+1<grid.length&&grid[i][j]>0){\\n                    int a=2*Math.min(grid[i][j],grid[i][j+1]);\\n                    sum=sum-a;\\n                }\\n            }\\n        } \\n        //calculate total kissing surfaces in y-axis of neighbour cubes\\n        //then subtract that area from total area        \\n        for(int i=0;i<grid.length;++i){\\n            for(int j=0;j<grid[i].length;++j){\\n                \\n                if(i+1<grid.length&&grid[i+1][j]>0){\\n                    int b=2*Math.min(grid[i][j],grid[i+1][j]);\\n                    sum=sum-b;\\n                }\\n                  \\n            }\\n        }\\n\\n        //calculate the kissing surfaces of cubes in a row\\n        //then subtract that area from total area\\n        for(int i=0;i<grid.length;++i){\\n            for(int j=0;j<grid[i].length;++j){   \\n                if(grid[i][j]>1){\\n                    sum=sum-2*(grid[i][j]-1);\\n                } \\n            }\\n        }\\n               \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066376,
                "title": "fast-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind solution is to calculate the surface area of each cube and add them up to get the total surface area.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe loop through each cube and calculate the surface area of that cube. If the cube is a non-zero cube, we add 2 to the total surface area. We then check if the cube is the leftmost, rightmost, topmost, or bottommost cube on the grid. If it is, we add the value of the cube to the total surface area. If it is not, we add the difference between the current cube and the adjacent cube to the total surface area. Finally, we return the total surface area.\\n# Complexity\\n- Time complexity: O(n^2) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nas we are looping through all cubes in the grid\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nas we are not using any extra space.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] > 0) ans += 2;\\n                if (i == 0) ans += grid[i][j];\\n                else ans += max(grid[i][j] - grid[i - 1][j], 0);\\n                if (i == n - 1) ans += grid[i][j];\\n                else ans += max(grid[i][j] - grid[i + 1][j], 0);\\n                if (j == 0) ans += grid[i][j];\\n                else ans += max(grid[i][j] - grid[i][j - 1], 0);\\n                if (j == n - 1) ans += grid[i][j];\\n                else ans += max(grid[i][j] - grid[i][j + 1], 0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] > 0) ans += 2;\\n                if (i == 0) ans += grid[i][j];\\n                else ans += max(grid[i][j] - grid[i - 1][j], 0);\\n                if (i == n - 1) ans += grid[i][j];\\n                else ans += max(grid[i][j] - grid[i + 1][j], 0);\\n                if (j == 0) ans += grid[i][j];\\n                else ans += max(grid[i][j] - grid[i][j - 1], 0);\\n                if (j == n - 1) ans += grid[i][j];\\n                else ans += max(grid[i][j] - grid[i][j + 1], 0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065723,
                "title": "java-solution-straightforward",
                "content": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        if (grid.length == 1)\\n            return 2 + grid[0][0] * 4;\\n        \\n        // upper and lower surface area\\n        int area = grid.length * grid[0].length * 2; \\n        \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 0)\\n                    area -= 2;\\n                \\n                // outer side surface area\\n                if (i == grid.length - 1 || i == 0 || j == 0 || j == grid[0].length - 1) {\\n                    if ((i == grid.length - 1 || i == 0) && (j == 0 || j == grid[0].length - 1))\\n                        area += grid[i][j] * 2;\\n                    else\\n                        area += grid[i][j];\\n                }\\n                \\n                // inner side surface area\\n                if (i < grid.length - 1 && grid[i][j] > grid[i + 1][j]) // down\\n                    area += grid[i][j] - grid[i + 1][j];\\n                if (i > 0 && grid[i][j] > grid[i - 1][j]) // up\\n                    area += grid[i][j] - grid[i - 1][j];\\n                if (j > 0 && grid[i][j] > grid[i][j - 1]) // left\\n                    area += grid[i][j] - grid[i][j - 1];\\n                if (j < grid[0].length - 1 && grid[i][j] > grid[i][j + 1]) // right\\n                    area += grid[i][j] - grid[i][j + 1];\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        if (grid.length == 1)\\n            return 2 + grid[0][0] * 4;\\n        \\n        // upper and lower surface area\\n        int area = grid.length * grid[0].length * 2; \\n        \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 0)\\n                    area -= 2;\\n                \\n                // outer side surface area\\n                if (i == grid.length - 1 || i == 0 || j == 0 || j == grid[0].length - 1) {\\n                    if ((i == grid.length - 1 || i == 0) && (j == 0 || j == grid[0].length - 1))\\n                        area += grid[i][j] * 2;\\n                    else\\n                        area += grid[i][j];\\n                }\\n                \\n                // inner side surface area\\n                if (i < grid.length - 1 && grid[i][j] > grid[i + 1][j]) // down\\n                    area += grid[i][j] - grid[i + 1][j];\\n                if (i > 0 && grid[i][j] > grid[i - 1][j]) // up\\n                    area += grid[i][j] - grid[i - 1][j];\\n                if (j > 0 && grid[i][j] > grid[i][j - 1]) // left\\n                    area += grid[i][j] - grid[i][j - 1];\\n                if (j < grid[0].length - 1 && grid[i][j] > grid[i][j + 1]) // right\\n                    area += grid[i][j] - grid[i][j + 1];\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993786,
                "title": "java-python-easy-solution-with-description",
                "content": "# Approach\\nThe approach is to first find the total surface area of each grid then subtract the overlapping area.\\n\\n# Complexity\\n- Time complexity:\\nThe Space complexity will be O(n^2).\\nn is the length of grid.\\n\\n- Space complexity:\\nThe Space complexity will be O(1)\\n\\n# Code\\n\\n**Java**\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]>0){\\n                    sum+=grid[i][j]*4+2;\\n                    if(i>0){\\n                        sum-=Math.min(grid[i][j],grid[i-1][j])*2;\\n                    }\\n                    if(j>0){\\n                        sum-=Math.min(grid[i][j],grid[i][j-1])*2;\\n                    }\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        sum=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if(grid[i][j]>0):\\n                    sum+=grid[i][j]*4+2\\n                    if(i>0):\\n                        sum-=min(grid[i][j],grid[i-1][j])*2\\n                    if(j>0):\\n                        sum-=min(grid[i][j],grid[i][j-1])*2\\n        return sum\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Math",
                    "Geometry",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]>0){\\n                    sum+=grid[i][j]*4+2;\\n                    if(i>0){\\n                        sum-=Math.min(grid[i][j],grid[i-1][j])*2;\\n                    }\\n                    if(j>0){\\n                        sum-=Math.min(grid[i][j],grid[i][j-1])*2;\\n                    }\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        sum=0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if(grid[i][j]>0):\\n                    sum+=grid[i][j]*4+2\\n                    if(i>0):\\n                        sum-=min(grid[i][j],grid[i-1][j])*2\\n                    if(j>0):\\n                        sum-=min(grid[i][j],grid[i][j-1])*2\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986131,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func surfaceArea(_ grid: [[Int]]) -> Int {\\n        \\n        var floorsCount = grid\\n            .map { $0.reduce(0, max) }\\n            .reduce(0, max)\\n        \\n        var floors = (1...floorsCount).map { f in grid.map { $0.map { $0 >= f ? 1 : 0 } } }\\n        \\n        var walls = 0\\n        for floor in floors {\\n            for i in floor.indices {\\n                for j in floor[i].indices where floor[i][j] == 1 {\\n                    for x in (i - 1)...(i + 1) {\\n                        for y in (j - 1)...(j + 1) where abs(x - i) + abs(y - j) == 1 {\\n                            if x < 0 || x >= floor.count || y < 0 || y >= floor.count || floor[x][y] == 0 {\\n                                walls += 1\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        let ceiling = grid\\n            .map {\\n                $0\\n                    .map { $0 > 0 ? 1 : 0 }\\n                    .reduce(0, +)\\n            }\\n            .reduce(0, +)\\n        \\n        return walls + ceiling * 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func surfaceArea(_ grid: [[Int]]) -> Int {\\n        \\n        var floorsCount = grid\\n            .map { $0.reduce(0, max) }\\n            .reduce(0, max)\\n        \\n        var floors = (1...floorsCount).map { f in grid.map { $0.map { $0 >= f ? 1 : 0 } } }\\n        \\n        var walls = 0\\n        for floor in floors {\\n            for i in floor.indices {\\n                for j in floor[i].indices where floor[i][j] == 1 {\\n                    for x in (i - 1)...(i + 1) {\\n                        for y in (j - 1)...(j + 1) where abs(x - i) + abs(y - j) == 1 {\\n                            if x < 0 || x >= floor.count || y < 0 || y >= floor.count || floor[x][y] == 0 {\\n                                walls += 1\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        let ceiling = grid\\n            .map {\\n                $0\\n                    .map { $0 > 0 ? 1 : 0 }\\n                    .reduce(0, +)\\n            }\\n            .reduce(0, +)\\n        \\n        return walls + ceiling * 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973645,
                "title": "simple-c-implementation-based-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getAdjacents(int i , int j , int n , int m , vector<vector<int>> &grid){\\n        int ct = 0;\\n        // left\\n        if(j==0){\\n            ct += grid[i][j];\\n        }\\n        else{\\n            ct += (grid[i][j]>grid[i][j-1] ? grid[i][j]-grid[i][j-1] :0);\\n        }\\n\\n        // right\\n        if(j==m-1){\\n            ct += grid[i][j];\\n        }\\n        else{\\n            ct += (grid[i][j]>grid[i][j+1] ? grid[i][j]-grid[i][j+1] :0);\\n        }\\n\\n        // top\\n        if(i==0){\\n            ct += grid[i][j];\\n        }\\n        else{\\n            ct += (grid[i][j]>grid[i-1][j] ? grid[i][j]-grid[i-1][j] :0);\\n        }\\n\\n        // bottom\\n        if(i==n-1){\\n            ct += grid[i][j];\\n        }\\n        else{\\n            ct += (grid[i][j]>grid[i+1][j] ? grid[i][j]-grid[i+1][j] :0);\\n        }\\n\\n\\n        return ct;\\n    }\\n\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n  = grid.size();\\n        int m = grid[0].size();\\n\\n        int ct = 0;\\n\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                ct += getAdjacents(i , j , n , m , grid);\\n                if(grid[i][j]!=0) ct += 2;\\n            }\\n            \\n        }\\n\\n\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getAdjacents(int i , int j , int n , int m , vector<vector<int>> &grid){\\n        int ct = 0;\\n        // left\\n        if(j==0){\\n            ct += grid[i][j];\\n        }\\n        else{\\n            ct += (grid[i][j]>grid[i][j-1] ? grid[i][j]-grid[i][j-1] :0);\\n        }\\n\\n        // right\\n        if(j==m-1){\\n            ct += grid[i][j];\\n        }\\n        else{\\n            ct += (grid[i][j]>grid[i][j+1] ? grid[i][j]-grid[i][j+1] :0);\\n        }\\n\\n        // top\\n        if(i==0){\\n            ct += grid[i][j];\\n        }\\n        else{\\n            ct += (grid[i][j]>grid[i-1][j] ? grid[i][j]-grid[i-1][j] :0);\\n        }\\n\\n        // bottom\\n        if(i==n-1){\\n            ct += grid[i][j];\\n        }\\n        else{\\n            ct += (grid[i][j]>grid[i+1][j] ? grid[i][j]-grid[i+1][j] :0);\\n        }\\n\\n\\n        return ct;\\n    }\\n\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int n  = grid.size();\\n        int m = grid[0].size();\\n\\n        int ct = 0;\\n\\n        for(int i=0 ; i<n ; i++){\\n            for(int j=0 ; j<m ; j++){\\n                ct += getAdjacents(i , j , n , m , grid);\\n                if(grid[i][j]!=0) ct += 2;\\n            }\\n            \\n        }\\n\\n\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962632,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun surfaceArea(grid: Array<IntArray>): Int {\\n        var result = 0\\n        val n = grid.size\\n        for (i in 0..n-1) {\\n            for (j in 0..n-1) {\\n                val cell = grid[i][j]\\n                if (cell != 0) result += cell * 4 + 2\\n                if (i > 0) result -= minOf(cell, grid[i-1][j])*2\\n                if (j > 0) result -= minOf(cell, grid[i][j-1])*2\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun surfaceArea(grid: Array<IntArray>): Int {\\n        var result = 0\\n        val n = grid.size\\n        for (i in 0..n-1) {\\n            for (j in 0..n-1) {\\n                val cell = grid[i][j]\\n                if (cell != 0) result += cell * 4 + 2\\n                if (i > 0) result -= minOf(cell, grid[i-1][j])*2\\n                if (j > 0) result -= minOf(cell, grid[i][j-1])*2\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915727,
                "title": "ruby-solution-nice-clean-and-commented",
                "content": "# Intuition\\nWe add up the number of cubes in each column, and subtract 2 for each of the faces glued to each other.\\n\\n# Approach\\nJust sweep through each matrix square, count the columns and calculate their total faces (6 per cube, less 2 for each cube beyond one, since they obscure top/bottom when they stack), and then check the size of the column vs. each of its four possible neighbors, and reduce the count by the shorter of the two columns.\\n\\n# Complexity\\n- Time complexity:\\nO(n)... five checks per each of the MxN cells\\n\\n- Space complexity:\\nO(1)... just two variables to total things in.\\n\\n# Code\\n```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef surface_area(grid)\\n    cube_faces = 0\\n    glued = 0\\n    for i in 0...grid.length\\n        for j in 0...grid[0].length\\n            # First, how many cubes have we got in this column? Count six sides each, less two for each cube other than the first.\\n            cube_faces += (grid[i][j] * 6 - (2 * (grid[i][j] - 1))) if grid[i][j] > 0\\n\\n            # Now check each of the adjacent columns... remove sides times the height of the shorter column.\\n            glued += [grid[i][j],grid[i-1][j]].min if i > 0\\n            glued += [grid[i][j],grid[i+1][j]].min if i < grid.length - 1\\n            glued += [grid[i][j],grid[i][j-1]].min if j > 0\\n            glued += [grid[i][j],grid[i][j+1]].min if j < grid[0].length - 1\\n        end\\n    end\\n\\n    # The answer is the total of cube faces (from each column) less each of the \"glued\" sides.\\n    cube_faces - glued\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef surface_area(grid)\\n    cube_faces = 0\\n    glued = 0\\n    for i in 0...grid.length\\n        for j in 0...grid[0].length\\n            # First, how many cubes have we got in this column? Count six sides each, less two for each cube other than the first.\\n            cube_faces += (grid[i][j] * 6 - (2 * (grid[i][j] - 1))) if grid[i][j] > 0\\n\\n            # Now check each of the adjacent columns... remove sides times the height of the shorter column.\\n            glued += [grid[i][j],grid[i-1][j]].min if i > 0\\n            glued += [grid[i][j],grid[i+1][j]].min if i < grid.length - 1\\n            glued += [grid[i][j],grid[i][j-1]].min if j > 0\\n            glued += [grid[i][j],grid[i][j+1]].min if j < grid[0].length - 1\\n        end\\n    end\\n\\n    # The answer is the total of cube faces (from each column) less each of the \"glued\" sides.\\n    cube_faces - glued\\n\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2912292,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        public int surfaceArea(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] > 0) res += grid[i][j] * 4 + 2;\\n                if (i > 0) res -= Math.min(grid[i][j], grid[i - 1][j]) * 2;\\n                if (j > 0) res -= Math.min(grid[i][j], grid[i][j - 1]) * 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int surfaceArea(int[][] grid) {\\n        int res = 0, n = grid.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] > 0) res += grid[i][j] * 4 + 2;\\n                if (i > 0) res -= Math.min(grid[i][j], grid[i - 1][j]) * 2;\\n                if (j > 0) res -= Math.min(grid[i][j], grid[i][j - 1]) * 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899235,
                "title": "c-straightforward",
                "content": "# Intuition\\nCalculate the surface area of each tower and add to ans.\\nStep through each row, then column,\\nThen check if it\\'s at least 1 to add 2 (top and bottom)\\nThen check all 4 adjacent sides and if the current tower is taller Add it\\'s height minus the side tower\\'s height (if there isn\\'t an adjacent tower (edge/corner) just say the adjacent tower\\'s height is 0.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        // calculate the surface area of each tower and add to ans\\n        // step through each row, then column,\\n        // then check if it\\'s at least 1 to add 2 (top and bottom)\\n        // then check all 4 adjacent sides and if the current tower is taller add it\\'s height minus the side tower\\'s height (if there isn\\'t an adjacent tower (edge/corner) just say the adjacent tower\\'s height is 0\\n        int cur = 0, adj = 0;\\n        for(int i=0; i<grid.size(); i++){\\n            //cout << \"i \" << i << endl;\\n            for(int j=0; j<grid[0].size(); j++){\\n                //cout << \"j \" << j << endl;\\n                cur = grid[i][j];\\n                if(cur>0){\\n                    ans+=2;\\n                    // check all 4 sides\\n                    //i-1\\n                    if(i-1<0){\\n                        adj = 0;\\n                    }else{\\n                        adj = grid[i-1][j];\\n                    }\\n                    if(cur>adj)\\n                        ans+=cur-adj;\\n                    //i+1\\n                    if(i+1>grid.size()-1){\\n                        adj = 0;\\n                    }else{\\n                        adj = grid[i+1][j];\\n                    }\\n                    if(cur>adj)\\n                        ans+=cur-adj;\\n                    //j-1\\n                    if(j-1<0){\\n                        adj = 0;\\n                    }else{\\n                        adj = grid[i][j-1];\\n                    }\\n                    if(cur>adj)\\n                        ans+=cur-adj;\\n                    //j+1\\n                    if(j+1>grid[0].size()-1){\\n                        adj = 0;\\n                    }else{\\n                        adj = grid[i][j+1];\\n                    }\\n                    if(cur>adj)\\n                        ans+=cur-adj;\\n                }\\n                //cout << \"ans \" << ans << endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        // calculate the surface area of each tower and add to ans\\n        // step through each row, then column,\\n        // then check if it\\'s at least 1 to add 2 (top and bottom)\\n        // then check all 4 adjacent sides and if the current tower is taller add it\\'s height minus the side tower\\'s height (if there isn\\'t an adjacent tower (edge/corner) just say the adjacent tower\\'s height is 0\\n        int cur = 0, adj = 0;\\n        for(int i=0; i<grid.size(); i++){\\n            //cout << \"i \" << i << endl;\\n            for(int j=0; j<grid[0].size(); j++){\\n                //cout << \"j \" << j << endl;\\n                cur = grid[i][j];\\n                if(cur>0){\\n                    ans+=2;\\n                    // check all 4 sides\\n                    //i-1\\n                    if(i-1<0){\\n                        adj = 0;\\n                    }else{\\n                        adj = grid[i-1][j];\\n                    }\\n                    if(cur>adj)\\n                        ans+=cur-adj;\\n                    //i+1\\n                    if(i+1>grid.size()-1){\\n                        adj = 0;\\n                    }else{\\n                        adj = grid[i+1][j];\\n                    }\\n                    if(cur>adj)\\n                        ans+=cur-adj;\\n                    //j-1\\n                    if(j-1<0){\\n                        adj = 0;\\n                    }else{\\n                        adj = grid[i][j-1];\\n                    }\\n                    if(cur>adj)\\n                        ans+=cur-adj;\\n                    //j+1\\n                    if(j+1>grid[0].size()-1){\\n                        adj = 0;\\n                    }else{\\n                        adj = grid[i][j+1];\\n                    }\\n                    if(cur>adj)\\n                        ans+=cur-adj;\\n                }\\n                //cout << \"ans \" << ans << endl;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2894567,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn surface_area(grid: Vec<Vec<i32>>) -> i32 {\\n        let n = grid.len();\\n        let mut area = 0;\\n\\n        for i in 0..n {\\n            for j in 0..n {\\n                area += 2 + grid[i][j] * 4;\\n\\n                if grid[i][j] == 0 {\\n                    area -= 2 + grid[i][j] * 4;\\n                }\\n\\n                // check up\\n                if i >= 1 {\\n                    if grid[i][j] <= grid[i - 1][j] {\\n                        area -= grid[i][j];\\n                    } else {\\n                        area -= grid[i - 1][j];\\n                    }\\n                }\\n                // check down\\n                if i + 1 < n {\\n                    if grid[i][j] <= grid[i + 1][j] {\\n                        area -= grid[i][j];\\n                    } else {\\n                        area -= grid[i + 1][j];\\n                    }\\n                }\\n                // check left\\n                if j >= 1 {\\n                    if grid[i][j] <= grid[i][j - 1] {\\n                        area -= grid[i][j];\\n                    } else {\\n                        area -= grid[i][j - 1];\\n                    }\\n                }\\n                // check right\\n                if j + 1 < n {\\n                    if grid[i][j] <= grid[i][j + 1] {\\n                        area -= grid[i][j];\\n                    } else {\\n                        area -= grid[i][j + 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        area\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn surface_area(grid: Vec<Vec<i32>>) -> i32 {\\n        let n = grid.len();\\n        let mut area = 0;\\n\\n        for i in 0..n {\\n            for j in 0..n {\\n                area += 2 + grid[i][j] * 4;\\n\\n                if grid[i][j] == 0 {\\n                    area -= 2 + grid[i][j] * 4;\\n                }\\n\\n                // check up\\n                if i >= 1 {\\n                    if grid[i][j] <= grid[i - 1][j] {\\n                        area -= grid[i][j];\\n                    } else {\\n                        area -= grid[i - 1][j];\\n                    }\\n                }\\n                // check down\\n                if i + 1 < n {\\n                    if grid[i][j] <= grid[i + 1][j] {\\n                        area -= grid[i][j];\\n                    } else {\\n                        area -= grid[i + 1][j];\\n                    }\\n                }\\n                // check left\\n                if j >= 1 {\\n                    if grid[i][j] <= grid[i][j - 1] {\\n                        area -= grid[i][j];\\n                    } else {\\n                        area -= grid[i][j - 1];\\n                    }\\n                }\\n                // check right\\n                if j + 1 < n {\\n                    if grid[i][j] <= grid[i][j + 1] {\\n                        area -= grid[i][j];\\n                    } else {\\n                        area -= grid[i][j + 1];\\n                    }\\n                }\\n            }\\n        }\\n\\n        area\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2894044,
                "title": "solution-kotlin",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun surfaceArea(grid: Array<IntArray>): Int {\\n        var c = 2 * grid.size * grid.size\\n        var zeroCount = 0\\n\\n        var sum = 0\\n\\n        for (i in 0 until grid.size) {\\n            for (j in 0 until grid[0].size) {\\n                \\n                if (grid[i][j] == 0) {\\n                    zeroCount++\\n                    continue\\n                }\\n\\n                val top = grid.getOrNull(i - 1)?.get(j) ?: 0\\n                val right = grid[i].getOrNull(j + 1) ?: 0\\n                val bottom = grid.getOrNull(i + 1)?.get(j) ?: 0\\n                val left = grid[i].getOrNull(j - 1) ?: 0\\n\\n                val v = grid[i][j]\\n\\n                if (v > right) {\\n                    sum += (v - right)\\n                }\\n                if (v > top) {\\n                    sum += (v - top)\\n                }\\n                if (v > bottom) {\\n                    sum += (v - bottom)\\n                }\\n                if (v > left) {\\n                    sum += (v - left)\\n                }\\n            }\\n        }\\n\\n        return sum + c - 2 * zeroCount\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun surfaceArea(grid: Array<IntArray>): Int {\\n        var c = 2 * grid.size * grid.size\\n        var zeroCount = 0\\n\\n        var sum = 0\\n\\n        for (i in 0 until grid.size) {\\n            for (j in 0 until grid[0].size) {\\n                \\n                if (grid[i][j] == 0) {\\n                    zeroCount++\\n                    continue\\n                }\\n\\n                val top = grid.getOrNull(i - 1)?.get(j) ?: 0\\n                val right = grid[i].getOrNull(j + 1) ?: 0\\n                val bottom = grid.getOrNull(i + 1)?.get(j) ?: 0\\n                val left = grid[i].getOrNull(j - 1) ?: 0\\n\\n                val v = grid[i][j]\\n\\n                if (v > right) {\\n                    sum += (v - right)\\n                }\\n                if (v > top) {\\n                    sum += (v - top)\\n                }\\n                if (v > bottom) {\\n                    sum += (v - bottom)\\n                }\\n                if (v > left) {\\n                    sum += (v - left)\\n                }\\n            }\\n        }\\n\\n        return sum + c - 2 * zeroCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849210,
                "title": "c-beats-98-time-space",
                "content": "# Intuition\\nCalculate the surface area for each point `(i, j)` individually, and add everything together.\\n\\n# Approach\\nFor any point `(i, j)` with non-zero height, the surface area will be:\\n\\n1. top face\\n2. bottom face\\n3. any exposed lateral faces\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ where $$n$$ is the length or width of the grid.\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int dirs[5] {0, 1, 0, -1, 0};\\n    int exposedFaces(const vector<vector<int> >& grid, int i, int j, const int N)\\n    {\\n        int exposed = 2; // top face and bottom face.\\n\\n        // iterate through top, right, bottom, left neighbors.\\n        for (int d = 0; d < 4; ++d)\\n        {\\n            // generate a neighbor\\'s coordinates.\\n            int modI = i + dirs[d], modJ = j + dirs[d + 1];\\n\\n            // if neighbor is out of bounds, then your entire height is exposed.\\n            if (modI == -1 or modI == N or modJ == -1 or modJ == N)\\n                exposed += grid[i][j];\\n\\n            // otherwise, pick up exposed faces: subtract neighbor height from yours.\\n            else exposed += max(0, grid[i][j] - grid[modI][modJ]);\\n        }\\n        return exposed;\\n    }\\n\\npublic:\\n    int surfaceArea(vector<vector<int> >& grid)\\n    {\\n        int surface_area = 0, N = size(grid);\\n        for (int i = 0; i < N; ++i)\\n            for (int j = 0; j < N; ++j)\\n                if (grid[i][j] != 0) // non-zero height\\n                    surface_area += exposedFaces(grid, i, j, N);\\n        return surface_area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dirs[5] {0, 1, 0, -1, 0};\\n    int exposedFaces(const vector<vector<int> >& grid, int i, int j, const int N)\\n    {\\n        int exposed = 2; // top face and bottom face.\\n\\n        // iterate through top, right, bottom, left neighbors.\\n        for (int d = 0; d < 4; ++d)\\n        {\\n            // generate a neighbor\\'s coordinates.\\n            int modI = i + dirs[d], modJ = j + dirs[d + 1];\\n\\n            // if neighbor is out of bounds, then your entire height is exposed.\\n            if (modI == -1 or modI == N or modJ == -1 or modJ == N)\\n                exposed += grid[i][j];\\n\\n            // otherwise, pick up exposed faces: subtract neighbor height from yours.\\n            else exposed += max(0, grid[i][j] - grid[modI][modJ]);\\n        }\\n        return exposed;\\n    }\\n\\npublic:\\n    int surfaceArea(vector<vector<int> >& grid)\\n    {\\n        int surface_area = 0, N = size(grid);\\n        for (int i = 0; i < N; ++i)\\n            for (int j = 0; j < N; ++j)\\n                if (grid[i][j] != 0) // non-zero height\\n                    surface_area += exposedFaces(grid, i, j, N);\\n        return surface_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827886,
                "title": "simple-java-solution-with-comments",
                "content": "# Code\\n```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int res = 0;\\n\\n        for(int y = 0; y < grid.length; y++){\\n            for(int x = 0; x < grid[0].length; x++){\\n                if(grid[y][x] > 0) res += grid[y][x] * 4 + 2; // regard it is a single tower\\n                if(x > 0) res -= Math.min(grid[y][x-1], grid[y][x]) * 2; // substract the double counted area\\n                if(y > 0) res -= Math.min(grid[y-1][x], grid[y][x]) * 2; // substract the double counted area\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int surfaceArea(int[][] grid) {\\n        int res = 0;\\n\\n        for(int y = 0; y < grid.length; y++){\\n            for(int x = 0; x < grid[0].length; x++){\\n                if(grid[y][x] > 0) res += grid[y][x] * 4 + 2; // regard it is a single tower\\n                if(x > 0) res -= Math.min(grid[y][x-1], grid[y][x]) * 2; // substract the double counted area\\n                if(y > 0) res -= Math.min(grid[y-1][x], grid[y][x]) * 2; // substract the double counted area\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753739,
                "title": "typescript-javascript-100-faster-100-memory-less",
                "content": "```\\nfunction surfaceArea(grid: number[][]): number {\\n    const n = grid.length;\\n    \\n    const visited: number[][] = [];\\n    for (let i = 0; i < n; i++) {\\n        visited.push(new Array(n).fill(0));\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            const v = grid[i][j];\\n            \\n            if (v && !visited[i][j]) {\\n                total += calculateSquare(grid, i, j, visited);\\n            }\\n        }\\n    }\\n    \\n    return total;\\n}\\n\\nfunction calculateSquare(\\n    grid: number[][], \\n    si: number, \\n    sj: number, \\n    visited: number[][]\\n): number {\\n    const stack = [[si, sj]];\\n    let total = 0;\\n    \\n    while (stack.length) {\\n        const [i, j] = stack.pop();\\n        \\n        if (visited[i][j]) {\\n            continue;\\n        }\\n        \\n        visited[i][j] = 1;\\n        \\n        const cells = [\\n            [i, j - 1],\\n            [i, j + 1],\\n            [i - 1, j],\\n            [i + 1, j],\\n        ];\\n        \\n        const v = grid[i][j];\\n        total += 2;\\n        \\n        cells.forEach(([ci, cj]) => {\\n            const cv = grid[ci] && grid[ci][cj] || 0;\\n            const s = v - cv;\\n            total += 0 < s ? s : 0;\\n            \\n            if (cv) {\\n                stack.push([ci, cj]);\\n            }\\n        });\\n    }\\n    \\n    return total;\\n}\\n```\\n\\n<img scr=\"https://assets.leetcode.com/users/images/7b7292a5-eff8-403e-9092-68ca40b5ed81_1666987239.3413463.png\" width=\"600px\"/>\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction surfaceArea(grid: number[][]): number {\\n    const n = grid.length;\\n    \\n    const visited: number[][] = [];\\n    for (let i = 0; i < n; i++) {\\n        visited.push(new Array(n).fill(0));\\n    }\\n    \\n    let total = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < n; j++) {\\n            const v = grid[i][j];\\n            \\n            if (v && !visited[i][j]) {\\n                total += calculateSquare(grid, i, j, visited);\\n            }\\n        }\\n    }\\n    \\n    return total;\\n}\\n\\nfunction calculateSquare(\\n    grid: number[][], \\n    si: number, \\n    sj: number, \\n    visited: number[][]\\n): number {\\n    const stack = [[si, sj]];\\n    let total = 0;\\n    \\n    while (stack.length) {\\n        const [i, j] = stack.pop();\\n        \\n        if (visited[i][j]) {\\n            continue;\\n        }\\n        \\n        visited[i][j] = 1;\\n        \\n        const cells = [\\n            [i, j - 1],\\n            [i, j + 1],\\n            [i - 1, j],\\n            [i + 1, j],\\n        ];\\n        \\n        const v = grid[i][j];\\n        total += 2;\\n        \\n        cells.forEach(([ci, cj]) => {\\n            const cv = grid[ci] && grid[ci][cj] || 0;\\n            const s = v - cv;\\n            total += 0 < s ? s : 0;\\n            \\n            if (cv) {\\n                stack.push([ci, cj]);\\n            }\\n        });\\n    }\\n    \\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2709466,
                "title": "c",
                "content": "```\\nint surfaceArea(int** grid, int gridSize, int* gridColSize){\\n    int row = gridSize;\\n    int col = *gridColSize;\\n\\n    int ans = 0;\\n    int zeroCn = 0;\\n    for(int i = 0; i < row; i++){\\n        int cn = 0;\\n        for(int j = 0; j < col; j++){\\n            if(grid[i][j] == 0)\\n               zeroCn++; \\n            if(j == 0)\\n                cn += grid[i][j];\\n            else\\n                cn += abs(grid[i][j] - grid[i][j-1]);\\n            if(j == (col-1))\\n                cn += grid[i][j];\\n        }\\n        ans += cn;\\n    }\\n\\n    for(int i = 0; i < col; i++){\\n        int cn = 0;\\n        for(int j = 0; j < row; j++){\\n            if(j == 0)\\n                cn += grid[j][i];\\n            else\\n                cn += abs(grid[j][i] - grid[j-1][i]);\\n            if(j == (col-1))\\n                cn += grid[j][i];\\n        }\\n        ans += cn;\\n    }    \\n\\n    ans = ans + (row*col- zeroCn) *2;\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint surfaceArea(int** grid, int gridSize, int* gridColSize){\\n    int row = gridSize;\\n    int col = *gridColSize;\\n\\n    int ans = 0;\\n    int zeroCn = 0;\\n    for(int i = 0; i < row; i++){\\n        int cn = 0;\\n        for(int j = 0; j < col; j++){\\n            if(grid[i][j] == 0)\\n               zeroCn++; \\n            if(j == 0)\\n                cn += grid[i][j];\\n            else\\n                cn += abs(grid[i][j] - grid[i][j-1]);\\n            if(j == (col-1))\\n                cn += grid[i][j];\\n        }\\n        ans += cn;\\n    }\\n\\n    for(int i = 0; i < col; i++){\\n        int cn = 0;\\n        for(int j = 0; j < row; j++){\\n            if(j == 0)\\n                cn += grid[j][i];\\n            else\\n                cn += abs(grid[j][i] - grid[j-1][i]);\\n            if(j == (col-1))\\n                cn += grid[j][i];\\n        }\\n        ans += cn;\\n    }    \\n\\n    ans = ans + (row*col- zeroCn) *2;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2707287,
                "title": "clean-concise-beginner-friendly-c",
                "content": "**If you liked this solution, please upvote!**\\nEach cube could contribute a max of `6 * cubes` to the surface area. However, you\\'ll need to subtract the area from adjacent cubes.\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for (int r = 0; r < grid.size(); r++) {\\n            for (int c = 0; c < grid[0].size(); c++) {\\n                int cubes = grid[r][c];\\n                if (cubes == 0) continue;\\n                int area = 6 * cubes - 2 * (cubes - 1);\\n                area -= min(cubes, cubesOn(grid, r, c - 1)); // left\\n                area -= min(cubes, cubesOn(grid, r, c + 1)); // right\\n                area -= min(cubes, cubesOn(grid, r - 1, c)); // top\\n                area -= min(cubes, cubesOn(grid, r + 1, c)); // bottom\\n                ans += area;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    int cubesOn(vector<vector<int>>& grid, int r, int c) {\\n        if (0 <= r && r < grid.size() && 0 <= c && c < grid[0].size()) {\\n            return grid[r][c];\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\nThis can be simplified by only checking the top and left adjacent cubes (and multiplying it by 2):\\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for (int r = 0; r < grid.size(); r++) {\\n            for (int c = 0; c < grid[0].size(); c++) {\\n                int cubes = grid[r][c];\\n                if (cubes) ans += 4 * cubes + 2;\\n                if (r) ans -= 2 * min(cubes, grid[r - 1][c]); // top\\n                if (c) ans -= 2 * min(cubes, grid[r][c - 1]); // left\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you liked this solution, please upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for (int r = 0; r < grid.size(); r++) {\\n            for (int c = 0; c < grid[0].size(); c++) {\\n                int cubes = grid[r][c];\\n                if (cubes == 0) continue;\\n                int area = 6 * cubes - 2 * (cubes - 1);\\n                area -= min(cubes, cubesOn(grid, r, c - 1)); // left\\n                area -= min(cubes, cubesOn(grid, r, c + 1)); // right\\n                area -= min(cubes, cubesOn(grid, r - 1, c)); // top\\n                area -= min(cubes, cubesOn(grid, r + 1, c)); // bottom\\n                ans += area;\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    int cubesOn(vector<vector<int>>& grid, int r, int c) {\\n        if (0 <= r && r < grid.size() && 0 <= c && c < grid[0].size()) {\\n            return grid[r][c];\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int surfaceArea(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for (int r = 0; r < grid.size(); r++) {\\n            for (int c = 0; c < grid[0].size(); c++) {\\n                int cubes = grid[r][c];\\n                if (cubes) ans += 4 * cubes + 2;\\n                if (r) ans -= 2 * min(cubes, grid[r - 1][c]); // top\\n                if (c) ans -= 2 * min(cubes, grid[r][c - 1]); // left\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636373,
                "title": "python-all-possible-area-minus-hidden-area",
                "content": "```\\nclass Solution:#Time/Space: O(N*M);O(1)\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        ret = 0\\n        m, n= len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                tot = grid[i][j]*6\\n                if grid[i][j] > 0: # if has at least 1 cube, then subtract internal \\'surface\\'\\n                    tot -= (grid[i][j]-1)*2\\n                #substract all surrounding hide surface\\n                if i > 0:\\n                    tot -= min(grid[i][j], grid[i-1][j])\\n                if j > 0:\\n                    tot -= min(grid[i][j], grid[i][j-1])\\n                if i < m - 1:\\n                    tot -= min(grid[i][j], grid[i+1][j])\\n                if j < n - 1:\\n                    tot -= min(grid[i][j], grid[i][j+1])\\n                ret += tot\\n        return ret\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:#Time/Space: O(N*M);O(1)\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        ret = 0\\n        m, n= len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                tot = grid[i][j]*6\\n                if grid[i][j] > 0: # if has at least 1 cube, then subtract internal \\'surface\\'\\n                    tot -= (grid[i][j]-1)*2\\n                #substract all surrounding hide surface\\n                if i > 0:\\n                    tot -= min(grid[i][j], grid[i-1][j])\\n                if j > 0:\\n                    tot -= min(grid[i][j], grid[i][j-1])\\n                if i < m - 1:\\n                    tot -= min(grid[i][j], grid[i+1][j])\\n                if j < n - 1:\\n                    tot -= min(grid[i][j], grid[i][j+1])\\n                ret += tot\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624539,
                "title": "simple-beginner-friendly-approach-one-pass-no-built-in-function-o-n-2",
                "content": "**Approach:**\\n- Each tower\\'s `total_faces` is equal to `6` times for each cube - `2` times the # of common faces hidden in between as shown below for 3 cube tower:\\n![image](https://assets.leetcode.com/users/images/90c3e63c-d70b-439e-9d27-40203ced0cb9_1664141748.524627.png)\\n- Each tower can have upto 4 neighbour. The `min` of the a cube and its neighbour will also be hidden as shown below:\\n![image](https://assets.leetcode.com/users/images/04bcd1e2-b263-41cb-a402-3aaa320d30c9_1664141955.2490022.png)\\n- As we loop over the grid, we need to count the `total_faces` and the `hidden faces` and generate the final answer\\n\\n```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        n = len(grid)\\n        for r in range(n):\\n            for c in range(n):\\n                total_faces = grid[r][c] * 6 - max(0, grid[r][c] - 1) * 2\\n                if total_faces == 0:\\n                    continue\\n                for (i, j) in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:\\n                    if 0 <= i <= n - 1 and 0 <= j <= n - 1:\\n                        total_faces -= min(grid[i][j], grid[r][c])\\n                res += total_faces\\n        return res\\n```\\n\\nTime Complexity: `O(N^2)`\\nSpace Complexity: `O(1)`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def surfaceArea(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        n = len(grid)\\n        for r in range(n):\\n            for c in range(n):\\n                total_faces = grid[r][c] * 6 - max(0, grid[r][c] - 1) * 2\\n                if total_faces == 0:\\n                    continue\\n                for (i, j) in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:\\n                    if 0 <= i <= n - 1 and 0 <= j <= n - 1:\\n                        total_faces -= min(grid[i][j], grid[r][c])\\n                res += total_faces\\n        return res\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565504,
                "content": [
                    {
                        "username": "ffmaer",
                        "content": "https://codepen.io/ffmaer/pen/xxGgeaE\\n\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633181.png)\\nInput: [[2]]\\nOutput: 10\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633188.png)\\nInput: [[1,2],[3,4]]\\nOutput: 34\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633195.png)\\nInput: [[1,0],[0,2]]\\nOutput: 16\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633203.png)\\nInput: [[1,1,1],[1,0,1],[1,1,1]]\\nOutput: 32\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633208.png)\\nInput: [[2,2,2],[2,1,2],[2,2,2]]\\nOutput: 46"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Man , THANK YOU SOOOO MUCH : )"
                    },
                    {
                        "username": "lin36716",
                        "content": "Thanks for the visualization, I really appreciate that, I had a slight difficulty to comprehend this problem and thought for a great hours...."
                    },
                    {
                        "username": "martinvelez",
                        "content": "I think this problem should be labeled as Medium.  (This is under the assumption that problems are manually labeled.) . I took a long time to solve this problem. I may have been misled by initial intuition which was to find the maximum of each row and the maximum of each column.  That gives me *part* of the surface area visible from x and y.  I developed a complex way of counting the surface area not visible from x and y.  The surface area of z is just the count of nonzero values * 2.\\n\\nI have read others\\' solution and, in hindsight, they are much more straight forward.  Essentially, compute the surface area of each grid but substract the overlapping areas.\\n\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be much much better. It just tests geometry/ mathematical formulas which most people dont use on a regular basis - and recruiters dont seem to understand this."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have some trouble to understand the question. For me a grid like that [[1]] has as area 5.\\nWhy? because the bottom is hidden.\\nMy code doesn\\'t pass the tests, of corse.\\nWhen I read the solutions, I was thinking: why they count the bottom?\\nI read the description again and... I found the solution; this sentence:\\n\"Note: The bottom face of each shape counts toward its surface area.\"\\nIt\\'s true: The biggest bug is the one sitting on the chair!\\n\\n"
                    },
                    {
                        "username": "charlychuanli",
                        "content": "one cube next to another tower with 5 cube, how could it return 6?  the surface of the 5 cube tower is alreadly bigger than 6."
                    },
                    {
                        "username": "htfy96",
                        "content": "The description says the answer for `[[1,0],[0,2]]` should be `16`, but when running code with custom testcase the *expected answer* outputs `20`. Maybe there are some mistakes in the sample program?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/htfy96/image_1535289972.png)\\n"
                    },
                    {
                        "username": "n761z",
                        "content": "Can someone suggest me a video editorial for this question. "
                    }
                ]
            },
            {
                "id": 1565079,
                "content": [
                    {
                        "username": "ffmaer",
                        "content": "https://codepen.io/ffmaer/pen/xxGgeaE\\n\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633181.png)\\nInput: [[2]]\\nOutput: 10\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633188.png)\\nInput: [[1,2],[3,4]]\\nOutput: 34\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633195.png)\\nInput: [[1,0],[0,2]]\\nOutput: 16\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633203.png)\\nInput: [[1,1,1],[1,0,1],[1,1,1]]\\nOutput: 32\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633208.png)\\nInput: [[2,2,2],[2,1,2],[2,2,2]]\\nOutput: 46"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Man , THANK YOU SOOOO MUCH : )"
                    },
                    {
                        "username": "lin36716",
                        "content": "Thanks for the visualization, I really appreciate that, I had a slight difficulty to comprehend this problem and thought for a great hours...."
                    },
                    {
                        "username": "martinvelez",
                        "content": "I think this problem should be labeled as Medium.  (This is under the assumption that problems are manually labeled.) . I took a long time to solve this problem. I may have been misled by initial intuition which was to find the maximum of each row and the maximum of each column.  That gives me *part* of the surface area visible from x and y.  I developed a complex way of counting the surface area not visible from x and y.  The surface area of z is just the count of nonzero values * 2.\\n\\nI have read others\\' solution and, in hindsight, they are much more straight forward.  Essentially, compute the surface area of each grid but substract the overlapping areas.\\n\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be much much better. It just tests geometry/ mathematical formulas which most people dont use on a regular basis - and recruiters dont seem to understand this."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have some trouble to understand the question. For me a grid like that [[1]] has as area 5.\\nWhy? because the bottom is hidden.\\nMy code doesn\\'t pass the tests, of corse.\\nWhen I read the solutions, I was thinking: why they count the bottom?\\nI read the description again and... I found the solution; this sentence:\\n\"Note: The bottom face of each shape counts toward its surface area.\"\\nIt\\'s true: The biggest bug is the one sitting on the chair!\\n\\n"
                    },
                    {
                        "username": "charlychuanli",
                        "content": "one cube next to another tower with 5 cube, how could it return 6?  the surface of the 5 cube tower is alreadly bigger than 6."
                    },
                    {
                        "username": "htfy96",
                        "content": "The description says the answer for `[[1,0],[0,2]]` should be `16`, but when running code with custom testcase the *expected answer* outputs `20`. Maybe there are some mistakes in the sample program?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/htfy96/image_1535289972.png)\\n"
                    },
                    {
                        "username": "n761z",
                        "content": "Can someone suggest me a video editorial for this question. "
                    }
                ]
            },
            {
                "id": 1708207,
                "content": [
                    {
                        "username": "ffmaer",
                        "content": "https://codepen.io/ffmaer/pen/xxGgeaE\\n\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633181.png)\\nInput: [[2]]\\nOutput: 10\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633188.png)\\nInput: [[1,2],[3,4]]\\nOutput: 34\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633195.png)\\nInput: [[1,0],[0,2]]\\nOutput: 16\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633203.png)\\nInput: [[1,1,1],[1,0,1],[1,1,1]]\\nOutput: 32\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633208.png)\\nInput: [[2,2,2],[2,1,2],[2,2,2]]\\nOutput: 46"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Man , THANK YOU SOOOO MUCH : )"
                    },
                    {
                        "username": "lin36716",
                        "content": "Thanks for the visualization, I really appreciate that, I had a slight difficulty to comprehend this problem and thought for a great hours...."
                    },
                    {
                        "username": "martinvelez",
                        "content": "I think this problem should be labeled as Medium.  (This is under the assumption that problems are manually labeled.) . I took a long time to solve this problem. I may have been misled by initial intuition which was to find the maximum of each row and the maximum of each column.  That gives me *part* of the surface area visible from x and y.  I developed a complex way of counting the surface area not visible from x and y.  The surface area of z is just the count of nonzero values * 2.\\n\\nI have read others\\' solution and, in hindsight, they are much more straight forward.  Essentially, compute the surface area of each grid but substract the overlapping areas.\\n\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be much much better. It just tests geometry/ mathematical formulas which most people dont use on a regular basis - and recruiters dont seem to understand this."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have some trouble to understand the question. For me a grid like that [[1]] has as area 5.\\nWhy? because the bottom is hidden.\\nMy code doesn\\'t pass the tests, of corse.\\nWhen I read the solutions, I was thinking: why they count the bottom?\\nI read the description again and... I found the solution; this sentence:\\n\"Note: The bottom face of each shape counts toward its surface area.\"\\nIt\\'s true: The biggest bug is the one sitting on the chair!\\n\\n"
                    },
                    {
                        "username": "charlychuanli",
                        "content": "one cube next to another tower with 5 cube, how could it return 6?  the surface of the 5 cube tower is alreadly bigger than 6."
                    },
                    {
                        "username": "htfy96",
                        "content": "The description says the answer for `[[1,0],[0,2]]` should be `16`, but when running code with custom testcase the *expected answer* outputs `20`. Maybe there are some mistakes in the sample program?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/htfy96/image_1535289972.png)\\n"
                    },
                    {
                        "username": "n761z",
                        "content": "Can someone suggest me a video editorial for this question. "
                    }
                ]
            },
            {
                "id": 1873581,
                "content": [
                    {
                        "username": "ffmaer",
                        "content": "https://codepen.io/ffmaer/pen/xxGgeaE\\n\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633181.png)\\nInput: [[2]]\\nOutput: 10\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633188.png)\\nInput: [[1,2],[3,4]]\\nOutput: 34\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633195.png)\\nInput: [[1,0],[0,2]]\\nOutput: 16\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633203.png)\\nInput: [[1,1,1],[1,0,1],[1,1,1]]\\nOutput: 32\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633208.png)\\nInput: [[2,2,2],[2,1,2],[2,2,2]]\\nOutput: 46"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Man , THANK YOU SOOOO MUCH : )"
                    },
                    {
                        "username": "lin36716",
                        "content": "Thanks for the visualization, I really appreciate that, I had a slight difficulty to comprehend this problem and thought for a great hours...."
                    },
                    {
                        "username": "martinvelez",
                        "content": "I think this problem should be labeled as Medium.  (This is under the assumption that problems are manually labeled.) . I took a long time to solve this problem. I may have been misled by initial intuition which was to find the maximum of each row and the maximum of each column.  That gives me *part* of the surface area visible from x and y.  I developed a complex way of counting the surface area not visible from x and y.  The surface area of z is just the count of nonzero values * 2.\\n\\nI have read others\\' solution and, in hindsight, they are much more straight forward.  Essentially, compute the surface area of each grid but substract the overlapping areas.\\n\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be much much better. It just tests geometry/ mathematical formulas which most people dont use on a regular basis - and recruiters dont seem to understand this."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have some trouble to understand the question. For me a grid like that [[1]] has as area 5.\\nWhy? because the bottom is hidden.\\nMy code doesn\\'t pass the tests, of corse.\\nWhen I read the solutions, I was thinking: why they count the bottom?\\nI read the description again and... I found the solution; this sentence:\\n\"Note: The bottom face of each shape counts toward its surface area.\"\\nIt\\'s true: The biggest bug is the one sitting on the chair!\\n\\n"
                    },
                    {
                        "username": "charlychuanli",
                        "content": "one cube next to another tower with 5 cube, how could it return 6?  the surface of the 5 cube tower is alreadly bigger than 6."
                    },
                    {
                        "username": "htfy96",
                        "content": "The description says the answer for `[[1,0],[0,2]]` should be `16`, but when running code with custom testcase the *expected answer* outputs `20`. Maybe there are some mistakes in the sample program?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/htfy96/image_1535289972.png)\\n"
                    },
                    {
                        "username": "n761z",
                        "content": "Can someone suggest me a video editorial for this question. "
                    }
                ]
            },
            {
                "id": 1569302,
                "content": [
                    {
                        "username": "ffmaer",
                        "content": "https://codepen.io/ffmaer/pen/xxGgeaE\\n\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633181.png)\\nInput: [[2]]\\nOutput: 10\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633188.png)\\nInput: [[1,2],[3,4]]\\nOutput: 34\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633195.png)\\nInput: [[1,0],[0,2]]\\nOutput: 16\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633203.png)\\nInput: [[1,1,1],[1,0,1],[1,1,1]]\\nOutput: 32\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633208.png)\\nInput: [[2,2,2],[2,1,2],[2,2,2]]\\nOutput: 46"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Man , THANK YOU SOOOO MUCH : )"
                    },
                    {
                        "username": "lin36716",
                        "content": "Thanks for the visualization, I really appreciate that, I had a slight difficulty to comprehend this problem and thought for a great hours...."
                    },
                    {
                        "username": "martinvelez",
                        "content": "I think this problem should be labeled as Medium.  (This is under the assumption that problems are manually labeled.) . I took a long time to solve this problem. I may have been misled by initial intuition which was to find the maximum of each row and the maximum of each column.  That gives me *part* of the surface area visible from x and y.  I developed a complex way of counting the surface area not visible from x and y.  The surface area of z is just the count of nonzero values * 2.\\n\\nI have read others\\' solution and, in hindsight, they are much more straight forward.  Essentially, compute the surface area of each grid but substract the overlapping areas.\\n\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be much much better. It just tests geometry/ mathematical formulas which most people dont use on a regular basis - and recruiters dont seem to understand this."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have some trouble to understand the question. For me a grid like that [[1]] has as area 5.\\nWhy? because the bottom is hidden.\\nMy code doesn\\'t pass the tests, of corse.\\nWhen I read the solutions, I was thinking: why they count the bottom?\\nI read the description again and... I found the solution; this sentence:\\n\"Note: The bottom face of each shape counts toward its surface area.\"\\nIt\\'s true: The biggest bug is the one sitting on the chair!\\n\\n"
                    },
                    {
                        "username": "charlychuanli",
                        "content": "one cube next to another tower with 5 cube, how could it return 6?  the surface of the 5 cube tower is alreadly bigger than 6."
                    },
                    {
                        "username": "htfy96",
                        "content": "The description says the answer for `[[1,0],[0,2]]` should be `16`, but when running code with custom testcase the *expected answer* outputs `20`. Maybe there are some mistakes in the sample program?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/htfy96/image_1535289972.png)\\n"
                    },
                    {
                        "username": "n761z",
                        "content": "Can someone suggest me a video editorial for this question. "
                    }
                ]
            },
            {
                "id": 1572105,
                "content": [
                    {
                        "username": "ffmaer",
                        "content": "https://codepen.io/ffmaer/pen/xxGgeaE\\n\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633181.png)\\nInput: [[2]]\\nOutput: 10\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633188.png)\\nInput: [[1,2],[3,4]]\\nOutput: 34\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633195.png)\\nInput: [[1,0],[0,2]]\\nOutput: 16\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633203.png)\\nInput: [[1,1,1],[1,0,1],[1,1,1]]\\nOutput: 32\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633208.png)\\nInput: [[2,2,2],[2,1,2],[2,2,2]]\\nOutput: 46"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Man , THANK YOU SOOOO MUCH : )"
                    },
                    {
                        "username": "lin36716",
                        "content": "Thanks for the visualization, I really appreciate that, I had a slight difficulty to comprehend this problem and thought for a great hours...."
                    },
                    {
                        "username": "martinvelez",
                        "content": "I think this problem should be labeled as Medium.  (This is under the assumption that problems are manually labeled.) . I took a long time to solve this problem. I may have been misled by initial intuition which was to find the maximum of each row and the maximum of each column.  That gives me *part* of the surface area visible from x and y.  I developed a complex way of counting the surface area not visible from x and y.  The surface area of z is just the count of nonzero values * 2.\\n\\nI have read others\\' solution and, in hindsight, they are much more straight forward.  Essentially, compute the surface area of each grid but substract the overlapping areas.\\n\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be much much better. It just tests geometry/ mathematical formulas which most people dont use on a regular basis - and recruiters dont seem to understand this."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have some trouble to understand the question. For me a grid like that [[1]] has as area 5.\\nWhy? because the bottom is hidden.\\nMy code doesn\\'t pass the tests, of corse.\\nWhen I read the solutions, I was thinking: why they count the bottom?\\nI read the description again and... I found the solution; this sentence:\\n\"Note: The bottom face of each shape counts toward its surface area.\"\\nIt\\'s true: The biggest bug is the one sitting on the chair!\\n\\n"
                    },
                    {
                        "username": "charlychuanli",
                        "content": "one cube next to another tower with 5 cube, how could it return 6?  the surface of the 5 cube tower is alreadly bigger than 6."
                    },
                    {
                        "username": "htfy96",
                        "content": "The description says the answer for `[[1,0],[0,2]]` should be `16`, but when running code with custom testcase the *expected answer* outputs `20`. Maybe there are some mistakes in the sample program?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/htfy96/image_1535289972.png)\\n"
                    },
                    {
                        "username": "n761z",
                        "content": "Can someone suggest me a video editorial for this question. "
                    }
                ]
            },
            {
                "id": 1798027,
                "content": [
                    {
                        "username": "ffmaer",
                        "content": "https://codepen.io/ffmaer/pen/xxGgeaE\\n\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633181.png)\\nInput: [[2]]\\nOutput: 10\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633188.png)\\nInput: [[1,2],[3,4]]\\nOutput: 34\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633195.png)\\nInput: [[1,0],[0,2]]\\nOutput: 16\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633203.png)\\nInput: [[1,1,1],[1,0,1],[1,1,1]]\\nOutput: 32\\n![image](https://assets.leetcode.com/users/ffmaer/image_1582633208.png)\\nInput: [[2,2,2],[2,1,2],[2,2,2]]\\nOutput: 46"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "Man , THANK YOU SOOOO MUCH : )"
                    },
                    {
                        "username": "lin36716",
                        "content": "Thanks for the visualization, I really appreciate that, I had a slight difficulty to comprehend this problem and thought for a great hours...."
                    },
                    {
                        "username": "martinvelez",
                        "content": "I think this problem should be labeled as Medium.  (This is under the assumption that problems are manually labeled.) . I took a long time to solve this problem. I may have been misled by initial intuition which was to find the maximum of each row and the maximum of each column.  That gives me *part* of the surface area visible from x and y.  I developed a complex way of counting the surface area not visible from x and y.  The surface area of z is just the count of nonzero values * 2.\\n\\nI have read others\\' solution and, in hindsight, they are much more straight forward.  Essentially, compute the surface area of each grid but substract the overlapping areas.\\n\\n"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem description could be much much better. It just tests geometry/ mathematical formulas which most people dont use on a regular basis - and recruiters dont seem to understand this."
                    },
                    {
                        "username": "hafid-hub",
                        "content": "I have some trouble to understand the question. For me a grid like that [[1]] has as area 5.\\nWhy? because the bottom is hidden.\\nMy code doesn\\'t pass the tests, of corse.\\nWhen I read the solutions, I was thinking: why they count the bottom?\\nI read the description again and... I found the solution; this sentence:\\n\"Note: The bottom face of each shape counts toward its surface area.\"\\nIt\\'s true: The biggest bug is the one sitting on the chair!\\n\\n"
                    },
                    {
                        "username": "charlychuanli",
                        "content": "one cube next to another tower with 5 cube, how could it return 6?  the surface of the 5 cube tower is alreadly bigger than 6."
                    },
                    {
                        "username": "htfy96",
                        "content": "The description says the answer for `[[1,0],[0,2]]` should be `16`, but when running code with custom testcase the *expected answer* outputs `20`. Maybe there are some mistakes in the sample program?\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/htfy96/image_1535289972.png)\\n"
                    },
                    {
                        "username": "n761z",
                        "content": "Can someone suggest me a video editorial for this question. "
                    }
                ]
            }
        ]
    }
]