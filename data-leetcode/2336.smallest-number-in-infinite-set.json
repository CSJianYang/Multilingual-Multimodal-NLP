[
    {
        "title": "Smallest Number in Infinite Set",
        "question_content": "You have a set which contains all positive integers [1, 2, 3, 4, 5, ...].\nImplement the SmallestInfiniteSet class:\n\n\tSmallestInfiniteSet() Initializes the SmallestInfiniteSet object to contain all positive integers.\n\tint popSmallest() Removes and returns the smallest integer contained in the infinite set.\n\tvoid addBack(int num) Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\n\n&nbsp;\nExample 1:\n\nInput\n[\"SmallestInfiniteSet\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\", \"addBack\", \"popSmallest\", \"popSmallest\", \"popSmallest\"]\n[[], [2], [], [], [], [1], [], [], []]\nOutput\n[null, null, 1, 2, 3, null, 1, 4, 5]\nExplanation\nSmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();\nsmallestInfiniteSet.addBack(2);    // 2 is already in the set, so no change is made.\nsmallestInfiniteSet.popSmallest(); // return 1, since 1 is the smallest number, and remove it from the set.\nsmallestInfiniteSet.popSmallest(); // return 2, and remove it from the set.\nsmallestInfiniteSet.popSmallest(); // return 3, and remove it from the set.\nsmallestInfiniteSet.addBack(1);    // 1 is added back to the set.\nsmallestInfiniteSet.popSmallest(); // return 1, since 1 was added back to the set and\n                                   // is the smallest number, and remove it from the set.\nsmallestInfiniteSet.popSmallest(); // return 4, and remove it from the set.\nsmallestInfiniteSet.popSmallest(); // return 5, and remove it from the set.\n\n&nbsp;\nConstraints:\n\n\t1 <= num <= 1000\n\tAt most 1000 calls will be made in total to popSmallest and addBack.",
        "solutions": [
            {
                "id": 2263510,
                "title": "without-hardcoding-the-value-1000",
                "content": "I saw a lot of top solutions pushing 1-> 1000 numbers in pq/set which I personally dont find good enough\\n\\n**APPROACH**\\nmaintain a variable which points to the current smallest element untill addBack is called\\nwhen addBack() is called only add elements to the set which were popped earlier i.e. smaller than cur\\nwhen popSmallest() is called return the top most element in the set if it exists else return cur\\n\\nI believe this approach uses less time and space as the set only holds elements that were added back\\nI got 100% faster submission in both time and space(c++)\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    int cur;\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        cur=1;\\n    }\\n    \\n    int popSmallest() {\\n        if(s.size()){\\n            int res=*s.begin(); s.erase(res);\\n            return res;\\n        }else{\\n            cur+=1;\\n            return cur-1;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if(cur>num) s.insert(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    int cur;\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        cur=1;\\n    }\\n    \\n    int popSmallest() {\\n        if(s.size()){\\n            int res=*s.begin(); s.erase(res);\\n            return res;\\n        }else{\\n            cur+=1;\\n            return cur-1;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if(cur>num) s.insert(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452136,
                "title": "image-explanation-fastest-easiest-with-dry-run-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Smallest Number in Infinite Set` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/aefbbfc7-4b81-4ea2-bd23-4e3064a39177_1682385546.3503208.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/e8cb1c49-5750-4fdb-a733-b39d76ea476c_1682384840.3456388.png)\\n![image.png](https://assets.leetcode.com/users/images/6f00cf50-ee04-4f65-8202-fc37cfda399b_1682384848.507986.png)\\n![image.png](https://assets.leetcode.com/users/images/acad4155-1b23-4606-91a9-514d16e1bba3_1682384859.145118.png)\\n![image.png](https://assets.leetcode.com/users/images/851e118e-145a-4296-9294-6a7805caf081_1682384867.60344.png)\\n![image.png](https://assets.leetcode.com/users/images/c76817e7-fd01-46e2-8204-d149feeb9fe3_1682384877.9855342.png)\\n![image.png](https://assets.leetcode.com/users/images/67bb9cfa-b063-4786-afae-4216e69e6a4e_1682384884.6454256.png)\\n![image.png](https://assets.leetcode.com/users/images/2d393c59-7eba-4b9e-b915-8a770fe41ea1_1682384890.7847543.png)\\n\\n# Code\\n```C++ []\\nclass SmallestInfiniteSet {\\npublic:\\n    int cur;\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        cur=1;\\n    }\\n    \\n    int popSmallest() {\\n        if(s.size()){\\n            int res=*s.begin(); s.erase(res);\\n            return res;\\n        }else{\\n            cur++;\\n            return cur-1;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if(cur>num) s.insert(num);\\n    }\\n};\\n```\\n```Java []\\nclass SmallestInfiniteSet {\\n    int cur;\\n    Set<Integer> s;\\n    \\n    public SmallestInfiniteSet() {\\n        cur = 1;\\n        s = new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        if (!s.isEmpty()) {\\n            int res = Collections.min(s);\\n            s.remove(res);\\n            return res;\\n        } else {\\n            cur++;\\n            return cur - 1;\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if (cur > num) {\\n            s.add(num);\\n        }\\n    }\\n}\\n```\\n```Python []\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.cur = 1\\n        self.s = set()\\n\\n    def popSmallest(self):\\n        if self.s:\\n            res = min(self.s)\\n            self.s.remove(res)\\n            return res\\n        else:\\n            self.cur += 1\\n            return self.cur - 1\\n\\n    def addBack(self, num):\\n        if self.cur > num:\\n            self.s.add(num) \\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```C++ []\\nclass SmallestInfiniteSet {\\npublic:\\n    int cur;\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        cur=1;\\n    }\\n    \\n    int popSmallest() {\\n        if(s.size()){\\n            int res=*s.begin(); s.erase(res);\\n            return res;\\n        }else{\\n            cur++;\\n            return cur-1;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if(cur>num) s.insert(num);\\n    }\\n};\\n```\n```Java []\\nclass SmallestInfiniteSet {\\n    int cur;\\n    Set<Integer> s;\\n    \\n    public SmallestInfiniteSet() {\\n        cur = 1;\\n        s = new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        if (!s.isEmpty()) {\\n            int res = Collections.min(s);\\n            s.remove(res);\\n            return res;\\n        } else {\\n            cur++;\\n            return cur - 1;\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if (cur > num) {\\n            s.add(num);\\n        }\\n    }\\n}\\n```\n```Python []\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.cur = 1\\n        self.s = set()\\n\\n    def popSmallest(self):\\n        if self.s:\\n            res = min(self.s)\\n            self.s.remove(res)\\n            return res\\n        else:\\n            self.cur += 1\\n            return self.cur - 1\\n\\n    def addBack(self, num):\\n        if self.cur > num:\\n            self.s.add(num) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265333,
                "title": "set-and-counter",
                "content": "We use counter `cur` so we do not have to track all numbers in the set. We only use `set` to track added back numbers.\\n\\n**C++**\\n```cpp\\nclass SmallestInfiniteSet {\\npublic:\\n    int cur = 1;\\n    set<int> added; \\n    int popSmallest() {\\n        if (!added.empty()) {\\n            int res = *begin(added);\\n            added.erase(begin(added));\\n            return res;\\n        }\\n        return cur++;\\n    }\\n    void addBack(int num) {\\n        if (num < cur)\\n            added.insert(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass SmallestInfiniteSet {\\npublic:\\n    int cur = 1;\\n    set<int> added; \\n    int popSmallest() {\\n        if (!added.empty()) {\\n            int res = *begin(added);\\n            added.erase(begin(added));\\n            return res;\\n        }\\n        return cur++;\\n    }\\n    void addBack(int num) {\\n        if (num < cur)\\n            added.insert(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261300,
                "title": "full-explanations-c-set-easy-to-understand-also-java-python-code",
                "content": "**The constraints say the numbers are between 1 and 1000 (inclusive) and there are at most 1000 operations. So we don\\'t need to populate more than 1000.**\\n* insert :- because of **set property all element are in sorted order**.\\n* popSmallest() :- in **set first element is smallet element** in all the element **so we pop last first element**.\\n\\n**Upvote if you like my apporch\\uD83D\\uDE01\\uD83D\\uDE80\\u2764\\uFE0F\\u200D\\uD83D\\uDD25**\\n\\n\\n**C++ Code :-**\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int>st;\\n    SmallestInfiniteSet() {\\n        st.clear();\\n        for(int i=1;i<=1000;i++){\\n            st.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int t = *st.begin();\\n        st.erase(st.begin());\\n        return t;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n```\\n**Please upvote is you like**\\n\\n**Java Code:-**\\n```\\nclass SmallestInfiniteSet {\\n    SortedSet<Integer> s=new TreeSet<Integer>();\\n    public SmallestInfiniteSet() {\\n        for(int i=1;i<1001;i++){\\n            s.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        int k=s.first();\\n        s.remove(k);\\n        return k;\\n    }\\n    \\n    public void addBack(int num) {\\n        s.add(num);\\n    }\\n}\\n```\\n\\n**Python Code :-**\\n```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.visited = set(x for x in range(1,1001))\\n\\n    def popSmallest(self) -> int:\\n        temp = min(self.visited)\\n        self.visited.remove(temp)\\n        return temp\\n\\n    def addBack(self, num: int) -> None:\\n        if num not in self.visited:\\n            self.visited.add(num)\\n```\\n\\n**When Constraints not given**\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    int cur;\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        cur=1;\\n    }\\n    \\n    int popSmallest() {\\n        if(s.size()){\\n            int res=*s.begin(); s.erase(res);\\n            return res;\\n        }else{\\n            cur++;\\n            return cur-1;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if(cur>num) s.insert(num);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/44f4a479-9b3e-4a70-bad4-a32a7fe19cd2_1657427852.6419635.png)\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/2549bf22-2de5-4a08-b403-d4e00a47e10e_1657427562.3537555.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int>st;\\n    SmallestInfiniteSet() {\\n        st.clear();\\n        for(int i=1;i<=1000;i++){\\n            st.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int t = *st.begin();\\n        st.erase(st.begin());\\n        return t;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n```\n```\\nclass SmallestInfiniteSet {\\n    SortedSet<Integer> s=new TreeSet<Integer>();\\n    public SmallestInfiniteSet() {\\n        for(int i=1;i<1001;i++){\\n            s.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        int k=s.first();\\n        s.remove(k);\\n        return k;\\n    }\\n    \\n    public void addBack(int num) {\\n        s.add(num);\\n    }\\n}\\n```\n```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.visited = set(x for x in range(1,1001))\\n\\n    def popSmallest(self) -> int:\\n        temp = min(self.visited)\\n        self.visited.remove(temp)\\n        return temp\\n\\n    def addBack(self, num: int) -> None:\\n        if num not in self.visited:\\n            self.visited.add(num)\\n```\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    int cur;\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        cur=1;\\n    }\\n    \\n    int popSmallest() {\\n        if(s.size()){\\n            int res=*s.begin(); s.erase(res);\\n            return res;\\n        }else{\\n            cur++;\\n            return cur-1;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if(cur>num) s.insert(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452140,
                "title": "easy-solution-explained-with-dry-run-minheap-counter-beginner-friendly",
                "content": "# Intuition\\nThe question wants us to implement a data structure that can efficiently return the minimum element in infinite set of integers, first thought comes to mind is minHeap as it will always contains minimum element at top and operation would take O(1) time.\\n\\n- **Heap** will store the minimum of the elements that are addedBack via addBack() method\\n- minNum or say counter will keep track of continous non popped elements\\n\\n---\\n\\n\\n# Approach\\nLook at dry run example below approach to understand code better.\\n### *addBack()*\\n1) If the number to be added(num) is less than minNum ie ```num < minNum```, then it means that num has not been popped yet.\\n2) Also we don\\'t want to add duplicates, so if nums is already present in heap we don\\'t add it.\\n3) else add to heap\\n\\n### *popSmallest*()\\n1) If the heap is not empty ```!heap.isEmpty()``` then we return top element from heap and remove it.\\n2) Incase heap is empty then we increment minNum and return minNum-1\\n, minNum keeps the track of numbers we have taken out till now.\\n\\n----\\nExample\\n*Operation* - popSmallest\\nresult 1 : (heap empty --> increment minNum --> minNum = 2)\\n\\n*Operation* - popSmallest\\nresult 2 : (heap empty --> increment minNum --> minNum = 3)\\n\\n*Operation* - addBack(2)\\nadded to heap : minNum > num  (3>2 and !heap.contains(2))\\nadd to heap --> heap contains 2 now\\n\\n*Operation* - popSmallest\\nresult 2 not 3 as we will return from heap which is not empty\\n\\n*Operation* - popSmallest\\nresult 3 (heap empty --> increment minNum --> = minNum 4)\\n\\n*Operation* - addSmallest(5)\\n5 will not be added as minNum > num not satisfied 4>5 (this means num=5 is not popped yet)\\n\\n---\\n***P.S*** This is a tricky question if you solve it considering infinite integers and not 1000 integer upperbound, If asked in interview interviewer won\\'t except asnwer with 1000 intialisation of heap or hashset in the constructor.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) : minHeapigy take logn each time, assuming n opertions happen at max nlogn will be complexity\\n\\n- Space complexity:\\nO(n) in worst case\\n\\n----\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n\\n----\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n\\n    private Integer minNum;\\n    private PriorityQueue<Integer> heap;\\n\\n    public SmallestInfiniteSet() {\\n        minNum = 1;\\n        heap = new PriorityQueue<>();\\n    }\\n    \\n   public int popSmallest() {\\n        if (!heap.isEmpty()) {\\n            return heap.poll();\\n        }\\n        minNum++;\\n        return minNum - 1;\\n    }\\n\\n    public void addBack(int num) {\\n        if (minNum > num && !heap.contains(num)) {\\n            heap.offer(num);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```num < minNum```\n```!heap.isEmpty()```\n```\\nclass SmallestInfiniteSet {\\n\\n    private Integer minNum;\\n    private PriorityQueue<Integer> heap;\\n\\n    public SmallestInfiniteSet() {\\n        minNum = 1;\\n        heap = new PriorityQueue<>();\\n    }\\n    \\n   public int popSmallest() {\\n        if (!heap.isEmpty()) {\\n            return heap.poll();\\n        }\\n        minNum++;\\n        return minNum - 1;\\n    }\\n\\n    public void addBack(int num) {\\n        if (minNum > num && !heap.contains(num)) {\\n            heap.offer(num);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261425,
                "title": "priority-queue-with-set-explained",
                "content": "We will have a `next_num` runner to know what is the next number to return from the infinite set.\\n\\nTo handle the \"addBack\" logic we are going to have a priority queue.\\n\\nTo stop \"addBack\" from inserting the same number multiple times, for example: addBack -> 3,3,3, we are going to have a set.\\n\\n# Code\\n```\\nfrom heapq import heapify, heappop, heappush\\n\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.next_num = 1\\n        self.added_back_heap = []\\n        self.added_back_set = set()\\n        \\n\\n    def popSmallest(self) -> int:\\n        if self.added_back_heap:\\n            smallest = heappop(self.added_back_heap)\\n            self.added_back_set.remove(smallest)\\n            return smallest\\n    \\n        num_to_return = self.next_num\\n        self.next_num += 1\\n        return num_to_return\\n        \\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.next_num and num not in self.added_back_set:\\n            self.added_back_set.add(num)\\n            heappush(self.added_back_heap, num)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nfrom heapq import heapify, heappop, heappush\\n\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.next_num = 1\\n        self.added_back_heap = []\\n        self.added_back_set = set()\\n        \\n\\n    def popSmallest(self) -> int:\\n        if self.added_back_heap:\\n            smallest = heappop(self.added_back_heap)\\n            self.added_back_set.remove(smallest)\\n            return smallest\\n    \\n        num_to_return = self.next_num\\n        self.next_num += 1\\n        return num_to_return\\n        \\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.next_num and num not in self.added_back_set:\\n            self.added_back_set.add(num)\\n            heappush(self.added_back_heap, num)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261433,
                "title": "java-clean-simple-priorityqueue",
                "content": "```\\nclass SmallestInfiniteSet {\\n    PriorityQueue<Integer> queue;\\n    int current;\\n\\n    public SmallestInfiniteSet() {\\n        queue = new PriorityQueue<>();\\n        current = 1;\\n    }\\n\\n    public int popSmallest() {\\n        int result = current;\\n\\n        if (!queue.isEmpty() && queue.peek() < current)\\n            result = queue.poll();\\n        else\\n            current++;\\n\\n        while (!queue.isEmpty() && queue.peek() == result)\\n            queue.poll();\\n\\n        return result;\\n    }\\n\\n    public void addBack(int num) {\\n        queue.add(num);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    PriorityQueue<Integer> queue;\\n    int current;\\n\\n    public SmallestInfiniteSet() {\\n        queue = new PriorityQueue<>();\\n        current = 1;\\n    }\\n\\n    public int popSmallest() {\\n        int result = current;\\n\\n        if (!queue.isEmpty() && queue.peek() < current)\\n            result = queue.poll();\\n        else\\n            current++;\\n\\n        while (!queue.isEmpty() && queue.peek() == result)\\n            queue.poll();\\n\\n        return result;\\n    }\\n\\n    public void addBack(int num) {\\n        queue.add(num);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452516,
                "title": "c-easy-2-methords-map-set",
                "content": "# Intuition\\nHere is some Key points to focus.\\n\\nOur all integer are in range of 1 to 1000.\\n\\nwe need to pop smallest Number from a list , most efficient way to find smallest numbe from a list by either using set or map or priority queue . With time complexity of log(N).\\n\\ninserting a new value if it is not not in our list. This can also be done Easly in Set and map as map does not store duplicate keys and set does not store dublicate elements , and insertion and removing both have time complexity of log(n), this is the lest time complexity we can have any data stucture.\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Using Map\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    map<int,int> mp;\\n    SmallestInfiniteSet() {\\n        for(int i =1;i<=1000;i++) mp[i]++;\\n    }\\n    \\n    int popSmallest() {\\n        int a = mp.begin()->first;\\n        mp.erase(a);\\n        return a;\\n    }\\n    \\n    void addBack(int num) {\\n        mp[num]++;\\n    }\\n};\\n```\\n# using Set\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() {\\n        for(int i =1;i<=1000;i++) st.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int a = *st.begin();\\n        st.erase(a);\\n        return a;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    map<int,int> mp;\\n    SmallestInfiniteSet() {\\n        for(int i =1;i<=1000;i++) mp[i]++;\\n    }\\n    \\n    int popSmallest() {\\n        int a = mp.begin()->first;\\n        mp.erase(a);\\n        return a;\\n    }\\n    \\n    void addBack(int num) {\\n        mp[num]++;\\n    }\\n};\\n```\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() {\\n        for(int i =1;i<=1000;i++) st.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int a = *st.begin();\\n        st.erase(a);\\n        return a;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261592,
                "title": "using-sorted-hashset-java-easy-o-logn-complexity-explained",
                "content": "The idea is as follows,\\n1. Initially all the elements will be present in smallest set. \\nLater, as the elements are popped, one by one the smallest element will be removed. `currentCounter` tracks the next smallest element to be popped.\\n\\n2. Later, the new elements are added back as well. Those added elements can be maintained in separate data structure. We have to chose a data structure such that it gives us smallest element quickly. Options could be using priorityQueue. \\nBut, one problem with priorityQueue is that it can have duplicate elements. To avoid checking duplicates we can use a HashSet that follows a sorted order. So that top element of hashset is always the next element to be popped. In java we use treeSet.\\n\\n3. Next time when new elements are popped, \\n-  if treeSet is empty the smallest element is currentCounter. \\n-  If treeSet is not empty, the smallest element is first element in tree set.\\n\\n```\\nclass SmallestInfiniteSet {\\n    TreeSet<Integer> set;\\n    int currentCounter;\\n    public SmallestInfiniteSet() {\\n        set = new TreeSet<Integer>();\\n        currentCounter = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        if(!set.isEmpty()){\\n            int top = set.first();\\n            set.remove(top);\\n            return top;\\n        }\\n        return currentCounter++;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(num >= currentCounter)\\n            return;\\n        set.add(num);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    TreeSet<Integer> set;\\n    int currentCounter;\\n    public SmallestInfiniteSet() {\\n        set = new TreeSet<Integer>();\\n        currentCounter = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        if(!set.isEmpty()){\\n            int top = set.first();\\n            set.remove(top);\\n            return top;\\n        }\\n        return currentCounter++;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(num >= currentCounter)\\n            return;\\n        set.add(num);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261732,
                "title": "c-use-vector-and-solved-in-one-go",
                "content": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    bool v[1001];\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<1001;i++)\\n        {\\n            v[i]=1;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int i=1;\\n        while(v[i]!=1)\\n        {\\n            i++;\\n        }\\n        v[i]=0;\\n        return i;\\n        \\n    }\\n    \\n    void addBack(int num) {\\n        v[num]=1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    bool v[1001];\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<1001;i++)\\n        {\\n            v[i]=1;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int i=1;\\n        while(v[i]!=1)\\n        {\\n            i++;\\n        }\\n        v[i]=0;\\n        return i;\\n        \\n    }\\n    \\n    void addBack(int num) {\\n        v[num]=1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453958,
                "title": "super-logic-with-heap-approach",
                "content": "```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.heap=[]\\n        self.min_num=1\\n        \\n    def popSmallest(self) -> int:\\n        if self.heap:\\n            return heapq.heappop(self.heap)\\n        self.min_num+=1\\n        return self.min_num-1\\n        \\n    def addBack(self, num: int) -> None:\\n        if self.min_num>num and num not in self.heap:\\n            heapq.heappush(self.heap,num)\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.heap=[]\\n        self.min_num=1\\n        \\n    def popSmallest(self) -> int:\\n        if self.heap:\\n            return heapq.heappop(self.heap)\\n        self.min_num+=1\\n        return self.min_num-1\\n        \\n    def addBack(self, num: int) -> None:\\n        if self.min_num>num and num not in self.heap:\\n            heapq.heappush(self.heap,num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452278,
                "title": "c-code-easy-short-hashmap-explained",
                "content": "- My intuition was to store the minimum element and the hash map \\n- and if the element is true in the hash map then it is logical that the the element is already popped out of the set\\n- After popping any element I make it true in the hash map.\\n- When a new element is popped back into the set then I change the hash value of it to false\\n- And if the mini < addback element then I update the mini value\\n- Next time mini value gets popped but there can be residual elements that are already popped before, so I used a while loop to get the next mini element.\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    int mini;\\n    unordered_map<int,bool> mp;\\n    SmallestInfiniteSet() { \\n        mini=1;               \\n    }\\n    \\n    int popSmallest() {\\n        int i=0;\\n        while(mp[mini+i]){\\n            i++;\\n        }\\n        mp[mini+i]=true;\\n        mini += i+1;\\n        return mini-1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(mp[num]){\\n            mini=min(mini,num);\\n            mp[num]=false;\\n        }                 \\n    }\\n};\\n```\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/83b52d34-d478-45a3-9c7f-69ede41e98d9_1682389995.619281.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    int mini;\\n    unordered_map<int,bool> mp;\\n    SmallestInfiniteSet() { \\n        mini=1;               \\n    }\\n    \\n    int popSmallest() {\\n        int i=0;\\n        while(mp[mini+i]){\\n            i++;\\n        }\\n        mp[mini+i]=true;\\n        mini += i+1;\\n        return mini-1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(mp[num]){\\n            mini=min(mini,num);\\n            mp[num]=false;\\n        }                 \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263266,
                "title": "python-java-90-faster-100-space-heap-index-with-explanations",
                "content": "**\\u2B06\\uFE0F\\uD83E\\uDD29\\uD83D\\uDD25\\u26A1\\u2B06\\uFE0F Up Vote If You Like My Answers \\u2B06\\uFE0F\\uD83E\\uDD29\\uD83D\\uDD25\\u26A1\\u2B06\\uFE0F**\\n\\nThe `index` would tell us what number we need to take out now,\\nand the heap will keep all the nums that are added later on.\\n\\nWhen ``popSmallest`` we check the heap:\\n- if the heap is not empty, meaning someone added a num and we can take it out (min heap = pop of min value).\\n- if the heap is empty we just give it the number the `index` is on it.\\n\\nWhen we `addBack` we check the num:\\n- first that it\\'s smaller then `index`, meaning we could have poped it, otherwise it wring value.\\n- second, if it\\'s not alrady in the heap. \\n\\n```python []\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.index = 1\\n        self.heap = []\\n\\n    def popSmallest(self) -> int:\\n        if self.heap:\\n            return heapq.heappop(self.heap)\\n        self.index += 1\\n        return self.index-1\\n\\n    def addBack(self, num: int) -> None:\\n        if self.index > num and num not in self.heap:\\n            heapq.heappush(self.heap,num)\\n```\\n```java []\\nclass SmallestInfiniteSet {\\n    private PriorityQueue<Integer> q;\\n    private int index;\\n    public SmallestInfiniteSet() {\\n        q = new PriorityQueue<Integer>();\\n        index = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        if (q.size()>0){\\n            return q.poll();\\n        }\\n        return index++;\\n    }\\n    \\n    private boolean is_in_q(int num){\\n        for(int i : q){\\n            if (i == num){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void addBack(int num) {\\n        if( num < index && !is_in_q(num)){\\n            q.add(num);\\n        }\\n    }\\n}\\n```\\n\\n\\n\\n\\n**Time Complexity:**\\n\\nThe init = `O(1)`\\nPop = `O(logn)` for the heappop.\\nAdd = `O(n+logn) = O(n)` (`O(n)` to check if num in heap, `O(logn)` to add to heap)\\n\\n**Space Complexity:**\\n\\nDue to the fact that we don\\'t have a limit to the number, it\\'s a bit of a problem to break it down,\\nbut `index` is `O(1)` space and the heap `O(max poped value)` - meaning if we pop `x` nums and then add them back, we could have a huge heap.\\nBut each value we keep is 8 bits, so it could become big.\\n\\nTo make it smaller in space we could use BitArr.\\n\\n**Note:** there is s trade off between time and space, if you want better space this is the solution, BUT for better time complexity, check-out @Himanshu3889 answer in the comments.",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python []\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.index = 1\\n        self.heap = []\\n\\n    def popSmallest(self) -> int:\\n        if self.heap:\\n            return heapq.heappop(self.heap)\\n        self.index += 1\\n        return self.index-1\\n\\n    def addBack(self, num: int) -> None:\\n        if self.index > num and num not in self.heap:\\n            heapq.heappush(self.heap,num)\\n```\n```java []\\nclass SmallestInfiniteSet {\\n    private PriorityQueue<Integer> q;\\n    private int index;\\n    public SmallestInfiniteSet() {\\n        q = new PriorityQueue<Integer>();\\n        index = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        if (q.size()>0){\\n            return q.poll();\\n        }\\n        return index++;\\n    }\\n    \\n    private boolean is_in_q(int num){\\n        for(int i : q){\\n            if (i == num){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public void addBack(int num) {\\n        if( num < index && !is_in_q(num)){\\n            q.add(num);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550100,
                "title": "python-heap-faster-than-90",
                "content": "According to this [conversation](https://stackoverflow.com/questions/7571635/fastest-way-to-check-if-a-value-exists-in-a-list) reversed dict (dictionary where d[x] provides the index of x) a little bit faster than set.\\nThe same code with set on average faster than 55% submissions only.\\n\\n![Screenshot 2023-05-22 at 03.10.42.png](https://assets.leetcode.com/users/images/c1dbe1ff-32a9-446f-8e34-b630bcac5aac_1684714277.117857.png)\\n\\n```python3 []\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.min_val = 1\\n        self.is_val_in_heap = {}\\n        #self.is_val_in_heap = set()\\n        self.heap = []\\n        heapify(self.heap)\\n\\n    def popSmallest(self) -> int:\\n        if not self.heap:\\n            smallest = self.min_val\\n            self.min_val +=1\\n        else:\\n            smallest = heappop(self.heap)\\n            del self.is_val_in_heap[smallest]\\n            #self.is_val_in_heap.remove(smallest)\\n        \\n        return smallest\\n\\n    def addBack(self, num: int) -> None:\\n        if num >= self.min_val or num in self.is_val_in_heap:\\n            return\\n        elif num == self.min_val - 1:\\n            self.min_val -= 1\\n        else:\\n            heappush(self.heap, num)\\n            self.is_val_in_heap[num] = True\\n            #self.is_val_in_heap.add(num)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```python3 []\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.min_val = 1\\n        self.is_val_in_heap = {}\\n        #self.is_val_in_heap = set()\\n        self.heap = []\\n        heapify(self.heap)\\n\\n    def popSmallest(self) -> int:\\n        if not self.heap:\\n            smallest = self.min_val\\n            self.min_val +=1\\n        else:\\n            smallest = heappop(self.heap)\\n            del self.is_val_in_heap[smallest]\\n            #self.is_val_in_heap.remove(smallest)\\n        \\n        return smallest\\n\\n    def addBack(self, num: int) -> None:\\n        if num >= self.min_val or num in self.is_val_in_heap:\\n            return\\n        elif num == self.min_val - 1:\\n            self.min_val -= 1\\n        else:\\n            heappush(self.heap, num)\\n            self.is_val_in_heap[num] = True\\n            #self.is_val_in_heap.add(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452223,
                "title": "easiest-java-solution-with-proper-explanation",
                "content": "# PLEASE UPVOTE!!!!\\n\\n![Screenshot 2023-04-25 at 07.28.00.png](https://assets.leetcode.com/users/images/d2828039-46da-4190-ad7c-3dc1b921f4bd_1682387906.273139.png)\\n\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Priority Queue and HashSet for smallest and unique funcionality needed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclaring HashSet and PriorityQueue and a variable smallest.\\nEverytime addback is called we check-\\n- if number is smaller than smallest\\n1. then add it to pq and set\\n- else do nothing.\\n\\nwhen popSmallest is called we are checking for smallest in pq or the smallest variable.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    PriorityQueue<Integer> pq;\\n    HashSet<Integer> set;\\n    int smallest;\\n\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<>();\\n        set = new HashSet<>();\\n        smallest = 1;\\n    }\\n\\n    public int popSmallest() {\\n        // System.out.println(\"popping smallest\");\\n        if (pq.isEmpty()) {\\n            // System.out.println(\"pq empty\");\\n            return smallest++;\\n        }\\n        // System.out.println(\"pq not empty peek: \"+pq.peek());\\n        set.remove(pq.peek());\\n        return pq.poll();\\n\\n    }\\n\\n    public void addBack(int num) {\\n        // System.out.println(\"num is \"+num+\" smallest is \"+smallest);\\n        if (smallest > num) {\\n            // System.out.println(\"inside if\");\\n            int sizeprev = set.size();\\n            set.add(num);\\n            if (sizeprev < set.size()) {\\n                pq.add(num);\\n            }\\n        }\\n\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    PriorityQueue<Integer> pq;\\n    HashSet<Integer> set;\\n    int smallest;\\n\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<>();\\n        set = new HashSet<>();\\n        smallest = 1;\\n    }\\n\\n    public int popSmallest() {\\n        // System.out.println(\"popping smallest\");\\n        if (pq.isEmpty()) {\\n            // System.out.println(\"pq empty\");\\n            return smallest++;\\n        }\\n        // System.out.println(\"pq not empty peek: \"+pq.peek());\\n        set.remove(pq.peek());\\n        return pq.poll();\\n\\n    }\\n\\n    public void addBack(int num) {\\n        // System.out.println(\"num is \"+num+\" smallest is \"+smallest);\\n        if (smallest > num) {\\n            // System.out.println(\"inside if\");\\n            int sizeprev = set.size();\\n            set.add(num);\\n            if (sizeprev < set.size()) {\\n                pq.add(num);\\n            }\\n        }\\n\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271543,
                "title": "simple-array-soooo-easy",
                "content": "# Intuition\\nUse index to represent the numbers.\\n\\nWell, I do welcome any better solutions. But this intuitive one works perfectly.\\n\\n# Complexity\\n- Time complexity:\\nO(n)>\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n  constructor() {\\n    this.arr = new Array(1001).fill(true);\\n  }\\n  popSmallest() {\\n    for (let i = 1; i < this.arr.length; i++) {\\n      if (this.arr[i]) {\\n        this.arr[i] = false;\\n        return i;\\n      }\\n    }\\n    return null;\\n  }\\n  addBack(num) {\\n    this.arr[num] = true;\\n  }\\n}\\n\\n```\\n\\n![1.jpg](https://assets.leetcode.com/users/images/b7c3d9b5-28e4-4431-888c-457b6148ab0e_1678261343.14182.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n  constructor() {\\n    this.arr = new Array(1001).fill(true);\\n  }\\n  popSmallest() {\\n    for (let i = 1; i < this.arr.length; i++) {\\n      if (this.arr[i]) {\\n        this.arr[i] = false;\\n        return i;\\n      }\\n    }\\n    return null;\\n  }\\n  addBack(num) {\\n    this.arr[num] = true;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784821,
                "title": "java-hashset-pq",
                "content": "```\\npublic class SmallestInfiniteSet {\\n\\n    // smallest integer which has never been popped.\\n    private int smallestNotPopped;\\n    // integers which have been added back, will be ordered.\\n    private PriorityQueue<Integer> addedBack;\\n    // Integers which have been popped.\\n    private HashSet<Integer> popped;\\n    public SmallestInfiniteSet() {\\n        smallestNotPopped = 1;\\n        addedBack = new PriorityQueue<>();\\n        popped = new HashSet<>();\\n    }\\n\\n    public int popSmallest() {\\n        // initialize answer to the smallest element not yet popped.\\n        int ans = smallestNotPopped;\\n        // if addedBack contains elements and has an element smaller than the smallestNotPopped\\n        // that would be the answer eg : popSmallest(1) popSmallest(2) popSmallest(3),\\n        // smallestNotPopped=4; addBack(3) .. since 3<4 return 3;\\n        if(!addedBack.isEmpty() && smallestNotPopped> addedBack.peek()) {\\n            ans = addedBack.poll();\\n        } else {\\n            // increment only when a new elment in popped.\\n            smallestNotPopped++;\\n        }\\n        // add to the pop set.\\n        popped.add(ans);\\n        return ans;\\n    }\\n\\n    public void addBack(int num) {\\n        // if already popped\\n        if(popped.contains(num)) {\\n            // remove from pop.\\n            popped.remove(num);\\n            // add to pq.\\n            addedBack.add(num);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class SmallestInfiniteSet {\\n\\n    // smallest integer which has never been popped.\\n    private int smallestNotPopped;\\n    // integers which have been added back, will be ordered.\\n    private PriorityQueue<Integer> addedBack;\\n    // Integers which have been popped.\\n    private HashSet<Integer> popped;\\n    public SmallestInfiniteSet() {\\n        smallestNotPopped = 1;\\n        addedBack = new PriorityQueue<>();\\n        popped = new HashSet<>();\\n    }\\n\\n    public int popSmallest() {\\n        // initialize answer to the smallest element not yet popped.\\n        int ans = smallestNotPopped;\\n        // if addedBack contains elements and has an element smaller than the smallestNotPopped\\n        // that would be the answer eg : popSmallest(1) popSmallest(2) popSmallest(3),\\n        // smallestNotPopped=4; addBack(3) .. since 3<4 return 3;\\n        if(!addedBack.isEmpty() && smallestNotPopped> addedBack.peek()) {\\n            ans = addedBack.poll();\\n        } else {\\n            // increment only when a new elment in popped.\\n            smallestNotPopped++;\\n        }\\n        // add to the pop set.\\n        popped.add(ans);\\n        return ans;\\n    }\\n\\n    public void addBack(int num) {\\n        // if already popped\\n        if(popped.contains(num)) {\\n            // remove from pop.\\n            popped.remove(num);\\n            // add to pq.\\n            addedBack.add(num);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453479,
                "title": "java-set-smallest-number-in-infinite-set",
                "content": "\\n```\\nimport java.util.TreeSet;\\n\\nclass SmallestInfiniteSet {\\n\\n    TreeSet<Integer> set;\\n    TreeSet<Integer> del;\\n    public SmallestInfiniteSet() {\\n        set = new TreeSet<>();\\n        set.add(1);\\n        del = new TreeSet<>();\\n    }\\n\\n    public int popSmallest() {\\n        if (!set.isEmpty()) {\\n            del.add(set.first());\\n            int i = set.first() + 1;\\n            while (del.contains(i)) i++;\\n            set.add(i);\\n            return set.pollFirst();\\n        }\\n        return 0;\\n    }\\n\\n    public void addBack(int num) {\\n        if (del.contains(num)) del.remove(num);\\n        set.add(num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.TreeSet;\\n\\nclass SmallestInfiniteSet {\\n\\n    TreeSet<Integer> set;\\n    TreeSet<Integer> del;\\n    public SmallestInfiniteSet() {\\n        set = new TreeSet<>();\\n        set.add(1);\\n        del = new TreeSet<>();\\n    }\\n\\n    public int popSmallest() {\\n        if (!set.isEmpty()) {\\n            del.add(set.first());\\n            int i = set.first() + 1;\\n            while (del.contains(i)) i++;\\n            set.add(i);\\n            return set.pollFirst();\\n        }\\n        return 0;\\n    }\\n\\n    public void addBack(int num) {\\n        if (del.contains(num)) del.remove(num);\\n        set.add(num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452593,
                "title": "c-compact-easy-solution-ordered-map-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution \\uD83D\\uDD25 || \\uD83D\\uDCAF\\uD83D\\uDCAFOrdered Map Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass SmallestInfiniteSet {\\n\\t//we have declared the map\\n    map<int,int>m;\\n    \\npublic:\\n    SmallestInfiniteSet() {\\n\\t\\t//we will put all the numbers till 1001 so that even after all the pop operation map not become empty\\n        for(int i=1;i<1002;i++){\\n            m[i]++;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n\\t\\t//we will store the value of top element as in map they are sorted in asending order\\n        int val=m.begin()->first;\\n\\t\\t//Erasing the element from the map\\n        m.erase(m.begin());\\n\\t\\t//returning the value\\n        return val;\\n    }\\n    \\n    void addBack(int num) {\\n\\t\\t//adding to the map \\n        m[num]++;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n\\t//we have declared the map\\n    map<int,int>m;\\n    \\npublic:\\n    SmallestInfiniteSet() {\\n\\t\\t//we will put all the numbers till 1001 so that even after all the pop operation map not become empty\\n        for(int i=1;i<1002;i++){\\n            m[i]++;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n\\t\\t//we will store the value of top element as in map they are sorted in asending order\\n        int val=m.begin()->first;\\n\\t\\t//Erasing the element from the map\\n        m.erase(m.begin());\\n\\t\\t//returning the value\\n        return val;\\n    }\\n    \\n    void addBack(int num) {\\n\\t\\t//adding to the map \\n        m[num]++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452190,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class SmallestInfiniteSet {\\n    PriorityQueue<int, int> pq;\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<int, int>(Enumerable.Range(1, 1000).Select(x => (x, x)));\\n    }\\n    \\n    public int PopSmallest() {\\n        int smallest = pq.Dequeue();\\n        while (pq.Count > 0 && pq.Peek() == smallest)\\n            pq.Dequeue();\\n\\n        return smallest;\\n    }\\n    \\n    public void AddBack(int num) {\\n        pq.Enqueue(num, num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.PopSmallest();\\n * obj.AddBack(num);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class SmallestInfiniteSet {\\n    PriorityQueue<int, int> pq;\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<int, int>(Enumerable.Range(1, 1000).Select(x => (x, x)));\\n    }\\n    \\n    public int PopSmallest() {\\n        int smallest = pq.Dequeue();\\n        while (pq.Count > 0 && pq.Peek() == smallest)\\n            pq.Dequeue();\\n\\n        return smallest;\\n    }\\n    \\n    public void AddBack(int num) {\\n        pq.Enqueue(num, num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.PopSmallest();\\n * obj.AddBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261549,
                "title": "easy-to-understand-c-solution",
                "content": "Smallest variable indicates that all values greater than equal to smallest are in the infinite set. All the values smaller than smallest which are in inifinite set are inserted into the set s.\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    int smallest=1;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        int t=smallest;\\n        if(!s.empty()){ // s will contain values smaller than smallest so return first element of the set\\n            t=*s.begin();\\n            s.erase(s.begin());\\n            return t;\\n        }\\n        smallest++;\\n        return t;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num<smallest){\\n            s.insert(num);\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    int smallest=1;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        int t=smallest;\\n        if(!s.empty()){ // s will contain values smaller than smallest so return first element of the set\\n            t=*s.begin();\\n            s.erase(s.begin());\\n            return t;\\n        }\\n        smallest++;\\n        return t;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num<smallest){\\n            s.insert(num);\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261257,
                "title": "smallest-number-in-infinite-set-java-solution",
                "content": "```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    SmallestInfiniteSet() \\n    {\\n        hs = new HashSet<>();\\n        for(int i=1;i<=1000;i++)\\n            hs.add(i);\\n    }\\n    \\n    int popSmallest() \\n    {\\n        int temp = Collections.min(hs);\\n        hs.remove(temp);\\n        return temp;\\n    }\\n    \\n    void addBack(int num) {\\n        hs.add(num);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    SmallestInfiniteSet() \\n    {\\n        hs = new HashSet<>();\\n        for(int i=1;i<=1000;i++)\\n            hs.add(i);\\n    }\\n    \\n    int popSmallest() \\n    {\\n        int temp = Collections.min(hs);\\n        hs.remove(temp);\\n        return temp;\\n    }\\n    \\n    void addBack(int num) {\\n        hs.add(num);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453384,
                "title": "smallest-number-without-pq-or-sorting-or-set-dp-approach-99-faster",
                "content": "Maintain a DP of size 1001, as there are maximum 1000 calls.\\nKeep a counter to point to the smallest number\\nEverytime you pop the smallest, return the smallest and itrate till you find the next smallest.\\nEverytime you add to the list check if it less than pointer values\\n\\n```\\npublic class SmallestInfiniteSet {\\n\\tint dp[];\\n\\tint pointer;\\n    public SmallestInfiniteSet() {\\n        dp = new int[1000];\\n        pointer = 0;\\n    }\\n    \\n    public int popSmallest() {\\n    \\tint small = pointer;\\n        dp[small] = 1;\\n        while(dp[pointer]==1){\\n        \\tpointer++;\\n        }\\n        return small+1;\\n    }\\n    \\n    public void addBack(int num) {\\n        dp[num-1]=0;\\n        if(pointer>num-1){\\n        \\tpointer = num-1;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Maintain a DP of size 1001, as there are maximum 1000 calls.\\nKeep a counter to point to the smallest number\\nEverytime you pop the smallest, return the smallest and itrate till you find the next smallest.\\nEverytime you add to the list check if it less than pointer values\\n\\n```\\npublic class SmallestInfiniteSet {\\n\\tint dp[];\\n\\tint pointer;\\n    public SmallestInfiniteSet() {\\n        dp = new int[1000];\\n        pointer = 0;\\n    }\\n    \\n    public int popSmallest() {\\n    \\tint small = pointer;\\n        dp[small] = 1;\\n        while(dp[pointer]==1){\\n        \\tpointer++;\\n        }\\n        return small+1;\\n    }\\n    \\n    public void addBack(int num) {\\n        dp[num-1]=0;\\n        if(pointer>num-1){\\n        \\tpointer = num-1;\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3453137,
                "title": "simple-and-fast-solution-ts-js",
                "content": "# Code\\n```typescript []\\nclass SmallestInfiniteSet {\\n  currentSmall: number = 1\\n  addedList: number[] = []\\n\\n  popSmallest(): number {\\n    // \\u0435\\u0441\\u043B\\u0438 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 \\u0435\\u0441\\u0442\\u044C \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u0431\\u0435\\u0440\\u0435\\u043C \\u0435\\u0433\\u043E (\\u0441\\u0432\\u043E\\u0439\\u0441\\u0442\\u0432\\u0430\\u043C\\u0438 shift)\\n    if (this.addedList.length) {\\n      return this.addedList.shift()\\n    } else {\\n      // \\u0438\\u043D\\u0430\\u0447\\u0435 \\u0443\\u0432\\u0435\\u043B\\u0438\\u0447\\u0438\\u0432\\u0430\\u0435\\u043C \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0435 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\n      this.currentSmall = this.currentSmall + 1\\n      return this.currentSmall - 1\\n    }\\n  }\\n\\n  addBack(num: number): void {\\n    // \\u043D\\u0435\\u0442 \\u0441\\u043C\\u044B\\u0441\\u043B\\u0430 \\u0445\\u0440\\u0430\\u043D\\u0438\\u0442\\u044C \\u0432\\u0441\\u0435 \\u0447\\u0442\\u043E \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0433\\u043E \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435\\u0433\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044F\\n    if (num < this.currentSmall) {\\n      // \\u043D\\u0435 \\u0437\\u0430\\u0431\\u044B\\u0432\\u0430\\u0435\\u043C \\u043F\\u0440\\u043E\\u0432\\u0435\\u0440\\u0438\\u0442\\u044C, \\u0432\\u043E\\u0437\\u043C\\u043E\\u0436\\u043D\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 \\u0443\\u0436\\u0435 \\u0435\\u0441\\u0442\\u044C\\n      if(!this.addedList.includes(num)) {\\n        this.addedList.push(num)\\n        // \\u043F\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u043D\\u0430\\u044F \\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u043A\\u0430 \\u043F\\u043E\\u0437\\u0432\\u043E\\u043B\\u044F\\u0435\\u0442 \\u0443\\u043F\\u0440\\u043E\\u0441\\u0442\\u0438\\u0442\\u044C this.popSmallest\\n        // \\u044D\\u0442\\u043E log(n) \\u043D\\u043E \\u043F\\u043E \\u0444\\u0430\\u043A\\u0442\\u0443 \\u043D\\u0430\\u0434\\u043E \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u043E\\u0432\\u044B\\u0439 num\\n        // \\u0442\\u0430\\u043A \\u0447\\u0442\\u043E \\u044D\\u0442\\u043E \\u0431\\u044B\\u0441\\u0442\\u0440\\u043E\\n        this.addedList = this.addedList.sort((a,b) => a - b)\\n      }\\n    }\\n  }\\n}\\n```\\n```javascript []\\nvar SmallestInfiniteSet = function() {\\n  this.currentSmall = 1\\n  this.addedList = [] \\n};\\n\\nSmallestInfiniteSet.prototype.popSmallest = function() {\\n  // \\u0435\\u0441\\u043B\\u0438 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 \\u0435\\u0441\\u0442\\u044C \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u0431\\u0435\\u0440\\u0435\\u043C \\u0435\\u0433\\u043E (\\u0441\\u0432\\u043E\\u0439\\u0441\\u0442\\u0432\\u0430\\u043C\\u0438 shift)\\n  if (this.addedList.length) {\\n    return this.addedList.shift()\\n  } else {\\n    // \\u0438\\u043D\\u0430\\u0447\\u0435 \\u0443\\u0432\\u0435\\u043B\\u0438\\u0447\\u0438\\u0432\\u0430\\u0435\\u043C \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0435 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\n    this.currentSmall = this.currentSmall + 1\\n    return this.currentSmall - 1\\n  }\\n};\\n\\nSmallestInfiniteSet.prototype.addBack = function(num) {\\n  // \\u043D\\u0435\\u0442 \\u0441\\u043C\\u044B\\u0441\\u043B\\u0430 \\u0445\\u0440\\u0430\\u043D\\u0438\\u0442\\u044C \\u0432\\u0441\\u0435 \\u0447\\u0442\\u043E \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0433\\u043E \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435\\u0433\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044F\\n  if (num < this.currentSmall) {\\n    // \\u043D\\u0435 \\u0437\\u0430\\u0431\\u044B\\u0432\\u0430\\u0435\\u043C \\u043F\\u0440\\u043E\\u0432\\u0435\\u0440\\u0438\\u0442\\u044C, \\u0432\\u043E\\u0437\\u043C\\u043E\\u0436\\u043D\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 \\u0443\\u0436\\u0435 \\u0435\\u0441\\u0442\\u044C\\n    if(!this.addedList.includes(num)) {\\n      this.addedList.push(num)\\n      // \\u043F\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u043D\\u0430\\u044F \\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u043A\\u0430 \\u043F\\u043E\\u0437\\u0432\\u043E\\u043B\\u044F\\u0435\\u0442 \\u0443\\u043F\\u0440\\u043E\\u0441\\u0442\\u0438\\u0442\\u044C this.popSmallest\\n      // \\u044D\\u0442\\u043E log(n) \\u043D\\u043E \\u043F\\u043E \\u0444\\u0430\\u043A\\u0442\\u0443 \\u043D\\u0430\\u0434\\u043E \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u043E\\u0432\\u044B\\u0439 num\\n      // \\u0442\\u0430\\u043A \\u0447\\u0442\\u043E \\u044D\\u0442\\u043E \\u0431\\u044B\\u0441\\u0442\\u0440\\u043E\\n      this.addedList = this.addedList.sort((a,b) => a - b)\\n    }\\n  }\\n};\\n```\\n\\n![\\u0421\\u043D\\u0438\\u043C\\u043E\\u043A \\u044D\\u043A\\u0440\\u0430\\u043D\\u0430 2023-04-25 \\u0432 10.57.34.png](https://assets.leetcode.com/users/images/aa77709b-7d1b-4612-b8bb-ea4ee56c2b77_1682409472.0544832.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript []\\nclass SmallestInfiniteSet {\\n  currentSmall: number = 1\\n  addedList: number[] = []\\n\\n  popSmallest(): number {\\n    // \\u0435\\u0441\\u043B\\u0438 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 \\u0435\\u0441\\u0442\\u044C \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u0431\\u0435\\u0440\\u0435\\u043C \\u0435\\u0433\\u043E (\\u0441\\u0432\\u043E\\u0439\\u0441\\u0442\\u0432\\u0430\\u043C\\u0438 shift)\\n    if (this.addedList.length) {\\n      return this.addedList.shift()\\n    } else {\\n      // \\u0438\\u043D\\u0430\\u0447\\u0435 \\u0443\\u0432\\u0435\\u043B\\u0438\\u0447\\u0438\\u0432\\u0430\\u0435\\u043C \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0435 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\n      this.currentSmall = this.currentSmall + 1\\n      return this.currentSmall - 1\\n    }\\n  }\\n\\n  addBack(num: number): void {\\n    // \\u043D\\u0435\\u0442 \\u0441\\u043C\\u044B\\u0441\\u043B\\u0430 \\u0445\\u0440\\u0430\\u043D\\u0438\\u0442\\u044C \\u0432\\u0441\\u0435 \\u0447\\u0442\\u043E \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0433\\u043E \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435\\u0433\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044F\\n    if (num < this.currentSmall) {\\n      // \\u043D\\u0435 \\u0437\\u0430\\u0431\\u044B\\u0432\\u0430\\u0435\\u043C \\u043F\\u0440\\u043E\\u0432\\u0435\\u0440\\u0438\\u0442\\u044C, \\u0432\\u043E\\u0437\\u043C\\u043E\\u0436\\u043D\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 \\u0443\\u0436\\u0435 \\u0435\\u0441\\u0442\\u044C\\n      if(!this.addedList.includes(num)) {\\n        this.addedList.push(num)\\n        // \\u043F\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u043D\\u0430\\u044F \\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u043A\\u0430 \\u043F\\u043E\\u0437\\u0432\\u043E\\u043B\\u044F\\u0435\\u0442 \\u0443\\u043F\\u0440\\u043E\\u0441\\u0442\\u0438\\u0442\\u044C this.popSmallest\\n        // \\u044D\\u0442\\u043E log(n) \\u043D\\u043E \\u043F\\u043E \\u0444\\u0430\\u043A\\u0442\\u0443 \\u043D\\u0430\\u0434\\u043E \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u043E\\u0432\\u044B\\u0439 num\\n        // \\u0442\\u0430\\u043A \\u0447\\u0442\\u043E \\u044D\\u0442\\u043E \\u0431\\u044B\\u0441\\u0442\\u0440\\u043E\\n        this.addedList = this.addedList.sort((a,b) => a - b)\\n      }\\n    }\\n  }\\n}\\n```\n```javascript []\\nvar SmallestInfiniteSet = function() {\\n  this.currentSmall = 1\\n  this.addedList = [] \\n};\\n\\nSmallestInfiniteSet.prototype.popSmallest = function() {\\n  // \\u0435\\u0441\\u043B\\u0438 \\u0432 \\u0441\\u043F\\u0438\\u0441\\u043A\\u0435 \\u0435\\u0441\\u0442\\u044C \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u0431\\u0435\\u0440\\u0435\\u043C \\u0435\\u0433\\u043E (\\u0441\\u0432\\u043E\\u0439\\u0441\\u0442\\u0432\\u0430\\u043C\\u0438 shift)\\n  if (this.addedList.length) {\\n    return this.addedList.shift()\\n  } else {\\n    // \\u0438\\u043D\\u0430\\u0447\\u0435 \\u0443\\u0432\\u0435\\u043B\\u0438\\u0447\\u0438\\u0432\\u0430\\u0435\\u043C \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0435 \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435\\u0435 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435\\n    this.currentSmall = this.currentSmall + 1\\n    return this.currentSmall - 1\\n  }\\n};\\n\\nSmallestInfiniteSet.prototype.addBack = function(num) {\\n  // \\u043D\\u0435\\u0442 \\u0441\\u043C\\u044B\\u0441\\u043B\\u0430 \\u0445\\u0440\\u0430\\u043D\\u0438\\u0442\\u044C \\u0432\\u0441\\u0435 \\u0447\\u0442\\u043E \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0433\\u043E \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435\\u0433\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u044F\\n  if (num < this.currentSmall) {\\n    // \\u043D\\u0435 \\u0437\\u0430\\u0431\\u044B\\u0432\\u0430\\u0435\\u043C \\u043F\\u0440\\u043E\\u0432\\u0435\\u0440\\u0438\\u0442\\u044C, \\u0432\\u043E\\u0437\\u043C\\u043E\\u0436\\u043D\\u043E \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u0438\\u0435 \\u0443\\u0436\\u0435 \\u0435\\u0441\\u0442\\u044C\\n    if(!this.addedList.includes(num)) {\\n      this.addedList.push(num)\\n      // \\u043F\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u043D\\u0430\\u044F \\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u043A\\u0430 \\u043F\\u043E\\u0437\\u0432\\u043E\\u043B\\u044F\\u0435\\u0442 \\u0443\\u043F\\u0440\\u043E\\u0441\\u0442\\u0438\\u0442\\u044C this.popSmallest\\n      // \\u044D\\u0442\\u043E log(n) \\u043D\\u043E \\u043F\\u043E \\u0444\\u0430\\u043A\\u0442\\u0443 \\u043D\\u0430\\u0434\\u043E \\u043E\\u0442\\u0441\\u043E\\u0440\\u0442\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043D\\u043E\\u0432\\u044B\\u0439 num\\n      // \\u0442\\u0430\\u043A \\u0447\\u0442\\u043E \\u044D\\u0442\\u043E \\u0431\\u044B\\u0441\\u0442\\u0440\\u043E\\n      this.addedList = this.addedList.sort((a,b) => a - b)\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452383,
                "title": "day-115-ordered-set-sorted-set-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Code :\\n```C++ []\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        //1 <= num <= 1000\\n        for (int i = 1; i <= 1005; i++)\\n        s.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int smallest = *s.begin();\\n        s.erase(s.begin());\\n        return smallest;\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O((m+n)logn)**\\n*In each popSmallest() method call, in the worst case, we will need to remove the first element of the sorted set which will take O(log\\u2061n) time. Thus, for m calls it will take O(m\\u22C5log\\u2061n) time.\\nIn each addBack(num) method call, we might push num into the sorted set which will take O(log\\u2061n)time. Thus, for n calls it will take O(n\\u22C5log\\u2061n) time.*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** *In the worst case, we might add n elements in the sorted set. Thus, it will take O(n) space.*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```C++ []\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        //1 <= num <= 1000\\n        for (int i = 1; i <= 1005; i++)\\n        s.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int smallest = *s.begin();\\n        s.erase(s.begin());\\n        return smallest;\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452211,
                "title": "c-solution-begineer-friendly-solution-ordered-setset",
                "content": "# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() \\n    {\\n        // Given 1k calls at most, so add 1k elements to the set\\n        for(int i = 1; i <= 1000; i++)\\n        st.insert(i);\\n    }\\n    \\n    int popSmallest() \\n    {\\n        // Set has the smallest element at the beginning\\n        int x = *(st.begin());\\n        st.erase(x);\\n        return x;\\n    }\\n    \\n    void addBack(int num) \\n    {\\n     // No issues with the duplicates\\n      st.insert(num);  \\n    }\\n};\\n```\\n**Do Upvote, If it helped :)**",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() \\n    {\\n        // Given 1k calls at most, so add 1k elements to the set\\n        for(int i = 1; i <= 1000; i++)\\n        st.insert(i);\\n    }\\n    \\n    int popSmallest() \\n    {\\n        // Set has the smallest element at the beginning\\n        int x = *(st.begin());\\n        st.erase(x);\\n        return x;\\n    }\\n    \\n    void addBack(int num) \\n    {\\n     // No issues with the duplicates\\n      st.insert(num);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452122,
                "title": "beginner-friendly-easy-c-solution-using-set-with-explanation",
                "content": "# Intuition\\nUsing a set data structure in c++ we can manage the list items in sorted order just remove the first element and will get the smallest in the list.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n`Declared a set data structure`\\nAs we know set keep the elements in a sorted order.\\n- In constructor just create a list of 1000 elements as it is our constrant.\\n- In popSmallest store the value of first element of the set in a variable erase the first element and return the value\\n- Simply add the element in set it will automatically put it in sorted order\\n<!-- Describe your approach to solving the problem. -->\\n# HOPE YOU LIKE THE SOLUTION IF YES THEN PLEASE UPVOTE \\uD83D\\uDE07\\n# Complexity\\n- Time complexity: O(log n) `input list items`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) `list space`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\nprivate:\\n    set<int> list;\\npublic:\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++){\\n            list.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        auto it = list.begin();\\n        int ans = *it;\\n        list.erase(list.begin());\\n        return ans;\\n    }\\n    \\n    void addBack(int num) {\\n        list.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\nprivate:\\n    set<int> list;\\npublic:\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++){\\n            list.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        auto it = list.begin();\\n        int ans = *it;\\n        list.erase(list.begin());\\n        return ans;\\n    }\\n    \\n    void addBack(int num) {\\n        list.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452083,
                "title": "rust-binaryheap-hashset",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a `smallest` variable to keep track of the smallest number in the continuous part of the infinite range.\\nUse a combination of HashSet and BinaryHeap for tracking the values added back.\\n\\nPlease note that Rust BinaryHeap is a max-heap by default so we will operate on the negative equivalent of the input.\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::{BinaryHeap, HashSet};\\n\\nstruct SmallestInfiniteSet {\\n    heap: BinaryHeap<i32>,\\n    set: HashSet<i32>,\\n    smallest: i32,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl SmallestInfiniteSet {\\n\\n    fn new() -> Self {\\n        SmallestInfiniteSet {\\n            heap: BinaryHeap::new(),\\n            set: HashSet::new(),\\n            smallest: 1,\\n        }\\n    }\\n    \\n    fn pop_smallest(&mut self) -> i32 {\\n        match self.heap.pop() {\\n            Some(n) => {\\n                self.set.remove(&n);\\n                -n\\n            },\\n            None => {\\n                self.smallest += 1;\\n                self.smallest - 1\\n            }\\n        }\\n    }\\n    \\n    fn add_back(&mut self, num: i32) {\\n        if num >= self.smallest { return; }\\n        if !self.set.contains(&(-num)) {\\n            self.heap.push(-num);\\n            self.set.insert(-num);\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * let obj = SmallestInfiniteSet::new();\\n * let ret_1: i32 = obj.pop_smallest();\\n * obj.add_back(num);\\n */\\n```",
                "solutionTags": [
                    "Rust",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nuse std::collections::{BinaryHeap, HashSet};\\n\\nstruct SmallestInfiniteSet {\\n    heap: BinaryHeap<i32>,\\n    set: HashSet<i32>,\\n    smallest: i32,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl SmallestInfiniteSet {\\n\\n    fn new() -> Self {\\n        SmallestInfiniteSet {\\n            heap: BinaryHeap::new(),\\n            set: HashSet::new(),\\n            smallest: 1,\\n        }\\n    }\\n    \\n    fn pop_smallest(&mut self) -> i32 {\\n        match self.heap.pop() {\\n            Some(n) => {\\n                self.set.remove(&n);\\n                -n\\n            },\\n            None => {\\n                self.smallest += 1;\\n                self.smallest - 1\\n            }\\n        }\\n    }\\n    \\n    fn add_back(&mut self, num: i32) {\\n        if num >= self.smallest { return; }\\n        if !self.set.contains(&(-num)) {\\n            self.heap.push(-num);\\n            self.set.insert(-num);\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * let obj = SmallestInfiniteSet::new();\\n * let ret_1: i32 = obj.pop_smallest();\\n * obj.add_back(num);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3452079,
                "title": "easy-java-solution-using-minheap-and-count-beginner-friendly",
                "content": "# Intuition\\nDivide logic in 2 sections, \\n1. Keep track of not seen continous element using SMALLEST\\n2. Keep track of push back elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSMALLEST -> to keep continuse non-popped part, SMALLEST is minimum \\nMinheap -> minHeap to track pushed backed element, peek is minimum in pushed backed.\\n#### addBack function approach:\\n1. if given num is equal or higher than SMALLEST then we dont have to add it as it is not yet popped\\n2. if given number is already present is heap then also we dont need to add again becuse we are not kepping duplicates\\n#### popSmallest function approach\\nin minHeap we are tracking element which were popped and push back and all element in minHeap are lower than SMALLEST, so first we will first pop from minHeap unless minheap is not emptly\\n1. Return element from minheap if minheap is not empty\\n2. if miniheap is emptty then return SMALLEST, make sure to increase it by 1 . \\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    int SMALLEST;\\n    PriorityQueue<Integer> minHeap;\\n    public SmallestInfiniteSet() {\\n        SMALLEST = 1;\\n        minHeap = new PriorityQueue<>();\\n    }\\n    \\n    public int popSmallest() {\\n        if(minHeap.isEmpty()){\\n            return SMALLEST++;\\n        }\\n        return minHeap.poll();\\n    }\\n    \\n    public void addBack(int num) {\\n        if(num >= SMALLEST || minHeap.contains(num)) {\\n            return;\\n        }\\n        minHeap.add(num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    int SMALLEST;\\n    PriorityQueue<Integer> minHeap;\\n    public SmallestInfiniteSet() {\\n        SMALLEST = 1;\\n        minHeap = new PriorityQueue<>();\\n    }\\n    \\n    public int popSmallest() {\\n        if(minHeap.isEmpty()){\\n            return SMALLEST++;\\n        }\\n        return minHeap.poll();\\n    }\\n    \\n    public void addBack(int num) {\\n        if(num >= SMALLEST || minHeap.contains(num)) {\\n            return;\\n        }\\n        minHeap.add(num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452028,
                "title": "daily-leetcoding-challenge-april-day-25",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/smallest-number-in-infinite-set/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashset + Heap\n\n  \n**Approach 2:** Sorted Set\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/smallest-number-in-infinite-set/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2261925,
                "title": "using-priority-queue-easy-and-simple",
                "content": "The constraints say the numbers are between 1 and 1000 (inclusive) so we don\\'t need to populate more than 1000.\\n\\n**C++ Code :-**\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>> pq;\\n    vector<bool> isPresent;\\n    \\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;++i)\\n            pq.push(i);\\n        isPresent=vector<bool>(1001,true);\\n    }\\n    \\n    int popSmallest() {\\n        int smallest_element=pq.top(); \\n        pq.pop();\\n        \\n        isPresent[smallest_element]=false;\\n        \\n        return smallest_element;\\n    }\\n    \\n    void addBack(int num) {\\n        if(isPresent[num]==false){\\n            pq.push(num);\\n            isPresent[num]=true;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>> pq;\\n    vector<bool> isPresent;\\n    \\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;++i)\\n            pq.push(i);\\n        isPresent=vector<bool>(1001,true);\\n    }\\n    \\n    int popSmallest() {\\n        int smallest_element=pq.top(); \\n        pq.pop();\\n        \\n        isPresent[smallest_element]=false;\\n        \\n        return smallest_element;\\n    }\\n    \\n    void addBack(int num) {\\n        if(isPresent[num]==false){\\n            pq.push(num);\\n            isPresent[num]=true;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261464,
                "title": "easy-java-solution",
                "content": "Intuition:\\nUse a min heap to get the smallest element in O(1) and set to know if the element is available in current set.  and since it was given that 1 <= num <= 1000 so we\\'ll prefil set with 1 to 1000 numbers\\n\\n\\n```\\nclass SmallestInfiniteSet {\\n\\n    PriorityQueue<Integer> pq;\\n    HashSet<Integer> set; \\n        \\n    public SmallestInfiniteSet() {\\n        this.pq = new PriorityQueue<>();\\n        this.set = new HashSet<>();\\n        \\n        for(int i = 1; i <= 1000; i++){\\n            this.pq.add(i);\\n            this.set.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        int sm = this.pq.poll();\\n        this.set.remove(sm);\\n        return sm;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(!this.set.contains(num)){\\n            this.pq.add(num);\\n            this.set.add(num);\\n        }\\n        \\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n\\n    PriorityQueue<Integer> pq;\\n    HashSet<Integer> set; \\n        \\n    public SmallestInfiniteSet() {\\n        this.pq = new PriorityQueue<>();\\n        this.set = new HashSet<>();\\n        \\n        for(int i = 1; i <= 1000; i++){\\n            this.pq.add(i);\\n            this.set.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        int sm = this.pq.poll();\\n        this.set.remove(sm);\\n        return sm;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(!this.set.contains(num)){\\n            this.pq.add(num);\\n            this.set.add(num);\\n        }\\n        \\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261427,
                "title": "c-two-approaches-min-heap-unordered-set-ordered-set",
                "content": "**Approach 1 Min Heap + Unordered Set**\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int, vector<int>, greater<int> >pq;\\n    unordered_set<int>st;\\n    SmallestInfiniteSet() {\\n        int i=1;\\n        while(i<=1000){\\n            pq.push(i);\\n            st.insert(i);\\n            i++;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int t=pq.top();\\n        pq.pop();\\n        st.erase(t);\\n        return t;\\n    }\\n    \\n    void addBack(int num) {\\n        if(st.find(num)==st.end()){\\n            pq.push(num);\\n            st.insert(num);\\n        }\\n        return;\\n    }\\n};\\n```\\n\\n**Approach 2---> Ordered Set**\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int>st;\\n    SmallestInfiniteSet() {\\n        st.clear();\\n        for(int i=1;i<=1000;i++) st.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int t = *st.begin();\\n        st.erase(st.begin());\\n        return t;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int, vector<int>, greater<int> >pq;\\n    unordered_set<int>st;\\n    SmallestInfiniteSet() {\\n        int i=1;\\n        while(i<=1000){\\n            pq.push(i);\\n            st.insert(i);\\n            i++;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int t=pq.top();\\n        pq.pop();\\n        st.erase(t);\\n        return t;\\n    }\\n    \\n    void addBack(int num) {\\n        if(st.find(num)==st.end()){\\n            pq.push(num);\\n            st.insert(num);\\n        }\\n        return;\\n    }\\n};\\n```\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int>st;\\n    SmallestInfiniteSet() {\\n        st.clear();\\n        for(int i=1;i<=1000;i++) st.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int t = *st.begin();\\n        st.erase(st.begin());\\n        return t;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042991,
                "title": "smallest-number-in-infinite-set-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    \\n    int ptr = 1;\\n    vector<bool> arr;\\n\\n    SmallestInfiniteSet() {\\n        arr.assign(1001,true);\\n    }\\n    \\n    int popSmallest() {\\n       while(!arr[ptr]) ptr++;\\n       arr[ptr] = false;\\n       ptr++;\\n       return ptr-1; \\n    } \\n    \\n    void addBack(int num) {\\n       arr[num] = true; \\n       if( ptr >= num) ptr = num; \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    \\n    int ptr = 1;\\n    vector<bool> arr;\\n\\n    SmallestInfiniteSet() {\\n        arr.assign(1001,true);\\n    }\\n    \\n    int popSmallest() {\\n       while(!arr[ptr]) ptr++;\\n       arr[ptr] = false;\\n       ptr++;\\n       return ptr-1; \\n    } \\n    \\n    void addBack(int num) {\\n       arr[num] = true; \\n       if( ptr >= num) ptr = num; \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656579,
                "title": "most-simple-c",
                "content": "# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    int x = 1;\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        x = 1;\\n        s.clear();\\n    }\\n    \\n    int popSmallest() {\\n        if(s.empty()){\\n            return x++;\\n        }\\n        int y = *s.begin();\\n        s.erase(y);\\n        return y;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num<x){\\n            s.insert(num);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    int x = 1;\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        x = 1;\\n        s.clear();\\n    }\\n    \\n    int popSmallest() {\\n        if(s.empty()){\\n            return x++;\\n        }\\n        int y = *s.begin();\\n        s.erase(y);\\n        return y;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num<x){\\n            s.insert(num);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465400,
                "title": "boolean-buckets-efficiency-99-easy-explanation-java-c",
                "content": "# Approach\\nAnyone knowing TreeSet will solve this problem using TreeSet. But that doesn\\'t give us efficient solution. We can make it efficient by using Boolean Buckets.\\n\\n\\n# Complexity\\n- Time complexity: $$O(N \\\\log N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` Java []\\nclass SmallestInfiniteSet {\\n    boolean[] isBucketEmpty;\\n    int n = 1001;\\n    int smallestNum;\\n    public SmallestInfiniteSet() {\\n        isBucketEmpty = new boolean[n];\\n        smallestNum = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        int currentSmallestNum = smallestNum;\\n        // make this bucket empty as we popped it\\n        isBucketEmpty[smallestNum] = true;\\n        // find next non empty bucket\\n        for(int i = smallestNum+1; i<n; i++) {\\n            if(!isBucketEmpty[i]){\\n                // this is our new smallestNum\\n                smallestNum = i;\\n                break;\\n            }\\n        }\\n        return currentSmallestNum;\\n    }\\n    \\n    public void addBack(int num) {\\n        // set the bucket to non empty\\n        isBucketEmpty[num] = false;\\n        // update smallestNum\\n        if(num<smallestNum) {\\n            smallestNum = num;\\n        }\\n        // same thing:\\n        // smallestNum = Math.min(smallestNum, num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```\\n\\n``` C++ []\\nclass SmallestInfiniteSet {\\npublic:\\n    bool *isBucketEmpty;\\n    int n = 1001;\\n    int smallestNum;\\n    SmallestInfiniteSet() {\\n        isBucketEmpty = new bool[n];\\n        for(int i=0; i<n; i++) {\\n            isBucketEmpty[i] = false;\\n        }\\n        smallestNum = 1;\\n    }\\n    \\n    int popSmallest() {\\n        int currentSmallestNum = smallestNum;\\n        // make this bucket empty as we popped it\\n        isBucketEmpty[smallestNum] = true;\\n        // find next non empty bucket\\n        for(int i = smallestNum+1; i<n; i++) {\\n            if(!isBucketEmpty[i]){\\n                // this is our new smallestNum\\n                smallestNum = i;\\n                break;\\n            }\\n        }\\n        return currentSmallestNum;\\n    }\\n    \\n    void addBack(int num) {\\n        // set the bucket to non empty\\n        isBucketEmpty[num] = false;\\n        // update smallestNum\\n        if(num<smallestNum) {\\n            smallestNum = num;\\n        }\\n        // same thing:\\n        // smallestNum = Math.min(smallestNum, num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "``` Java []\\nclass SmallestInfiniteSet {\\n    boolean[] isBucketEmpty;\\n    int n = 1001;\\n    int smallestNum;\\n    public SmallestInfiniteSet() {\\n        isBucketEmpty = new boolean[n];\\n        smallestNum = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        int currentSmallestNum = smallestNum;\\n        // make this bucket empty as we popped it\\n        isBucketEmpty[smallestNum] = true;\\n        // find next non empty bucket\\n        for(int i = smallestNum+1; i<n; i++) {\\n            if(!isBucketEmpty[i]){\\n                // this is our new smallestNum\\n                smallestNum = i;\\n                break;\\n            }\\n        }\\n        return currentSmallestNum;\\n    }\\n    \\n    public void addBack(int num) {\\n        // set the bucket to non empty\\n        isBucketEmpty[num] = false;\\n        // update smallestNum\\n        if(num<smallestNum) {\\n            smallestNum = num;\\n        }\\n        // same thing:\\n        // smallestNum = Math.min(smallestNum, num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```\n``` C++ []\\nclass SmallestInfiniteSet {\\npublic:\\n    bool *isBucketEmpty;\\n    int n = 1001;\\n    int smallestNum;\\n    SmallestInfiniteSet() {\\n        isBucketEmpty = new bool[n];\\n        for(int i=0; i<n; i++) {\\n            isBucketEmpty[i] = false;\\n        }\\n        smallestNum = 1;\\n    }\\n    \\n    int popSmallest() {\\n        int currentSmallestNum = smallestNum;\\n        // make this bucket empty as we popped it\\n        isBucketEmpty[smallestNum] = true;\\n        // find next non empty bucket\\n        for(int i = smallestNum+1; i<n; i++) {\\n            if(!isBucketEmpty[i]){\\n                // this is our new smallestNum\\n                smallestNum = i;\\n                break;\\n            }\\n        }\\n        return currentSmallestNum;\\n    }\\n    \\n    void addBack(int num) {\\n        // set the bucket to non empty\\n        isBucketEmpty[num] = false;\\n        // update smallestNum\\n        if(num<smallestNum) {\\n            smallestNum = num;\\n        }\\n        // same thing:\\n        // smallestNum = Math.min(smallestNum, num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454584,
                "title": "c-set-counter",
                "content": "````\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    int x = 1;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        if(s.size()>0&&*s.begin()<=x){\\n            int y = *s.begin();\\n            s.erase(s.begin());\\n            \\n            return y;\\n        }else\\n            return x++;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num<x)\\n        s.insert(num);\\n    }\\n};\\n ````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "````\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    int x = 1;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        if(s.size()>0&&*s.begin()<=x){\\n            int y = *s.begin();\\n            s.erase(s.begin());\\n            \\n            return y;\\n        }else\\n            return x++;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num<x)\\n        s.insert(num);\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3454567,
                "title": "my-java-solution-beats-99-submissions",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n\\n    int cur;\\n    PriorityQueue<Integer> heap;\\n    \\n    public SmallestInfiniteSet() {\\n        cur = 1;\\n        heap = new PriorityQueue<>();\\n    }\\n\\n    public int popSmallest() {\\n        if (heap.isEmpty()) {\\n            cur++;\\n            return cur - 1;\\n        }\\n        return heap.poll();\\n    }\\n\\n    public void addBack(int num) {\\n        if (num < cur && !heap.contains(num)) heap.add(num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n\\n    int cur;\\n    PriorityQueue<Integer> heap;\\n    \\n    public SmallestInfiniteSet() {\\n        cur = 1;\\n        heap = new PriorityQueue<>();\\n    }\\n\\n    public int popSmallest() {\\n        if (heap.isEmpty()) {\\n            cur++;\\n            return cur - 1;\\n        }\\n        return heap.poll();\\n    }\\n\\n    public void addBack(int num) {\\n        if (num < cur && !heap.contains(num)) heap.add(num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453389,
                "title": "space-optimized-using-set-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInfinite set is a huge set of numbers and to keep track of all the numbers which are present in the set takes more space. So, instead of storing all the numbers which are present in the set we will store the numbers which are not present.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a HashSet which stores distinct numbers. **Start** pointer which will keep track of the starting point of the set.\\n- To remove the first element return the **start** pointer integer, add the number to **\"removed\"** set and iterate to the next valid number.\\n- To add the number back to the infinite set remove the element from the **\"removed\"** set.\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    // Storing all the numbers from the infinite set takes huge amount of space so instead of that we will keep track of numbers which are been removed from set.\\n\\n    Set<Integer> removed; // contains numbers which are removed from the infinite Set.\\n    int start;\\n\\n    public SmallestInfiniteSet() {\\n        removed = new HashSet<Integer>();\\n        start = 1;      // start pointer\\n    }\\n    \\n    public int popSmallest() {\\n        int toRemove = start;  \\n        removed.add(start); // smallest number is the first number in the set.\\n\\n        int i = start+1;\\n\\n        // check for the elements which are not there in the infinite set and assign the next start\\n\\n        while(i <= start + removed.size()){ \\n            if(removed.contains(i)) i++;\\n            else break;\\n        }\\n\\n        start = i;\\n        return toRemove;\\n    }\\n    \\n    public void addBack(int num) {\\n        removed.remove(num); // num is added back so remove it from the \"removed\" set\\n        if(num < start) start = num;\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    // Storing all the numbers from the infinite set takes huge amount of space so instead of that we will keep track of numbers which are been removed from set.\\n\\n    Set<Integer> removed; // contains numbers which are removed from the infinite Set.\\n    int start;\\n\\n    public SmallestInfiniteSet() {\\n        removed = new HashSet<Integer>();\\n        start = 1;      // start pointer\\n    }\\n    \\n    public int popSmallest() {\\n        int toRemove = start;  \\n        removed.add(start); // smallest number is the first number in the set.\\n\\n        int i = start+1;\\n\\n        // check for the elements which are not there in the infinite set and assign the next start\\n\\n        while(i <= start + removed.size()){ \\n            if(removed.contains(i)) i++;\\n            else break;\\n        }\\n\\n        start = i;\\n        return toRemove;\\n    }\\n    \\n    public void addBack(int num) {\\n        removed.remove(num); // num is added back so remove it from the \"removed\" set\\n        if(num < start) start = num;\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453322,
                "title": "java-full-explaination-comments-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDeclare a PriorityQueue of integer type which stores data in ascending order.\\nAdd all positive integer into the array before performing any operation because its given in the question that it contains all postive number upto 1000(check the contraint).\\n\\nIn popSmalledt() : Just pop and return the first element using poll method of PriorityQueue.\\nIn addBack() : just check if given element is already present in the PriorityQueue using contains method of PriorityQueue. If its not present then add the element into the priorityQueue.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    PriorityQueue<Integer> q;\\n    public SmallestInfiniteSet() {\\n        q = new PriorityQueue<Integer>();//this PriorityQueue stores in asceding order\\n        for(int i = 1 ; i <= 1000; i ++){\\n            q.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        return q.poll();//just return the first element\\n    }\\n    \\n    public void addBack(int num) {\\n        if(!q.contains(num)){\\n            q.add(num);//check if not present then add the num\\n        }\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    PriorityQueue<Integer> q;\\n    public SmallestInfiniteSet() {\\n        q = new PriorityQueue<Integer>();//this PriorityQueue stores in asceding order\\n        for(int i = 1 ; i <= 1000; i ++){\\n            q.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        return q.poll();//just return the first element\\n    }\\n    \\n    public void addBack(int num) {\\n        if(!q.contains(num)){\\n            q.add(num);//check if not present then add the num\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452923,
                "title": "java-simple-array-beats-99-8-lines",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n  boolean[] set = new boolean[1000];\\n  int min;\\n\\n  public SmallestInfiniteSet() {}\\n  \\n  public int popSmallest() {\\n    var ret = min;\\n    set[ret] = true;\\n\\n    while (min < 999 && set[++min]);\\n    return ret + 1;\\n  }\\n  \\n  public void addBack(int num) {\\n    set[num - 1] = false;\\n    min = Math.min(min, num - 1);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n  boolean[] set = new boolean[1000];\\n  int min;\\n\\n  public SmallestInfiniteSet() {}\\n  \\n  public int popSmallest() {\\n    var ret = min;\\n    set[ret] = true;\\n\\n    while (min < 999 && set[++min]);\\n    return ret + 1;\\n  }\\n  \\n  public void addBack(int num) {\\n    set[num - 1] = false;\\n    min = Math.min(min, num - 1);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452700,
                "title": "easy-py",
                "content": "\\n# Code\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.c = 1\\n        self.s = set()\\n    def popSmallest(self):\\n        if self.s:\\n            r = min(self.s)\\n            self.s.remove(r)\\n            return r\\n        else:\\n            self.c += 1\\n            return self.c - 1\\n    def addBack(self, num):\\n        if self.c > num:\\n            self.s.add(num) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.c = 1\\n        self.s = set()\\n    def popSmallest(self):\\n        if self.s:\\n            r = min(self.s)\\n            self.s.remove(r)\\n            return r\\n        else:\\n            self.c += 1\\n            return self.c - 1\\n    def addBack(self, num):\\n        if self.c > num:\\n            self.s.add(num) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452537,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# My youtube channel - KeetCode(Ex-Amazon)\\nI create 156 videos for leetcode questions as of April 25, 2023. I believe my channel helps you prepare for the coming technical interviews. Please subscribe my channel!\\n\\n### Please subscribe my channel - KeetCode(Ex-Amazon) from here.\\n\\n**I created a video for this question. I believe you can understand easily with visualization.** \\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\nhttps://leetcode.com/niits/\\n\\n![FotoJet (58).jpg](https://assets.leetcode.com/users/images/f84be1da-b856-4454-b6f5-5b7535505e5a_1682396352.1289897.jpeg)\\n\\n\\n---\\n\\n# Intuition\\nUse heap to keep track of the smallest number and mininum variable instead of initialization from 1 to 1000\\n\\n# Approach\\nThis is based on Python code. Other languages might be different.\\n\\n1. Implement the popSmallest() method:\\n    - Check if the heap is not empty.\\n    - If not empty, pop the smallest element from the heap using heapq.heappop() function and return it.\\n    - If empty, increment min_num by 1 and return min_num - 1 as the smallest element.\\n\\n2. Implement the addBack(num) method:\\n    - Check if min_num is greater than num and num is not already in the heap.\\n    - If yes, push num into the heap using heapq.heappush() function.\\n\\n\\n---\\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\nhttps://leetcode.com/niits/\\n\\n---\\n\\n\\n# Complexity\\nThis is based on Python code. Other languages might be different.\\n\\n- Time complexity:\\n    - popSmallest - O(log n)\\n\\n        a. If the heap is not empty, it performs a heap pop operation using heapq.heappop(), which has a time complexity of O(log n), where n is the number of elements in the heap.\\n\\n        b. If the heap is empty, it increments self.min_num by 1 and returns self.min_num - 1, which takes constant time.\\n\\n        Therefore, the worst-case time complexity of popSmallest method is O(log n), where n is the number of elements in the heap.\\n\\n\\n    - addBack - O(log n)\\n    \\n        a. It checks if self.min_num is greater than num and num is not in the heap, which takes constant time.\\n\\n        b. If the above condition is True, it performs a heap push operation using heapq.heappush(), which has a time complexity of O(log n), where n is the number of elements in the heap.\\n\\n        Therefore, the worst-case time complexity of addBack method is O(log n), where n is the number of elements in the heap.\\n\\n- Space complexity: O(n)\\n n is the number of elements in the heap.\\n\\n# Python\\n```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.heap = []\\n        self.set = set()\\n        self.min_num = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.heap:\\n            num = heapq.heappop(self.heap)\\n            self.set.remove(num)\\n            return num\\n        self.min_num += 1\\n        return self.min_num - 1\\n\\n    def addBack(self, num: int) -> None:\\n        if self.min_num > num and num not in self.set:\\n            self.set.add(num)\\n            heapq.heappush(self.heap, num)\\n```\\n# JavaScript\\n```\\nvar SmallestInfiniteSet = function() {\\n    this.heap = [];\\n    this.min_num = 1;\\n};\\n\\n/**\\n * @return {number}\\n */\\nSmallestInfiniteSet.prototype.popSmallest = function() {\\n    if (this.heap.length > 0) {\\n        return this.heap.shift();\\n    }\\n    this.min_num += 1;\\n    return this.min_num - 1;    \\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSmallestInfiniteSet.prototype.addBack = function(num) {\\n    if (this.min_num > num && this.heap.indexOf(num) === -1) {\\n        this.heap.push(num);\\n        this.heap.sort((a, b) => a - b);\\n    }\\n};\\n```\\n# Java\\n```\\nclass SmallestInfiniteSet {\\n    private PriorityQueue<Integer> heap;\\n    private int min_num;\\n\\n    public SmallestInfiniteSet() {\\n        heap = new PriorityQueue<>();\\n        min_num = 1;        \\n    }\\n    \\n    public int popSmallest() {\\n        if (!heap.isEmpty()) {\\n            return heap.poll();\\n        }\\n        min_num += 1;\\n        return min_num - 1;        \\n    }\\n    \\n    public void addBack(int num) {\\n        if (min_num > num && !heap.contains(num)) {\\n            heap.offer(num);\\n        }        \\n    }\\n}\\n```\\n# C++\\n```\\n#include <queue>\\nusing namespace std;\\n\\nclass SmallestInfiniteSet {\\nprivate:\\n    priority_queue<int, vector<int>, greater<int>> heap;\\n    unordered_set<int> seen;\\n    int min_num;\\n\\npublic:\\n    SmallestInfiniteSet() {\\n        min_num = 1;\\n    }\\n    \\n    int popSmallest() {\\n        if (!heap.empty()) {\\n            int smallest = heap.top();\\n            heap.pop();\\n            seen.erase(smallest);\\n            return smallest;\\n        }\\n        min_num += 1;\\n        return min_num - 1;        \\n    }\\n    \\n    void addBack(int num) {\\n        if (min_num > num && seen.find(num) == seen.end()) {\\n            heap.push(num);\\n            seen.insert(num);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.heap = []\\n        self.set = set()\\n        self.min_num = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.heap:\\n            num = heapq.heappop(self.heap)\\n            self.set.remove(num)\\n            return num\\n        self.min_num += 1\\n        return self.min_num - 1\\n\\n    def addBack(self, num: int) -> None:\\n        if self.min_num > num and num not in self.set:\\n            self.set.add(num)\\n            heapq.heappush(self.heap, num)\\n```\n```\\nvar SmallestInfiniteSet = function() {\\n    this.heap = [];\\n    this.min_num = 1;\\n};\\n\\n/**\\n * @return {number}\\n */\\nSmallestInfiniteSet.prototype.popSmallest = function() {\\n    if (this.heap.length > 0) {\\n        return this.heap.shift();\\n    }\\n    this.min_num += 1;\\n    return this.min_num - 1;    \\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSmallestInfiniteSet.prototype.addBack = function(num) {\\n    if (this.min_num > num && this.heap.indexOf(num) === -1) {\\n        this.heap.push(num);\\n        this.heap.sort((a, b) => a - b);\\n    }\\n};\\n```\n```\\nclass SmallestInfiniteSet {\\n    private PriorityQueue<Integer> heap;\\n    private int min_num;\\n\\n    public SmallestInfiniteSet() {\\n        heap = new PriorityQueue<>();\\n        min_num = 1;        \\n    }\\n    \\n    public int popSmallest() {\\n        if (!heap.isEmpty()) {\\n            return heap.poll();\\n        }\\n        min_num += 1;\\n        return min_num - 1;        \\n    }\\n    \\n    public void addBack(int num) {\\n        if (min_num > num && !heap.contains(num)) {\\n            heap.offer(num);\\n        }        \\n    }\\n}\\n```\n```\\n#include <queue>\\nusing namespace std;\\n\\nclass SmallestInfiniteSet {\\nprivate:\\n    priority_queue<int, vector<int>, greater<int>> heap;\\n    unordered_set<int> seen;\\n    int min_num;\\n\\npublic:\\n    SmallestInfiniteSet() {\\n        min_num = 1;\\n    }\\n    \\n    int popSmallest() {\\n        if (!heap.empty()) {\\n            int smallest = heap.top();\\n            heap.pop();\\n            seen.erase(smallest);\\n            return smallest;\\n        }\\n        min_num += 1;\\n        return min_num - 1;        \\n    }\\n    \\n    void addBack(int num) {\\n        if (min_num > num && seen.find(num) == seen.end()) {\\n            heap.push(num);\\n            seen.insert(num);\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3452496,
                "title": "3-java-solution-using-hashset-treeset-priorityqueue",
                "content": "```\\nclass SmallestInfiniteSet {\\n     int cur;\\n    Set<Integer> s;\\n    \\n    public SmallestInfiniteSet() {\\n        cur = 1;\\n        s = new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        if (!s.isEmpty()) {\\n            int res = Collections.min(s);\\n            s.remove(res);\\n            return res;\\n        } else {\\n            cur++;\\n            return cur - 1;\\n        }\\n    }\\n    public void addBack(int num) {\\n        if (cur > num) {\\n            s.add(num);\\n        }\\n    }\\n}\\n```\\n\\n```\\nclass SmallestInfiniteSet {\\n   PriorityQueue<Integer> queue;\\n    int current;\\n\\n    public SmallestInfiniteSet() {\\n        queue = new PriorityQueue<>();\\n        current = 1;\\n    }\\n\\n    public int popSmallest() {\\n        int result = current;\\n\\n        if (!queue.isEmpty() && queue.peek() < current)\\n            result = queue.poll();\\n        else\\n            current++;\\n\\n        while (!queue.isEmpty() && queue.peek() == result)\\n            queue.poll();\\n\\n        return result;\\n    }\\n\\n    public void addBack(int num) {\\n        queue.add(num);\\n    }\\n}\\n```\\n\\n```\\nclass SmallestInfiniteSet {\\n    SortedSet<Integer> set=new TreeSet<Integer>();\\n    public SmallestInfiniteSet() {\\n     for(int i=1;i<1001;i++){\\n            set.add(i);\\n        }   \\n    }\\n    public int popSmallest() {\\n       int n=set.first();\\n       set.remove(n);\\n        return n;\\n    }\\n    \\n    public void addBack(int num) {\\n      set.add(num);  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n     int cur;\\n    Set<Integer> s;\\n    \\n    public SmallestInfiniteSet() {\\n        cur = 1;\\n        s = new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        if (!s.isEmpty()) {\\n            int res = Collections.min(s);\\n            s.remove(res);\\n            return res;\\n        } else {\\n            cur++;\\n            return cur - 1;\\n        }\\n    }\\n    public void addBack(int num) {\\n        if (cur > num) {\\n            s.add(num);\\n        }\\n    }\\n}\\n```\n```\\nclass SmallestInfiniteSet {\\n   PriorityQueue<Integer> queue;\\n    int current;\\n\\n    public SmallestInfiniteSet() {\\n        queue = new PriorityQueue<>();\\n        current = 1;\\n    }\\n\\n    public int popSmallest() {\\n        int result = current;\\n\\n        if (!queue.isEmpty() && queue.peek() < current)\\n            result = queue.poll();\\n        else\\n            current++;\\n\\n        while (!queue.isEmpty() && queue.peek() == result)\\n            queue.poll();\\n\\n        return result;\\n    }\\n\\n    public void addBack(int num) {\\n        queue.add(num);\\n    }\\n}\\n```\n```\\nclass SmallestInfiniteSet {\\n    SortedSet<Integer> set=new TreeSet<Integer>();\\n    public SmallestInfiniteSet() {\\n     for(int i=1;i<1001;i++){\\n            set.add(i);\\n        }   \\n    }\\n    public int popSmallest() {\\n       int n=set.first();\\n       set.remove(n);\\n        return n;\\n    }\\n    \\n    public void addBack(int num) {\\n      set.add(num);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452272,
                "title": "javascript-1-3-1-lines-easy-hash-array-time-o-n-space-o-k",
                "content": "# Approach\\n- `init`: Create array `set` of length `1000`, filled with `1`. \\n- `popSmallest`: Find 1st `num` where `set[num] == 1`. Set `set[num] = 0`. Return `num+1`.\\n- `addBack`: Set `set[num-1] = 1`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(k)\\n\\n# Code\\n```\\nvar SmallestInfiniteSet = function() {\\n    this.set = Array( 1000 ).fill( 1 )\\n};\\n\\nSmallestInfiniteSet.prototype.popSmallest = function() {\\n    let num = this.set.findIndex( n => n )\\n    this.set[ num ] = 0\\n    return num + 1\\n};\\n\\nSmallestInfiniteSet.prototype.addBack = function( num ) {\\n    this.set[ num - 1 ] = 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nvar SmallestInfiniteSet = function() {\\n    this.set = Array( 1000 ).fill( 1 )\\n};\\n\\nSmallestInfiniteSet.prototype.popSmallest = function() {\\n    let num = this.set.findIndex( n => n )\\n    this.set[ num ] = 0\\n    return num + 1\\n};\\n\\nSmallestInfiniteSet.prototype.addBack = function( num ) {\\n    this.set[ num - 1 ] = 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3452243,
                "title": "c-easy-solution-begineer-friendly-set",
                "content": "\\n\\t\\n\\tclass SmallestInfiniteSet {\\n    public:\\n    int x=1;\\n    set<int>pq;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        if(pq.size()!=0){\\n            auto d=*(pq.begin());\\n            pq.erase(pq.begin());\\n            //cout<<d;\\n            return d;\\n        }\\n        return x++;\\n\\n    }\\n    \\n    void addBack(int num) {\\n        if(num<x){\\n            pq.insert(num);\\n        }\\n      }\\n    };\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "\\n\\t\\n\\tclass SmallestInfiniteSet {\\n    public:\\n    int x=1;\\n    set<int>pq;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        if(pq.size()!=0){\\n            auto d=*(pq.begin());\\n            pq.erase(pq.begin());\\n            //cout<<d;\\n            return d;\\n        }\\n        return x++;\\n\\n    }\\n    \\n    void addBack(int num) {\\n        if(num<x){\\n            pq.insert(num);\\n        }\\n      }\\n    };\\n",
                "codeTag": "C++"
            },
            {
                "id": 3452093,
                "title": "127-ms",
                "content": "```ruby\\nclass SmallestInfiniteSet\\n\\n    def initialize\\n        @t = CRBTreeMap.new\\n        @c = 0\\n    end\\n\\n    def pop_smallest\\n        @t.empty? ? @c += 1 : @t.delete_min\\n    end\\n\\n    def add_back x\\n        @t[x] = x if x <= @c\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass SmallestInfiniteSet\\n\\n    def initialize\\n        @t = CRBTreeMap.new\\n        @c = 0\\n    end\\n\\n    def pop_smallest\\n        @t.empty? ? @c += 1 : @t.delete_min\\n    end\\n\\n    def add_back x\\n        @t[x] = x if x <= @c\\n    end\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007519,
                "title": "c-set-simple-solution",
                "content": "I saw many solutions inserting 1-1000 into a set. It is unnessary to do so. We can track the smallest element `idx` only and maintain a set which contains the element added by `addBack`.\\n\\n```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {}\\n    \\n    int popSmallest() {\\n        if (s.empty()) {\\n            return idx ++;\\n        }\\n        int res = *s.begin();\\n        s.erase(res);\\n        return res;\\n    }\\n    \\n    void addBack(int num) {\\n        if (num >= idx) return;\\n        s.insert(num);\\n        return;\\n    }\\nprivate:\\n    set<int, less<int>> s;\\n    int idx = 1;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {}\\n    \\n    int popSmallest() {\\n        if (s.empty()) {\\n            return idx ++;\\n        }\\n        int res = *s.begin();\\n        s.erase(res);\\n        return res;\\n    }\\n    \\n    void addBack(int num) {\\n        if (num >= idx) return;\\n        s.insert(num);\\n        return;\\n    }\\nprivate:\\n    set<int, less<int>> s;\\n    int idx = 1;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279657,
                "title": "kotlin-solution-hashset-simple-straightforward",
                "content": "```\\nclass SmallestInfiniteSet() {\\n    var hashSet = HashSet<Int>()\\n    init {\\n        for (i in 1 ..1000) hashSet.add(i)\\n    }\\n    fun popSmallest(): Int {\\n        var num = hashSet.min()!!\\n        hashSet.remove(hashSet.min()!!)\\n        return num\\n    }\\n\\n    fun addBack(num: Int) {\\n        hashSet.add(num)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet() {\\n    var hashSet = HashSet<Int>()\\n    init {\\n        for (i in 1 ..1000) hashSet.add(i)\\n    }\\n    fun popSmallest(): Int {\\n        var num = hashSet.min()!!\\n        hashSet.remove(hashSet.min()!!)\\n        return num\\n    }\\n\\n    fun addBack(num: Int) {\\n        hashSet.add(num)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261729,
                "title": "python3-without-priority-queue-easy-to-understand",
                "content": "```\\n    \\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.s=set()\\n        for i in range(1,1001):\\n            self.s.add(i)\\n        \\n\\n    def popSmallest(self) -> int:\\n        \\n        return self.s.pop()\\n\\n    def addBack(self, num: int) -> None:\\n        self.s.add(num)\\n\\n        self.s=set(sorted(list(self.s)))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\n    \\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.s=set()\\n        for i in range(1,1001):\\n            self.s.add(i)\\n        \\n\\n    def popSmallest(self) -> int:\\n        \\n        return self.s.pop()\\n\\n    def addBack(self, num: int) -> None:\\n        self.s.add(num)\\n\\n        self.s=set(sorted(list(self.s)))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455043,
                "title": "using-set-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    TreeSet<Integer> t;\\n    public SmallestInfiniteSet() {\\n        t=new TreeSet<Integer>();\\n        for(int i=1;i<=1000;i++)\\n        {\\n            t.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        return t.pollFirst();\\n        \\n    }\\n    \\n    public void addBack(int num) {\\n        t.add(num);\\n        \\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    TreeSet<Integer> t;\\n    public SmallestInfiniteSet() {\\n        t=new TreeSet<Integer>();\\n        for(int i=1;i<=1000;i++)\\n        {\\n            t.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        return t.pollFirst();\\n        \\n    }\\n    \\n    public void addBack(int num) {\\n        t.add(num);\\n        \\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454995,
                "title": "easy-c-explained-beats-100",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe class uses a set to store the integers in the infinite set. A set is a container that stores unique elements in a sorted order.\\n\\n\\nIn the constructor, the set is initialized with the first 1 thousands(as per the constraints) positive integers.\\n\\n\\npopSmallest() -- removes and returns the smallest integer in the set by calling begin() to get an iterator to the first element, dereferencing it with * to get the value, and then calling erase() to remove it from the set.\\n\\n\\naddBack(num) --  adds a positive integer num back into the set, if it is not already in the set. This is done by checking that num is positive and not already in the set using the count() method, and then inserting it into the set using the insert() method.\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) -- only adding thousands integer\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n\\n    set<int> nums;\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++){\\n            nums.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int smallest = *nums.begin();\\n        nums.erase(smallest);\\n        return smallest;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num > 0 && !nums.count(num)){\\n            nums.insert(num);\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n\\n    set<int> nums;\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++){\\n            nums.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int smallest = *nums.begin();\\n        nums.erase(smallest);\\n        return smallest;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num > 0 && !nums.count(num)){\\n            nums.insert(num);\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454628,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    \\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++) st.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int x = *st.begin();\\n        st.erase(x);\\n        return x;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    \\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++) st.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int x = *st.begin();\\n        st.erase(x);\\n        return x;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454241,
                "title": "swift-set-beats-100",
                "content": "# Set approach\\n\\n```\\nclass SmallestInfiniteSet {\\n    private var excluded = Set<Int>()\\n    private var smallest = 1\\n\\n    func popSmallest() -> Int {\\n        defer { \\n            excluded.insert(smallest)\\n            smallest = ((smallest+1)...1001).first { !excluded.contains($0) }! \\n        }\\n        return smallest        \\n    }\\n    \\n    func addBack(_ num: Int) {\\n        if num < smallest {\\n            smallest = num\\n        }\\n        excluded.remove(num)\\n    }\\n}\\n```\\n\\n> ***Please upvote if you like it***",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    private var excluded = Set<Int>()\\n    private var smallest = 1\\n\\n    func popSmallest() -> Int {\\n        defer { \\n            excluded.insert(smallest)\\n            smallest = ((smallest+1)...1001).first { !excluded.contains($0) }! \\n        }\\n        return smallest        \\n    }\\n    \\n    func addBack(_ num: Int) {\\n        if num < smallest {\\n            smallest = num\\n        }\\n        excluded.remove(num)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454219,
                "title": "min-heap-easy-to-understand",
                "content": "# Intuition\\nMin Heap\\n# Complexity\\n- Time complexity: lgn\\n- Space complexity: o(1000) ~= O(1)\\n\\n# Code\\n```\\nclass min_heap{\\n    constructor() {\\n        this.items = [];\\n    }\\n    add(x) {\\n        let q = this.items;\\n        q.push(x);\\n        let idx = q.length - 1;\\n        while(idx > 0) {\\n            let p = Math.floor((idx -1)/2);\\n            if(q[idx] < q[p]) {\\n                let t = q[idx];\\n                q[idx] = q[p];\\n                q[p] = t;\\n                idx = p;\\n            } else break\\n        }\\n    }\\n    remove() {\\n        let q = this.items;\\n        if(q.length === 1) {\\n            return q.pop();\\n        }\\n        let res = q[0];\\n        q[0] = q.pop();\\n        let idx = 0;\\n        let len = q.length;\\n        while(true) {\\n            let l = 2*idx + 1;\\n            let r = 2*idx + 2;\\n            let s = null;\\n            if(l < len && q[l] < q[idx]) {\\n                s = l;\\n            }\\n            if(r < len) {\\n                if(s === null && q[r] < q[idx]) {\\n                    s = r;\\n                }\\n                if(s !== null && q[r] < q[s]) {\\n                    s = r;\\n                }\\n            }\\n            if(s !== null) {\\n                let t = q[idx];\\n                q[idx] = q[s];\\n                q[s] = t;\\n                idx = s;\\n            } else break;\\n        }\\n        return res\\n    }\\n}\\n\\nvar SmallestInfiniteSet = function() {\\n    this.min_h = new min_heap();\\n    this.set = new Set();\\n    this.min_value = 1;\\n};\\n\\n/**\\n * @return {number}\\n */\\nSmallestInfiniteSet.prototype.popSmallest = function() {\\n    if (this.min_h.items.length === 0) {\\n        const result = this.min_value\\n        this.min_value += 1\\n        return result\\n    } else {\\n        const result = this.min_h.remove();\\n        this.set.delete(result)\\n        return result\\n    }\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSmallestInfiniteSet.prototype.addBack = function(num) {\\n    if (num < this.min_value && !this.set.has(num)) {\\n        this.min_h.add(num)\\n        this.set.add(num)\\n    }\\n};\\n\\n/** \\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * var obj = new SmallestInfiniteSet()\\n * var param_1 = obj.popSmallest()\\n * obj.addBack(num)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass min_heap{\\n    constructor() {\\n        this.items = [];\\n    }\\n    add(x) {\\n        let q = this.items;\\n        q.push(x);\\n        let idx = q.length - 1;\\n        while(idx > 0) {\\n            let p = Math.floor((idx -1)/2);\\n            if(q[idx] < q[p]) {\\n                let t = q[idx];\\n                q[idx] = q[p];\\n                q[p] = t;\\n                idx = p;\\n            } else break\\n        }\\n    }\\n    remove() {\\n        let q = this.items;\\n        if(q.length === 1) {\\n            return q.pop();\\n        }\\n        let res = q[0];\\n        q[0] = q.pop();\\n        let idx = 0;\\n        let len = q.length;\\n        while(true) {\\n            let l = 2*idx + 1;\\n            let r = 2*idx + 2;\\n            let s = null;\\n            if(l < len && q[l] < q[idx]) {\\n                s = l;\\n            }\\n            if(r < len) {\\n                if(s === null && q[r] < q[idx]) {\\n                    s = r;\\n                }\\n                if(s !== null && q[r] < q[s]) {\\n                    s = r;\\n                }\\n            }\\n            if(s !== null) {\\n                let t = q[idx];\\n                q[idx] = q[s];\\n                q[s] = t;\\n                idx = s;\\n            } else break;\\n        }\\n        return res\\n    }\\n}\\n\\nvar SmallestInfiniteSet = function() {\\n    this.min_h = new min_heap();\\n    this.set = new Set();\\n    this.min_value = 1;\\n};\\n\\n/**\\n * @return {number}\\n */\\nSmallestInfiniteSet.prototype.popSmallest = function() {\\n    if (this.min_h.items.length === 0) {\\n        const result = this.min_value\\n        this.min_value += 1\\n        return result\\n    } else {\\n        const result = this.min_h.remove();\\n        this.set.delete(result)\\n        return result\\n    }\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSmallestInfiniteSet.prototype.addBack = function(num) {\\n    if (num < this.min_value && !this.set.has(num)) {\\n        this.min_h.add(num)\\n        this.set.add(num)\\n    }\\n};\\n\\n/** \\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * var obj = new SmallestInfiniteSet()\\n * var param_1 = obj.popSmallest()\\n * obj.addBack(num)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454068,
                "title": "easiest-to-understand-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->Use min heap i.e. priority queue and a vector to mark the removed elements of min heap.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(1000) for initailizing the min heap with values. And O(1) for other operations.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1000+1000)\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue <int, vector<int>, greater<int>> pq;\\n    vector<int> remov;\\n    SmallestInfiniteSet() {\\n        for(int i =1; i<=1000;i++)\\n        pq.push(i);\\n        remov.resize(1001, 0);\\n    }\\n    \\n    int popSmallest() {\\n        if(!pq.empty())\\n        {\\n            int val = pq.top();\\n            pq.pop();\\n            remov[val]=1;\\n            return val;\\n        }\\n        return 0;\\n    }\\n    \\n    void addBack(int num) {\\n        if(remov[num])\\n        pq.push(num);\\n        remov[num]=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue <int, vector<int>, greater<int>> pq;\\n    vector<int> remov;\\n    SmallestInfiniteSet() {\\n        for(int i =1; i<=1000;i++)\\n        pq.push(i);\\n        remov.resize(1001, 0);\\n    }\\n    \\n    int popSmallest() {\\n        if(!pq.empty())\\n        {\\n            int val = pq.top();\\n            pq.pop();\\n            remov[val]=1;\\n            return val;\\n        }\\n        return 0;\\n    }\\n    \\n    void addBack(int num) {\\n        if(remov[num])\\n        pq.push(num);\\n        remov[num]=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453865,
                "title": "easy-solution-set-hashmap-cpp",
                "content": "# Intuition\\n*Insertion, Deletion and Lookup(minimun element)* should be fast. So ****Set**** *Data Stucture* comes to mind for this.\\nBecause each of these operation can be done in *log(N)* time.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize the **set** from 1 to 1001 values.\\n2. When popSmallest() is called then, *look* at the beginning of the set(st.begin()), becuase it store values in *ascending order* and return this value then *erase* from the set.\\n3. When addBack() call is made, then simply insert *num* in the set because if *duplicate* is their then it do nothing otherwise it will *insert* into it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:T(Nlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:S(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++){\\n            st.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        auto it = st.begin();\\n        int ans = *it;\\n        st.erase(it);\\n        return ans;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++){\\n            st.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        auto it = st.begin();\\n        int ans = *it;\\n        st.erase(it);\\n        return ans;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453162,
                "title": "c-solution-3",
                "content": "# Please give me an upvote. This is the first time I post here so I would like to have some love from our community. :3\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep a list (checkList) that contains the values we add back successfully. For AddBack operations lead to nothing, we don\\'t add those values to checkList. <br>\\nX param is used to save the largest number being popped from the beginning. <br>\\n## Some notes\\n- If we try to add a value greater than X, it should be existing in the set so we won\\'t add it to the set.\\n- Values in checkList must be identical (of course). That\\'s why I checked those conditions before adding num to the set.\\n- The smallest value must be in the checkList or X++ (if checkList is empty). Because the checkList contains only values that at-least-once being popped from the set (the set now is X + 1, X + 2, ..., Inf.). If some values is added again to the set (which are also added to checkList), it must be the smallest ones and must be popped before X + 1.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n168ms to run 135 testcases, beat 72%\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n57.2MB to run 135 testcases, beat 72%\\n\\n# Code\\n```\\npublic class SmallestInfiniteSet {\\n    int X;\\n    List<int> checkList;\\n    public SmallestInfiniteSet() {\\n        X = 0;\\n        checkList = new List<int>();\\n    }\\n    \\n    public int PopSmallest() {\\n        if (checkList.Count == 0) {\\n            X++;\\n            return X;\\n        }\\n        var min = checkList.Min();\\n        checkList.Remove(min);\\n        return min;\\n    }\\n    \\n    public void AddBack(int num) {\\n        if (num <= X && !checkList.Contains(num)) {\\n            checkList.Add(num);\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.PopSmallest();\\n * obj.AddBack(num);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class SmallestInfiniteSet {\\n    int X;\\n    List<int> checkList;\\n    public SmallestInfiniteSet() {\\n        X = 0;\\n        checkList = new List<int>();\\n    }\\n    \\n    public int PopSmallest() {\\n        if (checkList.Count == 0) {\\n            X++;\\n            return X;\\n        }\\n        var min = checkList.Min();\\n        checkList.Remove(min);\\n        return min;\\n    }\\n    \\n    public void AddBack(int num) {\\n        if (num <= X && !checkList.Contains(num)) {\\n            checkList.Add(num);\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.PopSmallest();\\n * obj.AddBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452959,
                "title": "easy-explanation-and-simple-approach-using-unordered-map-c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen  map is initialized, the map is populated with the integers from 1 to 1000, where the keys and values are the same for each integer. The variable k is initialized to 1, which represents the smallest integer in the set.\\n\\nThe popSmallest() function returns the smallest integer in the set, which is the value associated with the key k in the map. It then removes the key k from the map. Next, it searches for the next smallest integer in the set by iterating from k+1 to 1000 and looking for the smallest integer that exists in the map. If such an integer is found, it updates the value of k to that integer. Finally, it returns the smallest integer that was removed from the map.\\n\\nThe addBack(num) function adds the integer num to the map with the key and value both set to num. If num is smaller than k, it updates the value of k to num, as num is now the smallest integer in the set.\\n\\n# Complexity\\n- Time complexity:O(n)\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    int k=1;\\n    unordered_map<int,int>mpp;\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++) mpp[i]=i;\\n    }\\n    \\n    int popSmallest() {\\n        int d=mpp[k];\\n        mpp.erase(k);\\n        for(int i=k+1;i<=1000;i++){\\n            if(mpp.find(i)!=mpp.end()){\\n                k=i;\\n                break;\\n            }\\n        }\\n        return d;\\n    }\\n    \\n    void addBack(int num) {\\n        mpp[num]=num;\\n        if(num<k) k=num;\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    int k=1;\\n    unordered_map<int,int>mpp;\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++) mpp[i]=i;\\n    }\\n    \\n    int popSmallest() {\\n        int d=mpp[k];\\n        mpp.erase(k);\\n        for(int i=k+1;i<=1000;i++){\\n            if(mpp.find(i)!=mpp.end()){\\n                k=i;\\n                break;\\n            }\\n        }\\n        return d;\\n    }\\n    \\n    void addBack(int num) {\\n        mpp[num]=num;\\n        if(num<k) k=num;\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452894,
                "title": "simple-python3-solution-lists-dictionaries-upto-50-faster",
                "content": "# Approach\\nSimple Python3 code using Lists once and then dictionaries for the other.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n\\n\\n```python []\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.nums = list(range(1,1001))\\n        \\n\\n    def popSmallest(self) -> int:\\n        self.nums.sort()\\n        n = self.nums[0]\\n        self.nums[:] = self.nums[1:]\\n        return n\\n\\n    def addBack(self, num: int) -> None:\\n        if num not in self.nums:\\n            self.nums.append(num)\\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```\\n\\n```Py\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.nums = defaultdict(int)\\n        for i in range(1,1001):\\n            self.nums[i] = 1 \\n        \\n\\n    def popSmallest(self) -> int:\\n        temp = sorted(self.nums.keys())\\n        n = temp[0]\\n        del self.nums[n]\\n        return n\\n\\n    def addBack(self, num: int) -> None:\\n        self.nums[num] = 1\\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.nums = list(range(1,1001))\\n        \\n\\n    def popSmallest(self) -> int:\\n        self.nums.sort()\\n        n = self.nums[0]\\n        self.nums[:] = self.nums[1:]\\n        return n\\n\\n    def addBack(self, num: int) -> None:\\n        if num not in self.nums:\\n            self.nums.append(num)\\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```\n```Py\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.nums = defaultdict(int)\\n        for i in range(1,1001):\\n            self.nums[i] = 1 \\n        \\n\\n    def popSmallest(self) -> int:\\n        temp = sorted(self.nums.keys())\\n        n = temp[0]\\n        del self.nums[n]\\n        return n\\n\\n    def addBack(self, num: int) -> None:\\n        self.nums[num] = 1\\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452843,
                "title": "php-minheap-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(log N), insert heap, but other operations O(1)\\n\\n- Space complexity:\\nO(m + n), m - hash map, n - heap\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    private $minHeap;\\n    private $hashMap = [];\\n\\n    /**\\n     */\\n    function __construct() {\\n        $this->minHeap = new SplMinHeap();\\n\\n        for ($i = 1; $i <= 1000;$i++) {\\n            $this->minHeap->insert($i);\\n            $this->hashMap[$i] = $i;\\n        }\\n    }\\n  \\n    /**\\n     * @return Integer\\n     */\\n    function popSmallest() {\\n        $num = $this->minHeap->extract();\\n        unset($this->hashMap[$num]);\\n\\n        return $num;\\n    }\\n  \\n    /**\\n     * @param Integer $num\\n     * @return NULL\\n     */\\n    function addBack($num) {\\n        if (!isset($this->hashMap[$num])) {\\n            $this->minHeap->insert($num);\\n            $this->hashMap[$num] = $num; \\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * $obj = SmallestInfiniteSet();\\n * $ret_1 = $obj->popSmallest();\\n * $obj->addBack($num);\\n */\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    private $minHeap;\\n    private $hashMap = [];\\n\\n    /**\\n     */\\n    function __construct() {\\n        $this->minHeap = new SplMinHeap();\\n\\n        for ($i = 1; $i <= 1000;$i++) {\\n            $this->minHeap->insert($i);\\n            $this->hashMap[$i] = $i;\\n        }\\n    }\\n  \\n    /**\\n     * @return Integer\\n     */\\n    function popSmallest() {\\n        $num = $this->minHeap->extract();\\n        unset($this->hashMap[$num]);\\n\\n        return $num;\\n    }\\n  \\n    /**\\n     * @param Integer $num\\n     * @return NULL\\n     */\\n    function addBack($num) {\\n        if (!isset($this->hashMap[$num])) {\\n            $this->minHeap->insert($num);\\n            $this->hashMap[$num] = $num; \\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * $obj = SmallestInfiniteSet();\\n * $ret_1 = $obj->popSmallest();\\n * $obj->addBack($num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452696,
                "title": "java-99-9-counting-sort",
                "content": "# Time Complexity:\\npopSmallest() - o(n)\\naddBack() - o(1)\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n     int[] count;\\n     int popIndex = 1;\\n    public SmallestInfiniteSet() {\\n        count = new int[1002];\\n        Arrays.fill(count,1);\\n    }\\n    \\n    public int popSmallest() {\\n        \\n          count[popIndex] -= 1;\\n               \\n         int ans = popIndex;\\n          for(int i = popIndex + 1;i <= 1000;i++)\\n          {\\n              if(count[i] != 0)\\n              {\\n                popIndex = i;\\n                break;\\n              }\\n          }\\n        return ans;\\n    }\\n    \\n    public void addBack(int num) {\\n        \\n        if(count[num] != 0) return;\\n        count[num] += 1;\\n\\n        if(num < popIndex) popIndex = num;\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n     int[] count;\\n     int popIndex = 1;\\n    public SmallestInfiniteSet() {\\n        count = new int[1002];\\n        Arrays.fill(count,1);\\n    }\\n    \\n    public int popSmallest() {\\n        \\n          count[popIndex] -= 1;\\n               \\n         int ans = popIndex;\\n          for(int i = popIndex + 1;i <= 1000;i++)\\n          {\\n              if(count[i] != 0)\\n              {\\n                popIndex = i;\\n                break;\\n              }\\n          }\\n        return ans;\\n    }\\n    \\n    public void addBack(int num) {\\n        \\n        if(count[num] != 0) return;\\n        count[num] += 1;\\n\\n        if(num < popIndex) popIndex = num;\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452671,
                "title": "python-short-and-clean-2-solutions",
                "content": "# Approach\\nTL;DR, Similar to the [Editorial solution](https://leetcode.com/problems/smallest-number-in-infinite-set/editorial/).\\n\\n# Complexity\\n- Time complexity: $$O((m + n) * log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere,\\n`m is number of calls to popSmallest`,\\n`n is number of calls to addBack`.\\n\\n# Code\\nUsing SortedList:\\n```python\\nfrom sortedcontainers import SortedSet\\n\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.k = 1\\n        self.added = SortedSet()\\n\\n    def popSmallest(self) -> int:\\n        if self.added: return self.added.pop(0)\\n        else: self.k += 1; return self.k - 1\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.k: self.added.add(num)\\n\\n\\n```\\n\\nUsing heap and set:\\n```python\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.k: int = 1\\n        self.added: set[int] = set()\\n        self.added_hq: list[int] = []\\n\\n    def popSmallest(self) -> int:\\n        if self.added_hq:\\n            num = heappop(self.added_hq)\\n            self.added.remove(num)\\n        else:\\n            num = self.k\\n            self.k += 1\\n        return num\\n\\n    def addBack(self, num: int) -> None:\\n        if num >= self.k or num in self.added: return\\n        heappush(self.added_hq, num)\\n        self.added.add(num)\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Design",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedSet\\n\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.k = 1\\n        self.added = SortedSet()\\n\\n    def popSmallest(self) -> int:\\n        if self.added: return self.added.pop(0)\\n        else: self.k += 1; return self.k - 1\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.k: self.added.add(num)\\n\\n\\n```\n```python\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.k: int = 1\\n        self.added: set[int] = set()\\n        self.added_hq: list[int] = []\\n\\n    def popSmallest(self) -> int:\\n        if self.added_hq:\\n            num = heappop(self.added_hq)\\n            self.added.remove(num)\\n        else:\\n            num = self.k\\n            self.k += 1\\n        return num\\n\\n    def addBack(self, num: int) -> None:\\n        if num >= self.k or num in self.added: return\\n        heappush(self.added_hq, num)\\n        self.added.add(num)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452452,
                "title": "python3-solution",
                "content": "\\n```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.seen=[False]*1005\\n\\n\\n    def popSmallest(self) -> int:\\n        for i in range(1,1005):\\n            if not self.seen[i]:\\n                self.seen[i]=True\\n                return i\\n\\n    def addBack(self, num: int) -> None:\\n        if num<len(self.seen):\\n            self.seen[num]=False\\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.seen=[False]*1005\\n\\n\\n    def popSmallest(self) -> int:\\n        for i in range(1,1005):\\n            if not self.seen[i]:\\n                self.seen[i]=True\\n                return i\\n\\n    def addBack(self, num: int) -> None:\\n        if num<len(self.seen):\\n            self.seen[num]=False\\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452408,
                "title": "easy-java-solution-2-approaches",
                "content": "# Solution 1 \\n- Using HashSet and priority Queue\\n\\n# Complexity \\n- Time Complexity\\n    - popSmallest() -> $$O(nlog(n))$$\\n    - addBack() -> $$O(nlog(n))$$\\n- Space Complexity -> O(n)\\n\\nn is maximum number of insertion in Queue or hashset\\n\\n# Code \\n```\\nclass SmallestInfiniteSet {\\n    \\n    PriorityQueue<Integer> pq;\\n    HashSet<Integer> visited;\\n    int start;\\n\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<>();\\n        visited = new HashSet<>();\\n        start = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        if(pq.isEmpty()){\\n            return start++;\\n        } else {\\n            if(start < pq.peek()){\\n                return start++;\\n            } else {\\n                int smallest = pq.poll();\\n                if(start == smallest) start++;\\n                visited.remove(smallest);\\n                return smallest;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(!visited.contains(num)){\\n            visited.add(num);\\n            pq.offer(num);\\n        }\\n    }\\n}\\n```\\n\\n# Solution 2\\n- Using HashSet only\\n\\n# Complexity \\n- Time Complexity\\n    - popSmallest() -> $$O(nlog(n))$$\\n    - addBack() -> $$O(1)$$\\n- Space Complexity -> O(n)\\n\\nn is maximum number of insertion in Queue or hashset\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> visited;\\n    int start;\\n    public SmallestInfiniteSet() {\\n        visited = new HashSet<>();\\n        start = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        if(visited.isEmpty()){\\n            return start++;\\n        } else {\\n            int x = Collections.min(visited);\\n            visited.remove(x);\\n            return x;\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(start > num){\\n            visited.add(num);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    \\n    PriorityQueue<Integer> pq;\\n    HashSet<Integer> visited;\\n    int start;\\n\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<>();\\n        visited = new HashSet<>();\\n        start = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        if(pq.isEmpty()){\\n            return start++;\\n        } else {\\n            if(start < pq.peek()){\\n                return start++;\\n            } else {\\n                int smallest = pq.poll();\\n                if(start == smallest) start++;\\n                visited.remove(smallest);\\n                return smallest;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(!visited.contains(num)){\\n            visited.add(num);\\n            pq.offer(num);\\n        }\\n    }\\n}\\n```\n```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> visited;\\n    int start;\\n    public SmallestInfiniteSet() {\\n        visited = new HashSet<>();\\n        start = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        if(visited.isEmpty()){\\n            return start++;\\n        } else {\\n            int x = Collections.min(visited);\\n            visited.remove(x);\\n            return x;\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(start > num){\\n            visited.add(num);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452360,
                "title": "c-set-implementation-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\nDon,t be afraid of infinity. simply see the constraints.\\nYou can see it is from 1 to 1000. So just use it smartly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.)SmallestInfiniteSet()\\n\\nTo implement this simply initialises a set of integers from 1 to 1000.\\nYou can take a global variable set <int> s and insert numbers from 1 to N i.e. 1000 into it.\\n\\n2.)popSmallest()\\n\\nto pop the smallest , we know that in set smalest element will be at the beginning.\\nso just point to it with begin() function and remove it from the set with the help of erase() function.\\n\\n3.)addBack()\\n\\nfor this you have to simply insert the element into the set and set will take care of duplicate elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSmallestInfiniteSet() => O(N)\\npopSmallest() => O(1) i.e to point to first element it takes constant time\\naddBack() => O(logN) to insert the element\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe have used a set here to store 1 to N => O(N)\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\nprivate:\\nset<int>s;\\npublic:\\n    SmallestInfiniteSet() {\\n         const int sz = 1000; // const size\\n         for(int i=1;i<=1000;i++){\\n             s.insert(i);\\n         }\\n    }\\n    \\n    int popSmallest() {\\n        int smallest = *s.begin(); // to get the smallest element\\n        s.erase(s.begin()); // to remove that element from the stack\\n        return smallest;\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\nprivate:\\nset<int>s;\\npublic:\\n    SmallestInfiniteSet() {\\n         const int sz = 1000; // const size\\n         for(int i=1;i<=1000;i++){\\n             s.insert(i);\\n         }\\n    }\\n    \\n    int popSmallest() {\\n        int smallest = *s.begin(); // to get the smallest element\\n        s.erase(s.begin()); // to remove that element from the stack\\n        return smallest;\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452338,
                "title": "java-concise-code-beats-99-5",
                "content": "``` java []\\n\\n// 0 -> element is present\\n// 1 -> element is not present\\n\\nclass SmallestInfiniteSet {\\n    private byte[] a;\\n    private int minIndex;\\n    public SmallestInfiniteSet() {\\n        this.a=new byte[1001];\\n        this.minIndex=0;\\n    }\\n    \\n    public int popSmallest() {\\n        while(a[minIndex++]==1);\\n        a[minIndex-1]=1;\\n        return minIndex;\\n    }\\n    \\n    public void addBack(int num) {\\n        a[num-1]=0;\\n        minIndex = Math.min(minIndex,num-1);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\n\\n// 0 -> element is present\\n// 1 -> element is not present\\n\\nclass SmallestInfiniteSet {\\n    private byte[] a;\\n    private int minIndex;\\n    public SmallestInfiniteSet() {\\n        this.a=new byte[1001];\\n        this.minIndex=0;\\n    }\\n    \\n    public int popSmallest() {\\n        while(a[minIndex++]==1);\\n        a[minIndex-1]=1;\\n        return minIndex;\\n    }\\n    \\n    public void addBack(int num) {\\n        a[num-1]=0;\\n        minIndex = Math.min(minIndex,num-1);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452329,
                "title": "python3-heap-set-with-explanation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Use an int (self.current_num) to store the current smallest num in the infinite set **without considering addBack**\\n2. We need to use a min_heap (self.min_heap) to store the **addBack** num\\n2. What if we **addBack** a same num many times? We can\\'t add this num back to self.min_heap many times, because **SmallestInfiniteSet** is a **SET**!\\n\\n- Solution: We could use a set (self.s) to store the **addBack** num, this will make sure every **addBack** num only be added back to self.min_heap once!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **addBack**: We only add the num back to infinite set when this num is smaller than self.current_num **AND** this num has never been added back before. When adding this num, We need to do two operations.\\n    - 1. Add this num to self.min_heap. self.min_heap is used to store the added back nums. Smallest num is always at the top of the min_heap.\\n    - 2. Add this num to self.s. self.s is used to store the nums that has already been added once.\\n\\n- **popSmallest**:\\n    - 1. If there is num in self.min_heap, it means we have smaller nums (in self.min_heap) compared with self.current_num. We just need to pop the smallest num from self.min_heap. Don\\'t forget to remove this num from self.s, because we can add it back in the future.\\n    - 2. If self.min_heap is empty, return self.current_num and increase it by 1.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.current_num = 1\\n        self.min_heap = []\\n        self.s = set()\\n\\n        heapq.heapify(self.min_heap)\\n        \\n\\n    def popSmallest(self) -> int:\\n        # check the min_heap first\\n        if self.min_heap:\\n            smallest_num = heapq.heappop(self.min_heap)\\n            self.s.remove(smallest_num)\\n            return smallest_num\\n        \\n        else:\\n            smallest_num = self.current_num\\n            self.current_num += 1\\n            return smallest_num\\n        \\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.current_num and num not in self.s:\\n            self.s.add(num)\\n            heapq.heappush(self.min_heap, num)\\n        \\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.current_num = 1\\n        self.min_heap = []\\n        self.s = set()\\n\\n        heapq.heapify(self.min_heap)\\n        \\n\\n    def popSmallest(self) -> int:\\n        # check the min_heap first\\n        if self.min_heap:\\n            smallest_num = heapq.heappop(self.min_heap)\\n            self.s.remove(smallest_num)\\n            return smallest_num\\n        \\n        else:\\n            smallest_num = self.current_num\\n            self.current_num += 1\\n            return smallest_num\\n        \\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.current_num and num not in self.s:\\n            self.s.add(num)\\n            heapq.heappush(self.min_heap, num)\\n        \\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452192,
                "title": "c-using-set-implementation",
                "content": "# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        constexpr int N = 1000;\\n        for (int i = 1; i <= N; ++i) {\\n          s.emplace(i);\\n        }\\n    }\\n\\n    int popSmallest() {\\n        const int res = *s.begin();\\n        s.erase(s.begin());\\n        return res;\\n    }\\n\\n    void addBack(int num) {\\n        s.emplace(num);\\n    }\\n\\nprivate:\\n    set<int> s;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        constexpr int N = 1000;\\n        for (int i = 1; i <= N; ++i) {\\n          s.emplace(i);\\n        }\\n    }\\n\\n    int popSmallest() {\\n        const int res = *s.begin();\\n        s.erase(s.begin());\\n        return res;\\n    }\\n\\n    void addBack(int num) {\\n        s.emplace(num);\\n    }\\n\\nprivate:\\n    set<int> s;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452183,
                "title": "easy-c-solution-using-stl-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nSolution using the constraints\\n```\\nclass SmallestInfiniteSet {\\n    set<int> S;\\npublic:\\n    SmallestInfiniteSet() {\\n        for (int i=1; i<=1000; i++)\\n            S.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int x = *S.begin();\\n        S.erase(S.begin());\\n        return x;\\n    }\\n    \\n    void addBack(int num) {\\n        S.insert(num);\\n    }\\n};\\n\\n```\\nBetter solution\\n```\\nclass SmallestInfiniteSet {\\n    set<int> S;\\n    int min;\\npublic:\\n    SmallestInfiniteSet() {\\n        min=1;\\n    }\\n    \\n    int popSmallest() {\\n        if (!S.empty()){\\n            int x = *S.begin();\\n            S.erase(S.begin());\\n            return x;\\n        }\\n        return min++;\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < min)\\n            S.insert(num);\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Design"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    set<int> S;\\npublic:\\n    SmallestInfiniteSet() {\\n        for (int i=1; i<=1000; i++)\\n            S.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int x = *S.begin();\\n        S.erase(S.begin());\\n        return x;\\n    }\\n    \\n    void addBack(int num) {\\n        S.insert(num);\\n    }\\n};\\n\\n```\n```\\nclass SmallestInfiniteSet {\\n    set<int> S;\\n    int min;\\npublic:\\n    SmallestInfiniteSet() {\\n        min=1;\\n    }\\n    \\n    int popSmallest() {\\n        if (!S.empty()){\\n            int x = *S.begin();\\n            S.erase(S.begin());\\n            return x;\\n        }\\n        return min++;\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < min)\\n            S.insert(num);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452059,
                "title": "swift-using-array",
                "content": "**Array Approach (accepted answer)**\\n```\\nclass SmallestInfiniteSet {\\n    var popped = Array(repeating: false, count:1002) \\n    var smallest = 1\\n    \\n    func popSmallest() -> Int {\\n        popped[smallest] = true\\n        defer { smallest = popped[smallest...].firstIndex { !$0 }! } // !! this sets `smallest` AFTER the return statement\\n        return smallest\\n    }\\n    \\n    func addBack(_ num: Int) {\\n        popped[num] = false\\n        smallest = min(smallest, num)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    var popped = Array(repeating: false, count:1002) \\n    var smallest = 1\\n    \\n    func popSmallest() -> Int {\\n        popped[smallest] = true\\n        defer { smallest = popped[smallest...].firstIndex { !$0 }! } // !! this sets `smallest` AFTER the return statement\\n        return smallest\\n    }\\n    \\n    func addBack(_ num: Int) {\\n        popped[num] = false\\n        smallest = min(smallest, num)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040560,
                "title": "c-solution-using-set",
                "content": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    \\n    SmallestInfiniteSet() {\\n        s.insert(1);\\n    }\\n    \\n    int popSmallest() {\\n        int temp= *s.begin();\\n        s.erase(temp);\\n        if(s.size()==0){\\n            s.insert(temp+1);\\n        }\\n        return temp;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num< (*s.rbegin())){\\n            s.insert(num);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    \\n    SmallestInfiniteSet() {\\n        s.insert(1);\\n    }\\n    \\n    int popSmallest() {\\n        int temp= *s.begin();\\n        s.erase(temp);\\n        if(s.size()==0){\\n            s.insert(temp+1);\\n        }\\n        return temp;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num< (*s.rbegin())){\\n            s.insert(num);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2729313,
                "title": "efficient-solution",
                "content": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue <int, vector<int>, greater<int> > pq;\\n    unordered_set<int>st;\\n    \\n    SmallestInfiniteSet() \\n    {\\n         for(int i=1;i<=1001;i++)\\n         {\\n             pq.push(i);\\n             st.insert(i);\\n         }\\n    }\\n    \\n    int popSmallest() \\n    {\\n        int ele  = pq.top();\\n        st.erase(pq.top());\\n        pq.pop();\\n        return ele;\\n    }\\n    \\n    void addBack(int num) \\n    {\\n        if(st.find(num)!=st.end())\\n            return;\\n        else\\n        {\\n            pq.push(num);\\n            st.insert(num);\\n        }\\n            \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue <int, vector<int>, greater<int> > pq;\\n    unordered_set<int>st;\\n    \\n    SmallestInfiniteSet() \\n    {\\n         for(int i=1;i<=1001;i++)\\n         {\\n             pq.push(i);\\n             st.insert(i);\\n         }\\n    }\\n    \\n    int popSmallest() \\n    {\\n        int ele  = pq.top();\\n        st.erase(pq.top());\\n        pq.pop();\\n        return ele;\\n    }\\n    \\n    void addBack(int num) \\n    {\\n        if(st.find(num)!=st.end())\\n            return;\\n        else\\n        {\\n            pq.push(num);\\n            st.insert(num);\\n        }\\n            \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543051,
                "title": "using-set-only-efficient-solution",
                "content": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() {\\n        for(int i = 1 ; i <= 1000; i++)\\n            st.insert(i);\\n    }\\n    int popSmallest() {\\n        int a = *st.begin();\\n        st.erase(a);\\n        return a;   \\n    }\\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() {\\n        for(int i = 1 ; i <= 1000; i++)\\n            st.insert(i);\\n    }\\n    int popSmallest() {\\n        int a = *st.begin();\\n        st.erase(a);\\n        return a;   \\n    }\\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411239,
                "title": "c-easy-solution",
                "content": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int,vector<int>, greater<int> > v;\\n    vector<int> u;\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; ++i){\\n            v.push(i);\\n        }\\n        for(int i=0; i<1000; ++i){\\n            u.push_back(0);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int p = v.top();\\n        v.pop();\\n        u[p] = -1;\\n        return p;\\n    }\\n    \\n    void addBack(int num) {\\n        if(u[num] == -1){\\n            v.push(num);\\n            u[num] = 1;\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int,vector<int>, greater<int> > v;\\n    vector<int> u;\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; ++i){\\n            v.push(i);\\n        }\\n        for(int i=0; i<1000; ++i){\\n            u.push_back(0);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int p = v.top();\\n        v.pop();\\n        u[p] = -1;\\n        return p;\\n    }\\n    \\n    void addBack(int num) {\\n        if(u[num] == -1){\\n            v.push(num);\\n            u[num] = 1;\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282411,
                "title": "c-simple-code-95-better-solution",
                "content": "\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    int i=1;\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        auto it = s.begin();\\n        int x=i;\\n        if(s.size()>0&&*it<i) {\\n            x=*it;\\n            s.erase(*it);\\n        } else if(s.size()>0&&*it==i){\\n            s.erase(i);\\n            i++;\\n        } else i++;\\n        return x;\\n    }\\n    \\n    void addBack(int n) {\\n        s.insert(n);\\n    }\\n};",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    int i=1;\\n    set<int> s;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        auto it = s.begin();\\n        int x=i;\\n        if(s.size()>0&&*it<i) {\\n            x=*it;\\n            s.erase(*it);\\n        } else if(s.size()>0&&*it==i){\\n            s.erase(i);\\n            i++;\\n        } else i++;\\n        return x;\\n    }\\n    \\n    void addBack(int n) {\\n        s.insert(n);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2276468,
                "title": "java-brute-force-to-optimized-most-easiest-solution",
                "content": "**Brute-Force:**\\n```\\n    public static PriorityQueue<Integer> pq;\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<Integer>();\\n        for(int i = 1; i < 1001; i++) pq.offer(i);\\n    }\\n    public int popSmallest() {\\n        return pq.poll();\\n    }\\n    public void addBack(int num) {\\n        if(!pq.contains(num)) pq.offer(num);\\n    }\\n```\\n**Optimized (Easiest):**\\n```\\n    public static PriorityQueue<Integer> pq;\\n    int i = 1;\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<Integer>();\\n    }\\n    public int popSmallest() {\\n        if(pq.size() == 0) return i++;\\n        return pq.poll();\\n    }\\n    public void addBack(int num) {\\n        if(num < i && !pq.contains(num)) pq.add(num);\\n    }\\n```\\n**Upvote^, If you liked it.**\\n*Comment down, If you have any doubt.*",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public static PriorityQueue<Integer> pq;\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<Integer>();\\n        for(int i = 1; i < 1001; i++) pq.offer(i);\\n    }\\n    public int popSmallest() {\\n        return pq.poll();\\n    }\\n    public void addBack(int num) {\\n        if(!pq.contains(num)) pq.offer(num);\\n    }\\n```\n```\\n    public static PriorityQueue<Integer> pq;\\n    int i = 1;\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<Integer>();\\n    }\\n    public int popSmallest() {\\n        if(pq.size() == 0) return i++;\\n        return pq.poll();\\n    }\\n    public void addBack(int num) {\\n        if(num < i && !pq.contains(num)) pq.add(num);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2271878,
                "title": "python-heapq",
                "content": "```\\nfrom heapq import heapify,heappush,heappop\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.infiset=[i for i in range(1,1001)]\\n        heapify(self.infiset)\\n\\n    def popSmallest(self) -> int:\\n        \\n        data=heappop(self.infiset)\\n        return data\\n\\n    def addBack(self, num: int) -> None:\\n        if(num not in self.infiset):\\n            heappush(self.infiset,num)\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify,heappush,heappop\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.infiset=[i for i in range(1,1001)]\\n        heapify(self.infiset)\\n\\n    def popSmallest(self) -> int:\\n        \\n        data=heappop(self.infiset)\\n        return data\\n\\n    def addBack(self, num: int) -> None:\\n        if(num not in self.infiset):\\n            heappush(self.infiset,num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264506,
                "title": "100-c-set-explanation-with-code",
                "content": "We maintain a variable to store the last deleted number from the infinite positive numbers.\\nAlso, we maintain a set to store the numbers which get added back in the infinite positive numbers. When a number needs to be added back, we just insert it into the set.\\nThis way, when popping out a number, we can first check if the set is empty or not, if it is empty, we return ```lastDeleted + 1``` else we return the first number from the set and erase it from the set.\\n\\nC++ Code : \\n```\\nclass SmallestInfiniteSet {\\n    set<int> st;\\n    int lastDeleted; \\npublic:\\n    SmallestInfiniteSet() {\\n        lastDeleted = 0;\\n    }\\n    \\n    int popSmallest() {\\n        int ans;\\n        if(st.empty()){\\n            ans = lastDeleted + 1;\\n            lastDeleted = ans;\\n            return ans;\\n        }else{\\n            ans = *st.begin();\\n            st.erase(ans);\\n            return ans;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if(st.find(num)!=st.end() || num > lastDeleted)return;\\n        st.insert(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```lastDeleted + 1```\n```\\nclass SmallestInfiniteSet {\\n    set<int> st;\\n    int lastDeleted; \\npublic:\\n    SmallestInfiniteSet() {\\n        lastDeleted = 0;\\n    }\\n    \\n    int popSmallest() {\\n        int ans;\\n        if(st.empty()){\\n            ans = lastDeleted + 1;\\n            lastDeleted = ans;\\n            return ans;\\n        }else{\\n            ans = *st.begin();\\n            st.erase(ans);\\n            return ans;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if(st.find(num)!=st.end() || num > lastDeleted)return;\\n        st.insert(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261956,
                "title": "java-treeset",
                "content": "```\\nclass SmallestInfiniteSet {\\n        TreeSet<Integer> set;\\n\\t\\tint curMin = 1;\\n\\t    public SmallestInfiniteSet() {\\n\\t    \\tset = new TreeSet<>();\\n\\t    }\\n\\t    \\n\\t    public int popSmallest() {\\n\\t        if(!set.isEmpty()) return set.pollFirst();\\n\\t        return curMin++;\\n\\t    }\\n\\t    \\n\\t    public void addBack(int num) {\\n\\t    \\tif(num < curMin && !set.contains(num)) set.add(num);\\n\\t    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SmallestInfiniteSet {\\n        TreeSet<Integer> set;\\n\\t\\tint curMin = 1;\\n\\t    public SmallestInfiniteSet() {\\n\\t    \\tset = new TreeSet<>();\\n\\t    }\\n\\t    \\n\\t    public int popSmallest() {\\n\\t        if(!set.isEmpty()) return set.pollFirst();\\n\\t        return curMin++;\\n\\t    }\\n\\t    \\n\\t    public void addBack(int num) {\\n\\t    \\tif(num < curMin && !set.contains(num)) set.add(num);\\n\\t    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261723,
                "title": "c-set",
                "content": "We are making a set of elements that we do not have in the infinity set.\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int>s;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        int x=1;\\n        for(int i:s)\\n        {\\n            if(x!=i)\\n            {\\n                s.insert(x);    \\n                return x;\\n            }\\n            else \\n                x++;\\n        }\\n        s.insert(x);\\n        return x;\\n        \\n    }\\n    \\n    void addBack(int num) {\\n        if(s.find(num)!=s.end())\\n        {\\n            s.erase(num);\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int>s;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        int x=1;\\n        for(int i:s)\\n        {\\n            if(x!=i)\\n            {\\n                s.insert(x);    \\n                return x;\\n            }\\n            else \\n                x++;\\n        }\\n        s.insert(x);\\n        return x;\\n        \\n    }\\n    \\n    void addBack(int num) {\\n        if(s.find(num)!=s.end())\\n        {\\n            s.erase(num);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261544,
                "title": "no-hashmap-or-priorityqueue",
                "content": "```\\nclass SmallestInfiniteSet {\\n    TreeSet<Integer> set;\\n    public SmallestInfiniteSet() {\\n        set = new TreeSet<>();\\n        for(int i=1;i<=1000;i++){\\n            set.add(i);\\n        }\\n    }\\n    public int popSmallest() {\\n        return set.pollFirst();\\n    }\\n    public void addBack(int num) {\\n        set.add(num);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    TreeSet<Integer> set;\\n    public SmallestInfiniteSet() {\\n        set = new TreeSet<>();\\n        for(int i=1;i<=1000;i++){\\n            set.add(i);\\n        }\\n    }\\n    public int popSmallest() {\\n        return set.pollFirst();\\n    }\\n    public void addBack(int num) {\\n        set.add(num);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261470,
                "title": "a-few-solutions",
                "content": "Use a priority queue `q` and an unordered set of `seen` values.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass SmallestInfiniteSet() {\\n    private var q = PriorityQueue<Int>()\\n    private var seen = mutableSetOf<Int>()\\n    init {\\n        for (x in 1..1000) {\\n            q.add(x); seen.add(x)\\n        }\\n    }\\n    fun popSmallest(): Int {\\n        var x = q.poll(); seen.remove(x)\\n        return x\\n    }\\n    fun addBack(x: Int) {\\n        if (!seen.contains(x)) {\\n            q.add(x); seen.add(x)\\n        }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nclass SmallestInfiniteSet {\\n    constructor() {\\n        this.q = [];\\n        this.seen = new Set();\\n        for (let x = 1; x <= 1000; ++x)\\n            heappush(this.q, x), this.seen.add(x);\\n    }\\n    popSmallest() {\\n        let x = heappop(this.q); this.seen.delete(x);\\n        return x;\\n    }\\n    addBack(x) {\\n        if (!this.seen.has(x))\\n            heappush(this.q, x), this.seen.add(x);\\n    }\\n}\\n```\\n\\n*Python3*\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.q = [x for x in range(1, 1000 + 1)]; heapify(self.q)\\n        self.seen = set(self.q)\\n\\n    def popSmallest(self) -> int:\\n        x = heappop(self.q); self.seen.remove(x)\\n        return x\\n\\n    def addBack(self, x: int) -> None:\\n        if x not in self.seen:\\n            heappush(self.q, x); self.seen.add(x)\\n```\\n\\n*C++*\\n```\\nclass SmallestInfiniteSet {\\n    using Set = unordered_set<int>;\\n    using Queue = priority_queue<int, vector<int>, greater<int>>;\\n    Set seen;\\n    Queue q;\\npublic:\\n    SmallestInfiniteSet() {\\n        for (auto x{ 1 }; x <= 1000; ++x)\\n            q.push(x), seen.insert(x);\\n    }\\n    int popSmallest() {\\n        auto x = q.top(); q.pop(), seen.erase(x);\\n        return x;\\n    }\\n    void addBack(int x) {\\n        if (seen.insert(x).second)\\n            q.push(x);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass SmallestInfiniteSet() {\\n    private var q = PriorityQueue<Int>()\\n    private var seen = mutableSetOf<Int>()\\n    init {\\n        for (x in 1..1000) {\\n            q.add(x); seen.add(x)\\n        }\\n    }\\n    fun popSmallest(): Int {\\n        var x = q.poll(); seen.remove(x)\\n        return x\\n    }\\n    fun addBack(x: Int) {\\n        if (!seen.contains(x)) {\\n            q.add(x); seen.add(x)\\n        }\\n    }\\n}\\n```\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.min) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.min) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nclass SmallestInfiniteSet {\\n    constructor() {\\n        this.q = [];\\n        this.seen = new Set();\\n        for (let x = 1; x <= 1000; ++x)\\n            heappush(this.q, x), this.seen.add(x);\\n    }\\n    popSmallest() {\\n        let x = heappop(this.q); this.seen.delete(x);\\n        return x;\\n    }\\n    addBack(x) {\\n        if (!this.seen.has(x))\\n            heappush(this.q, x), this.seen.add(x);\\n    }\\n}\\n```\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.q = [x for x in range(1, 1000 + 1)]; heapify(self.q)\\n        self.seen = set(self.q)\\n\\n    def popSmallest(self) -> int:\\n        x = heappop(self.q); self.seen.remove(x)\\n        return x\\n\\n    def addBack(self, x: int) -> None:\\n        if x not in self.seen:\\n            heappush(self.q, x); self.seen.add(x)\\n```\n```\\nclass SmallestInfiniteSet {\\n    using Set = unordered_set<int>;\\n    using Queue = priority_queue<int, vector<int>, greater<int>>;\\n    Set seen;\\n    Queue q;\\npublic:\\n    SmallestInfiniteSet() {\\n        for (auto x{ 1 }; x <= 1000; ++x)\\n            q.push(x), seen.insert(x);\\n    }\\n    int popSmallest() {\\n        auto x = q.top(); q.pop(), seen.erase(x);\\n        return x;\\n    }\\n    void addBack(int x) {\\n        if (seen.insert(x).second)\\n            q.push(x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261384,
                "title": "c-using-set",
                "content": "class SmallestInfiniteSet {\\npublic:\\n\\n    set<int>s;\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++){\\n            s.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int ans=0;\\n        ans=*s.begin();\\n        s.erase(*s.begin());\\n        return ans;\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class SmallestInfiniteSet {\\npublic:\\n\\n    set<int>s;\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++){\\n            s.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int ans=0;\\n        ans=*s.begin();\\n        s.erase(*s.begin());\\n        return ans;\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2261231,
                "title": "c-set",
                "content": "***1. Declare a set***\\n***2. Initialize the set with 1st 1000 positive intergers in the SmallestInfiniteSet()***\\n***3. popSmallest() erase the smallest element (1st element of set)***\\n***4. insert element in set because it stores unique values only***\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s1;\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++)    s1.insert(i);\\n    } \\n    int popSmallest() {\\n        int it = *s1.begin();\\n        s1.erase(it);\\n        return it;\\n    }    \\n    void addBack(int num) {\\n        s1.insert(num);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s1;\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++)    s1.insert(i);\\n    } \\n    int popSmallest() {\\n        int it = *s1.begin();\\n        s1.erase(it);\\n        return it;\\n    }    \\n    void addBack(int num) {\\n        s1.insert(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064175,
                "title": "effecient-solution-new-approach",
                "content": "\\n```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> remov;\\n    int i;\\n    public SmallestInfiniteSet() {\\n        remov=new HashSet();\\n        i=1;\\n    }\\n    \\n    public int popSmallest() {\\n        while(remov.contains(i)){\\n            i++;\\n        }\\n        remov.add(i);\\n        return i++;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(remov.contains(num)){\\n            remov.remove(num);\\n            if(i>num){\\n                i=num;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> remov;\\n    int i;\\n    public SmallestInfiniteSet() {\\n        remov=new HashSet();\\n        i=1;\\n    }\\n    \\n    public int popSmallest() {\\n        while(remov.contains(i)){\\n            i++;\\n        }\\n        remov.add(i);\\n        return i++;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(remov.contains(num)){\\n            remov.remove(num);\\n            if(i>num){\\n                i=num;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932965,
                "title": "simple-using-min-heap-set",
                "content": "class SmallestInfiniteSet {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>>pq;\\n    unordered_set<int>st;\\n    \\n    SmallestInfiniteSet() {\\n        int i=1,f=1;\\n        while(i<1001 && f==1){\\n            pq.push(i);\\n            i++;\\n        }\\n        if(i==1001)f=0;\\n    }\\n    \\n    int popSmallest() {\\n         int x = pq.top();\\n         pq.pop();\\n         st.insert(x);\\n         return x;\\n    }\\n    \\n    void addBack(int num) {\\n        if(st.find(num)!=st.end()){\\n            pq.push(num);\\n            st.erase(st.find(num));\\n        }\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "class SmallestInfiniteSet {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>>pq;\\n    unordered_set<int>st;\\n    \\n    SmallestInfiniteSet() {\\n        int i=1,f=1;\\n        while(i<1001 && f==1){\\n            pq.push(i);\\n            i++;\\n        }\\n        if(i==1001)f=0;\\n    }\\n    \\n    int popSmallest() {\\n         int x = pq.top();\\n         pq.pop();\\n         st.insert(x);\\n         return x;\\n    }\\n    \\n    void addBack(int num) {\\n        if(st.find(num)!=st.end()){\\n            pq.push(num);\\n            st.erase(st.find(num));\\n        }\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3886611,
                "title": "c-set-with-good-explanation",
                "content": "```\\n- currSmallest starts at 1\\n- If you pop, currSmallest is now 2, pop again, currSmallest \\n is now 3\\n- Now the series looks like this [3, 4, ....]\\n- You can add a number which is smallest than currSmallest\\n- Add this number to the set S\\n- So, if we add 2, now it looks like this... S = {2},\\n  currSmallest = 3\\n- Add back 1. S = {1, 2}, currSmallest = 3\\n\\n- When you try popping, since set contains only numbers that are\\n  smaller than the currSmallest, we choose the smallest in\\n  the set.\\n- Smallest in the set is 1, we return this & remove it from the\\n  set S\\n- S = {2}, currSmallest = 3\\n\\n- If you pop again... since S is not empty, after popping it\\n  will look like this... S = {}, currSmallest = 3\\n- Now if you try popping again, since set S is empty, we are\\n  sure no element is smaller that the currSmallest. Hence we\\n  return currSmallest and increment by 1. currSmallest is now 4\\n- And so on...\\n```\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    \\n    int popSmallest() {\\n        if (!S.empty()) {\\n            int smallest = *S.begin();\\n            S.erase(smallest);\\n            return smallest;\\n        }\\n        return currSmallest++;\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currSmallest)\\n            S.insert(num);\\n    }\\n\\nprivate:\\n    set<int> S;\\n    int currSmallest;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\n- currSmallest starts at 1\\n- If you pop, currSmallest is now 2, pop again, currSmallest \\n is now 3\\n- Now the series looks like this [3, 4, ....]\\n- You can add a number which is smallest than currSmallest\\n- Add this number to the set S\\n- So, if we add 2, now it looks like this... S = {2},\\n  currSmallest = 3\\n- Add back 1. S = {1, 2}, currSmallest = 3\\n\\n- When you try popping, since set contains only numbers that are\\n  smaller than the currSmallest, we choose the smallest in\\n  the set.\\n- Smallest in the set is 1, we return this & remove it from the\\n  set S\\n- S = {2}, currSmallest = 3\\n\\n- If you pop again... since S is not empty, after popping it\\n  will look like this... S = {}, currSmallest = 3\\n- Now if you try popping again, since set S is empty, we are\\n  sure no element is smaller that the currSmallest. Hence we\\n  return currSmallest and increment by 1. currSmallest is now 4\\n- And so on...\\n```\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    \\n    int popSmallest() {\\n        if (!S.empty()) {\\n            int smallest = *S.begin();\\n            S.erase(smallest);\\n            return smallest;\\n        }\\n        return currSmallest++;\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currSmallest)\\n            S.insert(num);\\n    }\\n\\nprivate:\\n    set<int> S;\\n    int currSmallest;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779026,
                "title": "clean-priorityqueue-solution",
                "content": "# Approach\\nWe need to carry only 2 things:\\n1. What is current min\\n2. What numbers have been added\\n\\nIf queue is empty, then we just keep moving on straightly from 1 to inf increasing current value, otherwise we have added numbers, so we should pop them first of all form min to max, that is achieved by priority queue.\\n\\nIf it was helpfull, please like)\\n\\n# Code\\n```\\nclass SmallestInfiniteSet() {\\n    var cur = 1\\n    var added = PriorityQueue<Int>()\\n\\n    fun popSmallest(): Int {\\n        return if (added.isEmpty()) cur++\\n        else added.poll()\\n    }\\n\\n    fun addBack(num: Int) {\\n        if (num < cur && num !in added) added.add(num)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass SmallestInfiniteSet() {\\n    var cur = 1\\n    var added = PriorityQueue<Int>()\\n\\n    fun popSmallest(): Int {\\n        return if (added.isEmpty()) cur++\\n        else added.poll()\\n    }\\n\\n    fun addBack(num: Int) {\\n        if (num < cur && num !in added) added.add(num)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767072,
                "title": "java-99-99-beats-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n\\n    private Integer minNum;\\n    private PriorityQueue<Integer> heap;\\n\\n    public SmallestInfiniteSet() {\\n        minNum = 1;\\n        heap = new PriorityQueue<>();\\n    }\\n    \\n   public int popSmallest() {\\n        if (!heap.isEmpty()) {\\n            return heap.poll();\\n        }\\n        minNum++;\\n        return minNum - 1;\\n    }\\n\\n    public void addBack(int num) {\\n        if (minNum > num && !heap.contains(num)) {\\n            heap.offer(num);\\n        }\\n    }\\n}\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n\\n    private Integer minNum;\\n    private PriorityQueue<Integer> heap;\\n\\n    public SmallestInfiniteSet() {\\n        minNum = 1;\\n        heap = new PriorityQueue<>();\\n    }\\n    \\n   public int popSmallest() {\\n        if (!heap.isEmpty()) {\\n            return heap.poll();\\n        }\\n        minNum++;\\n        return minNum - 1;\\n    }\\n\\n    public void addBack(int num) {\\n        if (minNum > num && !heap.contains(num)) {\\n            heap.offer(num);\\n        }\\n    }\\n}\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520888,
                "title": "smallest-infinite-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        l=list(range(1,1001))\\n        self.s1=set(l)\\n        \\n\\n    def popSmallest(self) -> int:\\n        a1=min(self.s1)\\n        self.s1.remove(a1)\\n        return a1\\n\\n        \\n\\n    def addBack(self, num: int) -> None:\\n        if(num not in self.s1):\\n            self.s1.add(num)\\n        \\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        l=list(range(1,1001))\\n        self.s1=set(l)\\n        \\n\\n    def popSmallest(self) -> int:\\n        a1=min(self.s1)\\n        self.s1.remove(a1)\\n        return a1\\n\\n        \\n\\n    def addBack(self, num: int) -> None:\\n        if(num not in self.s1):\\n            self.s1.add(num)\\n        \\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456088,
                "title": "c-easy-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n\\n    set<int> st;\\n    \\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++){\\n            st.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        auto it = st.begin();\\n        int val = *it;\\n        st.erase(it);\\n        return val;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n\\n    set<int> st;\\n    \\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++){\\n            st.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        auto it = st.begin();\\n        int val = *it;\\n        st.erase(it);\\n        return val;\\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455833,
                "title": "javascript-solution-with-set",
                "content": "# Intuition\\nCreate a class that maintains a Set of integers and provides methods to remove the smallest element and add elements back to the Set.\\n\\n# Approach\\n1. Implement a SmallestInfiniteSet class with a constructor that initializes a Set containing numbers from 1 to 1001.\\n2.Implement a popSmallest method that iterates through the Set to find the smallest element, removes it from the Set, and returns it.\\n3. Implement an addBack method that adds a given number back to the Set if it doesn\\'t already exist in the Set.\\n\\n# Complexity\\n- Time complexity:\\ninitialization: O(n)\\npopSmallest: O(n)\\naddBack: O(1)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n  constructor() {\\n    this.set = new Set(Array.from({ length: 1001 }, (_, i) => i + 1));\\n  }\\n}\\n\\n/**\\n * @return {number}\\n */\\nSmallestInfiniteSet.prototype.popSmallest = function() {\\n  if (this.set.size === 0) return null;\\n\\n  let min = Infinity;\\n\\n  for (const num of this.set) {\\n    if (num < min) {\\n      min = num;\\n    }\\n  }\\n\\n  this.set.delete(min);\\n  return min;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSmallestInfiniteSet.prototype.addBack = function(num) {\\n     if (!this.set.has(num)) this.set.add(num)\\n};\\n\\n/** \\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * var obj = new SmallestInfiniteSet()\\n * var param_1 = obj.popSmallest()\\n * obj.addBack(num)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n  constructor() {\\n    this.set = new Set(Array.from({ length: 1001 }, (_, i) => i + 1));\\n  }\\n}\\n\\n/**\\n * @return {number}\\n */\\nSmallestInfiniteSet.prototype.popSmallest = function() {\\n  if (this.set.size === 0) return null;\\n\\n  let min = Infinity;\\n\\n  for (const num of this.set) {\\n    if (num < min) {\\n      min = num;\\n    }\\n  }\\n\\n  this.set.delete(min);\\n  return min;\\n};\\n\\n/** \\n * @param {number} num\\n * @return {void}\\n */\\nSmallestInfiniteSet.prototype.addBack = function(num) {\\n     if (!this.set.has(num)) this.set.add(num)\\n};\\n\\n/** \\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * var obj = new SmallestInfiniteSet()\\n * var param_1 = obj.popSmallest()\\n * obj.addBack(num)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455128,
                "title": "java-easy-to-understand-solution-hashmap-and-heap-tc-o-nlogn-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe provided solution comes to my mind when i look to constraints given in the question for num(numbers which we can conatins in the set as it given that the maximum value can be 1000).\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will create a minHeap/min Priority queue which will intially contains the value present in positive set(which contains all positive integers [1, 2, 3, 4, 5, ...] till 1000 as 1000 is the max limits of numbers that can be present in set).\\n\\nWe will also create a HashMap to keep the track of elements which have been removed from the minHeap therefore it will also keep the track of elements which are present in minHeap.\\nThe elements which are in minHeap would not be in hashMap and vice-versa.\\n\\nSo in SmallestInfiniteSet() we will intialize our minHeap of size 1000 and add 1 to 1000 elements in minHeap and also create a hashmap.\\n\\nIn popSmallest() function we will remove the top most element from minHeap which will be always smallest element present in set and return it.\\nAnd then we will also add it to HashMap so that we can use this hashmap while implementing addBack().\\n\\nIn addBack(int num) we will use the hashMap to check if the number which we are adding to the set/minheap is whether present in the set or not, like if the element is present in hashmap then it is not present in set as the hashMap only contains value which are removed from the set.\\nSo if value is present in hashMap then we will remove it from hashMap and add it set/minHeap.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n\\n    private PriorityQueue<Integer> pq;\\n    private HashMap<Integer, Integer> hm;\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<Integer>();\\n        hm = new HashMap<Integer, Integer>();\\n        for(int i=1; i<=1000; i++)\\n        {\\n            pq.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        hm.put(pq.peek(),1);\\n        return pq.poll();\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hm.containsKey(num))\\n        {\\n            hm.remove(num);\\n            pq.add(num);\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n\\n    private PriorityQueue<Integer> pq;\\n    private HashMap<Integer, Integer> hm;\\n    public SmallestInfiniteSet() {\\n        pq = new PriorityQueue<Integer>();\\n        hm = new HashMap<Integer, Integer>();\\n        for(int i=1; i<=1000; i++)\\n        {\\n            pq.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        hm.put(pq.peek(),1);\\n        return pq.poll();\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hm.containsKey(num))\\n        {\\n            hm.remove(num);\\n            pq.add(num);\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455036,
                "title": "python-heap-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to create a set-like data structure that can store an infinite number of integers and support the operations of adding a number to the set and removing the smallest number from the set. The most efficient way to perform these operations is by using a heap data structure.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use the heapq library in Python, which provides an implementation of the heap data structure. We can initialize a heap with integers from 1 to 1000 and perform the add and remove operations using the heappush and heappop methods, respectively. To keep track of the removed numbers, we can use a set to store them.\\n\\nThe __init__ method initializes the heap and the set. The popSmallest method pops the smallest number from the heap and adds it to the set of popped numbers. The addBack method adds a number to the heap if it has not been removed, otherwise, it removes it from the set of popped numbers and adds it to the heap.\\n\\n# Complexity\\n- Time complexity: (a + b)logn\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of __init__ method is O(n), where n is the number of integers in the heap. This is because time complexity of heapify() is O(n).\\nThe time complexity of popSmallest method is O(logn), where n is the number of integers in the heap.\\nThe time complexity of addBack method is O(logn), where n is the number of integers in the heap.\\nHence, overall time complexity is (a + b)logn, where n is total numbers initialised, and a and b are number of calls of popSmallest and addBack methods respectively.\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the SmallestInfiniteSet class is O(n), where n is the number of integers in the heap. This is because we store the integers from 1 to 1000 in the heap.\\n\\n# Code\\n```\\nfrom heapq import heapify, heappush, heappop\\n\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.popped_nums = set()\\n        self.heap = [i for i in range(1, 1001)]\\n        heapify(self.heap)\\n\\n    def popSmallest(self) -> int:\\n        top = heappop(self.heap)\\n        self.popped_nums.add(top)\\n        \\n        return top\\n        \\n    def addBack(self, num: int) -> None:\\n        if num in self.popped_nums:\\n            self.popped_nums.remove(num)\\n            heappush(self.heap, num)                  \\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify, heappush, heappop\\n\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.popped_nums = set()\\n        self.heap = [i for i in range(1, 1001)]\\n        heapify(self.heap)\\n\\n    def popSmallest(self) -> int:\\n        top = heappop(self.heap)\\n        self.popped_nums.add(top)\\n        \\n        return top\\n        \\n    def addBack(self, num: int) -> None:\\n        if num in self.popped_nums:\\n            self.popped_nums.remove(num)\\n            heappush(self.heap, num)                  \\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455007,
                "title": "simple-approach-fast-c",
                "content": "\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    \\n    int ptr = 1;\\n    vector<bool> arr;\\n\\n    SmallestInfiniteSet() {\\n        arr.assign(1001,true);\\n    }\\n    \\n    int popSmallest() {\\n       while(!arr[ptr]) ptr++;\\n       arr[ptr] = false;\\n       ptr++;\\n       return ptr-1; \\n    } \\n    \\n    void addBack(int num) {\\n       arr[num] = true; \\n       if( ptr >= num) ptr = num; \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    \\n    int ptr = 1;\\n    vector<bool> arr;\\n\\n    SmallestInfiniteSet() {\\n        arr.assign(1001,true);\\n    }\\n    \\n    int popSmallest() {\\n       while(!arr[ptr]) ptr++;\\n       arr[ptr] = false;\\n       ptr++;\\n       return ptr-1; \\n    } \\n    \\n    void addBack(int num) {\\n       arr[num] = true; \\n       if( ptr >= num) ptr = num; \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454926,
                "title": "smallest-number-in-infinite-set-solution-python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.list=list(range(1,1001))\\n        \\n\\n    def popSmallest(self) -> int:\\n        self.list.sort()\\n        n=self.list.pop(0)\\n        return n\\n\\n        \\n\\n    def addBack(self, num: int) -> None:\\n        if num not in self.list:\\n            self.list.append(num)\\n        \\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.list=list(range(1,1001))\\n        \\n\\n    def popSmallest(self) -> int:\\n        self.list.sort()\\n        n=self.list.pop(0)\\n        return n\\n\\n        \\n\\n    def addBack(self, num: int) -> None:\\n        if num not in self.list:\\n            self.list.append(num)\\n        \\n\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet()\\n# param_1 = obj.popSmallest()\\n# obj.addBack(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454786,
                "title": "beats-99-5-runtime-and-100-memory-simple-list-solution",
                "content": "# Intuition\\nBoolean list, false when number is in list and true when the number is out. Only need a list to 1001 as the max number of iterations is 1000 \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n\\n    boolean[] list;\\n    int nums;\\n    \\n    public SmallestInfiniteSet() {\\n        list = new boolean[1001];\\n        nums = 1;\\n    }\\n    \\n    public int popSmallest() {\\n\\n\\n        for(int x = nums; x < list.length; x++)\\n        {\\n            if(!list[x])\\n            {\\n                list[x] = true;\\n                nums = x;\\n                break;\\n            }\\n\\n        }\\n        return nums;\\n\\n\\n        \\n    }\\n    \\n    public void addBack(int num) {\\n        list[num] = false;\\n        nums = Math.min(num, nums);        \\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n\\n    boolean[] list;\\n    int nums;\\n    \\n    public SmallestInfiniteSet() {\\n        list = new boolean[1001];\\n        nums = 1;\\n    }\\n    \\n    public int popSmallest() {\\n\\n\\n        for(int x = nums; x < list.length; x++)\\n        {\\n            if(!list[x])\\n            {\\n                list[x] = true;\\n                nums = x;\\n                break;\\n            }\\n\\n        }\\n        return nums;\\n\\n\\n        \\n    }\\n    \\n    public void addBack(int num) {\\n        list[num] = false;\\n        nums = Math.min(num, nums);        \\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454448,
                "title": "smallest-number-in-infinite-set-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    vector<int> arr;\\n    SmallestInfiniteSet() {\\n        int i;\\n        for(i=1 ; i<=1000 ; i++)\\n        {\\n            arr.push_back(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        sort(arr.begin(), arr.end());\\n        int popped_value = arr[0];\\n        arr.erase(arr.begin()+0);\\n        return popped_value;\\n    }\\n    \\n    void addBack(int num) {\\n        if(count(arr.begin(), arr.end(), num)==0)\\n        {\\n            arr.push_back(num);\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/5f89494e-4f52-418b-be22-ba20e38eb060_1682612605.8113089.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    vector<int> arr;\\n    SmallestInfiniteSet() {\\n        int i;\\n        for(i=1 ; i<=1000 ; i++)\\n        {\\n            arr.push_back(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        sort(arr.begin(), arr.end());\\n        int popped_value = arr[0];\\n        arr.erase(arr.begin()+0);\\n        return popped_value;\\n    }\\n    \\n    void addBack(int num) {\\n        if(count(arr.begin(), arr.end(), num)==0)\\n        {\\n            arr.push_back(num);\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454368,
                "title": "java-amortized-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain a variable to store the smallest in the set. Store the Missing elements in a HashMap and use the HashMap to update the smallest element present in the set during addBack and popSmallest.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAmortized O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(Number of missing elements)\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n\\n    //Hashmap stores the missing values and smallest stores the smallest element present in the set\\n\\n    HashMap<Integer,Integer> hm;\\n    int smallest;\\n    public SmallestInfiniteSet() {\\n        hm = new HashMap<>();\\n        smallest = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        hm.put(smallest,1);\\n        int temp = smallest;\\n        int ans = temp;\\n\\n        while(hm.containsKey(temp))\\n            temp+=1;\\n        smallest = temp;\\n        return ans;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hm.containsKey(num))\\n            hm.remove(num);\\n        smallest = num<smallest?num:smallest;\\n    }\\n}\\n\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n\\n    //Hashmap stores the missing values and smallest stores the smallest element present in the set\\n\\n    HashMap<Integer,Integer> hm;\\n    int smallest;\\n    public SmallestInfiniteSet() {\\n        hm = new HashMap<>();\\n        smallest = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        hm.put(smallest,1);\\n        int temp = smallest;\\n        int ans = temp;\\n\\n        while(hm.containsKey(temp))\\n            temp+=1;\\n        smallest = temp;\\n        return ans;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hm.containsKey(num))\\n            hm.remove(num);\\n        smallest = num<smallest?num:smallest;\\n    }\\n}\\n\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454286,
                "title": "java-simple-array-solution",
                "content": "The follwing solution takes advantage of the fact that we have only numbers upto 1000 to process. Just create an array of size 1000 and mark the elements if they are present or absent based on the indexes. \\n```\\nclass SmallestInfiniteSet {\\n    \\n    int[] set;\\n    \\n    public SmallestInfiniteSet() {\\n        set = new int[1001];\\n        Arrays.fill(set, 1); // adding all elements in to the set\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1; i<1001; i++) \\n            if(set[i]==1) {\\n                set[i] = -1; // removing the element \\n                return i;\\n            }\\n        return 0;\\n    }\\n    \\n    public void addBack(int num) {\\n        set[num] = 1; // adding the element back\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    \\n    int[] set;\\n    \\n    public SmallestInfiniteSet() {\\n        set = new int[1001];\\n        Arrays.fill(set, 1); // adding all elements in to the set\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1; i<1001; i++) \\n            if(set[i]==1) {\\n                set[i] = -1; // removing the element \\n                return i;\\n            }\\n        return 0;\\n    }\\n    \\n    public void addBack(int num) {\\n        set[num] = 1; // adding the element back\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454194,
                "title": "java-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass SmallestInfiniteSet {\\n    private Set<Integer> set;\\n\\n    public SmallestInfiniteSet() {\\n        set = new HashSet<>();\\n        for(int i = 1; i <= 1000; i++) {\\n            set.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        int smallest = 0;\\n        for(int num : set) {\\n            smallest = num;\\n            set.remove(num);\\n            break;\\n        }\\n        return smallest;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(!set.contains(num)) {\\n            set.add(num);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    private Set<Integer> set;\\n\\n    public SmallestInfiniteSet() {\\n        set = new HashSet<>();\\n        for(int i = 1; i <= 1000; i++) {\\n            set.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        int smallest = 0;\\n        for(int num : set) {\\n            smallest = num;\\n            set.remove(num);\\n            break;\\n        }\\n        return smallest;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(!set.contains(num)) {\\n            set.add(num);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454108,
                "title": "c-solution-using-priority-queue-and-set",
                "content": "# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue <int, vector<int>, greater<int>> pq;\\n    set<int> st;\\n\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++) {\\n            st.insert(i);\\n            pq.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int n = pq.top();\\n        pq.pop();\\n        st.erase(n);\\n        return n;\\n    }\\n    \\n    void addBack(int num) {\\n        if(st.find(num) == st.end()) {\\n            pq.push(num);\\n            st.insert(num);\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue <int, vector<int>, greater<int>> pq;\\n    set<int> st;\\n\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++) {\\n            st.insert(i);\\n            pq.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int n = pq.top();\\n        pq.pop();\\n        st.erase(n);\\n        return n;\\n    }\\n    \\n    void addBack(int num) {\\n        if(st.find(num) == st.end()) {\\n            pq.push(num);\\n            st.insert(num);\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454105,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() \\n    {\\n        for(int i =1;i<=1000;i++) st.insert(i);\\n    }\\n    int popSmallest() \\n    {\\n        int a = *st.begin();\\n        st.erase(a);\\n        return a;\\n    }\\n    void addBack(int num)\\n     {\\n        st.insert(num);\\n    }\\n};\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() \\n    {\\n        for(int i =1;i<=1000;i++) st.insert(i);\\n    }\\n    int popSmallest() \\n    {\\n        int a = *st.begin();\\n        st.erase(a);\\n        return a;\\n    }\\n    void addBack(int num)\\n     {\\n        st.insert(num);\\n    }\\n};\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454080,
                "title": "easy-java-solution",
                "content": "\\n```\\nclass SmallestInfiniteSet {\\n    PriorityQueue<Integer> pq;\\n    HashSet<Integer> hs=new HashSet<>();\\n    public SmallestInfiniteSet() {\\n        pq=new PriorityQueue<>();\\n        for(int i=1;i<1001;i++){\\n            pq.add(i);\\n            hs.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        int r=pq.poll();\\n        hs.remove(r);\\n        return r;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(!hs.contains(num)){\\n            pq.add(num);\\n            hs.add(num);\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    PriorityQueue<Integer> pq;\\n    HashSet<Integer> hs=new HashSet<>();\\n    public SmallestInfiniteSet() {\\n        pq=new PriorityQueue<>();\\n        for(int i=1;i<1001;i++){\\n            pq.add(i);\\n            hs.add(i);\\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        int r=pq.poll();\\n        hs.remove(r);\\n        return r;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(!hs.contains(num)){\\n            pq.add(num);\\n            hs.add(num);\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453827,
                "title": "java-very-easy-solution",
                "content": "\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    Set<Integer> s;\\n    int min;\\n    public SmallestInfiniteSet() {\\n        s= new HashSet<>();\\n        min = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        while(s.contains(min)) min+=1;\\n        s.add(min);\\n        return min;\\n    }\\n    \\n    public void addBack(int num) {\\n        s.remove(num);\\n        if(num<min) min=num;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    Set<Integer> s;\\n    int min;\\n    public SmallestInfiniteSet() {\\n        s= new HashSet<>();\\n        min = 1;\\n    }\\n    \\n    public int popSmallest() {\\n        while(s.contains(min)) min+=1;\\n        s.add(min);\\n        return min;\\n    }\\n    \\n    public void addBack(int num) {\\n        s.remove(num);\\n        if(num<min) min=num;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453723,
                "title": "c-using-map",
                "content": "# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    map<int,int> mp;\\n    SmallestInfiniteSet() {\\n        for(int i =1;i<=1000;i++) mp[i]++;\\n    }\\n    \\n    int popSmallest() {\\n        int a = mp.begin()->first;\\n        mp.erase(a);\\n        return a;\\n    }\\n    \\n    void addBack(int num) {\\n        mp[num]++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    map<int,int> mp;\\n    SmallestInfiniteSet() {\\n        for(int i =1;i<=1000;i++) mp[i]++;\\n    }\\n    \\n    int popSmallest() {\\n        int a = mp.begin()->first;\\n        mp.erase(a);\\n        return a;\\n    }\\n    \\n    void addBack(int num) {\\n        mp[num]++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453596,
                "title": "c-ordered-set-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int>s;\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++){\\n            s.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int n=*s.begin();\\n        s.erase(*s.begin());\\n        return n;\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int>s;\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++){\\n            s.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int n=*s.begin();\\n        s.erase(*s.begin());\\n        return n;\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453506,
                "title": "my-kotlin-solution-with-time-o-nlogn-and-space-o-n",
                "content": "The idea is to keep track of the largest number that has ever been popped (denoted as `L`) and those numbers which have been popped but added back later (denoted as `S`). Then, we know the following invariants:\\n\\n1. All numbers that are greater than `L` have not been popped;\\n2. All elements in `S` will not be greater than `L` since `L` is the largest number that has ever been popped;\\n\\nNow, suppose we call the `popSmallest` function. if `S` is not empty, then we should pop the smallest number in `S`; otherwise, we should pop the number after `L`. \\n\\nFor the `addBack` function, we know `num` is not popped if it is greater than `L` or it is already in `S`. If this is the case, we do nothing; otherwise, we add it to `S`.\\n\\nWe can store `L` using a variable and `S` using a `SortedSet`. \\n\\nBelow is my solution in kotlin,\\n```\\nclass SmallestInfiniteSet() {\\n\\n    private var maxEverPopped = 0\\n    private var sortedAddedBack = sortedSetOf<Int>()\\n\\n    /* Complexity for N calls:\\n     * Time O(NLogN) and Space O(1);\\n     */\\n    fun popSmallest(): Int {\\n        return if (sortedAddedBack.isEmpty()) {\\n            maxEverPopped++\\n            maxEverPopped\\n        } else {\\n            checkNotNull(sortedAddedBack.pollFirst())\\n        }\\n    }\\n\\n    /* Complexity for N calls:\\n     * Time O(NLogN) and Space O(N);\\n     */\\n    fun addBack(num: Int) {\\n        val isPopped = num <= maxEverPopped && num !in sortedAddedBack\\n        if (isPopped) {\\n            sortedAddedBack.add(num)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass SmallestInfiniteSet() {\\n\\n    private var maxEverPopped = 0\\n    private var sortedAddedBack = sortedSetOf<Int>()\\n\\n    /* Complexity for N calls:\\n     * Time O(NLogN) and Space O(1);\\n     */\\n    fun popSmallest(): Int {\\n        return if (sortedAddedBack.isEmpty()) {\\n            maxEverPopped++\\n            maxEverPopped\\n        } else {\\n            checkNotNull(sortedAddedBack.pollFirst())\\n        }\\n    }\\n\\n    /* Complexity for N calls:\\n     * Time O(NLogN) and Space O(N);\\n     */\\n    fun addBack(num: Int) {\\n        val isPopped = num <= maxEverPopped && num !in sortedAddedBack\\n        if (isPopped) {\\n            sortedAddedBack.add(num)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453351,
                "title": "easy-c-solution-beat-100",
                "content": "\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n bool a[1001];\\n    SmallestInfiniteSet() {\\n       \\n        for(int i=1;i<1001;i++){\\n            a[i]=1;\\n        }\\n    }\\n    int popSmallest() {\\n        int i=1;\\n        while(a[i]!=1)\\n        i++;\\n        a[i]=0;\\n        return i;\\n    }\\n    void addBack(int num) {\\n        a[num]=1;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n bool a[1001];\\n    SmallestInfiniteSet() {\\n       \\n        for(int i=1;i<1001;i++){\\n            a[i]=1;\\n        }\\n    }\\n    int popSmallest() {\\n        int i=1;\\n        while(a[i]!=1)\\n        i++;\\n        a[i]=0;\\n        return i;\\n    }\\n    void addBack(int num) {\\n        a[num]=1;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 3453303,
                "title": "java-easiest-solution-using-treeset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\nTreeSet<Integer> ts= new TreeSet<>();\\n    public SmallestInfiniteSet() {\\n       for(int i=1;i<=1000;i++){\\n           ts.add(i);\\n       }\\n        \\n    }\\n    \\n    public int popSmallest() {\\n        int ans=0;\\n       if(!ts.isEmpty()){\\n           ans=ts.first();\\n           \\n       }\\n       ts.remove(ans);\\n       return ans;\\n\\n        \\n    }\\n    \\n    public void addBack(int num) {\\n    if(!ts.contains(num)){\\n        ts.add(num);\\n    }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\nTreeSet<Integer> ts= new TreeSet<>();\\n    public SmallestInfiniteSet() {\\n       for(int i=1;i<=1000;i++){\\n           ts.add(i);\\n       }\\n        \\n    }\\n    \\n    public int popSmallest() {\\n        int ans=0;\\n       if(!ts.isEmpty()){\\n           ans=ts.first();\\n           \\n       }\\n       ts.remove(ans);\\n       return ans;\\n\\n        \\n    }\\n    \\n    public void addBack(int num) {\\n    if(!ts.contains(num)){\\n        ts.add(num);\\n    }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453300,
                "title": "java-heap",
                "content": "```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> available = new HashSet<>();\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    int small = 1;\\n    \\n    public SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    public int popSmallest() {\\n        int ans ;\\n        if(pq.size() != 0){\\n            ans = pq.poll();\\n            available.remove(ans);\\n        }else{\\n            ans = small;\\n            small++;\\n        }\\n        return ans;\\n    }\\n    \\n    public void addBack(int num) {\\n        if( small <= num || available.contains(num))\\n            return;\\n        available.add(num);\\n        pq.add(num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> available = new HashSet<>();\\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\\n    int small = 1;\\n    \\n    public SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    public int popSmallest() {\\n        int ans ;\\n        if(pq.size() != 0){\\n            ans = pq.poll();\\n            available.remove(ans);\\n        }else{\\n            ans = small;\\n            small++;\\n        }\\n        return ans;\\n    }\\n    \\n    public void addBack(int num) {\\n        if( small <= num || available.contains(num))\\n            return;\\n        available.add(num);\\n        pq.add(num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453202,
                "title": "map-approach-c-code-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    map<int,int> mp;\\n    SmallestInfiniteSet() {\\n        for(int i =1;i<=1000;i++) mp[i]++;\\n    }\\n    \\n    int popSmallest() {\\n        int a = mp.begin()->first;\\n        mp.erase(a);\\n        return a;\\n    }\\n    \\n    void addBack(int num) {\\n        mp[num]++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    map<int,int> mp;\\n    SmallestInfiniteSet() {\\n        for(int i =1;i<=1000;i++) mp[i]++;\\n    }\\n    \\n    int popSmallest() {\\n        int a = mp.begin()->first;\\n        mp.erase(a);\\n        return a;\\n    }\\n    \\n    void addBack(int num) {\\n        mp[num]++;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453200,
                "title": "simple-approach-using-vector-c",
                "content": "\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    vector<int> v;\\n    SmallestInfiniteSet() {\\n        v.resize(1001, 1);\\n    }\\n    int popSmallest() {\\n        for(int i=1; i<1001; i++){\\n            if(v[i]==1){\\n                v[i]=0;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(v[num]==0) v[num]=1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    vector<int> v;\\n    SmallestInfiniteSet() {\\n        v.resize(1001, 1);\\n    }\\n    int popSmallest() {\\n        for(int i=1; i<1001; i++){\\n            if(v[i]==1){\\n                v[i]=0;\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(v[num]==0) v[num]=1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453145,
                "title": "2336-smallest-number-in-infinite-set-java",
                "content": "```\\nclass SmallestInfiniteSet {\\n\\n    PriorityQueue<Integer> pq=new PriorityQueue();\\n    int min=1;\\n    public SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    public int popSmallest() {\\n        if(!pq.isEmpty())\\n            return pq.poll();\\n        else\\n        {\\n            min++;\\n            return min-1;\\n        }\\n        \\n    }\\n    \\n    public void addBack(int num) {\\n        if(min>num&&!pq.contains(num))\\n            pq.offer(num);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n\\n    PriorityQueue<Integer> pq=new PriorityQueue();\\n    int min=1;\\n    public SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    public int popSmallest() {\\n        if(!pq.isEmpty())\\n            return pq.poll();\\n        else\\n        {\\n            min++;\\n            return min-1;\\n        }\\n        \\n    }\\n    \\n    public void addBack(int num) {\\n        if(min>num&&!pq.contains(num))\\n            pq.offer(num);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453117,
                "title": "c-code-solution-heap",
                "content": "```\\ntypedef struct {\\n    int top;\\n    int size;\\n    int heap[1008];\\n} SmallestInfiniteSet;\\n\\nvoid pushHeap(int *arr, int size, int new) {\\n    int i = size, tmp, next;\\n    arr[i] = new;\\n    while (i > 0) {\\n        next = (i - 1) / 2;\\n        if (arr[i] < arr[ next ]) {\\n            tmp = arr[i];\\n            arr[i] = arr[ next ];\\n            arr[ next ] = tmp;\\n            i = next;\\n        }\\n        else {\\n            return ;\\n        }\\n    }\\n    return ;\\n}\\nvoid popHeap(int *arr, int size) {\\n    int i = 0, next, end = size - 1, tmp;\\n    arr[0] = arr[size - 1];\\n    while (i * 2 + 1 < end) {\\n        if (i * 2 + 2 < end) {\\n            next = (arr[i * 2 + 1] < arr[i * 2 + 2]) ? i * 2 + 1 : i * 2 + 2;\\n            if (arr[i] > arr[next]) {\\n                tmp = arr[i];\\n                arr[i] = arr[next];\\n                arr[next] = tmp;\\n                i = next;\\n            }\\n            else {\\n                return ;\\n            }\\n        }\\n        else if (i * 2 + 1 < end) {\\n            next = i * 2 + 1;\\n            if (arr[i] > arr[next]) {\\n                tmp = arr[i];\\n                arr[i] = arr[next];\\n                arr[next] = tmp;\\n                i = next;\\n            }\\n            else {\\n                return ;\\n            }\\n        }\\n    }\\n    return ;\\n}\\n\\nSmallestInfiniteSet* smallestInfiniteSetCreate() {\\n    SmallestInfiniteSet *obj = (SmallestInfiniteSet *)malloc(sizeof(SmallestInfiniteSet));\\n    bzero(obj, sizeof(SmallestInfiniteSet));\\n    obj->top = 1;\\n    return obj;\\n}\\n\\nint smallestInfiniteSetPopSmallest(SmallestInfiniteSet* obj) {\\n    int ans;\\n    if (obj->size) {\\n        ans = obj->heap[0];\\n        popHeap(obj->heap, obj->size);\\n        obj->size --;\\n        while (obj->size && obj->heap[0] == ans) {\\n            popHeap(obj->heap, obj->size);\\n            obj->size --;\\n        }\\n    }\\n    else {\\n        ans = obj->top;\\n        obj->top ++;\\n    }\\n    return ans;\\n}\\n\\nvoid smallestInfiniteSetAddBack(SmallestInfiniteSet* obj, int num) {\\n    if (obj->top <= num) {\\n        return ;\\n    }\\n    else {\\n        pushHeap(obj->heap, obj->size, num);\\n        obj->size ++;\\n    }\\n    return ;\\n}\\n\\nvoid smallestInfiniteSetFree(SmallestInfiniteSet* obj) {\\n    free(obj);\\n    return;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    int top;\\n    int size;\\n    int heap[1008];\\n} SmallestInfiniteSet;\\n\\nvoid pushHeap(int *arr, int size, int new) {\\n    int i = size, tmp, next;\\n    arr[i] = new;\\n    while (i > 0) {\\n        next = (i - 1) / 2;\\n        if (arr[i] < arr[ next ]) {\\n            tmp = arr[i];\\n            arr[i] = arr[ next ];\\n            arr[ next ] = tmp;\\n            i = next;\\n        }\\n        else {\\n            return ;\\n        }\\n    }\\n    return ;\\n}\\nvoid popHeap(int *arr, int size) {\\n    int i = 0, next, end = size - 1, tmp;\\n    arr[0] = arr[size - 1];\\n    while (i * 2 + 1 < end) {\\n        if (i * 2 + 2 < end) {\\n            next = (arr[i * 2 + 1] < arr[i * 2 + 2]) ? i * 2 + 1 : i * 2 + 2;\\n            if (arr[i] > arr[next]) {\\n                tmp = arr[i];\\n                arr[i] = arr[next];\\n                arr[next] = tmp;\\n                i = next;\\n            }\\n            else {\\n                return ;\\n            }\\n        }\\n        else if (i * 2 + 1 < end) {\\n            next = i * 2 + 1;\\n            if (arr[i] > arr[next]) {\\n                tmp = arr[i];\\n                arr[i] = arr[next];\\n                arr[next] = tmp;\\n                i = next;\\n            }\\n            else {\\n                return ;\\n            }\\n        }\\n    }\\n    return ;\\n}\\n\\nSmallestInfiniteSet* smallestInfiniteSetCreate() {\\n    SmallestInfiniteSet *obj = (SmallestInfiniteSet *)malloc(sizeof(SmallestInfiniteSet));\\n    bzero(obj, sizeof(SmallestInfiniteSet));\\n    obj->top = 1;\\n    return obj;\\n}\\n\\nint smallestInfiniteSetPopSmallest(SmallestInfiniteSet* obj) {\\n    int ans;\\n    if (obj->size) {\\n        ans = obj->heap[0];\\n        popHeap(obj->heap, obj->size);\\n        obj->size --;\\n        while (obj->size && obj->heap[0] == ans) {\\n            popHeap(obj->heap, obj->size);\\n            obj->size --;\\n        }\\n    }\\n    else {\\n        ans = obj->top;\\n        obj->top ++;\\n    }\\n    return ans;\\n}\\n\\nvoid smallestInfiniteSetAddBack(SmallestInfiniteSet* obj, int num) {\\n    if (obj->top <= num) {\\n        return ;\\n    }\\n    else {\\n        pushHeap(obj->heap, obj->size, num);\\n        obj->size ++;\\n    }\\n    return ;\\n}\\n\\nvoid smallestInfiniteSetFree(SmallestInfiniteSet* obj) {\\n    free(obj);\\n    return;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3453093,
                "title": "best-optimal-python-solution",
                "content": "# Intuition\\nPlease UPVOTE\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\n\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.min_num = 1\\n        self.heap = []\\n\\n    def popSmallest(self) -> int:\\n        if self.heap:\\n            return heapq.heappop(self.heap)\\n        self.min_num += 1\\n        return self.min_num - 1\\n\\n    def addBack(self, num: int) -> None:\\n        if self.min_num > num and num not in self.heap:\\n            heapq.heappush(self.heap, num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.min_num = 1\\n        self.heap = []\\n\\n    def popSmallest(self) -> int:\\n        if self.heap:\\n            return heapq.heappop(self.heap)\\n        self.min_num += 1\\n        return self.min_num - 1\\n\\n    def addBack(self, num: int) -> None:\\n        if self.min_num > num and num not in self.heap:\\n            heapq.heappush(self.heap, num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453061,
                "title": "python-elegant-short-heap",
                "content": "# Complexity\\n- Time complexity: \\n        creation - $$O(1)$$\\n        **popSmallest** and **addBack** - $$O(\\\\log_{2} n)$$\\n\\n- Space complexity:\\n        creation - $$O(1)$$, increases with calls **addBack**\\n        **popSmallest** and **addBack** - $$O(1)$$\\n\\n# Code\\n```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.heap = []\\n        self.nums = set()\\n        self.smallest = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.heap:\\n            sm = heappop(self.heap)\\n            self.nums.remove(sm)\\n            return sm\\n        else:\\n            sm = self.smallest\\n            self.smallest += 1\\n            return sm\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.smallest and num not in self.heap:\\n            heappush(self.heap, num)\\n            self.nums.add(num)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.heap = []\\n        self.nums = set()\\n        self.smallest = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.heap:\\n            sm = heappop(self.heap)\\n            self.nums.remove(sm)\\n            return sm\\n        else:\\n            sm = self.smallest\\n            self.smallest += 1\\n            return sm\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.smallest and num not in self.heap:\\n            heappush(self.heap, num)\\n            self.nums.add(num)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453057,
                "title": "java-beats-100-easy-to-understand",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : PriorityQueue\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlog n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass SmallestInfiniteSet {\\n\\n    PriorityQueue<Integer> q ;\\n    int minVal;\\n    public SmallestInfiniteSet() {\\n        q = new PriorityQueue<>();\\n        minVal = 1;\\n    }\\n    \\n    public int popSmallest() {\\n\\n        if(!q.isEmpty())    return q.poll();\\n        minVal++;\\n        return minVal -1;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(minVal > num && !q.contains(num))    q.offer(num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```\\n```\\nIf you like please UpVote solution\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java []\\nclass SmallestInfiniteSet {\\n\\n    PriorityQueue<Integer> q ;\\n    int minVal;\\n    public SmallestInfiniteSet() {\\n        q = new PriorityQueue<>();\\n        minVal = 1;\\n    }\\n    \\n    public int popSmallest() {\\n\\n        if(!q.isEmpty())    return q.poll();\\n        minVal++;\\n        return minVal -1;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(minVal > num && !q.contains(num))    q.offer(num);\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```\n```\\nIf you like please UpVote solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452880,
                "title": "100-beginners-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nadd 1 to 1000 in set and priority queue\\n\\npriority queue will pop the smallest number\\nthen we remove the number from set too\\n\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> set;\\n    PriorityQueue<Integer> pq;\\n\\n    public SmallestInfiniteSet() {\\n        set=new HashSet<>(1000);\\n        pq=new PriorityQueue<>(1000);\\n        for(int i=1;i<=1000;i++){\\n          pq.add(i);\\n          set.add(i); \\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        int val= pq.poll();\\n        set.remove( val);\\n\\n        return val;\\n        \\n    }\\n    \\n    public void addBack(int num) {\\n        if(!set.contains(num)){\\n            set.add(num);\\n            pq.add(num);\\n        }\\n        \\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> set;\\n    PriorityQueue<Integer> pq;\\n\\n    public SmallestInfiniteSet() {\\n        set=new HashSet<>(1000);\\n        pq=new PriorityQueue<>(1000);\\n        for(int i=1;i<=1000;i++){\\n          pq.add(i);\\n          set.add(i); \\n        }\\n    }\\n    \\n    public int popSmallest() {\\n        int val= pq.poll();\\n        set.remove( val);\\n\\n        return val;\\n        \\n    }\\n    \\n    public void addBack(int num) {\\n        if(!set.contains(num)){\\n            set.add(num);\\n            pq.add(num);\\n        }\\n        \\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452810,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    int count=1;\\n    unordered_map<int,int> hash;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        int temp=count;\\n        count++;\\n        while(hash.find(count)!=hash.end())\\n            count++;\\n        hash[temp]++;\\n        return temp;\\n    }\\n    \\n    void addBack(int num) {\\n        if(hash.find(num)!=hash.end())\\n        {\\n            hash.erase(num);\\n            if(count>num) count=num;\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    int count=1;\\n    unordered_map<int,int> hash;\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        int temp=count;\\n        count++;\\n        while(hash.find(count)!=hash.end())\\n            count++;\\n        hash[temp]++;\\n        return temp;\\n    }\\n    \\n    void addBack(int num) {\\n        if(hash.find(num)!=hash.end())\\n        {\\n            hash.erase(num);\\n            if(count>num) count=num;\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452729,
                "title": "set-and-heap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int,vector<int>, greater<>> pq;\\n    unordered_set<int> s; \\n    SmallestInfiniteSet() \\n    {\\n        for(int i = 1; i<=1000;i++)\\n        {\\n        pq.push(i);\\n        s.insert(i);\\n\\n        }\\n        \\n    }\\n    \\n    int popSmallest() \\n    {\\n        int x =  pq.top();\\n        s.erase(pq.top());\\n        pq.pop();\\n        return x;\\n        \\n    }\\n    \\n    void addBack(int num) \\n    {   if(s.find(num)==s.end())\\n    {\\n\\n        pq.push(num);\\n        s.insert(num);\\n    }\\n        \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int,vector<int>, greater<>> pq;\\n    unordered_set<int> s; \\n    SmallestInfiniteSet() \\n    {\\n        for(int i = 1; i<=1000;i++)\\n        {\\n        pq.push(i);\\n        s.insert(i);\\n\\n        }\\n        \\n    }\\n    \\n    int popSmallest() \\n    {\\n        int x =  pq.top();\\n        s.erase(pq.top());\\n        pq.pop();\\n        return x;\\n        \\n    }\\n    \\n    void addBack(int num) \\n    {   if(s.find(num)==s.end())\\n    {\\n\\n        pq.push(num);\\n        s.insert(num);\\n    }\\n        \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452665,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++){\\n            st.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int t = *(st.begin());\\n        st.erase(t);\\n        return t;\\n    }\\n    \\n    void addBack(int num) {\\n        if(st.find(num) == st.end()){\\n            st.insert(num);\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> st;\\n    SmallestInfiniteSet() {\\n        for(int i=1;i<=1000;i++){\\n            st.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int t = *(st.begin());\\n        st.erase(t);\\n        return t;\\n    }\\n    \\n    void addBack(int num) {\\n        if(st.find(num) == st.end()){\\n            st.insert(num);\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452569,
                "title": "c-priority-queue-faster-easy-to-understand",
                "content": "* ***Priority Queue***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    \\n    // declare a min heap\\n    \\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    \\n    // declare a unordered set\\n    \\n    unordered_set<int> s;\\n    \\n    SmallestInfiniteSet() {\\n        \\n        // insert numbers into pq and set\\n        \\n        for(int i = 1; i <= 1005; i++)\\n        {\\n            pq.push(i);\\n            \\n            s.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(pq.size())\\n        {\\n            int x = pq.top();\\n            \\n            // erase from set\\n            \\n            s.erase(x);\\n            \\n            pq.pop();\\n            \\n            return x;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        \\n        // if not present in set\\n        \\n        if(s.count(num) == 0)\\n        {\\n            s.insert(num);\\n            \\n            pq.push(num);\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    \\n    // declare a min heap\\n    \\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    \\n    // declare a unordered set\\n    \\n    unordered_set<int> s;\\n    \\n    SmallestInfiniteSet() {\\n        \\n        // insert numbers into pq and set\\n        \\n        for(int i = 1; i <= 1005; i++)\\n        {\\n            pq.push(i);\\n            \\n            s.insert(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(pq.size())\\n        {\\n            int x = pq.top();\\n            \\n            // erase from set\\n            \\n            s.erase(x);\\n            \\n            pq.pop();\\n            \\n            return x;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        \\n        // if not present in set\\n        \\n        if(s.count(num) == 0)\\n        {\\n            s.insert(num);\\n            \\n            pq.push(num);\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452558,
                "title": "simple-c-intuitive-85-beats",
                "content": "# Intuition\\nUse priority_queue (min heap) for popping min element.\\n\\n# Approach\\nStoring an array with all elements = 1;\\nIf any ith element gets popped changing the ith index to 0, \\n\\n1 --> Signifies Element is present.\\n0-->Signifies  Element is not present.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>>pq;\\n    int store[1001];  // all ele initilased to 0\\n\\n    SmallestInfiniteSet() {\\n        \\n        for(int i=1;i<=1000;i++)\\n        {\\n            pq.push(i);\\n            store[i]=1; // 1 signifies ele is present\\n        }\\n     \\n    }\\n    \\n    int popSmallest() {\\n       int ele=pq.top();\\n        pq.pop();\\n        store[ele]=0; //0 signifies ele nahi hai kyuki mene pop kiya\\n\\n        return ele;\\n        \\n    }\\n    \\n    void addBack(int num) {\\n        if(store[num]==1)\\n        return;\\n\\n        else // store[num]==0 , matlab number nhi hai\\n        {\\n            store[num]=1;\\n            pq.push(num);\\n        }\\n       \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>>pq;\\n    int store[1001];  // all ele initilased to 0\\n\\n    SmallestInfiniteSet() {\\n        \\n        for(int i=1;i<=1000;i++)\\n        {\\n            pq.push(i);\\n            store[i]=1; // 1 signifies ele is present\\n        }\\n     \\n    }\\n    \\n    int popSmallest() {\\n       int ele=pq.top();\\n        pq.pop();\\n        store[ele]=0; //0 signifies ele nahi hai kyuki mene pop kiya\\n\\n        return ele;\\n        \\n    }\\n    \\n    void addBack(int num) {\\n        if(store[num]==1)\\n        return;\\n\\n        else // store[num]==0 , matlab number nhi hai\\n        {\\n            store[num]=1;\\n            pq.push(num);\\n        }\\n       \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452525,
                "title": "100-easy-c-solution-have-a-look-and-judge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing unordered map and iterating from beginning.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize an unordered map and in the constructor intialize the set from 1 to 1000(according to the given constraint). For popSmallest function, start a loop from 1 onwards and if one is present in the map then erase 1 and break the loop and return the answer which is 1.\\nIf one is not present in the map then it will check whether 2 is present in the map or not. Likewise it will keeps going on. \\nfor addBack function, Check if the num is already present or not. If not then just add it to the map.\\n\\n# Complexity\\n- Time complexity: O(k), k = 1000\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k), k = 1000\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    unordered_map<int, bool> mp;\\n    SmallestInfiniteSet() {\\n        for (int i = 1; i<=1000; i++){\\n            mp[i] = true;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int ans = 0;\\n        for (int i = 1; i<=1000; i++){\\n            if (mp.find(i) != mp.end()){\\n                ans = i;\\n                mp.erase(i);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void addBack(int num) {\\n        if (mp.find(num) == mp.end()){\\n            mp[num] = true;\\n        }\\n    }\\n};\\n\\n\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    unordered_map<int, bool> mp;\\n    SmallestInfiniteSet() {\\n        for (int i = 1; i<=1000; i++){\\n            mp[i] = true;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int ans = 0;\\n        for (int i = 1; i<=1000; i++){\\n            if (mp.find(i) != mp.end()){\\n                ans = i;\\n                mp.erase(i);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void addBack(int num) {\\n        if (mp.find(num) == mp.end()){\\n            mp[num] = true;\\n        }\\n    }\\n};\\n\\n\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452510,
                "title": "zero-iq-solution-really-infinite-big-very-much",
                "content": "![image.png](https://assets.leetcode.com/users/images/7acd1d85-74ee-4cf0-9890-f6e456aaf5f4_1682395910.6840515.png)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nQuesion says it infinite\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou type infnite\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWHAT?\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nInfinite.\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    set<int> st;\\npublic:\\n    SmallestInfiniteSet() {\\n        st={1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000};\\n\\n    }\\n    \\n    int popSmallest() {\\n        int smol = *st.begin();\\n        st.erase(smol);\\n        return  smol;\\n        \\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);        \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    set<int> st;\\npublic:\\n    SmallestInfiniteSet() {\\n        st={1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000};\\n\\n    }\\n    \\n    int popSmallest() {\\n        int smol = *st.begin();\\n        st.erase(smol);\\n        return  smol;\\n        \\n    }\\n    \\n    void addBack(int num) {\\n        st.insert(num);        \\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452498,
                "title": "88-faster-java",
                "content": "# Approach\\nCreated boolean array of size `1000` to store whether index is present or popped, when it is popped mark as false, if it is inserted mark it as true\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n\\n    boolean[] nums = new boolean[1001];\\n    int low = 1;\\n\\n    public SmallestInfiniteSet() {\\n        // initialize all to true\\n        for(int i=0; i< 1001; i++) nums[i] = true;\\n    }\\n    \\n    public int popSmallest() {\\n\\n        // mark lower as popped\\n        nums[low] = false;\\n        int t = low++;\\n\\n        // move to next smaller untill it is present\\n        while(low < nums.length - 1 && !nums[low]) low++;\\n        return t;\\n    }\\n    \\n    public void addBack(int num) {\\n\\n        // store num in low if it is smaller\\n        if(num < low) {\\n            low = num;\\n        }\\n\\n        // num marked as present\\n        nums[num] = true;\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n\\n    boolean[] nums = new boolean[1001];\\n    int low = 1;\\n\\n    public SmallestInfiniteSet() {\\n        // initialize all to true\\n        for(int i=0; i< 1001; i++) nums[i] = true;\\n    }\\n    \\n    public int popSmallest() {\\n\\n        // mark lower as popped\\n        nums[low] = false;\\n        int t = low++;\\n\\n        // move to next smaller untill it is present\\n        while(low < nums.length - 1 && !nums[low]) low++;\\n        return t;\\n    }\\n    \\n    public void addBack(int num) {\\n\\n        // store num in low if it is smaller\\n        if(num < low) {\\n            low = num;\\n        }\\n\\n        // num marked as present\\n        nums[num] = true;\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452493,
                "title": "mean-heap-easy-c-solution",
                "content": "# Intuition:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- In constructor just push first 1000 elements in mean heap and hash table.\\n- In popSmallest, the element on the top of mean heap is our answer so return it by removing it from the hash table.\\n- In addBack, if the num is not present in the map we can push it into the heap and map it in hash table, if its not present then continue.\\n\\n# Complexity:\\n- Time complexity: Input list items<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: List space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    unordered_map<int, int> mp;\\n\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++){\\n            pq.push(i);\\n            mp[i]++;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int ans= pq.top();\\n        pq.pop();\\n\\n        mp.erase(ans);\\n        return ans;     \\n    }\\n    \\n    void addBack(int num) {\\n        if(!mp.count(num)){\\n            pq.push(num);\\n            mp[num]++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    unordered_map<int, int> mp;\\n\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<=1000; i++){\\n            pq.push(i);\\n            mp[i]++;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int ans= pq.top();\\n        pq.pop();\\n\\n        mp.erase(ans);\\n        return ans;     \\n    }\\n    \\n    void addBack(int num) {\\n        if(!mp.count(num)){\\n            pq.push(num);\\n            mp[num]++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452490,
                "title": "easy-java-solution-using-hashset-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> set;   // set that will conatins any removed element\\n    int min = 1;    // min element in non-removed universal set\\n    public SmallestInfiniteSet() {\\n        set = new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        while(set.contains(min)) min++;        \\n        set.add(min);\\n        return min;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(set.contains(num)){\\n            min = Math.min(num,min);\\n            set.remove(num);\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    HashSet<Integer> set;   // set that will conatins any removed element\\n    int min = 1;    // min element in non-removed universal set\\n    public SmallestInfiniteSet() {\\n        set = new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        while(set.contains(min)) min++;        \\n        set.add(min);\\n        return min;\\n    }\\n    \\n    public void addBack(int num) {\\n        if(set.contains(num)){\\n            min = Math.min(num,min);\\n            set.remove(num);\\n        }\\n    }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452451,
                "title": "easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int>s;\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<1005; i++)\\n        s.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int top = *s.begin();\\n        s.erase(s.begin());\\n        return top;\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int>s;\\n    SmallestInfiniteSet() {\\n        for(int i=1; i<1005; i++)\\n        s.insert(i);\\n    }\\n    \\n    int popSmallest() {\\n        int top = *s.begin();\\n        s.erase(s.begin());\\n        return top;\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452409,
                "title": "rust-horizon-ordered-set-11ms",
                "content": "# Approach\\nIf we assume the set contains all numbers from 1 to infinity, and can only pop the smallest, then we can maintain a horizon for the next smallest number that can be popped. \\n\\nTo keep track of what numbers have been added back in, an ordered set is used. On the next pop operation, this set is checked to see if it has any items to pop; if so, pop one and return it. If not, the horizon is moved and the next number returned.\\n\\n# Complexity\\n- Time: \\n    - `pop_smallest()`: $O(log(n))$ \\n    - `add_back()`: $O(log(n))$\\n- Space: $O(n)$\\n\\n# Code\\n```rust\\nuse std::collections::BTreeSet;\\n\\nstruct SmallestInfiniteSet {\\n    added: BTreeSet<i32>,\\n    horiz: i32,\\n}\\n\\nimpl SmallestInfiniteSet {\\n\\n    fn new() -> Self {\\n        Self { added: BTreeSet::new(), horiz: 1 }\\n    }\\n    \\n    fn pop_smallest(&mut self) -> i32 {\\n        match self.added.iter().copied().next() {\\n            Some(n) => {\\n                self.added.remove(&n);\\n                n\\n            },\\n            _ => {\\n                self.horiz += 1;\\n                self.horiz - 1\\n            }\\n        }\\n    }\\n    \\n    fn add_back(&mut self, num: i32) {\\n        if num < self.horiz {\\n            self.added.insert(num);\\n        }\\n    }\\n}\\n```\\n\\n# Using a Bit Field as Ordered Set\\n\\nA bit field could be used as the ordered set. The code is more complex and gets about the same performance as the above solution despite the better space and time complexity.\\n\\n# Complexity\\n- Time: \\n    - pop_smallest() - $O(1)$ \\n        - This method\\'s approach to finding the next value is cache efficient due to the small memory footprint.\\n    - add_back - $O(1)$\\n- Space: $O(1)$ This solution takes only a constant 140 bytes.\\n\\n# Code\\n```rust\\ntype CellType = u64;\\n\\nconst N_BITS  : usize = std::mem::size_of::<CellType>() * 8;\\nconst N_CELLS : usize = (NUM_MAX as usize + N_BITS - 1) / N_BITS;\\nconst NUM_MAX : i32   = 1000;\\n\\nstruct SmallestInfiniteSet {\\n    added: [CellType; N_CELLS], // 128 bytes.\\n    range: (i32, i32),\\n    horiz: i32,\\n}\\n\\nimpl SmallestInfiniteSet {\\n\\n    fn new() -> Self {\\n        Self { \\n            added: [0; N_CELLS], \\n            range: (i32::MAX, 0), \\n            horiz: 1 \\n        }\\n    }\\n    \\n    fn pop_smallest(&mut self) -> i32 {\\n        if self.range.0 != i32::MAX {\\n            // If `num` comes from the ordered set, remove it. Then set\\n            // `range.0` to the next smallest number in `added`.\\n            let num = self.range.0;\\n            let mut offset = num as usize / N_BITS;\\n\\n            self.added[offset] &= !(1 << num as usize % N_BITS);\\n\\n            if self.range.0 != self.range.1 {\\n                while self.added[offset] == 0 { offset += 1; }\\n\\n                self.range.0 = (offset * N_BITS) as i32 \\n                             + self.added[offset].trailing_zeros() as i32;\\n            } else {\\n                self.range = (i32::MAX, 0);\\n            }\\n            num\\n        } else {\\n            // If `num` comes from `horiz`, increment `horiz`.\\n            self.horiz += 1;\\n            self.horiz - 1\\n        }\\n    }\\n    \\n    fn add_back(&mut self, num: i32) {\\n        if num < self.horiz {\\n            self.added[num as usize / N_BITS] |= 1 << num as usize % N_BITS;\\n            self.range = (self.range.0.min(num), self.range.1.max(num));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation",
                    "Ordered Set"
                ],
                "code": "```rust\\nuse std::collections::BTreeSet;\\n\\nstruct SmallestInfiniteSet {\\n    added: BTreeSet<i32>,\\n    horiz: i32,\\n}\\n\\nimpl SmallestInfiniteSet {\\n\\n    fn new() -> Self {\\n        Self { added: BTreeSet::new(), horiz: 1 }\\n    }\\n    \\n    fn pop_smallest(&mut self) -> i32 {\\n        match self.added.iter().copied().next() {\\n            Some(n) => {\\n                self.added.remove(&n);\\n                n\\n            },\\n            _ => {\\n                self.horiz += 1;\\n                self.horiz - 1\\n            }\\n        }\\n    }\\n    \\n    fn add_back(&mut self, num: i32) {\\n        if num < self.horiz {\\n            self.added.insert(num);\\n        }\\n    }\\n}\\n```\n```rust\\ntype CellType = u64;\\n\\nconst N_BITS  : usize = std::mem::size_of::<CellType>() * 8;\\nconst N_CELLS : usize = (NUM_MAX as usize + N_BITS - 1) / N_BITS;\\nconst NUM_MAX : i32   = 1000;\\n\\nstruct SmallestInfiniteSet {\\n    added: [CellType; N_CELLS], // 128 bytes.\\n    range: (i32, i32),\\n    horiz: i32,\\n}\\n\\nimpl SmallestInfiniteSet {\\n\\n    fn new() -> Self {\\n        Self { \\n            added: [0; N_CELLS], \\n            range: (i32::MAX, 0), \\n            horiz: 1 \\n        }\\n    }\\n    \\n    fn pop_smallest(&mut self) -> i32 {\\n        if self.range.0 != i32::MAX {\\n            // If `num` comes from the ordered set, remove it. Then set\\n            // `range.0` to the next smallest number in `added`.\\n            let num = self.range.0;\\n            let mut offset = num as usize / N_BITS;\\n\\n            self.added[offset] &= !(1 << num as usize % N_BITS);\\n\\n            if self.range.0 != self.range.1 {\\n                while self.added[offset] == 0 { offset += 1; }\\n\\n                self.range.0 = (offset * N_BITS) as i32 \\n                             + self.added[offset].trailing_zeros() as i32;\\n            } else {\\n                self.range = (i32::MAX, 0);\\n            }\\n            num\\n        } else {\\n            // If `num` comes from `horiz`, increment `horiz`.\\n            self.horiz += 1;\\n            self.horiz - 1\\n        }\\n    }\\n    \\n    fn add_back(&mut self, num: i32) {\\n        if num < self.horiz {\\n            self.added[num as usize / N_BITS] |= 1 << num as usize % N_BITS;\\n            self.range = (self.range.0.min(num), self.range.1.max(num));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3452373,
                "title": "python3-heap",
                "content": "# Intuition\\nMaintain a counter, use a heap for anything smaller than the counter\\n\\n# Code\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.m = 1\\n        self.h = []\\n\\n    def popSmallest(self) -> int:\\n        if self.h:\\n            x = self.h[0]\\n            while self.h and x == self.h[0]:\\n                heappop(self.h)\\n            return x\\n        else:\\n            self.m += 1\\n            return self.m - 1\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.m:\\n            heappush(self.h, num)\\n       \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.m = 1\\n        self.h = []\\n\\n    def popSmallest(self) -> int:\\n        if self.h:\\n            x = self.h[0]\\n            while self.h and x == self.h[0]:\\n                heappop(self.h)\\n            return x\\n        else:\\n            self.m += 1\\n            return self.m - 1\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.m:\\n            heappush(self.h, num)\\n       \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452343,
                "title": "python3-beats-95-5-and-99-45-quibler7",
                "content": "![Screenshot 2023-04-25 at 8.29.50 AM.png](https://assets.leetcode.com/users/images/64fc7c75-034e-447b-807e-a4ef5e6e3a70_1682391604.414772.png)\\n# Code\\n```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.curr = 1\\n        self.set = set()\\n\\n    def popSmallest(self) -> int:\\n        if self.set:\\n            ans = min(self.set)\\n            self.set.remove(ans)\\n            return ans\\n        else: \\n            self.curr += 1\\n            return self.curr -1\\n\\n    def addBack(self, num: int) -> None:\\n        if self.curr > num:\\n            self.set.add(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.curr = 1\\n        self.set = set()\\n\\n    def popSmallest(self) -> int:\\n        if self.set:\\n            ans = min(self.set)\\n            self.set.remove(ans)\\n            return ans\\n        else: \\n            self.curr += 1\\n            return self.curr -1\\n\\n    def addBack(self, num: int) -> None:\\n        if self.curr > num:\\n            self.set.add(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452319,
                "title": "c-2-approach-priority-queue-map-and-set-optimized",
                "content": "# **approach - 1 =>  map + priority queue**\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n\\n    priority_queue<int, vector<int>, greater<int> > pq;\\n    vector<int> v;\\n\\n\\n    SmallestInfiniteSet() {\\n        v.push_back(1);\\n        for(int i=1; i<=1000; i++)   {\\n            pq.push(i);\\n            v.push_back(1);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int x = pq.top();\\n        pq.pop();\\n        v[x]--;\\n        return x;\\n    }\\n    \\n    void addBack(int num) {\\n        if(v[num])   return;\\n        v[num]++;\\n        pq.push(num);\\n    }\\n};\\n```\\n\\n# **approach - 2 optimized =>  only one set**\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n\\n    set<int> s;\\n    int curr;\\n\\n    SmallestInfiniteSet() {\\n        curr = 1;\\n    }\\n    \\n    int popSmallest() {\\n        if(s.size() > 0)    {\\n            int x = *s.begin();\\n            s.erase(x);\\n            return x;\\n        }\\n        else    {\\n            curr++;\\n            return curr-1;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if(curr > num)  s.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Ordered Map",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n\\n    priority_queue<int, vector<int>, greater<int> > pq;\\n    vector<int> v;\\n\\n\\n    SmallestInfiniteSet() {\\n        v.push_back(1);\\n        for(int i=1; i<=1000; i++)   {\\n            pq.push(i);\\n            v.push_back(1);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int x = pq.top();\\n        pq.pop();\\n        v[x]--;\\n        return x;\\n    }\\n    \\n    void addBack(int num) {\\n        if(v[num])   return;\\n        v[num]++;\\n        pq.push(num);\\n    }\\n};\\n```\n```\\nclass SmallestInfiniteSet {\\npublic:\\n\\n    set<int> s;\\n    int curr;\\n\\n    SmallestInfiniteSet() {\\n        curr = 1;\\n    }\\n    \\n    int popSmallest() {\\n        if(s.size() > 0)    {\\n            int x = *s.begin();\\n            s.erase(x);\\n            return x;\\n        }\\n        else    {\\n            curr++;\\n            return curr-1;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if(curr > num)  s.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452275,
                "title": "java-runtime-37-ms-beats-29-74-memory-43-6-mb-beats-11-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    TreeSet<Integer> set = new TreeSet<>();\\n    public SmallestInfiniteSet() \\n    {\\n        for(int i=1;i<1001;i++)\\n        {\\n            set.add(i);\\n        }\\n    }\\n    public int popSmallest() {\\n        Integer x = set.first();\\n        set.remove(x);\\n        return x;\\n    }\\n    public void addBack(int num) {\\n        set.add(num);\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    TreeSet<Integer> set = new TreeSet<>();\\n    public SmallestInfiniteSet() \\n    {\\n        for(int i=1;i<1001;i++)\\n        {\\n            set.add(i);\\n        }\\n    }\\n    public int popSmallest() {\\n        Integer x = set.first();\\n        set.remove(x);\\n        return x;\\n    }\\n    public void addBack(int num) {\\n        set.add(num);\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452222,
                "title": "python-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n```SmallestInfiniteSet().popSmallest()```: if ```len(SmallestInfiniteSet().added) == n > 0``` -> $$O(n)$$ else $$O(1)$$\\n```SmallestInfiniteSet().addBack()```: $$O(1)$$\\n```SmallestInfiniteSet()```: $$O(1)$$\\n\\n- Space complexity:\\n```SmallestInfiniteSet().popSmallest()```: if ```len(SmallestInfiniteSet().added) == n > 0``` -> $$O(n)$$ else $$O(1)$$\\n```SmallestInfiniteSet().addBack()```: $$O(1)$$\\n```SmallestInfiniteSet()```: $$O(1)$$\\n\\n# Code\\n```python\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.min = 1\\n        self.added = set()\\n\\n    def popSmallest(self) -> int:\\n        to_pop = self.min\\n        if len(self.added) > 0:\\n            to_pop = min(min(self.added), to_pop)\\n\\n        self.added.discard(to_pop)\\n        if to_pop == self.min:\\n            self.min += 1\\n\\n        return to_pop\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.min:\\n            self.added.add(num)\\n\\n```\\n\\n## OR\\n\\n# Code\\n```python\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.min = 1\\n        self.added = set()\\n\\n    def popSmallest(self) -> int:\\n        to_pop = self.min\\n        if len(self.added) > 0:\\n            to_pop = min(min(self.added), to_pop)\\n\\n        if to_pop == self.min:\\n            self.min += 1\\n        else:\\n            self.added.remove(to_pop)\\n\\n        return to_pop\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.min:\\n            self.added.add(num)\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```SmallestInfiniteSet().popSmallest()```\n```len(SmallestInfiniteSet().added) == n > 0```\n```SmallestInfiniteSet().addBack()```\n```SmallestInfiniteSet()```\n```SmallestInfiniteSet().popSmallest()```\n```len(SmallestInfiniteSet().added) == n > 0```\n```SmallestInfiniteSet().addBack()```\n```SmallestInfiniteSet()```\n```python\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.min = 1\\n        self.added = set()\\n\\n    def popSmallest(self) -> int:\\n        to_pop = self.min\\n        if len(self.added) > 0:\\n            to_pop = min(min(self.added), to_pop)\\n\\n        self.added.discard(to_pop)\\n        if to_pop == self.min:\\n            self.min += 1\\n\\n        return to_pop\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.min:\\n            self.added.add(num)\\n\\n```\n```python\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.min = 1\\n        self.added = set()\\n\\n    def popSmallest(self) -> int:\\n        to_pop = self.min\\n        if len(self.added) > 0:\\n            to_pop = min(min(self.added), to_pop)\\n\\n        if to_pop == self.min:\\n            self.min += 1\\n        else:\\n            self.added.remove(to_pop)\\n\\n        return to_pop\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.min:\\n            self.added.add(num)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452181,
                "title": "c-array-vs-set-100-time-52ms-95-space-35-3mb",
                "content": "Nice little data structure problem we can solve in many ways - with the main challenge being how to keep track of the reinserted numbers when they are below our current minimum value (later: `curr`), so that we can quickly access them and pop the smallest one of them.\\n\\nWe might be tempted to use something like a linked list for this, but it would hardly be worth the overhead with a maximum cap of `1000` calls (which means we would never have to worry about `num > 1000`, even if that did not have the same maximum constraint as well).\\n\\nWe will solve this problem storing this information in a boolean array first and then in an ordered set to see what would perform better - keeping in mind it really depends from the test cases to see what would run faster (I would expect the array to win in all the cases where we do not have a very sparse collection of reinserted values)\\n\\nFor starters, we will declare at instance level:\\n* `curr`, our current value to be `return`ed, initially set to `1` (the very firts positive integer);\\n* `removed` is an array of `1001` booleans, initially all set to `false`.\\n\\nThe `constructor` will do nothing, while `popSmallest` will:\\n* advance `curr` by `1` position `while` we are on values that were popped already (ie: `removed[curr] == true`);\\n* mark `curr` as popped by setting `removed[curr]` to `true`;\\n* `return` `curr`.\\n\\n`addBack` will be pretty plain:\\n* if `num < curr`, we will set `curr` to be `num`;\\n* in any case, mark `removed[num]` to be `false` (that won\\'t do a thing when `curr > num`).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ (`popSmallest`), $$O(1)$$ (constructor and `addBack`)\\n- Space complexity: $$O(n)$$ (with `n` being the upper limit of our range)\\n\\n# Code\\n```cpp\\nclass SmallestInfiniteSet {\\n    int curr = 1;\\n    bool removed[1001] = {};\\npublic:\\n    SmallestInfiniteSet() {}\\n    \\n    int popSmallest() {\\n        while (removed[curr]) curr++;\\n        removed[curr] = true;\\n        return curr;\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < curr) curr = num;\\n        removed[num] = false;\\n    }\\n};\\n```\\n\\nBy comparison using a set `addedBack` to store all the numbers `< curr` we insert back runs a bit slower (~5ms more) due to the overhead of using a set with a relatively small range and burns some extra space:\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$ (`popSmallest` and `addBack`), $$O(1)$$ (constructor)\\n- Space complexity: $$O(n)$$ (with `n` being the upper limit of our range)\\n\\n# Code\\n```cpp\\nclass SmallestInfiniteSet {\\n    int curr = 1, res;\\n    set<int> addedBack;\\npublic:\\n    SmallestInfiniteSet() {}\\n    \\n    int popSmallest() {\\n        if (addedBack.size()) {\\n            auto pos = begin(addedBack);\\n            res = *pos;\\n            addedBack.erase(pos);\\n            return res;\\n        }\\n        return curr++;\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < curr) addedBack.insert(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design",
                    "Ordered Set"
                ],
                "code": "```cpp\\nclass SmallestInfiniteSet {\\n    int curr = 1;\\n    bool removed[1001] = {};\\npublic:\\n    SmallestInfiniteSet() {}\\n    \\n    int popSmallest() {\\n        while (removed[curr]) curr++;\\n        removed[curr] = true;\\n        return curr;\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < curr) curr = num;\\n        removed[num] = false;\\n    }\\n};\\n```\n```cpp\\nclass SmallestInfiniteSet {\\n    int curr = 1, res;\\n    set<int> addedBack;\\npublic:\\n    SmallestInfiniteSet() {}\\n    \\n    int popSmallest() {\\n        if (addedBack.size()) {\\n            auto pos = begin(addedBack);\\n            res = *pos;\\n            addedBack.erase(pos);\\n            return res;\\n        }\\n        return curr++;\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < curr) addedBack.insert(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452069,
                "title": "c-solutions-explained-line-by-line-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given program implements a class called \"SmallestInfiniteSet\" that maintains a sorted set of integers. The class provides a member function called \"popSmallest()\" that returns and removes the smallest element from the set, and a member function called \"addBack(int num)\" that adds the given integer to the set.\\n\\nThe approach used in this program is to maintain a sorted set of integers using the \"set\" data structure provided by the C++ Standard Library. The class ensures that the set is always sorted in increasing order.\\n\\nThe \"popSmallest()\" function retrieves the smallest element from the set using the \"begin()\" function, and if this smallest element is less than the current left end of the set, it is returned as the smallest element. Otherwise, the left end of the set is updated to the current smallest element, and the smallest element is returned.\\n\\nThe \"addBack(int num)\" function simply inserts the given integer into the set using the \"insert()\" function provided by the set.\\n\\nThe time complexity of both the \"popSmallest()\" and \"addBack(int num)\" functions is O(log N), where N is the size of the set. The space complexity of the program is also O(N), where N is the number of elements in the set.\\n\\nOverall, this program provides an efficient and elegant solution for maintaining a sorted set of integers and finding the smallest element in the set.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this program is to maintain a sorted set of integers using the \"set\" data structure provided by the C++ Standard Library. The class ensures that the set is always sorted in increasing order.\\n\\nThe \"popSmallest()\" function retrieves the smallest element from the set using the \"begin()\" function, and if this smallest element is less than the current left end of the set, it is returned as the smallest element. Otherwise, the left end of the set is updated to the current smallest element, and the smallest element is returned.\\n\\nThe \"addBack(int num)\" function simply inserts the given integer into the set using the \"insert()\" function provided by the set.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the \"popSmallest()\" function is O(log N), where N is the size of the set. This is because the \"begin()\" function takes constant time to retrieve the smallest element, and erasing an element from a set takes logarithmic time in the worst case.\\n\\nThe time complexity of the \"addBack(int num)\" function is also O(log N), where N is the size of the set. This is because inserting an element into a set takes logarithmic time in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this program is O(N), where N is the number of elements in the set. This is because the \"set\" data structure used by the program stores all its elements in memory, and the size of the set grows as more elements are added to it.\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    int left = 0; // The left end of the sorted infinite set\\n    \\n    // Constructor that initializes the set with the integer value 1\\n    SmallestInfiniteSet() {\\n        s.insert(1);\\n    }\\n    \\n    // Returns and removes the smallest element from the set\\n    int popSmallest() {\\n        if(left == 0) { // First deletion\\n            s.insert(2); // Insert the next smallest element (which is 2) into the set\\n            s.erase(1); // Erase the smallest element (which is 1)\\n            left = 1; // Update the left end to 1\\n            return 1; // Return 1\\n        }\\n        else {\\n            s.insert(left + 1); // Insert the element to ensure set is not empty\\n            auto it = s.begin(); // Retrieve an iterator to the smallest element in the set\\n            int currSmall = *it; // Store the smallest element in currSmall\\n            if(currSmall < left) { // If the smallest element is less than left\\n                s.erase(it); // Erase the smallest element from the set\\n                return currSmall; // Return the smallest element\\n            }\\n            else { // If the smallest element is greater than or equal to left\\n                left = currSmall; // Update the left end to currSmall\\n                s.erase(it); // Erase the smallest element from the set\\n                return currSmall; // Return the smallest element\\n            }\\n        }\\n    }\\n    \\n    // Adds the given integer to the set\\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    int left = 0; // The left end of the sorted infinite set\\n    \\n    // Constructor that initializes the set with the integer value 1\\n    SmallestInfiniteSet() {\\n        s.insert(1);\\n    }\\n    \\n    // Returns and removes the smallest element from the set\\n    int popSmallest() {\\n        if(left == 0) { // First deletion\\n            s.insert(2); // Insert the next smallest element (which is 2) into the set\\n            s.erase(1); // Erase the smallest element (which is 1)\\n            left = 1; // Update the left end to 1\\n            return 1; // Return 1\\n        }\\n        else {\\n            s.insert(left + 1); // Insert the element to ensure set is not empty\\n            auto it = s.begin(); // Retrieve an iterator to the smallest element in the set\\n            int currSmall = *it; // Store the smallest element in currSmall\\n            if(currSmall < left) { // If the smallest element is less than left\\n                s.erase(it); // Erase the smallest element from the set\\n                return currSmall; // Return the smallest element\\n            }\\n            else { // If the smallest element is greater than or equal to left\\n                left = currSmall; // Update the left end to currSmall\\n                s.erase(it); // Erase the smallest element from the set\\n                return currSmall; // Return the smallest element\\n            }\\n        }\\n    }\\n    \\n    // Adds the given integer to the set\\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452055,
                "title": "set",
                "content": "# Code\\n```\\nclass SmallestInfiniteSet {\\nprivate:\\n    set<int> st;\\n    int start = 1;\\npublic:\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        if(st.size()){\\n            int e = *st.begin();\\n            st.erase(st.begin());\\n            return e;\\n        }\\n        return start++;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < start)\\n            st.insert(num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\nprivate:\\n    set<int> st;\\n    int start = 1;\\npublic:\\n    SmallestInfiniteSet() {\\n        \\n    }\\n    \\n    int popSmallest() {\\n        if(st.size()){\\n            int e = *st.begin();\\n            st.erase(st.begin());\\n            return e;\\n        }\\n        return start++;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < start)\\n            st.insert(num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452054,
                "title": "python3-heap-approach",
                "content": "# Intuition\\nWe need to maintain:\\n1. Smallest number not yet retrieved\\n2. Numbers that were already put back - in a heap and in a set\\n\\nWhen popping smallest - check if we have it pushed back - in the set - if it is present - then remove it from the set and from the heap, and return. \\nOtherwise - return smallest and increment it. If after the increment it is present in the heap and set - remove it.  \\n\\nWhen pushing back - check if it already present in the heap & set or is greater or equal than the smallest one - then ignore. \\nOtherwise add it into the set and into the heap.\\n\\n\\n# Code\\n```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.smallest = 1\\n        self.added = []\\n        self.added_set = set()\\n\\n    def popSmallest(self) -> int:\\n        if self.added and self.added[0] < self.smallest:\\n            result = heapq.heappop(self.added)\\n            self.added_set.remove(result)\\n            return result\\n        result = self.smallest\\n        self.smallest += 1\\n        if self.added and self.smallest == self.added[0]:\\n            heapq.heappop(self.added)\\n            self.added_set.remove(self.smallest)\\n        return result\\n\\n    def addBack(self, num: int) -> None:\\n        if num >= self.smallest or num in self.added_set:\\n            return\\n        heapq.heappush(self.added, num)\\n        self.added_set.add(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.smallest = 1\\n        self.added = []\\n        self.added_set = set()\\n\\n    def popSmallest(self) -> int:\\n        if self.added and self.added[0] < self.smallest:\\n            result = heapq.heappop(self.added)\\n            self.added_set.remove(result)\\n            return result\\n        result = self.smallest\\n        self.smallest += 1\\n        if self.added and self.smallest == self.added[0]:\\n            heapq.heappop(self.added)\\n            self.added_set.remove(self.smallest)\\n        return result\\n\\n    def addBack(self, num: int) -> None:\\n        if num >= self.smallest or num in self.added_set:\\n            return\\n        heapq.heappush(self.added, num)\\n        self.added_set.add(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327054,
                "title": "ruby-solution",
                "content": "```\\nclass SmallestInfiniteSet\\n    def initialize()\\n        @set = Set.new\\n        for i in(1).upto(1000)\\n            @set.add(i)\\n        end\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def pop_smallest()\\n        num = @set.min\\n        @set.delete(num)\\n        num\\n    end\\n\\n\\n=begin\\n    :type num: Integer\\n    :rtype: Void\\n=end\\n    def add_back(num)\\n        @set.add(num) unless @set.include?(num)\\n    end\\n\\n\\nend\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet.new()\\n# param_1 = obj.pop_smallest()\\n# obj.add_back(num)\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass SmallestInfiniteSet\\n    def initialize()\\n        @set = Set.new\\n        for i in(1).upto(1000)\\n            @set.add(i)\\n        end\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def pop_smallest()\\n        num = @set.min\\n        @set.delete(num)\\n        num\\n    end\\n\\n\\n=begin\\n    :type num: Integer\\n    :rtype: Void\\n=end\\n    def add_back(num)\\n        @set.add(num) unless @set.include?(num)\\n    end\\n\\n\\nend\\n\\n# Your SmallestInfiniteSet object will be instantiated and called as such:\\n# obj = SmallestInfiniteSet.new()\\n# param_1 = obj.pop_smallest()\\n# obj.add_back(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170438,
                "title": "min-heap-and-ordered-map-easy-solution",
                "content": "# Approach\\n1. create minheap and map according to given constraints\\n2. in popsmallest function simply pop and remove element from heap and map both\\n3. in addBack function check if num is already present or not and add accordingly\\n# Complexity\\n- Time complexity:\\nO(logn)\\n- Space complexity:\\nO(1000) = O(1)\\n# Code\\n```\\nclass SmallestInfiniteSet {\\n    map<int,bool> map;\\n    priority_queue<int,vector<int>,greater<int>> minheap;\\npublic:\\n    SmallestInfiniteSet() {\\n        for(int i = 1; i <= 1000; i++){\\n            minheap.push(i);\\n            map[i] = true;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int num = minheap.top();\\n        minheap.pop();\\n        map[num] = false;\\n        return num;\\n    }\\n    \\n    void addBack(int num) {\\n        if(map[num] == false){\\n            minheap.push(num);\\n            map[num] = true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n    map<int,bool> map;\\n    priority_queue<int,vector<int>,greater<int>> minheap;\\npublic:\\n    SmallestInfiniteSet() {\\n        for(int i = 1; i <= 1000; i++){\\n            minheap.push(i);\\n            map[i] = true;\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        int num = minheap.top();\\n        minheap.pop();\\n        map[num] = false;\\n        return num;\\n    }\\n    \\n    void addBack(int num) {\\n        if(map[num] == false){\\n            minheap.push(num);\\n            map[num] = true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926455,
                "title": "beats-90-codedominar-solution",
                "content": "# Code\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.heap = [i for i in range(1,1001)]\\n        heapq.heapify(self.heap)\\n        self.d = Counter(self.heap)\\n    def popSmallest(self) -> int:\\n        val = heapq.heappop(self.heap)\\n        self.d[val] = 0\\n        return val        \\n    def addBack(self, num: int) -> None:\\n        if num not in self.d or not self.d[num]:\\n            heapq.heappush(self.heap,num)\\n            self.d[num] = 1\\n\\n# # Your SmallestInfiniteSet object will be instantiated and called as such:\\n# # obj = SmallestInfiniteSet()\\n# # param_1 = obj.popSmallest()\\n# # obj.addBack(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.heap = [i for i in range(1,1001)]\\n        heapq.heapify(self.heap)\\n        self.d = Counter(self.heap)\\n    def popSmallest(self) -> int:\\n        val = heapq.heappop(self.heap)\\n        self.d[val] = 0\\n        return val        \\n    def addBack(self, num: int) -> None:\\n        if num not in self.d or not self.d[num]:\\n            heapq.heappush(self.heap,num)\\n            self.d[num] = 1\\n\\n# # Your SmallestInfiniteSet object will be instantiated and called as such:\\n# # obj = SmallestInfiniteSet()\\n# # param_1 = obj.popSmallest()\\n# # obj.addBack(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821943,
                "title": "python-heap",
                "content": "# Intuition\\nAs the constraints are small, we can just use Heap with Set.\\n\\n# Complexity\\n- Time complexity:\\nO(LogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nimport heapq\\n\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.hq = []\\n        self.numSet = set()\\n        \\n        for num in range(1, 1001):\\n            heapq.heappush(self.hq, num)\\n            self.numSet.add(num)\\n\\n    def popSmallest(self) -> int:\\n        num = heapq.heappop(self.hq)\\n        self.numSet.discard(num)\\n        \\n        return num\\n        \\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.numSet:\\n            return\\n        \\n        heapq.heappush(self.hq, num)\\n        self.numSet.add(num)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.hq = []\\n        self.numSet = set()\\n        \\n        for num in range(1, 1001):\\n            heapq.heappush(self.hq, num)\\n            self.numSet.add(num)\\n\\n    def popSmallest(self) -> int:\\n        num = heapq.heappop(self.hq)\\n        self.numSet.discard(num)\\n        \\n        return num\\n        \\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.numSet:\\n            return\\n        \\n        heapq.heappush(self.hq, num)\\n        self.numSet.add(num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787143,
                "title": "c-simple-solution",
                "content": "```\\nclass SmallestInfiniteSet {\\nprivate:\\n    set<int> remove;\\n    int small;\\npublic:\\n    SmallestInfiniteSet() {\\n        small = 1;\\n    }\\n    \\n    int popSmallest() {\\n        int res = small;\\n        remove.insert(small);\\n        while (remove.find(small) != remove.end())\\n            small++;\\n        return res;\\n    }\\n    \\n    void addBack(int num) {\\n        small = min(small, num);\\n        remove.erase(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\nprivate:\\n    set<int> remove;\\n    int small;\\npublic:\\n    SmallestInfiniteSet() {\\n        small = 1;\\n    }\\n    \\n    int popSmallest() {\\n        int res = small;\\n        remove.insert(small);\\n        while (remove.find(small) != remove.end())\\n            small++;\\n        return res;\\n    }\\n    \\n    void addBack(int num) {\\n        small = min(small, num);\\n        remove.erase(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746173,
                "title": "c-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe shall make use of a data structure Set. Set stores the elements in sorted order. so finding smallest elemet is O(1) work. while extracting it is O(logn) \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nkeep a left end of deleted smallest numbers in the account.\\nleft stores the maximum value deleted so far.\\n\\n# Complexity\\n- **Time complexity** : $$O(nlogm)$$ --> n is number of calls and m = max size of set at any momemt.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity**: $$O(m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    int left = 0;// it is the left end of the sorted infinite set \\n    // there might be some elements before it which might have been added later\\n    SmallestInfiniteSet() {\\n        s.insert(1);\\n    }\\n    \\n    int popSmallest() {\\n        if(left==0) // first deletion\\n        {\\n            s.insert(2);\\n            s.erase(1);\\n            left = 1;\\n            return 1;\\n        }\\n        else\\n        {\\n            \\n            s.insert(left + 1); // insert the element to ensure set is not empty\\n            auto it = s.begin();\\n            int currSmall = *it;\\n            if(currSmall < left)\\n            {\\n                s.erase(it);\\n                return currSmall;\\n            }\\n            else\\n            {\\n                left = currSmall;\\n                s.erase(it);\\n                return currSmall;\\n            }\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\npublic:\\n    set<int> s;\\n    int left = 0;// it is the left end of the sorted infinite set \\n    // there might be some elements before it which might have been added later\\n    SmallestInfiniteSet() {\\n        s.insert(1);\\n    }\\n    \\n    int popSmallest() {\\n        if(left==0) // first deletion\\n        {\\n            s.insert(2);\\n            s.erase(1);\\n            left = 1;\\n            return 1;\\n        }\\n        else\\n        {\\n            \\n            s.insert(left + 1); // insert the element to ensure set is not empty\\n            auto it = s.begin();\\n            int currSmall = *it;\\n            if(currSmall < left)\\n            {\\n                s.erase(it);\\n                return currSmall;\\n            }\\n            else\\n            {\\n                left = currSmall;\\n                s.erase(it);\\n                return currSmall;\\n            }\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        s.insert(num);\\n    }\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660796,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass SmallestInfiniteSet {\\n\\n    Set<Integer> setOfDeleted;\\n        int smallest;\\n        public SmallestInfiniteSet() {\\n            setOfDeleted = new HashSet<>();\\n            smallest = 1;\\n        }\\n\\n        public int popSmallest() {\\n            if (!setOfDeleted.contains(smallest)) {\\n                setOfDeleted.add(smallest);\\n                return smallest++;\\n            } else {\\n                while (setOfDeleted.contains(smallest)) {\\n                    smallest++;\\n                }\\n                setOfDeleted.add(smallest);\\n                return smallest;\\n            }\\n        }\\n\\n        public void addBack(int num) {\\n            if (smallest > num) {\\n                smallest = num;\\n            }\\n            setOfDeleted.remove(num);\\n        }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass SmallestInfiniteSet {\\n\\n    Set<Integer> setOfDeleted;\\n        int smallest;\\n        public SmallestInfiniteSet() {\\n            setOfDeleted = new HashSet<>();\\n            smallest = 1;\\n        }\\n\\n        public int popSmallest() {\\n            if (!setOfDeleted.contains(smallest)) {\\n                setOfDeleted.add(smallest);\\n                return smallest++;\\n            } else {\\n                while (setOfDeleted.contains(smallest)) {\\n                    smallest++;\\n                }\\n                setOfDeleted.add(smallest);\\n                return smallest;\\n            }\\n        }\\n\\n        public void addBack(int num) {\\n            if (smallest > num) {\\n                smallest = num;\\n            }\\n            setOfDeleted.remove(num);\\n        }\\n}\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet obj = new SmallestInfiniteSet();\\n * int param_1 = obj.popSmallest();\\n * obj.addBack(num);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601125,
                "title": "c",
                "content": "```\\ntypedef struct {\\n    int* heap;\\n    bool* hash;\\n    int  heapsize;\\n} SmallestInfiniteSet;\\n\\n\\nSmallestInfiniteSet* smallestInfiniteSetCreate() {\\n    SmallestInfiniteSet* ret = malloc(sizeof(SmallestInfiniteSet));\\n    ret->heap = malloc(1001 * sizeof(int));\\n    ret->hash = malloc(1000 * sizeof(bool));\\n    for(int i = 0; i < 1000; i++){\\n        ret->heap[i] = i + 1; \\n        ret->hash[i] = true;\\n    }\\n    ret->heapsize =  1000;\\n    return ret;\\n}\\n\\nint smallestInfiniteSetPopSmallest(SmallestInfiniteSet* obj) {\\n    if(obj->heapsize == 0)\\n        return -1;\\n\\n    int ans = obj->heap[0];\\n    obj->hash[ans-1] = false;\\n    obj->heap[0] = obj->heap[obj->heapsize - 1];\\n    obj->heapsize--;\\n    int pos = 0, temp;\\n    \\n    while(pos < obj->heapsize){\\n        if((2*pos + 1) >= obj->heapsize)\\n            break;\\n        if((2*pos + 1) == ((obj->heapsize) - 1)){\\n            if(obj->heap[pos] > obj->heap[2*pos+ 1]){\\n                temp = obj->heap[pos] ;\\n                obj->heap[pos] = obj->heap[2 * pos + 1];\\n                obj->heap[2*pos + 1] = temp; \\n                pos = 2*pos + 1;\\n            }\\n            break;\\n        }\\n        if(obj->heap[pos] > obj->heap[2*pos + 1] || obj->heap[pos] > obj->heap[2*pos + 2]){\\n            if(obj->heap[2*pos + 1] <=  obj->heap[2*pos + 2] )  {\\n                temp = obj->heap[2*pos + 1];\\n                obj->heap[2*pos + 1] = obj->heap[pos];\\n                obj->heap[pos] = temp;\\n                pos = 2*pos + 1;\\n            } \\n            else{\\n                temp = obj->heap[2*pos + 2];\\n                obj->heap[2*pos + 2] = obj->heap[pos];\\n                obj->heap[pos] = temp;    \\n                pos = 2*pos + 2;\\n            }\\n        }\\n        else\\n            break;\\n    }\\n    return ans;\\n}\\n\\nvoid smallestInfiniteSetAddBack(SmallestInfiniteSet* obj, int num) {\\n\\n    if(obj->hash[num-1] == true)\\n        return ;\\n    else\\n        obj->hash[num-1] = true;\\n\\n    obj->heap[obj->heapsize]  = num;\\n    int pos = obj->heapsize;\\n    obj->heapsize++;\\n    int temp;\\n    while(pos > 0 && (obj->heap[pos] < obj->heap[(pos-1)/2] )){\\n        temp = obj->heap[(pos-1)/2];\\n        obj->heap[(pos-1)/2] = obj->heap[pos] ;\\n        obj->heap[pos]  = temp;\\n        pos = (pos-1)/2;\\n    }    \\n}\\n\\nvoid smallestInfiniteSetFree(SmallestInfiniteSet* obj) {\\n    free(obj->heap);\\n    free(obj);\\n}\\n\\n/**\\n * Your SmallestInfiniteSet struct will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = smallestInfiniteSetCreate();\\n * int param_1 = smallestInfiniteSetPopSmallest(obj);\\n \\n * smallestInfiniteSetAddBack(obj, num);\\n \\n * smallestInfiniteSetFree(obj);\\n*/\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef struct {\\n    int* heap;\\n    bool* hash;\\n    int  heapsize;\\n} SmallestInfiniteSet;\\n\\n\\nSmallestInfiniteSet* smallestInfiniteSetCreate() {\\n    SmallestInfiniteSet* ret = malloc(sizeof(SmallestInfiniteSet));\\n    ret->heap = malloc(1001 * sizeof(int));\\n    ret->hash = malloc(1000 * sizeof(bool));\\n    for(int i = 0; i < 1000; i++){\\n        ret->heap[i] = i + 1; \\n        ret->hash[i] = true;\\n    }\\n    ret->heapsize =  1000;\\n    return ret;\\n}\\n\\nint smallestInfiniteSetPopSmallest(SmallestInfiniteSet* obj) {\\n    if(obj->heapsize == 0)\\n        return -1;\\n\\n    int ans = obj->heap[0];\\n    obj->hash[ans-1] = false;\\n    obj->heap[0] = obj->heap[obj->heapsize - 1];\\n    obj->heapsize--;\\n    int pos = 0, temp;\\n    \\n    while(pos < obj->heapsize){\\n        if((2*pos + 1) >= obj->heapsize)\\n            break;\\n        if((2*pos + 1) == ((obj->heapsize) - 1)){\\n            if(obj->heap[pos] > obj->heap[2*pos+ 1]){\\n                temp = obj->heap[pos] ;\\n                obj->heap[pos] = obj->heap[2 * pos + 1];\\n                obj->heap[2*pos + 1] = temp; \\n                pos = 2*pos + 1;\\n            }\\n            break;\\n        }\\n        if(obj->heap[pos] > obj->heap[2*pos + 1] || obj->heap[pos] > obj->heap[2*pos + 2]){\\n            if(obj->heap[2*pos + 1] <=  obj->heap[2*pos + 2] )  {\\n                temp = obj->heap[2*pos + 1];\\n                obj->heap[2*pos + 1] = obj->heap[pos];\\n                obj->heap[pos] = temp;\\n                pos = 2*pos + 1;\\n            } \\n            else{\\n                temp = obj->heap[2*pos + 2];\\n                obj->heap[2*pos + 2] = obj->heap[pos];\\n                obj->heap[pos] = temp;    \\n                pos = 2*pos + 2;\\n            }\\n        }\\n        else\\n            break;\\n    }\\n    return ans;\\n}\\n\\nvoid smallestInfiniteSetAddBack(SmallestInfiniteSet* obj, int num) {\\n\\n    if(obj->hash[num-1] == true)\\n        return ;\\n    else\\n        obj->hash[num-1] = true;\\n\\n    obj->heap[obj->heapsize]  = num;\\n    int pos = obj->heapsize;\\n    obj->heapsize++;\\n    int temp;\\n    while(pos > 0 && (obj->heap[pos] < obj->heap[(pos-1)/2] )){\\n        temp = obj->heap[(pos-1)/2];\\n        obj->heap[(pos-1)/2] = obj->heap[pos] ;\\n        obj->heap[pos]  = temp;\\n        pos = (pos-1)/2;\\n    }    \\n}\\n\\nvoid smallestInfiniteSetFree(SmallestInfiniteSet* obj) {\\n    free(obj->heap);\\n    free(obj);\\n}\\n\\n/**\\n * Your SmallestInfiniteSet struct will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = smallestInfiniteSetCreate();\\n * int param_1 = smallestInfiniteSetPopSmallest(obj);\\n \\n * smallestInfiniteSetAddBack(obj, num);\\n \\n * smallestInfiniteSetFree(obj);\\n*/\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2409218,
                "title": "using-a-vector-and-counter-variable",
                "content": "use a int counter varriable to store an infinite set starting from 1  , and increase its value on each pop. in case of insertion if num > =counter no need to add else we insert the num in vector in sorted way  . during pop we check and return v[0]<counter?v[0]:counter .\\n```class SmallestInfiniteSet {\\npublic:\\n    int n;\\n    vector<int> v;\\n    SmallestInfiniteSet() {\\n        n = 1;\\n        return;\\n    }\\n    int popSmallest() {\\n        int min = n++;\\n        if(v.size()==0)return min;\\n        else if(v[0]<min)\\n        {\\n            n--;\\n            min = v[0];\\n            v.erase(v.begin() , v.begin()+1);\\n            return min;\\n        }\\n        else return min;\\n    }\\n    \\n    void addBack(int num) {\\n        if(n<=num)return;\\n        else if(num==n-1)\\n        {\\n            n--;\\n            return;\\n        }\\n        else if(v.size()==0)\\n        {\\n            v.push_back(num);\\n            return;\\n        }\\n        else if(v[0]>num)\\n        {\\n            v.insert(v.begin() , num);\\n            return;\\n        }\\n        else\\n        {\\n            for(int i =0 ;i<v.size()-1;i++)\\n            {\\n                if(v[i]==num)return;\\n                if(v[i]<num&&v[i+1]>num)\\n                {\\n                    v.insert(v.begin()+i+1 , num);\\n                    return;\\n                }\\n            }\\n        }\\n        if(v[v.size()-1]==num)\\n            return;\\n        v.push_back(num);\\n        return;\\n    }\\n};\\n```\\nhope this will help you , thank you.",
                "solutionTags": [],
                "code": "```class SmallestInfiniteSet {\\npublic:\\n    int n;\\n    vector<int> v;\\n    SmallestInfiniteSet() {\\n        n = 1;\\n        return;\\n    }\\n    int popSmallest() {\\n        int min = n++;\\n        if(v.size()==0)return min;\\n        else if(v[0]<min)\\n        {\\n            n--;\\n            min = v[0];\\n            v.erase(v.begin() , v.begin()+1);\\n            return min;\\n        }\\n        else return min;\\n    }\\n    \\n    void addBack(int num) {\\n        if(n<=num)return;\\n        else if(num==n-1)\\n        {\\n            n--;\\n            return;\\n        }\\n        else if(v.size()==0)\\n        {\\n            v.push_back(num);\\n            return;\\n        }\\n        else if(v[0]>num)\\n        {\\n            v.insert(v.begin() , num);\\n            return;\\n        }\\n        else\\n        {\\n            for(int i =0 ;i<v.size()-1;i++)\\n            {\\n                if(v[i]==num)return;\\n                if(v[i]<num&&v[i+1]>num)\\n                {\\n                    v.insert(v.begin()+i+1 , num);\\n                    return;\\n                }\\n            }\\n        }\\n        if(v[v.size()-1]==num)\\n            return;\\n        v.push_back(num);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1873154,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873217,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873218,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873200,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873163,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873159,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873327,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873189,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1881410,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873168,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873154,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873217,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873218,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873200,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873163,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873159,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873327,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873189,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1881410,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873168,
                "content": [
                    {
                        "username": "Maang-io",
                        "content": "Should be marked as Easy, it is straightforward"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Didn\\'t find it easy."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@pokaChika](/pokaChika) totally agree. that Infinite set of integers mentioned int the problem is confusing."
                    },
                    {
                        "username": "Maang-io",
                        "content": "[@matthewwdaly](/matthewwdaly) I might agree with you, at the same time this problem can be solved using boolean arrays. Yeah time complexity would be higher O(n) compared to O(logN) for heaps"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "There are almost no easy problems with the heap tag, and even fewer where you need a heap to solve it.  Even though it\\'s not a hard structure to work with, knowing about it must be intrinsically medium to LC."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Only easy until we consider it actually an infinte set of integers!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Step 1: Put all positive integers into a heap.\\n\\nNo wait..."
                    },
                    {
                        "username": "prototye",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "beda9846",
                        "content": "[@codeMonarch](/codeMonarch) wating..."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "waiting\\n"
                    },
                    {
                        "username": "py3LC",
                        "content": "The question shouldn\\'t have mentioned 1000 limit, then it would have been more challenging."
                    },
                    {
                        "username": "Godwin_NG",
                        "content": "Yeah, I think mentioning that they make a maximum number of calls between `popSmallest()` and `addBack()` makes it a bit easier to estimate what we can expect in terms of maximum expected inputs thus making the question somewhat easier than medium however, I\\'ll still consider this easyish-medium."
                    },
                    {
                        "username": "pokaChika",
                        "content": "Is not easy if we consider the infinite integer set statment! Thats what makes it medium #heapifyit"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "I find the wording of \"infinite\" to be a bit dubious in this problem, especially when considering the constraints (as well as the associated hint). Clearly the set is *finite* (contains positive integers between 1 and n, inclusive), but the number of operations that can be performed are *infinite*."
                    },
                    {
                        "username": "kylecrowley",
                        "content": "[@TamasTako](/TamasTako) That is true, but that is my whole point. Nothing in this problem is truly \"infinite\", due to the fact that this is a LC problem that can\\'t run forever. As it stands you could take my code and apply an infinite number of operations, but once you truly make the set itself \"infinite\", you run into a slew of other problems (how to represent every positive  integer, will it fit in memory, etc).\\n\\nAs for the hints: re-read the second hint. The second part is hinting that there are a fixed amount of elements to consider (read: finite), which is, again, contradictory to \"infinite\"."
                    },
                    {
                        "username": "TamasTako",
                        "content": "The second constraint says \"At most 1000 calls will be made in total to popSmallest and addBack.\", so the operations performed won\\'t be infinite either. These constraints force the problem into a [1, 1001] finite problem, it is contradicting with the infinite set, and also the hints say to consider what could be the biggest number you can get.."
                    },
                    {
                        "username": "vin36",
                        "content": "The constraints mention that num <= 1000 and calls <= 1000. Follow up question: consider an implemention for an actual infinite set with no such constraints."
                    },
                    {
                        "username": "hosua",
                        "content": "[@cswartzell](/cswartzell) Yeah. If anything like INT_MAX or something."
                    },
                    {
                        "username": "cswartzell",
                        "content": "You'd need to suggest *some* constraints as otherwise any solution would require an infinite amount of memory. If you have infinite memory, then the solution remains the same"
                    },
                    {
                        "username": "wb2128",
                        "content": "what is wrong with my code, two cases cannot pass\\n```\\nclass SmallestInfiniteSet:\\n    def __init__(self):\\n        self.arr = []\\n        heapify(self.arr)\\n        self.ceiling = 1\\n\\n    def popSmallest(self) -> int:\\n        if len(self.arr) == 0:\\n            self.ceiling += 1\\n            return self.ceiling - 1\\n        else:\\n            return heappop(self.arr)\\n\\n    def addBack(self, num: int) -> None:\\n        if num < self.ceiling:\\n            heappush(self.arr, num)\\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@TobiasKaufmann](/TobiasKaufmann) \n```    \ndef addBack(self, num: int) -> None:\n        if num in self.arr:\n            return\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```\nFor the problem size, just checking whethe we have already stored it could solve the problem without TLE.\n\nAnd we could also pop all the duplicates but this actually runs slower than checking in the list.\n```\nimport heapq\n\nclass SmallestInfiniteSet:\n    def __init__(self):\n        self.arr = []\n        heapify(self.arr)\n        self.ceiling = 1\n\n    def popSmallest(self) -> int:\n        if len(self.arr) == 0:\n            self.ceiling += 1\n            return self.ceiling - 1\n        else:\n            e = heappop(self.arr)\n            while(self.arr and e == self.arr[0]):\n                heappop(self.arr)\n            return e\n\n    def addBack(self, num: int) -> None:\n        if num < self.ceiling:\n            heappush(self.arr, num)\n```"
                    },
                    {
                        "username": "wb2128",
                        "content": "[@hero080](/hero080)  Thank you that is indeed the issue."
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "[@hero080](/hero080) How to address it issue without using hashset?"
                    },
                    {
                        "username": "hero080",
                        "content": "It is possible that `addBack()` is called with the same `num` multiple times, while the `num` is less than the `ceiling`. The code needs to properly dedup."
                    },
                    {
                        "username": "shreshthpal",
                        "content": "following this thread i have the same issue 2 test cases are failing"
                    },
                    {
                        "username": "shreshthpal",
                        "content": "[@user2285TI](/user2285TI) he has set a ceiling var which pushes it into the heap only when it is smaller than the ceiling\\n"
                    },
                    {
                        "username": "user2285TI",
                        "content": "\"Adds a positive integer num back into the infinite set, if it is not already in the infinite set.\" Your addBack() function does not seem to be meeting this requirement."
                    },
                    {
                        "username": "anwendeng",
                        "content": "I just used the C++ STL set, and solved the problem!"
                    },
                    {
                        "username": "shvmsaini",
                        "content": "If anyone is wondering why Set worked but priority queue didn\\'t it\\'s due to duplicates being added."
                    },
                    {
                        "username": "AMerrill",
                        "content": "I thought this problem had a reasonable difficulty if you try to push for the fastest solution, and it felt quite satisfying to finally solve! (Took me about an hour)"
                    }
                ]
            },
            {
                "id": 1873952,
                "content": [
                    {
                        "username": "chinmaynirwan",
                        "content": "hey can any one tell me what is wrong in my code , i am getting wrong ans for 134th testcase\\n\\n  public:\\n     int frd=1;\\n     unordered_set<int> s;\\n     set<int> ad;\\n\\n    SmallestInfiniteSet() {\\n       \\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(s.empty()){\\n\\n            s.insert(frd);\\n            frd++;\\n        }else{\\n            if(ad.empty()){\\n\\n                s.insert(frd);\\n                frd++;\\n                return frd-1;\\n            }else{\\n                \\n                int ans= *ad.begin();\\n                s.insert(ans);\\n                ad.erase(ans);\\n\\n                return ans;\\n            }\\n        }\\n       \\n        return frd-1;\\n       \\n    }\\n    \\n    void addBack(int num) {\\n        \\n        if(s.find(num)!=s.end()){\\n\\n            ad.insert(num);\\n            s.erase(num);\\n            \\n            }\\n    }"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "class SmallestInfiniteSet {\n   priority_queue<int, vector<int>, greater<int>> pq;\n    int small;\npublic:\n    SmallestInfiniteSet() {\n        small = 1;\n    }\n    \n    int popSmallest() {\n        int ans;\n        if(pq.size())\n        {\n            ans = pq.top();\n            pq.pop();\n        }\n        else\n        {\n            ans = small;\n            small ++;\n        }\n        return ans;\n    }\n    \n    void addBack(int num) {\n        if(num < small)\n            pq.push(num);\n    }\n};\n\n\n\nwhy it is showing wrong ans ? and if i use set instead of priority queue its showing right ans, why ?"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Is it really what question's asking?\n\n`\n`class SmallestInfiniteSet {\npublic:\n    set<int> s;\n    SmallestInfiniteSet() {\n        for(int i=1; i<=1000; i++){\n            s.insert(i);\n        }\n    }\n    \n    int popSmallest() {\n      \n        int k = *s.begin();\n        s.erase(s.begin());\n        return k;   \n    }\n    \n    void addBack(int num) {\n        s.insert(num);\n    }\n};`\n`"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Can anyone check what is wrong in my code. It seems that the logic is correct atleast to me?\n\n```\nclass SmallestInfiniteSet:\n\n    def __init__(self):\n        self.heap = []\n        self.last = 1\n        heapify(self.heap)\n\n    def popSmallest(self) -> int:\n        if self.heap:\n            return heappop(self.heap)\n            \n        self.last += 1\n        return self.last - 1\n\n    def addBack(self, num: int) -> None:\n        if num < self.last:\n            heappush(self.heap, num)\n```"
                    },
                    {
                        "username": "hacker363",
                        "content": "class SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.removed = []\\n        self.minimum = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.l:\\n            m = min(self.l)\\n            self.l=[]\\n            return m\\n        self.removed.append(self.minimum)\\n        self.minimum += 1\\n        return self.minimum - 1\\n\\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.removed:\\n            self.l.append(num)\\nCan anybody please please tell me why my code only passes(133/135) test cases"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "Isn\\'t implementing custom heap best solution hear? Why are people using built-in DS and functions?"
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "I passed 133/135 testcases idk whu it's not working, help \n```\nclass SmallestInfiniteSet {\npublic:\n    vector<int> push;\n    int g=1;\n    int popSmallest() {\n        if(push.empty() || g<=push[0]) return g++;\n        else{\n            int x=push[0];\n            push.erase(push.begin());\n            return x;\n        }\n        \n    }\n    void addBack(int num) {\n        if(num<g){\n            int i=0,f=1;\n            for(i=0;i<push.size();++i){\n                if(num<push[i]){\n                    push.insert(push.begin()+i,num);\n                    f=0;\n                    break;\n                }\n            }\n            if(f) push.push_back(num);\n        }\n    }\n};\n```\n"
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "public:\\n    priority_queue<int, std::vector<int>, std::greater<int>>p;\\n    SmallestInfiniteSet() {\\n        for(int i=0;i<=1000;i++){\\n            p.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        if(!p.empty()){\\n            int smal = p.top();\\n            p.pop();\\n            return smal;\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(p.find(num)==p.end())   <------------------------------------\\n        p.push(num);\\n    }\\n\\nIn addBack func, I\\'m getting error: \\'find\\' cant be used. Can someone please help?"
                    },
                    {
                        "username": "yepyepyepyep",
                        "content": "I\\'m not sure why my C++ solution with min heap doesn\\'t work. It passes all test cases until 133/135.\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    int popSmallest() {\\n        if(minHeap.empty())\\n        {\\n            currSmallest++;\\n            return currSmallest - 1;\\n        }\\n        int minHeapTop = minHeap.top();\\n        minHeap.pop();\\n        return minHeapTop;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < currSmallest)\\n            minHeap.push(num);\\n    }\\nprivate:\\n    int currSmallest;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n};"
                    },
                    {
                        "username": "itzzme_pk",
                        "content": "Based on the constraints, what is the maximum element that can possibly be popped?\\n\\nwhat is the use of above mentioned condition? I think my code works good even if there is infinte pops"
                    }
                ]
            },
            {
                "id": 1873718,
                "content": [
                    {
                        "username": "chinmaynirwan",
                        "content": "hey can any one tell me what is wrong in my code , i am getting wrong ans for 134th testcase\\n\\n  public:\\n     int frd=1;\\n     unordered_set<int> s;\\n     set<int> ad;\\n\\n    SmallestInfiniteSet() {\\n       \\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(s.empty()){\\n\\n            s.insert(frd);\\n            frd++;\\n        }else{\\n            if(ad.empty()){\\n\\n                s.insert(frd);\\n                frd++;\\n                return frd-1;\\n            }else{\\n                \\n                int ans= *ad.begin();\\n                s.insert(ans);\\n                ad.erase(ans);\\n\\n                return ans;\\n            }\\n        }\\n       \\n        return frd-1;\\n       \\n    }\\n    \\n    void addBack(int num) {\\n        \\n        if(s.find(num)!=s.end()){\\n\\n            ad.insert(num);\\n            s.erase(num);\\n            \\n            }\\n    }"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "class SmallestInfiniteSet {\n   priority_queue<int, vector<int>, greater<int>> pq;\n    int small;\npublic:\n    SmallestInfiniteSet() {\n        small = 1;\n    }\n    \n    int popSmallest() {\n        int ans;\n        if(pq.size())\n        {\n            ans = pq.top();\n            pq.pop();\n        }\n        else\n        {\n            ans = small;\n            small ++;\n        }\n        return ans;\n    }\n    \n    void addBack(int num) {\n        if(num < small)\n            pq.push(num);\n    }\n};\n\n\n\nwhy it is showing wrong ans ? and if i use set instead of priority queue its showing right ans, why ?"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Is it really what question's asking?\n\n`\n`class SmallestInfiniteSet {\npublic:\n    set<int> s;\n    SmallestInfiniteSet() {\n        for(int i=1; i<=1000; i++){\n            s.insert(i);\n        }\n    }\n    \n    int popSmallest() {\n      \n        int k = *s.begin();\n        s.erase(s.begin());\n        return k;   \n    }\n    \n    void addBack(int num) {\n        s.insert(num);\n    }\n};`\n`"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Can anyone check what is wrong in my code. It seems that the logic is correct atleast to me?\n\n```\nclass SmallestInfiniteSet:\n\n    def __init__(self):\n        self.heap = []\n        self.last = 1\n        heapify(self.heap)\n\n    def popSmallest(self) -> int:\n        if self.heap:\n            return heappop(self.heap)\n            \n        self.last += 1\n        return self.last - 1\n\n    def addBack(self, num: int) -> None:\n        if num < self.last:\n            heappush(self.heap, num)\n```"
                    },
                    {
                        "username": "hacker363",
                        "content": "class SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.removed = []\\n        self.minimum = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.l:\\n            m = min(self.l)\\n            self.l=[]\\n            return m\\n        self.removed.append(self.minimum)\\n        self.minimum += 1\\n        return self.minimum - 1\\n\\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.removed:\\n            self.l.append(num)\\nCan anybody please please tell me why my code only passes(133/135) test cases"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "Isn\\'t implementing custom heap best solution hear? Why are people using built-in DS and functions?"
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "I passed 133/135 testcases idk whu it's not working, help \n```\nclass SmallestInfiniteSet {\npublic:\n    vector<int> push;\n    int g=1;\n    int popSmallest() {\n        if(push.empty() || g<=push[0]) return g++;\n        else{\n            int x=push[0];\n            push.erase(push.begin());\n            return x;\n        }\n        \n    }\n    void addBack(int num) {\n        if(num<g){\n            int i=0,f=1;\n            for(i=0;i<push.size();++i){\n                if(num<push[i]){\n                    push.insert(push.begin()+i,num);\n                    f=0;\n                    break;\n                }\n            }\n            if(f) push.push_back(num);\n        }\n    }\n};\n```\n"
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "public:\\n    priority_queue<int, std::vector<int>, std::greater<int>>p;\\n    SmallestInfiniteSet() {\\n        for(int i=0;i<=1000;i++){\\n            p.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        if(!p.empty()){\\n            int smal = p.top();\\n            p.pop();\\n            return smal;\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(p.find(num)==p.end())   <------------------------------------\\n        p.push(num);\\n    }\\n\\nIn addBack func, I\\'m getting error: \\'find\\' cant be used. Can someone please help?"
                    },
                    {
                        "username": "yepyepyepyep",
                        "content": "I\\'m not sure why my C++ solution with min heap doesn\\'t work. It passes all test cases until 133/135.\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    int popSmallest() {\\n        if(minHeap.empty())\\n        {\\n            currSmallest++;\\n            return currSmallest - 1;\\n        }\\n        int minHeapTop = minHeap.top();\\n        minHeap.pop();\\n        return minHeapTop;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < currSmallest)\\n            minHeap.push(num);\\n    }\\nprivate:\\n    int currSmallest;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n};"
                    },
                    {
                        "username": "itzzme_pk",
                        "content": "Based on the constraints, what is the maximum element that can possibly be popped?\\n\\nwhat is the use of above mentioned condition? I think my code works good even if there is infinte pops"
                    }
                ]
            },
            {
                "id": 2036110,
                "content": [
                    {
                        "username": "chinmaynirwan",
                        "content": "hey can any one tell me what is wrong in my code , i am getting wrong ans for 134th testcase\\n\\n  public:\\n     int frd=1;\\n     unordered_set<int> s;\\n     set<int> ad;\\n\\n    SmallestInfiniteSet() {\\n       \\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(s.empty()){\\n\\n            s.insert(frd);\\n            frd++;\\n        }else{\\n            if(ad.empty()){\\n\\n                s.insert(frd);\\n                frd++;\\n                return frd-1;\\n            }else{\\n                \\n                int ans= *ad.begin();\\n                s.insert(ans);\\n                ad.erase(ans);\\n\\n                return ans;\\n            }\\n        }\\n       \\n        return frd-1;\\n       \\n    }\\n    \\n    void addBack(int num) {\\n        \\n        if(s.find(num)!=s.end()){\\n\\n            ad.insert(num);\\n            s.erase(num);\\n            \\n            }\\n    }"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "class SmallestInfiniteSet {\n   priority_queue<int, vector<int>, greater<int>> pq;\n    int small;\npublic:\n    SmallestInfiniteSet() {\n        small = 1;\n    }\n    \n    int popSmallest() {\n        int ans;\n        if(pq.size())\n        {\n            ans = pq.top();\n            pq.pop();\n        }\n        else\n        {\n            ans = small;\n            small ++;\n        }\n        return ans;\n    }\n    \n    void addBack(int num) {\n        if(num < small)\n            pq.push(num);\n    }\n};\n\n\n\nwhy it is showing wrong ans ? and if i use set instead of priority queue its showing right ans, why ?"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Is it really what question's asking?\n\n`\n`class SmallestInfiniteSet {\npublic:\n    set<int> s;\n    SmallestInfiniteSet() {\n        for(int i=1; i<=1000; i++){\n            s.insert(i);\n        }\n    }\n    \n    int popSmallest() {\n      \n        int k = *s.begin();\n        s.erase(s.begin());\n        return k;   \n    }\n    \n    void addBack(int num) {\n        s.insert(num);\n    }\n};`\n`"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Can anyone check what is wrong in my code. It seems that the logic is correct atleast to me?\n\n```\nclass SmallestInfiniteSet:\n\n    def __init__(self):\n        self.heap = []\n        self.last = 1\n        heapify(self.heap)\n\n    def popSmallest(self) -> int:\n        if self.heap:\n            return heappop(self.heap)\n            \n        self.last += 1\n        return self.last - 1\n\n    def addBack(self, num: int) -> None:\n        if num < self.last:\n            heappush(self.heap, num)\n```"
                    },
                    {
                        "username": "hacker363",
                        "content": "class SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.removed = []\\n        self.minimum = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.l:\\n            m = min(self.l)\\n            self.l=[]\\n            return m\\n        self.removed.append(self.minimum)\\n        self.minimum += 1\\n        return self.minimum - 1\\n\\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.removed:\\n            self.l.append(num)\\nCan anybody please please tell me why my code only passes(133/135) test cases"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "Isn\\'t implementing custom heap best solution hear? Why are people using built-in DS and functions?"
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "I passed 133/135 testcases idk whu it's not working, help \n```\nclass SmallestInfiniteSet {\npublic:\n    vector<int> push;\n    int g=1;\n    int popSmallest() {\n        if(push.empty() || g<=push[0]) return g++;\n        else{\n            int x=push[0];\n            push.erase(push.begin());\n            return x;\n        }\n        \n    }\n    void addBack(int num) {\n        if(num<g){\n            int i=0,f=1;\n            for(i=0;i<push.size();++i){\n                if(num<push[i]){\n                    push.insert(push.begin()+i,num);\n                    f=0;\n                    break;\n                }\n            }\n            if(f) push.push_back(num);\n        }\n    }\n};\n```\n"
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "public:\\n    priority_queue<int, std::vector<int>, std::greater<int>>p;\\n    SmallestInfiniteSet() {\\n        for(int i=0;i<=1000;i++){\\n            p.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        if(!p.empty()){\\n            int smal = p.top();\\n            p.pop();\\n            return smal;\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(p.find(num)==p.end())   <------------------------------------\\n        p.push(num);\\n    }\\n\\nIn addBack func, I\\'m getting error: \\'find\\' cant be used. Can someone please help?"
                    },
                    {
                        "username": "yepyepyepyep",
                        "content": "I\\'m not sure why my C++ solution with min heap doesn\\'t work. It passes all test cases until 133/135.\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    int popSmallest() {\\n        if(minHeap.empty())\\n        {\\n            currSmallest++;\\n            return currSmallest - 1;\\n        }\\n        int minHeapTop = minHeap.top();\\n        minHeap.pop();\\n        return minHeapTop;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < currSmallest)\\n            minHeap.push(num);\\n    }\\nprivate:\\n    int currSmallest;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n};"
                    },
                    {
                        "username": "itzzme_pk",
                        "content": "Based on the constraints, what is the maximum element that can possibly be popped?\\n\\nwhat is the use of above mentioned condition? I think my code works good even if there is infinte pops"
                    }
                ]
            },
            {
                "id": 1985936,
                "content": [
                    {
                        "username": "chinmaynirwan",
                        "content": "hey can any one tell me what is wrong in my code , i am getting wrong ans for 134th testcase\\n\\n  public:\\n     int frd=1;\\n     unordered_set<int> s;\\n     set<int> ad;\\n\\n    SmallestInfiniteSet() {\\n       \\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(s.empty()){\\n\\n            s.insert(frd);\\n            frd++;\\n        }else{\\n            if(ad.empty()){\\n\\n                s.insert(frd);\\n                frd++;\\n                return frd-1;\\n            }else{\\n                \\n                int ans= *ad.begin();\\n                s.insert(ans);\\n                ad.erase(ans);\\n\\n                return ans;\\n            }\\n        }\\n       \\n        return frd-1;\\n       \\n    }\\n    \\n    void addBack(int num) {\\n        \\n        if(s.find(num)!=s.end()){\\n\\n            ad.insert(num);\\n            s.erase(num);\\n            \\n            }\\n    }"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "class SmallestInfiniteSet {\n   priority_queue<int, vector<int>, greater<int>> pq;\n    int small;\npublic:\n    SmallestInfiniteSet() {\n        small = 1;\n    }\n    \n    int popSmallest() {\n        int ans;\n        if(pq.size())\n        {\n            ans = pq.top();\n            pq.pop();\n        }\n        else\n        {\n            ans = small;\n            small ++;\n        }\n        return ans;\n    }\n    \n    void addBack(int num) {\n        if(num < small)\n            pq.push(num);\n    }\n};\n\n\n\nwhy it is showing wrong ans ? and if i use set instead of priority queue its showing right ans, why ?"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Is it really what question's asking?\n\n`\n`class SmallestInfiniteSet {\npublic:\n    set<int> s;\n    SmallestInfiniteSet() {\n        for(int i=1; i<=1000; i++){\n            s.insert(i);\n        }\n    }\n    \n    int popSmallest() {\n      \n        int k = *s.begin();\n        s.erase(s.begin());\n        return k;   \n    }\n    \n    void addBack(int num) {\n        s.insert(num);\n    }\n};`\n`"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Can anyone check what is wrong in my code. It seems that the logic is correct atleast to me?\n\n```\nclass SmallestInfiniteSet:\n\n    def __init__(self):\n        self.heap = []\n        self.last = 1\n        heapify(self.heap)\n\n    def popSmallest(self) -> int:\n        if self.heap:\n            return heappop(self.heap)\n            \n        self.last += 1\n        return self.last - 1\n\n    def addBack(self, num: int) -> None:\n        if num < self.last:\n            heappush(self.heap, num)\n```"
                    },
                    {
                        "username": "hacker363",
                        "content": "class SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.removed = []\\n        self.minimum = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.l:\\n            m = min(self.l)\\n            self.l=[]\\n            return m\\n        self.removed.append(self.minimum)\\n        self.minimum += 1\\n        return self.minimum - 1\\n\\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.removed:\\n            self.l.append(num)\\nCan anybody please please tell me why my code only passes(133/135) test cases"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "Isn\\'t implementing custom heap best solution hear? Why are people using built-in DS and functions?"
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "I passed 133/135 testcases idk whu it's not working, help \n```\nclass SmallestInfiniteSet {\npublic:\n    vector<int> push;\n    int g=1;\n    int popSmallest() {\n        if(push.empty() || g<=push[0]) return g++;\n        else{\n            int x=push[0];\n            push.erase(push.begin());\n            return x;\n        }\n        \n    }\n    void addBack(int num) {\n        if(num<g){\n            int i=0,f=1;\n            for(i=0;i<push.size();++i){\n                if(num<push[i]){\n                    push.insert(push.begin()+i,num);\n                    f=0;\n                    break;\n                }\n            }\n            if(f) push.push_back(num);\n        }\n    }\n};\n```\n"
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "public:\\n    priority_queue<int, std::vector<int>, std::greater<int>>p;\\n    SmallestInfiniteSet() {\\n        for(int i=0;i<=1000;i++){\\n            p.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        if(!p.empty()){\\n            int smal = p.top();\\n            p.pop();\\n            return smal;\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(p.find(num)==p.end())   <------------------------------------\\n        p.push(num);\\n    }\\n\\nIn addBack func, I\\'m getting error: \\'find\\' cant be used. Can someone please help?"
                    },
                    {
                        "username": "yepyepyepyep",
                        "content": "I\\'m not sure why my C++ solution with min heap doesn\\'t work. It passes all test cases until 133/135.\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    int popSmallest() {\\n        if(minHeap.empty())\\n        {\\n            currSmallest++;\\n            return currSmallest - 1;\\n        }\\n        int minHeapTop = minHeap.top();\\n        minHeap.pop();\\n        return minHeapTop;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < currSmallest)\\n            minHeap.push(num);\\n    }\\nprivate:\\n    int currSmallest;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n};"
                    },
                    {
                        "username": "itzzme_pk",
                        "content": "Based on the constraints, what is the maximum element that can possibly be popped?\\n\\nwhat is the use of above mentioned condition? I think my code works good even if there is infinte pops"
                    }
                ]
            },
            {
                "id": 1981779,
                "content": [
                    {
                        "username": "chinmaynirwan",
                        "content": "hey can any one tell me what is wrong in my code , i am getting wrong ans for 134th testcase\\n\\n  public:\\n     int frd=1;\\n     unordered_set<int> s;\\n     set<int> ad;\\n\\n    SmallestInfiniteSet() {\\n       \\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(s.empty()){\\n\\n            s.insert(frd);\\n            frd++;\\n        }else{\\n            if(ad.empty()){\\n\\n                s.insert(frd);\\n                frd++;\\n                return frd-1;\\n            }else{\\n                \\n                int ans= *ad.begin();\\n                s.insert(ans);\\n                ad.erase(ans);\\n\\n                return ans;\\n            }\\n        }\\n       \\n        return frd-1;\\n       \\n    }\\n    \\n    void addBack(int num) {\\n        \\n        if(s.find(num)!=s.end()){\\n\\n            ad.insert(num);\\n            s.erase(num);\\n            \\n            }\\n    }"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "class SmallestInfiniteSet {\n   priority_queue<int, vector<int>, greater<int>> pq;\n    int small;\npublic:\n    SmallestInfiniteSet() {\n        small = 1;\n    }\n    \n    int popSmallest() {\n        int ans;\n        if(pq.size())\n        {\n            ans = pq.top();\n            pq.pop();\n        }\n        else\n        {\n            ans = small;\n            small ++;\n        }\n        return ans;\n    }\n    \n    void addBack(int num) {\n        if(num < small)\n            pq.push(num);\n    }\n};\n\n\n\nwhy it is showing wrong ans ? and if i use set instead of priority queue its showing right ans, why ?"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Is it really what question's asking?\n\n`\n`class SmallestInfiniteSet {\npublic:\n    set<int> s;\n    SmallestInfiniteSet() {\n        for(int i=1; i<=1000; i++){\n            s.insert(i);\n        }\n    }\n    \n    int popSmallest() {\n      \n        int k = *s.begin();\n        s.erase(s.begin());\n        return k;   \n    }\n    \n    void addBack(int num) {\n        s.insert(num);\n    }\n};`\n`"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Can anyone check what is wrong in my code. It seems that the logic is correct atleast to me?\n\n```\nclass SmallestInfiniteSet:\n\n    def __init__(self):\n        self.heap = []\n        self.last = 1\n        heapify(self.heap)\n\n    def popSmallest(self) -> int:\n        if self.heap:\n            return heappop(self.heap)\n            \n        self.last += 1\n        return self.last - 1\n\n    def addBack(self, num: int) -> None:\n        if num < self.last:\n            heappush(self.heap, num)\n```"
                    },
                    {
                        "username": "hacker363",
                        "content": "class SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.removed = []\\n        self.minimum = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.l:\\n            m = min(self.l)\\n            self.l=[]\\n            return m\\n        self.removed.append(self.minimum)\\n        self.minimum += 1\\n        return self.minimum - 1\\n\\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.removed:\\n            self.l.append(num)\\nCan anybody please please tell me why my code only passes(133/135) test cases"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "Isn\\'t implementing custom heap best solution hear? Why are people using built-in DS and functions?"
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "I passed 133/135 testcases idk whu it's not working, help \n```\nclass SmallestInfiniteSet {\npublic:\n    vector<int> push;\n    int g=1;\n    int popSmallest() {\n        if(push.empty() || g<=push[0]) return g++;\n        else{\n            int x=push[0];\n            push.erase(push.begin());\n            return x;\n        }\n        \n    }\n    void addBack(int num) {\n        if(num<g){\n            int i=0,f=1;\n            for(i=0;i<push.size();++i){\n                if(num<push[i]){\n                    push.insert(push.begin()+i,num);\n                    f=0;\n                    break;\n                }\n            }\n            if(f) push.push_back(num);\n        }\n    }\n};\n```\n"
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "public:\\n    priority_queue<int, std::vector<int>, std::greater<int>>p;\\n    SmallestInfiniteSet() {\\n        for(int i=0;i<=1000;i++){\\n            p.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        if(!p.empty()){\\n            int smal = p.top();\\n            p.pop();\\n            return smal;\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(p.find(num)==p.end())   <------------------------------------\\n        p.push(num);\\n    }\\n\\nIn addBack func, I\\'m getting error: \\'find\\' cant be used. Can someone please help?"
                    },
                    {
                        "username": "yepyepyepyep",
                        "content": "I\\'m not sure why my C++ solution with min heap doesn\\'t work. It passes all test cases until 133/135.\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    int popSmallest() {\\n        if(minHeap.empty())\\n        {\\n            currSmallest++;\\n            return currSmallest - 1;\\n        }\\n        int minHeapTop = minHeap.top();\\n        minHeap.pop();\\n        return minHeapTop;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < currSmallest)\\n            minHeap.push(num);\\n    }\\nprivate:\\n    int currSmallest;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n};"
                    },
                    {
                        "username": "itzzme_pk",
                        "content": "Based on the constraints, what is the maximum element that can possibly be popped?\\n\\nwhat is the use of above mentioned condition? I think my code works good even if there is infinte pops"
                    }
                ]
            },
            {
                "id": 1918582,
                "content": [
                    {
                        "username": "chinmaynirwan",
                        "content": "hey can any one tell me what is wrong in my code , i am getting wrong ans for 134th testcase\\n\\n  public:\\n     int frd=1;\\n     unordered_set<int> s;\\n     set<int> ad;\\n\\n    SmallestInfiniteSet() {\\n       \\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(s.empty()){\\n\\n            s.insert(frd);\\n            frd++;\\n        }else{\\n            if(ad.empty()){\\n\\n                s.insert(frd);\\n                frd++;\\n                return frd-1;\\n            }else{\\n                \\n                int ans= *ad.begin();\\n                s.insert(ans);\\n                ad.erase(ans);\\n\\n                return ans;\\n            }\\n        }\\n       \\n        return frd-1;\\n       \\n    }\\n    \\n    void addBack(int num) {\\n        \\n        if(s.find(num)!=s.end()){\\n\\n            ad.insert(num);\\n            s.erase(num);\\n            \\n            }\\n    }"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "class SmallestInfiniteSet {\n   priority_queue<int, vector<int>, greater<int>> pq;\n    int small;\npublic:\n    SmallestInfiniteSet() {\n        small = 1;\n    }\n    \n    int popSmallest() {\n        int ans;\n        if(pq.size())\n        {\n            ans = pq.top();\n            pq.pop();\n        }\n        else\n        {\n            ans = small;\n            small ++;\n        }\n        return ans;\n    }\n    \n    void addBack(int num) {\n        if(num < small)\n            pq.push(num);\n    }\n};\n\n\n\nwhy it is showing wrong ans ? and if i use set instead of priority queue its showing right ans, why ?"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Is it really what question's asking?\n\n`\n`class SmallestInfiniteSet {\npublic:\n    set<int> s;\n    SmallestInfiniteSet() {\n        for(int i=1; i<=1000; i++){\n            s.insert(i);\n        }\n    }\n    \n    int popSmallest() {\n      \n        int k = *s.begin();\n        s.erase(s.begin());\n        return k;   \n    }\n    \n    void addBack(int num) {\n        s.insert(num);\n    }\n};`\n`"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Can anyone check what is wrong in my code. It seems that the logic is correct atleast to me?\n\n```\nclass SmallestInfiniteSet:\n\n    def __init__(self):\n        self.heap = []\n        self.last = 1\n        heapify(self.heap)\n\n    def popSmallest(self) -> int:\n        if self.heap:\n            return heappop(self.heap)\n            \n        self.last += 1\n        return self.last - 1\n\n    def addBack(self, num: int) -> None:\n        if num < self.last:\n            heappush(self.heap, num)\n```"
                    },
                    {
                        "username": "hacker363",
                        "content": "class SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.removed = []\\n        self.minimum = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.l:\\n            m = min(self.l)\\n            self.l=[]\\n            return m\\n        self.removed.append(self.minimum)\\n        self.minimum += 1\\n        return self.minimum - 1\\n\\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.removed:\\n            self.l.append(num)\\nCan anybody please please tell me why my code only passes(133/135) test cases"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "Isn\\'t implementing custom heap best solution hear? Why are people using built-in DS and functions?"
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "I passed 133/135 testcases idk whu it's not working, help \n```\nclass SmallestInfiniteSet {\npublic:\n    vector<int> push;\n    int g=1;\n    int popSmallest() {\n        if(push.empty() || g<=push[0]) return g++;\n        else{\n            int x=push[0];\n            push.erase(push.begin());\n            return x;\n        }\n        \n    }\n    void addBack(int num) {\n        if(num<g){\n            int i=0,f=1;\n            for(i=0;i<push.size();++i){\n                if(num<push[i]){\n                    push.insert(push.begin()+i,num);\n                    f=0;\n                    break;\n                }\n            }\n            if(f) push.push_back(num);\n        }\n    }\n};\n```\n"
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "public:\\n    priority_queue<int, std::vector<int>, std::greater<int>>p;\\n    SmallestInfiniteSet() {\\n        for(int i=0;i<=1000;i++){\\n            p.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        if(!p.empty()){\\n            int smal = p.top();\\n            p.pop();\\n            return smal;\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(p.find(num)==p.end())   <------------------------------------\\n        p.push(num);\\n    }\\n\\nIn addBack func, I\\'m getting error: \\'find\\' cant be used. Can someone please help?"
                    },
                    {
                        "username": "yepyepyepyep",
                        "content": "I\\'m not sure why my C++ solution with min heap doesn\\'t work. It passes all test cases until 133/135.\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    int popSmallest() {\\n        if(minHeap.empty())\\n        {\\n            currSmallest++;\\n            return currSmallest - 1;\\n        }\\n        int minHeapTop = minHeap.top();\\n        minHeap.pop();\\n        return minHeapTop;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < currSmallest)\\n            minHeap.push(num);\\n    }\\nprivate:\\n    int currSmallest;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n};"
                    },
                    {
                        "username": "itzzme_pk",
                        "content": "Based on the constraints, what is the maximum element that can possibly be popped?\\n\\nwhat is the use of above mentioned condition? I think my code works good even if there is infinte pops"
                    }
                ]
            },
            {
                "id": 1874298,
                "content": [
                    {
                        "username": "chinmaynirwan",
                        "content": "hey can any one tell me what is wrong in my code , i am getting wrong ans for 134th testcase\\n\\n  public:\\n     int frd=1;\\n     unordered_set<int> s;\\n     set<int> ad;\\n\\n    SmallestInfiniteSet() {\\n       \\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(s.empty()){\\n\\n            s.insert(frd);\\n            frd++;\\n        }else{\\n            if(ad.empty()){\\n\\n                s.insert(frd);\\n                frd++;\\n                return frd-1;\\n            }else{\\n                \\n                int ans= *ad.begin();\\n                s.insert(ans);\\n                ad.erase(ans);\\n\\n                return ans;\\n            }\\n        }\\n       \\n        return frd-1;\\n       \\n    }\\n    \\n    void addBack(int num) {\\n        \\n        if(s.find(num)!=s.end()){\\n\\n            ad.insert(num);\\n            s.erase(num);\\n            \\n            }\\n    }"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "class SmallestInfiniteSet {\n   priority_queue<int, vector<int>, greater<int>> pq;\n    int small;\npublic:\n    SmallestInfiniteSet() {\n        small = 1;\n    }\n    \n    int popSmallest() {\n        int ans;\n        if(pq.size())\n        {\n            ans = pq.top();\n            pq.pop();\n        }\n        else\n        {\n            ans = small;\n            small ++;\n        }\n        return ans;\n    }\n    \n    void addBack(int num) {\n        if(num < small)\n            pq.push(num);\n    }\n};\n\n\n\nwhy it is showing wrong ans ? and if i use set instead of priority queue its showing right ans, why ?"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Is it really what question's asking?\n\n`\n`class SmallestInfiniteSet {\npublic:\n    set<int> s;\n    SmallestInfiniteSet() {\n        for(int i=1; i<=1000; i++){\n            s.insert(i);\n        }\n    }\n    \n    int popSmallest() {\n      \n        int k = *s.begin();\n        s.erase(s.begin());\n        return k;   \n    }\n    \n    void addBack(int num) {\n        s.insert(num);\n    }\n};`\n`"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Can anyone check what is wrong in my code. It seems that the logic is correct atleast to me?\n\n```\nclass SmallestInfiniteSet:\n\n    def __init__(self):\n        self.heap = []\n        self.last = 1\n        heapify(self.heap)\n\n    def popSmallest(self) -> int:\n        if self.heap:\n            return heappop(self.heap)\n            \n        self.last += 1\n        return self.last - 1\n\n    def addBack(self, num: int) -> None:\n        if num < self.last:\n            heappush(self.heap, num)\n```"
                    },
                    {
                        "username": "hacker363",
                        "content": "class SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.removed = []\\n        self.minimum = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.l:\\n            m = min(self.l)\\n            self.l=[]\\n            return m\\n        self.removed.append(self.minimum)\\n        self.minimum += 1\\n        return self.minimum - 1\\n\\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.removed:\\n            self.l.append(num)\\nCan anybody please please tell me why my code only passes(133/135) test cases"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "Isn\\'t implementing custom heap best solution hear? Why are people using built-in DS and functions?"
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "I passed 133/135 testcases idk whu it's not working, help \n```\nclass SmallestInfiniteSet {\npublic:\n    vector<int> push;\n    int g=1;\n    int popSmallest() {\n        if(push.empty() || g<=push[0]) return g++;\n        else{\n            int x=push[0];\n            push.erase(push.begin());\n            return x;\n        }\n        \n    }\n    void addBack(int num) {\n        if(num<g){\n            int i=0,f=1;\n            for(i=0;i<push.size();++i){\n                if(num<push[i]){\n                    push.insert(push.begin()+i,num);\n                    f=0;\n                    break;\n                }\n            }\n            if(f) push.push_back(num);\n        }\n    }\n};\n```\n"
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "public:\\n    priority_queue<int, std::vector<int>, std::greater<int>>p;\\n    SmallestInfiniteSet() {\\n        for(int i=0;i<=1000;i++){\\n            p.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        if(!p.empty()){\\n            int smal = p.top();\\n            p.pop();\\n            return smal;\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(p.find(num)==p.end())   <------------------------------------\\n        p.push(num);\\n    }\\n\\nIn addBack func, I\\'m getting error: \\'find\\' cant be used. Can someone please help?"
                    },
                    {
                        "username": "yepyepyepyep",
                        "content": "I\\'m not sure why my C++ solution with min heap doesn\\'t work. It passes all test cases until 133/135.\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    int popSmallest() {\\n        if(minHeap.empty())\\n        {\\n            currSmallest++;\\n            return currSmallest - 1;\\n        }\\n        int minHeapTop = minHeap.top();\\n        minHeap.pop();\\n        return minHeapTop;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < currSmallest)\\n            minHeap.push(num);\\n    }\\nprivate:\\n    int currSmallest;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n};"
                    },
                    {
                        "username": "itzzme_pk",
                        "content": "Based on the constraints, what is the maximum element that can possibly be popped?\\n\\nwhat is the use of above mentioned condition? I think my code works good even if there is infinte pops"
                    }
                ]
            },
            {
                "id": 1874224,
                "content": [
                    {
                        "username": "chinmaynirwan",
                        "content": "hey can any one tell me what is wrong in my code , i am getting wrong ans for 134th testcase\\n\\n  public:\\n     int frd=1;\\n     unordered_set<int> s;\\n     set<int> ad;\\n\\n    SmallestInfiniteSet() {\\n       \\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(s.empty()){\\n\\n            s.insert(frd);\\n            frd++;\\n        }else{\\n            if(ad.empty()){\\n\\n                s.insert(frd);\\n                frd++;\\n                return frd-1;\\n            }else{\\n                \\n                int ans= *ad.begin();\\n                s.insert(ans);\\n                ad.erase(ans);\\n\\n                return ans;\\n            }\\n        }\\n       \\n        return frd-1;\\n       \\n    }\\n    \\n    void addBack(int num) {\\n        \\n        if(s.find(num)!=s.end()){\\n\\n            ad.insert(num);\\n            s.erase(num);\\n            \\n            }\\n    }"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "class SmallestInfiniteSet {\n   priority_queue<int, vector<int>, greater<int>> pq;\n    int small;\npublic:\n    SmallestInfiniteSet() {\n        small = 1;\n    }\n    \n    int popSmallest() {\n        int ans;\n        if(pq.size())\n        {\n            ans = pq.top();\n            pq.pop();\n        }\n        else\n        {\n            ans = small;\n            small ++;\n        }\n        return ans;\n    }\n    \n    void addBack(int num) {\n        if(num < small)\n            pq.push(num);\n    }\n};\n\n\n\nwhy it is showing wrong ans ? and if i use set instead of priority queue its showing right ans, why ?"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Is it really what question's asking?\n\n`\n`class SmallestInfiniteSet {\npublic:\n    set<int> s;\n    SmallestInfiniteSet() {\n        for(int i=1; i<=1000; i++){\n            s.insert(i);\n        }\n    }\n    \n    int popSmallest() {\n      \n        int k = *s.begin();\n        s.erase(s.begin());\n        return k;   \n    }\n    \n    void addBack(int num) {\n        s.insert(num);\n    }\n};`\n`"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Can anyone check what is wrong in my code. It seems that the logic is correct atleast to me?\n\n```\nclass SmallestInfiniteSet:\n\n    def __init__(self):\n        self.heap = []\n        self.last = 1\n        heapify(self.heap)\n\n    def popSmallest(self) -> int:\n        if self.heap:\n            return heappop(self.heap)\n            \n        self.last += 1\n        return self.last - 1\n\n    def addBack(self, num: int) -> None:\n        if num < self.last:\n            heappush(self.heap, num)\n```"
                    },
                    {
                        "username": "hacker363",
                        "content": "class SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.removed = []\\n        self.minimum = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.l:\\n            m = min(self.l)\\n            self.l=[]\\n            return m\\n        self.removed.append(self.minimum)\\n        self.minimum += 1\\n        return self.minimum - 1\\n\\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.removed:\\n            self.l.append(num)\\nCan anybody please please tell me why my code only passes(133/135) test cases"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "Isn\\'t implementing custom heap best solution hear? Why are people using built-in DS and functions?"
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "I passed 133/135 testcases idk whu it's not working, help \n```\nclass SmallestInfiniteSet {\npublic:\n    vector<int> push;\n    int g=1;\n    int popSmallest() {\n        if(push.empty() || g<=push[0]) return g++;\n        else{\n            int x=push[0];\n            push.erase(push.begin());\n            return x;\n        }\n        \n    }\n    void addBack(int num) {\n        if(num<g){\n            int i=0,f=1;\n            for(i=0;i<push.size();++i){\n                if(num<push[i]){\n                    push.insert(push.begin()+i,num);\n                    f=0;\n                    break;\n                }\n            }\n            if(f) push.push_back(num);\n        }\n    }\n};\n```\n"
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "public:\\n    priority_queue<int, std::vector<int>, std::greater<int>>p;\\n    SmallestInfiniteSet() {\\n        for(int i=0;i<=1000;i++){\\n            p.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        if(!p.empty()){\\n            int smal = p.top();\\n            p.pop();\\n            return smal;\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(p.find(num)==p.end())   <------------------------------------\\n        p.push(num);\\n    }\\n\\nIn addBack func, I\\'m getting error: \\'find\\' cant be used. Can someone please help?"
                    },
                    {
                        "username": "yepyepyepyep",
                        "content": "I\\'m not sure why my C++ solution with min heap doesn\\'t work. It passes all test cases until 133/135.\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    int popSmallest() {\\n        if(minHeap.empty())\\n        {\\n            currSmallest++;\\n            return currSmallest - 1;\\n        }\\n        int minHeapTop = minHeap.top();\\n        minHeap.pop();\\n        return minHeapTop;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < currSmallest)\\n            minHeap.push(num);\\n    }\\nprivate:\\n    int currSmallest;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n};"
                    },
                    {
                        "username": "itzzme_pk",
                        "content": "Based on the constraints, what is the maximum element that can possibly be popped?\\n\\nwhat is the use of above mentioned condition? I think my code works good even if there is infinte pops"
                    }
                ]
            },
            {
                "id": 1873969,
                "content": [
                    {
                        "username": "chinmaynirwan",
                        "content": "hey can any one tell me what is wrong in my code , i am getting wrong ans for 134th testcase\\n\\n  public:\\n     int frd=1;\\n     unordered_set<int> s;\\n     set<int> ad;\\n\\n    SmallestInfiniteSet() {\\n       \\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(s.empty()){\\n\\n            s.insert(frd);\\n            frd++;\\n        }else{\\n            if(ad.empty()){\\n\\n                s.insert(frd);\\n                frd++;\\n                return frd-1;\\n            }else{\\n                \\n                int ans= *ad.begin();\\n                s.insert(ans);\\n                ad.erase(ans);\\n\\n                return ans;\\n            }\\n        }\\n       \\n        return frd-1;\\n       \\n    }\\n    \\n    void addBack(int num) {\\n        \\n        if(s.find(num)!=s.end()){\\n\\n            ad.insert(num);\\n            s.erase(num);\\n            \\n            }\\n    }"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "class SmallestInfiniteSet {\n   priority_queue<int, vector<int>, greater<int>> pq;\n    int small;\npublic:\n    SmallestInfiniteSet() {\n        small = 1;\n    }\n    \n    int popSmallest() {\n        int ans;\n        if(pq.size())\n        {\n            ans = pq.top();\n            pq.pop();\n        }\n        else\n        {\n            ans = small;\n            small ++;\n        }\n        return ans;\n    }\n    \n    void addBack(int num) {\n        if(num < small)\n            pq.push(num);\n    }\n};\n\n\n\nwhy it is showing wrong ans ? and if i use set instead of priority queue its showing right ans, why ?"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Is it really what question's asking?\n\n`\n`class SmallestInfiniteSet {\npublic:\n    set<int> s;\n    SmallestInfiniteSet() {\n        for(int i=1; i<=1000; i++){\n            s.insert(i);\n        }\n    }\n    \n    int popSmallest() {\n      \n        int k = *s.begin();\n        s.erase(s.begin());\n        return k;   \n    }\n    \n    void addBack(int num) {\n        s.insert(num);\n    }\n};`\n`"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Can anyone check what is wrong in my code. It seems that the logic is correct atleast to me?\n\n```\nclass SmallestInfiniteSet:\n\n    def __init__(self):\n        self.heap = []\n        self.last = 1\n        heapify(self.heap)\n\n    def popSmallest(self) -> int:\n        if self.heap:\n            return heappop(self.heap)\n            \n        self.last += 1\n        return self.last - 1\n\n    def addBack(self, num: int) -> None:\n        if num < self.last:\n            heappush(self.heap, num)\n```"
                    },
                    {
                        "username": "hacker363",
                        "content": "class SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.removed = []\\n        self.minimum = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.l:\\n            m = min(self.l)\\n            self.l=[]\\n            return m\\n        self.removed.append(self.minimum)\\n        self.minimum += 1\\n        return self.minimum - 1\\n\\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.removed:\\n            self.l.append(num)\\nCan anybody please please tell me why my code only passes(133/135) test cases"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "Isn\\'t implementing custom heap best solution hear? Why are people using built-in DS and functions?"
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "I passed 133/135 testcases idk whu it's not working, help \n```\nclass SmallestInfiniteSet {\npublic:\n    vector<int> push;\n    int g=1;\n    int popSmallest() {\n        if(push.empty() || g<=push[0]) return g++;\n        else{\n            int x=push[0];\n            push.erase(push.begin());\n            return x;\n        }\n        \n    }\n    void addBack(int num) {\n        if(num<g){\n            int i=0,f=1;\n            for(i=0;i<push.size();++i){\n                if(num<push[i]){\n                    push.insert(push.begin()+i,num);\n                    f=0;\n                    break;\n                }\n            }\n            if(f) push.push_back(num);\n        }\n    }\n};\n```\n"
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "public:\\n    priority_queue<int, std::vector<int>, std::greater<int>>p;\\n    SmallestInfiniteSet() {\\n        for(int i=0;i<=1000;i++){\\n            p.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        if(!p.empty()){\\n            int smal = p.top();\\n            p.pop();\\n            return smal;\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(p.find(num)==p.end())   <------------------------------------\\n        p.push(num);\\n    }\\n\\nIn addBack func, I\\'m getting error: \\'find\\' cant be used. Can someone please help?"
                    },
                    {
                        "username": "yepyepyepyep",
                        "content": "I\\'m not sure why my C++ solution with min heap doesn\\'t work. It passes all test cases until 133/135.\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    int popSmallest() {\\n        if(minHeap.empty())\\n        {\\n            currSmallest++;\\n            return currSmallest - 1;\\n        }\\n        int minHeapTop = minHeap.top();\\n        minHeap.pop();\\n        return minHeapTop;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < currSmallest)\\n            minHeap.push(num);\\n    }\\nprivate:\\n    int currSmallest;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n};"
                    },
                    {
                        "username": "itzzme_pk",
                        "content": "Based on the constraints, what is the maximum element that can possibly be popped?\\n\\nwhat is the use of above mentioned condition? I think my code works good even if there is infinte pops"
                    }
                ]
            },
            {
                "id": 1873887,
                "content": [
                    {
                        "username": "chinmaynirwan",
                        "content": "hey can any one tell me what is wrong in my code , i am getting wrong ans for 134th testcase\\n\\n  public:\\n     int frd=1;\\n     unordered_set<int> s;\\n     set<int> ad;\\n\\n    SmallestInfiniteSet() {\\n       \\n    }\\n    \\n    int popSmallest() {\\n        \\n        if(s.empty()){\\n\\n            s.insert(frd);\\n            frd++;\\n        }else{\\n            if(ad.empty()){\\n\\n                s.insert(frd);\\n                frd++;\\n                return frd-1;\\n            }else{\\n                \\n                int ans= *ad.begin();\\n                s.insert(ans);\\n                ad.erase(ans);\\n\\n                return ans;\\n            }\\n        }\\n       \\n        return frd-1;\\n       \\n    }\\n    \\n    void addBack(int num) {\\n        \\n        if(s.find(num)!=s.end()){\\n\\n            ad.insert(num);\\n            s.erase(num);\\n            \\n            }\\n    }"
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "class SmallestInfiniteSet {\n   priority_queue<int, vector<int>, greater<int>> pq;\n    int small;\npublic:\n    SmallestInfiniteSet() {\n        small = 1;\n    }\n    \n    int popSmallest() {\n        int ans;\n        if(pq.size())\n        {\n            ans = pq.top();\n            pq.pop();\n        }\n        else\n        {\n            ans = small;\n            small ++;\n        }\n        return ans;\n    }\n    \n    void addBack(int num) {\n        if(num < small)\n            pq.push(num);\n    }\n};\n\n\n\nwhy it is showing wrong ans ? and if i use set instead of priority queue its showing right ans, why ?"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Is it really what question's asking?\n\n`\n`class SmallestInfiniteSet {\npublic:\n    set<int> s;\n    SmallestInfiniteSet() {\n        for(int i=1; i<=1000; i++){\n            s.insert(i);\n        }\n    }\n    \n    int popSmallest() {\n      \n        int k = *s.begin();\n        s.erase(s.begin());\n        return k;   \n    }\n    \n    void addBack(int num) {\n        s.insert(num);\n    }\n};`\n`"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Can anyone check what is wrong in my code. It seems that the logic is correct atleast to me?\n\n```\nclass SmallestInfiniteSet:\n\n    def __init__(self):\n        self.heap = []\n        self.last = 1\n        heapify(self.heap)\n\n    def popSmallest(self) -> int:\n        if self.heap:\n            return heappop(self.heap)\n            \n        self.last += 1\n        return self.last - 1\n\n    def addBack(self, num: int) -> None:\n        if num < self.last:\n            heappush(self.heap, num)\n```"
                    },
                    {
                        "username": "hacker363",
                        "content": "class SmallestInfiniteSet:\\n\\n    def __init__(self):\\n        self.l = []\\n        self.removed = []\\n        self.minimum = 1\\n\\n    def popSmallest(self) -> int:\\n        if self.l:\\n            m = min(self.l)\\n            self.l=[]\\n            return m\\n        self.removed.append(self.minimum)\\n        self.minimum += 1\\n        return self.minimum - 1\\n\\n\\n    def addBack(self, num: int) -> None:\\n        if num in self.removed:\\n            self.l.append(num)\\nCan anybody please please tell me why my code only passes(133/135) test cases"
                    },
                    {
                        "username": "TechBytesMe",
                        "content": "Isn\\'t implementing custom heap best solution hear? Why are people using built-in DS and functions?"
                    },
                    {
                        "username": "rinz0x0cruz",
                        "content": "I passed 133/135 testcases idk whu it's not working, help \n```\nclass SmallestInfiniteSet {\npublic:\n    vector<int> push;\n    int g=1;\n    int popSmallest() {\n        if(push.empty() || g<=push[0]) return g++;\n        else{\n            int x=push[0];\n            push.erase(push.begin());\n            return x;\n        }\n        \n    }\n    void addBack(int num) {\n        if(num<g){\n            int i=0,f=1;\n            for(i=0;i<push.size();++i){\n                if(num<push[i]){\n                    push.insert(push.begin()+i,num);\n                    f=0;\n                    break;\n                }\n            }\n            if(f) push.push_back(num);\n        }\n    }\n};\n```\n"
                    },
                    {
                        "username": "rishabhkochar27",
                        "content": "public:\\n    priority_queue<int, std::vector<int>, std::greater<int>>p;\\n    SmallestInfiniteSet() {\\n        for(int i=0;i<=1000;i++){\\n            p.push(i);\\n        }\\n    }\\n    \\n    int popSmallest() {\\n        if(!p.empty()){\\n            int smal = p.top();\\n            p.pop();\\n            return smal;\\n        }\\n        return -1;\\n    }\\n    \\n    void addBack(int num) {\\n        if(p.find(num)==p.end())   <------------------------------------\\n        p.push(num);\\n    }\\n\\nIn addBack func, I\\'m getting error: \\'find\\' cant be used. Can someone please help?"
                    },
                    {
                        "username": "yepyepyepyep",
                        "content": "I\\'m not sure why my C++ solution with min heap doesn\\'t work. It passes all test cases until 133/135.\\n\\n```\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n        currSmallest = 1;\\n    }\\n    int popSmallest() {\\n        if(minHeap.empty())\\n        {\\n            currSmallest++;\\n            return currSmallest - 1;\\n        }\\n        int minHeapTop = minHeap.top();\\n        minHeap.pop();\\n        return minHeapTop;\\n    }\\n    \\n    void addBack(int num) {\\n        if(num < currSmallest)\\n            minHeap.push(num);\\n    }\\nprivate:\\n    int currSmallest;\\n    priority_queue<int, vector<int>, greater<int>> minHeap;\\n};"
                    },
                    {
                        "username": "itzzme_pk",
                        "content": "Based on the constraints, what is the maximum element that can possibly be popped?\\n\\nwhat is the use of above mentioned condition? I think my code works good even if there is infinte pops"
                    }
                ]
            },
            {
                "id": 1873751,
                "content": [
                    {
                        "username": "PRINCEBharti",
                        "content": "class SmallestInfiniteSet {\n    HashMap<Integer, Boolean> map;\n    PriorityQueue<Integer> pq;\n    public SmallestInfiniteSet() {\n        HashMap<Integer, Boolean> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n    }\n    \n    public int popSmallest() {\n        int val = pq.remove();\n        map.remove(val);\n        return val;\n\n    }\n    \n    public void addBack(int num) {\n        if(!map.containsKey(num)){\n            map.put(num, true);\n            pq.add(num);\n        }\n    }\n}\n\n\nwhy i get error at (!map.containsKey(num))?"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "And don't forget fill your pq =)"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "Hello! You should remove HashMap<Integer, Boolean> and PriorityQueue in constructor =) \n\nmap = new HashMap<>();\npq = new PriorityQueue<>();"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "Why my C++ cannot pass all the tests?\\n\\n```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n    \\n    }\\n    \\n    int popSmallest() {\\n        if (q.size() > 0) {\\n            if (q.top() < currMin) {\\n                int res = q.top(); q.pop();\\n                return res;\\n            } else {\\n                int res = q.top(); q.pop();\\n                currMin ++;\\n                return res;   \\n            }\\n        } else {\\n            int res = currMin;\\n            currMin ++;\\n            return res;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currMin || (q.size() > 0 && num < q.top())) q.push(num);\\n    }\\n\\nprivate:\\n    int currMin = 1;\\n    struct compare {\\n        bool operator() (const int & a, const int & b) {\\n            return a > b;\\n        }\\n    };\\n    priority_queue<int, std::vector<int>, compare> q;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "I don't understand why people saying making it infinite set would make it more difficult.\njust add a variable  X which begins with 1.\nfor popping,  ++X if no element in heap , else heappop.\nfor pushing, add the number , if it is less than X and not in heap\n\nis it because of the space constraints we are considering infinite set to be a hard problem?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@prathmesh_24](/prathmesh_24) So basically we have only 2 operations, push and pop. both care only about the least element in the set. so i set the least element as 1 initially . whenever popped i increase the least element by 1( at first 1 gets popped etc).\nwhen the least element is  5 ( after 4 pop operations) , if push 1 is the operation, i cannot set least element as 1 since after that 2,3,4 etc will get popped.\nso i use a min heap for this case alone, when an element less than least element is pushed.\nso always if the min heap is not empty will have elements less than the least element. so while pop,\n\nfirst check if heap has more than 0 elements , if yes heap pop\nelse return least element and increase it by 1\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@jagan028](/A-V-Jagannathan) Could you please explain this approach in more detail, it sounds interesting."
                    },
                    {
                        "username": "Nishchal-Tiwari",
                        "content": "class SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    public SmallestInfiniteSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1;;i++){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n                return i;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hs.contains(num))\\n            hs.remove(num);\\n    }\\n}"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Question for python programmers: \\n\\nIf we are incorporating set checks (num should not be in the infinite set already etc), then why use a set and a heap (list) separately as in the official solution?! \\n\\nWhy not use a single min-heap and current integer only. t\\uD83E\\uDD14"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not exactly sure what you're asking. Your question doesn't really seem Python specific either.\n\nWith just a min-heap we might add duplicates to the heap. Imagine the lower bound is `100` and the heap is empty. We call `addBack(20)` and `addBack(20)`, then two calls to `popSmallest()`. They'll return `20` and `20` when they should return `20` and `100`.\n\nOr are you asking why we don't just prevent duplicates by searching the heap before pushing to it? Searching is O(N) where N is the number of elements in the heap. Pushing is O(log N) so we've ruined the time complexity and made `addBack()` O(N) instead of O(log N). Whereas an O(1) set check keeps `addBack()` as O(log N).\n\nThe LeetCode constraints are so small that O(N) runs fast, but it's not a good solution for larger constraints, and a smart interviewer definitely wouldn't like it."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "This question is \"Medium\" if you overlook the case of calling `addBack(int num)` with same `num` more than once before `popSmallest()` pop\\'s it "
                    },
                    {
                        "username": "andrewseva",
                        "content": "Brute force with \"array<int, 1000> allowed\" works due to too easy constrains"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need a boolean array to keep track of which numbers are present and a binary heap to keep track of the smallest remaining number in the array."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Just use a set?\\nThats it?"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "I was more stumbled by trying to find a catch, but there is none, it\\'s very-very straightforward and many easy questions can be way harder. \\nI think it should be a part of a series of questions. This one - easy, next one is the same, but there are no constraints, but limited to int, maybe by requesting ranges of numbers, so it can do millions of numbers at once4 and the hard one should be without any constraints so you may need to also implement your big int.\\n"
                    }
                ]
            },
            {
                "id": 1873689,
                "content": [
                    {
                        "username": "PRINCEBharti",
                        "content": "class SmallestInfiniteSet {\n    HashMap<Integer, Boolean> map;\n    PriorityQueue<Integer> pq;\n    public SmallestInfiniteSet() {\n        HashMap<Integer, Boolean> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n    }\n    \n    public int popSmallest() {\n        int val = pq.remove();\n        map.remove(val);\n        return val;\n\n    }\n    \n    public void addBack(int num) {\n        if(!map.containsKey(num)){\n            map.put(num, true);\n            pq.add(num);\n        }\n    }\n}\n\n\nwhy i get error at (!map.containsKey(num))?"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "And don't forget fill your pq =)"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "Hello! You should remove HashMap<Integer, Boolean> and PriorityQueue in constructor =) \n\nmap = new HashMap<>();\npq = new PriorityQueue<>();"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "Why my C++ cannot pass all the tests?\\n\\n```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n    \\n    }\\n    \\n    int popSmallest() {\\n        if (q.size() > 0) {\\n            if (q.top() < currMin) {\\n                int res = q.top(); q.pop();\\n                return res;\\n            } else {\\n                int res = q.top(); q.pop();\\n                currMin ++;\\n                return res;   \\n            }\\n        } else {\\n            int res = currMin;\\n            currMin ++;\\n            return res;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currMin || (q.size() > 0 && num < q.top())) q.push(num);\\n    }\\n\\nprivate:\\n    int currMin = 1;\\n    struct compare {\\n        bool operator() (const int & a, const int & b) {\\n            return a > b;\\n        }\\n    };\\n    priority_queue<int, std::vector<int>, compare> q;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "I don't understand why people saying making it infinite set would make it more difficult.\njust add a variable  X which begins with 1.\nfor popping,  ++X if no element in heap , else heappop.\nfor pushing, add the number , if it is less than X and not in heap\n\nis it because of the space constraints we are considering infinite set to be a hard problem?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@prathmesh_24](/prathmesh_24) So basically we have only 2 operations, push and pop. both care only about the least element in the set. so i set the least element as 1 initially . whenever popped i increase the least element by 1( at first 1 gets popped etc).\nwhen the least element is  5 ( after 4 pop operations) , if push 1 is the operation, i cannot set least element as 1 since after that 2,3,4 etc will get popped.\nso i use a min heap for this case alone, when an element less than least element is pushed.\nso always if the min heap is not empty will have elements less than the least element. so while pop,\n\nfirst check if heap has more than 0 elements , if yes heap pop\nelse return least element and increase it by 1\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@jagan028](/A-V-Jagannathan) Could you please explain this approach in more detail, it sounds interesting."
                    },
                    {
                        "username": "Nishchal-Tiwari",
                        "content": "class SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    public SmallestInfiniteSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1;;i++){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n                return i;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hs.contains(num))\\n            hs.remove(num);\\n    }\\n}"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Question for python programmers: \\n\\nIf we are incorporating set checks (num should not be in the infinite set already etc), then why use a set and a heap (list) separately as in the official solution?! \\n\\nWhy not use a single min-heap and current integer only. t\\uD83E\\uDD14"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not exactly sure what you're asking. Your question doesn't really seem Python specific either.\n\nWith just a min-heap we might add duplicates to the heap. Imagine the lower bound is `100` and the heap is empty. We call `addBack(20)` and `addBack(20)`, then two calls to `popSmallest()`. They'll return `20` and `20` when they should return `20` and `100`.\n\nOr are you asking why we don't just prevent duplicates by searching the heap before pushing to it? Searching is O(N) where N is the number of elements in the heap. Pushing is O(log N) so we've ruined the time complexity and made `addBack()` O(N) instead of O(log N). Whereas an O(1) set check keeps `addBack()` as O(log N).\n\nThe LeetCode constraints are so small that O(N) runs fast, but it's not a good solution for larger constraints, and a smart interviewer definitely wouldn't like it."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "This question is \"Medium\" if you overlook the case of calling `addBack(int num)` with same `num` more than once before `popSmallest()` pop\\'s it "
                    },
                    {
                        "username": "andrewseva",
                        "content": "Brute force with \"array<int, 1000> allowed\" works due to too easy constrains"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need a boolean array to keep track of which numbers are present and a binary heap to keep track of the smallest remaining number in the array."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Just use a set?\\nThats it?"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "I was more stumbled by trying to find a catch, but there is none, it\\'s very-very straightforward and many easy questions can be way harder. \\nI think it should be a part of a series of questions. This one - easy, next one is the same, but there are no constraints, but limited to int, maybe by requesting ranges of numbers, so it can do millions of numbers at once4 and the hard one should be without any constraints so you may need to also implement your big int.\\n"
                    }
                ]
            },
            {
                "id": 1873646,
                "content": [
                    {
                        "username": "PRINCEBharti",
                        "content": "class SmallestInfiniteSet {\n    HashMap<Integer, Boolean> map;\n    PriorityQueue<Integer> pq;\n    public SmallestInfiniteSet() {\n        HashMap<Integer, Boolean> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n    }\n    \n    public int popSmallest() {\n        int val = pq.remove();\n        map.remove(val);\n        return val;\n\n    }\n    \n    public void addBack(int num) {\n        if(!map.containsKey(num)){\n            map.put(num, true);\n            pq.add(num);\n        }\n    }\n}\n\n\nwhy i get error at (!map.containsKey(num))?"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "And don't forget fill your pq =)"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "Hello! You should remove HashMap<Integer, Boolean> and PriorityQueue in constructor =) \n\nmap = new HashMap<>();\npq = new PriorityQueue<>();"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "Why my C++ cannot pass all the tests?\\n\\n```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n    \\n    }\\n    \\n    int popSmallest() {\\n        if (q.size() > 0) {\\n            if (q.top() < currMin) {\\n                int res = q.top(); q.pop();\\n                return res;\\n            } else {\\n                int res = q.top(); q.pop();\\n                currMin ++;\\n                return res;   \\n            }\\n        } else {\\n            int res = currMin;\\n            currMin ++;\\n            return res;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currMin || (q.size() > 0 && num < q.top())) q.push(num);\\n    }\\n\\nprivate:\\n    int currMin = 1;\\n    struct compare {\\n        bool operator() (const int & a, const int & b) {\\n            return a > b;\\n        }\\n    };\\n    priority_queue<int, std::vector<int>, compare> q;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "I don't understand why people saying making it infinite set would make it more difficult.\njust add a variable  X which begins with 1.\nfor popping,  ++X if no element in heap , else heappop.\nfor pushing, add the number , if it is less than X and not in heap\n\nis it because of the space constraints we are considering infinite set to be a hard problem?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@prathmesh_24](/prathmesh_24) So basically we have only 2 operations, push and pop. both care only about the least element in the set. so i set the least element as 1 initially . whenever popped i increase the least element by 1( at first 1 gets popped etc).\nwhen the least element is  5 ( after 4 pop operations) , if push 1 is the operation, i cannot set least element as 1 since after that 2,3,4 etc will get popped.\nso i use a min heap for this case alone, when an element less than least element is pushed.\nso always if the min heap is not empty will have elements less than the least element. so while pop,\n\nfirst check if heap has more than 0 elements , if yes heap pop\nelse return least element and increase it by 1\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@jagan028](/A-V-Jagannathan) Could you please explain this approach in more detail, it sounds interesting."
                    },
                    {
                        "username": "Nishchal-Tiwari",
                        "content": "class SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    public SmallestInfiniteSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1;;i++){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n                return i;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hs.contains(num))\\n            hs.remove(num);\\n    }\\n}"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Question for python programmers: \\n\\nIf we are incorporating set checks (num should not be in the infinite set already etc), then why use a set and a heap (list) separately as in the official solution?! \\n\\nWhy not use a single min-heap and current integer only. t\\uD83E\\uDD14"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not exactly sure what you're asking. Your question doesn't really seem Python specific either.\n\nWith just a min-heap we might add duplicates to the heap. Imagine the lower bound is `100` and the heap is empty. We call `addBack(20)` and `addBack(20)`, then two calls to `popSmallest()`. They'll return `20` and `20` when they should return `20` and `100`.\n\nOr are you asking why we don't just prevent duplicates by searching the heap before pushing to it? Searching is O(N) where N is the number of elements in the heap. Pushing is O(log N) so we've ruined the time complexity and made `addBack()` O(N) instead of O(log N). Whereas an O(1) set check keeps `addBack()` as O(log N).\n\nThe LeetCode constraints are so small that O(N) runs fast, but it's not a good solution for larger constraints, and a smart interviewer definitely wouldn't like it."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "This question is \"Medium\" if you overlook the case of calling `addBack(int num)` with same `num` more than once before `popSmallest()` pop\\'s it "
                    },
                    {
                        "username": "andrewseva",
                        "content": "Brute force with \"array<int, 1000> allowed\" works due to too easy constrains"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need a boolean array to keep track of which numbers are present and a binary heap to keep track of the smallest remaining number in the array."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Just use a set?\\nThats it?"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "I was more stumbled by trying to find a catch, but there is none, it\\'s very-very straightforward and many easy questions can be way harder. \\nI think it should be a part of a series of questions. This one - easy, next one is the same, but there are no constraints, but limited to int, maybe by requesting ranges of numbers, so it can do millions of numbers at once4 and the hard one should be without any constraints so you may need to also implement your big int.\\n"
                    }
                ]
            },
            {
                "id": 1873631,
                "content": [
                    {
                        "username": "PRINCEBharti",
                        "content": "class SmallestInfiniteSet {\n    HashMap<Integer, Boolean> map;\n    PriorityQueue<Integer> pq;\n    public SmallestInfiniteSet() {\n        HashMap<Integer, Boolean> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n    }\n    \n    public int popSmallest() {\n        int val = pq.remove();\n        map.remove(val);\n        return val;\n\n    }\n    \n    public void addBack(int num) {\n        if(!map.containsKey(num)){\n            map.put(num, true);\n            pq.add(num);\n        }\n    }\n}\n\n\nwhy i get error at (!map.containsKey(num))?"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "And don't forget fill your pq =)"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "Hello! You should remove HashMap<Integer, Boolean> and PriorityQueue in constructor =) \n\nmap = new HashMap<>();\npq = new PriorityQueue<>();"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "Why my C++ cannot pass all the tests?\\n\\n```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n    \\n    }\\n    \\n    int popSmallest() {\\n        if (q.size() > 0) {\\n            if (q.top() < currMin) {\\n                int res = q.top(); q.pop();\\n                return res;\\n            } else {\\n                int res = q.top(); q.pop();\\n                currMin ++;\\n                return res;   \\n            }\\n        } else {\\n            int res = currMin;\\n            currMin ++;\\n            return res;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currMin || (q.size() > 0 && num < q.top())) q.push(num);\\n    }\\n\\nprivate:\\n    int currMin = 1;\\n    struct compare {\\n        bool operator() (const int & a, const int & b) {\\n            return a > b;\\n        }\\n    };\\n    priority_queue<int, std::vector<int>, compare> q;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "I don't understand why people saying making it infinite set would make it more difficult.\njust add a variable  X which begins with 1.\nfor popping,  ++X if no element in heap , else heappop.\nfor pushing, add the number , if it is less than X and not in heap\n\nis it because of the space constraints we are considering infinite set to be a hard problem?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@prathmesh_24](/prathmesh_24) So basically we have only 2 operations, push and pop. both care only about the least element in the set. so i set the least element as 1 initially . whenever popped i increase the least element by 1( at first 1 gets popped etc).\nwhen the least element is  5 ( after 4 pop operations) , if push 1 is the operation, i cannot set least element as 1 since after that 2,3,4 etc will get popped.\nso i use a min heap for this case alone, when an element less than least element is pushed.\nso always if the min heap is not empty will have elements less than the least element. so while pop,\n\nfirst check if heap has more than 0 elements , if yes heap pop\nelse return least element and increase it by 1\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@jagan028](/A-V-Jagannathan) Could you please explain this approach in more detail, it sounds interesting."
                    },
                    {
                        "username": "Nishchal-Tiwari",
                        "content": "class SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    public SmallestInfiniteSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1;;i++){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n                return i;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hs.contains(num))\\n            hs.remove(num);\\n    }\\n}"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Question for python programmers: \\n\\nIf we are incorporating set checks (num should not be in the infinite set already etc), then why use a set and a heap (list) separately as in the official solution?! \\n\\nWhy not use a single min-heap and current integer only. t\\uD83E\\uDD14"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not exactly sure what you're asking. Your question doesn't really seem Python specific either.\n\nWith just a min-heap we might add duplicates to the heap. Imagine the lower bound is `100` and the heap is empty. We call `addBack(20)` and `addBack(20)`, then two calls to `popSmallest()`. They'll return `20` and `20` when they should return `20` and `100`.\n\nOr are you asking why we don't just prevent duplicates by searching the heap before pushing to it? Searching is O(N) where N is the number of elements in the heap. Pushing is O(log N) so we've ruined the time complexity and made `addBack()` O(N) instead of O(log N). Whereas an O(1) set check keeps `addBack()` as O(log N).\n\nThe LeetCode constraints are so small that O(N) runs fast, but it's not a good solution for larger constraints, and a smart interviewer definitely wouldn't like it."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "This question is \"Medium\" if you overlook the case of calling `addBack(int num)` with same `num` more than once before `popSmallest()` pop\\'s it "
                    },
                    {
                        "username": "andrewseva",
                        "content": "Brute force with \"array<int, 1000> allowed\" works due to too easy constrains"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need a boolean array to keep track of which numbers are present and a binary heap to keep track of the smallest remaining number in the array."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Just use a set?\\nThats it?"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "I was more stumbled by trying to find a catch, but there is none, it\\'s very-very straightforward and many easy questions can be way harder. \\nI think it should be a part of a series of questions. This one - easy, next one is the same, but there are no constraints, but limited to int, maybe by requesting ranges of numbers, so it can do millions of numbers at once4 and the hard one should be without any constraints so you may need to also implement your big int.\\n"
                    }
                ]
            },
            {
                "id": 1873612,
                "content": [
                    {
                        "username": "PRINCEBharti",
                        "content": "class SmallestInfiniteSet {\n    HashMap<Integer, Boolean> map;\n    PriorityQueue<Integer> pq;\n    public SmallestInfiniteSet() {\n        HashMap<Integer, Boolean> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n    }\n    \n    public int popSmallest() {\n        int val = pq.remove();\n        map.remove(val);\n        return val;\n\n    }\n    \n    public void addBack(int num) {\n        if(!map.containsKey(num)){\n            map.put(num, true);\n            pq.add(num);\n        }\n    }\n}\n\n\nwhy i get error at (!map.containsKey(num))?"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "And don't forget fill your pq =)"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "Hello! You should remove HashMap<Integer, Boolean> and PriorityQueue in constructor =) \n\nmap = new HashMap<>();\npq = new PriorityQueue<>();"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "Why my C++ cannot pass all the tests?\\n\\n```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n    \\n    }\\n    \\n    int popSmallest() {\\n        if (q.size() > 0) {\\n            if (q.top() < currMin) {\\n                int res = q.top(); q.pop();\\n                return res;\\n            } else {\\n                int res = q.top(); q.pop();\\n                currMin ++;\\n                return res;   \\n            }\\n        } else {\\n            int res = currMin;\\n            currMin ++;\\n            return res;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currMin || (q.size() > 0 && num < q.top())) q.push(num);\\n    }\\n\\nprivate:\\n    int currMin = 1;\\n    struct compare {\\n        bool operator() (const int & a, const int & b) {\\n            return a > b;\\n        }\\n    };\\n    priority_queue<int, std::vector<int>, compare> q;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "I don't understand why people saying making it infinite set would make it more difficult.\njust add a variable  X which begins with 1.\nfor popping,  ++X if no element in heap , else heappop.\nfor pushing, add the number , if it is less than X and not in heap\n\nis it because of the space constraints we are considering infinite set to be a hard problem?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@prathmesh_24](/prathmesh_24) So basically we have only 2 operations, push and pop. both care only about the least element in the set. so i set the least element as 1 initially . whenever popped i increase the least element by 1( at first 1 gets popped etc).\nwhen the least element is  5 ( after 4 pop operations) , if push 1 is the operation, i cannot set least element as 1 since after that 2,3,4 etc will get popped.\nso i use a min heap for this case alone, when an element less than least element is pushed.\nso always if the min heap is not empty will have elements less than the least element. so while pop,\n\nfirst check if heap has more than 0 elements , if yes heap pop\nelse return least element and increase it by 1\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@jagan028](/A-V-Jagannathan) Could you please explain this approach in more detail, it sounds interesting."
                    },
                    {
                        "username": "Nishchal-Tiwari",
                        "content": "class SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    public SmallestInfiniteSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1;;i++){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n                return i;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hs.contains(num))\\n            hs.remove(num);\\n    }\\n}"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Question for python programmers: \\n\\nIf we are incorporating set checks (num should not be in the infinite set already etc), then why use a set and a heap (list) separately as in the official solution?! \\n\\nWhy not use a single min-heap and current integer only. t\\uD83E\\uDD14"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not exactly sure what you're asking. Your question doesn't really seem Python specific either.\n\nWith just a min-heap we might add duplicates to the heap. Imagine the lower bound is `100` and the heap is empty. We call `addBack(20)` and `addBack(20)`, then two calls to `popSmallest()`. They'll return `20` and `20` when they should return `20` and `100`.\n\nOr are you asking why we don't just prevent duplicates by searching the heap before pushing to it? Searching is O(N) where N is the number of elements in the heap. Pushing is O(log N) so we've ruined the time complexity and made `addBack()` O(N) instead of O(log N). Whereas an O(1) set check keeps `addBack()` as O(log N).\n\nThe LeetCode constraints are so small that O(N) runs fast, but it's not a good solution for larger constraints, and a smart interviewer definitely wouldn't like it."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "This question is \"Medium\" if you overlook the case of calling `addBack(int num)` with same `num` more than once before `popSmallest()` pop\\'s it "
                    },
                    {
                        "username": "andrewseva",
                        "content": "Brute force with \"array<int, 1000> allowed\" works due to too easy constrains"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need a boolean array to keep track of which numbers are present and a binary heap to keep track of the smallest remaining number in the array."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Just use a set?\\nThats it?"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "I was more stumbled by trying to find a catch, but there is none, it\\'s very-very straightforward and many easy questions can be way harder. \\nI think it should be a part of a series of questions. This one - easy, next one is the same, but there are no constraints, but limited to int, maybe by requesting ranges of numbers, so it can do millions of numbers at once4 and the hard one should be without any constraints so you may need to also implement your big int.\\n"
                    }
                ]
            },
            {
                "id": 1873575,
                "content": [
                    {
                        "username": "PRINCEBharti",
                        "content": "class SmallestInfiniteSet {\n    HashMap<Integer, Boolean> map;\n    PriorityQueue<Integer> pq;\n    public SmallestInfiniteSet() {\n        HashMap<Integer, Boolean> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n    }\n    \n    public int popSmallest() {\n        int val = pq.remove();\n        map.remove(val);\n        return val;\n\n    }\n    \n    public void addBack(int num) {\n        if(!map.containsKey(num)){\n            map.put(num, true);\n            pq.add(num);\n        }\n    }\n}\n\n\nwhy i get error at (!map.containsKey(num))?"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "And don't forget fill your pq =)"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "Hello! You should remove HashMap<Integer, Boolean> and PriorityQueue in constructor =) \n\nmap = new HashMap<>();\npq = new PriorityQueue<>();"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "Why my C++ cannot pass all the tests?\\n\\n```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n    \\n    }\\n    \\n    int popSmallest() {\\n        if (q.size() > 0) {\\n            if (q.top() < currMin) {\\n                int res = q.top(); q.pop();\\n                return res;\\n            } else {\\n                int res = q.top(); q.pop();\\n                currMin ++;\\n                return res;   \\n            }\\n        } else {\\n            int res = currMin;\\n            currMin ++;\\n            return res;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currMin || (q.size() > 0 && num < q.top())) q.push(num);\\n    }\\n\\nprivate:\\n    int currMin = 1;\\n    struct compare {\\n        bool operator() (const int & a, const int & b) {\\n            return a > b;\\n        }\\n    };\\n    priority_queue<int, std::vector<int>, compare> q;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "I don't understand why people saying making it infinite set would make it more difficult.\njust add a variable  X which begins with 1.\nfor popping,  ++X if no element in heap , else heappop.\nfor pushing, add the number , if it is less than X and not in heap\n\nis it because of the space constraints we are considering infinite set to be a hard problem?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@prathmesh_24](/prathmesh_24) So basically we have only 2 operations, push and pop. both care only about the least element in the set. so i set the least element as 1 initially . whenever popped i increase the least element by 1( at first 1 gets popped etc).\nwhen the least element is  5 ( after 4 pop operations) , if push 1 is the operation, i cannot set least element as 1 since after that 2,3,4 etc will get popped.\nso i use a min heap for this case alone, when an element less than least element is pushed.\nso always if the min heap is not empty will have elements less than the least element. so while pop,\n\nfirst check if heap has more than 0 elements , if yes heap pop\nelse return least element and increase it by 1\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@jagan028](/A-V-Jagannathan) Could you please explain this approach in more detail, it sounds interesting."
                    },
                    {
                        "username": "Nishchal-Tiwari",
                        "content": "class SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    public SmallestInfiniteSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1;;i++){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n                return i;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hs.contains(num))\\n            hs.remove(num);\\n    }\\n}"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Question for python programmers: \\n\\nIf we are incorporating set checks (num should not be in the infinite set already etc), then why use a set and a heap (list) separately as in the official solution?! \\n\\nWhy not use a single min-heap and current integer only. t\\uD83E\\uDD14"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not exactly sure what you're asking. Your question doesn't really seem Python specific either.\n\nWith just a min-heap we might add duplicates to the heap. Imagine the lower bound is `100` and the heap is empty. We call `addBack(20)` and `addBack(20)`, then two calls to `popSmallest()`. They'll return `20` and `20` when they should return `20` and `100`.\n\nOr are you asking why we don't just prevent duplicates by searching the heap before pushing to it? Searching is O(N) where N is the number of elements in the heap. Pushing is O(log N) so we've ruined the time complexity and made `addBack()` O(N) instead of O(log N). Whereas an O(1) set check keeps `addBack()` as O(log N).\n\nThe LeetCode constraints are so small that O(N) runs fast, but it's not a good solution for larger constraints, and a smart interviewer definitely wouldn't like it."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "This question is \"Medium\" if you overlook the case of calling `addBack(int num)` with same `num` more than once before `popSmallest()` pop\\'s it "
                    },
                    {
                        "username": "andrewseva",
                        "content": "Brute force with \"array<int, 1000> allowed\" works due to too easy constrains"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need a boolean array to keep track of which numbers are present and a binary heap to keep track of the smallest remaining number in the array."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Just use a set?\\nThats it?"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "I was more stumbled by trying to find a catch, but there is none, it\\'s very-very straightforward and many easy questions can be way harder. \\nI think it should be a part of a series of questions. This one - easy, next one is the same, but there are no constraints, but limited to int, maybe by requesting ranges of numbers, so it can do millions of numbers at once4 and the hard one should be without any constraints so you may need to also implement your big int.\\n"
                    }
                ]
            },
            {
                "id": 1873519,
                "content": [
                    {
                        "username": "PRINCEBharti",
                        "content": "class SmallestInfiniteSet {\n    HashMap<Integer, Boolean> map;\n    PriorityQueue<Integer> pq;\n    public SmallestInfiniteSet() {\n        HashMap<Integer, Boolean> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n    }\n    \n    public int popSmallest() {\n        int val = pq.remove();\n        map.remove(val);\n        return val;\n\n    }\n    \n    public void addBack(int num) {\n        if(!map.containsKey(num)){\n            map.put(num, true);\n            pq.add(num);\n        }\n    }\n}\n\n\nwhy i get error at (!map.containsKey(num))?"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "And don't forget fill your pq =)"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "Hello! You should remove HashMap<Integer, Boolean> and PriorityQueue in constructor =) \n\nmap = new HashMap<>();\npq = new PriorityQueue<>();"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "Why my C++ cannot pass all the tests?\\n\\n```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n    \\n    }\\n    \\n    int popSmallest() {\\n        if (q.size() > 0) {\\n            if (q.top() < currMin) {\\n                int res = q.top(); q.pop();\\n                return res;\\n            } else {\\n                int res = q.top(); q.pop();\\n                currMin ++;\\n                return res;   \\n            }\\n        } else {\\n            int res = currMin;\\n            currMin ++;\\n            return res;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currMin || (q.size() > 0 && num < q.top())) q.push(num);\\n    }\\n\\nprivate:\\n    int currMin = 1;\\n    struct compare {\\n        bool operator() (const int & a, const int & b) {\\n            return a > b;\\n        }\\n    };\\n    priority_queue<int, std::vector<int>, compare> q;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "I don't understand why people saying making it infinite set would make it more difficult.\njust add a variable  X which begins with 1.\nfor popping,  ++X if no element in heap , else heappop.\nfor pushing, add the number , if it is less than X and not in heap\n\nis it because of the space constraints we are considering infinite set to be a hard problem?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@prathmesh_24](/prathmesh_24) So basically we have only 2 operations, push and pop. both care only about the least element in the set. so i set the least element as 1 initially . whenever popped i increase the least element by 1( at first 1 gets popped etc).\nwhen the least element is  5 ( after 4 pop operations) , if push 1 is the operation, i cannot set least element as 1 since after that 2,3,4 etc will get popped.\nso i use a min heap for this case alone, when an element less than least element is pushed.\nso always if the min heap is not empty will have elements less than the least element. so while pop,\n\nfirst check if heap has more than 0 elements , if yes heap pop\nelse return least element and increase it by 1\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@jagan028](/A-V-Jagannathan) Could you please explain this approach in more detail, it sounds interesting."
                    },
                    {
                        "username": "Nishchal-Tiwari",
                        "content": "class SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    public SmallestInfiniteSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1;;i++){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n                return i;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hs.contains(num))\\n            hs.remove(num);\\n    }\\n}"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Question for python programmers: \\n\\nIf we are incorporating set checks (num should not be in the infinite set already etc), then why use a set and a heap (list) separately as in the official solution?! \\n\\nWhy not use a single min-heap and current integer only. t\\uD83E\\uDD14"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not exactly sure what you're asking. Your question doesn't really seem Python specific either.\n\nWith just a min-heap we might add duplicates to the heap. Imagine the lower bound is `100` and the heap is empty. We call `addBack(20)` and `addBack(20)`, then two calls to `popSmallest()`. They'll return `20` and `20` when they should return `20` and `100`.\n\nOr are you asking why we don't just prevent duplicates by searching the heap before pushing to it? Searching is O(N) where N is the number of elements in the heap. Pushing is O(log N) so we've ruined the time complexity and made `addBack()` O(N) instead of O(log N). Whereas an O(1) set check keeps `addBack()` as O(log N).\n\nThe LeetCode constraints are so small that O(N) runs fast, but it's not a good solution for larger constraints, and a smart interviewer definitely wouldn't like it."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "This question is \"Medium\" if you overlook the case of calling `addBack(int num)` with same `num` more than once before `popSmallest()` pop\\'s it "
                    },
                    {
                        "username": "andrewseva",
                        "content": "Brute force with \"array<int, 1000> allowed\" works due to too easy constrains"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need a boolean array to keep track of which numbers are present and a binary heap to keep track of the smallest remaining number in the array."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Just use a set?\\nThats it?"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "I was more stumbled by trying to find a catch, but there is none, it\\'s very-very straightforward and many easy questions can be way harder. \\nI think it should be a part of a series of questions. This one - easy, next one is the same, but there are no constraints, but limited to int, maybe by requesting ranges of numbers, so it can do millions of numbers at once4 and the hard one should be without any constraints so you may need to also implement your big int.\\n"
                    }
                ]
            },
            {
                "id": 1873408,
                "content": [
                    {
                        "username": "PRINCEBharti",
                        "content": "class SmallestInfiniteSet {\n    HashMap<Integer, Boolean> map;\n    PriorityQueue<Integer> pq;\n    public SmallestInfiniteSet() {\n        HashMap<Integer, Boolean> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n    }\n    \n    public int popSmallest() {\n        int val = pq.remove();\n        map.remove(val);\n        return val;\n\n    }\n    \n    public void addBack(int num) {\n        if(!map.containsKey(num)){\n            map.put(num, true);\n            pq.add(num);\n        }\n    }\n}\n\n\nwhy i get error at (!map.containsKey(num))?"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "And don't forget fill your pq =)"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "Hello! You should remove HashMap<Integer, Boolean> and PriorityQueue in constructor =) \n\nmap = new HashMap<>();\npq = new PriorityQueue<>();"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "Why my C++ cannot pass all the tests?\\n\\n```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n    \\n    }\\n    \\n    int popSmallest() {\\n        if (q.size() > 0) {\\n            if (q.top() < currMin) {\\n                int res = q.top(); q.pop();\\n                return res;\\n            } else {\\n                int res = q.top(); q.pop();\\n                currMin ++;\\n                return res;   \\n            }\\n        } else {\\n            int res = currMin;\\n            currMin ++;\\n            return res;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currMin || (q.size() > 0 && num < q.top())) q.push(num);\\n    }\\n\\nprivate:\\n    int currMin = 1;\\n    struct compare {\\n        bool operator() (const int & a, const int & b) {\\n            return a > b;\\n        }\\n    };\\n    priority_queue<int, std::vector<int>, compare> q;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "I don't understand why people saying making it infinite set would make it more difficult.\njust add a variable  X which begins with 1.\nfor popping,  ++X if no element in heap , else heappop.\nfor pushing, add the number , if it is less than X and not in heap\n\nis it because of the space constraints we are considering infinite set to be a hard problem?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@prathmesh_24](/prathmesh_24) So basically we have only 2 operations, push and pop. both care only about the least element in the set. so i set the least element as 1 initially . whenever popped i increase the least element by 1( at first 1 gets popped etc).\nwhen the least element is  5 ( after 4 pop operations) , if push 1 is the operation, i cannot set least element as 1 since after that 2,3,4 etc will get popped.\nso i use a min heap for this case alone, when an element less than least element is pushed.\nso always if the min heap is not empty will have elements less than the least element. so while pop,\n\nfirst check if heap has more than 0 elements , if yes heap pop\nelse return least element and increase it by 1\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@jagan028](/A-V-Jagannathan) Could you please explain this approach in more detail, it sounds interesting."
                    },
                    {
                        "username": "Nishchal-Tiwari",
                        "content": "class SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    public SmallestInfiniteSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1;;i++){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n                return i;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hs.contains(num))\\n            hs.remove(num);\\n    }\\n}"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Question for python programmers: \\n\\nIf we are incorporating set checks (num should not be in the infinite set already etc), then why use a set and a heap (list) separately as in the official solution?! \\n\\nWhy not use a single min-heap and current integer only. t\\uD83E\\uDD14"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not exactly sure what you're asking. Your question doesn't really seem Python specific either.\n\nWith just a min-heap we might add duplicates to the heap. Imagine the lower bound is `100` and the heap is empty. We call `addBack(20)` and `addBack(20)`, then two calls to `popSmallest()`. They'll return `20` and `20` when they should return `20` and `100`.\n\nOr are you asking why we don't just prevent duplicates by searching the heap before pushing to it? Searching is O(N) where N is the number of elements in the heap. Pushing is O(log N) so we've ruined the time complexity and made `addBack()` O(N) instead of O(log N). Whereas an O(1) set check keeps `addBack()` as O(log N).\n\nThe LeetCode constraints are so small that O(N) runs fast, but it's not a good solution for larger constraints, and a smart interviewer definitely wouldn't like it."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "This question is \"Medium\" if you overlook the case of calling `addBack(int num)` with same `num` more than once before `popSmallest()` pop\\'s it "
                    },
                    {
                        "username": "andrewseva",
                        "content": "Brute force with \"array<int, 1000> allowed\" works due to too easy constrains"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need a boolean array to keep track of which numbers are present and a binary heap to keep track of the smallest remaining number in the array."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Just use a set?\\nThats it?"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "I was more stumbled by trying to find a catch, but there is none, it\\'s very-very straightforward and many easy questions can be way harder. \\nI think it should be a part of a series of questions. This one - easy, next one is the same, but there are no constraints, but limited to int, maybe by requesting ranges of numbers, so it can do millions of numbers at once4 and the hard one should be without any constraints so you may need to also implement your big int.\\n"
                    }
                ]
            },
            {
                "id": 1873353,
                "content": [
                    {
                        "username": "PRINCEBharti",
                        "content": "class SmallestInfiniteSet {\n    HashMap<Integer, Boolean> map;\n    PriorityQueue<Integer> pq;\n    public SmallestInfiniteSet() {\n        HashMap<Integer, Boolean> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n    }\n    \n    public int popSmallest() {\n        int val = pq.remove();\n        map.remove(val);\n        return val;\n\n    }\n    \n    public void addBack(int num) {\n        if(!map.containsKey(num)){\n            map.put(num, true);\n            pq.add(num);\n        }\n    }\n}\n\n\nwhy i get error at (!map.containsKey(num))?"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "And don't forget fill your pq =)"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "Hello! You should remove HashMap<Integer, Boolean> and PriorityQueue in constructor =) \n\nmap = new HashMap<>();\npq = new PriorityQueue<>();"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "Why my C++ cannot pass all the tests?\\n\\n```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n    \\n    }\\n    \\n    int popSmallest() {\\n        if (q.size() > 0) {\\n            if (q.top() < currMin) {\\n                int res = q.top(); q.pop();\\n                return res;\\n            } else {\\n                int res = q.top(); q.pop();\\n                currMin ++;\\n                return res;   \\n            }\\n        } else {\\n            int res = currMin;\\n            currMin ++;\\n            return res;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currMin || (q.size() > 0 && num < q.top())) q.push(num);\\n    }\\n\\nprivate:\\n    int currMin = 1;\\n    struct compare {\\n        bool operator() (const int & a, const int & b) {\\n            return a > b;\\n        }\\n    };\\n    priority_queue<int, std::vector<int>, compare> q;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "I don't understand why people saying making it infinite set would make it more difficult.\njust add a variable  X which begins with 1.\nfor popping,  ++X if no element in heap , else heappop.\nfor pushing, add the number , if it is less than X and not in heap\n\nis it because of the space constraints we are considering infinite set to be a hard problem?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@prathmesh_24](/prathmesh_24) So basically we have only 2 operations, push and pop. both care only about the least element in the set. so i set the least element as 1 initially . whenever popped i increase the least element by 1( at first 1 gets popped etc).\nwhen the least element is  5 ( after 4 pop operations) , if push 1 is the operation, i cannot set least element as 1 since after that 2,3,4 etc will get popped.\nso i use a min heap for this case alone, when an element less than least element is pushed.\nso always if the min heap is not empty will have elements less than the least element. so while pop,\n\nfirst check if heap has more than 0 elements , if yes heap pop\nelse return least element and increase it by 1\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@jagan028](/A-V-Jagannathan) Could you please explain this approach in more detail, it sounds interesting."
                    },
                    {
                        "username": "Nishchal-Tiwari",
                        "content": "class SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    public SmallestInfiniteSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1;;i++){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n                return i;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hs.contains(num))\\n            hs.remove(num);\\n    }\\n}"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Question for python programmers: \\n\\nIf we are incorporating set checks (num should not be in the infinite set already etc), then why use a set and a heap (list) separately as in the official solution?! \\n\\nWhy not use a single min-heap and current integer only. t\\uD83E\\uDD14"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not exactly sure what you're asking. Your question doesn't really seem Python specific either.\n\nWith just a min-heap we might add duplicates to the heap. Imagine the lower bound is `100` and the heap is empty. We call `addBack(20)` and `addBack(20)`, then two calls to `popSmallest()`. They'll return `20` and `20` when they should return `20` and `100`.\n\nOr are you asking why we don't just prevent duplicates by searching the heap before pushing to it? Searching is O(N) where N is the number of elements in the heap. Pushing is O(log N) so we've ruined the time complexity and made `addBack()` O(N) instead of O(log N). Whereas an O(1) set check keeps `addBack()` as O(log N).\n\nThe LeetCode constraints are so small that O(N) runs fast, but it's not a good solution for larger constraints, and a smart interviewer definitely wouldn't like it."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "This question is \"Medium\" if you overlook the case of calling `addBack(int num)` with same `num` more than once before `popSmallest()` pop\\'s it "
                    },
                    {
                        "username": "andrewseva",
                        "content": "Brute force with \"array<int, 1000> allowed\" works due to too easy constrains"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need a boolean array to keep track of which numbers are present and a binary heap to keep track of the smallest remaining number in the array."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Just use a set?\\nThats it?"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "I was more stumbled by trying to find a catch, but there is none, it\\'s very-very straightforward and many easy questions can be way harder. \\nI think it should be a part of a series of questions. This one - easy, next one is the same, but there are no constraints, but limited to int, maybe by requesting ranges of numbers, so it can do millions of numbers at once4 and the hard one should be without any constraints so you may need to also implement your big int.\\n"
                    }
                ]
            },
            {
                "id": 1873336,
                "content": [
                    {
                        "username": "PRINCEBharti",
                        "content": "class SmallestInfiniteSet {\n    HashMap<Integer, Boolean> map;\n    PriorityQueue<Integer> pq;\n    public SmallestInfiniteSet() {\n        HashMap<Integer, Boolean> map = new HashMap<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n    }\n    \n    public int popSmallest() {\n        int val = pq.remove();\n        map.remove(val);\n        return val;\n\n    }\n    \n    public void addBack(int num) {\n        if(!map.containsKey(num)){\n            map.put(num, true);\n            pq.add(num);\n        }\n    }\n}\n\n\nwhy i get error at (!map.containsKey(num))?"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "And don't forget fill your pq =)"
                    },
                    {
                        "username": "Maksim_Leonov",
                        "content": "Hello! You should remove HashMap<Integer, Boolean> and PriorityQueue in constructor =) \n\nmap = new HashMap<>();\npq = new PriorityQueue<>();"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "Why my C++ cannot pass all the tests?\\n\\n```c++\\nclass SmallestInfiniteSet {\\npublic:\\n    SmallestInfiniteSet() {\\n    \\n    }\\n    \\n    int popSmallest() {\\n        if (q.size() > 0) {\\n            if (q.top() < currMin) {\\n                int res = q.top(); q.pop();\\n                return res;\\n            } else {\\n                int res = q.top(); q.pop();\\n                currMin ++;\\n                return res;   \\n            }\\n        } else {\\n            int res = currMin;\\n            currMin ++;\\n            return res;\\n        }\\n    }\\n    \\n    void addBack(int num) {\\n        if (num < currMin || (q.size() > 0 && num < q.top())) q.push(num);\\n    }\\n\\nprivate:\\n    int currMin = 1;\\n    struct compare {\\n        bool operator() (const int & a, const int & b) {\\n            return a > b;\\n        }\\n    };\\n    priority_queue<int, std::vector<int>, compare> q;\\n};\\n\\n/**\\n * Your SmallestInfiniteSet object will be instantiated and called as such:\\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\\n * int param_1 = obj->popSmallest();\\n * obj->addBack(num);\\n */\\n```"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "I don't understand why people saying making it infinite set would make it more difficult.\njust add a variable  X which begins with 1.\nfor popping,  ++X if no element in heap , else heappop.\nfor pushing, add the number , if it is less than X and not in heap\n\nis it because of the space constraints we are considering infinite set to be a hard problem?"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@prathmesh_24](/prathmesh_24) So basically we have only 2 operations, push and pop. both care only about the least element in the set. so i set the least element as 1 initially . whenever popped i increase the least element by 1( at first 1 gets popped etc).\nwhen the least element is  5 ( after 4 pop operations) , if push 1 is the operation, i cannot set least element as 1 since after that 2,3,4 etc will get popped.\nso i use a min heap for this case alone, when an element less than least element is pushed.\nso always if the min heap is not empty will have elements less than the least element. so while pop,\n\nfirst check if heap has more than 0 elements , if yes heap pop\nelse return least element and increase it by 1\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "[@jagan028](/A-V-Jagannathan) Could you please explain this approach in more detail, it sounds interesting."
                    },
                    {
                        "username": "Nishchal-Tiwari",
                        "content": "class SmallestInfiniteSet {\\n    HashSet<Integer> hs;\\n    public SmallestInfiniteSet() {\\n        hs=new HashSet<>();\\n    }\\n    \\n    public int popSmallest() {\\n        for(int i=1;;i++){\\n            if(!hs.contains(i)){\\n                hs.add(i);\\n                return i;\\n            }\\n        }\\n    }\\n    \\n    public void addBack(int num) {\\n        if(hs.contains(num))\\n            hs.remove(num);\\n    }\\n}"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Question for python programmers: \\n\\nIf we are incorporating set checks (num should not be in the infinite set already etc), then why use a set and a heap (list) separately as in the official solution?! \\n\\nWhy not use a single min-heap and current integer only. t\\uD83E\\uDD14"
                    },
                    {
                        "username": "nikhila01",
                        "content": "I'm not exactly sure what you're asking. Your question doesn't really seem Python specific either.\n\nWith just a min-heap we might add duplicates to the heap. Imagine the lower bound is `100` and the heap is empty. We call `addBack(20)` and `addBack(20)`, then two calls to `popSmallest()`. They'll return `20` and `20` when they should return `20` and `100`.\n\nOr are you asking why we don't just prevent duplicates by searching the heap before pushing to it? Searching is O(N) where N is the number of elements in the heap. Pushing is O(log N) so we've ruined the time complexity and made `addBack()` O(N) instead of O(log N). Whereas an O(1) set check keeps `addBack()` as O(log N).\n\nThe LeetCode constraints are so small that O(N) runs fast, but it's not a good solution for larger constraints, and a smart interviewer definitely wouldn't like it."
                    },
                    {
                        "username": "rohit_adithya",
                        "content": "This question is \"Medium\" if you overlook the case of calling `addBack(int num)` with same `num` more than once before `popSmallest()` pop\\'s it "
                    },
                    {
                        "username": "andrewseva",
                        "content": "Brute force with \"array<int, 1000> allowed\" works due to too easy constrains"
                    },
                    {
                        "username": "psionl0",
                        "content": "You need a boolean array to keep track of which numbers are present and a binary heap to keep track of the smallest remaining number in the array."
                    },
                    {
                        "username": "arghyadas",
                        "content": "Just use a set?\\nThats it?"
                    },
                    {
                        "username": "user5822gZ",
                        "content": "I was more stumbled by trying to find a catch, but there is none, it\\'s very-very straightforward and many easy questions can be way harder. \\nI think it should be a part of a series of questions. This one - easy, next one is the same, but there are no constraints, but limited to int, maybe by requesting ranges of numbers, so it can do millions of numbers at once4 and the hard one should be without any constraints so you may need to also implement your big int.\\n"
                    }
                ]
            }
        ]
    }
]