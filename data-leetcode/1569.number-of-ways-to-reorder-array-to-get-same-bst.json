[
    {
        "title": "Minimum Number of Days to Disconnect Island",
        "question_content": "You are given an m x n binary grid grid where 1 represents land and 0 represents water. An island is a maximal 4-directionally (horizontal or vertical) connected group of 1's.\nThe grid is said to be connected if we have exactly one island, otherwise is said disconnected.\nIn one day, we are allowed to change any single land cell (1) into a water cell (0).\nReturn the minimum number of days to disconnect the grid.\n&nbsp;\nExample 1:\n\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\nOutput: 2\nExplanation: We need at least 2 days to get a disconnected grid.\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island.\n\nExample 2:\n\nInput: grid = [[1,1]]\nOutput: 2\nExplanation: Grid of full water is also disconnected ([[1,1]] -> [[0,0]]), 0 islands.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 30\n\tgrid[i][j] is either 0 or 1.",
        "solutions": [
            {
                "id": 819303,
                "title": "python-you-need-at-most-2-days",
                "content": "The tricky part of this question is to notice that, you can disconnect any given island formation in at most 2 days (and you need to convince yourself that this is true).\\nExample: Imagine we have 30-by-30 array of all 1\\'s. For the top left corner, just remove the one to the right and below. And you are done.\\n\\n**Day 0:** Check islands at day 0, return 0 if you have less than or greater than one island.\\n\\n**Day 1**: If not, try to add water at any given location, and check if that gives you a valid island formation.\\n\\n**Day 2:** Else, just return 2!\\n\\n```\\nimport copy\\nclass Solution:\\n\\t#this is just a helper function for the no_islands function below\\n    def no_islands_recur(self, grid, i, j, m, n):\\n        if grid[i][j]==0:\\n            return\\n        grid[i][j]=0\\n        if i-1>=0:\\n            self.no_islands_recur(grid, i-1, j, m, n)\\n        if i+1<m:\\n            self.no_islands_recur(grid, i+1, j, m, n)\\n        if j-1>=0:\\n            self.no_islands_recur(grid, i, j-1, m, n)\\n        if j+1<n:\\n            self.no_islands_recur(grid, i, j+1, m, n)\\n    \\n\\t\\n    #find how many islands the given grid has        \\n    def no_islands(self, grid):\\n        ret = 0\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    ret += 1\\n                    self.no_islands_recur(grid, i, j, m, n)\\n        return ret\\n    \\n    \\n    def minDays(self, grid: List[List[int]]) -> int:\\n        #if we have 0 or more than 1 islands at day 0, return day 0\\n        time = 0\\n        grid_copy = copy.deepcopy(grid)\\n        n = self.no_islands(grid_copy)\\n        if n!=1:\\n            return time\\n        \\n\\t\\t#try to remove any land any see if it works\\n        time = 1\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid_copy = copy.deepcopy(grid)\\n                grid_copy[i][j] = 0\\n                n = self.no_islands(grid_copy)\\n                if n!=1:\\n                    return time\\n        \\n\\t\\t#well then just return 2\\n        time = 2\\n        return time\\n```\\n\\n**Edit:** I sincerely appreciate all the kindness in the comments. One thing I noticed time over time, over the solutions of many amazing people here, when a problem looks too difficult to be solved, often there is a catch that lands itself to easy coding. For this one it was the limited number of iterations one would need. So overall it might be a good strategy to think about this, which can save time and coding effort.",
                "solutionTags": [],
                "code": "```\\nimport copy\\nclass Solution:\\n\\t#this is just a helper function for the no_islands function below\\n    def no_islands_recur(self, grid, i, j, m, n):\\n        if grid[i][j]==0:\\n            return\\n        grid[i][j]=0\\n        if i-1>=0:\\n            self.no_islands_recur(grid, i-1, j, m, n)\\n        if i+1<m:\\n            self.no_islands_recur(grid, i+1, j, m, n)\\n        if j-1>=0:\\n            self.no_islands_recur(grid, i, j-1, m, n)\\n        if j+1<n:\\n            self.no_islands_recur(grid, i, j+1, m, n)\\n    \\n\\t\\n    #find how many islands the given grid has        \\n    def no_islands(self, grid):\\n        ret = 0\\n        m, n = len(grid), len(grid[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    ret += 1\\n                    self.no_islands_recur(grid, i, j, m, n)\\n        return ret\\n    \\n    \\n    def minDays(self, grid: List[List[int]]) -> int:\\n        #if we have 0 or more than 1 islands at day 0, return day 0\\n        time = 0\\n        grid_copy = copy.deepcopy(grid)\\n        n = self.no_islands(grid_copy)\\n        if n!=1:\\n            return time\\n        \\n\\t\\t#try to remove any land any see if it works\\n        time = 1\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid_copy = copy.deepcopy(grid)\\n                grid_copy[i][j] = 0\\n                n = self.no_islands(grid_copy)\\n                if n!=1:\\n                    return time\\n        \\n\\t\\t#well then just return 2\\n        time = 2\\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819296,
                "title": "dfs-c-clean-code-with-explanation",
                "content": "# Observation\\n## **ans <= 2**\\nans is always less-equal to 2\\n## **why?**\\nfor any island we can remove the two blocks around the bottom left corner to make it disconnected\\n```\\nx x x\\nx . x\\nx x x\\n```\\ncan be changed to\\n```\\nx x x\\nx . .\\nx . x\\n```\\nif you still don\\'t get it read this: [comment](https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/discuss/819296/DFS-c++-clean-code-with-explanation/679802)\\nwe need to check for only when ans is 1 or 0\\n## **ans = 1**\\nwe remove a block and check if it disconnects the islands\\n## **ans = 0**\\nwe check if there are > 1 islands already\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<int>> & vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[x][y] = 1;\\n        for (int a = 0; a < 4; a++)\\n        {\\n            int nx = x + dx[a];\\n            int ny = y + dy[a];\\n            if (nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny])\\n            {\\n                dfs(nx, ny, grid, vis);\\n            }\\n        }\\n    }\\n    int count_islands(vector<vector<int>> & grid)\\n    {\\n        int islands = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (!vis[i][j] and grid[i][j])\\n                {\\n                    dfs(i, j, grid, vis);\\n                    islands ++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int islands = count_islands(grid);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t// check for 0 ans\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = count_islands(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```\\n### Time Complexity: O((m*n)^2)",
                "solutionTags": [],
                "code": "```\\nx x x\\nx . x\\nx x x\\n```\n```\\nx x x\\nx . .\\nx . x\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<int>> & vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[x][y] = 1;\\n        for (int a = 0; a < 4; a++)\\n        {\\n            int nx = x + dx[a];\\n            int ny = y + dy[a];\\n            if (nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny])\\n            {\\n                dfs(nx, ny, grid, vis);\\n            }\\n        }\\n    }\\n    int count_islands(vector<vector<int>> & grid)\\n    {\\n        int islands = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (!vis[i][j] and grid[i][j])\\n                {\\n                    dfs(i, j, grid, vis);\\n                    islands ++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int islands = count_islands(grid);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t// check for 0 ans\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = count_islands(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819342,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        if(noOfIsland(grid) != 1){\\n            return 0;\\n        }\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(noOfIsland(grid) != 1){\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    \\n    private int noOfIsland(int [][]grid){\\n        int ans = 0;\\n        boolean [][]visited = new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(!visited[i][j] && grid[i][j] == 1){\\n                    ans ++;\\n                    dfs(visited, grid,i,j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(boolean [][]visited, int [][]grid,int i, int j){\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0){\\n            return ;\\n        }\\n        visited[i][j] = true;\\n        dfs(visited, grid, i-1, j);\\n        dfs(visited, grid, i+1, j);\\n        dfs(visited, grid, i, j-1);\\n        dfs(visited, grid, i, j+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        if(noOfIsland(grid) != 1){\\n            return 0;\\n        }\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(noOfIsland(grid) != 1){\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    \\n    private int noOfIsland(int [][]grid){\\n        int ans = 0;\\n        boolean [][]visited = new boolean[grid.length][grid[0].length];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(!visited[i][j] && grid[i][j] == 1){\\n                    ans ++;\\n                    dfs(visited, grid,i,j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(boolean [][]visited, int [][]grid,int i, int j){\\n        if(i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0){\\n            return ;\\n        }\\n        visited[i][j] = true;\\n        dfs(visited, grid, i-1, j);\\n        dfs(visited, grid, i+1, j);\\n        dfs(visited, grid, i, j-1);\\n        dfs(visited, grid, i, j+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819277,
                "title": "python-golang-there-are-only-3-possible-answers",
                "content": "\\n## Idea\\n**How to make the grid disconnected?**\\nWe can tell from the first official example that, the worst situation we may get into is to take 2 steps and separate a single island out.\\nMore specifically, there are 3 situation.\\n1. The number of island on the grid is not 1.\\n\\t- return 0\\n1. The number of island on the grid is 1, and we can break them into 2 islands within 1 step.\\n\\t- return 1\\n1. The number of island on the grid is 1, and we cannot break them into 2 islands within 1 step.\\n\\t- return 2, because no matter what, we can always separate 1 island out within 2 steps\\n\\n\\n**How to count the number of islands on the grid**\\nThere are many different ways like DFS, Union Find. I use union find here.\\n\\n## Complexity\\n- Time: O(n^4)\\n- Space: O(n^2)\\n\\n## Python\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        def countIsland():\\n            roots = {(i,j):(i,j) for i in range(m) for j in range(n)}\\n            def find(i):\\n                if roots[i] != i: roots[i] = find(roots[i])\\n                return roots[i]                    \\n            \\n            def unite(i, j):\\n                roots[find(i)] = find(j)\\n                \\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j]:\\n                        if i < m - 1 and grid[i + 1][j]:\\n                            unite((i, j), (i + 1, j))\\n                        if j < n - 1 and grid[i][j + 1]:\\n                            unite((i, j), (i, j + 1))\\n            return len(set(find((i, j)) for i in range(m) for j in range(n) if grid[i][j]))                            \\n        \\n        if countIsland() != 1:\\n            return 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    grid[i][j] = 0\\n                    if countIsland() != 1:\\n                        return 1\\n                    grid[i][j] = 1\\n        return 2\\n```\\n\\n## Golang\\n```\\nimport \"fmt\"\\n\\nfunc minDays(grid [][]int) int {\\n    if countIslands(grid) != 1 {\\n        return 0\\n    }\\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                grid[i][j] = 0\\n                if countIslands(grid) != 1 {\\n                    return 1\\n                }\\n                grid[i][j] = 1\\n            }\\n        }\\n    }\\n    return 2\\n}\\n\\nvar roots [][][2]int\\n\\nfunc countIslands(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n    roots = make([][][2]int, m)\\n    for i := range grid {\\n        roots[i] = make([][2]int, n)\\n        for j := range roots[i] {\\n            roots[i][j] = [2]int {i, j}\\n        }\\n    }\\n    \\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                if i < m - 1 && grid[i + 1][j] == 1 {\\n                    unite(i, j, i + 1, j)\\n                }\\n                if j < n - 1 && grid[i][j + 1] == 1 {\\n                    unite(i, j, i, j + 1)\\n                }\\n            }\\n        }\\n    }\\n    set := make(map[int]bool)\\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                tmp := find(i, j)\\n                set[tmp[0] * n + tmp[1]] = true\\n            }\\n        }\\n    }\\n    return len(set)\\n}\\n\\nfunc find(i, j int) [2]int {\\n    if roots[i][j] != [2]int {i, j} {\\n        tmp := roots[i][j]\\n        roots[i][j] = find(tmp[0], tmp[1])\\n    }\\n    return roots[i][j]\\n}\\n\\nfunc unite(xi, xj, yi, yj int) {\\n    x := find(xi, xj)\\n    roots[x[0]][x[1]] = find(yi, yj)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        def countIsland():\\n            roots = {(i,j):(i,j) for i in range(m) for j in range(n)}\\n            def find(i):\\n                if roots[i] != i: roots[i] = find(roots[i])\\n                return roots[i]                    \\n            \\n            def unite(i, j):\\n                roots[find(i)] = find(j)\\n                \\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j]:\\n                        if i < m - 1 and grid[i + 1][j]:\\n                            unite((i, j), (i + 1, j))\\n                        if j < n - 1 and grid[i][j + 1]:\\n                            unite((i, j), (i, j + 1))\\n            return len(set(find((i, j)) for i in range(m) for j in range(n) if grid[i][j]))                            \\n        \\n        if countIsland() != 1:\\n            return 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    grid[i][j] = 0\\n                    if countIsland() != 1:\\n                        return 1\\n                    grid[i][j] = 1\\n        return 2\\n```\n```\\nimport \"fmt\"\\n\\nfunc minDays(grid [][]int) int {\\n    if countIslands(grid) != 1 {\\n        return 0\\n    }\\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                grid[i][j] = 0\\n                if countIslands(grid) != 1 {\\n                    return 1\\n                }\\n                grid[i][j] = 1\\n            }\\n        }\\n    }\\n    return 2\\n}\\n\\nvar roots [][][2]int\\n\\nfunc countIslands(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n    roots = make([][][2]int, m)\\n    for i := range grid {\\n        roots[i] = make([][2]int, n)\\n        for j := range roots[i] {\\n            roots[i][j] = [2]int {i, j}\\n        }\\n    }\\n    \\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                if i < m - 1 && grid[i + 1][j] == 1 {\\n                    unite(i, j, i + 1, j)\\n                }\\n                if j < n - 1 && grid[i][j + 1] == 1 {\\n                    unite(i, j, i, j + 1)\\n                }\\n            }\\n        }\\n    }\\n    set := make(map[int]bool)\\n    for i := range grid {\\n        for j := range grid[0] {\\n            if grid[i][j] == 1 {\\n                tmp := find(i, j)\\n                set[tmp[0] * n + tmp[1]] = true\\n            }\\n        }\\n    }\\n    return len(set)\\n}\\n\\nfunc find(i, j int) [2]int {\\n    if roots[i][j] != [2]int {i, j} {\\n        tmp := roots[i][j]\\n        roots[i][j] = find(tmp[0], tmp[1])\\n    }\\n    return roots[i][j]\\n}\\n\\nfunc unite(xi, xj, yi, yj int) {\\n    x := find(xi, xj)\\n    roots[x[0]][x[1]] = find(yi, yj)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819428,
                "title": "c-at-most-2-removal-try-removing-each-one-and-see-if-the-graph-is-disconnected",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nYou need at most two days to separate out a `1` at the corner with all other `1`s. So the answer is one of `0`, `1`, `2`.\\n\\nIf the graph is already disconnected, return `0`.\\n\\nFor each `1`, see if removing it can disconnect the graph. If yes, then return `1`.\\n\\nOtherwise return `2`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/\\n// Author: github.com/lzl124631x\\n// Time: O((MN)^2)\\n// Space: O(MN)\\nclass Solution {\\n    int M, N, dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n    void dfs(vector<vector<int>> &G, int i, int j,vector<vector<int>> &seen) {\\n        seen[i][j] = true;\\n        for (auto &[dx, dy] : dirs) {\\n            int x = dx + i, y = dy + j;\\n            if (x < 0 || x >= M || y < 0 || y >= N || G[x][y] != 1 || seen[x][y]) continue;\\n            dfs(G, x, y, seen);\\n        }\\n    }\\n    bool disconnected(vector<vector<int>> &G) {\\n        vector<vector<int>> seen(M, vector<int>(N, false));\\n        int cnt = 0;\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (G[i][j] != 1 || seen[i][j]) continue;\\n                if (++cnt > 1) return true;\\n                dfs(G, i, j, seen);\\n            }\\n        }\\n        return cnt == 0;\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& G) {\\n        M = G.size(), N = G[0].size();\\n        if (disconnected(G)) return 0;\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (G[i][j] != 1) continue;\\n                G[i][j] = 0;\\n                if (disconnected(G)) return 1;\\n                G[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/\\n// Author: github.com/lzl124631x\\n// Time: O((MN)^2)\\n// Space: O(MN)\\nclass Solution {\\n    int M, N, dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};\\n    void dfs(vector<vector<int>> &G, int i, int j,vector<vector<int>> &seen) {\\n        seen[i][j] = true;\\n        for (auto &[dx, dy] : dirs) {\\n            int x = dx + i, y = dy + j;\\n            if (x < 0 || x >= M || y < 0 || y >= N || G[x][y] != 1 || seen[x][y]) continue;\\n            dfs(G, x, y, seen);\\n        }\\n    }\\n    bool disconnected(vector<vector<int>> &G) {\\n        vector<vector<int>> seen(M, vector<int>(N, false));\\n        int cnt = 0;\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (G[i][j] != 1 || seen[i][j]) continue;\\n                if (++cnt > 1) return true;\\n                dfs(G, i, j, seen);\\n            }\\n        }\\n        return cnt == 0;\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& G) {\\n        M = G.size(), N = G[0].size();\\n        if (disconnected(G)) return 0;\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (G[i][j] != 1) continue;\\n                G[i][j] = 0;\\n                if (disconnected(G)) return 1;\\n                G[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821143,
                "title": "java-o-mn-2ms-articulation-point-bridge-approach",
                "content": "All the posted solutions are using the similar basic flow: \\n1. If there is no island or more than 1 island, return 0;\\n2. If there is only one land, return 1;\\n3. If any single cell could serve as the cut point ( divide 1 island into 2 islands), return 1;\\n4. Otherwise, return 2 ( I haven\\'t found a formal proof yet).\\n\\nThe major difference is how to find single cut point. Solutions like BFS/DFS/UnionFind all have to try each and every land cell, resulting in **O(M^2N^2)** worst case time complexity. We could use Tarjan\\'s algorithm to find the articulation point with **O(MN)** time complexity(https://en.wikipedia.org/wiki/Biconnected_component). It\\'s similar to my original bridge solution, except that it\\'s shorter and more intuitive.\\n\\n```\\nclass Solution {\\n    boolean ap; //articulation point\\n    int time; //visit time\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int minDays(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        ap = false;\\n        time = 0;\\n        int lands = 0, islands = 0;\\n        int[][] depth = new int[n][m];\\n        int[][] low = new int[n][m];\\n        int[][] parent = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(depth[i], -1);\\n            Arrays.fill(low[i], -1);\\n            Arrays.fill(parent[i], -1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    lands++;\\n                    if (depth[i][j] == -1) {\\n                        apDFS(grid, i, j, depth, low, parent);\\n                        islands++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (islands == 0 || islands >= 2) return 0;\\n        if (lands == 1) return 1;\\n        if (ap) return 1;\\n        return 2;\\n    }\\n\\n    private void apDFS(int[][] grid, int i, int j, int[][] depth, int[][] low, int[][] parent) {\\n        int n = grid.length, m = grid[0].length;\\n        depth[i][j] = time++;\\n        low[i][j] = depth[i][j];\\n        int children = 0;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == 1) {\\n                //valid connection\\n                if (depth[ni][nj] == -1) {\\n                    children++;\\n                    parent[ni][nj] = i*m + j;\\n                    apDFS(grid, ni, nj, depth, low, parent);\\n                    low[i][j] = Math.min(low[i][j], low[ni][nj]);\\n                    if (low[ni][nj] >= depth[i][j] && parent[i][j] > -1) {\\n                        ap = true;\\n                    }\\n                } else if (ni*m + nj != parent[i][j]) {//ignore the incoming path\\n                    low[i][j] = Math.min(low[i][j], depth[ni][nj]);\\n                }\\n            }\\n        }\\n        if (parent[i][j] == -1 && children > 1) {\\n            ap = true;\\n        }\\n    }\\n}\\n```\\n\\n#### Original bridge solution\\n<details>\\n  <summary>Click to expand!</summary>\\nHere is a solution using Tarjan\\'s algorithm to find the bridge in **O(MN)** time. See [**here**](https://stackoverflow.com/questions/28917290/how-can-i-find-bridges-in-an-undirected-graph) for details. \\n\\nOne minor difference between our solution and the original algorithm (https://algs4.cs.princeton.edu/41graph/Bridge.java.html) is: we\\'re not trying to cut the connection (the boundary between cells with value 1), we\\'re trying to cut a cell, which might have 4 connections. So it\\'s not done when we find a bridge, we also need to make sure either cell of the bridge has other connections. E.g. in case of `[[1,1]]`, we do have a bridge, but removing either cell of the bridge doesn\\'t make it 2 islands.\\n\\n```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int c = getIslands(grid);\\n        if (c == 0 || c >= 2) return 0;\\n        if (hasOneLand(grid)) return 1;\\n        if (hasBridge(grid)) return 1;\\n        return 2;\\n    }\\n\\n    private boolean hasOneLand(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, c = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && ++c > 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return c == 1;\\n    }\\n\\n    boolean found = false;//whether there\\'s a bridge\\n    int cnt = 0;//node dfs visit sequence number\\n    private boolean hasBridge(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        found = false;\\n        cnt = 0;\\n        int[][] pre = new int[n][m];\\n        int[][] low = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(pre[i], -1);\\n            Arrays.fill(low[i], -1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && pre[i][j] == -1) {\\n                    bridgeDFS(grid, i, j, i, j, pre, low);\\n                    if (found) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     *\\n     * @param i1 from row\\n     * @param j1 from column\\n     * @param i current row\\n     * @param j current column\\n     * @param pre array that keeps track of current cnt during dfs; -1 means not visited\\n     * @param low lowest pre order that\\'s connected to the current node\\n     */\\n    private void bridgeDFS(int[][] grid, int i1, int j1, int i, int j, int[][] pre, int[][] low) {\\n        int n = grid.length, m = grid[0].length;\\n        pre[i][j] = cnt++;\\n        low[i][j] = pre[i][j];\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == 1) {\\n                //valid connection\\n                if (pre[ni][nj] == -1) {\\n                    bridgeDFS(grid, i, j, ni, nj, pre, low);\\n                    low[i][j] = Math.min(low[i][j], low[ni][nj]);\\n                    if (low[ni][nj] == pre[ni][nj]) {\\n                        //i,j to ni, nj is bridge. (i,j) or (ni,nj) must have other neighbors for the cell to be the cut point\\n                        if (hasMoreNeighbors(grid, i, j) || hasMoreNeighbors(grid, ni, nj)) {\\n                            //shortcut, no need to search any more\\n                            found = true;\\n                            return;\\n                        }\\n                    }\\n                } else if (ni != i1 || nj != j1) {//ignore the incoming path\\n                    low[i][j] = Math.min(low[i][j], pre[ni][nj]);\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Returns whether the cell has 2 or more neighbors\\n     */\\n    private boolean hasMoreNeighbors(int[][] grid, int i, int j) {\\n        int c = 0;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {\\n                c++;\\n            }\\n        }\\n        return c > 1;\\n    }\\n\\n    /**\\n     * Gets number of islands\\n     */\\n    private int getIslands(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        boolean[][] v = new boolean[n][m];\\n        int c = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && !v[i][j]) {\\n                    dfsIslands(grid, i, j, v);\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private void dfsIslands(int[][] grid, int i, int j, boolean[][] v) {\\n        if (v[i][j]) return;\\n        v[i][j] = true;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {\\n                dfsIslands(grid, ni, nj, v);\\n            }\\n        }\\n    }\\n\\n}\\n```\\n  \\n  </details>\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean ap; //articulation point\\n    int time; //visit time\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    public int minDays(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        ap = false;\\n        time = 0;\\n        int lands = 0, islands = 0;\\n        int[][] depth = new int[n][m];\\n        int[][] low = new int[n][m];\\n        int[][] parent = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(depth[i], -1);\\n            Arrays.fill(low[i], -1);\\n            Arrays.fill(parent[i], -1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    lands++;\\n                    if (depth[i][j] == -1) {\\n                        apDFS(grid, i, j, depth, low, parent);\\n                        islands++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (islands == 0 || islands >= 2) return 0;\\n        if (lands == 1) return 1;\\n        if (ap) return 1;\\n        return 2;\\n    }\\n\\n    private void apDFS(int[][] grid, int i, int j, int[][] depth, int[][] low, int[][] parent) {\\n        int n = grid.length, m = grid[0].length;\\n        depth[i][j] = time++;\\n        low[i][j] = depth[i][j];\\n        int children = 0;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == 1) {\\n                //valid connection\\n                if (depth[ni][nj] == -1) {\\n                    children++;\\n                    parent[ni][nj] = i*m + j;\\n                    apDFS(grid, ni, nj, depth, low, parent);\\n                    low[i][j] = Math.min(low[i][j], low[ni][nj]);\\n                    if (low[ni][nj] >= depth[i][j] && parent[i][j] > -1) {\\n                        ap = true;\\n                    }\\n                } else if (ni*m + nj != parent[i][j]) {//ignore the incoming path\\n                    low[i][j] = Math.min(low[i][j], depth[ni][nj]);\\n                }\\n            }\\n        }\\n        if (parent[i][j] == -1 && children > 1) {\\n            ap = true;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int c = getIslands(grid);\\n        if (c == 0 || c >= 2) return 0;\\n        if (hasOneLand(grid)) return 1;\\n        if (hasBridge(grid)) return 1;\\n        return 2;\\n    }\\n\\n    private boolean hasOneLand(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, c = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && ++c > 1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return c == 1;\\n    }\\n\\n    boolean found = false;//whether there\\'s a bridge\\n    int cnt = 0;//node dfs visit sequence number\\n    private boolean hasBridge(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        found = false;\\n        cnt = 0;\\n        int[][] pre = new int[n][m];\\n        int[][] low = new int[n][m];\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(pre[i], -1);\\n            Arrays.fill(low[i], -1);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && pre[i][j] == -1) {\\n                    bridgeDFS(grid, i, j, i, j, pre, low);\\n                    if (found) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     *\\n     * @param i1 from row\\n     * @param j1 from column\\n     * @param i current row\\n     * @param j current column\\n     * @param pre array that keeps track of current cnt during dfs; -1 means not visited\\n     * @param low lowest pre order that\\'s connected to the current node\\n     */\\n    private void bridgeDFS(int[][] grid, int i1, int j1, int i, int j, int[][] pre, int[][] low) {\\n        int n = grid.length, m = grid[0].length;\\n        pre[i][j] = cnt++;\\n        low[i][j] = pre[i][j];\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m && grid[ni][nj] == 1) {\\n                //valid connection\\n                if (pre[ni][nj] == -1) {\\n                    bridgeDFS(grid, i, j, ni, nj, pre, low);\\n                    low[i][j] = Math.min(low[i][j], low[ni][nj]);\\n                    if (low[ni][nj] == pre[ni][nj]) {\\n                        //i,j to ni, nj is bridge. (i,j) or (ni,nj) must have other neighbors for the cell to be the cut point\\n                        if (hasMoreNeighbors(grid, i, j) || hasMoreNeighbors(grid, ni, nj)) {\\n                            //shortcut, no need to search any more\\n                            found = true;\\n                            return;\\n                        }\\n                    }\\n                } else if (ni != i1 || nj != j1) {//ignore the incoming path\\n                    low[i][j] = Math.min(low[i][j], pre[ni][nj]);\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Returns whether the cell has 2 or more neighbors\\n     */\\n    private boolean hasMoreNeighbors(int[][] grid, int i, int j) {\\n        int c = 0;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {\\n                c++;\\n            }\\n        }\\n        return c > 1;\\n    }\\n\\n    /**\\n     * Gets number of islands\\n     */\\n    private int getIslands(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        boolean[][] v = new boolean[n][m];\\n        int c = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && !v[i][j]) {\\n                    dfsIslands(grid, i, j, v);\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n\\n    int[][] dir = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private void dfsIslands(int[][] grid, int i, int j, boolean[][] v) {\\n        if (v[i][j]) return;\\n        v[i][j] = true;\\n        for (int k = 0; k < dir.length; k++) {\\n            int ni = i + dir[k][0];\\n            int nj = j + dir[k][1];\\n            if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {\\n                dfsIslands(grid, ni, nj, v);\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494932,
                "title": "articulation-point",
                "content": "there are only 3 possible cases:\\n\\n* **if the graph already has more than 1 components**\\n* **if the graph has atleast one articulation point**\\n* **if the graph does\\'t follow those two rules**\\n\\n\\n<br>\\n<br>\\n<br>\\nin the first case the ans is 0 becuse we don\\'t need to convert any 1 to 0 because graph is already disconnected<br>\\nin the second case the ans is 1 because by removing that point graph will be divided into two components<br>\\nin the third case we will make any of the boundry 1 as a seperate componet.<br>\\n\\n**e.g.**<br>\\nin this case the ans is 1 because if we remove any of those nodes graph is divided into two components.<br>\\n\\n![image](https://assets.leetcode.com/users/images/40b6c039-50a7-4e41-b1e7-1cd1f37cad52_1661680065.8876095.png)\\n\\nin that case if we make the boundry 1 as seprate component by removing red cells the graph is disconnected,because either the rest two cells are not valid or it has water in those cells.\\n\\n![image](https://assets.leetcode.com/users/images/0d8af90f-33d0-49b4-9646-4358d43e561d_1661680427.3998525.png)\\n\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        //if the graph has already greater than 1 components than ans is 0\\n        //if the graph has any articulation point than ans is 1\\n        //else ans is 2\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int count = 0;\\n        //discovery time\\n        vector<vector<int>> disc(n,vector<int>(m,0));\\n        //low time\\n        vector<vector<int>> low(n,vector<int>(m,0));\\n        //visited array\\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        //direction array\\n        int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\\n        //if ok is true means there is a articulation point in the graph\\n        bool ok = false;\\n        //dfs call\\n        function<void(int,int,int&,int)> dfs = [&](int x,int y,int &time,int p){\\n            //mark the nodes as visited and update their low and disc time\\n            visited[x][y] = true;\\n            disc[x][y] = low[x][y] = time++;\\n            //for root if there are more than 1 recursive tree than root is a articulation point\\n            int rootCall = 0;\\n            //going in all direction and making a dfs call\\n            for(int i = 0 ; i < 4 ; i++){\\n                int newX = x+dir[i][0];\\n                int newY = y+dir[i][1];\\n                //if child cordinates are valid and there is a 1 at that point ans also it is not parent\\n                if(newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1 && newX*m+newY != p){\\n                    if(!visited[newX][newY]){\\n                        dfs(newX,newY,time,x*m+y);\\n                        //update the low time\\n                        low[x][y] = min(low[x][y],low[newX][newY]);\\n                        //checking whether [x,y] is articulation point or not\\n                        if(p == -1){\\n                            rootCall++;\\n                        }else if(disc[x][y] <= low[newX][newY]){\\n                            ok = true;\\n                        }\\n                    }else{\\n                        //updating the low time\\n                        low[x][y] = min(low[x][y],disc[newX][newY]);\\n                    }\\n                }\\n            }\\n            //if root and more than 1 recurive tree formed than articulation point\\n            if(p == -1 && rootCall > 1){\\n                ok = true;\\n            }\\n        };\\n        //counting the number of 1\\'s and making dfs call\\n        int to1 = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(grid[i][j] == 1){\\n                    to1++;\\n                    if(!visited[i][j]){\\n                        int time = 1;\\n                        dfs(i,j,time,-1);\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(count > 1){\\n            //if more than one components are formed\\n            return 0;\\n        }else if(ok){\\n            //if onlu one component is formed and there is a articulation point\\n            return 1;\\n        }else{\\n            //if total number of 1 is 1\\n            if(to1 == 1){\\n                return 1;\\n            }else if(to1 == 0){\\n                //if total number of 1 is 0\\n                return 0;\\n            }\\n            //else\\n            return 2;\\n        }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        //if the graph has already greater than 1 components than ans is 0\\n        //if the graph has any articulation point than ans is 1\\n        //else ans is 2\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int count = 0;\\n        //discovery time\\n        vector<vector<int>> disc(n,vector<int>(m,0));\\n        //low time\\n        vector<vector<int>> low(n,vector<int>(m,0));\\n        //visited array\\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        //direction array\\n        int dir[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};\\n        //if ok is true means there is a articulation point in the graph\\n        bool ok = false;\\n        //dfs call\\n        function<void(int,int,int&,int)> dfs = [&](int x,int y,int &time,int p){\\n            //mark the nodes as visited and update their low and disc time\\n            visited[x][y] = true;\\n            disc[x][y] = low[x][y] = time++;\\n            //for root if there are more than 1 recursive tree than root is a articulation point\\n            int rootCall = 0;\\n            //going in all direction and making a dfs call\\n            for(int i = 0 ; i < 4 ; i++){\\n                int newX = x+dir[i][0];\\n                int newY = y+dir[i][1];\\n                //if child cordinates are valid and there is a 1 at that point ans also it is not parent\\n                if(newX >= 0 && newX < n && newY >= 0 && newY < m && grid[newX][newY] == 1 && newX*m+newY != p){\\n                    if(!visited[newX][newY]){\\n                        dfs(newX,newY,time,x*m+y);\\n                        //update the low time\\n                        low[x][y] = min(low[x][y],low[newX][newY]);\\n                        //checking whether [x,y] is articulation point or not\\n                        if(p == -1){\\n                            rootCall++;\\n                        }else if(disc[x][y] <= low[newX][newY]){\\n                            ok = true;\\n                        }\\n                    }else{\\n                        //updating the low time\\n                        low[x][y] = min(low[x][y],disc[newX][newY]);\\n                    }\\n                }\\n            }\\n            //if root and more than 1 recurive tree formed than articulation point\\n            if(p == -1 && rootCall > 1){\\n                ok = true;\\n            }\\n        };\\n        //counting the number of 1\\'s and making dfs call\\n        int to1 = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(grid[i][j] == 1){\\n                    to1++;\\n                    if(!visited[i][j]){\\n                        int time = 1;\\n                        dfs(i,j,time,-1);\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if(count > 1){\\n            //if more than one components are formed\\n            return 0;\\n        }else if(ok){\\n            //if onlu one component is formed and there is a articulation point\\n            return 1;\\n        }else{\\n            //if total number of 1 is 1\\n            if(to1 == 1){\\n                return 1;\\n            }else if(to1 == 0){\\n                //if total number of 1 is 0\\n                return 0;\\n            }\\n            //else\\n            return 2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820434,
                "title": "python-o-n-m-articulation-points-beats-100",
                "content": "This question can be divided into 3 cases :\\n\\n1) The most number of cells to be removed in the worst case will be 2, explained later.\\n2) If there is an articulation point, the answer will be 1.\\n3) The matrix is already divided or there are no 1\\'s, the answer is 0.\\n\\n\\nSo, if you didnt understand the worst case scenario, \\nhere is an example:\\n```\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n\\nwe just change two 1\\'s\\n\\n1 0 1 1 1 1\\n0 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n```\\nSo, the answer will be always 2 at max.\\n\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        cnt = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    cnt += 1 # count the number of elements\\n                    root = (i, j) # assign the root node for the graph\\n                    \\n        if cnt <= 1 :  return cnt # no elements in the map\\n        \\n        vis, low, time, res = {root}, {}, {}, []\\n        \\n        # find whether articulation points are present in the matrix\\n        def articulation_points(curr, parent): \\n            low[curr] = time[curr] = len(vis)\\n            children = 0\\n            i, j = curr\\n            \\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                if (x, y) == parent : continue\\n                    \\n                if 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]:\\n                    if (x, y) not in vis:\\n                        vis.add((x,y))\\n                        articulation_points((x,y), curr)\\n                        low[curr] = min(low[curr], low[(x, y)])\\n                        children += 1\\n                        if low[(x, y)] >= time[(curr)] and parent!=(-1, -1):\\n                            res.append([i, j])\\n                    else:\\n                        low[curr] = min(low[curr], time[(x, y)])\\n                        \\n                if parent == (-1, -1) and children > 1:\\n                    res.append([x, y])\\n\\n        articulation_points(root, (-1, -1))\\n\\n        if len(vis) != cnt: # if the matrix is disconnected beforehand\\n            return 0\\n        elif res: # if there are any articulation points\\n            return 1\\n        else: # worst case, no articulation points\\n            return 2\\n            \\n```\\n\\nTime = Space = O(N* M)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n\\nwe just change two 1\\'s\\n\\n1 0 1 1 1 1\\n0 1 1 1 1 1\\n1 1 1 1 1 1\\n1 1 1 1 1 1\\n```\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        cnt = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    cnt += 1 # count the number of elements\\n                    root = (i, j) # assign the root node for the graph\\n                    \\n        if cnt <= 1 :  return cnt # no elements in the map\\n        \\n        vis, low, time, res = {root}, {}, {}, []\\n        \\n        # find whether articulation points are present in the matrix\\n        def articulation_points(curr, parent): \\n            low[curr] = time[curr] = len(vis)\\n            children = 0\\n            i, j = curr\\n            \\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                if (x, y) == parent : continue\\n                    \\n                if 0<=x<len(grid) and 0<=y<len(grid[0]) and grid[x][y]:\\n                    if (x, y) not in vis:\\n                        vis.add((x,y))\\n                        articulation_points((x,y), curr)\\n                        low[curr] = min(low[curr], low[(x, y)])\\n                        children += 1\\n                        if low[(x, y)] >= time[(curr)] and parent!=(-1, -1):\\n                            res.append([i, j])\\n                    else:\\n                        low[curr] = min(low[curr], time[(x, y)])\\n                        \\n                if parent == (-1, -1) and children > 1:\\n                    res.append([x, y])\\n\\n        articulation_points(root, (-1, -1))\\n\\n        if len(vis) != cnt: # if the matrix is disconnected beforehand\\n            return 0\\n        elif res: # if there are any articulation points\\n            return 1\\n        else: # worst case, no articulation points\\n            return 2\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 822726,
                "title": "java-clean-tarjan-o-mn",
                "content": "This question is similar to question 1192 https://leetcode.com/problems/critical-connections-in-a-network/description/\\nwe use tarjan\\'s algorithm to record (every node) id and the (lowest id it can reach), if we find a critical edge, which means we can cut the island two parts by one cut.\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    Map<Integer, Integer> timeMap = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n\\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        if (count == 2) return 2;\\n        buildGraph(grid);                           //build graph\\n        tarjan(-1, root, 0, new HashSet<>());       //(parent, cur, id_time, visietd)\\n        return foundCriticalEdge ? 1 : 2;\\n    }\\n    \\n    private void tarjan(int parent, int cur, int time, Set<Integer> visited) {\\n        visited.add(cur);\\n        timeMap.put(cur, time);\\n        for (int nei : graph.get(cur)) {\\n            if (nei == parent) continue;\\n            if (!visited.contains(nei)) tarjan(cur, nei, time + 1, visited);\\n            if (time < timeMap.get(nei)) foundCriticalEdge = true;\\n            timeMap.put(cur, Math.min(timeMap.get(cur), timeMap.get(nei)));            \\n        }\\n    }\\n    \\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```\\n\\n\\n\\n\\nOr if you prefer the text book version, which is directly transfered from pseudo code\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n    int[] dfn; int[] low;\\n    \\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        if (count == 2) return 2;\\n        buildGraph(grid);                           //build graph\\n        int m = grid.length, n = grid[0].length;\\n        dfn = new int[m * n]; low = new int[m * n]; //Trajan\\'s algorithm\\n        Arrays.fill(dfn, -1);\\n        tarjan(-1, root);                            //(parent, cur, id_time, visietd)\\n        return foundCriticalEdge ? 1 : 2;\\n    }\\n    \\n    private void tarjan(int prev, int cur) {\\n        if (foundCriticalEdge) return;\\n        dfn[cur] = low[cur] = ++time;\\n        for (int nei : graph.get(cur)) {\\n            if (nei == prev) continue;\\n            if (dfn[nei] == -1) {\\n                tarjan(cur, nei);\\n                if (low[nei] > dfn[cur]) {\\n                    foundCriticalEdge = true;\\n                    // return;\\n                }\\n            }\\n            low[cur]=Math.min(low[cur],low[nei]);\\n        }\\n    }\\n    \\n\\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    Map<Integer, Integer> timeMap = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n\\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        if (count == 2) return 2;\\n        buildGraph(grid);                           //build graph\\n        tarjan(-1, root, 0, new HashSet<>());       //(parent, cur, id_time, visietd)\\n        return foundCriticalEdge ? 1 : 2;\\n    }\\n    \\n    private void tarjan(int parent, int cur, int time, Set<Integer> visited) {\\n        visited.add(cur);\\n        timeMap.put(cur, time);\\n        for (int nei : graph.get(cur)) {\\n            if (nei == parent) continue;\\n            if (!visited.contains(nei)) tarjan(cur, nei, time + 1, visited);\\n            if (time < timeMap.get(nei)) foundCriticalEdge = true;\\n            timeMap.put(cur, Math.min(timeMap.get(cur), timeMap.get(nei)));            \\n        }\\n    }\\n    \\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n    int[] dfn; int[] low;\\n    \\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        if (count == 2) return 2;\\n        buildGraph(grid);                           //build graph\\n        int m = grid.length, n = grid[0].length;\\n        dfn = new int[m * n]; low = new int[m * n]; //Trajan\\'s algorithm\\n        Arrays.fill(dfn, -1);\\n        tarjan(-1, root);                            //(parent, cur, id_time, visietd)\\n        return foundCriticalEdge ? 1 : 2;\\n    }\\n    \\n    private void tarjan(int prev, int cur) {\\n        if (foundCriticalEdge) return;\\n        dfn[cur] = low[cur] = ++time;\\n        for (int nei : graph.get(cur)) {\\n            if (nei == prev) continue;\\n            if (dfn[nei] == -1) {\\n                tarjan(cur, nei);\\n                if (low[nei] > dfn[cur]) {\\n                    foundCriticalEdge = true;\\n                    // return;\\n                }\\n            }\\n            low[cur]=Math.min(low[cur],low[nei]);\\n        }\\n    }\\n    \\n\\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819572,
                "title": "c-easy-to-understand-with-explanation-bfs",
                "content": "Looking at the question, it might give an impression as a very difficult question. This question actually is lot easier than it looks. On careful observation, you can notice that the answer can only lie between 0 and 2. \\n\\nWhen does answer can be 0? If the given matrix already contains more than one island or if the matrix doesn\\'t contain any island. When can the answer be 1 or 2 and why can\\'t it be greater than 2?\\n\\nNotice that the question just wants you to disconnect the grid. It doesn\\'t matter how many elements are present in the islands that are formed after disconnecting the original grid. We can disconnect the corners from the island and can achieve a disconnected grid. Disconnecting corners from the original grid require at max 2 operations. Consider the following examples:\\n```\\n0 1 1 0\\n0 1 1 0\\n0 0 0 0\\n```\\nDisconecting the corner (0,1) in the above example requires two operations. grid[0][2]=0 and grid[1][1]=0. Sometimes it requires just one operation like in the following case:\\n```\\n0 1 1 0\\n0 0 1 0\\n0 0 0 0\\n```\\nNote that I am talking about corners of the grid. Corners are connected to a grid in atmax two directions only out of 4 possible directions. But what about the following cases \\n\\n```\\n0 1 1 1 0                     1 1 1 1 1\\n                              1 1 1 0 1\\n```\\nAbove two examples require just one move and that move in both the cases is not a corner. \\nWhat we can do is change one 1 in the entire grid to 0 and check if two islands are formed. If formed, then the answer is 1. If two islands can\\'t be formed by changing just one 1 to 0, then answer is 2. Consider the following algorithm for clear understanding.\\n\\n```\\n1. Check if given grid contains 0 or more than 1 island using bfs. If yes, return 0.\\n2. For each element having value 1 present in the grid, change it to 0 and apply bfs. If more than two islands are formed, then the answer is 1.\\n3. If there is no way we can change just one element to 0 and get a disconnected grid, then the answer is 2.\\n````\\n\\nCheck the following code for clearer understanding:\\n\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>&grid)\\n    {\\n        int num_islands=0;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        unordered_set<int>set;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0 || set.find(i*n+j)!=set.end())\\n                    continue;\\n                num_islands++;\\n                if(num_islands>1)\\n                    return 2;\\n                queue<int>q;\\n                q.push(i*n+j);\\n                set.insert(i*n+j);\\n                while(!q.empty())\\n                {\\n                    int temp=q.front();\\n                    q.pop();\\n                    int x=temp/n;\\n                    int y=temp%n;\\n                    if(x<m-1 && grid[x+1][y]==1 && set.find((x+1)*n+y)==set.end())\\n                    {\\n                        set.insert((x+1)*n+y);\\n                        q.push((x+1)*n+y);\\n                    }\\n                    if(x>0 && grid[x-1][y]==1 && set.find((x-1)*n+y)==set.end())\\n                    {\\n                        set.insert((x-1)*n+y);\\n                        q.push((x-1)*n+y);\\n                    }\\n                    if(y<n-1 && grid[x][y+1]==1 && set.find(x*n+y+1)==set.end())\\n                    {\\n                        set.insert(x*n+y+1);\\n                        q.push(x*n+y+1);\\n                    }\\n                    if(y>0 && grid[x][y-1]==1 && set.find(x*n+y-1)==set.end())\\n                    {\\n                        set.insert(x*n+y-1);\\n                        q.push(x*n+y-1);\\n                    }\\n                }\\n            }\\n        }\\n        return num_islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        if(bfs(grid)!=1)\\n            return 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==0)\\n                    continue;\\n                grid[i][j]=0;\\n                if(bfs(grid)!=1)\\n                    return 1;\\n                grid[i][j]=1;\\n            }\\n        }\\n        return 2;\\n        \\n    }\\n};\\n\\n```\\n\\nComplexity analysis:\\nSince we are performing bfs repeatedly, time complexity of O(m^2 * n^2)\\n```\\nTime complexity: O(m^2 * n^2)\\nSpace complexity: O(m*n)\\n```\\n\\nUpvote if you found the solution useful. If you found any difficulty in understanding the explanation or the code, or if you want to suggest any improvements, please comment.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n0 1 1 0\\n0 1 1 0\\n0 0 0 0\\n```\n```\\n0 1 1 0\\n0 0 1 0\\n0 0 0 0\\n```\n```\\n0 1 1 1 0                     1 1 1 1 1\\n                              1 1 1 0 1\\n```\n```\\n1. Check if given grid contains 0 or more than 1 island using bfs. If yes, return 0.\\n2. For each element having value 1 present in the grid, change it to 0 and apply bfs. If more than two islands are formed, then the answer is 1.\\n3. If there is no way we can change just one element to 0 and get a disconnected grid, then the answer is 2.\\n```\n```\\nclass Solution {\\npublic:\\n    int bfs(vector<vector<int>>&grid)\\n    {\\n        int num_islands=0;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        unordered_set<int>set;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0 || set.find(i*n+j)!=set.end())\\n                    continue;\\n                num_islands++;\\n                if(num_islands>1)\\n                    return 2;\\n                queue<int>q;\\n                q.push(i*n+j);\\n                set.insert(i*n+j);\\n                while(!q.empty())\\n                {\\n                    int temp=q.front();\\n                    q.pop();\\n                    int x=temp/n;\\n                    int y=temp%n;\\n                    if(x<m-1 && grid[x+1][y]==1 && set.find((x+1)*n+y)==set.end())\\n                    {\\n                        set.insert((x+1)*n+y);\\n                        q.push((x+1)*n+y);\\n                    }\\n                    if(x>0 && grid[x-1][y]==1 && set.find((x-1)*n+y)==set.end())\\n                    {\\n                        set.insert((x-1)*n+y);\\n                        q.push((x-1)*n+y);\\n                    }\\n                    if(y<n-1 && grid[x][y+1]==1 && set.find(x*n+y+1)==set.end())\\n                    {\\n                        set.insert(x*n+y+1);\\n                        q.push(x*n+y+1);\\n                    }\\n                    if(y>0 && grid[x][y-1]==1 && set.find(x*n+y-1)==set.end())\\n                    {\\n                        set.insert(x*n+y-1);\\n                        q.push(x*n+y-1);\\n                    }\\n                }\\n            }\\n        }\\n        return num_islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        if(bfs(grid)!=1)\\n            return 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==0)\\n                    continue;\\n                grid[i][j]=0;\\n                if(bfs(grid)!=1)\\n                    return 1;\\n                grid[i][j]=1;\\n            }\\n        }\\n        return 2;\\n        \\n    }\\n};\\n\\n```\n```\\nTime complexity: O(m^2 * n^2)\\nSpace complexity: O(m*n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819426,
                "title": "java-remove-at-most-two",
                "content": "The trick is maximum remove 2 points can get more than two islands.... - -\\nThere is always one node in the cornor, for example:\\n0 1 1 1 0\\n0 1 1 1 0\\n0 1 1 ***1*** 0\\n0 0 0 0 0\\nwe can always remove the point next to the right-bottom 1 to get more than 2 island, this case we remove [1,3],[2,2]\\n0 1 1 1 0\\n0 1 1 0 0\\n0 1 0 ***1*** 0\\n0 0 0 0 0\\nSo only need remove at most 2\\n\\nspecial case, \\n0 1s, then return 0;\\n1 1s, then return 1;\\n\\nJust need to verify the remove 1 point case... \\n```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        Set<Integer> ones = new HashSet<>();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    ones.add(i * grid[0].length + j);\\n                }\\n            }\\n        }\\n        if(ones.size() == 0) return 0;\\n        if(ones.size() == 1) return 1;\\n        if(moreThanOneIsland(grid, ones)) return 0;\\n        \\n        Set<Integer> tmp = new HashSet<>(ones);\\n        for(int one : ones){\\n            tmp.remove(one);\\n            if(moreThanOneIsland(grid, tmp)) return 1;\\n            tmp.add(one);\\n        }\\n        return 2;\\n    }\\n    private int[][] dirs = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n    //if can\\'t access all island, means more than 2 island, O(K)\\n    private boolean moreThanOneIsland(int[][] grid,  Set<Integer> ones){\\n        Queue<Integer> queue = new LinkedList<>();\\n        int start = ones.iterator().next();\\n        queue.offer(start);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        while(!queue.isEmpty()){\\n            int point = queue.poll();\\n            visited.add(start);\\n            int x = point / grid[0].length;\\n            int y = point % grid[0].length;\\n            for(int[] dir : dirs){\\n                int newX = x + dir[0];\\n                int newY = y + dir[1];\\n                if(newX >=0 && newX < grid.length && newY >=0 && newY < grid[0].length){\\n                    int key = newX * grid[0].length + newY;\\n                    if(!visited.contains(key) && ones.contains(key)){\\n                        visited.add(key);\\n                        queue.offer(key);\\n                    }\\n                }\\n            }\\n        }\\n        return visited.size() < ones.size();\\n    }\\n}\\n```\\nTime complexity O(MN + K^2), K is the number of ones\\nSpace O(K)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        Set<Integer> ones = new HashSet<>();\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    ones.add(i * grid[0].length + j);\\n                }\\n            }\\n        }\\n        if(ones.size() == 0) return 0;\\n        if(ones.size() == 1) return 1;\\n        if(moreThanOneIsland(grid, ones)) return 0;\\n        \\n        Set<Integer> tmp = new HashSet<>(ones);\\n        for(int one : ones){\\n            tmp.remove(one);\\n            if(moreThanOneIsland(grid, tmp)) return 1;\\n            tmp.add(one);\\n        }\\n        return 2;\\n    }\\n    private int[][] dirs = new int[][]{{-1,0},{1,0},{0,1},{0,-1}};\\n    //if can\\'t access all island, means more than 2 island, O(K)\\n    private boolean moreThanOneIsland(int[][] grid,  Set<Integer> ones){\\n        Queue<Integer> queue = new LinkedList<>();\\n        int start = ones.iterator().next();\\n        queue.offer(start);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        while(!queue.isEmpty()){\\n            int point = queue.poll();\\n            visited.add(start);\\n            int x = point / grid[0].length;\\n            int y = point % grid[0].length;\\n            for(int[] dir : dirs){\\n                int newX = x + dir[0];\\n                int newY = y + dir[1];\\n                if(newX >=0 && newX < grid.length && newY >=0 && newY < grid[0].length){\\n                    int key = newX * grid[0].length + newY;\\n                    if(!visited.contains(key) && ones.contains(key)){\\n                        visited.add(key);\\n                        queue.offer(key);\\n                    }\\n                }\\n            }\\n        }\\n        return visited.size() < ones.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819849,
                "title": "python-easy",
                "content": "The answer can be atmost 2 as \\n--->For example number of islands are not 1 we can return 0 as there is no need to do anything\\n--->If there is 1 island we can return 1 as 1 step will be sufficient to break them into\\n--->If there is 1 island and we cannot break them into 2 islands in 1 day we are left with only one option which 2 so return 2\\n\\nActually this question can be divided into 2 parts one is [Count islands](https://leetcode.com/problems/number-of-islands/) and next part is as mentioned above\\n\\n\\n\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        \\n        def countislands(grid):\\n            islands = 0\\n            visited = set()\\n\\n            def dfs(grid,row,col,visited):\\n                if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and grid[row][col] == 1 and (row,col) not in visited:\\n                    visited.add((row,col))\\n                    dfs(grid,row+1,col,visited)\\n                    dfs(grid,row-1,col,visited)\\n                    dfs(grid,row,col+1,visited)\\n                    dfs(grid,row,col-1,visited)\\n\\n\\n            for row in range(len(grid)):\\n                for col in range(len(grid[0])):\\n                    if grid[row][col] == 1 and (row,col) not in visited:\\n                        islands += 1\\n                        dfs(grid,row,col,visited)\\n            \\n            return islands\\n        \\n        if countislands(grid) != 1:\\n            return 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    grid[i][j] = 0\\n                    if countislands(grid) != 1:\\n                        return 1\\n                    grid[i][j] = 1\\n        return 2\\n\\t\\t\\n\\t",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "The answer can be atmost 2 as \\n--->For example number of islands are not 1 we can return 0 as there is no need to do anything\\n--->If there is 1 island we can return 1 as 1 step will be sufficient to break them into\\n--->If there is 1 island and we cannot break them into 2 islands in 1 day we are left with only one option which 2 so return 2\\n\\nActually this question can be divided into 2 parts one is [Count islands](https://leetcode.com/problems/number-of-islands/) and next part is as mentioned above\\n\\n\\n\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        \\n        def countislands(grid):\\n            islands = 0\\n            visited = set()\\n\\n            def dfs(grid,row,col,visited):\\n                if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and grid[row][col] == 1 and (row,col) not in visited:\\n                    visited.add((row,col))\\n                    dfs(grid,row+1,col,visited)\\n                    dfs(grid,row-1,col,visited)\\n                    dfs(grid,row,col+1,visited)\\n                    dfs(grid,row,col-1,visited)\\n\\n\\n            for row in range(len(grid)):\\n                for col in range(len(grid[0])):\\n                    if grid[row][col] == 1 and (row,col) not in visited:\\n                        islands += 1\\n                        dfs(grid,row,col,visited)\\n            \\n            return islands\\n        \\n        if countislands(grid) != 1:\\n            return 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]:\\n                    grid[i][j] = 0\\n                    if countislands(grid) != 1:\\n                        return 1\\n                    grid[i][j] = 1\\n        return 2\\n\\t\\t\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 819643,
                "title": "java-tarjan-4ms-with-explain",
                "content": "**Explanation**\\n1. First let\\'s construc a graph\\n2. You want to make at least 2 component (if already more than one, just return 0 by doing a simple DFS/BFS check)\\n3. You want to find a cut point (use tarjan algorithm),the cutpoint is the point where it can split the graph if you remove it and all its adjeccent edges\\n4. What about the graph is a strong component(without cut point)? We can think it as a cycle (circle), which means we need to remove at least 2 points to cut the cycle (circle)\\n\\n```\\nclass Solution {\\n    int cnt=0;\\n    boolean visit[][];\\n    int graph[][];\\n    List<Integer>adjecent[];\\n    int dis[],low[];\\n    int time=1;\\n    boolean cut=false;int root=-1;\\n    public int minDays(int[][] grid) {\\n        \\n        int r=grid.length,c=grid[0].length;\\n        adjecent=new ArrayList[r*c];\\n        dis=new int[r*c];low=new int[r*c];\\n        for(int i=0;i<adjecent.length;i++)adjecent[i]=new ArrayList<>();\\n        visit=new boolean[r][c];\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                sum+=grid[i][j];\\n                if(grid[i][j]==0||visit[i][j])continue;\\n                if(root==-1)root=i*grid[0].length+j;\\n                cnt++;\\n                dfs(grid,i,j);\\n            }\\n        }\\n        \\n        if(cnt>1)return 0;\\n        if(sum<=2)return sum;\\n\\t\\t\\n        for(int i=0;i<grid.length;i++){//build the graph\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0)continue;\\n                mark(grid,i,j,i+1,j);\\n                mark(grid,i,j,i-1,j);\\n                mark(grid,i,j,i,j+1);\\n                mark(grid,i,j,i,j-1);\\n            }\\n        }\\n        tarjan(-1,root);\\n        \\n        if(cut)return 1;\\n        return 2;\\n        \\n       \\n    }\\n    \\n        public void tarjan(int p,int r){\\n            if(cut)return;\\n            List<Integer>childs=adjecent[r];\\n            dis[r]=low[r]=time;\\n            time++;\\n\\n            //core for tarjan, finding critical point\\n            int son=0;\\n            for(int c:childs){\\n                if(c==p)continue;\\n                if(dis[c]==0){\\n                    son++;\\n                    tarjan(r,c);\\n                    low[r]=Math.min(low[r],low[c]);\\n                    if((r==root&&son>1)||(low[c]>=dis[r]&&r!=root)){\\n                        cut=true;\\n                        return;\\n                    }\\n                }else{\\n                    if(c!=p){\\n                        low[r]=Math.min(low[r],dis[c]);\\n                    }\\n                }\\n            }\\n\\n        }\\n    \\n    public void mark(int grid[][],int r,int c,int r1,int c1){\\n        if(r1<0||c1<0||r1>=grid.length||c1>=grid[0].length)return;\\n        if(grid[r1][c1]==0)return;\\n        \\n        int id1=r*grid[0].length+c;\\n        int id2=r1*grid[0].length+c1;\\n        adjecent[id1].add(id2);\\n        adjecent[id2].add(id1);\\n        \\n    }\\n    \\n    public void dfs(int grid[][],int i,int j){\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length)return;\\n        if(grid[i][j]==0)return;\\n        if(visit[i][j])return;\\n        visit[i][j]=true;\\n        dfs(grid,i+1,j);\\n        dfs(grid,i-1,j);\\n        dfs(grid,i,j+1);\\n        dfs(grid,i,j-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int cnt=0;\\n    boolean visit[][];\\n    int graph[][];\\n    List<Integer>adjecent[];\\n    int dis[],low[];\\n    int time=1;\\n    boolean cut=false;int root=-1;\\n    public int minDays(int[][] grid) {\\n        \\n        int r=grid.length,c=grid[0].length;\\n        adjecent=new ArrayList[r*c];\\n        dis=new int[r*c];low=new int[r*c];\\n        for(int i=0;i<adjecent.length;i++)adjecent[i]=new ArrayList<>();\\n        visit=new boolean[r][c];\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                sum+=grid[i][j];\\n                if(grid[i][j]==0||visit[i][j])continue;\\n                if(root==-1)root=i*grid[0].length+j;\\n                cnt++;\\n                dfs(grid,i,j);\\n            }\\n        }\\n        \\n        if(cnt>1)return 0;\\n        if(sum<=2)return sum;\\n\\t\\t\\n        for(int i=0;i<grid.length;i++){//build the graph\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0)continue;\\n                mark(grid,i,j,i+1,j);\\n                mark(grid,i,j,i-1,j);\\n                mark(grid,i,j,i,j+1);\\n                mark(grid,i,j,i,j-1);\\n            }\\n        }\\n        tarjan(-1,root);\\n        \\n        if(cut)return 1;\\n        return 2;\\n        \\n       \\n    }\\n    \\n        public void tarjan(int p,int r){\\n            if(cut)return;\\n            List<Integer>childs=adjecent[r];\\n            dis[r]=low[r]=time;\\n            time++;\\n\\n            //core for tarjan, finding critical point\\n            int son=0;\\n            for(int c:childs){\\n                if(c==p)continue;\\n                if(dis[c]==0){\\n                    son++;\\n                    tarjan(r,c);\\n                    low[r]=Math.min(low[r],low[c]);\\n                    if((r==root&&son>1)||(low[c]>=dis[r]&&r!=root)){\\n                        cut=true;\\n                        return;\\n                    }\\n                }else{\\n                    if(c!=p){\\n                        low[r]=Math.min(low[r],dis[c]);\\n                    }\\n                }\\n            }\\n\\n        }\\n    \\n    public void mark(int grid[][],int r,int c,int r1,int c1){\\n        if(r1<0||c1<0||r1>=grid.length||c1>=grid[0].length)return;\\n        if(grid[r1][c1]==0)return;\\n        \\n        int id1=r*grid[0].length+c;\\n        int id2=r1*grid[0].length+c1;\\n        adjecent[id1].add(id2);\\n        adjecent[id2].add(id1);\\n        \\n    }\\n    \\n    public void dfs(int grid[][],int i,int j){\\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length)return;\\n        if(grid[i][j]==0)return;\\n        if(visit[i][j])return;\\n        visit[i][j]=true;\\n        dfs(grid,i+1,j);\\n        dfs(grid,i-1,j);\\n        dfs(grid,i,j+1);\\n        dfs(grid,i,j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293931,
                "title": "simplest-explanation-with-diagram-articulation-point-tarjan-algo-faster-than-100",
                "content": "# Now, first of all how many solutions can be there, I will say only 0,1 and 2, **why** ?\\n\\n### 1. for \\'0\\'\\na. there is a initially more than one connected components.\\nwhich is quite easy to find, just using a dfs/bfs.\\nb. there is no land (all zeroes in grid).\\n\\n### 2. for \\'2\\'\\n\\n at max you can remove 2 connecting node of any **corner node**(as there always be a corner) to make it disconnected.\\n![image](https://assets.leetcode.com/users/images/158b1e1f-1dc5-49f8-8230-e6791805e69a_1624527641.3018715.png)\\n\\n### 3. for \\'1\\' (most important case)\\na. if there is only one node of land, i.e. only one \\'1\\' in the grid.\\n#### b. if there is any articulation point present in the grid.\\nArticulation point is a point in a graph, which on removing increases the number of connected conponents of that graph.\\nex. **(articulation point marked in red)**\\n1. ![image](https://assets.leetcode.com/users/images/a4a8e3cc-86c1-4534-b318-6e27f68bdd16_1624528648.7351217.png)\\n2. ![image](https://assets.leetcode.com/users/images/514d83a2-da9c-4409-a3c3-8e90bdb1c61c_1624528665.6771123.png)\\n\\nSo what I did is first find that if there is only:\\n1. one \\'1\\': return 1;\\n2. all \\'0\\': return 0;\\n3. all \\'1\\': return 2;\\n\\nThen applied simple tarjan algo to find articulation point(explaining it here is just useless as there are some very nice videos out there on youtube) to find if there is any articuation point or not. And as tarjan algo is just a dfs traversal, it will traverse all the nodes in **one connected component\".** So, if there is any node which is \\'1\\' and not visited yet, then that means that there is more than one connected component (just return 0;). after that if there is any articulation point in the graph, return 1. Otherwise return 2.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int t = 0;\\n    bool isArticulation = 0;\\n    vector<pair<int, int>>moves = {{ -1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    bool check(int r, int c, int n, int m) {\\n        return (r<n and r >= 0 and c<m and c >= 0);\\n    }\\n\\n    void tarjan(int r, int c, vector<vector<int>>&a, vector<vector<int>>&visit_time, vector<vector<int>>&low_time, vector<vector<pair<int, int>>>&parent, int parR, int parC, int n, int m) {\\n        visit_time[r][c] = low_time[r][c] = t;\\n        parent[r][c] = {parR, parC};\\n        t += 1;\\n        int child = 0;\\n        for (auto x : moves) {\\n            if (check(r + x.first, c + x.second, n, m) and a[r + x.first][c + x.second] == 1) {\\n                if (visit_time[r + x.first][c + x.second] == -1) {\\n                    child += 1;\\n                    tarjan(r + x.first, c + x.second, a, visit_time, low_time, parent, r, c, n, m);\\n                    low_time[r][c] = min(low_time[r][c], low_time[r + x.first][c + x.second]);\\n\\n                    if (child > 1 and parent[r][c].first == -1) {\\n                        isArticulation = 1;\\n                        // return;\\n                    }\\n\\n                    if (low_time[r + x.first][c + x.second] >= visit_time[r][c] and parent[r][c].first != -1) {\\n                        isArticulation = 1;\\n                        // return;\\n                    }\\n                }\\n                else if (r + x.first != parent[r][c].first or c + x.second != parent[r][c].second) {\\n                    low_time[r][c] = min(low_time[r][c], low_time[r + x.first][c + x.second]);\\n                }\\n            }\\n        }\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int zeroSum = 0, oneSum = 0;\\n        for (auto x : grid) {\\n            for (auto y : x) {\\n                if (y == 0) zeroSum += 1;\\n                if (y == 1) oneSum += 1;\\n            }\\n        }\\n        if (oneSum == 1) {\\n            return 1;\\n        }\\n\\n        if (zeroSum == n * m) {\\n            return 0;\\n        }\\n        if (oneSum == n * m) {\\n            return 2;\\n        }\\n        vector<vector<int>>visit_time(n, vector<int>(m, -1));\\n        vector<vector<int>>low_time(n, vector<int>(m, INT_MAX));\\n        vector<vector<pair<int, int>>>parent(n, vector<pair<int, int>>(m));\\n        bool tarjanDone = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 and visit_time[i][j] == -1 and !tarjanDone) {\\n                    tarjan(i, j, grid, visit_time, low_time, parent, -1, -1, n, m);\\n                    tarjanDone = 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 and visit_time[i][j] == -1) {\\n                    return 0;\\n                }\\n            }\\n        }\\n\\n        if (isArticulation) {\\n            return 1;\\n        }\\n        return 2;\\n        // return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t = 0;\\n    bool isArticulation = 0;\\n    vector<pair<int, int>>moves = {{ -1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    bool check(int r, int c, int n, int m) {\\n        return (r<n and r >= 0 and c<m and c >= 0);\\n    }\\n\\n    void tarjan(int r, int c, vector<vector<int>>&a, vector<vector<int>>&visit_time, vector<vector<int>>&low_time, vector<vector<pair<int, int>>>&parent, int parR, int parC, int n, int m) {\\n        visit_time[r][c] = low_time[r][c] = t;\\n        parent[r][c] = {parR, parC};\\n        t += 1;\\n        int child = 0;\\n        for (auto x : moves) {\\n            if (check(r + x.first, c + x.second, n, m) and a[r + x.first][c + x.second] == 1) {\\n                if (visit_time[r + x.first][c + x.second] == -1) {\\n                    child += 1;\\n                    tarjan(r + x.first, c + x.second, a, visit_time, low_time, parent, r, c, n, m);\\n                    low_time[r][c] = min(low_time[r][c], low_time[r + x.first][c + x.second]);\\n\\n                    if (child > 1 and parent[r][c].first == -1) {\\n                        isArticulation = 1;\\n                        // return;\\n                    }\\n\\n                    if (low_time[r + x.first][c + x.second] >= visit_time[r][c] and parent[r][c].first != -1) {\\n                        isArticulation = 1;\\n                        // return;\\n                    }\\n                }\\n                else if (r + x.first != parent[r][c].first or c + x.second != parent[r][c].second) {\\n                    low_time[r][c] = min(low_time[r][c], low_time[r + x.first][c + x.second]);\\n                }\\n            }\\n        }\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int zeroSum = 0, oneSum = 0;\\n        for (auto x : grid) {\\n            for (auto y : x) {\\n                if (y == 0) zeroSum += 1;\\n                if (y == 1) oneSum += 1;\\n            }\\n        }\\n        if (oneSum == 1) {\\n            return 1;\\n        }\\n\\n        if (zeroSum == n * m) {\\n            return 0;\\n        }\\n        if (oneSum == n * m) {\\n            return 2;\\n        }\\n        vector<vector<int>>visit_time(n, vector<int>(m, -1));\\n        vector<vector<int>>low_time(n, vector<int>(m, INT_MAX));\\n        vector<vector<pair<int, int>>>parent(n, vector<pair<int, int>>(m));\\n        bool tarjanDone = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 and visit_time[i][j] == -1 and !tarjanDone) {\\n                    tarjan(i, j, grid, visit_time, low_time, parent, -1, -1, n, m);\\n                    tarjanDone = 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 and visit_time[i][j] == -1) {\\n                    return 0;\\n                }\\n            }\\n        }\\n\\n        if (isArticulation) {\\n            return 1;\\n        }\\n        return 2;\\n        // return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638094,
                "title": "easy-java-solution-clean-code",
                "content": "# Java Code\\n---\\n> #### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F\\n---\\n```\\nclass Solution {\\n    int[] xDir = {0,0,-1,1};\\n    int[] yDir = {-1,1,0,0};\\n    public boolean isSafe(int[][] grid,int i,int j,boolean[][] visited)\\n    {\\n        return(i>=0 && j>=0 && i<grid.length  && j<grid[0].length && visited[i][j] == false && grid[i][j] == 1);\\n    }\\n    public void islandCount(int[][] grid,int i,int j,boolean[][] visited)\\n    {\\n        visited[i][j] = true;\\n        for(int k = 0;k<4;k++)\\n        {\\n            int newRow = i+xDir[k];\\n            int newCol = j+yDir[k];\\n            if(isSafe(grid,newRow,newCol,visited))\\n            {\\n                islandCount(grid,newRow,newCol,visited);\\n            }\\n        }\\n    }\\n    public int CountLand(int[][] grid,boolean[][] visited)\\n    {\\n        int count = 0;\\n        for(int i = 0;i<grid.length;i++)\\n        {\\n            for(int j = 0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 1 && visited[i][j] == false)\\n                {\\n                    islandCount(grid,i,j,visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int minDays(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean[][] visited = new boolean[rows][cols];\\n        int count = CountLand(grid,visited);\\n        if(count > 1 || count == 0) return 0;\\n        for(int i = 0;i<rows;i++)\\n        {\\n            for(int j = 0;j<cols;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    grid[i][j] = 0;\\n                    boolean[][] mat = new boolean[rows][cols];\\n                    int count2 = CountLand(grid,mat);\\n                    grid[i][j] = 1;\\n                    if(count2 > 1 || count2 == 0)\\n                    {\\n                        return 1;   \\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```\\n---\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int[] xDir = {0,0,-1,1};\\n    int[] yDir = {-1,1,0,0};\\n    public boolean isSafe(int[][] grid,int i,int j,boolean[][] visited)\\n    {\\n        return(i>=0 && j>=0 && i<grid.length  && j<grid[0].length && visited[i][j] == false && grid[i][j] == 1);\\n    }\\n    public void islandCount(int[][] grid,int i,int j,boolean[][] visited)\\n    {\\n        visited[i][j] = true;\\n        for(int k = 0;k<4;k++)\\n        {\\n            int newRow = i+xDir[k];\\n            int newCol = j+yDir[k];\\n            if(isSafe(grid,newRow,newCol,visited))\\n            {\\n                islandCount(grid,newRow,newCol,visited);\\n            }\\n        }\\n    }\\n    public int CountLand(int[][] grid,boolean[][] visited)\\n    {\\n        int count = 0;\\n        for(int i = 0;i<grid.length;i++)\\n        {\\n            for(int j = 0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 1 && visited[i][j] == false)\\n                {\\n                    islandCount(grid,i,j,visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int minDays(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        boolean[][] visited = new boolean[rows][cols];\\n        int count = CountLand(grid,visited);\\n        if(count > 1 || count == 0) return 0;\\n        for(int i = 0;i<rows;i++)\\n        {\\n            for(int j = 0;j<cols;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    grid[i][j] = 0;\\n                    boolean[][] mat = new boolean[rows][cols];\\n                    int count2 = CountLand(grid,mat);\\n                    grid[i][j] = 1;\\n                    if(count2 > 1 || count2 == 0)\\n                    {\\n                        return 1;   \\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724195,
                "title": "java-2-methods-brute-force-and-articulation-point",
                "content": "```\\n    // b <================= Minimum Number of Days to Disconnect Island ==========>\\n    // https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/\\n\\n    // ! Brute Force, passed since the test case and constraints are small.\\n\\n    public static void dfs_numsIsland(int sr, int sc, int[][] grid, int[][] dir, boolean[][] vis) {\\n        vis[sr][sc] = true;\\n\\n        for (int d = 0; d < dir.length; d++) {\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] == 1 && !vis[r][c]) {\\n                dfs_numsIsland(r, c, grid, dir, vis);\\n            }\\n        }\\n    }\\n\\n    public static int numOfIslands(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        boolean[][] vis = new boolean[n][m];\\n\\n        int noOfIslands = 0;\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n            if (!vis[r][c] && grid[r][c] == 1) {\\n                dfs_numsIsland(r, c, grid, dir, vis);\\n                noOfIslands++;\\n            }\\n        }\\n\\n        return noOfIslands;\\n    }\\n\\n    public int minDays_(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int initialComponents = numOfIslands(grid);\\n        if (initialComponents > 1 || initialComponents == 0)\\n            return 0;\\n\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n\\n            if (grid[r][c] == 1) {\\n                grid[r][c] = 0;\\n                int noOfComponents = numOfIslands(grid);\\n                if (noOfComponents > 1 || noOfComponents == 0)\\n                    return 1;\\n                grid[r][c] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n\\n    // B Optimized using the articulation Point\\n\\n    private static int[] low, disc;\\n    private static int time = 0;\\n    private static boolean[] vis;\\n\\n    public static int dfs_size(int idx, int[][] grid, boolean[] vis) {\\n        int n = grid.length, m = grid[0].length;\\n        int sr = idx / m, sc = idx % m;\\n\\n        vis[idx] = true;\\n\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n        int count = 0;\\n\\n        for (int d = 0; d < dir.length; d++) {\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] == 1 && !vis[r * m + c]) {\\n                count += dfs_size(r * m + c, grid, vis);\\n            }\\n        }\\n\\n        return count + 1;\\n    }\\n\\n    public static boolean tarjans(int src, int par, int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        disc[src] = low[src] = time++;\\n        vis[src] = true;\\n\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\n        boolean res = false;\\n        for (int d = 0; d < dir.length; d++) {\\n            int sr = src / m, sc = src % m;\\n\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == 1) {\\n                int nbr = r * m + c;\\n                if (!vis[nbr]) {\\n                    res = res || tarjans(nbr, src, grid);\\n                    if (disc[src] < low[nbr]) { // Yahan pe equal to sign nhi kiya use. Why? ==> Kyunki hume cycle wale\\n                                                // structure ke liye bhi true return karna tha kyunki wahan pe do vertex\\n                                                // ko nikal ke graph disconnected ban sakta hai. Example is of a square,\\n                                                // removing the diagonal vertex will make component disconnected.\\n                        return true;\\n                    }\\n                    low[src] = Math.min(low[nbr], low[src]);\\n                } else if (nbr != par) {\\n                    low[src] = Math.min(low[src], disc[nbr]);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n\\n        disc = new int[n * m];\\n        low = new int[n * m];\\n        vis = new boolean[n * m];\\n        int root = -1;\\n        int noOfComponents = 0, size = 0;\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n\\n            if (grid[r][c] == 1 && !vis[i]) {\\n                root = i;\\n                size += dfs_size(i, grid, vis);\\n                noOfComponents++;\\n            }\\n        }\\n\\n        if (noOfComponents == 0 || noOfComponents > 1) // Agar mera component 0 hai ya 1 ha se bada hai to mai already\\n                                                       // disconnected hun, to 0 retun kardo\\n            return 0;\\n        else if (size <= 2) // Ab kyunki mai uper component ka check karke aaya hun to mai sure hun ki ab ek\\n                            // he single component hai graph mai. To agar component ka size 1 ya 2 hua, to\\n                            // ` utne he din lagte use disconnect karne mai jitna size hota.\\n            return size;\\n\\n        vis = new boolean[n * m];\\n        boolean res = tarjans(root, -1, grid);\\n        return res ? 1 : 2; // Ab agar mujhe articulation point milta hai to mai to mai 1 return kardunga,\\n                            // aur agar nhi milta hai to mai 2 return kardunga kyunki at most mera answer 2\\n                            // ho sakta hai.\\n\\n    }\\n```\\n\\n## Answer to Why at most can be the answer : \\n\\n![image](https://assets.leetcode.com/users/images/e7c2d449-7122-4bb0-84cc-d9f854f02171_1666238915.071379.png)\\n\\n## Some Notes on Articulation Point :\\n\\n![image](https://assets.leetcode.com/users/images/364a8186-0c6a-40bd-b668-e696974e870c_1666184295.366266.png)\\n\\n![image](https://assets.leetcode.com/users/images/7d7dc322-047e-487d-b119-4affda0b7218_1666184270.9859486.png)\\n\\n![image](https://assets.leetcode.com/users/images/64503ae8-9afa-4965-9c71-3e548078c34b_1666184306.0032978.png)\\n\\n![image](https://assets.leetcode.com/users/images/3203bb2a-2d07-451d-959d-7338615c71b8_1666184313.2574124.png)\\n\\n![image](https://assets.leetcode.com/users/images/73439563-4253-400b-a360-a8066971a046_1666184332.6346247.png)\\n\\n![image](https://assets.leetcode.com/users/images/247c2009-b1d0-4155-942b-0e4a33eeee1e_1666184337.7150605.png)\\n\\n![image](https://assets.leetcode.com/users/images/e3a120a6-fa89-4815-b820-f12cf4d7aae1_1666184358.489158.png)\\n\\n![image](https://assets.leetcode.com/users/images/25d779a5-e6ff-4c93-9618-bb7a37904be0_1666184372.5872371.png)\\n\\n![image](https://assets.leetcode.com/users/images/b8efccce-1fec-4cbc-ab90-4d10760b55da_1666184388.2051961.png)\\n\\n![image](https://assets.leetcode.com/users/images/9c68a388-9d6e-44f5-8cc4-f3a4268e9f4f_1666184408.4437969.png)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    // b <================= Minimum Number of Days to Disconnect Island ==========>\\n    // https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/\\n\\n    // ! Brute Force, passed since the test case and constraints are small.\\n\\n    public static void dfs_numsIsland(int sr, int sc, int[][] grid, int[][] dir, boolean[][] vis) {\\n        vis[sr][sc] = true;\\n\\n        for (int d = 0; d < dir.length; d++) {\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] == 1 && !vis[r][c]) {\\n                dfs_numsIsland(r, c, grid, dir, vis);\\n            }\\n        }\\n    }\\n\\n    public static int numOfIslands(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        boolean[][] vis = new boolean[n][m];\\n\\n        int noOfIslands = 0;\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n            if (!vis[r][c] && grid[r][c] == 1) {\\n                dfs_numsIsland(r, c, grid, dir, vis);\\n                noOfIslands++;\\n            }\\n        }\\n\\n        return noOfIslands;\\n    }\\n\\n    public int minDays_(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        int initialComponents = numOfIslands(grid);\\n        if (initialComponents > 1 || initialComponents == 0)\\n            return 0;\\n\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n\\n            if (grid[r][c] == 1) {\\n                grid[r][c] = 0;\\n                int noOfComponents = numOfIslands(grid);\\n                if (noOfComponents > 1 || noOfComponents == 0)\\n                    return 1;\\n                grid[r][c] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n\\n    // B Optimized using the articulation Point\\n\\n    private static int[] low, disc;\\n    private static int time = 0;\\n    private static boolean[] vis;\\n\\n    public static int dfs_size(int idx, int[][] grid, boolean[] vis) {\\n        int n = grid.length, m = grid[0].length;\\n        int sr = idx / m, sc = idx % m;\\n\\n        vis[idx] = true;\\n\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n        int count = 0;\\n\\n        for (int d = 0; d < dir.length; d++) {\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] == 1 && !vis[r * m + c]) {\\n                count += dfs_size(r * m + c, grid, vis);\\n            }\\n        }\\n\\n        return count + 1;\\n    }\\n\\n    public static boolean tarjans(int src, int par, int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        disc[src] = low[src] = time++;\\n        vis[src] = true;\\n\\n        int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\n        boolean res = false;\\n        for (int d = 0; d < dir.length; d++) {\\n            int sr = src / m, sc = src % m;\\n\\n            int r = sr + dir[d][0];\\n            int c = sc + dir[d][1];\\n\\n            if (r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == 1) {\\n                int nbr = r * m + c;\\n                if (!vis[nbr]) {\\n                    res = res || tarjans(nbr, src, grid);\\n                    if (disc[src] < low[nbr]) { // Yahan pe equal to sign nhi kiya use. Why? ==> Kyunki hume cycle wale\\n                                                // structure ke liye bhi true return karna tha kyunki wahan pe do vertex\\n                                                // ko nikal ke graph disconnected ban sakta hai. Example is of a square,\\n                                                // removing the diagonal vertex will make component disconnected.\\n                        return true;\\n                    }\\n                    low[src] = Math.min(low[nbr], low[src]);\\n                } else if (nbr != par) {\\n                    low[src] = Math.min(low[src], disc[nbr]);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n\\n        disc = new int[n * m];\\n        low = new int[n * m];\\n        vis = new boolean[n * m];\\n        int root = -1;\\n        int noOfComponents = 0, size = 0;\\n        for (int i = 0; i < n * m; i++) {\\n            int r = i / m, c = i % m;\\n\\n            if (grid[r][c] == 1 && !vis[i]) {\\n                root = i;\\n                size += dfs_size(i, grid, vis);\\n                noOfComponents++;\\n            }\\n        }\\n\\n        if (noOfComponents == 0 || noOfComponents > 1) // Agar mera component 0 hai ya 1 ha se bada hai to mai already\\n                                                       // disconnected hun, to 0 retun kardo\\n            return 0;\\n        else if (size <= 2) // Ab kyunki mai uper component ka check karke aaya hun to mai sure hun ki ab ek\\n                            // he single component hai graph mai. To agar component ka size 1 ya 2 hua, to\\n                            // ` utne he din lagte use disconnect karne mai jitna size hota.\\n            return size;\\n\\n        vis = new boolean[n * m];\\n        boolean res = tarjans(root, -1, grid);\\n        return res ? 1 : 2; // Ab agar mujhe articulation point milta hai to mai to mai 1 return kardunga,\\n                            // aur agar nhi milta hai to mai 2 return kardunga kyunki at most mera answer 2\\n                            // ho sakta hai.\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1896493,
                "title": "c-islands-problems-medium-hard",
                "content": "**PLEASE UPVOTE IF YOU FIND MY SOLUTION HELPFUL**\\n\\n```\\nclass Solution {\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    bool vis[31][31];\\n    int noOfIslands(vector<vector<int>>& grid,int &n,int &m)\\n    {\\n       int islands=0;\\n       memset(vis,0,sizeof(vis));\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n           {\\n               if(grid[i][j])\\n               {\\n                   islands++;\\n                   dfs(grid,i,j,n,m);\\n               }\\n           }\\n       }\\n       \\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n               grid[i][j]=vis[i][j]?1:0;\\n       }\\n        \\n        return islands;\\n    }\\n    void dfs(vector<vector<int>>& grid,int i,int j,int &n,int &m)\\n    {\\n        if(i<0||j<0||i>=n||j>=m||!grid[i][j])return;\\n        vis[i][j]=1;\\n        grid[i][j]=0;\\n        \\n        for(int k=0;k<4;k++)\\n        {\\n            int ni=i+dir[k][0];\\n            int nj=j+dir[k][1];\\n            \\n            dfs(grid,ni,nj,n,m);\\n        }\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        //we can disconnect the island into 2 from the corner by at most 2 changes\\n        //00000     00000\\n        //01110     01010\\n        //01110---->00110\\n        //01110     01110\\n        //00000     00000\\n        \\n        //so basically in the worst case we need 2 steps-->ans can be 0,1,2\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        \\n         //edge cases\\n        if(n==1&&m==1)\\n            return grid[0][0];\\n        \\n        if(n*m==2)\\n        {\\n            int countOnes=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              for(int j=0;j<m;j++)\\n              {if(grid[i][j]==1)countOnes++;}\\n          }\\n            return countOnes;\\n        }\\n        \\n        int initialIslands=noOfIslands(grid,n,m);\\n\\n        //made mistake in the checking condition dumbo :\\'( islands must not be one that is it\\n        //zero islands are considered valid cases\\n        \\n        if(initialIslands!=1)return 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int islands=0;\\n                if(grid[i][j])\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0;\\n                    \\n                   islands=noOfIslands(grid,n,m);\\n                  if(islands!=1)return 1; \\n                    \\n                    grid[i][j]=temp;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    bool vis[31][31];\\n    int noOfIslands(vector<vector<int>>& grid,int &n,int &m)\\n    {\\n       int islands=0;\\n       memset(vis,0,sizeof(vis));\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n           {\\n               if(grid[i][j])\\n               {\\n                   islands++;\\n                   dfs(grid,i,j,n,m);\\n               }\\n           }\\n       }\\n       \\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=0;j<m;j++)\\n               grid[i][j]=vis[i][j]?1:0;\\n       }\\n        \\n        return islands;\\n    }\\n    void dfs(vector<vector<int>>& grid,int i,int j,int &n,int &m)\\n    {\\n        if(i<0||j<0||i>=n||j>=m||!grid[i][j])return;\\n        vis[i][j]=1;\\n        grid[i][j]=0;\\n        \\n        for(int k=0;k<4;k++)\\n        {\\n            int ni=i+dir[k][0];\\n            int nj=j+dir[k][1];\\n            \\n            dfs(grid,ni,nj,n,m);\\n        }\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        //we can disconnect the island into 2 from the corner by at most 2 changes\\n        //00000     00000\\n        //01110     01010\\n        //01110---->00110\\n        //01110     01110\\n        //00000     00000\\n        \\n        //so basically in the worst case we need 2 steps-->ans can be 0,1,2\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        \\n         //edge cases\\n        if(n==1&&m==1)\\n            return grid[0][0];\\n        \\n        if(n*m==2)\\n        {\\n            int countOnes=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              for(int j=0;j<m;j++)\\n              {if(grid[i][j]==1)countOnes++;}\\n          }\\n            return countOnes;\\n        }\\n        \\n        int initialIslands=noOfIslands(grid,n,m);\\n\\n        //made mistake in the checking condition dumbo :\\'( islands must not be one that is it\\n        //zero islands are considered valid cases\\n        \\n        if(initialIslands!=1)return 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int islands=0;\\n                if(grid[i][j])\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0;\\n                    \\n                   islands=noOfIslands(grid,n,m);\\n                  if(islands!=1)return 1; \\n                    \\n                    grid[i][j]=temp;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394064,
                "title": "c-articulation-point-o-m-n",
                "content": "Guys, Comment me if you have any questions, Approach is pretty similar to AP but we need to consider some corner cases as well, \\nCase 1 : there is only one island and one land return 1\\nCase 2 : if no of islands are more than one -> in this case we need to return 0;\\nCase 3: there is only one island and two lands return 2;\\nCase 4:  if there is an AP present return 1;\\nCase 5:  No Island return 0;\\nAll other cases:  return 2;\\n\\n\\n```\\nclass Solution {\\n    void dfs(list<int>* adj, vector<bool>& visited, vector<int>& discTime, vector<int>& lowTime, int& ap, int parent, int u){\\n        visited[u] = true;\\n        static int time = 0;\\n        discTime[u] = lowTime[u] = ++time;\\n        \\n        list<int>:: iterator itr;\\n        \\n        for(itr = adj[u].begin(); itr != adj[u].end(); itr++ ){\\n            int v = *itr;\\n            \\n            if(!visited[v]){\\n                dfs(adj, visited, discTime, lowTime, ap, u, v);\\n                lowTime[u] = min(lowTime[u], lowTime[v]);\\n                \\n                if(lowTime[v] > discTime[u]){\\n                    ap++;\\n                }\\n            }\\n            else if(parent != v){\\n                lowTime[u] = min(lowTime[u], discTime[v]);\\n            }\\n        }\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        if(grid.size() == 0) return 0;\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int size = m*n;\\n        int count = 0;\\n        vector<int> disc(size, 0);\\n        vector<int> low(size, 0);\\n        vector<bool> visited(size, false);\\n        int ap = 0;\\n        list<int> adj[size];\\n        int ones = size;\\n        \\n        for(int i = 0; i < m; i++ ){\\n            for(int j = 0; j < n; j++  ){\\n                if(grid[i][j]){\\n                    if(i+1 < m && grid[i+1][j]){\\n                        adj[i*n + j].push_back((i+1)*n + j);\\n                        adj[(i+1)*n + j].push_back(i*n + j);\\n                    }\\n                    if(i-1 >= 0 && grid[i-1][j]){\\n                        adj[i*n + j].push_back((i-1)*n + j);\\n                        adj[(i-1)*n + j].push_back(i*n + j);\\n                    }\\n                    if(j+1 < n && grid[i][j+1]){\\n                        adj[i*n + j].push_back(i*n + (j+1));\\n                        adj[(i*n + (j+1))].push_back(i*n + j);\\n                    }\\n                    if(j-1 >= 0 && grid[i][j-1]){\\n                        adj[i*n + j].push_back(i*n + (j-1));\\n                        adj[(i*n + (j-1))].push_back(i*n + j);\\n                     }         \\n                }\\n                else{\\n                    visited[i*n + j] = true;\\n                    ones--;\\n                }\\n            }\\n        }\\n        \\n        // Case 1 : there is only one island and one land\\n        if(ones == 1) return 1;\\n        \\n        for(int i = 0; i < size; i++ ){\\n            if(!visited[i]){\\n               dfs(adj, visited, disc, low, ap, -1, i);\\n               count++;\\n            }\\n        }\\n        \\n        \\n        // Case 2: island are more than 1 \\n        if(count > 1) return 0;\\n        \\n        // Case 3: there is only one island and two lands\\n        if(ones == 2) return 2;\\n        \\n        // Case 4: if there is an AP present\\n        if(ap) return 1;\\n        \\n\\t\\t// Case 5: No Island\\n        if(count == 0) return 0;\\n        \\n        // All other cases \\n        return 2;\\n    \\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(list<int>* adj, vector<bool>& visited, vector<int>& discTime, vector<int>& lowTime, int& ap, int parent, int u){\\n        visited[u] = true;\\n        static int time = 0;\\n        discTime[u] = lowTime[u] = ++time;\\n        \\n        list<int>:: iterator itr;\\n        \\n        for(itr = adj[u].begin(); itr != adj[u].end(); itr++ ){\\n            int v = *itr;\\n            \\n            if(!visited[v]){\\n                dfs(adj, visited, discTime, lowTime, ap, u, v);\\n                lowTime[u] = min(lowTime[u], lowTime[v]);\\n                \\n                if(lowTime[v] > discTime[u]){\\n                    ap++;\\n                }\\n            }\\n            else if(parent != v){\\n                lowTime[u] = min(lowTime[u], discTime[v]);\\n            }\\n        }\\n    }\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        if(grid.size() == 0) return 0;\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int size = m*n;\\n        int count = 0;\\n        vector<int> disc(size, 0);\\n        vector<int> low(size, 0);\\n        vector<bool> visited(size, false);\\n        int ap = 0;\\n        list<int> adj[size];\\n        int ones = size;\\n        \\n        for(int i = 0; i < m; i++ ){\\n            for(int j = 0; j < n; j++  ){\\n                if(grid[i][j]){\\n                    if(i+1 < m && grid[i+1][j]){\\n                        adj[i*n + j].push_back((i+1)*n + j);\\n                        adj[(i+1)*n + j].push_back(i*n + j);\\n                    }\\n                    if(i-1 >= 0 && grid[i-1][j]){\\n                        adj[i*n + j].push_back((i-1)*n + j);\\n                        adj[(i-1)*n + j].push_back(i*n + j);\\n                    }\\n                    if(j+1 < n && grid[i][j+1]){\\n                        adj[i*n + j].push_back(i*n + (j+1));\\n                        adj[(i*n + (j+1))].push_back(i*n + j);\\n                    }\\n                    if(j-1 >= 0 && grid[i][j-1]){\\n                        adj[i*n + j].push_back(i*n + (j-1));\\n                        adj[(i*n + (j-1))].push_back(i*n + j);\\n                     }         \\n                }\\n                else{\\n                    visited[i*n + j] = true;\\n                    ones--;\\n                }\\n            }\\n        }\\n        \\n        // Case 1 : there is only one island and one land\\n        if(ones == 1) return 1;\\n        \\n        for(int i = 0; i < size; i++ ){\\n            if(!visited[i]){\\n               dfs(adj, visited, disc, low, ap, -1, i);\\n               count++;\\n            }\\n        }\\n        \\n        \\n        // Case 2: island are more than 1 \\n        if(count > 1) return 0;\\n        \\n        // Case 3: there is only one island and two lands\\n        if(ones == 2) return 2;\\n        \\n        // Case 4: if there is an AP present\\n        if(ap) return 1;\\n        \\n\\t\\t// Case 5: No Island\\n        if(count == 0) return 0;\\n        \\n        // All other cases \\n        return 2;\\n    \\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340328,
                "title": "c-2-solutions-clean-code-and-detailed-explanation",
                "content": "The idea:\\nFirst thing to notice is that we need atmost two days to disconnect an island. The intuition is that since diagonal does not count as a connection, given a corner of the island, we can disconnect two of its connections (in fact it only has two connections) to seperate it. Notice that we can do this to any corner of an island.\\n\\nThe intuitive idea is to simply brute force our way through this question. Using a simple dfs, we can count the number of islands. If that number is larger than 1 we know that the island is disconnected. Therefore, let us count the number of island first without doing anything, if the grid is already disconnected, return 0. If the grid is not, we will remove every `1` in the grid and count the number of islands. If that number increase after 1 removal, we know that we can remove only 1 piece. Therefore, we can return 1. However, if removing any `1` won\\'t give us a disconnected grid, we can safely return `2`.\\n\\nThis idea should be alot clearer once you see the implementation:\\n```\\nclass Solution {\\n    \\n    int n;\\n    int m;\\n    \\n    vector<vector<int>> offset{{-1,0},{1,0},{0,-1},{0,1}};\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j) {\\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        for(int k = 0; k < 4; k++) {\\n            dfs(grid, visited, i + offset[k][0], j + offset[k][1]);\\n        }\\n    }\\n    \\n    bool one_islands(vector<vector<int>>& grid) {\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        bool found = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] != 0 && !visited[i][j]) {\\n                    if(!found) {\\n                        found = true;\\n                        dfs(grid, visited, i, j);\\n                    }\\n                    else return false;\\n                }\\n            }\\n        }\\n        \\n        return true && found;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        bool test = one_islands(grid);\\n        if(!test) return 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    bool yes = one_islands(grid);\\n                    if(!yes) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n```\\nCouple of implementation details to address. First, notice that `one_islands` method return `true && found`. This is to account for cases where there is a single `1` in the entire grid. When that happens, we want to make sure that an empty grid is counted as disconnected. Counting the number of islands takes `O(n * m)` worst case we need to count it `n * m` times (a full grid of `1`). Therefore, the time complexity is `O((nm)^2)`, space complexity is `O(nm)` (`visited` array and call stack)\\n\\nThe second idea(Tarjan/Articulation point):\\nSo time complexity of `O((nm)^2)` is not exactly thrilling. Is there a way we can improve this?\\n\\nThink of the grid as an undirected graph. If there is a way for us to remove 1 vertex to disconnect the graph, then we can safely return 1. This \"critical\" vertex is the `Articulation point`. As it turns out, this is a well known problem in finding vulnerabilities in networks and we can use Tarjan\\'s Algorithm to solve this question. \\n\\nShort introduction to Tarjan\\'s algorithm. Tarjan\\'s algorithm is a single pass DFS algorithm that can find all strongly connected components. Tarjan mainly work by keeping track of the highest ancestor a vertex can reach in the DFS tree. This value is often kept within the array `low`. To do this we also need to keep track of the array `disc` which records the discovery time of each vertex. The array `parent` is also important for reasons we will discuss later, but it keeps track of the parent of a vertex in the DFS tree.\\n\\nHow can we use Tarjan to find the articultion point? Well, suppose we are on vertex `u` and we are process one of our children vertex `v`. After we recursived called on it if `low[v] <= disc[u]` it means that there is a path from `v` to a vertex above `u` in the DFS tree, confirming that `u` cannot be the articualtion point (we can reach `v` from that vertex above `u` by reversing the back edge, remember that this is a undirected graph). If `low[v] > disc[u]`, this means that `u` is a \"choke point\" for `v`, making `u` an articulation point. Similary, if `u` is the root of the DFS tree, if it has more than 2 children, it must be an articulation point too. \\n\\nIf you are confused, don\\'t worry, Tarjan\\'s algorithm is not friendly to people who don\\'t understand them fully. I recommend goolging it and watching a few tutorials explaining Tarjan\\'s. In addition, you can try this simmilar question in finding \"bridge\" of a network https://leetcode.com/problems/critical-connections-in-a-network/. Anyways, here is the implementation:\\n```\\nclass Solution {\\n    \\n    int n;\\n    int m;\\n    \\n    int time = 0;\\n    vector<vector<int>> offset{{-1,0},{1,0},{0,-1},{0,1}};\\n    \\n    bool ap(vector<vector<int>>& grid, vector<vector<bool>>& visited, vector<vector<int>>& low,\\n            vector<vector<int>>& disc, vector<vector<int>>& parent, int i, int j, bool is_parent) {\\n        int children = 0;\\n        visited[i][j] = true;\\n        \\n        disc[i][j] = low[i][j] = ++time;\\n        \\n        for(int k = 0; k < 4; k++) {\\n            int ci = i + offset[k][0];\\n            int cj = j + offset[k][1];\\n            \\n            if(ci < 0 || ci >= n || cj < 0 || cj >= m || grid[ci][cj] == 0) continue;\\n            \\n            if(!visited[ci][cj]) {\\n                children++;\\n                parent[ci][cj] = i * m + j;\\n                bool terminate = ap(grid, visited, low, disc, parent, ci, cj, false);\\n                if(terminate) return true;\\n                \\n                low[i][j] = min(low[i][j], low[ci][cj]);\\n                \\n                if(is_parent && children > 1) return true;\\n                \\n                if(!is_parent && low[ci][cj] >= disc[i][j]) return true;\\n            } else if (ci != parent[i][j] / m || cj != parent[i][j] % m) {\\n                low[i][j] = min(low[i][j], disc[ci][cj]);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j) {\\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        for(int k = 0; k < 4; k++) {\\n            dfs(grid, visited, i + offset[k][0], j + offset[k][1]);\\n        }\\n    }\\n    \\n    bool one_islands(vector<vector<int>>& grid) {\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        bool found = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] != 0 && !visited[i][j]) {\\n                    if(!found) {\\n                        found = true;\\n                        dfs(grid, visited, i, j);\\n                    }\\n                    else return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        bool test = one_islands(grid);\\n        if(!test) return 0;\\n        \\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        vector<vector<int>> low(n, vector<int>(m, 0));\\n        vector<vector<int>> disc(n, vector<int>(m, 0));\\n        vector<vector<int>> parent(n, vector<int>(m, 0));\\n        \\n        int start_i = 0;\\n        int start_j = 0;\\n        for(; start_i < n; start_i++) {\\n            for(start_j = 0; start_j < m; start_j++) {\\n                if(grid[start_i][start_j] != 0) goto OUT;\\n            }\\n        }\\n        \\n        OUT:\\n        \\n        test = ap(grid, visited, low, disc, parent, start_i, start_j, true);\\n        if(test || time == 1) return 1;\\n        \\n        return 2;\\n    }\\n};\\n```\\nNotice that we have to check `ci != parent[i][j] / m || cj != parent[i][j] % m` to make sure that we don\\'t use an edge twice. Tarjan has the time complexity of `O(nm)`, therefore the entire algorithm has the time complexity of `O(nm)`. The space complexity is also `O(nm)` but with a lot more hidden constants.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int n;\\n    int m;\\n    \\n    vector<vector<int>> offset{{-1,0},{1,0},{0,-1},{0,1}};\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j) {\\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        for(int k = 0; k < 4; k++) {\\n            dfs(grid, visited, i + offset[k][0], j + offset[k][1]);\\n        }\\n    }\\n    \\n    bool one_islands(vector<vector<int>>& grid) {\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        bool found = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] != 0 && !visited[i][j]) {\\n                    if(!found) {\\n                        found = true;\\n                        dfs(grid, visited, i, j);\\n                    }\\n                    else return false;\\n                }\\n            }\\n        }\\n        \\n        return true && found;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        bool test = one_islands(grid);\\n        if(!test) return 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    bool yes = one_islands(grid);\\n                    if(!yes) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n    int n;\\n    int m;\\n    \\n    int time = 0;\\n    vector<vector<int>> offset{{-1,0},{1,0},{0,-1},{0,1}};\\n    \\n    bool ap(vector<vector<int>>& grid, vector<vector<bool>>& visited, vector<vector<int>>& low,\\n            vector<vector<int>>& disc, vector<vector<int>>& parent, int i, int j, bool is_parent) {\\n        int children = 0;\\n        visited[i][j] = true;\\n        \\n        disc[i][j] = low[i][j] = ++time;\\n        \\n        for(int k = 0; k < 4; k++) {\\n            int ci = i + offset[k][0];\\n            int cj = j + offset[k][1];\\n            \\n            if(ci < 0 || ci >= n || cj < 0 || cj >= m || grid[ci][cj] == 0) continue;\\n            \\n            if(!visited[ci][cj]) {\\n                children++;\\n                parent[ci][cj] = i * m + j;\\n                bool terminate = ap(grid, visited, low, disc, parent, ci, cj, false);\\n                if(terminate) return true;\\n                \\n                low[i][j] = min(low[i][j], low[ci][cj]);\\n                \\n                if(is_parent && children > 1) return true;\\n                \\n                if(!is_parent && low[ci][cj] >= disc[i][j]) return true;\\n            } else if (ci != parent[i][j] / m || cj != parent[i][j] % m) {\\n                low[i][j] = min(low[i][j], disc[ci][cj]);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j) {\\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j] || grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        for(int k = 0; k < 4; k++) {\\n            dfs(grid, visited, i + offset[k][0], j + offset[k][1]);\\n        }\\n    }\\n    \\n    bool one_islands(vector<vector<int>>& grid) {\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        bool found = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] != 0 && !visited[i][j]) {\\n                    if(!found) {\\n                        found = true;\\n                        dfs(grid, visited, i, j);\\n                    }\\n                    else return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        \\n        bool test = one_islands(grid);\\n        if(!test) return 0;\\n        \\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        vector<vector<int>> low(n, vector<int>(m, 0));\\n        vector<vector<int>> disc(n, vector<int>(m, 0));\\n        vector<vector<int>> parent(n, vector<int>(m, 0));\\n        \\n        int start_i = 0;\\n        int start_j = 0;\\n        for(; start_i < n; start_i++) {\\n            for(start_j = 0; start_j < m; start_j++) {\\n                if(grid[start_i][start_j] != 0) goto OUT;\\n            }\\n        }\\n        \\n        OUT:\\n        \\n        test = ap(grid, visited, low, disc, parent, start_i, start_j, true);\\n        if(test || time == 1) return 1;\\n        \\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910145,
                "title": "c-bfs-islands-problems-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAll the posted solutions are using the similar basic flow:\\n\\n- If there is no island or more than 1 island, return 0;\\n- If there is only one land, return 1;\\n- If any single cell could serve as the cut point ( divide 1 island into 2 islands), return 1;\\n- Otherwise, return 2 \\n\\n# Approach\\nUsing BFS to find number of island after replacing land to water\\n\\n<!-- Time Complexity: O((m*n)^2) -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dx = {1, 0, -1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    int number_of_island(vector<vector<int>>&grid, int row, int col)\\n    {\\n        vector<vector<int>>vis(row, vector<int>(col, 0));\\n        int count = 0; //number of island\\n        queue<pair<int, int>>q;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j] == 0)\\n                {\\n                    vis[i][j] = 1;\\n                    q.push({i,j});\\n                    count++;\\n                    while(q.empty()==false)\\n                    {\\n                        int sz = q.size();\\n                        while(sz--)\\n                        {\\n                            auto curr = q.front(); q.pop();\\n                            int f = curr.first;\\n                            int s = curr.second;\\n                            for(int k=0;k<4;k++)\\n                            {\\n                                int u = f + dx[k];\\n                                int v = s + dy[k];\\n                                if(u < row && u >= 0 && v < col && v >= 0  && grid[u][v] == 1 && vis[u][v] == 0 )\\n                                {\\n                                    q.push({u, v});\\n                                    vis[u][v] =1 ;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int count = number_of_island(grid, row, col); // initial number of island\\n        \\n        if (count > 1 or count == 0)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int islands = 0;\\n                if(grid[i][j]==1)\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0; // change land to water\\n                    \\n                    islands=number_of_island(grid,row,col);\\n                    if(islands!=1)\\n                        return 1; \\n                    \\n                    grid[i][j]=temp; // replace our changed water cell to land \\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dx = {1, 0, -1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    int number_of_island(vector<vector<int>>&grid, int row, int col)\\n    {\\n        vector<vector<int>>vis(row, vector<int>(col, 0));\\n        int count = 0; //number of island\\n        queue<pair<int, int>>q;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j] == 0)\\n                {\\n                    vis[i][j] = 1;\\n                    q.push({i,j});\\n                    count++;\\n                    while(q.empty()==false)\\n                    {\\n                        int sz = q.size();\\n                        while(sz--)\\n                        {\\n                            auto curr = q.front(); q.pop();\\n                            int f = curr.first;\\n                            int s = curr.second;\\n                            for(int k=0;k<4;k++)\\n                            {\\n                                int u = f + dx[k];\\n                                int v = s + dy[k];\\n                                if(u < row && u >= 0 && v < col && v >= 0  && grid[u][v] == 1 && vis[u][v] == 0 )\\n                                {\\n                                    q.push({u, v});\\n                                    vis[u][v] =1 ;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int count = number_of_island(grid, row, col); // initial number of island\\n        \\n        if (count > 1 or count == 0)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int islands = 0;\\n                if(grid[i][j]==1)\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0; // change land to water\\n                    \\n                    islands=number_of_island(grid,row,col);\\n                    if(islands!=1)\\n                        return 1; \\n                    \\n                    grid[i][j]=temp; // replace our changed water cell to land \\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385133,
                "title": "java-easy-dfs-using-number-of-islands",
                "content": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int n = grid.length ;\\n        int m = grid[0].length ;\\n        if(numIslands(grid) != 1){\\n          return 0;\\n        }\\n        for(int i = 0; i < n;i++ ){\\n          for(int j = 0 ; j < m ; j++){\\n              if(grid[i][j] == 1){\\n                 grid[i][j] = 0;\\n                \\n                 if(numIslands(grid) != 1){\\n                   return 1;\\n                 }\\n                 \\n                 grid[i][j] = 1;\\n              }\\n          }\\n        }\\n      return 2;\\n    }\\n  public int numIslands(int[][] grid) {\\n        int count = 0;\\n        boolean visited[][] = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] != 0 && visited[i][j] == false){\\n                   \\n                    count++;\\n                    countIslands(grid,i,j,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n  private void countIslands(int grid[][],int i,int j,boolean visited[][]){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || visited[i][j] == true){\\n        return;    \\n        } \\n         visited[i][j] = true;\\n         countIslands(grid,i - 1,j,visited);\\n         countIslands(grid,i + 1,j,visited);\\n         countIslands(grid,i,j - 1,visited);\\n         countIslands(grid,i,j + 1,visited);\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int n = grid.length ;\\n        int m = grid[0].length ;\\n        if(numIslands(grid) != 1){\\n          return 0;\\n        }\\n        for(int i = 0; i < n;i++ ){\\n          for(int j = 0 ; j < m ; j++){\\n              if(grid[i][j] == 1){\\n                 grid[i][j] = 0;\\n                \\n                 if(numIslands(grid) != 1){\\n                   return 1;\\n                 }\\n                 \\n                 grid[i][j] = 1;\\n              }\\n          }\\n        }\\n      return 2;\\n    }\\n  public int numIslands(int[][] grid) {\\n        int count = 0;\\n        boolean visited[][] = new boolean[grid.length][grid[0].length];\\n        \\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] != 0 && visited[i][j] == false){\\n                   \\n                    count++;\\n                    countIslands(grid,i,j,visited);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n  private void countIslands(int grid[][],int i,int j,boolean visited[][]){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0 || visited[i][j] == true){\\n        return;    \\n        } \\n         visited[i][j] = true;\\n         countIslands(grid,i - 1,j,visited);\\n         countIslands(grid,i + 1,j,visited);\\n         countIslands(grid,i,j - 1,visited);\\n         countIslands(grid,i,j + 1,visited);\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951870,
                "title": "bfs-c-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n    bool safe(int x,int y,int m,int n)\\n    {\\n        return (x>=0&&x<m&&y>=0&&y<n);\\n    }\\n    void travel(int i,int j,vector<vector<int> > &grid,vector<vector<int> > &visited)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<pair<int,int > >q;\\n        q.push({i,j});\\n        visited[i][j]=1;\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nx=x+dx[k];\\n                int ny=y+dy[k];\\n                                  \\n                if(safe(nx,ny,m,n)&&!visited[nx][ny]&&grid[nx][ny]==1)\\n                {\\n                    visited[nx][ny]=1;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return ;\\n    }\\n    int bfs(vector<vector<int> > &grid)\\n    {\\n        //number of connected component\\n        int count=0;\\n        int m=grid.size();\\n        if(m==0)\\n            return 0;\\n        int n=grid[0].size();\\n        vector<vector<int> > visited(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1&&!visited[i][j])\\n                {\\n                    count++;\\n                    travel(i,j,grid,visited);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int count=bfs(grid);\\n        if(count!=1)\\n            return 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    \\n                    count=bfs(grid);\\n                    if(count!=1)\\n                        return 1;\\n                    \\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n    bool safe(int x,int y,int m,int n)\\n    {\\n        return (x>=0&&x<m&&y>=0&&y<n);\\n    }\\n    void travel(int i,int j,vector<vector<int> > &grid,vector<vector<int> > &visited)\\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        queue<pair<int,int > >q;\\n        q.push({i,j});\\n        visited[i][j]=1;\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n            for(int k=0;k<4;k++)\\n            {\\n                int nx=x+dx[k];\\n                int ny=y+dy[k];\\n                                  \\n                if(safe(nx,ny,m,n)&&!visited[nx][ny]&&grid[nx][ny]==1)\\n                {\\n                    visited[nx][ny]=1;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        return ;\\n    }\\n    int bfs(vector<vector<int> > &grid)\\n    {\\n        //number of connected component\\n        int count=0;\\n        int m=grid.size();\\n        if(m==0)\\n            return 0;\\n        int n=grid[0].size();\\n        vector<vector<int> > visited(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1&&!visited[i][j])\\n                {\\n                    count++;\\n                    travel(i,j,grid,visited);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int count=bfs(grid);\\n        if(count!=1)\\n            return 0;\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    \\n                    count=bfs(grid);\\n                    if(count!=1)\\n                        return 1;\\n                    \\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819402,
                "title": "java-bfs",
                "content": "If you look carefully, the result is 0, 1, or 2;\\n1, if num of islands not 1, reutrn 0;\\n2, special cases, only one 1 or two 1s;\\n3, try to remove any 1 that has more than 1 neighbors, if it splits the islands, return 1;\\n4, otherwise return 2;\\n\\n```\\nclass Solution {\\n    Queue<int[]> connects;\\n    public int minDays(int[][] g) {\\n        int m = g.length, n = g[0].length, ones = 0, dir[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        connects = new LinkedList<>();\\n        if (getNumOfIslandsAndConnects(g) != 1) return 0;\\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) ones += g[i][j];\\n        if (ones <= 2) return ones;\\n        while(!connects.isEmpty()) {  // only check ones with neigs > 1, which potentially connects 2 islands\\n            int[] curr = connects.poll();\\n            g[curr[0]][curr[1]] = 0;\\n            if (getNumOfIslandsOnly(g) > 1) return 1;\\n            g[curr[0]][curr[1]] = 1;\\n        }\\n        return 2;\\n    }\\n    \\n    private int getNumOfIslandsAndConnects(int[][] g){\\n        return getNumOfIslands(g, true);\\n    }\\n    \\n    private int getNumOfIslandsOnly(int[][] g){\\n        return getNumOfIslands(g, false);\\n    }\\n    \\n    private int getNumOfIslands(int[][] g, boolean setConnects){\\n        int m = g.length, n = g[0].length, islands = 0, dir[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] vs = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (g[i][j] == 0 || vs[i][j]) continue;\\n                islands++;\\n                Queue<int[]> q = new LinkedList<>();\\n                q.offer(new int[]{i, j});\\n                vs[i][j] = true;\\n                while (!q.isEmpty()) {\\n                    int[] cur = q.poll();\\n                    int numOfNeigs = 0;\\n                    for(int[] d : dir) {\\n                        int row = cur[0] + d[0], col = cur[1] + d[1];\\n                        if (row < 0 || row >= m || col < 0 || col >= n || g[row][col] == 0) continue;\\n                        numOfNeigs++;\\n                        if (vs[row][col]) continue;\\n                        vs[row][col] = true;\\n                        q.offer(new int[]{row, col});\\n                    }\\n                    if (setConnects && numOfNeigs > 1) connects.offer(cur);   // connects has more than 1 neighbors\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Queue<int[]> connects;\\n    public int minDays(int[][] g) {\\n        int m = g.length, n = g[0].length, ones = 0, dir[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        connects = new LinkedList<>();\\n        if (getNumOfIslandsAndConnects(g) != 1) return 0;\\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) ones += g[i][j];\\n        if (ones <= 2) return ones;\\n        while(!connects.isEmpty()) {  // only check ones with neigs > 1, which potentially connects 2 islands\\n            int[] curr = connects.poll();\\n            g[curr[0]][curr[1]] = 0;\\n            if (getNumOfIslandsOnly(g) > 1) return 1;\\n            g[curr[0]][curr[1]] = 1;\\n        }\\n        return 2;\\n    }\\n    \\n    private int getNumOfIslandsAndConnects(int[][] g){\\n        return getNumOfIslands(g, true);\\n    }\\n    \\n    private int getNumOfIslandsOnly(int[][] g){\\n        return getNumOfIslands(g, false);\\n    }\\n    \\n    private int getNumOfIslands(int[][] g, boolean setConnects){\\n        int m = g.length, n = g[0].length, islands = 0, dir[][] = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] vs = new boolean[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (g[i][j] == 0 || vs[i][j]) continue;\\n                islands++;\\n                Queue<int[]> q = new LinkedList<>();\\n                q.offer(new int[]{i, j});\\n                vs[i][j] = true;\\n                while (!q.isEmpty()) {\\n                    int[] cur = q.poll();\\n                    int numOfNeigs = 0;\\n                    for(int[] d : dir) {\\n                        int row = cur[0] + d[0], col = cur[1] + d[1];\\n                        if (row < 0 || row >= m || col < 0 || col >= n || g[row][col] == 0) continue;\\n                        numOfNeigs++;\\n                        if (vs[row][col]) continue;\\n                        vs[row][col] = true;\\n                        q.offer(new int[]{row, col});\\n                    }\\n                    if (setConnects && numOfNeigs > 1) connects.offer(cur);   // connects has more than 1 neighbors\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819368,
                "title": "easy-c-solution-with-full-explanation",
                "content": "# Connected Components\\n**Look closely, the answer of the question can not be greater than 2.**\\n\\nAlgo:\\n1. First Check if the connected components are already greater than 1, if yes return 0\\n2. Then do the following:\\n    for every grid value of 1, set it up for 0, check connected components, if connect components are now > 1 return ans 1, else set it up for 1 again\\n3. if ans is not returned till now, ans must be 2, so just return 2 ;)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int connected_components(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        if(n==0) return 0;\\n        int m=grid[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j]==false)\\n                {\\n                    count++;\\n                    queue<pair<int,int>>q;\\n                    vis[i][j]=true;\\n                    q.push(make_pair(i,j));\\n                    int dir[]={0,1,0,-1,0};\\n                    while(!q.empty())\\n                    {\\n                        auto p= q.front();\\n                        q.pop();\\n                        int x=p.first, y=p.second;\\n                        for(int k=0;k<4;k++)\\n                        {\\n                            int nx= x+dir[k];\\n                            int ny= y+dir[k+1];\\n                            if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny] && !vis[nx][ny])\\n                            {\\n                                vis[nx][ny]=true;\\n                                q.push(make_pair(nx,ny));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int conn= connected_components(grid);\\n        if(conn>1) return 0;\\n\\t\\t\\n        int n=grid.size();\\n        if(n==0) return 0;\\n        int m=grid[0].size();\\n\\t\\t\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    conn= connected_components(grid);\\n                    if(conn>1) return 1;\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int connected_components(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        if(n==0) return 0;\\n        int m=grid[0].size();\\n        \\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j]==false)\\n                {\\n                    count++;\\n                    queue<pair<int,int>>q;\\n                    vis[i][j]=true;\\n                    q.push(make_pair(i,j));\\n                    int dir[]={0,1,0,-1,0};\\n                    while(!q.empty())\\n                    {\\n                        auto p= q.front();\\n                        q.pop();\\n                        int x=p.first, y=p.second;\\n                        for(int k=0;k<4;k++)\\n                        {\\n                            int nx= x+dir[k];\\n                            int ny= y+dir[k+1];\\n                            if(nx>=0 && nx<n && ny>=0 && ny<m && grid[nx][ny] && !vis[nx][ny])\\n                            {\\n                                vis[nx][ny]=true;\\n                                q.push(make_pair(nx,ny));\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int conn= connected_components(grid);\\n        if(conn>1) return 0;\\n\\t\\t\\n        int n=grid.size();\\n        if(n==0) return 0;\\n        int m=grid[0].size();\\n\\t\\t\\n         for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    conn= connected_components(grid);\\n                    if(conn>1) return 1;\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819295,
                "title": "javascript-find-the-critical-points-and-check-o-mnk-k-number-of-critical-point",
                "content": "The maximum answer could only be 2.\\nEx:\\n0111\\n0111\\n0111\\n0000\\n-->\\n0111\\n0011\\n0101\\n0000\\n\\nSince we know this rule. Now we have to do the following steps:\\n1. Is it only one island?\\n\\tYes: Go next Step\\n\\tNo: return 0\\n2. In the step 1, you can check which land connect 2 lands at most\\n    If connect 1 land, return 1\\n\\tIf connect 2 lands, it is critical point\\n3. Check every case by converting critical point to 0\\n\\n```\\nfunction markIsland(x, y, checked, grid, bridges = []) {\\n    let land = 0;\\n    const moves = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n    checked[x][y] = true;\\n    let newi, newj;\\n\\n    for (let move of moves) {\\n        let i = x + move[0],\\n            j = y + move[1];\\n\\n        if (0 <= i && i < grid.length && 0 <= j && j < grid[0].length && grid[i][j] == 1) {\\n            land++;\\n            if (checked[i][j] == false)\\n                markIsland(i, j, checked, grid, bridges);\\n            if (land == 1) {\\n                newi = i;\\n                newj = j;\\n            }\\n        }\\n    }\\n    if (land == 2)\\n        bridges.push([x, y]);\\n    if (land == 1)\\n        bridges.push([newi, newj]);\\n}\\n\\nfunction isOneIsland(grid, bridges) {\\n    const checked = [...Array(grid.length)].map(() => new Array(grid[0].length).fill(false));\\n    let islandCount = 0;\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (!checked[i][j] && grid[i][j] == 1) {\\n                islandCount++;\\n                markIsland(i, j, checked, grid, bridges);\\n            }\\n        }\\n    }\\n    \\n    return islandCount;\\n}\\n\\nvar minDays = function(grid) {\\n    const checked = [...Array(grid.length)].map(() => new Array(grid[0].length).fill(false));\\n    let bridges = [];\\n    let islandCount = isOneIsland(grid, bridges);\\n    if (islandCount !== 1)\\n        return 0;\\n    \\n    for (let [x, y] of bridges) {\\n        grid[x][y] = 0;\\n        if (isOneIsland(grid) !== 1) {\\n            return 1;\\n        }\\n        grid[x][y] = 1;\\n    }\\n    \\n    return 2;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "The maximum answer could only be 2.\\nEx:\\n0111\\n0111\\n0111\\n0000\\n-->\\n0111\\n0011\\n0101\\n0000\\n\\nSince we know this rule. Now we have to do the following steps:\\n1. Is it only one island?\\n\\tYes: Go next Step\\n\\tNo: return 0\\n2. In the step 1, you can check which land connect 2 lands at most\\n    If connect 1 land, return 1\\n\\tIf connect 2 lands, it is critical point\\n3. Check every case by converting critical point to 0\\n\\n```\\nfunction markIsland(x, y, checked, grid, bridges = []) {\\n    let land = 0;\\n    const moves = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n    checked[x][y] = true;\\n    let newi, newj;\\n\\n    for (let move of moves) {\\n        let i = x + move[0],\\n            j = y + move[1];\\n\\n        if (0 <= i && i < grid.length && 0 <= j && j < grid[0].length && grid[i][j] == 1) {\\n            land++;\\n            if (checked[i][j] == false)\\n                markIsland(i, j, checked, grid, bridges);\\n            if (land == 1) {\\n                newi = i;\\n                newj = j;\\n            }\\n        }\\n    }\\n    if (land == 2)\\n        bridges.push([x, y]);\\n    if (land == 1)\\n        bridges.push([newi, newj]);\\n}\\n\\nfunction isOneIsland(grid, bridges) {\\n    const checked = [...Array(grid.length)].map(() => new Array(grid[0].length).fill(false));\\n    let islandCount = 0;\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (!checked[i][j] && grid[i][j] == 1) {\\n                islandCount++;\\n                markIsland(i, j, checked, grid, bridges);\\n            }\\n        }\\n    }\\n    \\n    return islandCount;\\n}\\n\\nvar minDays = function(grid) {\\n    const checked = [...Array(grid.length)].map(() => new Array(grid[0].length).fill(false));\\n    let bridges = [];\\n    let islandCount = isOneIsland(grid, bridges);\\n    if (islandCount !== 1)\\n        return 0;\\n    \\n    for (let [x, y] of bridges) {\\n        grid[x][y] = 0;\\n        if (isOneIsland(grid) !== 1) {\\n            return 1;\\n        }\\n        grid[x][y] = 1;\\n    }\\n    \\n    return 2;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3593822,
                "title": "c-textbook-tarjan-s",
                "content": "This was a bit nuanced to implement but we can use textbook Tarjan\\'s algorithm. First we find the number of 1s in the graph. We will pick one random poin, and apply Tarjan\\'s articulation point finding algorithm. The algo also keeps track of number of nodes it visited.\\n\\nIf the algorithm didn\\'t visited all 1s in the graph, then there are 2 islands, no need to cut off anything. Ans = 0.\\n\\nOtherwise, if we found an articulation point, then the answer can be 1. Otherwise  2 (except if the graph only has 1 single 1, then it\\'s 1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dirs[5] = { 0, 1, 0, -1, 0 };\\n    int n, m;\\n    int visitedCount = 0;\\n    bool dfs(int i, int j, int pi, int pj, int time, \\n        vector<vector<bool>>& visited,\\n        vector<vector<int>>& tin,\\n        vector<vector<int>>& low,\\n        vector<vector<int>>& grid\\n        )\\n    {\\n        visited[i][j] = true;\\n        visitedCount++;\\n        low[i][j] = tin[i][j] = time++;\\n        int children = 0;\\n        int ans = false;\\n        for (int di = 0; di < 4; di++) {\\n            int ii = i + dirs[di];\\n            int jj = j + dirs[di+1];\\n            if (ii < 0 || ii == n || jj < 0 || jj == m) continue;\\n            if (grid[ii][jj] == 0) continue;\\n            if (ii == pi && jj == pj) continue;\\n            if (visited[ii][jj]) {\\n                low[i][j] = min(low[i][j], tin[ii][jj]);\\n            } else {\\n                if (dfs(ii, jj, i, j, time, visited, tin, low, grid)) {\\n                    ans = true;\\n                }\\n                low[i][j] = min(low[i][j], low[ii][jj]);\\n                if (low[ii][jj] >= tin[i][j] && pi != -1 && pj != -1) {\\n                    ans = true;\\n                }\\n                children++;\\n            }\\n        }\\n        if (pi == -1 && pj == -1 && children > 1) {\\n            ans = true;\\n        }\\n        return ans;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(); m = grid[0].size();\\n        vector<vector<int>> tin(n, vector<int>(m));\\n        vector<vector<int>> low(n, vector<int>(m));\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        int found = 0;\\n        int ones = 0;\\n        int ii, jj;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j]) {\\n                    ones++;\\n                    ii = i;\\n                    jj = j;\\n                }\\n            }\\n        }\\n\\n        if (ones == 1) return 1; // edge case\\n        if (ones == 0) return 0; // edge case\\n        bool hasArticulationPoint = dfs(ii, jj, -1, -1, 0, visited, tin, low, grid);\\n        if (ones != visitedCount) {\\n            return 0;\\n        }\\n\\n        return hasArticulationPoint ? 1 : 2;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dirs[5] = { 0, 1, 0, -1, 0 };\\n    int n, m;\\n    int visitedCount = 0;\\n    bool dfs(int i, int j, int pi, int pj, int time, \\n        vector<vector<bool>>& visited,\\n        vector<vector<int>>& tin,\\n        vector<vector<int>>& low,\\n        vector<vector<int>>& grid\\n        )\\n    {\\n        visited[i][j] = true;\\n        visitedCount++;\\n        low[i][j] = tin[i][j] = time++;\\n        int children = 0;\\n        int ans = false;\\n        for (int di = 0; di < 4; di++) {\\n            int ii = i + dirs[di];\\n            int jj = j + dirs[di+1];\\n            if (ii < 0 || ii == n || jj < 0 || jj == m) continue;\\n            if (grid[ii][jj] == 0) continue;\\n            if (ii == pi && jj == pj) continue;\\n            if (visited[ii][jj]) {\\n                low[i][j] = min(low[i][j], tin[ii][jj]);\\n            } else {\\n                if (dfs(ii, jj, i, j, time, visited, tin, low, grid)) {\\n                    ans = true;\\n                }\\n                low[i][j] = min(low[i][j], low[ii][jj]);\\n                if (low[ii][jj] >= tin[i][j] && pi != -1 && pj != -1) {\\n                    ans = true;\\n                }\\n                children++;\\n            }\\n        }\\n        if (pi == -1 && pj == -1 && children > 1) {\\n            ans = true;\\n        }\\n        return ans;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(); m = grid[0].size();\\n        vector<vector<int>> tin(n, vector<int>(m));\\n        vector<vector<int>> low(n, vector<int>(m));\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        int found = 0;\\n        int ones = 0;\\n        int ii, jj;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j]) {\\n                    ones++;\\n                    ii = i;\\n                    jj = j;\\n                }\\n            }\\n        }\\n\\n        if (ones == 1) return 1; // edge case\\n        if (ones == 0) return 0; // edge case\\n        bool hasArticulationPoint = dfs(ii, jj, -1, -1, 0, visited, tin, low, grid);\\n        if (ones != visitedCount) {\\n            return 0;\\n        }\\n\\n        return hasArticulationPoint ? 1 : 2;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237534,
                "title": "simple-dfs-c-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>&vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[row][col]=1;\\n        int delrow[] = {1, -1, 0, 0};\\n        int delcol[] = {0, 0, 1, -1};\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow=row+delrow[i];\\n            int ncol=col+delcol[i];\\n\\nif(nrow>=0&&nrow<n&&ncol>=0&&ncol<m&&!vis[nrow][ncol]&&grid[nrow][ncol]==1)\\n            {\\n            dfs(nrow,ncol,grid,vis);\\n            }\\n        }\\n    }\\n    int countIsland(vector<vector<int>>& grid)\\n      {  \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int island=0;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j] && grid[i][j]==1)\\n                {\\n                    dfs(i,j,grid,vis);\\n                    island++;\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int islands=countIsland(grid);\\n    //all zero\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = countIsland(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int row,int col,vector<vector<int>>& grid,vector<vector<int>>&vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[row][col]=1;\\n        int delrow[] = {1, -1, 0, 0};\\n        int delcol[] = {0, 0, 1, -1};\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow=row+delrow[i];\\n            int ncol=col+delcol[i];\\n\\nif(nrow>=0&&nrow<n&&ncol>=0&&ncol<m&&!vis[nrow][ncol]&&grid[nrow][ncol]==1)\\n            {\\n            dfs(nrow,ncol,grid,vis);\\n            }\\n        }\\n    }\\n    int countIsland(vector<vector<int>>& grid)\\n      {  \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int island=0;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j] && grid[i][j]==1)\\n                {\\n                    dfs(i,j,grid,vis);\\n                    island++;\\n                }\\n            }\\n        }\\n        return island;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int islands=countIsland(grid);\\n    //all zero\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = countIsland(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958195,
                "title": "c-bfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(n x m x n x m)\\n\\n- Space complexity:O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        vector<pair<int, int>>po;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        int cnt=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                if(!v[i][j] && grid[i][j]){\\n                    po.push_back({i, j});\\n                    cnt++;\\n                    v[i][j]=1;\\n                    queue<pair<int, int>>q;\\n                    q.push({i, j});\\n                    while(!q.empty()){\\n                        int x=q.front().first, y=q.front().second;\\n                        q.pop();\\n                        int c[4]={0, -1, 0, 1};\\n                        int r[4]={-1, 0, 1, 0};\\n                        for(int k=0; k<4; k++){\\n                            int row=r[k]+x, col=c[k]+y;\\n                            if(isvalid(row, col, grid.size(), grid[0].size())){\\n                                if(!v[row][col] && grid[row][col]){\\n                                    po.push_back({row, col});\\n                                    v[row][col]=1;\\n                                    q.push({row, col});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(cnt==0 || cnt>1){return 0;}\\n        else{\\n            for(int i=0; i<po.size(); i++){\\n                v[po[i].first][po[i].second]=0;\\n                vector<vector<int>>chk(v.size(), vector<int>(v[0].size(), 0));\\n                int cnt1=0;\\n                for(int x=0; x<v.size(); x++){\\n                    for(int j=0; j<v[0].size(); j++){\\n                        if(v[x][j] && !chk[x][j]){\\n                            cnt1++;\\n                            //cout<<x<<\" \"<<j<<endl;\\n                            chk[x][j]=1;\\n                            queue<pair<int, int>>q;\\n                            q.push({x, j});\\n                            while(!q.empty()){\\n                                int x=q.front().first, y=q.front().second;\\n                                q.pop();\\n                                int c[4]={0, -1, 0, 1};\\n                                int r[4]={-1, 0, 1, 0};\\n                                for(int k=0; k<4; k++){\\n                                    int row=r[k]+x, col=c[k]+y;\\n                                    if(isvalid(row, col, grid.size(), grid[0].size())){\\n                                        if(!chk[row][col] && v[row][col]){\\n                                            chk[row][col]=1;\\n                                            q.push({row, col});\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                //cout<<cnt1<<endl;\\n                if(cnt1>1 || cnt1==0){return 1;}\\n                else{v[po[i].first][po[i].second]=1;}\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        vector<pair<int, int>>po;\\n        vector<vector<int>>v(grid.size(), vector<int>(grid[0].size(), 0));\\n        int cnt=0;\\n        for(int i=0; i<v.size(); i++){\\n            for(int j=0; j<v[0].size(); j++){\\n                if(!v[i][j] && grid[i][j]){\\n                    po.push_back({i, j});\\n                    cnt++;\\n                    v[i][j]=1;\\n                    queue<pair<int, int>>q;\\n                    q.push({i, j});\\n                    while(!q.empty()){\\n                        int x=q.front().first, y=q.front().second;\\n                        q.pop();\\n                        int c[4]={0, -1, 0, 1};\\n                        int r[4]={-1, 0, 1, 0};\\n                        for(int k=0; k<4; k++){\\n                            int row=r[k]+x, col=c[k]+y;\\n                            if(isvalid(row, col, grid.size(), grid[0].size())){\\n                                if(!v[row][col] && grid[row][col]){\\n                                    po.push_back({row, col});\\n                                    v[row][col]=1;\\n                                    q.push({row, col});\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(cnt==0 || cnt>1){return 0;}\\n        else{\\n            for(int i=0; i<po.size(); i++){\\n                v[po[i].first][po[i].second]=0;\\n                vector<vector<int>>chk(v.size(), vector<int>(v[0].size(), 0));\\n                int cnt1=0;\\n                for(int x=0; x<v.size(); x++){\\n                    for(int j=0; j<v[0].size(); j++){\\n                        if(v[x][j] && !chk[x][j]){\\n                            cnt1++;\\n                            //cout<<x<<\" \"<<j<<endl;\\n                            chk[x][j]=1;\\n                            queue<pair<int, int>>q;\\n                            q.push({x, j});\\n                            while(!q.empty()){\\n                                int x=q.front().first, y=q.front().second;\\n                                q.pop();\\n                                int c[4]={0, -1, 0, 1};\\n                                int r[4]={-1, 0, 1, 0};\\n                                for(int k=0; k<4; k++){\\n                                    int row=r[k]+x, col=c[k]+y;\\n                                    if(isvalid(row, col, grid.size(), grid[0].size())){\\n                                        if(!chk[row][col] && v[row][col]){\\n                                            chk[row][col]=1;\\n                                            q.push({row, col});\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                //cout<<cnt1<<endl;\\n                if(cnt1>1 || cnt1==0){return 1;}\\n                else{v[po[i].first][po[i].second]=1;}\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2934372,
                "title": "java-easy-solution-with-visuals-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![image.png](https://assets.leetcode.com/users/images/993bfbc9-1371-479a-a6d6-15d2a57ebbe3_1671600258.314148.png)\\n![image.png](https://assets.leetcode.com/users/images/9fd4db9f-d8ec-4cf5-8e79-bec571339146_1671600298.5091133.png)\\n![image.png](https://assets.leetcode.com/users/images/ced7c207-456d-4221-b5c3-a800e62df608_1671600374.1280644.png)\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/9710faee-4626-4ac4-aefd-cb724ae139d0_1671600333.0815878.png)\\n\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(V+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575657,
                "title": "c-dfs-time-o-r-c-r-c-space-o-r-c",
                "content": "DFS solution\\n\\n```\\n// time: O(r * c * r * c)\\n// space: O(r * c)\\n\\nclass Solution {\\npublic:\\n  int minDays(vector<vector<int>>& grid) {\\n    if (numberOfIslands(grid) != 1) // check the initial number of islands\\n      return 0;\\n    \\n    for (int r = 0; r < grid.size(); r++) {\\n      for (int c = 0; c < grid[0].size(); c++) {\\n        if (grid[r][c]) {\\n          grid[r][c] = 0; // remove one land to see whether we can disconnect the entire island\\n          if (numberOfIslands(grid) != 1)\\n            return 1;\\n          grid[r][c] = 1; // reset the land\\n        }\\n      }\\n    }\\n    \\n    return 2; // otherwise need at most 2 days to disconnect\\n  }\\n  \\nprivate:\\n  int numberOfIslands(vector<vector<int>>& grid) {\\n    int islands = 0;\\n    char visited[300][300] {};\\n    \\n    for (int r = 0; r < grid.size(); r++) {\\n      for (int c = 0; c < grid[0].size(); c++) {\\n        islands += dfs(grid, r, c, visited);\\n      }\\n    }\\n    return islands;\\n  }\\n  \\n  int dfs(vector<vector<int>>& grid, int r, int c, char (*visited)[300]) {\\n    if (r < 0 or r >= grid.size() or c < 0 or c >= grid[0].size() or grid[r][c] == 0 or visited[r][c])\\n      return 0;\\n    \\n    visited[r][c] = 1;\\n    \\n    dfs(grid, r+1, c, visited);\\n    dfs(grid, r-1, c, visited);\\n    dfs(grid, r, c+1, visited);\\n    dfs(grid, r, c-1, visited);\\n    \\n    return 1;\\n  }\\n};\\n```\\n\\nThanks for watching : )",
                "solutionTags": [],
                "code": "```\\n// time: O(r * c * r * c)\\n// space: O(r * c)\\n\\nclass Solution {\\npublic:\\n  int minDays(vector<vector<int>>& grid) {\\n    if (numberOfIslands(grid) != 1) // check the initial number of islands\\n      return 0;\\n    \\n    for (int r = 0; r < grid.size(); r++) {\\n      for (int c = 0; c < grid[0].size(); c++) {\\n        if (grid[r][c]) {\\n          grid[r][c] = 0; // remove one land to see whether we can disconnect the entire island\\n          if (numberOfIslands(grid) != 1)\\n            return 1;\\n          grid[r][c] = 1; // reset the land\\n        }\\n      }\\n    }\\n    \\n    return 2; // otherwise need at most 2 days to disconnect\\n  }\\n  \\nprivate:\\n  int numberOfIslands(vector<vector<int>>& grid) {\\n    int islands = 0;\\n    char visited[300][300] {};\\n    \\n    for (int r = 0; r < grid.size(); r++) {\\n      for (int c = 0; c < grid[0].size(); c++) {\\n        islands += dfs(grid, r, c, visited);\\n      }\\n    }\\n    return islands;\\n  }\\n  \\n  int dfs(vector<vector<int>>& grid, int r, int c, char (*visited)[300]) {\\n    if (r < 0 or r >= grid.size() or c < 0 or c >= grid[0].size() or grid[r][c] == 0 or visited[r][c])\\n      return 0;\\n    \\n    visited[r][c] = 1;\\n    \\n    dfs(grid, r+1, c, visited);\\n    dfs(grid, r-1, c, visited);\\n    dfs(grid, r, c+1, visited);\\n    dfs(grid, r, c-1, visited);\\n    \\n    return 1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176459,
                "title": "tarjin-with-c-clean-code-brief-explanation",
                "content": "Intuitives:\\n1. Needs to figure out how many connected islands (classic dfs). If only one island, needs to disconnect.\\n2. At most two steps, the island definitely can be departed. More specificly, is is possible to disconnect with just ONE step?\\n3. Treat the island as a connected graph, and the question transformed to \"find the critical edge in a graph\". For this question,\\n    brutal-force solution is straight forward by cut each graph edge and count the connected components. But to optimize, \\n\\t\"tarjin\" can solve this issue with linear time complexity.\\n\\t \\n\\t\\n        // 1. find all islands\\n        int islands = 0;\\n        int start_x, start_y;\\n        for (int x=0;x<grid.size();++x) {\\n            for (int y=0;y<grid[0].size();++y) {\\n                if (grid[x][y]==1) {\\n                    islands++;\\n                    start_x = x;\\n                    start_y = y;\\n                    dfs(grid,x,y);\\n                }\\n            }\\n        }\\n        if (islands != 1) return 0;\\n        \\n        // 2. corner case, one island with 1 or 2 cells. Since tarjin is targeting edges, a minor difference with nodes.\\n        int cnt = 0;\\n        for (int x=0;x<grid.size();++x) {\\n            for (int y=0;y<grid[0].size();++y) {\\n                if (grid[x][y]==2) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        if (cnt==2 || cnt==1) return cnt;\\n        \\n        \\n        // 3. disconnect islands. Check if critial edge exist\\n        vector<vector<int>> depth(grid.size(), vector<int>(grid[0].size(), -1));\\n        vector<vector<int>> min_depth(grid.size(), vector<int>(grid[0].size(), -1));\\n        if (tarjin({start_x, start_y}, {-1,-1}, grid, depth, min_depth, 0)) {\\n            return 1;\\n        }\\n        return 2;\\n        }\\n    \\n       bool tarjin(vector<int> cur, vector<int> previous, vector<vector<int>>& grid, \\n                vector<vector<int>>& depth, vector<vector<int>>& min_depth, int cur_depth) {\\n          if (depth[cur[0]][cur[1]]!=-1) return false;\\n          depth[cur[0]][cur[1]] = cur_depth;\\n          min_depth[cur[0]][cur[1]] = cur_depth;\\n          // check child nodes, i.e. the grid neighbors\\n          for (auto& next : nexts) {\\n            int next_x = cur[0]+next[0];\\n            int next_y = cur[1]+next[1];\\n            if (next_x<0 || next_x>=grid.size() || next_y<0 || next_y>=grid[0].size()) continue;\\n            if (grid[next_x][next_y] != 2) continue;\\n            // must ignore parent node.\\n            if (next_x == previous[0] && next_y == previous[1]) continue;  \\n            // calculate child nodes\\' min reachable depth.\\n            if (min_depth[next_x][next_y] == -1) { \\n                if (tarjin({next_x, next_y},cur,grid,depth,min_depth,cur_depth+1)) {\\n                    return true;\\n                }\\n            }\\n            if (min_depth[next_x][next_y] > depth[cur[0]][cur[1]]) {\\n                // critical edge detected.\\n                return true;\\n            }\\n            \\n            min_depth[cur[0]][cur[1]] = min(min_depth[cur[0]][cur[1]], min_depth[next_x][next_y]);\\n        }\\n        return false;\\n       }\\n    \\n    \\n       void dfs(vector<vector<int>>& grid, int x, int y) {\\n        if (x<0 || x>=grid.size() || y<0 || y>=grid[0].size() || grid[x][y] != 1) return;\\n        grid[x][y] = 2;\\n        for (auto& next : nexts) {\\n           int next_x = x + next[0];\\n           int next_y = y + next[1];\\n           dfs(grid, next_x, next_y);\\n        }\\n       } \\n",
                "solutionTags": [],
                "code": "Intuitives:\\n1. Needs to figure out how many connected islands (classic dfs). If only one island, needs to disconnect.\\n2. At most two steps, the island definitely can be departed. More specificly, is is possible to disconnect with just ONE step?\\n3. Treat the island as a connected graph, and the question transformed to \"find the critical edge in a graph\". For this question,\\n    brutal-force solution is straight forward by cut each graph edge and count the connected components. But to optimize, \\n\\t\"tarjin\" can solve this issue with linear time complexity.\\n\\t \\n\\t\\n        // 1. find all islands\\n        int islands = 0;\\n        int start_x, start_y;\\n        for (int x=0;x<grid.size();++x) {\\n            for (int y=0;y<grid[0].size();++y) {\\n                if (grid[x][y]==1) {\\n                    islands++;\\n                    start_x = x;\\n                    start_y = y;\\n                    dfs(grid,x,y);\\n                }\\n            }\\n        }\\n        if (islands != 1) return 0;\\n        \\n        // 2. corner case, one island with 1 or 2 cells. Since tarjin is targeting edges, a minor difference with nodes.\\n        int cnt = 0;\\n        for (int x=0;x<grid.size();++x) {\\n            for (int y=0;y<grid[0].size();++y) {\\n                if (grid[x][y]==2) {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        if (cnt==2 || cnt==1) return cnt;\\n        \\n        \\n        // 3. disconnect islands. Check if critial edge exist\\n        vector<vector<int>> depth(grid.size(), vector<int>(grid[0].size(), -1));\\n        vector<vector<int>> min_depth(grid.size(), vector<int>(grid[0].size(), -1));\\n        if (tarjin({start_x, start_y}, {-1,-1}, grid, depth, min_depth, 0)) {\\n            return 1;\\n        }\\n        return 2;\\n        }\\n    \\n       bool tarjin(vector<int> cur, vector<int> previous, vector<vector<int>>& grid, \\n                vector<vector<int>>& depth, vector<vector<int>>& min_depth, int cur_depth) {\\n          if (depth[cur[0]][cur[1]]!=-1) return false;\\n          depth[cur[0]][cur[1]] = cur_depth;\\n          min_depth[cur[0]][cur[1]] = cur_depth;\\n          // check child nodes, i.e. the grid neighbors\\n          for (auto& next : nexts) {\\n            int next_x = cur[0]+next[0];\\n            int next_y = cur[1]+next[1];\\n            if (next_x<0 || next_x>=grid.size() || next_y<0 || next_y>=grid[0].size()) continue;\\n            if (grid[next_x][next_y] != 2) continue;\\n            // must ignore parent node.\\n            if (next_x == previous[0] && next_y == previous[1]) continue;  \\n            // calculate child nodes\\' min reachable depth.\\n            if (min_depth[next_x][next_y] == -1) { \\n                if (tarjin({next_x, next_y},cur,grid,depth,min_depth,cur_depth+1)) {\\n                    return true;\\n                }\\n            }\\n            if (min_depth[next_x][next_y] > depth[cur[0]][cur[1]]) {\\n                // critical edge detected.\\n                return true;\\n            }\\n            \\n            min_depth[cur[0]][cur[1]] = min(min_depth[cur[0]][cur[1]], min_depth[next_x][next_y]);\\n        }\\n        return false;\\n       }\\n    \\n    \\n       void dfs(vector<vector<int>>& grid, int x, int y) {\\n        if (x<0 || x>=grid.size() || y<0 || y>=grid[0].size() || grid[x][y] != 1) return;\\n        grid[x][y] = 2;\\n        for (auto& next : nexts) {\\n           int next_x = x + next[0];\\n           int next_y = y + next[1];\\n           dfs(grid, next_x, next_y);\\n        }\\n       } \\n",
                "codeTag": "Java"
            },
            {
                "id": 2138275,
                "title": "c-the-only-observation-to-solve-the-problem",
                "content": "`You will need at most 2 days.`\\n\\nProof: you can always just isolate the ```1``` in the corner by making his 2 neighbours equal to zero.\\n\\nSo, first we will check the number of islands we have, if it is more than 1 we return 0, because islands are already disconnected. If it is equal to 1, we will replace each of 1\\'s in grid to see if we can create 2 disconnected islands. And if we were not able to divide the island, we return 2.\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m, ones = 0;\\n    vector<int> DIR = {1, 0, -1, 0, 1};\\n    int islands(vector<vector<int>>& grid){   \\n        vector<vector<int>> A(grid.begin(), grid.end());\\n        int count = 0;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(A[i][j])\\n                    helper(i, j, A), count++;\\n        return count;\\n    }\\n    void helper(int i, int j, vector<vector<int>>& A){\\n        if(i < 0 || i == n || j < 0 || j == m || !A[i][j])\\n            return;\\n        A[i][j] = 0;\\n        for(int k = 0; k < 4; k++)\\n            helper(i + DIR[k], j + DIR[k + 1], A);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                ones += grid[i][j];\\n        if(islands(grid) > 1) return 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = 0;\\n                    if(islands(grid) > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return min(2, ones);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```1```\n```\\nclass Solution {\\npublic:\\n    int n, m, ones = 0;\\n    vector<int> DIR = {1, 0, -1, 0, 1};\\n    int islands(vector<vector<int>>& grid){   \\n        vector<vector<int>> A(grid.begin(), grid.end());\\n        int count = 0;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                if(A[i][j])\\n                    helper(i, j, A), count++;\\n        return count;\\n    }\\n    void helper(int i, int j, vector<vector<int>>& A){\\n        if(i < 0 || i == n || j < 0 || j == m || !A[i][j])\\n            return;\\n        A[i][j] = 0;\\n        for(int k = 0; k < 4; k++)\\n            helper(i + DIR[k], j + DIR[k + 1], A);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                ones += grid[i][j];\\n        if(islands(grid) > 1) return 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = 0;\\n                    if(islands(grid) > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return min(2, ones);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950150,
                "title": "beats-100-time-and-100-space",
                "content": "The trick here is that you cannot have more than 2 days as the answer.\\n\\nFirst check whether there are already 2 islands present(return 0) or there is just 1 cell as island(return 1)\\n\\nThen set each cell as water one by one and try to find the number of islands, if it is more than 1, the days needed is 1 else 2.\\n\\n```\\nlet directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\nvar minDays = function(grid) {\\n    let colorNumber = 2;\\n    let landCells = [];\\n    \\n    function colorIsland(i, j) {\\n        grid[i][j] = colorNumber;\\n        for(let k = 0; k < directions.length; k++) {\\n            let newI = i + directions[k][0];\\n            let newJ = j + directions[k][1];\\n            \\n            if(newI >= 0 && newJ >= 0 && newI < grid.length && newJ < grid[0].length && grid[newI][newJ] && grid[newI][newJ] != colorNumber) {\\n                colorIsland(newI, newJ);\\n            }\\n        }\\n    }\\n    \\n    function addLandCells() {\\n        for(let i = 0; i < grid.length; i++) {\\n            for(let j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j]) {\\n                    landCells.push([i, j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    function findAnotherIsland() {\\n        for(let i = 0; i < grid.length; i++) {\\n            for(let j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] && grid[i][j] != colorNumber) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    addLandCells();\\n    \\n    if(landCells.length < 2) {\\n        return landCells.length;\\n    }\\n    \\n    colorIsland(landCells[0][0], landCells[0][1]);\\n    \\n    if(findAnotherIsland()) {\\n        return 0;\\n    }\\n    \\n    colorNumber++;\\n    \\n    for(let i = 0; i < landCells.length; i++) {\\n        grid[landCells[i][0]][landCells[i][1]] = 0;\\n        colorIsland(landCells[(i + 1) % landCells.length][0], landCells[(i + 1) % landCells.length][1]);\\n        if(findAnotherIsland()) {\\n            return 1;\\n        }\\n        grid[landCells[i][0]][landCells[i][1]] = colorNumber;\\n        colorNumber++;\\n    }\\n    \\n    return 2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n\\nvar minDays = function(grid) {\\n    let colorNumber = 2;\\n    let landCells = [];\\n    \\n    function colorIsland(i, j) {\\n        grid[i][j] = colorNumber;\\n        for(let k = 0; k < directions.length; k++) {\\n            let newI = i + directions[k][0];\\n            let newJ = j + directions[k][1];\\n            \\n            if(newI >= 0 && newJ >= 0 && newI < grid.length && newJ < grid[0].length && grid[newI][newJ] && grid[newI][newJ] != colorNumber) {\\n                colorIsland(newI, newJ);\\n            }\\n        }\\n    }\\n    \\n    function addLandCells() {\\n        for(let i = 0; i < grid.length; i++) {\\n            for(let j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j]) {\\n                    landCells.push([i, j]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    function findAnotherIsland() {\\n        for(let i = 0; i < grid.length; i++) {\\n            for(let j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] && grid[i][j] != colorNumber) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    addLandCells();\\n    \\n    if(landCells.length < 2) {\\n        return landCells.length;\\n    }\\n    \\n    colorIsland(landCells[0][0], landCells[0][1]);\\n    \\n    if(findAnotherIsland()) {\\n        return 0;\\n    }\\n    \\n    colorNumber++;\\n    \\n    for(let i = 0; i < landCells.length; i++) {\\n        grid[landCells[i][0]][landCells[i][1]] = 0;\\n        colorIsland(landCells[(i + 1) % landCells.length][0], landCells[(i + 1) % landCells.length][1]);\\n        if(findAnotherIsland()) {\\n            return 1;\\n        }\\n        grid[landCells[i][0]][landCells[i][1]] = colorNumber;\\n        colorNumber++;\\n    }\\n    \\n    return 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1464631,
                "title": "c-similar-to-finding-articulation-point-explained",
                "content": "I\\'ll tell you the steps:\\n1) Convert the grid into a graph.\\n2) If there is only one 1, then you need to remove it (because connected definition says only 1 island)\\n3) Find number of connected components\\n4) If connected components>1 return 0\\n5) Find articulation point\\n6) If articulation point is present, then return 1, else return 2\\nFor the code part of articulation point, you can refer to any youtube tutorial or cp algorithms\\n```\\nclass Solution {\\npublic:\\n    vector<int> adj[904];\\n    vector<int> v;\\n    vector<int> vis;\\n    vector<int> in,low;\\n    int n, m;\\n    int timer;\\n    \\n    void dfsArticulation(int node, int par){\\n        vis[node] = true;\\n        in[node] = low[node] = timer++;\\n        int children=0;\\n        for (int it : adj[node]) {\\n            if (it == par) continue;\\n            if (vis[it]) {\\n                low[node] = min(low[node], in[it]);\\n            } else {\\n                dfsArticulation(it, node);\\n                low[node] = min(low[node], low[it]);\\n                if (low[it] >= in[node] && par!=-1)\\n                    v.push_back(node);\\n                ++children;\\n            }\\n        }\\n        if(par == -1 && children > 1)\\n            v.push_back(node);\\n    }\\n    \\n    void dfs(int i){\\n        vis[i]=true;\\n        for(auto it: adj[i]){\\n            if(!vis[it]) dfs(it);\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        int dx[]={1,0,0,-1};\\n        int dy[]={0,1,-1,0};\\n        int l=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1) {grid[i][j]=l,l++;}\\n            }\\n        }\\n        if(l==2) return 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<4;k++){\\n                    int nx=i+dx[k];\\n                    int ny=j+dy[k];\\n                    if(nx<0 || ny<0 || nx>=n || ny>=m) continue;\\n                    if(grid[i][j] && grid[nx][ny]){\\n                        adj[grid[i][j]].push_back(grid[nx][ny]);\\n                    }\\n                }\\n            }\\n        }\\n       \\n        vis.resize(l,false);\\n        int c=0;\\n        for(int i=1;i<l;i++){\\n            if(vis[i]==false){\\n                dfs(i);\\n                c++;\\n            }\\n        }\\n        if(c>1 || c==0) return 0;\\n        \\n        for(int i=0;i<l;i++){\\n            vis[i]=false;\\n        }\\n        in.resize(l,-1);\\n        low.resize(l,-1);\\n        \\n        for (int i = 1; i < l; ++i) {\\n           \\n            if (!vis[i])\\n                dfsArticulation (i,-1);\\n        }\\n        \\n        if(v.size()>0) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[904];\\n    vector<int> v;\\n    vector<int> vis;\\n    vector<int> in,low;\\n    int n, m;\\n    int timer;\\n    \\n    void dfsArticulation(int node, int par){\\n        vis[node] = true;\\n        in[node] = low[node] = timer++;\\n        int children=0;\\n        for (int it : adj[node]) {\\n            if (it == par) continue;\\n            if (vis[it]) {\\n                low[node] = min(low[node], in[it]);\\n            } else {\\n                dfsArticulation(it, node);\\n                low[node] = min(low[node], low[it]);\\n                if (low[it] >= in[node] && par!=-1)\\n                    v.push_back(node);\\n                ++children;\\n            }\\n        }\\n        if(par == -1 && children > 1)\\n            v.push_back(node);\\n    }\\n    \\n    void dfs(int i){\\n        vis[i]=true;\\n        for(auto it: adj[i]){\\n            if(!vis[it]) dfs(it);\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        int dx[]={1,0,0,-1};\\n        int dy[]={0,1,-1,0};\\n        int l=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1) {grid[i][j]=l,l++;}\\n            }\\n        }\\n        if(l==2) return 1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                for(int k=0;k<4;k++){\\n                    int nx=i+dx[k];\\n                    int ny=j+dy[k];\\n                    if(nx<0 || ny<0 || nx>=n || ny>=m) continue;\\n                    if(grid[i][j] && grid[nx][ny]){\\n                        adj[grid[i][j]].push_back(grid[nx][ny]);\\n                    }\\n                }\\n            }\\n        }\\n       \\n        vis.resize(l,false);\\n        int c=0;\\n        for(int i=1;i<l;i++){\\n            if(vis[i]==false){\\n                dfs(i);\\n                c++;\\n            }\\n        }\\n        if(c>1 || c==0) return 0;\\n        \\n        for(int i=0;i<l;i++){\\n            vis[i]=false;\\n        }\\n        in.resize(l,-1);\\n        low.resize(l,-1);\\n        \\n        for (int i = 1; i < l; ++i) {\\n           \\n            if (!vis[i])\\n                dfsArticulation (i,-1);\\n        }\\n        \\n        if(v.size()>0) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406384,
                "title": "java-dfs-connected-components-with-comments",
                "content": "```\\nclass Solution {\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394785,
                "title": "c-bfs-solution-beginner-friendly-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\t//below code for finding number of connected components\\n    int no_of_conn(vector<vector<int>>& grid){\\n        \\n        int visit[30][30] = {0};\\n        int count =0;\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<grid.size();i++){\\n            \\n            for(int j=0;j<grid[i].size();j++){\\n                \\n                if(grid[i][j]==1 && visit[i][j]==0){\\n                    count++;\\n                    q.push({i,j});\\n                    visit[i][j] = 1;\\n                    \\n                        while(!q.empty()){\\n                            \\n                            int s = q.size();\\n                            \\n                            for(int i=0;i<s;i++){\\n                                auto p = q.front();\\n                                q.pop();\\n                                int x = p.first;\\n                                int y = p.second;\\n    \\n                                if(x+1<grid.size() && visit[x+1][y]==0 && grid[x+1][y]==1){\\n                                    q.push({x+1,y});\\n                                    visit[x+1][y] = 1;\\n                                }\\n                                if(y+1<grid[0].size() && visit[x][y+1]==0 && grid[x][y+1]==1){\\n                                    q.push({x,y+1});\\n                                    visit[x][y+1] = 1;\\n                                }\\n                                if(x-1>=0 && visit[x-1][y]==0 && grid[x-1][y]==1){\\n                                    q.push({x-1,y});\\n                                    visit[x-1][y] = 1;\\n                                }\\n                                if(y-1>=0 && visit[x][y-1]==0 && grid[x][y-1]==1){\\n                                    q.push({x,y-1});\\n                                    visit[x][y-1] = 1;\\n                                }\\n                            }\\n                        }\\n                        \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return count;\\n       \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int num = no_of_conn(grid);\\n        \\n        if(num!=1){\\n            return 0;\\n        }\\n        \\n        \\n            \\n            vector<pair<int,int>> ind;\\n            \\n            for(int i=0;i<grid.size();i++){\\n                \\n                for(int j=0;j<grid[i].size();j++){\\n                    \\n                    if(grid[i][j]==1){\\n                        grid[i][j] = 0;//make that 0\\n                        \\n\\t\\t\\t\\t\\t\\t// check for number of conn components\\n                        if(no_of_conn(grid)!=1){\\n                            return 1;\\n                        }\\n                        \\n                        grid[i][j] =1;//make that 1 again as it was not the desired land\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            \\n            \\n        return 2; //at max we need only 2 days to disconnect any island ...Thinnk about it. :)\\n        \\n        \\n    }\\n};\\n```\\n**Hit like if you liked my solution .. Happy coding :)**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t//below code for finding number of connected components\\n    int no_of_conn(vector<vector<int>>& grid){\\n        \\n        int visit[30][30] = {0};\\n        int count =0;\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<grid.size();i++){\\n            \\n            for(int j=0;j<grid[i].size();j++){\\n                \\n                if(grid[i][j]==1 && visit[i][j]==0){\\n                    count++;\\n                    q.push({i,j});\\n                    visit[i][j] = 1;\\n                    \\n                        while(!q.empty()){\\n                            \\n                            int s = q.size();\\n                            \\n                            for(int i=0;i<s;i++){\\n                                auto p = q.front();\\n                                q.pop();\\n                                int x = p.first;\\n                                int y = p.second;\\n    \\n                                if(x+1<grid.size() && visit[x+1][y]==0 && grid[x+1][y]==1){\\n                                    q.push({x+1,y});\\n                                    visit[x+1][y] = 1;\\n                                }\\n                                if(y+1<grid[0].size() && visit[x][y+1]==0 && grid[x][y+1]==1){\\n                                    q.push({x,y+1});\\n                                    visit[x][y+1] = 1;\\n                                }\\n                                if(x-1>=0 && visit[x-1][y]==0 && grid[x-1][y]==1){\\n                                    q.push({x-1,y});\\n                                    visit[x-1][y] = 1;\\n                                }\\n                                if(y-1>=0 && visit[x][y-1]==0 && grid[x][y-1]==1){\\n                                    q.push({x,y-1});\\n                                    visit[x][y-1] = 1;\\n                                }\\n                            }\\n                        }\\n                        \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return count;\\n       \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int num = no_of_conn(grid);\\n        \\n        if(num!=1){\\n            return 0;\\n        }\\n        \\n        \\n            \\n            vector<pair<int,int>> ind;\\n            \\n            for(int i=0;i<grid.size();i++){\\n                \\n                for(int j=0;j<grid[i].size();j++){\\n                    \\n                    if(grid[i][j]==1){\\n                        grid[i][j] = 0;//make that 0\\n                        \\n\\t\\t\\t\\t\\t\\t// check for number of conn components\\n                        if(no_of_conn(grid)!=1){\\n                            return 1;\\n                        }\\n                        \\n                        grid[i][j] =1;//make that 1 again as it was not the desired land\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n            \\n            \\n        return 2; //at max we need only 2 days to disconnect any island ...Thinnk about it. :)\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375275,
                "title": "articulation-point-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\t/*\\n        We will never need more than 2 days to disconnect the island.\\n        There will always be atleast 1 land-cell which will have atmost 2 neighbouring land cells(cell 1)\\n        Thus, if that land-cell has 2 neighbouring land-cells, our answer is 2 days.\\n        Else, if that land-cell has only 1 neighbouring land-cell, our answer is 1 day.\\n\\t\\t\\n\\t\\tIf there are any articulation points, days=1.\\n        Else days=2.\\n    */\\n    vector<vector<int>> dir{{-1,0},{0,-1},{1,0},{0,1}};\\n    vector<bool> visited;\\n    vector<int> ids;\\n    vector<int> low_links;\\n    // vector<bool> ap;\\n    int flag = 2;\\n    \\n    /*\\n        We don\\'t need ap vector (Articulation Point vector) here, but I\\'m maintaining it for template code\\n        reference. We won\\'t need flag, islands variables in general Articulation point questions.\\n    */\\n    \\n    void articulationPointsUtil(vector<int> adj[], int id, int parent, int u) {\\n        visited[u] = true;\\n        ids[u] = low_links[u] = id++;\\n        int out = 0;\\n        \\n        for(auto v: adj[u]) {\\n            if(v == parent) continue;\\n            if(!visited[v]) {\\n                out++;\\n                articulationPointsUtil(adj, id, u, v);\\n                low_links[u] = min(low_links[u], low_links[v]);\\n                \\n                if(parent == -1 && out > 1) {\\n                    // ap[u] = true;\\n                    flag = 1;\\n                }\\n                \\n                if(parent != -1 && ids[u] <= low_links[v]) {\\n                    // ap[u] = true;\\n                    flag = 1;\\n                }\\n            } else {\\n                low_links[u] = min(low_links[u], ids[v]);\\n            }\\n        }\\n    }\\n    \\n    int articulationPoints(vector<int> adj[], int n) {\\n        visited.resize(n, false);\\n        ids.resize(n);\\n        low_links.resize(n);\\n        // ap.resize(n, false);\\n        \\n        int islands = 0;\\n        for(int i=0; i<n; i++) {\\n            if(!visited[i]) {\\n                islands++;\\n                articulationPointsUtil(adj, 0, -1, i);\\n            }\\n        }\\n        \\n        return (islands == 1) ? flag : 0;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        map<pair<int,int>, int> map;\\n        int id = 0;\\n        int m=grid.size(), n=grid[0].size();\\n        vector<int> adj[m*n];\\n        \\n        if(m*n == 1 && grid[0][0] == 0) return 0;\\n        if(m*n == 1 && grid[0][0] == 1) return 1;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1) {\\n                    int u = (map.find({i,j}) != map.end()) ? map[{i,j}] : id++;\\n                    map[{i,j}] = u;\\n                    \\n                    for(int k=0; k<4; k++) {\\n                        int nx = i + dir[k][0];\\n                        int ny = j + dir[k][1];\\n                        if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]==1) {\\n                            int v = (map.find({nx,ny}) != map.end()) ? map[{nx,ny}] : id++;\\n                            map[{nx,ny}] = v;\\n                            adj[u].push_back(v);\\n                        }\\n                    }\\n                    \\n                    if(u>0 && adj[u].size()==0) return 0;\\n                }\\n            }\\n        }\\n        \\n        if(id==1 && adj[id-1].size()==0) return 1;\\n        \\n        return articulationPoints(adj, id);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t/*\\n        We will never need more than 2 days to disconnect the island.\\n        There will always be atleast 1 land-cell which will have atmost 2 neighbouring land cells(cell 1)\\n        Thus, if that land-cell has 2 neighbouring land-cells, our answer is 2 days.\\n        Else, if that land-cell has only 1 neighbouring land-cell, our answer is 1 day.\\n\\t\\t\\n\\t\\tIf there are any articulation points, days=1.\\n        Else days=2.\\n    */\\n    vector<vector<int>> dir{{-1,0},{0,-1},{1,0},{0,1}};\\n    vector<bool> visited;\\n    vector<int> ids;\\n    vector<int> low_links;\\n    // vector<bool> ap;\\n    int flag = 2;\\n    \\n    /*\\n        We don\\'t need ap vector (Articulation Point vector) here, but I\\'m maintaining it for template code\\n        reference. We won\\'t need flag, islands variables in general Articulation point questions.\\n    */\\n    \\n    void articulationPointsUtil(vector<int> adj[], int id, int parent, int u) {\\n        visited[u] = true;\\n        ids[u] = low_links[u] = id++;\\n        int out = 0;\\n        \\n        for(auto v: adj[u]) {\\n            if(v == parent) continue;\\n            if(!visited[v]) {\\n                out++;\\n                articulationPointsUtil(adj, id, u, v);\\n                low_links[u] = min(low_links[u], low_links[v]);\\n                \\n                if(parent == -1 && out > 1) {\\n                    // ap[u] = true;\\n                    flag = 1;\\n                }\\n                \\n                if(parent != -1 && ids[u] <= low_links[v]) {\\n                    // ap[u] = true;\\n                    flag = 1;\\n                }\\n            } else {\\n                low_links[u] = min(low_links[u], ids[v]);\\n            }\\n        }\\n    }\\n    \\n    int articulationPoints(vector<int> adj[], int n) {\\n        visited.resize(n, false);\\n        ids.resize(n);\\n        low_links.resize(n);\\n        // ap.resize(n, false);\\n        \\n        int islands = 0;\\n        for(int i=0; i<n; i++) {\\n            if(!visited[i]) {\\n                islands++;\\n                articulationPointsUtil(adj, 0, -1, i);\\n            }\\n        }\\n        \\n        return (islands == 1) ? flag : 0;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        map<pair<int,int>, int> map;\\n        int id = 0;\\n        int m=grid.size(), n=grid[0].size();\\n        vector<int> adj[m*n];\\n        \\n        if(m*n == 1 && grid[0][0] == 0) return 0;\\n        if(m*n == 1 && grid[0][0] == 1) return 1;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 1) {\\n                    int u = (map.find({i,j}) != map.end()) ? map[{i,j}] : id++;\\n                    map[{i,j}] = u;\\n                    \\n                    for(int k=0; k<4; k++) {\\n                        int nx = i + dir[k][0];\\n                        int ny = j + dir[k][1];\\n                        if(nx>=0 && nx<m && ny>=0 && ny<n && grid[nx][ny]==1) {\\n                            int v = (map.find({nx,ny}) != map.end()) ? map[{nx,ny}] : id++;\\n                            map[{nx,ny}] = v;\\n                            adj[u].push_back(v);\\n                        }\\n                    }\\n                    \\n                    if(u>0 && adj[u].size()==0) return 0;\\n                }\\n            }\\n        }\\n        \\n        if(id==1 && adj[id-1].size()==0) return 1;\\n        \\n        return articulationPoints(adj, id);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099205,
                "title": "c-following-the-hints",
                "content": "As the hints suggest, if the graph is already disconnected, then return 0.\\n\\nif we can make the graph disconnected by removing one \"1\", return 1.\\n```\\nclass Solution {\\n    vector<int> g;\\n    int find(int i) {\\n        if(g[i] == i) return i;\\n        g[i] = find(g[i]);\\n        return g[i];\\n    }\\n    \\n    void merge(int i, int j) {\\n        i = find(i);\\n        j = find(j);\\n        g[j] = i;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size(), n =grid[0].size();\\n        g.resize(m*n, 0);\\n        for(int i=0; i<m*n; ++i) g[i] = i;\\n        \\n        if(Disconnected(grid)) {\\n            return 0;\\n        }\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                grid[i][j] = 0;\\n                if(Disconnected(grid)) return 1;\\n                grid[i][j] = 1;\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    bool Disconnected(vector<vector<int>>& grid) {\\n        int m = grid.size(), n =grid[0].size();\\n        g.resize(m*n, 0);\\n        for(int i=0; i<m*n; ++i) g[i] = i;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                if(i+1 < m && grid[i+1][j] == 1) merge(i * n + j, (i+1) * n + j);\\n                if(j+1 < n && grid[i][j+1] == 1) merge(i * n + j, i * n + j + 1);\\n            }\\n        }\\n        \\n        int res = -1;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                if(res == -1) {\\n                    res = find(i*n + j);\\n                } else if(res != find(i*n + j)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        if(res == -1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> g;\\n    int find(int i) {\\n        if(g[i] == i) return i;\\n        g[i] = find(g[i]);\\n        return g[i];\\n    }\\n    \\n    void merge(int i, int j) {\\n        i = find(i);\\n        j = find(j);\\n        g[j] = i;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size(), n =grid[0].size();\\n        g.resize(m*n, 0);\\n        for(int i=0; i<m*n; ++i) g[i] = i;\\n        \\n        if(Disconnected(grid)) {\\n            return 0;\\n        }\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                grid[i][j] = 0;\\n                if(Disconnected(grid)) return 1;\\n                grid[i][j] = 1;\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    bool Disconnected(vector<vector<int>>& grid) {\\n        int m = grid.size(), n =grid[0].size();\\n        g.resize(m*n, 0);\\n        for(int i=0; i<m*n; ++i) g[i] = i;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                if(i+1 < m && grid[i+1][j] == 1) merge(i * n + j, (i+1) * n + j);\\n                if(j+1 < n && grid[i][j+1] == 1) merge(i * n + j, i * n + j + 1);\\n            }\\n        }\\n        \\n        int res = -1;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] == 0) continue;\\n                if(res == -1) {\\n                    res = find(i*n + j);\\n                } else if(res != find(i*n + j)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        if(res == -1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835144,
                "title": "count-number-of-islands-using-both-union-find-and-dfs-python",
                "content": "The algorithm for solving this problem has been articulated in top rated votes. There could only be three possible answers, either 0, 1, 2.\\n\\n(1) if the total number of islands is not 1, we return 0 immediately.\\n(2) if the total number of islands is 1, then we enumerate all cases where we set independently one of the 1s in the orignal grid to 0, and count the number of islands. If any of this operation changes the total number to be diffrent than 1 (i.e. could be 0, 2, 3 etc), we return 1.\\n(3) If not (1) and (2), we return 2 instead. \\n\\nThe code below uses both Union Find and DFS to count the number of islands. \\n```\\nclass DisjointSetUnion:\\n    def __init__(self, matrix):\\n        R, C = len(matrix), len(matrix[0])\\n        size = R * C\\n        self.parent = [0 for i in range(size)]\\n        self.size = [0 for i in range(size)]\\n        self.count = 0\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 1:\\n                    self.parent[i * C + j] = i * C + j\\n                    self.size[i*C + j] = 1\\n                    self.count += 1\\n                \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px == py:\\n            return py\\n        \\n        if self.size[px] > self.size[py]:\\n            px, py = py, px\\n            \\n        self.parent[px] = py\\n        self.size[py] += self.size[px]\\n        self.count -= 1\\n        return py\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        if not grid:\\n            return 0\\n        \\n        def count_number_of_islands(matrix):\\n            R, C = len(matrix), len(matrix[0])\\n            dsu = DisjointSetUnion(matrix)\\n            seen = set()\\n            for r in range(R):\\n                for c in range(C):\\n                    if matrix[r][c] == 1:\\n                        for x, y in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                            nr = r + x\\n                            nc = c + y\\n                            if 0<= nr < R and 0<= nc < C and matrix[nr][nc] == 1 and (r*C + c, nr * C + nc) not in seen:\\n                                seen.add((r*C + c, nr * C + nc))\\n                                seen.add((nr * C + nc, r*C + c))\\n                                dsu.union(r*C + c, nr * C + nc)\\n                                \\n            return dsu.count\\n        \\n        def count_number_of_islands_1(matrix):\\n            visited = set()\\n            R, C = len(matrix), len(matrix[0])\\n            def dfs(i,j):\\n                visited.add((i,j))\\n                \\n                for x, y in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    nx = i + x\\n                    ny = j + y\\n                    if 0 <= nx < R and 0 <= ny < C and matrix[nx][ny] == 1 and (nx, ny) not in visited:\\n                        dfs(nx, ny)\\n                        \\n            count = 0\\n            for r in range(R):\\n                for c in range(C):\\n                    if matrix[r][c] == 1 and (r,c) not in visited:\\n                        dfs(r,c)\\n                        count += 1\\n                        \\n            return count\\n                \\n        # case 1\\n        num_islands = count_number_of_islands(grid)\\n        if num_islands != 1:\\n            return 0\\n        \\n        # case 2 check if we can disconnect the island in one day\\n        R, C = len(grid), len(grid[0])\\n        for r in range(R):\\n            for c in range(C):\\n                if grid[r][c] == 1:\\n                    grid_new = copy.deepcopy(grid)\\n                    grid_new[r][c] = 0\\n                    if count_number_of_islands(grid_new) != 1:\\n                        return 1\\n        # case 3     \\n        return 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass DisjointSetUnion:\\n    def __init__(self, matrix):\\n        R, C = len(matrix), len(matrix[0])\\n        size = R * C\\n        self.parent = [0 for i in range(size)]\\n        self.size = [0 for i in range(size)]\\n        self.count = 0\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 1:\\n                    self.parent[i * C + j] = i * C + j\\n                    self.size[i*C + j] = 1\\n                    self.count += 1\\n                \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px == py:\\n            return py\\n        \\n        if self.size[px] > self.size[py]:\\n            px, py = py, px\\n            \\n        self.parent[px] = py\\n        self.size[py] += self.size[px]\\n        self.count -= 1\\n        return py\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        if not grid:\\n            return 0\\n        \\n        def count_number_of_islands(matrix):\\n            R, C = len(matrix), len(matrix[0])\\n            dsu = DisjointSetUnion(matrix)\\n            seen = set()\\n            for r in range(R):\\n                for c in range(C):\\n                    if matrix[r][c] == 1:\\n                        for x, y in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                            nr = r + x\\n                            nc = c + y\\n                            if 0<= nr < R and 0<= nc < C and matrix[nr][nc] == 1 and (r*C + c, nr * C + nc) not in seen:\\n                                seen.add((r*C + c, nr * C + nc))\\n                                seen.add((nr * C + nc, r*C + c))\\n                                dsu.union(r*C + c, nr * C + nc)\\n                                \\n            return dsu.count\\n        \\n        def count_number_of_islands_1(matrix):\\n            visited = set()\\n            R, C = len(matrix), len(matrix[0])\\n            def dfs(i,j):\\n                visited.add((i,j))\\n                \\n                for x, y in [(1,0), (-1,0), (0,1), (0,-1)]:\\n                    nx = i + x\\n                    ny = j + y\\n                    if 0 <= nx < R and 0 <= ny < C and matrix[nx][ny] == 1 and (nx, ny) not in visited:\\n                        dfs(nx, ny)\\n                        \\n            count = 0\\n            for r in range(R):\\n                for c in range(C):\\n                    if matrix[r][c] == 1 and (r,c) not in visited:\\n                        dfs(r,c)\\n                        count += 1\\n                        \\n            return count\\n                \\n        # case 1\\n        num_islands = count_number_of_islands(grid)\\n        if num_islands != 1:\\n            return 0\\n        \\n        # case 2 check if we can disconnect the island in one day\\n        R, C = len(grid), len(grid[0])\\n        for r in range(R):\\n            for c in range(C):\\n                if grid[r][c] == 1:\\n                    grid_new = copy.deepcopy(grid)\\n                    grid_new[r][c] = 0\\n                    if count_number_of_islands(grid_new) != 1:\\n                        return 1\\n        # case 3     \\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828885,
                "title": "java-simple-and-clean-solution",
                "content": "```\\nclass Solution {\\n    private static final int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int minDays(int[][] grid) {\\n        if (isDisconnected(grid)) {\\n            return 0;\\n        } else if (isStrongConnected(grid)) {\\n            return 2;\\n        } else {\\n            return 1;\\n        }\\n    }\\n    \\n    private boolean isDisconnected(int[][] grid) {\\n        int answer = 0, n = grid.length, m = grid[0].length;\\n        boolean[][] visited = new boolean[n][m];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (dfs(grid, visited, i, j)) {\\n                    answer++;\\n                }\\n            }\\n        }\\n        \\n        return answer != 1;\\n    }\\n    \\n    private boolean dfs(int[][] grid, boolean[][] visited, int y, int x) {\\n        if (y < 0 || y >= grid.length || x < 0 || x >= grid[y].length) {\\n            return false;\\n        }\\n        \\n        if (grid[y][x] == 0) {\\n            return false;\\n        }\\n        \\n        if (visited[y][x]) {\\n            return false;\\n        }\\n        visited[y][x] = true;\\n        \\n        for (int[] move : moves) {\\n            dfs(grid, visited, y + move[0], x + move[1]);\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean isStrongConnected(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) {\\n                    continue;\\n                }\\n                \\n                grid[i][j] = 0;\\n                if (isDisconnected(grid)) {\\n                    return false;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    public int minDays(int[][] grid) {\\n        if (isDisconnected(grid)) {\\n            return 0;\\n        } else if (isStrongConnected(grid)) {\\n            return 2;\\n        } else {\\n            return 1;\\n        }\\n    }\\n    \\n    private boolean isDisconnected(int[][] grid) {\\n        int answer = 0, n = grid.length, m = grid[0].length;\\n        boolean[][] visited = new boolean[n][m];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (dfs(grid, visited, i, j)) {\\n                    answer++;\\n                }\\n            }\\n        }\\n        \\n        return answer != 1;\\n    }\\n    \\n    private boolean dfs(int[][] grid, boolean[][] visited, int y, int x) {\\n        if (y < 0 || y >= grid.length || x < 0 || x >= grid[y].length) {\\n            return false;\\n        }\\n        \\n        if (grid[y][x] == 0) {\\n            return false;\\n        }\\n        \\n        if (visited[y][x]) {\\n            return false;\\n        }\\n        visited[y][x] = true;\\n        \\n        for (int[] move : moves) {\\n            dfs(grid, visited, y + move[0], x + move[1]);\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean isStrongConnected(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) {\\n                    continue;\\n                }\\n                \\n                grid[i][j] = 0;\\n                if (isDisconnected(grid)) {\\n                    return false;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820801,
                "title": "c-o-mn-2",
                "content": "```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        List<int[]> dirs = new List<int[]>() {\\n            new int[2] {1, 0},\\n            new int[2] {0, 1},\\n            new int[2] {-1, 0},\\n            new int[2] {0, -1}\\n        };\\n        \\n        if (GetNumberOfIslands(grid, dirs) > 1) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    \\n                    if (GetNumberOfIslands(grid, dirs) > 1) {\\n                        return 1;\\n                    }\\n                    \\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int GetNumberOfIslands(int[][] grid, List<int[]> dirs) {\\n        bool[,] visited = new bool[grid.Length, grid[0].Length];\\n        int islandCount = 0;\\n        \\n        for (int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                if (!visited[i, j] && grid[i][j] == 1)\\n                {\\n                    VisitIsland(grid, i, j, visited, dirs);\\n                    islandCount++;\\n                }\\n            }\\n        }\\n        \\n        return islandCount;\\n    }\\n    \\n    private void VisitIsland(int[][] grid, int i, int j, bool[,] visited, List<int[]> dirs) {\\n        visited[i, j] = true;\\n        foreach (int[] dir in dirs) {\\n            int nexti = i + dir[0];\\n            int nextj = j + dir[1];\\n\\n            if (IsInBound(grid, nexti, nextj) && !visited[nexti, nextj] && grid[nexti][nextj] == 1)\\n            {\\n                VisitIsland(grid, nexti, nextj, visited, dirs);\\n            }\\n        }\\n    }\\n    \\n    private bool IsInBound(int[][] grid, int i, int j){\\n        return i >= 0 && j >= 0 && i < grid.Length && j < grid[0].Length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        List<int[]> dirs = new List<int[]>() {\\n            new int[2] {1, 0},\\n            new int[2] {0, 1},\\n            new int[2] {-1, 0},\\n            new int[2] {0, -1}\\n        };\\n        \\n        if (GetNumberOfIslands(grid, dirs) > 1) {\\n            return 0;\\n        }\\n        \\n        for (int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    \\n                    if (GetNumberOfIslands(grid, dirs) > 1) {\\n                        return 1;\\n                    }\\n                    \\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int GetNumberOfIslands(int[][] grid, List<int[]> dirs) {\\n        bool[,] visited = new bool[grid.Length, grid[0].Length];\\n        int islandCount = 0;\\n        \\n        for (int i = 0; i < grid.Length; i++) {\\n            for (int j = 0; j < grid[0].Length; j++) {\\n                if (!visited[i, j] && grid[i][j] == 1)\\n                {\\n                    VisitIsland(grid, i, j, visited, dirs);\\n                    islandCount++;\\n                }\\n            }\\n        }\\n        \\n        return islandCount;\\n    }\\n    \\n    private void VisitIsland(int[][] grid, int i, int j, bool[,] visited, List<int[]> dirs) {\\n        visited[i, j] = true;\\n        foreach (int[] dir in dirs) {\\n            int nexti = i + dir[0];\\n            int nextj = j + dir[1];\\n\\n            if (IsInBound(grid, nexti, nextj) && !visited[nexti, nextj] && grid[nexti][nextj] == 1)\\n            {\\n                VisitIsland(grid, nexti, nextj, visited, dirs);\\n            }\\n        }\\n    }\\n    \\n    private bool IsInBound(int[][] grid, int i, int j){\\n        return i >= 0 && j >= 0 && i < grid.Length && j < grid[0].Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820609,
                "title": "python-cutting-points-tarjan-s-algorithm",
                "content": "# Intuition\\n1. Use `union-find` to track the number of connected islands. Return `0` if we started with 0 or more than 1 islands.\\n2. Use `Tarjan\\'s algorithm` to check whether we can solve the problem in `1` day (cutting/articulation point)\\n3. Return `2` if none of above test passed.\\n\\n# Complexity\\nSay it is a M * N matrix\\nTime: O(M * N)   ;   M * N for union-find part, M * N for Tarjan\\'s algorithm\\nSpace: O(M * N)\\n```python\\nclass Solution:\\n    def minDays(self, grid) -> int:\\n        def find_cutting_points(graph):\\n            ids, low = {}, {}\\n            is_cut, id_max = set(), 0\\n\\n            def dfs(u, p, root):\\n                nonlocal out_edge\\n                nonlocal id_max\\n                if p == root: \\n                    out_edge += 1\\n                ids[u] = low[u] = id_max\\n                id_max += 1\\n                \\n                for v in graph[u]:\\n                    if v == p: continue\\n                    if v not in ids:\\n                        dfs(v, u, root)\\n                        low[u] = min(low[u], low[v])\\n                        if low[v] >= ids[u]:\\n                            is_cut.add(u)\\n                    else:\\n                        low[u] = min(low[u], ids[v])\\n\\n            for u in graph.keys():\\n                if u not in ids:\\n                    out_edge = 0\\n                    dfs(u, -1, u)\\n                    if out_edge > 1:\\n                        is_cut.add(u)\\n                    else:\\n                        is_cut.remove(u)\\n            return is_cut\\n\\n        uf = {}\\n        def find(x):\\n            uf.setdefault(x, x)\\n            if uf[x] != x: uf[x] = find(uf[x])\\n            return uf[x]\\n        def union(x, y): # x-> y\\n            uf[find(x)] = find(y)\\n            \\n        m, n = len(grid), len(grid[0])\\n        graph = defaultdict(set)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 1: continue\\n                find((i,j))\\n                for rr, cc in [(-1, 0), (0, -1)]:\\n                    r, c = i+rr, j+cc\\n                    if 0 <= r < m and 0 <= c < n and grid[r][c] == 1:\\n                        union((i, j), (r, c))\\n                        graph[(i,j)].add((r,c))\\n                        graph[(r,c)].add((i,j))\\n\\n        if len(set(map(find, uf.keys()))) != 1:\\n            return 0\\n        if find_cutting_points(graph):\\n            return 1\\n        return 2\\n````",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```python\\nclass Solution:\\n    def minDays(self, grid) -> int:\\n        def find_cutting_points(graph):\\n            ids, low = {}, {}\\n            is_cut, id_max = set(), 0\\n\\n            def dfs(u, p, root):\\n                nonlocal out_edge\\n                nonlocal id_max\\n                if p == root: \\n                    out_edge += 1\\n                ids[u] = low[u] = id_max\\n                id_max += 1\\n                \\n                for v in graph[u]:\\n                    if v == p: continue\\n                    if v not in ids:\\n                        dfs(v, u, root)\\n                        low[u] = min(low[u], low[v])\\n                        if low[v] >= ids[u]:\\n                            is_cut.add(u)\\n                    else:\\n                        low[u] = min(low[u], ids[v])\\n\\n            for u in graph.keys():\\n                if u not in ids:\\n                    out_edge = 0\\n                    dfs(u, -1, u)\\n                    if out_edge > 1:\\n                        is_cut.add(u)\\n                    else:\\n                        is_cut.remove(u)\\n            return is_cut\\n\\n        uf = {}\\n        def find(x):\\n            uf.setdefault(x, x)\\n            if uf[x] != x: uf[x] = find(uf[x])\\n            return uf[x]\\n        def union(x, y): # x-> y\\n            uf[find(x)] = find(y)\\n            \\n        m, n = len(grid), len(grid[0])\\n        graph = defaultdict(set)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] != 1: continue\\n                find((i,j))\\n                for rr, cc in [(-1, 0), (0, -1)]:\\n                    r, c = i+rr, j+cc\\n                    if 0 <= r < m and 0 <= c < n and grid[r][c] == 1:\\n                        union((i, j), (r, c))\\n                        graph[(i,j)].add((r,c))\\n                        graph[(r,c)].add((i,j))\\n\\n        if len(set(map(find, uf.keys()))) != 1:\\n            return 0\\n        if find_cutting_points(graph):\\n            return 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820446,
                "title": "java-dfs-backtracking-tle-to-smart-answer",
                "content": "When you aren\\'t smart enough to realize the fact answer is at most 2 days. You come up with exponential time complexity solution :(\\n```\\nint res = Integer.MAX_VALUE;\\npublic int minDays(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tList<int[]> cells = new ArrayList<>();\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tcells.add(new int[]{i, j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (cells.size() == 0 || isDisconnected(grid)) {\\n\\t\\treturn 0;\\n\\t}\\n\\tdfs(grid, cells, 0, 0);\\n\\treturn res;\\n}\\nprivate void dfs(int[][] grid, List<int[]> cells, int idx, int cnt) {\\n\\tif (res <= cnt) {\\n\\t\\treturn;\\n\\t}\\n\\tif (isDisconnected(grid)) {\\n\\t\\tres = Math.min(res, cnt);   \\n\\t\\treturn;\\n\\t}\\n\\tif (idx == cells.size()) {\\n\\t\\treturn; \\n\\t}\\n\\n\\tdfs(grid, cells, idx + 1, cnt);\\n\\tint[] cord = cells.get(idx);\\n\\tgrid[cord[0]][cord[1]] = 0; \\n\\tdfs(grid, cells, idx + 1, cnt + 1);\\n\\tgrid[cord[0]][cord[1]] = 1;\\n\\n}\\nprivate boolean isDisconnected(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tboolean[][] visited = new boolean[m][n];\\n\\tint cnt = 0;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\t\\t\\tif (cnt == 1) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttraverse(grid, visited, i, j);\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt == 0;\\n}\\nprivate void traverse(int[][] grid, boolean[][] visited, int i, int j) {\\n\\tif (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] == 0) {\\n\\t\\treturn;\\n\\t}\\n\\tvisited[i][j] = true;\\n\\ttraverse(grid, visited, i + 1, j);\\n\\ttraverse(grid, visited, i - 1, j);\\n\\ttraverse(grid, visited, i, j + 1);\\n\\ttraverse(grid, visited, i, j - 1);\\n}\\n```\\n\\nAnd then when you check out the answer from smart people, you changed your answer to pretend you are smart as well.\\n```\\npublic int minDays(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\t// check if it\\'s initially disconnected\\n\\tif (isDisconnected(grid)) {\\n\\t\\treturn 0;\\n\\t}\\n\\t// check for 1 day\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\t\\tif (isDisconnected(grid)) {\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// if not 1 day, then it\\'s 2 days \\n\\treturn 2;\\n}\\nprivate boolean isDisconnected(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tboolean[][] visited = new boolean[m][n];\\n\\tint cnt = 0;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\t\\t\\tif (cnt == 1) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttraverse(grid, visited, i, j);\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt == 0;\\n}\\nprivate void traverse(int[][] grid, boolean[][] visited, int i, int j) {\\n\\tif (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] == 0) {\\n\\t\\treturn;\\n\\t}\\n\\tvisited[i][j] = true;\\n\\ttraverse(grid, visited, i + 1, j);\\n\\ttraverse(grid, visited, i - 1, j);\\n\\ttraverse(grid, visited, i, j + 1);\\n\\ttraverse(grid, visited, i, j - 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint res = Integer.MAX_VALUE;\\npublic int minDays(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tList<int[]> cells = new ArrayList<>();\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tcells.add(new int[]{i, j});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tif (cells.size() == 0 || isDisconnected(grid)) {\\n\\t\\treturn 0;\\n\\t}\\n\\tdfs(grid, cells, 0, 0);\\n\\treturn res;\\n}\\nprivate void dfs(int[][] grid, List<int[]> cells, int idx, int cnt) {\\n\\tif (res <= cnt) {\\n\\t\\treturn;\\n\\t}\\n\\tif (isDisconnected(grid)) {\\n\\t\\tres = Math.min(res, cnt);   \\n\\t\\treturn;\\n\\t}\\n\\tif (idx == cells.size()) {\\n\\t\\treturn; \\n\\t}\\n\\n\\tdfs(grid, cells, idx + 1, cnt);\\n\\tint[] cord = cells.get(idx);\\n\\tgrid[cord[0]][cord[1]] = 0; \\n\\tdfs(grid, cells, idx + 1, cnt + 1);\\n\\tgrid[cord[0]][cord[1]] = 1;\\n\\n}\\nprivate boolean isDisconnected(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tboolean[][] visited = new boolean[m][n];\\n\\tint cnt = 0;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\t\\t\\tif (cnt == 1) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttraverse(grid, visited, i, j);\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt == 0;\\n}\\nprivate void traverse(int[][] grid, boolean[][] visited, int i, int j) {\\n\\tif (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] == 0) {\\n\\t\\treturn;\\n\\t}\\n\\tvisited[i][j] = true;\\n\\ttraverse(grid, visited, i + 1, j);\\n\\ttraverse(grid, visited, i - 1, j);\\n\\ttraverse(grid, visited, i, j + 1);\\n\\ttraverse(grid, visited, i, j - 1);\\n}\\n```\n```\\npublic int minDays(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\t// check if it\\'s initially disconnected\\n\\tif (isDisconnected(grid)) {\\n\\t\\treturn 0;\\n\\t}\\n\\t// check for 1 day\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\t\\tif (isDisconnected(grid)) {\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t// if not 1 day, then it\\'s 2 days \\n\\treturn 2;\\n}\\nprivate boolean isDisconnected(int[][] grid) {\\n\\tint m = grid.length;\\n\\tint n = grid[0].length;\\n\\tboolean[][] visited = new boolean[m][n];\\n\\tint cnt = 0;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\t\\t\\tif (cnt == 1) {\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttraverse(grid, visited, i, j);\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt == 0;\\n}\\nprivate void traverse(int[][] grid, boolean[][] visited, int i, int j) {\\n\\tif (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || visited[i][j] || grid[i][j] == 0) {\\n\\t\\treturn;\\n\\t}\\n\\tvisited[i][j] = true;\\n\\ttraverse(grid, visited, i + 1, j);\\n\\ttraverse(grid, visited, i - 1, j);\\n\\ttraverse(grid, visited, i, j + 1);\\n\\ttraverse(grid, visited, i, j - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820411,
                "title": "union-find-at-most-2-days",
                "content": "```\\nusing vi = vector<int>;\\nusing vvi = vector<vi>;\\nusing vvvi = vector<vvi>;\\nclass Solution {\\n    vvvi ds = vvvi(30, vvi(30, vi(2, 0)));\\n    int n, m;\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n\\n        int islands = getIslands(grid);\\n        if (islands == 0 || islands > 1) return 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    grid[i][j] = 0;\\n                    if (getIslands(grid) > 1) {\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        return 2;\\n    }\\n\\nprivate:\\n    int getIslands(vvi& grid) {\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                ds[i][j][0] = i * m + j, ds[i][j][1] = 0;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    if (j < m - 1 && grid[i][j + 1]) {\\n                        unionSet(findSet(i, j), findSet(i, j + 1));\\n                    }\\n                    if (i < n - 1 && grid[i + 1][j]) {\\n                        unionSet(findSet(i, j), findSet(i + 1, j));\\n                    }\\n                }\\n            }\\n        }\\n\\n        unordered_set<int> set;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    set.emplace(findSet(i, j));\\n                }\\n            }\\n        }\\n\\n        return set.size();\\n    }\\n\\n    void unionSet(int p1, int p2) {\\n        int i1 = p1 / m, j1 = p1 % m, i2 = p2 / m, j2 = p2 % m;\\n        if (ds[i1][j1][1] < ds[i2][j2][1]) {\\n            ds[i1][j1][0] = p2;\\n        } else {\\n            ds[i2][j2][0] = p1;\\n            if (ds[i1][j1][1] == ds[i2][j2][1]) {\\n                ++ds[i1][j1][1];\\n            }\\n        }\\n    }\\n\\n    int findSet(int i, int j) {\\n        int p = ds[i][j][0];\\n        if (p == i * m + j) {\\n            return p;\\n        } else {\\n            return ds[i][j][0] = findSet(p / m, p % m);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing vi = vector<int>;\\nusing vvi = vector<vi>;\\nusing vvvi = vector<vvi>;\\nclass Solution {\\n    vvvi ds = vvvi(30, vvi(30, vi(2, 0)));\\n    int n, m;\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n\\n        int islands = getIslands(grid);\\n        if (islands == 0 || islands > 1) return 0;\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    grid[i][j] = 0;\\n                    if (getIslands(grid) > 1) {\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        return 2;\\n    }\\n\\nprivate:\\n    int getIslands(vvi& grid) {\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                ds[i][j][0] = i * m + j, ds[i][j][1] = 0;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    if (j < m - 1 && grid[i][j + 1]) {\\n                        unionSet(findSet(i, j), findSet(i, j + 1));\\n                    }\\n                    if (i < n - 1 && grid[i + 1][j]) {\\n                        unionSet(findSet(i, j), findSet(i + 1, j));\\n                    }\\n                }\\n            }\\n        }\\n\\n        unordered_set<int> set;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j]) {\\n                    set.emplace(findSet(i, j));\\n                }\\n            }\\n        }\\n\\n        return set.size();\\n    }\\n\\n    void unionSet(int p1, int p2) {\\n        int i1 = p1 / m, j1 = p1 % m, i2 = p2 / m, j2 = p2 % m;\\n        if (ds[i1][j1][1] < ds[i2][j2][1]) {\\n            ds[i1][j1][0] = p2;\\n        } else {\\n            ds[i2][j2][0] = p1;\\n            if (ds[i1][j1][1] == ds[i2][j2][1]) {\\n                ++ds[i1][j1][1];\\n            }\\n        }\\n    }\\n\\n    int findSet(int i, int j) {\\n        int p = ds[i][j][0];\\n        if (p == i * m + j) {\\n            return p;\\n        } else {\\n            return ds[i][j][0] = findSet(p / m, p % m);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819610,
                "title": "java-at-most-2-days",
                "content": "```\\nclass Solution {\\n    \\n    private int m;\\n    private int n;\\n    private int[][] grid;\\n    \\n    private void dfs(int i, int j, boolean[] visited) {\\n        if (i < 0 || j < 0 || i == m || j == n || grid[i][j] == 0 || visited[i * n + j]) {\\n            return;\\n        }\\n        visited[i * n + j] = true;\\n        dfs(i + 1, j, visited);\\n        dfs(i - 1, j, visited);\\n        dfs(i, j + 1, visited);\\n        dfs(i, j - 1, visited);\\n    }\\n    \\n    private boolean disconnected() {\\n        boolean disconnected = false;\\n        boolean allZeros = true;\\n        boolean[] visited = new boolean[n * m];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && !visited[i * n + j]) {\\n                    allZeros = false;\\n                    if (disconnected) {\\n                        return true;\\n                    }\\n                    dfs(i, j, visited);\\n                    disconnected = true;\\n                }\\n            }\\n        }\\n        return allZeros;\\n    }\\n    \\n    public int minDays(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        this.grid = grid;\\n        \\n        Deque<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    queue.offer(i * n + j);\\n                }\\n            }\\n        }\\n        \\n        if (disconnected()) return 0;\\n        for (int k = queue.size(); k > 0; k--) {\\n            int index = queue.poll();\\n            int i = index / n;\\n            int j = index % n;\\n            grid[i][j] = 0;\\n            if (disconnected()) return 1;\\n            grid[i][j] = 1;\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int m;\\n    private int n;\\n    private int[][] grid;\\n    \\n    private void dfs(int i, int j, boolean[] visited) {\\n        if (i < 0 || j < 0 || i == m || j == n || grid[i][j] == 0 || visited[i * n + j]) {\\n            return;\\n        }\\n        visited[i * n + j] = true;\\n        dfs(i + 1, j, visited);\\n        dfs(i - 1, j, visited);\\n        dfs(i, j + 1, visited);\\n        dfs(i, j - 1, visited);\\n    }\\n    \\n    private boolean disconnected() {\\n        boolean disconnected = false;\\n        boolean allZeros = true;\\n        boolean[] visited = new boolean[n * m];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && !visited[i * n + j]) {\\n                    allZeros = false;\\n                    if (disconnected) {\\n                        return true;\\n                    }\\n                    dfs(i, j, visited);\\n                    disconnected = true;\\n                }\\n            }\\n        }\\n        return allZeros;\\n    }\\n    \\n    public int minDays(int[][] grid) {\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        this.grid = grid;\\n        \\n        Deque<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    queue.offer(i * n + j);\\n                }\\n            }\\n        }\\n        \\n        if (disconnected()) return 0;\\n        for (int k = queue.size(); k > 0; k--) {\\n            int index = queue.poll();\\n            int i = index / n;\\n            int j = index % n;\\n            grid[i][j] = 0;\\n            if (disconnected()) return 1;\\n            grid[i][j] = 1;\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819564,
                "title": "c-using-dfs-video-explanation",
                "content": "Video: https://youtu.be/DHPg2h589MY\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size(), islands = 0, ones = 0;\\n        memset(visited, 0, sizeof(visited));\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++) {    // finding out #islands\\n            if(!visited[i][j] && grid[i][j] == 1)\\n                dfs(i, j, grid), islands++;\\n            if(grid[i][j] == 1) ones++;\\n        }\\n        \\n        if(islands != 1) return 0;     // islands = #Connected Components\\n        \\n        if(m == 1 || n == 1 || ones <= 2) return (ones == 2 ? 2: 1);   // #islands = 1\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++) if(grid[i][j] == 1) {\\n            int x = i, y = j; grid[i][j] = 0;\\n            \\n            memset(visited, 0, sizeof(visited));\\n            islands = 0;\\n            \\n             for(int i=0; i<m; i++) for(int j=0; j<n; j++) {     // finding out #islands\\n                if(!visited[i][j] && grid[i][j] == 1)\\n                    dfs(i, j, grid), islands++;\\n            }           \\n            \\n            if(islands > 1) return 1;    // we were able to disconnect the islands\\n            \\n            grid[x][y] = 1;\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    void dfs(int i, int j, vector<vector<int>> &g) {    // visits all the 1s of 1 island, marks them visited\\n        visited[i][j] = 1; \\n        \\n        if(i && !visited[i-1][j] && g[i-1][j] == 1) dfs(i-1, j, g);\\n        if(j && !visited[i][j-1] && g[i][j-1] == 1) dfs(i, j-1, g);\\n        if(i < m - 1 && !visited[i+1][j] && g[i+1][j] == 1) dfs(i+1, j, g);\\n        if(j < n - 1 && !visited[i][j+1] && g[i][j+1] == 1) dfs(i, j+1, g);\\n    }\\n    \\nprivate:\\n    int m, n, islands, ones, visited[35][35];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size(), islands = 0, ones = 0;\\n        memset(visited, 0, sizeof(visited));\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++) {    // finding out #islands\\n            if(!visited[i][j] && grid[i][j] == 1)\\n                dfs(i, j, grid), islands++;\\n            if(grid[i][j] == 1) ones++;\\n        }\\n        \\n        if(islands != 1) return 0;     // islands = #Connected Components\\n        \\n        if(m == 1 || n == 1 || ones <= 2) return (ones == 2 ? 2: 1);   // #islands = 1\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++) if(grid[i][j] == 1) {\\n            int x = i, y = j; grid[i][j] = 0;\\n            \\n            memset(visited, 0, sizeof(visited));\\n            islands = 0;\\n            \\n             for(int i=0; i<m; i++) for(int j=0; j<n; j++) {     // finding out #islands\\n                if(!visited[i][j] && grid[i][j] == 1)\\n                    dfs(i, j, grid), islands++;\\n            }           \\n            \\n            if(islands > 1) return 1;    // we were able to disconnect the islands\\n            \\n            grid[x][y] = 1;\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    void dfs(int i, int j, vector<vector<int>> &g) {    // visits all the 1s of 1 island, marks them visited\\n        visited[i][j] = 1; \\n        \\n        if(i && !visited[i-1][j] && g[i-1][j] == 1) dfs(i-1, j, g);\\n        if(j && !visited[i][j-1] && g[i][j-1] == 1) dfs(i, j-1, g);\\n        if(i < m - 1 && !visited[i+1][j] && g[i+1][j] == 1) dfs(i+1, j, g);\\n        if(j < n - 1 && !visited[i][j+1] && g[i][j+1] == 1) dfs(i, j+1, g);\\n    }\\n    \\nprivate:\\n    int m, n, islands, ones, visited[35][35];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819559,
                "title": "golang-solution-similar-to-other-solutions",
                "content": "Only two important things to solve this\\n1. Hint/Selfobservation that the answer can be only 0 , 1 or 2\\n2. Convince yourself that using time complexity of O(n^4) and space complexity of O(n^2) is fine here\\n\\nI got the hint for point 1 from discuss\\n\\n```\\nfunc minDays(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n\\tvisited := make([][]bool, m)\\n\\tfor t := 0; t < m; t++ {\\n\\t\\tvisited[t] = make([]bool, n)\\n\\t}\\n\\n\\tc := 0\\n\\t// check for answer 0\\n\\t// If already > 1 island then we dont need any days to disconnect them\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 && !visited[i][j] {\\n\\t\\t\\t\\tc++\\n\\t\\t\\t\\tdfs(grid, i, j, m, n, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif c > 1 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// check for 1\\n\\t// for all grid values of 1, make it 0 and check no of islands\\n\\t// if anytime you find > 1 island, we need 1 day to disconnect them\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 {\\n\\t\\t\\t\\tgrid[i][j] = 0\\n\\t\\t\\t\\tif findNoOfIslands(grid, i, j, m, n) > 1 {\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// answer still not found , ans is 2 because\\n\\t// at max we need to turn only 2 cells (from 1 to 0) to disconnect islands\\n    return 2\\n\\n}\\n\\nfunc findNoOfIslands(grid [][]int, i, j, m, n int) int {\\n\\tvisited := make([][]bool, m)\\n\\tfor t := 0; t < m; t++ {\\n\\t\\tvisited[t] = make([]bool, n)\\n\\t}\\n\\tc := 0\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 && !visited[i][j] {\\n\\t\\t\\t\\tc++\\n\\t\\t\\t\\tdfs(grid, i, j, m, n, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn c\\n}\\n\\nfunc dfs(grid [][]int, i, j, m, n int, visited [][]bool) {\\n\\n\\tif i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0 || visited[i][j] {\\n\\t\\treturn\\n\\t}\\n\\n\\tvisited[i][j] = true\\n\\n\\tdfs(grid, i-1, j, m, n, visited)\\n\\tdfs(grid, i, j+1, m, n, visited)\\n\\tdfs(grid, i+1, j, m, n, visited)\\n\\tdfs(grid, i, j-1, m, n, visited)\\n\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minDays(grid [][]int) int {\\n    m, n := len(grid), len(grid[0])\\n\\tvisited := make([][]bool, m)\\n\\tfor t := 0; t < m; t++ {\\n\\t\\tvisited[t] = make([]bool, n)\\n\\t}\\n\\n\\tc := 0\\n\\t// check for answer 0\\n\\t// If already > 1 island then we dont need any days to disconnect them\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 && !visited[i][j] {\\n\\t\\t\\t\\tc++\\n\\t\\t\\t\\tdfs(grid, i, j, m, n, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif c > 1 {\\n\\t\\treturn 0\\n\\t}\\n\\n\\t// check for 1\\n\\t// for all grid values of 1, make it 0 and check no of islands\\n\\t// if anytime you find > 1 island, we need 1 day to disconnect them\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 {\\n\\t\\t\\t\\tgrid[i][j] = 0\\n\\t\\t\\t\\tif findNoOfIslands(grid, i, j, m, n) > 1 {\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// answer still not found , ans is 2 because\\n\\t// at max we need to turn only 2 cells (from 1 to 0) to disconnect islands\\n    return 2\\n\\n}\\n\\nfunc findNoOfIslands(grid [][]int, i, j, m, n int) int {\\n\\tvisited := make([][]bool, m)\\n\\tfor t := 0; t < m; t++ {\\n\\t\\tvisited[t] = make([]bool, n)\\n\\t}\\n\\tc := 0\\n\\tfor i := 0; i < m; i++ {\\n\\t\\tfor j := 0; j < n; j++ {\\n\\t\\t\\tif grid[i][j] == 1 && !visited[i][j] {\\n\\t\\t\\t\\tc++\\n\\t\\t\\t\\tdfs(grid, i, j, m, n, visited)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn c\\n}\\n\\nfunc dfs(grid [][]int, i, j, m, n int, visited [][]bool) {\\n\\n\\tif i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0 || visited[i][j] {\\n\\t\\treturn\\n\\t}\\n\\n\\tvisited[i][j] = true\\n\\n\\tdfs(grid, i-1, j, m, n, visited)\\n\\tdfs(grid, i, j+1, m, n, visited)\\n\\tdfs(grid, i+1, j, m, n, visited)\\n\\tdfs(grid, i, j-1, m, n, visited)\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 819518,
                "title": "dfs-c-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> rows{-1,0,1,0};\\n    vector<int> cols{0,1,0,-1};\\n    int isSafe(vector<vector<int>>& grid, int i, int j,vector<vector<bool>>& visited){\\n        int row = grid.size();\\n        int col = row ? grid[0].size():0;\\n        return (i<row &&  i>=0 && j >=0 && j<col && (grid[i][j] == 1 && !visited[i][j]));\\n    }\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i,int j){\\n\\n        \\n        visited[i][j] = true;\\n        \\n        for(int k =0;k<4;++k){\\n            if(isSafe(grid,i+rows[k],j+cols[k],visited)){\\n                dfs(grid,visited,i+rows[k],j+cols[k]);\\n            }\\n        }\\n\\n        \\n    }\\n    \\n    int noOfIslands(vector<vector<int>>& grid){\\n        int m = grid.size();\\n        int n = m ? grid[0].size() :0;\\n        \\n        assert(n>=0);\\n        int count =0;\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        \\n        for(int i =0;i<m;++i){\\n            for(int j =0;j<n ;++j){\\n                if(visited[i][j] == false && grid[i][j] == 1){\\n                        dfs(grid,visited,i,j);\\n                        count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = m ? grid[0].size() :m;\\n        int islands = noOfIslands(grid);\\n        if(islands >1 or islands == 0){\\n            return 0;\\n        } else{\\n            for(int i =0;i<m;++i){\\n                for(int j =0;j<n ;++j){\\n                    if(grid[i][j]){\\n                        grid[i][j] =0;\\n                        int islands= noOfIslands(grid);\\n                        grid[i][j] =1;\\n                        if( islands> 1 or islands == 0){\\n                            return 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 2;      \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> rows{-1,0,1,0};\\n    vector<int> cols{0,1,0,-1};\\n    int isSafe(vector<vector<int>>& grid, int i, int j,vector<vector<bool>>& visited){\\n        int row = grid.size();\\n        int col = row ? grid[0].size():0;\\n        return (i<row &&  i>=0 && j >=0 && j<col && (grid[i][j] == 1 && !visited[i][j]));\\n    }\\n    \\n    \\n    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i,int j){\\n\\n        \\n        visited[i][j] = true;\\n        \\n        for(int k =0;k<4;++k){\\n            if(isSafe(grid,i+rows[k],j+cols[k],visited)){\\n                dfs(grid,visited,i+rows[k],j+cols[k]);\\n            }\\n        }\\n\\n        \\n    }\\n    \\n    int noOfIslands(vector<vector<int>>& grid){\\n        int m = grid.size();\\n        int n = m ? grid[0].size() :0;\\n        \\n        assert(n>=0);\\n        int count =0;\\n        vector<vector<bool>> visited(m,vector<bool>(n,false));\\n        \\n        for(int i =0;i<m;++i){\\n            for(int j =0;j<n ;++j){\\n                if(visited[i][j] == false && grid[i][j] == 1){\\n                        dfs(grid,visited,i,j);\\n                        count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = m ? grid[0].size() :m;\\n        int islands = noOfIslands(grid);\\n        if(islands >1 or islands == 0){\\n            return 0;\\n        } else{\\n            for(int i =0;i<m;++i){\\n                for(int j =0;j<n ;++j){\\n                    if(grid[i][j]){\\n                        grid[i][j] =0;\\n                        int islands= noOfIslands(grid);\\n                        grid[i][j] =1;\\n                        if( islands> 1 or islands == 0){\\n                            return 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 2;      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819484,
                "title": "python3-solution-easy-to-understand-beats-100-00",
                "content": "```\\n# Key point: The return value can only be 0, 1 or 2\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        N_ones = sum([sum(i) for i in grid])\\n        if(N_ones == 0):\\n            return 0\\n        nRows = len(grid)\\n        nCols = len(grid[0])\\n        \\n        # This function calculates the area of the first island that we encounter\\n        def count_island_area():\\n            for i in range(nRows):\\n                for j in range(nCols):\\n                    if(grid[i][j] == 1):\\n                        g = [a[:] for a in grid]\\n                        area = 1\\n                        q = deque()\\n                        q.append((i,j))\\n                        g[i][j] = 0\\n                        while(q):\\n                            r,c = q.popleft()\\n                            if(r-1 >= 0 and g[r-1][c] == 1):\\n                                area += 1\\n                                g[r-1][c] = 0\\n                                q.append((r-1,c))\\n                            if(r+1 < nRows and g[r+1][c] == 1):\\n                                area += 1\\n                                g[r+1][c] = 0\\n                                q.append((r+1,c))\\n                            if(c-1 >= 0 and g[r][c-1] == 1):\\n                                area += 1\\n                                g[r][c-1] = 0\\n                                q.append((r,c-1))\\n                            if(c+1 < nCols and g[r][c+1] == 1):\\n                                area += 1\\n                                g[r][c+1] = 0\\n                                q.append((r,c+1))\\n                        return area\\n        # If the area of the first island we encounter is smaller than the total area of the island, that means there are more than one island. So we return 0\\n        if(count_island_area() < N_ones):\\n            return 0\\n        # At this point, there is only one island. We try to replace a \\'1\\' in the island with \\'0\\' one by one, and see if we can end up getting two islands.\\n        else:\\n            for i in range(nRows):\\n                for j in range(nCols):\\n                    if(grid[i][j] == 1):\\n                        grid[i][j] = 0\\n                        # If there are two islands after replacing a \\'1\\' with \\'0\\', return 1\\n                        if(count_island_area() < N_ones - 1):\\n                            return 1 \\n                        grid[i][j] = 1\\n        return 2\\n```",
                "solutionTags": [],
                "code": "```\\n# Key point: The return value can only be 0, 1 or 2\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        N_ones = sum([sum(i) for i in grid])\\n        if(N_ones == 0):\\n            return 0\\n        nRows = len(grid)\\n        nCols = len(grid[0])\\n        \\n        # This function calculates the area of the first island that we encounter\\n        def count_island_area():\\n            for i in range(nRows):\\n                for j in range(nCols):\\n                    if(grid[i][j] == 1):\\n                        g = [a[:] for a in grid]\\n                        area = 1\\n                        q = deque()\\n                        q.append((i,j))\\n                        g[i][j] = 0\\n                        while(q):\\n                            r,c = q.popleft()\\n                            if(r-1 >= 0 and g[r-1][c] == 1):\\n                                area += 1\\n                                g[r-1][c] = 0\\n                                q.append((r-1,c))\\n                            if(r+1 < nRows and g[r+1][c] == 1):\\n                                area += 1\\n                                g[r+1][c] = 0\\n                                q.append((r+1,c))\\n                            if(c-1 >= 0 and g[r][c-1] == 1):\\n                                area += 1\\n                                g[r][c-1] = 0\\n                                q.append((r,c-1))\\n                            if(c+1 < nCols and g[r][c+1] == 1):\\n                                area += 1\\n                                g[r][c+1] = 0\\n                                q.append((r,c+1))\\n                        return area\\n        # If the area of the first island we encounter is smaller than the total area of the island, that means there are more than one island. So we return 0\\n        if(count_island_area() < N_ones):\\n            return 0\\n        # At this point, there is only one island. We try to replace a \\'1\\' in the island with \\'0\\' one by one, and see if we can end up getting two islands.\\n        else:\\n            for i in range(nRows):\\n                for j in range(nCols):\\n                    if(grid[i][j] == 1):\\n                        grid[i][j] = 0\\n                        # If there are two islands after replacing a \\'1\\' with \\'0\\', return 1\\n                        if(count_island_area() < N_ones - 1):\\n                            return 1 \\n                        grid[i][j] = 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051729,
                "title": "c-disjoint-set-articulation-point-beats-89-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. If number of components != 1 --> return 0\\n2. Else if #components = 1, and articulation point exists --> return 1\\n3. Else return 2\\n4. Imp observation: Max possible answer is 2 in any case. As even if complete mesh, remove two adjacent nodes of corner cell to make it disconnected.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timer = 0;\\n    bool ap = 0;\\n    void makeset(vector<int> &parent, vector<int> &siz)\\n    {\\n        for(int i = 0 ; i < siz.size() ; i++)\\n        {\\n            parent[i] = i;\\n            siz[i] = 1;\\n        }\\n    }\\n    int findparent(int node, vector<int> &parent)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        return parent[node] = findparent(parent[node], parent);\\n    }\\n    void Union(int u, int v, vector<int> &parent, vector<int> &siz)\\n    {\\n        int pu = findparent(u, parent);\\n        int pv = findparent(v, parent);\\n        if(pu == pv)\\n            return;\\n        if(siz[pv] > siz[pu])\\n        {\\n            parent[pu] = pv;\\n            siz[pv] += siz[pu];\\n        }\\n        else\\n        {\\n            parent[pv] = pu;\\n            siz[pu] += siz[pv];\\n        }\\n    }\\n    void dfs(int node, int parent, unordered_map<int, set<int>> &adj, vector<int> &disc, vector<int> &low, vector<int> &vis)\\n    {\\n        vis[node] = 1;\\n        disc[node] = timer;\\n        low[node] = timer;\\n        timer++;\\n        int child = 0;\\n        for(auto it: adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it, node, adj, disc, low, vis);\\n                low[node] = min(low[node], low[it]);\\n                if(disc[node] <= low[it] && parent != -1)\\n                {\\n                    ap = 1;\\n                }\\n                child++;\\n            }\\n            else\\n                low[node] = min(low[node], disc[it]);\\n        }\\n        if(child > 1 && parent == -1)\\n            ap = 1;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> parent(m*n);\\n        vector<int> siz(m*n);\\n        makeset(parent, siz);\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n\\n                if(grid[i][j] == 1)\\n                {\\n                    int cell = i*n + j;\\n                    int l = cell, r = cell, u = cell, d = cell;\\n                    if(i-1 >= 0 && grid[i-1][j] == 1)\\n                        u = (i-1)*n + j;\\n                    if(j-1 >= 0 && grid[i][j-1] == 1)\\n                        l = (i)*n + j-1;\\n                    if(i+1 < m && grid[i+1][j] == 1)\\n                        d = (i+1)*n + j;\\n                    if(j+1 < n && grid[i][j+1] == 1)\\n                        r = (i)*n + j+1;\\n                    Union(cell, l, parent, siz);\\n                    Union(cell, r, parent, siz);\\n                    Union(cell, d, parent, siz);\\n                    Union(cell, u, parent, siz);\\n                }\\n            }\\n        }\\n        int comp = 0;\\n        int store = 0;\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid[i][j] == 1 && findparent(i*n+j, parent) == i*n+j)\\n                {\\n                    store = i*n+j;\\n                    comp++;\\n                }\\n            }\\n        }\\n        if(comp != 1)\\n            return 0;\\n        else if(comp == 1 && siz[store] == 1)\\n            return 1;\\n        \\n        // check if articulation point exists\\n        vector<int> disc(n*m);\\n        vector<int> low(n*m);\\n        vector<int> vis(n*m, 0);\\n        unordered_map<int, set<int>> adj;\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    int cell = i*n+j;\\n                    if(i-1 >= 0 && grid[i-1][j] == 1)\\n                        adj[cell].insert((i-1)*n+j);\\n                    if(j-1 >= 0 && grid[i][j-1] == 1)\\n                        adj[cell].insert((i)*n+j-1);\\n                    if(i+1 < m && grid[i+1][j] == 1)\\n                        adj[cell].insert((i+1)*n+j);\\n                    if(j+1 < n && grid[i][j+1] == 1)\\n                        adj[cell].insert((i)*n+j+1);\\n                }\\n            }\\n        }\\n        dfs(store, -1, adj, disc, low, vis);\\n        if(ap)\\n            return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timer = 0;\\n    bool ap = 0;\\n    void makeset(vector<int> &parent, vector<int> &siz)\\n    {\\n        for(int i = 0 ; i < siz.size() ; i++)\\n        {\\n            parent[i] = i;\\n            siz[i] = 1;\\n        }\\n    }\\n    int findparent(int node, vector<int> &parent)\\n    {\\n        if(parent[node] == node)\\n            return node;\\n        return parent[node] = findparent(parent[node], parent);\\n    }\\n    void Union(int u, int v, vector<int> &parent, vector<int> &siz)\\n    {\\n        int pu = findparent(u, parent);\\n        int pv = findparent(v, parent);\\n        if(pu == pv)\\n            return;\\n        if(siz[pv] > siz[pu])\\n        {\\n            parent[pu] = pv;\\n            siz[pv] += siz[pu];\\n        }\\n        else\\n        {\\n            parent[pv] = pu;\\n            siz[pu] += siz[pv];\\n        }\\n    }\\n    void dfs(int node, int parent, unordered_map<int, set<int>> &adj, vector<int> &disc, vector<int> &low, vector<int> &vis)\\n    {\\n        vis[node] = 1;\\n        disc[node] = timer;\\n        low[node] = timer;\\n        timer++;\\n        int child = 0;\\n        for(auto it: adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                dfs(it, node, adj, disc, low, vis);\\n                low[node] = min(low[node], low[it]);\\n                if(disc[node] <= low[it] && parent != -1)\\n                {\\n                    ap = 1;\\n                }\\n                child++;\\n            }\\n            else\\n                low[node] = min(low[node], disc[it]);\\n        }\\n        if(child > 1 && parent == -1)\\n            ap = 1;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> parent(m*n);\\n        vector<int> siz(m*n);\\n        makeset(parent, siz);\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n\\n                if(grid[i][j] == 1)\\n                {\\n                    int cell = i*n + j;\\n                    int l = cell, r = cell, u = cell, d = cell;\\n                    if(i-1 >= 0 && grid[i-1][j] == 1)\\n                        u = (i-1)*n + j;\\n                    if(j-1 >= 0 && grid[i][j-1] == 1)\\n                        l = (i)*n + j-1;\\n                    if(i+1 < m && grid[i+1][j] == 1)\\n                        d = (i+1)*n + j;\\n                    if(j+1 < n && grid[i][j+1] == 1)\\n                        r = (i)*n + j+1;\\n                    Union(cell, l, parent, siz);\\n                    Union(cell, r, parent, siz);\\n                    Union(cell, d, parent, siz);\\n                    Union(cell, u, parent, siz);\\n                }\\n            }\\n        }\\n        int comp = 0;\\n        int store = 0;\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid[i][j] == 1 && findparent(i*n+j, parent) == i*n+j)\\n                {\\n                    store = i*n+j;\\n                    comp++;\\n                }\\n            }\\n        }\\n        if(comp != 1)\\n            return 0;\\n        else if(comp == 1 && siz[store] == 1)\\n            return 1;\\n        \\n        // check if articulation point exists\\n        vector<int> disc(n*m);\\n        vector<int> low(n*m);\\n        vector<int> vis(n*m, 0);\\n        unordered_map<int, set<int>> adj;\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    int cell = i*n+j;\\n                    if(i-1 >= 0 && grid[i-1][j] == 1)\\n                        adj[cell].insert((i-1)*n+j);\\n                    if(j-1 >= 0 && grid[i][j-1] == 1)\\n                        adj[cell].insert((i)*n+j-1);\\n                    if(i+1 < m && grid[i+1][j] == 1)\\n                        adj[cell].insert((i+1)*n+j);\\n                    if(j+1 < n && grid[i][j+1] == 1)\\n                        adj[cell].insert((i)*n+j+1);\\n                }\\n            }\\n        }\\n        dfs(store, -1, adj, disc, low, vis);\\n        if(ap)\\n            return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032134,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool valid (int x,int y,int n,int m)\\n  {\\n      return x>=0 && y>=0 && x<n && y<m;\\n  }\\n  void dfs (int x,int y,vector<vector<int>>& grid,vector<vector<int>>& vis,int n,int m)\\n  {\\n     vis[x][y]=1;\\n     int deli[]={0,0,1,-1};\\n     int delj[]={1,-1,0,0};\\n     for (int i=0;i<4;i++)\\n     {\\n         int newi=x+deli[i];\\n         int newj=y+delj[i];\\n         if (valid(newi,newj,n,m) && vis[newi][newj]==0 && grid[newi][newj]==1)\\n         {\\n           dfs(newi,newj,grid,vis,n,m);\\n         }\\n     }\\n  }\\n    bool disconnected(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int cnt=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n                if (grid[i][j]==0) continue;\\n                if (vis[i][j]==0) cnt++;\\n                if (cnt>1) return true;\\n                dfs(i,j,grid,vis,n,m);\\n            }\\n        }\\n       if (cnt==0) return true;\\n        return false;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        if (disconnected(grid)) return 0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n               if (grid[i][j]==0) continue;\\n               grid[i][j]=0;\\n               if (disconnected(grid)) return 1;\\n               grid[i][j]=1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool valid (int x,int y,int n,int m)\\n  {\\n      return x>=0 && y>=0 && x<n && y<m;\\n  }\\n  void dfs (int x,int y,vector<vector<int>>& grid,vector<vector<int>>& vis,int n,int m)\\n  {\\n     vis[x][y]=1;\\n     int deli[]={0,0,1,-1};\\n     int delj[]={1,-1,0,0};\\n     for (int i=0;i<4;i++)\\n     {\\n         int newi=x+deli[i];\\n         int newj=y+delj[i];\\n         if (valid(newi,newj,n,m) && vis[newi][newj]==0 && grid[newi][newj]==1)\\n         {\\n           dfs(newi,newj,grid,vis,n,m);\\n         }\\n     }\\n  }\\n    bool disconnected(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        int cnt=0;\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n                if (grid[i][j]==0) continue;\\n                if (vis[i][j]==0) cnt++;\\n                if (cnt>1) return true;\\n                dfs(i,j,grid,vis,n,m);\\n            }\\n        }\\n       if (cnt==0) return true;\\n        return false;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        if (disconnected(grid)) return 0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=0;j<m;j++)\\n            {\\n               if (grid[i][j]==0) continue;\\n               grid[i][j]=0;\\n               if (disconnected(grid)) return 1;\\n               grid[i][j]=1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032131,
                "title": "dfs-super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int rows, cols;\\n    vector<pair<int,int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int r, int c, vector<vector<int>>& grid, vector<vector<int>> &vis)\\n    {\\n        vis[r][c]=1;\\n        for(auto it: directions)\\n        {\\n            int dr=r+it.first, dc=c+it.second;\\n            if(dr<0 || dc<0 || dr>=rows || dc>=cols || vis[dr][dc] || !grid[dr][dc]) continue;\\n            dfs(dr,dc,grid,vis);\\n        }\\n    }\\n    bool disconnected(vector<vector<int>>& grid)\\n    {\\n        int components=0;\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                if(grid[x][y] && !vis[x][y])\\n                {\\n                    dfs(x,y,grid,vis);\\n                    components++;\\n                    if(components>1 || components==0) return true;\\n                }\\n            }\\n        }\\n        return (components>1 || components==0);\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        rows=grid.size(), cols=grid[0].size();\\n        if(disconnected(grid)) return 0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                if(!grid[x][y]) continue;\\n                grid[x][y]=0;\\n                if(disconnected(grid)) return 1;\\n                grid[x][y]=1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int rows, cols;\\n    vector<pair<int,int>> directions={{-1,0},{0,-1},{1,0},{0,1}};\\n    void dfs(int r, int c, vector<vector<int>>& grid, vector<vector<int>> &vis)\\n    {\\n        vis[r][c]=1;\\n        for(auto it: directions)\\n        {\\n            int dr=r+it.first, dc=c+it.second;\\n            if(dr<0 || dc<0 || dr>=rows || dc>=cols || vis[dr][dc] || !grid[dr][dc]) continue;\\n            dfs(dr,dc,grid,vis);\\n        }\\n    }\\n    bool disconnected(vector<vector<int>>& grid)\\n    {\\n        int components=0;\\n        vector<vector<int>> vis(rows, vector<int> (cols,0));\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                if(grid[x][y] && !vis[x][y])\\n                {\\n                    dfs(x,y,grid,vis);\\n                    components++;\\n                    if(components>1 || components==0) return true;\\n                }\\n            }\\n        }\\n        return (components>1 || components==0);\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        rows=grid.size(), cols=grid[0].size();\\n        if(disconnected(grid)) return 0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                if(!grid[x][y]) continue;\\n                grid[x][y]=0;\\n                if(disconnected(grid)) return 1;\\n                grid[x][y]=1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028419,
                "title": "cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<int>> & vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[x][y] = 1;\\n        for (int a = 0; a < 4; a++)\\n        {\\n            int nx = x + dx[a];\\n            int ny = y + dy[a];\\n            if (nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny])\\n            {\\n                dfs(nx, ny, grid, vis);\\n            }\\n        }\\n    }\\n    int count_islands(vector<vector<int>> & grid)\\n    {\\n        int islands = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (!vis[i][j] and grid[i][j])\\n                {\\n                    dfs(i, j, grid, vis);\\n                    islands ++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int islands = count_islands(grid);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t// check for 0 ans\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = count_islands(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<int>> & vis)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[x][y] = 1;\\n        for (int a = 0; a < 4; a++)\\n        {\\n            int nx = x + dx[a];\\n            int ny = y + dy[a];\\n            if (nx >= 0 and ny >= 0 and nx < n and ny < m and !vis[nx][ny] and grid[nx][ny])\\n            {\\n                dfs(nx, ny, grid, vis);\\n            }\\n        }\\n    }\\n    int count_islands(vector<vector<int>> & grid)\\n    {\\n        int islands = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if (!vis[i][j] and grid[i][j])\\n                {\\n                    dfs(i, j, grid, vis);\\n                    islands ++;\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int islands = count_islands(grid);\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t// check for 0 ans\\n        if (islands > 1 or islands == 0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n\\t\\t\\t// check for 1 ans\\n            for (int i = 0 ; i < n; i ++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    if (grid[i][j])\\n                    {\\n                        grid[i][j] = 0;\\n\\t\\t\\t\\t\\t\\t// remove this block\\n                        islands = count_islands(grid);\\n\\t\\t\\t\\t\\t\\t// add back the block\\n                        grid[i][j] = 1;\\n                        if (islands > 1 or islands == 0)\\n                            return 1;\\n                    }\\n\\n                }\\n            }\\n        }\\n\\t\\t// else\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971014,
                "title": "java-beats-100-onlyyyyyyy-tarjan-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n@SuppressWarnings(\"java:S107\")\\npublic class Solution {\\n\\n  private final int[][] dirs = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n\\n  public int minDays(int[][] grid) {\\n    int m = grid.length;\\n    int n = grid[0].length;\\n    int numOfIslands = 0;\\n    boolean hasArticulationPoint = false;\\n    int color = 1;\\n    int minIslandSize = m * n;\\n    int[][] time = new int[m][n];\\n    int[][] low = new int[m][n];\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1) {\\n          numOfIslands++;\\n          color++;\\n          List<Integer> articulationPoints = new ArrayList<>();\\n          int[] islandSize = new int[1];\\n          tarjan(\\n            i,\\n            j,\\n            -1,\\n            -1,\\n            0,\\n            time,\\n            low,\\n            grid,\\n            articulationPoints,\\n            color,\\n            islandSize\\n          );\\n          minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n          if (!articulationPoints.isEmpty()) {\\n            hasArticulationPoint = true;\\n          }\\n        }\\n      }\\n    }\\n    if (numOfIslands >= 2) {\\n      return 0;\\n    }\\n    if (numOfIslands == 0) {\\n      return 0;\\n    }\\n    if (numOfIslands == 1 && minIslandSize == 1) {\\n      return 1;\\n    }\\n    return hasArticulationPoint ? 1 : 2;\\n  }\\n\\n  private void tarjan(\\n    int x,\\n    int y,\\n    int prex,\\n    int prey,\\n    int time,\\n    int[][] times,\\n    int[][] lows,\\n    int[][] grid,\\n    List<Integer> articulationPoints,\\n    int color,\\n    int[] islandSize\\n  ) {\\n    times[x][y] = time;\\n    lows[x][y] = time;\\n    grid[x][y] = color;\\n    islandSize[0]++;\\n    int children = 0;\\n    for (int[] dir : dirs) {\\n      int nx = x + dir[0];\\n      int ny = y + dir[1];\\n      if (nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length) {\\n        continue;\\n      }\\n      if (grid[nx][ny] == 1) {\\n        children++;\\n        tarjan(\\n          nx,\\n          ny,\\n          x,\\n          y,\\n          time + 1,\\n          times,\\n          lows,\\n          grid,\\n          articulationPoints,\\n          color,\\n          islandSize\\n        );\\n        lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n        if (prex != -1 && lows[nx][ny] >= time) {\\n          articulationPoints.add(x * grid.length + y);\\n        }\\n      } else if ((nx != prex || ny != prey) && grid[nx][ny] != 0) {\\n        lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n      }\\n    }\\n    if (prex == -1 && children > 1) {\\n      articulationPoints.add(x * grid.length + y);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n@SuppressWarnings(\"java:S107\")\\npublic class Solution {\\n\\n  private final int[][] dirs = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n\\n  public int minDays(int[][] grid) {\\n    int m = grid.length;\\n    int n = grid[0].length;\\n    int numOfIslands = 0;\\n    boolean hasArticulationPoint = false;\\n    int color = 1;\\n    int minIslandSize = m * n;\\n    int[][] time = new int[m][n];\\n    int[][] low = new int[m][n];\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1) {\\n          numOfIslands++;\\n          color++;\\n          List<Integer> articulationPoints = new ArrayList<>();\\n          int[] islandSize = new int[1];\\n          tarjan(\\n            i,\\n            j,\\n            -1,\\n            -1,\\n            0,\\n            time,\\n            low,\\n            grid,\\n            articulationPoints,\\n            color,\\n            islandSize\\n          );\\n          minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n          if (!articulationPoints.isEmpty()) {\\n            hasArticulationPoint = true;\\n          }\\n        }\\n      }\\n    }\\n    if (numOfIslands >= 2) {\\n      return 0;\\n    }\\n    if (numOfIslands == 0) {\\n      return 0;\\n    }\\n    if (numOfIslands == 1 && minIslandSize == 1) {\\n      return 1;\\n    }\\n    return hasArticulationPoint ? 1 : 2;\\n  }\\n\\n  private void tarjan(\\n    int x,\\n    int y,\\n    int prex,\\n    int prey,\\n    int time,\\n    int[][] times,\\n    int[][] lows,\\n    int[][] grid,\\n    List<Integer> articulationPoints,\\n    int color,\\n    int[] islandSize\\n  ) {\\n    times[x][y] = time;\\n    lows[x][y] = time;\\n    grid[x][y] = color;\\n    islandSize[0]++;\\n    int children = 0;\\n    for (int[] dir : dirs) {\\n      int nx = x + dir[0];\\n      int ny = y + dir[1];\\n      if (nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length) {\\n        continue;\\n      }\\n      if (grid[nx][ny] == 1) {\\n        children++;\\n        tarjan(\\n          nx,\\n          ny,\\n          x,\\n          y,\\n          time + 1,\\n          times,\\n          lows,\\n          grid,\\n          articulationPoints,\\n          color,\\n          islandSize\\n        );\\n        lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n        if (prex != -1 && lows[nx][ny] >= time) {\\n          articulationPoints.add(x * grid.length + y);\\n        }\\n      } else if ((nx != prex || ny != prey) && grid[nx][ny] != 0) {\\n        lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n      }\\n    }\\n    if (prex == -1 && children > 1) {\\n      articulationPoints.add(x * grid.length + y);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888175,
                "title": "easy-c-articulation-point-check-this-out-by-amazon",
                "content": "# Intuition\\n**easy c++ !! articulation point !! check this out by amazon !!** \\n\\n# Approach\\n**ARTICULATION POINT**\\n\\n# Complexity\\n- Time complexity:\\n**TC = tc of DFS**\\n\\n- Space complexity:\\n**SC = 0(n)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int timer = 1 ; \\n      vector<pair<int,int>>movements ={\\n         {1,0} ,{0,1} ,{-1,0} ,{0,-1}\\n      } ;\\n    void dfs( int x , int y , int px , int py ,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<int>>&entry , vector<vector<int>>&lowtime , vector<vector<bool>>&AP , int nr , int nc )  {\\n        vis[x][y] = true ;\\n        entry[x][y] = timer ;\\n        lowtime[x][y] = timer ; \\n        timer +=1 ; \\n         int childcount = 0 ; \\n        for( auto movement : movements ){\\n            int childx = movement.first + x ;\\n            int childy = movement.second + y ;\\n           if( childx >= 0 and childx <= nr-1 and childy >= 0 and childy <= nc-1 ){\\n               //valid cell hai !! \\n               if( grid[childx][childy] == 0 ) continue ; \\n               if( (childx == px) and (childy == py) ) continue ; \\n               if( vis[childx][childy] ) {\\n                   lowtime[x][y] = min( lowtime[x][y] , entry[childx][childy]) ; \\n                   continue ;\\n               }\\n               childcount ++ ;\\n               dfs( childx , childy , x , y , grid , vis , entry , lowtime , AP , nr , nc ) ;\\n               lowtime[x][y] = min( lowtime[x][y] , lowtime[childx][childy] ) ;\\n               // condition !! \\n               if( (entry[x][y] <= lowtime[childx][childy]) and (px != -1 and py != -1) ){\\n                   // x,y vertex is saying , you can reach to me !! BUT NOT BEFORE ME , hence iam the AP \\n                   AP[x][y] = true ;\\n                  continue ; \\n               }\\n           }\\n            \\n        }\\n        if( childcount > 1 and (px==-1 and py == -1 ) )AP[x][y]=true ;\\n        return ;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        // if( AP is found ) ans = 1 ; \\n        // else ans = 2 ; \\n        int nr = grid.size() ;\\n         int nc = grid[0].size() ;\\n \\n       vector<vector<bool>>vis(nr,vector<bool>(nc,false));\\n       vector<vector<int>>entry( nr , vector<int>(nc,0)) ;\\n       vector<vector<int>>lowtime( nr , vector<int>(nc,0) ) ;\\n       vector<vector<bool>>AP(nr,vector<bool>(nc,false)) ;\\n       bool dfsdone = false ;\\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( grid[i][j] == 1 ){\\n                    dfsdone = true ;\\n                    dfs( i , j , -1 , -1 , grid , vis , entry , lowtime , AP , nr , nc  ) ;\\n                    break ; \\n                }\\n            }\\n            if( dfsdone == true ) break ;\\n        }\\n\\n// for( int i = 0 ; i < nr ; i++ ){\\n//             for( int j = 0 ; j < nc ; j++ ){\\n//              cout << vis[i][j] <<\" \" ;\\n//             }\\n//             cout <<\"\\\\n\" ;\\n//         }\\n\\n        timer = 1 ;\\n       int ctvis = 0 ;\\n       \\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( vis[i][j] == false and grid[i][j] == 1 ) return  0 ; \\n                if( vis[i][j] == true )ctvis++ ; \\n            }\\n        }\\n        if( ctvis == 1 ) return 1 ; \\n        if( ctvis == 0 ) return 0 ;\\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( AP[i][j] == true ) return 1 ;\\n            }\\n        }\\n\\n        return 2 ; \\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Brainteaser",
                    "Matrix",
                    "Iterator",
                    "Biconnected Component",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int timer = 1 ; \\n      vector<pair<int,int>>movements ={\\n         {1,0} ,{0,1} ,{-1,0} ,{0,-1}\\n      } ;\\n    void dfs( int x , int y , int px , int py ,vector<vector<int>>& grid,vector<vector<bool>>&vis,vector<vector<int>>&entry , vector<vector<int>>&lowtime , vector<vector<bool>>&AP , int nr , int nc )  {\\n        vis[x][y] = true ;\\n        entry[x][y] = timer ;\\n        lowtime[x][y] = timer ; \\n        timer +=1 ; \\n         int childcount = 0 ; \\n        for( auto movement : movements ){\\n            int childx = movement.first + x ;\\n            int childy = movement.second + y ;\\n           if( childx >= 0 and childx <= nr-1 and childy >= 0 and childy <= nc-1 ){\\n               //valid cell hai !! \\n               if( grid[childx][childy] == 0 ) continue ; \\n               if( (childx == px) and (childy == py) ) continue ; \\n               if( vis[childx][childy] ) {\\n                   lowtime[x][y] = min( lowtime[x][y] , entry[childx][childy]) ; \\n                   continue ;\\n               }\\n               childcount ++ ;\\n               dfs( childx , childy , x , y , grid , vis , entry , lowtime , AP , nr , nc ) ;\\n               lowtime[x][y] = min( lowtime[x][y] , lowtime[childx][childy] ) ;\\n               // condition !! \\n               if( (entry[x][y] <= lowtime[childx][childy]) and (px != -1 and py != -1) ){\\n                   // x,y vertex is saying , you can reach to me !! BUT NOT BEFORE ME , hence iam the AP \\n                   AP[x][y] = true ;\\n                  continue ; \\n               }\\n           }\\n            \\n        }\\n        if( childcount > 1 and (px==-1 and py == -1 ) )AP[x][y]=true ;\\n        return ;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        // if( AP is found ) ans = 1 ; \\n        // else ans = 2 ; \\n        int nr = grid.size() ;\\n         int nc = grid[0].size() ;\\n \\n       vector<vector<bool>>vis(nr,vector<bool>(nc,false));\\n       vector<vector<int>>entry( nr , vector<int>(nc,0)) ;\\n       vector<vector<int>>lowtime( nr , vector<int>(nc,0) ) ;\\n       vector<vector<bool>>AP(nr,vector<bool>(nc,false)) ;\\n       bool dfsdone = false ;\\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( grid[i][j] == 1 ){\\n                    dfsdone = true ;\\n                    dfs( i , j , -1 , -1 , grid , vis , entry , lowtime , AP , nr , nc  ) ;\\n                    break ; \\n                }\\n            }\\n            if( dfsdone == true ) break ;\\n        }\\n\\n// for( int i = 0 ; i < nr ; i++ ){\\n//             for( int j = 0 ; j < nc ; j++ ){\\n//              cout << vis[i][j] <<\" \" ;\\n//             }\\n//             cout <<\"\\\\n\" ;\\n//         }\\n\\n        timer = 1 ;\\n       int ctvis = 0 ;\\n       \\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( vis[i][j] == false and grid[i][j] == 1 ) return  0 ; \\n                if( vis[i][j] == true )ctvis++ ; \\n            }\\n        }\\n        if( ctvis == 1 ) return 1 ; \\n        if( ctvis == 0 ) return 0 ;\\n        for( int i = 0 ; i < nr ; i++ ){\\n            for( int j = 0 ; j < nc ; j++ ){\\n                if( AP[i][j] == true ) return 1 ;\\n            }\\n        }\\n\\n        return 2 ; \\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3840858,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        int countone =0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    countone++;\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        if(countone==0)return 0;\\n        return 2;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int [][]dirs={{-1,0},{0,1},{0,-1},{1,0}};\\n    public void connectedComponents(int[][] grid, int i, int j, boolean[][] visited) {\\n        \\n        visited[i][j] = true;\\n        for(int d=0;d<4;d++){\\n            int r=i+dirs[d][0];\\n            int c=j+dirs[d][1];\\n            \\n            if(r>=0 && r<grid.length && c>=0 && c<grid[0].length && grid[r][c]==1 && visited[r][c]==false){\\n                connectedComponents(grid,r,c,visited);\\n            }\\n        }\\n    }\\n\\n    public int numIslands(int[][] grid) {\\n        int islandCount = 0;\\n        boolean vis[][] = new boolean[grid.length][grid[0].length];\\n\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 1 && vis[i][j] == false) {\\n                    islandCount++;\\n                    connectedComponents(grid, i, j, vis);\\n                }\\n            }\\n        }\\n\\n        return islandCount;\\n    }\\n\\n    public int minDays(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n\\n        //if more than 1 island is there then the graph is already disconnected\\n        if (numIslands(grid) > 1) {\\n            return 0;\\n        }\\n\\n        //check for all 1\\'s remove it and if there is more than 1 island then return 1\\n        int countone =0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    countone++;\\n                    grid[i][j] = 0;\\n\\n                    if (numIslands(grid) != 1) {\\n                        return 1;\\n                    }\\n\\n                    //recorrect it while backtracking\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n        //else we need min 2 removal\\n        if(countone==0)return 0;\\n        return 2;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834235,
                "title": "c-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n\\n    void dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>&grid)\\n    {\\n        vis[row][col]=1;\\n\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nr=dx[i]+row;\\n            int nc=dy[i]+col;\\n\\n            if(nr<0 || nr>=n || nc<0 || nc>=m) continue;\\n            //out of bounds then continue\\n\\n            // join the adjacent ones and simply do a dfs to connect the \\n            //remaining ones \\n            if(grid[nr][nc]==1 && vis[nr][nc]==0)\\n            {\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n\\n        int count=0;\\n\\n        //if we do a dfs and find out there are more than one conected component then \\n        //we will return 0\\n        //bcz already there are more than one connected component\\n\\n        int cc=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis1(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1 && vis1[i][j]==0)\\n                {\\n                    dfs(i,j,vis1,grid);\\n                    cc++;\\n                 }\\n            }\\n        }\\n        if(cc>1 || cc==0) return 0;\\n        //if we do not have any ones to disconnect or if we have the number of connected component as already greater than one then we simply return 0\\n\\n\\n\\n\\n        //if we reach here we have exactly one connected component of 1\\'s\\n        //we have exactly one connected component\\n        //we will try to make one by one cell value as 0 and do a dfs to find how many connected components the graph still has if it is having 0 / >=2 components then it would be having pattern somewhat similar to this\\n\\n         //1111 111\\n        // 11111111   kind of like a start graph then disconnecting the node at the middle would make \\n        // 1111 111   into more than one component so we will simply return 1 in such cases // we are trying to try for such possibilities\\n\\n        //with the loops grid[i][j]=0 made equal to 0 then tried for counting the number of cc \\n        //then made grid[i][j]=1  to try for other one\\'s as to find that one node that diconnects into multiple components\\n        \\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n\\n                  vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n                    grid[i][j]=0;\\n                    int connected=0;\\n\\n                  for(int i=0;i<n;i++)\\n                  {\\n                      for(int j=0;j<m;j++)\\n                      {\\n                          if(grid[i][j]==1 && vis[i][j]==0)\\n                          {\\n                              dfs(i,j,vis,grid);\\n                              connected++;\\n                          }\\n                      }\\n                  \\n                  }\\n                  grid[i][j]=1;\\n\\n                  if(connected==0 || connected>=2) return 1;\\n                }\\n            }\\n        } \\n\\n        return 2;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,0,1,0};\\n    int dy[4]={0,1,0,-1};\\n\\n    void dfs(int row,int col,vector<vector<int>>&vis,vector<vector<int>>&grid)\\n    {\\n        vis[row][col]=1;\\n\\n        int n=grid.size();\\n        int m=grid[0].size();\\n\\n        for(int i=0;i<4;i++)\\n        {\\n            int nr=dx[i]+row;\\n            int nc=dy[i]+col;\\n\\n            if(nr<0 || nr>=n || nc<0 || nc>=m) continue;\\n            //out of bounds then continue\\n\\n            // join the adjacent ones and simply do a dfs to connect the \\n            //remaining ones \\n            if(grid[nr][nc]==1 && vis[nr][nc]==0)\\n            {\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n\\n        int count=0;\\n\\n        //if we do a dfs and find out there are more than one conected component then \\n        //we will return 0\\n        //bcz already there are more than one connected component\\n\\n        int cc=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis1(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1 && vis1[i][j]==0)\\n                {\\n                    dfs(i,j,vis1,grid);\\n                    cc++;\\n                 }\\n            }\\n        }\\n        if(cc>1 || cc==0) return 0;\\n        //if we do not have any ones to disconnect or if we have the number of connected component as already greater than one then we simply return 0\\n\\n\\n\\n\\n        //if we reach here we have exactly one connected component of 1\\'s\\n        //we have exactly one connected component\\n        //we will try to make one by one cell value as 0 and do a dfs to find how many connected components the graph still has if it is having 0 / >=2 components then it would be having pattern somewhat similar to this\\n\\n         //1111 111\\n        // 11111111   kind of like a start graph then disconnecting the node at the middle would make \\n        // 1111 111   into more than one component so we will simply return 1 in such cases // we are trying to try for such possibilities\\n\\n        //with the loops grid[i][j]=0 made equal to 0 then tried for counting the number of cc \\n        //then made grid[i][j]=1  to try for other one\\'s as to find that one node that diconnects into multiple components\\n        \\n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n\\n                  vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n                    grid[i][j]=0;\\n                    int connected=0;\\n\\n                  for(int i=0;i<n;i++)\\n                  {\\n                      for(int j=0;j<m;j++)\\n                      {\\n                          if(grid[i][j]==1 && vis[i][j]==0)\\n                          {\\n                              dfs(i,j,vis,grid);\\n                              connected++;\\n                          }\\n                      }\\n                  \\n                  }\\n                  grid[i][j]=1;\\n\\n                  if(connected==0 || connected>=2) return 1;\\n                }\\n            }\\n        } \\n\\n        return 2;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798645,
                "title": "java-tarjan-easier-to-read-than-others",
                "content": "# Intuition\\nAs of now, this should be the easiest Tarjan solution to read in Java.\\n\\n# Approach\\nThere are a lot Tarjan articles and they do better than what I can write. I just have to say that I wasn\\'t able find a good one that explained the scenario when root has two children during DFS is a cut vertex. If anyone can share a good article that can really explain Tarjan this scenario, I will appreciate it.\\n\\nFound some hint from this paper:\\nhttps://arxiv.org/pdf/1805.11864.pdf\\n\"Cut vertices: Output each vertex v in F that has a child w with P(w) = false and is not a root in F or has two or more children.\"\\n\\nIf you speak Chinese, this video has that part explained around 4:30 min:\\nhttps://www.youtube.com/watch?v=-0SmfUw_f4o&ab_channel=latadage\\n\\nI also want to point out that it\\'s a shame that we still know ahead of time that we only need to cut off no more than two lands. Without this assumption ahead of time, there is no tarjan solution.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n    int[] dfn; int[] low;\\n    \\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        // If number of lands is 2, we want to return 2 that will remove all lands from graph.\\n        if (count == 1) return 1;\\n        if (count == 2) return 2;\\n        buildGraph(grid);\\n        int m = grid.length, n = grid[0].length;\\n        dfn = new int[m * n]; low = new int[m * n];\\n        Arrays.fill(dfn, -1);\\n        tarjan(-1, root);\\n        return foundCriticalEdge ? 1 : 2;  // We still know it\\'s only 1 or 2 ahead of time.\\n    }\\n    \\n    private void tarjan(int prev, int cur) {\\n        if (foundCriticalEdge) return;\\n        dfn[cur] = low[cur] = ++time;\\n\\n        int son = 0;\\n        for (int nei : graph.get(cur)) {\\n            //System.out.println(\"nei: \" + nei + \" prev: \" + prev + \" dfn[nei] \" + dfn[nei]);\\n            if (nei == prev) continue;            \\n            if (dfn[nei] == -1) {\\n                son++;\\n                tarjan(cur, nei);\\n                low[cur] = Math.min(low[cur], low[nei]);\\n                if ((cur == root && son > 1) || (low[nei] >= dfn[cur] && cur != root)) {\\n                    //System.out.println(\"foundCriticalEdge cur is \" + cur + \" son \" + son + \" nei \" + nei + \" low[nei] \" + low[nei] + \" dfn[cur] \" + dfn[cur] + \" root \" + root);\\n                    //System.out.println(\" low \" + Arrays.toString(low) + \" dfn \" + Arrays.toString(dfn));\\n                    foundCriticalEdge = true;\\n                    return;\\n                }\\n            } else {\\n                low[cur] = Math.min(low[cur], low[nei]);  //low[nei] or dfn[nei] both work.\\n            }\\n        }\\n    }\\n    /* This is the usecase when (cur == root && son > 1) matters\\n    [0,1,1],\\n    [1,1,1],\\n    [1,1,0]\\n    */\\n\\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    boolean foundCriticalEdge;\\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    int root = -1, time = 0, count = 0;\\n    int[] dfn; int[] low;\\n    \\n    public int minDays(int[][] grid) {\\n        if (noOfIsland(grid) != 1) return 0;\\n        // If number of lands is 2, we want to return 2 that will remove all lands from graph.\\n        if (count == 1) return 1;\\n        if (count == 2) return 2;\\n        buildGraph(grid);\\n        int m = grid.length, n = grid[0].length;\\n        dfn = new int[m * n]; low = new int[m * n];\\n        Arrays.fill(dfn, -1);\\n        tarjan(-1, root);\\n        return foundCriticalEdge ? 1 : 2;  // We still know it\\'s only 1 or 2 ahead of time.\\n    }\\n    \\n    private void tarjan(int prev, int cur) {\\n        if (foundCriticalEdge) return;\\n        dfn[cur] = low[cur] = ++time;\\n\\n        int son = 0;\\n        for (int nei : graph.get(cur)) {\\n            //System.out.println(\"nei: \" + nei + \" prev: \" + prev + \" dfn[nei] \" + dfn[nei]);\\n            if (nei == prev) continue;            \\n            if (dfn[nei] == -1) {\\n                son++;\\n                tarjan(cur, nei);\\n                low[cur] = Math.min(low[cur], low[nei]);\\n                if ((cur == root && son > 1) || (low[nei] >= dfn[cur] && cur != root)) {\\n                    //System.out.println(\"foundCriticalEdge cur is \" + cur + \" son \" + son + \" nei \" + nei + \" low[nei] \" + low[nei] + \" dfn[cur] \" + dfn[cur] + \" root \" + root);\\n                    //System.out.println(\" low \" + Arrays.toString(low) + \" dfn \" + Arrays.toString(dfn));\\n                    foundCriticalEdge = true;\\n                    return;\\n                }\\n            } else {\\n                low[cur] = Math.min(low[cur], low[nei]);  //low[nei] or dfn[nei] both work.\\n            }\\n        }\\n    }\\n    /* This is the usecase when (cur == root && son > 1) matters\\n    [0,1,1],\\n    [1,1,1],\\n    [1,1,0]\\n    */\\n\\n    public void buildGraph(int[][] grid) {\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (grid[i][j] == 1)\\n                    for (int[] dir : dirs)\\n                        mark(grid, i, j, i + dir[0], j + dir[1]);\\n    }\\n    \\n    public void mark(int grid[][], int prevX, int prevY, int x, int y) {\\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0) return;\\n        int n1 = prevX * grid[0].length + prevY;\\n        int n2 = x * grid[0].length + y;\\n        graph.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n        graph.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n    }\\n    \\n    private int noOfIsland(int[][] grid) {\\n        int res = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for (int i = 0; i < grid.length; i++)\\n            for (int j = 0; j < grid[0].length; j++)\\n                if (!visited[i][j] && grid[i][j] == 1) {\\n                    if (root == -1) root = i * grid[0].length + j;\\n                    res++;\\n                    dfs(visited, grid,i,j);\\n                }\\n        return res;\\n    }\\n    \\n    private void dfs(boolean[][] visited, int[][] grid, int i, int j) {\\n        if (i < 0 || j < 0 || i == grid.length || j == grid[0].length || visited[i][j] || grid[i][j] == 0) return;\\n        count++;\\n        visited[i][j] = true;\\n        for (int[] dir : dirs) \\n            dfs(visited, grid, i + dir[0], j + dir[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759869,
                "title": "java-with-explanation-dfs",
                "content": "Do upvote (\\uD83D\\uDC4D) if you like the solution. \\n\\n# Approach\\n    hint : \\n    1. Return 0 if the grid is already disconnected.\\n    2. Return 1 if changing a single land to water disconnect the island.\\n    3. Otherwise return 2\\n    4. We can disconnect the grid within at most 2 days.\\n\\nbased on above hint, \\n\\n1. Check if graph already diconncted\\n    - do DFS on each node,  if DFS count !=1 then graph is disconected\\n2. Check if removing any node makes graph disconnected\\n    - For each land grid i,j - consider node as \\'x\\'\\n    - if x has minimum 2 adjacent land nodes, then change x\\'s value to water.\\n    - And start from any adjancent land node and do DFS on it. \\n    - If any of the node\\'s adjacent grid is not visited with above DFS, we can treat that our \\'x\\' node disconnected the graph.\\n    - otherwise change back grid value to land;  \\n![Screenshot 2023-07-13 at 8.47.20 PM.png](https://assets.leetcode.com/users/images/2de18acf-e03b-4840-ab11-48d01a093128_1689261519.4931056.png)\\n\\n3. return 2\\n# Code\\n```\\nclass Solution {\\n    int WATER = 0;\\n    int LAND = 1;\\n\\n    /*\\n\\n    hint : \\n    1. Return 0 if the grid is already disconnected.\\n    2. Return 1 if changing a single land to water disconnect the island.\\n    3. Otherwise return 2\\n    4. We can disconnect the grid within at most 2 days.\\n\\n    So \\n     > do DFS on any land grid. \\n     > after DFS if we still find any unvisited 1\\'s , then return 0. which mean graph is already diconnected. \\n     > while doig DFS find any land with has only 2 connected lands. if such node exists return 1;\\n     > eles return 2 \\n\\n    */\\n    public int minDays(int[][] grid) {\\n        if(isGraphDisconnected(grid))\\n            return 0;\\n        if(checkIfRemovingOneNodeDisconnectsGraph(grid))\\n            return 1; \\n        return 2;\\n    }\\n\\n    boolean isGraphDisconnected(int[][] grid){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        boolean[][] visited = new boolean[M][N];\\n        int dfsCount=0;\\n        for(int i=0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                if(grid[i][j]==LAND && !visited[i][j]){\\n                    dfsCount++;\\n                    if(dfsCount>1)\\n                        return true;\\n                    DFS(grid, i, j, visited);\\n                }\\n            }\\n        }\\n        return dfsCount!=1;\\n    }\\n\\n    boolean checkIfRemovingOneNodeDisconnectsGraph(int[][] grid){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        int landCount =0;\\n        for(int i=0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                if(grid[i][j]==LAND){\\n                    landCount++;\\n                    grid[i][j] = WATER;\\n                    boolean[][] visited = new boolean[M][N];\\n                    int adjacentLandCount=1;\\n                    for(int[] dir: dirs){\\n                        int nextRow = i+dir[0];\\n                        int nextCol = j+dir[1];\\n                        if(isSafe(nextRow,nextCol, M, N) && grid[nextRow][nextCol]==1){\\n                            adjacentLandCount++;\\n                            if(adjacentLandCount>1){\\n                                DFS(grid, nextRow, nextCol, visited);\\n                                break;\\n                            }\\n                        }\\n                    }\\n\\n                    for(int[] dir: dirs){\\n                        int nextRow = i+dir[0];\\n                        int nextCol = j+dir[1];\\n                        if(isSafe(nextRow,nextCol, M, N) && grid[nextRow][nextCol]==1){\\n                            if(!visited[nextRow][nextCol])\\n                                return true;\\n                        }\\n                    }\\n                    grid[i][j] = LAND;\\n                }\\n            }\\n        }\\n        return landCount==1;\\n    }\\n\\n    boolean isSafe(int row, int col , int M, int N){\\n        return row>=0 && row<M && col>=0 && col<N;\\n    }\\n\\n    int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void DFS(int[][] grid, int row, int col, boolean[][] visited){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        if(!isSafe(row, col, M, N) || visited[row][col] || grid[row][col]==0)\\n            return;\\n        visited[row][col]= true;\\n        int visitedCount = 1;\\n        for(int[] dir: dirs){\\n            int newRow = row+dir[0];\\n            int newCol = col+dir[1];\\n            if(isSafe(newRow,newCol, M, N) && !visited[newRow][newCol] && grid[newRow][newCol]==1)\\n                DFS(grid, newRow, newCol, visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int WATER = 0;\\n    int LAND = 1;\\n\\n    /*\\n\\n    hint : \\n    1. Return 0 if the grid is already disconnected.\\n    2. Return 1 if changing a single land to water disconnect the island.\\n    3. Otherwise return 2\\n    4. We can disconnect the grid within at most 2 days.\\n\\n    So \\n     > do DFS on any land grid. \\n     > after DFS if we still find any unvisited 1\\'s , then return 0. which mean graph is already diconnected. \\n     > while doig DFS find any land with has only 2 connected lands. if such node exists return 1;\\n     > eles return 2 \\n\\n    */\\n    public int minDays(int[][] grid) {\\n        if(isGraphDisconnected(grid))\\n            return 0;\\n        if(checkIfRemovingOneNodeDisconnectsGraph(grid))\\n            return 1; \\n        return 2;\\n    }\\n\\n    boolean isGraphDisconnected(int[][] grid){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        boolean[][] visited = new boolean[M][N];\\n        int dfsCount=0;\\n        for(int i=0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                if(grid[i][j]==LAND && !visited[i][j]){\\n                    dfsCount++;\\n                    if(dfsCount>1)\\n                        return true;\\n                    DFS(grid, i, j, visited);\\n                }\\n            }\\n        }\\n        return dfsCount!=1;\\n    }\\n\\n    boolean checkIfRemovingOneNodeDisconnectsGraph(int[][] grid){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        int landCount =0;\\n        for(int i=0;i<M;i++){\\n            for(int j=0;j<N;j++){\\n                if(grid[i][j]==LAND){\\n                    landCount++;\\n                    grid[i][j] = WATER;\\n                    boolean[][] visited = new boolean[M][N];\\n                    int adjacentLandCount=1;\\n                    for(int[] dir: dirs){\\n                        int nextRow = i+dir[0];\\n                        int nextCol = j+dir[1];\\n                        if(isSafe(nextRow,nextCol, M, N) && grid[nextRow][nextCol]==1){\\n                            adjacentLandCount++;\\n                            if(adjacentLandCount>1){\\n                                DFS(grid, nextRow, nextCol, visited);\\n                                break;\\n                            }\\n                        }\\n                    }\\n\\n                    for(int[] dir: dirs){\\n                        int nextRow = i+dir[0];\\n                        int nextCol = j+dir[1];\\n                        if(isSafe(nextRow,nextCol, M, N) && grid[nextRow][nextCol]==1){\\n                            if(!visited[nextRow][nextCol])\\n                                return true;\\n                        }\\n                    }\\n                    grid[i][j] = LAND;\\n                }\\n            }\\n        }\\n        return landCount==1;\\n    }\\n\\n    boolean isSafe(int row, int col , int M, int N){\\n        return row>=0 && row<M && col>=0 && col<N;\\n    }\\n\\n    int[][] dirs = {{0,1},{1,0},{0,-1},{-1,0}};\\n    void DFS(int[][] grid, int row, int col, boolean[][] visited){\\n        int M = grid.length;\\n        int N = grid[0].length;\\n        if(!isSafe(row, col, M, N) || visited[row][col] || grid[row][col]==0)\\n            return;\\n        visited[row][col]= true;\\n        int visitedCount = 1;\\n        for(int[] dir: dirs){\\n            int newRow = row+dir[0];\\n            int newCol = col+dir[1];\\n            if(isSafe(newRow,newCol, M, N) && !visited[newRow][newCol] && grid[newRow][newCol]==1)\\n                DFS(grid, newRow, newCol, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717286,
                "title": "bfs-dfs-for-articulation-point-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arr1[4]={1,-1,0,0};\\n    int arr2[4]={0,0,1,-1};\\n    void bfs(int x,int y,vector<vector<int>> &vis,vector<vector<int>> grid){\\n        queue<pair<int,int>> pq;\\n        vis[x][y]=1;\\n        pq.push({x,y});\\n        while(!pq.empty()){\\n            pair<int,int> p=pq.front();\\n            int cx=p.first;\\n            int cy=p.second;\\n            pq.pop();\\n            for(int i=0;i<4;i++){\\n                int nx=cx+arr1[i];\\n                int ny=cy+arr2[i];\\n                if(nx>=0 and ny>=0 and nx<grid.size() and ny<grid[0].size()){\\n                    if(vis[nx][ny]==0 and grid[nx][ny]==1){\\n                        pq.push({nx,ny});\\n                        vis[nx][ny]=1;\\n                    }\\n                }\\n            }\\n        }\\n\\n    }\\n    int f=0;\\n    void dfs(int sx,int sy,int timer,vector<vector<int>> &lo,vector<vector<int>> &time,int parentx,int parenty,vector<vector<int>> grid,vector<vector<int>> &vis){\\n        timer++;\\n        time[sx][sy]=timer;\\n        lo[sx][sy]=timer;\\n        vis[sx][sy]=1;\\n        int child=0;\\n        // cout<<sx<<\\' \\'<<sy<<endl;\\n        for(int i=0;i<4;i++){\\n            int nx=arr1[i]+sx;\\n            int ny=arr2[i]+sy;\\n            if(nx>=0 and ny>=0 and nx<grid.size() and ny<grid[0].size() and grid[nx][ny]==1){\\n                if(parentx==nx and parenty==ny){\\n                    //extra case\\n                    continue;\\n                }\\n                else if(vis[nx][ny]==0){\\n                    //case0\\n                    dfs(nx,ny,timer,lo,time,sx,sy,grid,vis);\\n                    // cout<<nx<<\\' \\'<<ny<<endl;\\n                    // case2\\n                    lo[sx][sy]=min(lo[sx][sy],lo[nx][ny]);\\n                    //case3\\n                    if(nx==1 and ny==2){\\n                        // cout<<\"toi\";\\n                        // cout<<lo[nx][ny]<<\" \"<<time[sx][sy]<<endl;\\n                    }\\n                    if(lo[nx][ny]>=time[sx][sy] and parentx!=-1 and parenty!=-1){\\n                        f=1;\\n                    }\\n                    child++;\\n                }\\n                else{\\n                    // case 1\\n                    lo[sx][sy]=min(lo[sx][sy],time[nx][ny]);\\n                }\\n            }\\n        }  \\n        if(parentx==-1 and parenty==-1){\\n            if(child>1){\\n                // cout<<child<<endl;\\n                f=1;\\n            }\\n        }  \\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int c=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int sourcex,sourcey;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 and grid[i][j]==1){\\n                    sourcex=i;\\n                    sourcey=j;\\n                    c++;\\n                    bfs(i,j,vis,grid);\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> vis1(n,vector<int>(m,0));\\n        vector<vector<int>> lo(n,vector<int>(m,0));\\n        vector<vector<int>> time(n,vector<int>(m,0));\\n        if(c>1){\\n            return 0;\\n        }\\n        else{\\n            dfs(sourcex,sourcey,0,lo,time,-1,-1,grid,vis1);\\n            if(f==1){\\n                return 1;\\n            }\\n        }\\n        return min(cnt,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arr1[4]={1,-1,0,0};\\n    int arr2[4]={0,0,1,-1};\\n    void bfs(int x,int y,vector<vector<int>> &vis,vector<vector<int>> grid){\\n        queue<pair<int,int>> pq;\\n        vis[x][y]=1;\\n        pq.push({x,y});\\n        while(!pq.empty()){\\n            pair<int,int> p=pq.front();\\n            int cx=p.first;\\n            int cy=p.second;\\n            pq.pop();\\n            for(int i=0;i<4;i++){\\n                int nx=cx+arr1[i];\\n                int ny=cy+arr2[i];\\n                if(nx>=0 and ny>=0 and nx<grid.size() and ny<grid[0].size()){\\n                    if(vis[nx][ny]==0 and grid[nx][ny]==1){\\n                        pq.push({nx,ny});\\n                        vis[nx][ny]=1;\\n                    }\\n                }\\n            }\\n        }\\n\\n    }\\n    int f=0;\\n    void dfs(int sx,int sy,int timer,vector<vector<int>> &lo,vector<vector<int>> &time,int parentx,int parenty,vector<vector<int>> grid,vector<vector<int>> &vis){\\n        timer++;\\n        time[sx][sy]=timer;\\n        lo[sx][sy]=timer;\\n        vis[sx][sy]=1;\\n        int child=0;\\n        // cout<<sx<<\\' \\'<<sy<<endl;\\n        for(int i=0;i<4;i++){\\n            int nx=arr1[i]+sx;\\n            int ny=arr2[i]+sy;\\n            if(nx>=0 and ny>=0 and nx<grid.size() and ny<grid[0].size() and grid[nx][ny]==1){\\n                if(parentx==nx and parenty==ny){\\n                    //extra case\\n                    continue;\\n                }\\n                else if(vis[nx][ny]==0){\\n                    //case0\\n                    dfs(nx,ny,timer,lo,time,sx,sy,grid,vis);\\n                    // cout<<nx<<\\' \\'<<ny<<endl;\\n                    // case2\\n                    lo[sx][sy]=min(lo[sx][sy],lo[nx][ny]);\\n                    //case3\\n                    if(nx==1 and ny==2){\\n                        // cout<<\"toi\";\\n                        // cout<<lo[nx][ny]<<\" \"<<time[sx][sy]<<endl;\\n                    }\\n                    if(lo[nx][ny]>=time[sx][sy] and parentx!=-1 and parenty!=-1){\\n                        f=1;\\n                    }\\n                    child++;\\n                }\\n                else{\\n                    // case 1\\n                    lo[sx][sy]=min(lo[sx][sy],time[nx][ny]);\\n                }\\n            }\\n        }  \\n        if(parentx==-1 and parenty==-1){\\n            if(child>1){\\n                // cout<<child<<endl;\\n                f=1;\\n            }\\n        }  \\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int c=0;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int sourcex,sourcey;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 and grid[i][j]==1){\\n                    sourcex=i;\\n                    sourcey=j;\\n                    c++;\\n                    bfs(i,j,vis,grid);\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    cnt++;\\n                }\\n            }\\n        }\\n        vector<vector<int>> vis1(n,vector<int>(m,0));\\n        vector<vector<int>> lo(n,vector<int>(m,0));\\n        vector<vector<int>> time(n,vector<int>(m,0));\\n        if(c>1){\\n            return 0;\\n        }\\n        else{\\n            dfs(sourcex,sourcey,0,lo,time,-1,-1,grid,vis1);\\n            if(f==1){\\n                return 1;\\n            }\\n        }\\n        return min(cnt,2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3630139,
                "title": "articulation-point-algorithm-2d-matrix-as-a-graph",
                "content": "# Complexity\\n- Time complexity:\\nO(mn)\\n\\n- Space complexity:\\nO(mn)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_days(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut point: Vec<usize> = Vec::with_capacity(2);\\n        let (m, n) = (grid.len(), grid[0].len()); \\n        let mut no_of_island = 0;\\n        let mut art = false;\\n        \\n        let mut timer = 0;\\n                    \\n        for i in 0..m {\\n            for j in 0..n {\\n                if grid[i][j] == 1 {\\n                    println!(\"{} {}\", i, j);\\n                    no_of_island += 1;\\n                    let mut low_tin = vec![vec![0; n]; m];\\n                    let mut tin = vec![vec![0; n]; m];\\n                    timer = 0;\\n                    Solution::dfs(\\n                        -1, -1,  &mut grid, i, j, &mut low_tin, &mut tin, &mut art,\\n                        &mut timer \\n                    ); \\n                }\\n            }\\n        }\\n        if no_of_island == 0 {return 0;}\\n        if no_of_island > 1 {return 0;}\\n        if timer == 1 {return 1;}\\n        if art {return 1;}\\n        return 2;\\n    }\\n\\n    pub fn dfs(parentx:i32, parenty:i32, grid: &mut Vec<Vec<i32>>, i:usize, j:usize, \\n    low_tin: &mut Vec<Vec<i32>>, tin: &mut Vec<Vec<i32>>, art: &mut bool, timer:&mut i32 ){\\n        \\n        grid[i][j] = -1;\\n        tin[i][j] = *timer;\\n        low_tin[i][j] = *timer;\\n        let mut rootcall = 0;\\n        *timer = *timer+1;\\n\\n        let dirs: [[i32; 2]; 4] = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n        for it in dirs {\\n            let newx = i as i32+it[0];\\n            let newy = j as i32+it[1];\\n            if parentx == newx && parenty == newy {continue;}\\n            if newx >= 0 &&  newy >= 0 && newx < grid.len() as i32 && newy < grid[0].len() as i32 {\\n                if grid[newx as usize][newy  as usize] == 1{\\n                    Solution::dfs(\\n                        i as i32, j as i32, grid, newx as usize, newy as usize, low_tin, tin, art, timer\\n                    );   \\n                    low_tin[i][j] = std::cmp::min(low_tin[i][j], low_tin[newx as usize][newy as usize]);\\n                    if tin[i][j] <= low_tin[newx as usize][newy as usize] && parentx != -1 && parenty != -1 {\\n                        *art = true;\\n                    }\\n                    rootcall += 1;\\n                \\n                } else if grid[newx as usize][newy as usize] == -1 {\\n                    low_tin[i][j] = std::cmp::min(low_tin[i][j], tin[newx as usize][newy as usize]); \\n                }\\n            } else {continue;}        \\n        }\\n        if parentx == -1 && parenty == -1  && rootcall > 1 {\\n            *art = true;\\n        }       \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_days(mut grid: Vec<Vec<i32>>) -> i32 {\\n        let mut point: Vec<usize> = Vec::with_capacity(2);\\n        let (m, n) = (grid.len(), grid[0].len()); \\n        let mut no_of_island = 0;\\n        let mut art = false;\\n        \\n        let mut timer = 0;\\n                    \\n        for i in 0..m {\\n            for j in 0..n {\\n                if grid[i][j] == 1 {\\n                    println!(\"{} {}\", i, j);\\n                    no_of_island += 1;\\n                    let mut low_tin = vec![vec![0; n]; m];\\n                    let mut tin = vec![vec![0; n]; m];\\n                    timer = 0;\\n                    Solution::dfs(\\n                        -1, -1,  &mut grid, i, j, &mut low_tin, &mut tin, &mut art,\\n                        &mut timer \\n                    ); \\n                }\\n            }\\n        }\\n        if no_of_island == 0 {return 0;}\\n        if no_of_island > 1 {return 0;}\\n        if timer == 1 {return 1;}\\n        if art {return 1;}\\n        return 2;\\n    }\\n\\n    pub fn dfs(parentx:i32, parenty:i32, grid: &mut Vec<Vec<i32>>, i:usize, j:usize, \\n    low_tin: &mut Vec<Vec<i32>>, tin: &mut Vec<Vec<i32>>, art: &mut bool, timer:&mut i32 ){\\n        \\n        grid[i][j] = -1;\\n        tin[i][j] = *timer;\\n        low_tin[i][j] = *timer;\\n        let mut rootcall = 0;\\n        *timer = *timer+1;\\n\\n        let dirs: [[i32; 2]; 4] = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n        for it in dirs {\\n            let newx = i as i32+it[0];\\n            let newy = j as i32+it[1];\\n            if parentx == newx && parenty == newy {continue;}\\n            if newx >= 0 &&  newy >= 0 && newx < grid.len() as i32 && newy < grid[0].len() as i32 {\\n                if grid[newx as usize][newy  as usize] == 1{\\n                    Solution::dfs(\\n                        i as i32, j as i32, grid, newx as usize, newy as usize, low_tin, tin, art, timer\\n                    );   \\n                    low_tin[i][j] = std::cmp::min(low_tin[i][j], low_tin[newx as usize][newy as usize]);\\n                    if tin[i][j] <= low_tin[newx as usize][newy as usize] && parentx != -1 && parenty != -1 {\\n                        *art = true;\\n                    }\\n                    rootcall += 1;\\n                \\n                } else if grid[newx as usize][newy as usize] == -1 {\\n                    low_tin[i][j] = std::cmp::min(low_tin[i][j], tin[newx as usize][newy as usize]); \\n                }\\n            } else {continue;}        \\n        }\\n        if parentx == -1 && parenty == -1  && rootcall > 1 {\\n            *art = true;\\n        }       \\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593181,
                "title": "python-tarjan-s-algorithm-articulation-point-detection-at-most-2-days-of-flipping-1s-to-0s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a haaaard problem if you don\\'t know that we can take at most 2 days to separate a given island. We solve this using SCCs concept + articulation point detection.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use Tarjan\\'s algorithm with articulation point detection. This enables us to calculate the number of islands (strongly connected components) in our grid. Moreover, we detect if we have an articulation point -> a node/point, if remove, will disconnect our SCC breaking it to separate SCCs\\n2. Handle edge cases. If we have more than 1 SCCs, return 0. If we have an articulation point, return 1. Otherwise, check if we actually have islands in the grid. If no islands, return 0. If we have a single 1, return 1.\\n3. Finally, if any of the above did not happen, return 2. Imagine a board full of 1. At the minimum, how many 1 should we erase to have two separate islands?\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        rows, cols = len(grid), len(grid[0])\\n\\n        disc_time = [[-1 for _ in range(cols)] for _ in range(rows)]\\n        low_value = [[-1 for _ in range(cols)] for _ in range(rows)]\\n        parents = [[(-1, -1) for _ in range(cols)] for _ in range(rows)]\\n        is_ap = [[False for _ in range(cols)] for _ in range(rows)]\\n        dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n\\n        time = 0\\n        has_ap = False\\n        def dfs(i, j):\\n            if grid[i][j] == 0:\\n                return\\n            nonlocal time\\n            nonlocal has_ap\\n            disc_time[i][j] = time\\n            low_value[i][j] = time\\n            time += 1\\n\\n            child = 0\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if not (0 <= ni < rows) or not (0 <= nj < cols):\\n                    continue\\n                if grid[ni][nj] != 1:\\n                    continue\\n\\n                if disc_time[ni][nj] == -1: # not visited\\n                    child += 1\\n                    parents[ni][nj] = (i, j)\\n                    dfs(ni, nj)\\n                    low_value[i][j] = min(low_value[i][j], low_value[ni][nj])\\n\\n                    if parents[i][j] == (-1, -1) and child > 1:\\n                        is_ap[i][j] = True\\n                        has_ap = True\\n\\n                    if parents[i][j] != (-1, -1) and low_value[ni][nj] >= disc_time[i][j]:\\n                        is_ap[i][j] = True\\n                        has_ap = True\\n                elif (ni, nj) != parents[i][j]:\\n                    low_value[i][j] = min(low_value[i][j], disc_time[ni][nj])\\n\\n        sccs = 0\\n        num_ones = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid[i][j] == 1:\\n                    num_ones += 1\\n                if disc_time[i][j] == -1 and grid[i][j] == 1:\\n                    dfs(i, j)\\n                    sccs += 1\\n\\n\\n        if sccs > 1:\\n            return 0\\n        elif has_ap:\\n            return 1\\n        else:\\n            if num_ones == 1:\\n                return 1\\n            elif num_ones == 0:\\n                return 0\\n        return 2\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        rows, cols = len(grid), len(grid[0])\\n\\n        disc_time = [[-1 for _ in range(cols)] for _ in range(rows)]\\n        low_value = [[-1 for _ in range(cols)] for _ in range(rows)]\\n        parents = [[(-1, -1) for _ in range(cols)] for _ in range(rows)]\\n        is_ap = [[False for _ in range(cols)] for _ in range(rows)]\\n        dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\\n\\n        time = 0\\n        has_ap = False\\n        def dfs(i, j):\\n            if grid[i][j] == 0:\\n                return\\n            nonlocal time\\n            nonlocal has_ap\\n            disc_time[i][j] = time\\n            low_value[i][j] = time\\n            time += 1\\n\\n            child = 0\\n            for di, dj in dirs:\\n                ni, nj = i + di, j + dj\\n                if not (0 <= ni < rows) or not (0 <= nj < cols):\\n                    continue\\n                if grid[ni][nj] != 1:\\n                    continue\\n\\n                if disc_time[ni][nj] == -1: # not visited\\n                    child += 1\\n                    parents[ni][nj] = (i, j)\\n                    dfs(ni, nj)\\n                    low_value[i][j] = min(low_value[i][j], low_value[ni][nj])\\n\\n                    if parents[i][j] == (-1, -1) and child > 1:\\n                        is_ap[i][j] = True\\n                        has_ap = True\\n\\n                    if parents[i][j] != (-1, -1) and low_value[ni][nj] >= disc_time[i][j]:\\n                        is_ap[i][j] = True\\n                        has_ap = True\\n                elif (ni, nj) != parents[i][j]:\\n                    low_value[i][j] = min(low_value[i][j], disc_time[ni][nj])\\n\\n        sccs = 0\\n        num_ones = 0\\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid[i][j] == 1:\\n                    num_ones += 1\\n                if disc_time[i][j] == -1 and grid[i][j] == 1:\\n                    dfs(i, j)\\n                    sccs += 1\\n\\n\\n        if sccs > 1:\\n            return 0\\n        elif has_ap:\\n            return 1\\n        else:\\n            if num_ones == 1:\\n                return 1\\n            elif num_ones == 0:\\n                return 0\\n        return 2\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591730,
                "title": "simple-dfs-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n,m,islands,ones,vis[35][35];\\n    void dfs(int r,int c,vector<vector<int>>& grid){\\n        if(r<0 or c<0 or r>=grid.size() or c>=grid[0].size() or grid[r][c]==0 or vis[r][c]==1 ) return;\\n        vis[r][c]=1;\\n\\n        dfs(r+1,c,grid);\\n        dfs(r-1,c,grid);\\n        dfs(r,c+1,grid);\\n        dfs(r,c-1,grid);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n\\n        n=grid.size(),m=grid[0].size();\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 and grid[i][j]==1){\\n                    dfs(i,j,grid),islands++;\\n                }\\n                if(grid[i][j]==1) ones++;\\n            }\\n        }\\n\\n        if(islands!=1) return 0;\\n\\n        if(m==1 or n==1 or ones<=2) return ones==2 ? 2 : 1;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               if(grid[i][j]==1){\\n                   int x=i,y=j;\\n                   grid[i][j]=0;\\n                   islands=0;\\n                   memset(vis,0,sizeof(vis));\\n                   for(int a=0;a<n;a++){\\n                       for(int b=0;b<m;b++){\\n                           if(vis[a][b]==0 and grid[a][b]==1){\\n                               dfs(a,b,grid),islands++;\\n                           }\\n                       }\\n                   }\\n\\n                   if(islands>1) return 1;\\n\\n                   grid[x][y]=1;\\n               }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m,islands,ones,vis[35][35];\\n    void dfs(int r,int c,vector<vector<int>>& grid){\\n        if(r<0 or c<0 or r>=grid.size() or c>=grid[0].size() or grid[r][c]==0 or vis[r][c]==1 ) return;\\n        vis[r][c]=1;\\n\\n        dfs(r+1,c,grid);\\n        dfs(r-1,c,grid);\\n        dfs(r,c+1,grid);\\n        dfs(r,c-1,grid);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n\\n        n=grid.size(),m=grid[0].size();\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 and grid[i][j]==1){\\n                    dfs(i,j,grid),islands++;\\n                }\\n                if(grid[i][j]==1) ones++;\\n            }\\n        }\\n\\n        if(islands!=1) return 0;\\n\\n        if(m==1 or n==1 or ones<=2) return ones==2 ? 2 : 1;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n               if(grid[i][j]==1){\\n                   int x=i,y=j;\\n                   grid[i][j]=0;\\n                   islands=0;\\n                   memset(vis,0,sizeof(vis));\\n                   for(int a=0;a<n;a++){\\n                       for(int b=0;b<m;b++){\\n                           if(vis[a][b]==0 and grid[a][b]==1){\\n                               dfs(a,b,grid),islands++;\\n                           }\\n                       }\\n                   }\\n\\n                   if(islands>1) return 1;\\n\\n                   grid[x][y]=1;\\n               }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578886,
                "title": "c-easy-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dx = {1, 0, -1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    int number_of_island(vector<vector<int>>&grid, int row, int col)\\n    {\\n        vector<vector<int>>vis(row, vector<int>(col, 0));\\n        int count = 0; //number of island\\n        queue<pair<int, int>>q;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j] == 0)\\n                {\\n                    vis[i][j] = 1;\\n                    q.push({i,j});\\n                    count++;\\n                    while(!q.empty())\\n                    {\\n                        int sz = q.size();\\n                        while(sz--)\\n                        {\\n                            auto curr = q.front(); q.pop();\\n                            int f = curr.first;\\n                            int s = curr.second;\\n                            for(int k=0;k<4;k++)\\n                            {\\n                                int u = f + dx[k];\\n                                int v = s + dy[k];\\n        if(u < row && u >= 0 && v < col && v >= 0  && grid[u][v] == 1 && vis[u][v] == 0 )\\n                                {\\n                                    q.push({u, v});\\n                                    vis[u][v] =1 ;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int count = number_of_island(grid, row, col); // initial number of island\\n        \\n        if (count > 1 or count == 0)  //already their are more than one island seperated or it is empty\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int islands = 0;\\n                if(grid[i][j]==1)\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0; // change land to water\\n                    \\n                    islands=number_of_island(grid,row,col);\\n                    if(islands!=1)\\n                        return 1; \\n                    \\n                    grid[i][j]=temp; // replace our changed water cell to land \\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dx = {1, 0, -1, 0};\\n    vector<int>dy = {0, 1, 0, -1};\\n    \\n    int number_of_island(vector<vector<int>>&grid, int row, int col)\\n    {\\n        vector<vector<int>>vis(row, vector<int>(col, 0));\\n        int count = 0; //number of island\\n        queue<pair<int, int>>q;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j] == 0)\\n                {\\n                    vis[i][j] = 1;\\n                    q.push({i,j});\\n                    count++;\\n                    while(!q.empty())\\n                    {\\n                        int sz = q.size();\\n                        while(sz--)\\n                        {\\n                            auto curr = q.front(); q.pop();\\n                            int f = curr.first;\\n                            int s = curr.second;\\n                            for(int k=0;k<4;k++)\\n                            {\\n                                int u = f + dx[k];\\n                                int v = s + dy[k];\\n        if(u < row && u >= 0 && v < col && v >= 0  && grid[u][v] == 1 && vis[u][v] == 0 )\\n                                {\\n                                    q.push({u, v});\\n                                    vis[u][v] =1 ;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int count = number_of_island(grid, row, col); // initial number of island\\n        \\n        if (count > 1 or count == 0)  //already their are more than one island seperated or it is empty\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                int islands = 0;\\n                if(grid[i][j]==1)\\n                {\\n                    int temp=grid[i][j];\\n                    grid[i][j]=0; // change land to water\\n                    \\n                    islands=number_of_island(grid,row,col);\\n                    if(islands!=1)\\n                        return 1; \\n                    \\n                    grid[i][j]=temp; // replace our changed water cell to land \\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533445,
                "title": "edge-case-sucks-targens-algo-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIf already more than 1 connected comp return 0;\\n\\nif(just 1 conn comp and that too of size 1) return 1;\\nif(no connected comp) return 0;\\n\\nif(any articulation point is found) return 1;\\n\\nelse return 2;\\n\\nWHy? let\\'see\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nin the remaining cases the answer is 2 , because you cannot traverse diagonally and by eliminating at max 2 land(1\\'s) you can make a land not reachable.\\n\\n1 1\\n1 1\\n\\nmake it \\n\\n0 1\\n1 0\\n\\n1 1 1   --->  1 0 1\\n1 1 1         1 1 0\\n1 1 1         1 1 1\\n\\nyou can always make it break into two with at most 2 moves.\\n\\n\\nnow the remaining lands are not reachable\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> low , disc ;\\n    vector<vector<bool>> arti;\\n    vector<vector<pair<int , int>>> par;\\n\\n    int n , m;\\n    int time;\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        n = grid.size() ;\\n        m = grid[0].size();\\n\\n        low.resize(n , vector<int> (m , -1));\\n        disc.resize(n , vector<int> (m , -1));\\n        par.resize(n , vector<pair<int , int>> (m , {-1 , -1}));\\n        arti.resize(n , vector<bool>(m , false));\\n      \\n        int flg_arti = 0;\\n\\n        int conn = 0 , cnt = 0;\\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 0 ; j < m ; j++) {\\n                if(grid[i][j] == 1 && disc[i][j] == -1) {\\n                    if(conn == 1) return 0;\\n                    conn++;\\n                    time = 0;\\n                    cnt += solve(i , j , grid);\\n                }\\n                if(arti[i][j]) {\\n                    flg_arti = 1;\\n                }\\n            }\\n        }\\n        if(cnt == 0) return 0;\\n        if(cnt == 1 || flg_arti) return 1;\\n        return 2;\\n\\n\\n    }\\n\\n    int dx[4] = {1 , -1 , 0 , 0};\\n    int dy[4] = {0 , 0 , -1 , 1};\\n\\n\\n    int solve(int rw , int col , vector<vector<int>> &grid) {\\n\\n        disc[rw][col] = low[rw][col] = time++;\\n        int child = 0;\\n        int cnt = 1;\\n       \\n        for(int i = 0 ; i < 4 ; i++) {\\n            int x = rw + dx[i];\\n            int y = col + dy[i];\\n\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 1) {\\n                \\n                if(disc[x][y] == -1) {\\n                    par[x][y] = {rw , col};\\n                    child += 1;\\n\\n                    cnt += solve(x , y , grid);\\n\\n                    low[rw][col] = min(low[rw][col] , low[x][y]);\\n\\n                    if(par[rw][col].first == -1 && par[rw][col].second == -1 && child >= 2) {\\n                        arti[rw][col] = true;\\n                    }\\n                    if(par[rw][col].first != -1 && par[rw][col].second != -1 && low[x][y] >= disc[rw][col]) {\\n                        arti[rw][col] = true;\\n                    } \\n                }\\n                else if(make_pair(x , y) != par[rw][col]) {\\n                    low[rw][col] = min(low[rw][col] , disc[x][y]);\\n                }\\n\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> low , disc ;\\n    vector<vector<bool>> arti;\\n    vector<vector<pair<int , int>>> par;\\n\\n    int n , m;\\n    int time;\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        n = grid.size() ;\\n        m = grid[0].size();\\n\\n        low.resize(n , vector<int> (m , -1));\\n        disc.resize(n , vector<int> (m , -1));\\n        par.resize(n , vector<pair<int , int>> (m , {-1 , -1}));\\n        arti.resize(n , vector<bool>(m , false));\\n      \\n        int flg_arti = 0;\\n\\n        int conn = 0 , cnt = 0;\\n        for(int i = 0 ; i < n ; i++) {\\n            for(int j = 0 ; j < m ; j++) {\\n                if(grid[i][j] == 1 && disc[i][j] == -1) {\\n                    if(conn == 1) return 0;\\n                    conn++;\\n                    time = 0;\\n                    cnt += solve(i , j , grid);\\n                }\\n                if(arti[i][j]) {\\n                    flg_arti = 1;\\n                }\\n            }\\n        }\\n        if(cnt == 0) return 0;\\n        if(cnt == 1 || flg_arti) return 1;\\n        return 2;\\n\\n\\n    }\\n\\n    int dx[4] = {1 , -1 , 0 , 0};\\n    int dy[4] = {0 , 0 , -1 , 1};\\n\\n\\n    int solve(int rw , int col , vector<vector<int>> &grid) {\\n\\n        disc[rw][col] = low[rw][col] = time++;\\n        int child = 0;\\n        int cnt = 1;\\n       \\n        for(int i = 0 ; i < 4 ; i++) {\\n            int x = rw + dx[i];\\n            int y = col + dy[i];\\n\\n            if(x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 1) {\\n                \\n                if(disc[x][y] == -1) {\\n                    par[x][y] = {rw , col};\\n                    child += 1;\\n\\n                    cnt += solve(x , y , grid);\\n\\n                    low[rw][col] = min(low[rw][col] , low[x][y]);\\n\\n                    if(par[rw][col].first == -1 && par[rw][col].second == -1 && child >= 2) {\\n                        arti[rw][col] = true;\\n                    }\\n                    if(par[rw][col].first != -1 && par[rw][col].second != -1 && low[x][y] >= disc[rw][col]) {\\n                        arti[rw][col] = true;\\n                    } \\n                }\\n                else if(make_pair(x , y) != par[rw][col]) {\\n                    low[rw][col] = min(low[rw][col] , disc[x][y]);\\n                }\\n\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465948,
                "title": "minimum-number-of-days-to-disconnect-island",
                "content": "Time Complexity : O((N * M)2) Where\\n\\n Space Complexity: O(N * M)\\n\\n# Code\\n```\\nclass Solution {\\n    private int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private void dfs(int[][] grid, boolean[][] visited, int row, int col) {\\n        if(visited[row][col]) return;\\n\\n        visited[row][col] = true;\\n        for(int[] dir: dirs) {\\n            int rowNew = row + dir[0];\\n            int colNew = col + dir[1];\\n            if(rowNew >= 0 && rowNew < grid.length && colNew >= 0 && colNew < grid[0].length && grid[rowNew][colNew] == 1) {\\n                dfs(grid, visited, rowNew, colNew);\\n            }\\n        }\\n    }\\n    private int islandCount(int[][] grid) {\\n        int count = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1 && !visited[i][j]) {\\n                    dfs(grid, visited, i, j);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n \\n    public int minDays(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n\\n        if(islandCount(grid) != 1) return 0;\\n\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    if(islandCount(grid) != 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    private void dfs(int[][] grid, boolean[][] visited, int row, int col) {\\n        if(visited[row][col]) return;\\n\\n        visited[row][col] = true;\\n        for(int[] dir: dirs) {\\n            int rowNew = row + dir[0];\\n            int colNew = col + dir[1];\\n            if(rowNew >= 0 && rowNew < grid.length && colNew >= 0 && colNew < grid[0].length && grid[rowNew][colNew] == 1) {\\n                dfs(grid, visited, rowNew, colNew);\\n            }\\n        }\\n    }\\n    private int islandCount(int[][] grid) {\\n        int count = 0;\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1 && !visited[i][j]) {\\n                    dfs(grid, visited, i, j);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n \\n    public int minDays(int[][] grid) {\\n        if(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n\\n        if(islandCount(grid) != 1) return 0;\\n\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    if(islandCount(grid) != 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465553,
                "title": "not-an-optimized-approach-but-good-to-know-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n\\n        def numIslands(grid):\\n            ans=0\\n            n=len(grid)\\n            m=len(grid[0])\\n            def dfs(i,j,visited):\\n                if (i,j) in visited:\\n                    return\\n                if grid[i][j]==0:\\n                    visited.add((i,j))\\n                    return\\n                visited.add((i,j))\\n                A=[(-1,0),(1,0),(0,-1),(0,1)]\\n                for dx,dy in A:\\n                    if 0<=i+dx<=n-1 and 0<=j+dy<=m-1 and grid[i+dx][j+dy]==1:\\n                        dfs(i+dx,j+dy,visited)\\n            visited=set()\\n            for i in range(n):\\n                for j in range(m):\\n                    if grid[i][j]==1 and (i,j) not in visited:\\n                        dfs(i,j,visited)\\n                        ans+=1\\n            return ans\\n        \\n        if numIslands(grid)!=1:\\n            return 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    grid[i][j]=0\\n                    \\n                    if numIslands(grid)!=1:\\n                        return 1\\n                    else:\\n                        grid[i][j]=1\\n        return 2\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n\\n        def numIslands(grid):\\n            ans=0\\n            n=len(grid)\\n            m=len(grid[0])\\n            def dfs(i,j,visited):\\n                if (i,j) in visited:\\n                    return\\n                if grid[i][j]==0:\\n                    visited.add((i,j))\\n                    return\\n                visited.add((i,j))\\n                A=[(-1,0),(1,0),(0,-1),(0,1)]\\n                for dx,dy in A:\\n                    if 0<=i+dx<=n-1 and 0<=j+dy<=m-1 and grid[i+dx][j+dy]==1:\\n                        dfs(i+dx,j+dy,visited)\\n            visited=set()\\n            for i in range(n):\\n                for j in range(m):\\n                    if grid[i][j]==1 and (i,j) not in visited:\\n                        dfs(i,j,visited)\\n                        ans+=1\\n            return ans\\n        \\n        if numIslands(grid)!=1:\\n            return 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==1:\\n                    grid[i][j]=0\\n                    \\n                    if numIslands(grid)!=1:\\n                        return 1\\n                    else:\\n                        grid[i][j]=1\\n        return 2\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445107,
                "title": "java-solution-articulation-point-dfs",
                "content": "```\\nclass Solution {\\n    int [][] disc;\\n    int [][] sat;\\n    int [][] parent;\\n    boolean [][] vis;\\n    int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n    int time=0;\\n    public int DFSSIZE(int [][] grid,int i ,int j ,boolean [][] vis){\\n        vis[i][j]=true;\\n        int count=0;\\n        for(int [] arr:dir){\\n            int r=arr[0]+i;\\n            int c=arr[1]+j;\\n            \\n            if(r>=0 && c>=0 && r<grid.length && c<grid[0].length && grid[r][c]==1 && !vis[r][c]){\\n                count+=DFSSIZE(grid,r,c,vis);\\n            }\\n        }\\n        return count+1;\\n    }\\n    \\n    public boolean AP(int [][] grid,int srcr,int srcc,int [][] parent){\\n        disc[srcr][srcc]=sat[srcr][srcc]=++time;\\n        int child=0;\\n        boolean res=false;\\n        for(int [] arr:dir){\\n            int nbrx=arr[0]+srcr;\\n            int nbry=arr[1]+srcc;\\n            int m=grid[0].length;\\n        \\n            if(nbrx>=0 && nbry>=0 && nbrx<grid.length && nbry<grid[0].length && grid[nbrx][nbry]==1){\\n                // System.out.println(nbrx+\" \"+nbry);\\n                if(vis[nbrx][nbry] && parent[srcr][srcc]==(nbrx*m)+nbry){\\n                   \\n                    continue;\\n                }\\n                else if(vis[nbrx][nbry]){\\n                    \\n                    sat[srcr][srcc]=Math.min(sat[srcr][srcc],disc[nbrx][nbry]);\\n                }\\n                else{\\n                    vis[nbrx][nbry]=true;\\n                    parent[nbrx][nbry]=(srcr*m)+srcc;\\n                    child++;\\n                    res=res || AP(grid,nbrx,nbry,parent);\\n                    \\n                    sat[srcr][srcc]=Math.min(sat[srcr][srcc],sat[nbrx][nbry]);\\n                    \\n                    if(parent[srcr][srcc]==-1){\\n                        if(child>=2){\\n                            return true;\\n                        }\\n                    }\\n                    else{\\n                        if(disc[srcr][srcc]<=sat[nbrx][nbry]){\\n                            return true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res; \\n    }\\n    public int minDays(int[][] grid) {\\n        int size=0;\\n        int noofComponents=0;\\n        int n =grid.length;\\n        int m =grid[0].length;\\n        parent=new int[n][m];\\n        sat=new int[n][m];\\n        disc=new int[n][m];\\n        vis=new boolean[n][m];\\n        int rootx=0;\\n        int rooty=0;\\n        boolean res=false;\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]==1){\\n                    rootx=i;\\n                    rooty=j;\\n                    size+=DFSSIZE(grid,i,j,vis);\\n                   noofComponents++; \\n                }\\n            }\\n        }\\n        vis=new boolean [n][m];\\n        if(noofComponents==0 || noofComponents>1){\\n            return 0;\\n        }\\n        else {\\n            if(size==1 || size==2){\\n                return size;\\n            }\\n            else{\\n                parent[rootx][rooty]=-1;\\n               vis[rootx][rooty]=true;\\n               res=AP(grid,rootx,rooty,parent); \\n             \\n                if(res){\\n                    return 1;\\n                }\\n                else{\\n                    return 2;\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int [][] disc;\\n    int [][] sat;\\n    int [][] parent;\\n    boolean [][] vis;\\n    int[][] dir = { { 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 } };\\n    int time=0;\\n    public int DFSSIZE(int [][] grid,int i ,int j ,boolean [][] vis){\\n        vis[i][j]=true;\\n        int count=0;\\n        for(int [] arr:dir){\\n            int r=arr[0]+i;\\n            int c=arr[1]+j;\\n            \\n            if(r>=0 && c>=0 && r<grid.length && c<grid[0].length && grid[r][c]==1 && !vis[r][c]){\\n                count+=DFSSIZE(grid,r,c,vis);\\n            }\\n        }\\n        return count+1;\\n    }\\n    \\n    public boolean AP(int [][] grid,int srcr,int srcc,int [][] parent){\\n        disc[srcr][srcc]=sat[srcr][srcc]=++time;\\n        int child=0;\\n        boolean res=false;\\n        for(int [] arr:dir){\\n            int nbrx=arr[0]+srcr;\\n            int nbry=arr[1]+srcc;\\n            int m=grid[0].length;\\n        \\n            if(nbrx>=0 && nbry>=0 && nbrx<grid.length && nbry<grid[0].length && grid[nbrx][nbry]==1){\\n                // System.out.println(nbrx+\" \"+nbry);\\n                if(vis[nbrx][nbry] && parent[srcr][srcc]==(nbrx*m)+nbry){\\n                   \\n                    continue;\\n                }\\n                else if(vis[nbrx][nbry]){\\n                    \\n                    sat[srcr][srcc]=Math.min(sat[srcr][srcc],disc[nbrx][nbry]);\\n                }\\n                else{\\n                    vis[nbrx][nbry]=true;\\n                    parent[nbrx][nbry]=(srcr*m)+srcc;\\n                    child++;\\n                    res=res || AP(grid,nbrx,nbry,parent);\\n                    \\n                    sat[srcr][srcc]=Math.min(sat[srcr][srcc],sat[nbrx][nbry]);\\n                    \\n                    if(parent[srcr][srcc]==-1){\\n                        if(child>=2){\\n                            return true;\\n                        }\\n                    }\\n                    else{\\n                        if(disc[srcr][srcc]<=sat[nbrx][nbry]){\\n                            return true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res; \\n    }\\n    public int minDays(int[][] grid) {\\n        int size=0;\\n        int noofComponents=0;\\n        int n =grid.length;\\n        int m =grid[0].length;\\n        parent=new int[n][m];\\n        sat=new int[n][m];\\n        disc=new int[n][m];\\n        vis=new boolean[n][m];\\n        int rootx=0;\\n        int rooty=0;\\n        boolean res=false;\\n        for(int i =0;i<n;i++){\\n            for(int j =0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]==1){\\n                    rootx=i;\\n                    rooty=j;\\n                    size+=DFSSIZE(grid,i,j,vis);\\n                   noofComponents++; \\n                }\\n            }\\n        }\\n        vis=new boolean [n][m];\\n        if(noofComponents==0 || noofComponents>1){\\n            return 0;\\n        }\\n        else {\\n            if(size==1 || size==2){\\n                return size;\\n            }\\n            else{\\n                parent[rootx][rooty]=-1;\\n               vis[rootx][rooty]=true;\\n               res=AP(grid,rootx,rooty,parent); \\n             \\n                if(res){\\n                    return 1;\\n                }\\n                else{\\n                    return 2;\\n                }\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363658,
                "title": "max-2-days-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        num_1s = abs(sum(sum(row) for row in grid))\\n\\n        @cache\\n        def get_rc():\\n            for r in range(m):\\n                for c in range(n):\\n                    if grid[r][c]:\\n                        yield r, c\\n\\n        # mul = 1\\n        # def set_dist(r, c, dist):\\n        #     if r < 0 or r>= m or c < 0 or c >= n:\\n        #         return\\n        #     if grid[r][c] != 1 and grid[r][c] <= dist:\\n        #         return\\n        #     grid[r][c] = dist\\n            \\n        #     set_dist(r-1, c, dist + 1)\\n        #     set_dist(r+1, c, dist + 1)\\n        #     set_dist(r, c-1, dist + 1)\\n        #     set_dist(r, c+1, dist + 1)\\n        \\n        island = 1\\n        def is_connected():\\n            nonlocal island\\n            def count(r, c):\\n                if r < 0 or r>= m or c < 0 or c >= n: return 0\\n                if grid[r][c] != island: return 0\\n                grid[r][c] = -island\\n                total = 1\\n                total += count(r-1, c)\\n                total += count(r+1, c)\\n                total += count(r, c-1)\\n                total += count(r, c+1)\\n                return total\\n            r, c = first_rc\\n            if not grid[r][c]:\\n                r, c = second_rc\\n            conn = count(r, c)\\n            island = -island\\n            return conn == num_1s\\n\\n        if num_1s == 0:\\n            return 0\\n        elif num_1s == 1:\\n            return 1\\n        \\n        \\n        g = get_rc()\\n        first_rc = next(g)\\n        second_rc = next(g)\\n\\n        if not is_connected():\\n            return 0\\n        elif num_1s == 2:\\n            return 2\\n        \\n\\n        # skip = True\\n        num_1s -= 1\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0:\\n                    continue\\n                # if skip:\\n                #     skip = False\\n                #     continue\\n                grid[r][c] = 0\\n                if not is_connected():\\n                    # print(f\"Choke at {r}, {c}\")\\n                    return 1\\n                grid[r][c] = island\\n                \\n                \\n        return 2\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        num_1s = abs(sum(sum(row) for row in grid))\\n\\n        @cache\\n        def get_rc():\\n            for r in range(m):\\n                for c in range(n):\\n                    if grid[r][c]:\\n                        yield r, c\\n\\n        # mul = 1\\n        # def set_dist(r, c, dist):\\n        #     if r < 0 or r>= m or c < 0 or c >= n:\\n        #         return\\n        #     if grid[r][c] != 1 and grid[r][c] <= dist:\\n        #         return\\n        #     grid[r][c] = dist\\n            \\n        #     set_dist(r-1, c, dist + 1)\\n        #     set_dist(r+1, c, dist + 1)\\n        #     set_dist(r, c-1, dist + 1)\\n        #     set_dist(r, c+1, dist + 1)\\n        \\n        island = 1\\n        def is_connected():\\n            nonlocal island\\n            def count(r, c):\\n                if r < 0 or r>= m or c < 0 or c >= n: return 0\\n                if grid[r][c] != island: return 0\\n                grid[r][c] = -island\\n                total = 1\\n                total += count(r-1, c)\\n                total += count(r+1, c)\\n                total += count(r, c-1)\\n                total += count(r, c+1)\\n                return total\\n            r, c = first_rc\\n            if not grid[r][c]:\\n                r, c = second_rc\\n            conn = count(r, c)\\n            island = -island\\n            return conn == num_1s\\n\\n        if num_1s == 0:\\n            return 0\\n        elif num_1s == 1:\\n            return 1\\n        \\n        \\n        g = get_rc()\\n        first_rc = next(g)\\n        second_rc = next(g)\\n\\n        if not is_connected():\\n            return 0\\n        elif num_1s == 2:\\n            return 2\\n        \\n\\n        # skip = True\\n        num_1s -= 1\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0:\\n                    continue\\n                # if skip:\\n                #     skip = False\\n                #     continue\\n                grid[r][c] = 0\\n                if not is_connected():\\n                    # print(f\"Choke at {r}, {c}\")\\n                    return 1\\n                grid[r][c] = island\\n                \\n                \\n        return 2\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337239,
                "title": "articulation-point-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean[] vis;\\n    int[] dis;\\n    int[] low;\\n    public int minDays(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        int zerosum=0;\\n        int onesum=0;\\n        //find all no land ans water\\n        for(int[] g : grid){\\n            for(int val : g){\\n                if(val==1)\\n                onesum++;\\n                else\\n                zerosum++;\\n            }\\n        }\\n       //if no land\\n        if(zerosum==(n*m))\\n        return 0;\\n        //if 1 island\\n        if(onesum==1)\\n        return 1;\\n        //if only land then any corner can be made 2nd component my removing 2 land adj to corner\\n        if(onesum==(n*m))\\n        return 2;\\n\\n        vis=new boolean[n*m];\\n        low=new int[n*m];\\n        dis=new int[n*m];\\n        int len=0;\\n        int root=-1;\\n        //first land mass\\n        for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            if(grid[i][j]==1){\\n                root=i*m+j;\\n                break;\\n            }\\n        }\\n        if(root!=-1)\\n        break;\\n        }\\n       //articulation point \\n        boolean ans=arti(root,-1,grid,len,n,m);\\n\\n        // vis will not be true on all1s if their are already multiple components\\n        for(int i=0;i<(n*m);i++)\\n        if(grid[i/m][i%m]==1 && vis[i]==false){\\n          return 0;\\n        }\\n        // if true their is point and we need to remove only that\\n        //or else remove 2 lands masses to make component\\n        return ans?1:2;\\n    }\\n    boolean arti(int root,int par,int[][] grid,int len,int n,int m){\\n        // root col and row\\n        int sr=root/m;\\n        int sc=root%m;\\n\\n        vis[root]=true;\\n        dis[root]=low[root]=len++;\\n        boolean res=false;\\n        //no of components/islands\\n        int com=0;\\n        // array for traversing in 4 directions\\n        int[][] dir={{ 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 }};\\n        for(int[] d: dir){\\n            int r=sr+d[0];\\n            int c=sc+d[1];\\n            int child=r*m+c;\\n            //if thier is land in child coordinates\\n            if(r>=0 && r<n && c>=0 && c<m && grid[r][c]==1){\\n                //logic of articulation point refer youtube video\\n                // consider love babber code help placement series lecture 99\\n                if(!vis[child]){\\n                    com++;\\n                    res=arti(child,root,grid,len,n,m)||res;\\n                    low[root]=Math.min(low[root],low[child]);\\n                    \\n                    if(low[child]>=dis[root] && par!=-1){\\n                       \\n                     res=true;\\n                    }\\n                    \\n                }\\n                if(child!=par){\\n                    low[root]=Math.min(low[root],low[child]);\\n                }\\n                \\n               \\n            }\\n        }\\n        if(par==-1 && com>1)\\n        return true;\\n       \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    boolean[] vis;\\n    int[] dis;\\n    int[] low;\\n    public int minDays(int[][] grid) {\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        int zerosum=0;\\n        int onesum=0;\\n        //find all no land ans water\\n        for(int[] g : grid){\\n            for(int val : g){\\n                if(val==1)\\n                onesum++;\\n                else\\n                zerosum++;\\n            }\\n        }\\n       //if no land\\n        if(zerosum==(n*m))\\n        return 0;\\n        //if 1 island\\n        if(onesum==1)\\n        return 1;\\n        //if only land then any corner can be made 2nd component my removing 2 land adj to corner\\n        if(onesum==(n*m))\\n        return 2;\\n\\n        vis=new boolean[n*m];\\n        low=new int[n*m];\\n        dis=new int[n*m];\\n        int len=0;\\n        int root=-1;\\n        //first land mass\\n        for(int i=0;i<n;i++){\\n        for(int j=0;j<m;j++){\\n            if(grid[i][j]==1){\\n                root=i*m+j;\\n                break;\\n            }\\n        }\\n        if(root!=-1)\\n        break;\\n        }\\n       //articulation point \\n        boolean ans=arti(root,-1,grid,len,n,m);\\n\\n        // vis will not be true on all1s if their are already multiple components\\n        for(int i=0;i<(n*m);i++)\\n        if(grid[i/m][i%m]==1 && vis[i]==false){\\n          return 0;\\n        }\\n        // if true their is point and we need to remove only that\\n        //or else remove 2 lands masses to make component\\n        return ans?1:2;\\n    }\\n    boolean arti(int root,int par,int[][] grid,int len,int n,int m){\\n        // root col and row\\n        int sr=root/m;\\n        int sc=root%m;\\n\\n        vis[root]=true;\\n        dis[root]=low[root]=len++;\\n        boolean res=false;\\n        //no of components/islands\\n        int com=0;\\n        // array for traversing in 4 directions\\n        int[][] dir={{ 1, 0 }, { -1, 0 }, { 0, -1 }, { 0, 1 }};\\n        for(int[] d: dir){\\n            int r=sr+d[0];\\n            int c=sc+d[1];\\n            int child=r*m+c;\\n            //if thier is land in child coordinates\\n            if(r>=0 && r<n && c>=0 && c<m && grid[r][c]==1){\\n                //logic of articulation point refer youtube video\\n                // consider love babber code help placement series lecture 99\\n                if(!vis[child]){\\n                    com++;\\n                    res=arti(child,root,grid,len,n,m)||res;\\n                    low[root]=Math.min(low[root],low[child]);\\n                    \\n                    if(low[child]>=dis[root] && par!=-1){\\n                       \\n                     res=true;\\n                    }\\n                    \\n                }\\n                if(child!=par){\\n                    low[root]=Math.min(low[root],low[child]);\\n                }\\n                \\n               \\n            }\\n        }\\n        if(par==-1 && com>1)\\n        return true;\\n       \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328078,
                "title": "try-deleting-any-land-tile",
                "content": "# Complexity\\n- Time complexity:\\n$$O(m^2 n^2)$$\\n\\n- Space complexity:\\n$$O(m n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        int m = grid.Length, n = grid[0].Length;\\n\\n        bool isLand(int x, int y)\\n        {\\n            if(x < 0 || x >= m || y < 0 || y >= n || (grid[x][y] != 1))\\n                return false;\\n            return true;\\n        }\\n        bool isConnected()\\n        {\\n            bool[,] visited = new bool[m, n];\\n            bool visit(int x, int y)\\n            {\\n                if((!isLand(x, y)) || visited[x, y])\\n                    return false;\\n                visited[x, y] = true;\\n                visit(x - 1, y);\\n                visit(x + 1, y);\\n                visit(x, y - 1);\\n                visit(x, y + 1);\\n                return true;\\n            }\\n            int visitedCnt = 0;\\n            for(int i = 0; i < m; i++)\\n                for(int j = 0; j < n; j++)\\n                    visitedCnt += visit(i, j)?1:0;            \\n            return visitedCnt == 1;\\n        }\\n\\n        //already disconnected\\n        if(!isConnected())\\n            return 0;\\n        \\n        //one single operation required: try deleting any land tile\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(isLand(i, j))\\n                {\\n                    grid[i][j] = 0;\\n                    if(!isConnected())\\n                        return 1;\\n                    grid[i][j] = 1;\\n                }\\n\\n        //all other cases:\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        int m = grid.Length, n = grid[0].Length;\\n\\n        bool isLand(int x, int y)\\n        {\\n            if(x < 0 || x >= m || y < 0 || y >= n || (grid[x][y] != 1))\\n                return false;\\n            return true;\\n        }\\n        bool isConnected()\\n        {\\n            bool[,] visited = new bool[m, n];\\n            bool visit(int x, int y)\\n            {\\n                if((!isLand(x, y)) || visited[x, y])\\n                    return false;\\n                visited[x, y] = true;\\n                visit(x - 1, y);\\n                visit(x + 1, y);\\n                visit(x, y - 1);\\n                visit(x, y + 1);\\n                return true;\\n            }\\n            int visitedCnt = 0;\\n            for(int i = 0; i < m; i++)\\n                for(int j = 0; j < n; j++)\\n                    visitedCnt += visit(i, j)?1:0;            \\n            return visitedCnt == 1;\\n        }\\n\\n        //already disconnected\\n        if(!isConnected())\\n            return 0;\\n        \\n        //one single operation required: try deleting any land tile\\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(isLand(i, j))\\n                {\\n                    grid[i][j] = 0;\\n                    if(!isConnected())\\n                        return 1;\\n                    grid[i][j] = 1;\\n                }\\n\\n        //all other cases:\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325845,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int i,int j,int n,int m,vector<vector<int>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=n || j>=m || arr[i][j]==0 || visited[i][j]==true){\\n            return;\\n        }\\n        visited[i][j]=true;\\n        helper(i+1,j,n,m,arr,visited);\\n        helper(i,j-1,n,m,arr,visited);\\n        helper(i-1,j,n,m,arr,visited);\\n        helper(i,j+1,n,m,arr,visited);\\n        \\n    }\\n    int numislands(int n,int m,vector<vector<int>>&arr){\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(arr[i][j]==1 && visited[i][j]!=true){\\n                    helper(i,j,n,m,arr,visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int ans=numislands(n,m,grid);\\n        if(ans>1 || ans==0){\\n            return 0;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                if(grid[i][j]==1){\\n                    grid[i][j]=0;\\n                    int num=numislands(n,m,grid);\\n                    if(num>1 || num==0){\\n                        return 1;\\n                    }\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void helper(int i,int j,int n,int m,vector<vector<int>>&arr,vector<vector<bool>>&visited){\\n        \\n        if(i<0 || j<0 || i>=n || j>=m || arr[i][j]==0 || visited[i][j]==true){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3171061,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_days(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut grid = grid;\\n        let mut islands = Self::count_islands(&grid);\\n        let (n, m) = (grid.len(), grid[0].len());\\n        if islands > 1 || islands == 0 {\\n            return 0;\\n        } else {\\n            for i in 0..n {\\n                for j in 0..m {\\n                    if grid[i][j] == 1 {\\n                        grid[i][j] = 0;\\n                        islands = Self::count_islands(&grid);\\n                        grid[i][j] = 1;\\n                        if islands > 1 || islands == 0 {\\n                            return 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        2\\n    }\\n\\n    fn dfs(x: usize, y: usize, grid: &Vec<Vec<i32>>, vis: &mut Vec<Vec<i32>>) {\\n        let dx = vec![1, -1, 0, 0];\\n        let dy = vec![0, 0, 1, -1];\\n        let (n, m) = (grid.len(), grid[0].len());\\n        vis[x][y] = 1;\\n        for a in 0..4 {\\n            let nx = x as i32 + dx[a];\\n            let ny = y as i32 + dy[a];\\n            if nx >= 0\\n                && ny >= 0\\n                && nx < n as i32\\n                && ny < m as i32\\n                && vis[nx as usize][ny as usize] == 0\\n                && grid[nx as usize][ny as usize] == 1\\n            {\\n                Self::dfs(nx as usize, ny as usize, grid, vis);\\n            }\\n        }\\n    }\\n\\n    fn count_islands(grid: &Vec<Vec<i32>>) -> i32 {\\n        let mut islands = 0;\\n        let (n, m) = (grid.len(), grid[0].len());\\n        let mut vis = vec![vec![0; m]; n];\\n        for i in 0..n {\\n            for j in 0..m {\\n                if vis[i][j] == 0 && grid[i][j] == 1 {\\n                    Self::dfs(i, j, grid, &mut vis);\\n                    islands += 1;\\n                }\\n            }\\n        }\\n        islands\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_days(grid: Vec<Vec<i32>>) -> i32 {\\n        let mut grid = grid;\\n        let mut islands = Self::count_islands(&grid);\\n        let (n, m) = (grid.len(), grid[0].len());\\n        if islands > 1 || islands == 0 {\\n            return 0;\\n        } else {\\n            for i in 0..n {\\n                for j in 0..m {\\n                    if grid[i][j] == 1 {\\n                        grid[i][j] = 0;\\n                        islands = Self::count_islands(&grid);\\n                        grid[i][j] = 1;\\n                        if islands > 1 || islands == 0 {\\n                            return 1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        2\\n    }\\n\\n    fn dfs(x: usize, y: usize, grid: &Vec<Vec<i32>>, vis: &mut Vec<Vec<i32>>) {\\n        let dx = vec![1, -1, 0, 0];\\n        let dy = vec![0, 0, 1, -1];\\n        let (n, m) = (grid.len(), grid[0].len());\\n        vis[x][y] = 1;\\n        for a in 0..4 {\\n            let nx = x as i32 + dx[a];\\n            let ny = y as i32 + dy[a];\\n            if nx >= 0\\n                && ny >= 0\\n                && nx < n as i32\\n                && ny < m as i32\\n                && vis[nx as usize][ny as usize] == 0\\n                && grid[nx as usize][ny as usize] == 1\\n            {\\n                Self::dfs(nx as usize, ny as usize, grid, vis);\\n            }\\n        }\\n    }\\n\\n    fn count_islands(grid: &Vec<Vec<i32>>) -> i32 {\\n        let mut islands = 0;\\n        let (n, m) = (grid.len(), grid[0].len());\\n        let mut vis = vec![vec![0; m]; n];\\n        for i in 0..n {\\n            for j in 0..m {\\n                if vis[i][j] == 0 && grid[i][j] == 1 {\\n                    Self::dfs(i, j, grid, &mut vis);\\n                    islands += 1;\\n                }\\n            }\\n        }\\n        islands\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152047,
                "title": "simple-dfs-solution-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will check if we have not 1 island then return 0 , else we will try to make every 1 cell 0 then check if we have more than 1 islands if we have then we return 1 else in end we return 2 .\\n# Complexity\\n- Time complexity: O(N^4)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(vector<vector<bool>>& vis, int i, int j, vector<vector<int>>& g){\\n        if(i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || !g[i][j] || vis[i][j]) return 0;\\n        vis[i][j] = 1;\\n        return 1 + dfs(vis,i+1,j, g) + dfs(vis,i,j+1, g) + dfs(vis,i-1,j, g) + dfs(vis,i,j-1, g);\\n    }\\n\\n    int icnt(vector<vector<int>>& g){\\n        int ino = 0;\\n        vector<vector<bool>> vis(g.size(),vector<bool>(g[0].size(),0));\\n        for(int i=0;i<g.size();i++){\\n            for(int j=0;j<g[0].size();j++){\\n                if(g[i][j] && !vis[i][j]){\\n                    dfs(vis,i,j,g);\\n                    ino++;\\n                }\\n            }\\n        }\\n        return ino;\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int noi = 0, size = 0;\\n        vector<vector<bool>> vis(m,vector<bool>(n,0));\\n        int x = 0, y = 0;\\n        // first we count number of islands\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] && !vis[i][j]){\\n                    size = dfs(vis,i,j,grid);\\n                    x = i, y = j;\\n                    noi++;\\n                }\\n                if(noi > 1) return 0;\\n            }\\n        }\\n        if(noi == 0) return 0;\\n        // now we will try to flip every one and check if doing this will make 2 island\\n        if(size < 3) return size;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = 0;\\n                    // Now do icnt\\n                    if(icnt(grid) >= 2) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(vector<vector<bool>>& vis, int i, int j, vector<vector<int>>& g){\\n        if(i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || !g[i][j] || vis[i][j]) return 0;\\n        vis[i][j] = 1;\\n        return 1 + dfs(vis,i+1,j, g) + dfs(vis,i,j+1, g) + dfs(vis,i-1,j, g) + dfs(vis,i,j-1, g);\\n    }\\n\\n    int icnt(vector<vector<int>>& g){\\n        int ino = 0;\\n        vector<vector<bool>> vis(g.size(),vector<bool>(g[0].size(),0));\\n        for(int i=0;i<g.size();i++){\\n            for(int j=0;j<g[0].size();j++){\\n                if(g[i][j] && !vis[i][j]){\\n                    dfs(vis,i,j,g);\\n                    ino++;\\n                }\\n            }\\n        }\\n        return ino;\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int noi = 0, size = 0;\\n        vector<vector<bool>> vis(m,vector<bool>(n,0));\\n        int x = 0, y = 0;\\n        // first we count number of islands\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] && !vis[i][j]){\\n                    size = dfs(vis,i,j,grid);\\n                    x = i, y = j;\\n                    noi++;\\n                }\\n                if(noi > 1) return 0;\\n            }\\n        }\\n        if(noi == 0) return 0;\\n        // now we will try to flip every one and check if doing this will make 2 island\\n        if(size < 3) return size;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    grid[i][j] = 0;\\n                    // Now do icnt\\n                    if(icnt(grid) >= 2) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094296,
                "title": "boring-brute-force-approach-dfs",
                "content": "```\\nimport random\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def dfs(i, j, visited):\\n            visited.add((i,j))\\n            for x, y in get_neis(i, j):\\n                if is_valid(x, y) and (x,y) not in visited and grid[x][y] == 1:\\n                    dfs(x, y, visited)\\n        \\n        islands = []\\n        seen = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if (i,j) not in seen and grid[i][j] == 1:\\n                    visited = set()\\n                    dfs(i, j, visited)\\n                    islands.append(visited)\\n                    seen.update(visited)\\n\\n        if len(islands) > 1 or len(islands) == 0:\\n            return 0\\n        \\n        island_indices = islands[0]\\n        if len(island_indices) == 1:\\n            return 1\\n\\n        island_copy = copy.copy(island_indices)\\n        for index in island_indices:\\n            i, j = index\\n            island_copy.remove(index)\\n            grid[i][j] = 0\\n            visited = set()\\n            x, y = random.choice(list(island_copy))\\n            dfs(x, y, visited)\\n            if len(visited) != len(island_copy):\\n                return 1\\n\\n            island_copy.add(index)\\n            grid[i][j] = 1\\n\\n        return 2\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nimport random\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n        \\n        def dfs(i, j, visited):\\n            visited.add((i,j))\\n            for x, y in get_neis(i, j):\\n                if is_valid(x, y) and (x,y) not in visited and grid[x][y] == 1:\\n                    dfs(x, y, visited)\\n        \\n        islands = []\\n        seen = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if (i,j) not in seen and grid[i][j] == 1:\\n                    visited = set()\\n                    dfs(i, j, visited)\\n                    islands.append(visited)\\n                    seen.update(visited)\\n\\n        if len(islands) > 1 or len(islands) == 0:\\n            return 0\\n        \\n        island_indices = islands[0]\\n        if len(island_indices) == 1:\\n            return 1\\n\\n        island_copy = copy.copy(island_indices)\\n        for index in island_indices:\\n            i, j = index\\n            island_copy.remove(index)\\n            grid[i][j] = 0\\n            visited = set()\\n            x, y = random.choice(list(island_copy))\\n            dfs(x, y, visited)\\n            if len(visited) != len(island_copy):\\n                return 1\\n\\n            island_copy.add(index)\\n            grid[i][j] = 1\\n\\n        return 2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045234,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\nprivate:\\n    int m, n;\\n    int ts;\\n    vector<vector<int>> dfn, low;\\n    bool cut;\\n    int rx, ry;\\n\\n    void dfs(int x, int y, const vector<vector<int>> &grid) {\\n        const int dx[4] = {0, 1, 0, -1};\\n        const int dy[4] = {1, 0, -1 ,0};\\n\\n        dfn[x][y] = low[x][y] = ++ts;\\n        int branch = 0;\\n        for (int i = 0; i < 4; i++) {\\n            int tx = x + dx[i], ty = y + dy[i];\\n            if (tx < 0 || tx >= m || ty < 0 || ty >= n || grid[tx][ty] == 0)\\n                continue;\\n\\n            if (dfn[tx][ty] != 0) {\\n                low[x][y] = min(low[x][y], dfn[tx][ty]);\\n                continue;\\n            }\\n\\n            dfs(tx, ty, grid);\\n\\n            branch++;\\n            low[x][y] = min(low[x][y], low[tx][ty]);\\n\\n            if (low[tx][ty] >= dfn[x][y]) {\\n                if (branch >= 2 || !(x == rx && y == ry))\\n                    cut = true;\\n            }\\n        }\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        dfn.resize(m, vector<int>(n, 0));\\n        low.resize(m, vector<int>(n, 0));\\n        ts = 0;\\n        cut = false;\\n\\n        bool first = false;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (grid[i][j] == 1 && dfn[i][j] == 0) {\\n                    if (first) return 0;\\n                    first = true;\\n                    rx = i; ry = j;\\n                    dfs(i, j, grid);\\n                }\\n\\n        if (!first) return 0;\\n        if (ts == 1 || cut) return 1;\\n        return 2;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        articulationPoint, time, numRows, numCols = False, 0, len(grid), len(grid[0])\\n        directions, lands, islands = [[1, 0], [-1, 0], [0, 1], [0, -1]], 0, 0\\n        depth = [[-1] * numCols for _ in range(numRows)]\\n        low = [[-1] * numCols for _ in range(numRows)]\\n        parent = [[-1] * numCols for _ in range(numRows)]\\n        \\n        def articulationPointDFS(row: int, col: int) -> None:\\n            nonlocal grid, depth, low, parent, numRows, numCols, time, articulationPoint\\n            depth[row][col] = time; time += 1\\n            low[row][col], children = depth[row][col], 0\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                if newRow >= 0 and newRow < numRows and newCol >= 0 and newCol < numCols and grid[newRow][newCol] == 1:\\n                    if depth[newRow][newCol] == -1:\\n                        children += 1\\n                        parent[newRow][newCol] = (row * numCols) + col\\n                        articulationPointDFS(newRow, newCol)\\n                        low[row][col] = min(low[row][col], low[newRow][newCol])\\n                        if low[newRow][newCol] >= depth[row][col] and parent[row][col] > -1:\\n                            articulationPoint = True\\n                    elif newRow * numCols + newCol != parent[row][col]:\\n                        low[row][col] = min(low[row][col], depth[newRow][newCol])\\n            if parent[row][col] == -1 and children > 1:\\n                articulationPoint = True\\n            \\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == 1:\\n                    lands += 1\\n                    if depth[row][col] == -1:\\n                        articulationPointDFS(row, col)\\n                        islands += 1\\n        if islands == 0 or islands >= 2: \\n            return 0\\n        if lands == 1: \\n            return 1\\n        if articulationPoint: \\n            return 1\\n        return 2\\n```\\n\\n```Java []\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\n@SuppressWarnings(\"java:S107\")\\npublic class Solution {\\n    private final int[][] dirs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int minDays(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int numOfIslands = 0;\\n        boolean hasArticulationPoint = false;\\n        int color = 1;\\n        int minIslandSize = m * n;\\n        int[][] time = new int[m][n];\\n        int[][] low = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    numOfIslands++;\\n                    color++;\\n                    List<Integer> articulationPoints = new ArrayList<>();\\n                    int[] islandSize = new int[1];\\n                    tarjan(i, j, -1, -1, 0, time, low, grid, articulationPoints, color, islandSize);\\n                    minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n                    if (!articulationPoints.isEmpty()) {\\n                        hasArticulationPoint = true;\\n                    }\\n                }\\n            }\\n        }\\n        if (numOfIslands >= 2) {\\n            return 0;\\n        }\\n        if (numOfIslands == 0) {\\n            return 0;\\n        }\\n        if (numOfIslands == 1 && minIslandSize == 1) {\\n            return 1;\\n        }\\n        return hasArticulationPoint ? 1 : 2;\\n    }\\n\\n    private void tarjan(\\n            int x,\\n            int y,\\n            int prex,\\n            int prey,\\n            int time,\\n            int[][] times,\\n            int[][] lows,\\n            int[][] grid,\\n            List<Integer> articulationPoints,\\n            int color,\\n            int[] islandSize) {\\n        times[x][y] = time;\\n        lows[x][y] = time;\\n        grid[x][y] = color;\\n        islandSize[0]++;\\n        int children = 0;\\n        for (int[] dir : dirs) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length) {\\n                continue;\\n            }\\n            if (grid[nx][ny] == 1) {\\n                children++;\\n                tarjan(\\n                        nx,\\n                        ny,\\n                        x,\\n                        y,\\n                        time + 1,\\n                        times,\\n                        lows,\\n                        grid,\\n                        articulationPoints,\\n                        color,\\n                        islandSize);\\n                lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n                if (prex != -1 && lows[nx][ny] >= time) {\\n                    articulationPoints.add(x * grid.length + y);\\n                }\\n            } else if ((nx != prex || ny != prey) && grid[nx][ny] != 0) {\\n                lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n            }\\n        }\\n        if (prex == -1 && children > 1) {\\n            articulationPoints.add(x * grid.length + y);\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    int m, n;\\n    int ts;\\n    vector<vector<int>> dfn, low;\\n    bool cut;\\n    int rx, ry;\\n\\n    void dfs(int x, int y, const vector<vector<int>> &grid) {\\n        const int dx[4] = {0, 1, 0, -1};\\n        const int dy[4] = {1, 0, -1 ,0};\\n\\n        dfn[x][y] = low[x][y] = ++ts;\\n        int branch = 0;\\n        for (int i = 0; i < 4; i++) {\\n            int tx = x + dx[i], ty = y + dy[i];\\n            if (tx < 0 || tx >= m || ty < 0 || ty >= n || grid[tx][ty] == 0)\\n                continue;\\n\\n            if (dfn[tx][ty] != 0) {\\n                low[x][y] = min(low[x][y], dfn[tx][ty]);\\n                continue;\\n            }\\n\\n            dfs(tx, ty, grid);\\n\\n            branch++;\\n            low[x][y] = min(low[x][y], low[tx][ty]);\\n\\n            if (low[tx][ty] >= dfn[x][y]) {\\n                if (branch >= 2 || !(x == rx && y == ry))\\n                    cut = true;\\n            }\\n        }\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        dfn.resize(m, vector<int>(n, 0));\\n        low.resize(m, vector<int>(n, 0));\\n        ts = 0;\\n        cut = false;\\n\\n        bool first = false;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (grid[i][j] == 1 && dfn[i][j] == 0) {\\n                    if (first) return 0;\\n                    first = true;\\n                    rx = i; ry = j;\\n                    dfs(i, j, grid);\\n                }\\n\\n        if (!first) return 0;\\n        if (ts == 1 || cut) return 1;\\n        return 2;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        articulationPoint, time, numRows, numCols = False, 0, len(grid), len(grid[0])\\n        directions, lands, islands = [[1, 0], [-1, 0], [0, 1], [0, -1]], 0, 0\\n        depth = [[-1] * numCols for _ in range(numRows)]\\n        low = [[-1] * numCols for _ in range(numRows)]\\n        parent = [[-1] * numCols for _ in range(numRows)]\\n        \\n        def articulationPointDFS(row: int, col: int) -> None:\\n            nonlocal grid, depth, low, parent, numRows, numCols, time, articulationPoint\\n            depth[row][col] = time; time += 1\\n            low[row][col], children = depth[row][col], 0\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                if newRow >= 0 and newRow < numRows and newCol >= 0 and newCol < numCols and grid[newRow][newCol] == 1:\\n                    if depth[newRow][newCol] == -1:\\n                        children += 1\\n                        parent[newRow][newCol] = (row * numCols) + col\\n                        articulationPointDFS(newRow, newCol)\\n                        low[row][col] = min(low[row][col], low[newRow][newCol])\\n                        if low[newRow][newCol] >= depth[row][col] and parent[row][col] > -1:\\n                            articulationPoint = True\\n                    elif newRow * numCols + newCol != parent[row][col]:\\n                        low[row][col] = min(low[row][col], depth[newRow][newCol])\\n            if parent[row][col] == -1 and children > 1:\\n                articulationPoint = True\\n            \\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == 1:\\n                    lands += 1\\n                    if depth[row][col] == -1:\\n                        articulationPointDFS(row, col)\\n                        islands += 1\\n        if islands == 0 or islands >= 2: \\n            return 0\\n        if lands == 1: \\n            return 1\\n        if articulationPoint: \\n            return 1\\n        return 2\\n```\n```Java []\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\n@SuppressWarnings(\"java:S107\")\\npublic class Solution {\\n    private final int[][] dirs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public int minDays(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int numOfIslands = 0;\\n        boolean hasArticulationPoint = false;\\n        int color = 1;\\n        int minIslandSize = m * n;\\n        int[][] time = new int[m][n];\\n        int[][] low = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    numOfIslands++;\\n                    color++;\\n                    List<Integer> articulationPoints = new ArrayList<>();\\n                    int[] islandSize = new int[1];\\n                    tarjan(i, j, -1, -1, 0, time, low, grid, articulationPoints, color, islandSize);\\n                    minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n                    if (!articulationPoints.isEmpty()) {\\n                        hasArticulationPoint = true;\\n                    }\\n                }\\n            }\\n        }\\n        if (numOfIslands >= 2) {\\n            return 0;\\n        }\\n        if (numOfIslands == 0) {\\n            return 0;\\n        }\\n        if (numOfIslands == 1 && minIslandSize == 1) {\\n            return 1;\\n        }\\n        return hasArticulationPoint ? 1 : 2;\\n    }\\n\\n    private void tarjan(\\n            int x,\\n            int y,\\n            int prex,\\n            int prey,\\n            int time,\\n            int[][] times,\\n            int[][] lows,\\n            int[][] grid,\\n            List<Integer> articulationPoints,\\n            int color,\\n            int[] islandSize) {\\n        times[x][y] = time;\\n        lows[x][y] = time;\\n        grid[x][y] = color;\\n        islandSize[0]++;\\n        int children = 0;\\n        for (int[] dir : dirs) {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if (nx < 0 || ny < 0 || nx >= grid.length || ny >= grid[0].length) {\\n                continue;\\n            }\\n            if (grid[nx][ny] == 1) {\\n                children++;\\n                tarjan(\\n                        nx,\\n                        ny,\\n                        x,\\n                        y,\\n                        time + 1,\\n                        times,\\n                        lows,\\n                        grid,\\n                        articulationPoints,\\n                        color,\\n                        islandSize);\\n                lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n                if (prex != -1 && lows[nx][ny] >= time) {\\n                    articulationPoints.add(x * grid.length + y);\\n                }\\n            } else if ((nx != prex || ny != prey) && grid[nx][ny] != 0) {\\n                lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n            }\\n        }\\n        if (prex == -1 && children > 1) {\\n            articulationPoints.add(x * grid.length + y);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005357,
                "title": "ruby-brute-force-2092-ms",
                "content": "# Intuition\\nAnswer is always in [0..2]. If we can\\'t disconnect the grid by removing only 1 island, then the answer will be 2.\\nSo we should remove every single island and see whether the grid is stayed connected.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    $$O(n^4)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    $$O(n^2)$$ (array `visited`)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```ruby\\nDIRECTIONS  = [[1, 0], [-1, 0], [0, 1], [0, -1]].each\\ndef min_days(grid)\\n    m, n = grid.size, grid[0].size\\n    maxi = m - 1\\n    maxj = n - 1\\n    islands = 0\\n    start = start2 = nil \\n    m.times do |i| # Let\\'s count the number of islands.\\n        n.times do |j|\\n            val = grid[i][j]\\n            if val == 1\\n                start2 ||= [i, j] if start\\n                start ||= [i, j]\\n                islands += 1\\n            end\\n        end\\n    end\\n    \\n    return islands if islands.between?(0,1)\\n\\n    connected = -> exclude do # It is true or false.\\n        queue = [exclude == start ? start2 : start]\\n        visited = Array.new(m) { Array.new(n) }\\n        if exclude\\n            exi, exj = exclude\\n            visited[exi][exj] = true\\n            counter = islands - 1\\n        else counter = islands\\n        end\\n\\n        until queue.empty?\\n            i, j = queue.shift\\n            next if visited[i][j]\\n            counter -= 1\\n            return true if counter.zero?\\n            visited[i][j] = true\\n            DIRECTIONS.each do |a, b|\\n                ii = i + a\\n                jj = j + b\\n                if ii.between?(0, maxi) && jj.between?(0, maxj) && grid[ii][jj] == 1 && !visited[ii][jj]\\n                    queue << [ii, jj]\\n                end\\n            end\\n        end\\n        false\\n    end\\n\\n    return 0 unless connected.(nil)\\n    return 2 if islands == 2\\n    return 1 if islands == 3\\n\\n    m.times do |i|\\n        n.times do |j|\\n            return 1 if grid[i][j] == 1 && !connected.([i, j])\\n        end\\n    end\\n    2\\nend\\n```\\n<hr>\\n\\n# Tests:\\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_min_days < Test::Unit::TestCase\\n    def test_\\n        assert_equal 1, min_days([[1,1,1,1],[1,1,1,0],[1,1,0,1],[1,1,1,1],[1,1,0,0],[1,1,1,1]])\\n        assert_equal 1, min_days([[1,1,0,1,1],[1,1,1,1,1],[1,1,0,1,1],[1,1,0,1,1]])\\n        assert_equal 2, min_days([[0,1,1,0],[0,1,1,0],[0,0,0,0]])\\n        assert_equal 2, min_days([[1,1]])\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nDIRECTIONS  = [[1, 0], [-1, 0], [0, 1], [0, -1]].each\\ndef min_days(grid)\\n    m, n = grid.size, grid[0].size\\n    maxi = m - 1\\n    maxj = n - 1\\n    islands = 0\\n    start = start2 = nil \\n    m.times do |i| # Let\\'s count the number of islands.\\n        n.times do |j|\\n            val = grid[i][j]\\n            if val == 1\\n                start2 ||= [i, j] if start\\n                start ||= [i, j]\\n                islands += 1\\n            end\\n        end\\n    end\\n    \\n    return islands if islands.between?(0,1)\\n\\n    connected = -> exclude do # It is true or false.\\n        queue = [exclude == start ? start2 : start]\\n        visited = Array.new(m) { Array.new(n) }\\n        if exclude\\n            exi, exj = exclude\\n            visited[exi][exj] = true\\n            counter = islands - 1\\n        else counter = islands\\n        end\\n\\n        until queue.empty?\\n            i, j = queue.shift\\n            next if visited[i][j]\\n            counter -= 1\\n            return true if counter.zero?\\n            visited[i][j] = true\\n            DIRECTIONS.each do |a, b|\\n                ii = i + a\\n                jj = j + b\\n                if ii.between?(0, maxi) && jj.between?(0, maxj) && grid[ii][jj] == 1 && !visited[ii][jj]\\n                    queue << [ii, jj]\\n                end\\n            end\\n        end\\n        false\\n    end\\n\\n    return 0 unless connected.(nil)\\n    return 2 if islands == 2\\n    return 1 if islands == 3\\n\\n    m.times do |i|\\n        n.times do |j|\\n            return 1 if grid[i][j] == 1 && !connected.([i, j])\\n        end\\n    end\\n    2\\nend\\n```\n```ruby\\nrequire \\'test/unit\\'\\nclass Test_min_days < Test::Unit::TestCase\\n    def test_\\n        assert_equal 1, min_days([[1,1,1,1],[1,1,1,0],[1,1,0,1],[1,1,1,1],[1,1,0,0],[1,1,1,1]])\\n        assert_equal 1, min_days([[1,1,0,1,1],[1,1,1,1,1],[1,1,0,1,1],[1,1,0,1,1]])\\n        assert_equal 2, min_days([[0,1,1,0],[0,1,1,0],[0,0,0,0]])\\n        assert_equal 2, min_days([[1,1]])\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969006,
                "title": "c-articulation-points-50-lines-7ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dir[5] = {0,1,0,-1,0};\\n    int m, n;\\n    int t = 0;\\n    bool has_ap = false;\\n    int dis[900], low[900];\\n    int minDays(vector<vector<int>>& grid) {\\n      m = grid.size(), n = grid[0].size();\\n      memset(dis, 0, sizeof(dis));\\n      memset(low, 0, sizeof(low));\\n      int c = 0, area = 0;\\n      for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n          int u = i*n+j;\\n          if (grid[i][j]) {\\n            ++area;\\n            if (!dis[u]) {\\n              dfs(grid, u, -1);\\n              ++c;\\n            }\\n          }\\n        }\\n      }\\n      if (c > 1) { return 0; }\\n      else if (has_ap) { return 1; }\\n      else { return min(area, 2); }\\n    }\\n    void dfs(vector<vector<int>>& grid, int u, int p) {\\n      low[u] = dis[u] = ++t;\\n      int r = u/n, c = u%n;\\n      bool is_ap = false;\\n      int children = 0;\\n      for (int di = 0; di < 4; ++di) {\\n        int nr = r+dir[di], nc = c+dir[di+1];\\n        if (nr < 0 || nr >= m || nc < 0 || nc >= n || !grid[nr][nc]) {\\n          continue;\\n        }\\n        int v = nr*n+nc;\\n        if (v == p) { continue; }\\n        if (dis[v]) {\\n          low[u] = min(low[u], dis[v]);\\n        } else {\\n          dfs(grid, v, u);\\n          ++children;\\n          low[u] = min(low[u], low[v]);\\n          if (low[v] >= dis[u] && p != -1) {\\n            is_ap = true;\\n          }\\n        }\\n      }\\n      is_ap |= (p==-1)&&(children>1);\\n      has_ap |= is_ap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[5] = {0,1,0,-1,0};\\n    int m, n;\\n    int t = 0;\\n    bool has_ap = false;\\n    int dis[900], low[900];\\n    int minDays(vector<vector<int>>& grid) {\\n      m = grid.size(), n = grid[0].size();\\n      memset(dis, 0, sizeof(dis));\\n      memset(low, 0, sizeof(low));\\n      int c = 0, area = 0;\\n      for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n          int u = i*n+j;\\n          if (grid[i][j]) {\\n            ++area;\\n            if (!dis[u]) {\\n              dfs(grid, u, -1);\\n              ++c;\\n            }\\n          }\\n        }\\n      }\\n      if (c > 1) { return 0; }\\n      else if (has_ap) { return 1; }\\n      else { return min(area, 2); }\\n    }\\n    void dfs(vector<vector<int>>& grid, int u, int p) {\\n      low[u] = dis[u] = ++t;\\n      int r = u/n, c = u%n;\\n      bool is_ap = false;\\n      int children = 0;\\n      for (int di = 0; di < 4; ++di) {\\n        int nr = r+dir[di], nc = c+dir[di+1];\\n        if (nr < 0 || nr >= m || nc < 0 || nc >= n || !grid[nr][nc]) {\\n          continue;\\n        }\\n        int v = nr*n+nc;\\n        if (v == p) { continue; }\\n        if (dis[v]) {\\n          low[u] = min(low[u], dis[v]);\\n        } else {\\n          dfs(grid, v, u);\\n          ++children;\\n          low[u] = min(low[u], low[v]);\\n          if (low[v] >= dis[u] && p != -1) {\\n            is_ap = true;\\n          }\\n        }\\n      }\\n      is_ap |= (p==-1)&&(children>1);\\n      has_ap |= is_ap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952200,
                "title": "tarjan-s-algorithm-o-m-n-with-approach-and-detailed-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe DFS function uses Tarjan\\'s algorithm to identify the articulation points in the grid. It keeps track of the insertion time and lowest time of each cell, which are used to determine whether a cell is an articulation point. The insertion time of a cell is the time at which it is visited during the DFS, and the lowest time of a cell is the minimum of its insertion time and the insertion times of its neighbours that can be reached without going through the parent of the current cell.\\n\\nIf the lowest time of a neighbour is greater than or equal to the insertion time of the current cell, and the current cell is not the root (has a parent), it means that the neighbour can only be reached through the current cell, so if the current cell is removed, the neighbour becomes disconnected from the rest of the grid. Therefore, the current cell is an articulation point.\\n\\nIf the current cell has more than 1 child component and is the root (has no parent), it means that it has more than 1 neighbour that can be reached without going through the parent, so if the current cell is removed, more than 1 component becomes disconnected from the rest of the grid. Therefore, the current cell is also an articulation point.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Perform a depth-first search (DFS) on the grid to identify the articulation points. An articulation point is a cell that, when removed, disconnects the grid.\\n\\n\\n3. If the number of connected components in the grid is not 1, the grid is already disconnected, so return 0 days. Otherwise, if the grid contains an articulation point or if there is only 1 land cell in the grid, return 1 day. Otherwise, return 2 days.\\n\\n# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    // helper function to check if the given row and column indices are within the bounds of the grid\\n    bool isInBounds(int row, int col, int totalRows, int totalCols) {\\n        return row >= 0 && row < totalRows && col >= 0 && col < totalCols;\\n    }\\n\\n    // Depth-First Search function to identify the articulation points in the grid\\n    // An articulation point is a cell that, when removed, disconnects the grid\\n    void dfsArticulationPoint(int row, int col, int parentRow, int parentCol, vector<vector<int>>& insertionTime, vector<vector<int>>& lowestTime, bool& containsArticulationPoint, int& timer,\\n                                vector<vector<bool>>& visited, vector<vector<int>>& grid, vector<int>& dRow, vector<int>& dCol) {\\n        // mark the current cell as visited\\n        visited[row][col] = true;\\n\\n        // set the insertion time and lowest time of the current cell as the current timer value\\n        insertionTime[row][col] = lowestTime[row][col] = timer++;\\n        \\n        // variable to store the number of child components (connected 1s) of the current cell\\n        int childComponents = 0;\\n\\n        // iterate through the 4 directions (left, right, up, down) to visit the neighbours\\n        for(int direction = 0; direction < 4; direction++) {\\n            int neighbourRow = row + dRow[direction];\\n            int neighbourCol = col + dCol[direction];\\n\\n            // skip the parent cell, as it is not a neighbour\\n            if(neighbourRow == parentRow && neighbourCol == parentCol) continue;\\n\\n            // if the neighbour cell is within the bounds of the grid and is a land cell (has a value of 1)\\n            if(isInBounds(neighbourRow, neighbourCol, grid.size(), grid[0].size()) && grid[neighbourRow][neighbourCol] == 1) {\\n                \\n                // if the neighbour has not been visited yet\\n                if(!visited[neighbourRow][neighbourCol]) {\\n                    \\n                    // recursively call the DFS function on the neighbour\\n                    dfsArticulationPoint(neighbourRow, neighbourCol, row, col, insertionTime, lowestTime, containsArticulationPoint, timer, visited, grid, dRow, dCol);\\n\\n                    // update the lowest time of the current cell with the minimum of its current lowest time and the lowest time of the neighbour\\n                    lowestTime[row][col] = min(lowestTime[row][col], lowestTime[neighbourRow][neighbourCol]);\\n\\n                    // if the lowest time of the neighbour is greater than or equal to the insertion time of the current cell, and the current cell is not the root (has a parent)\\n                    if(lowestTime[neighbourRow][neighbourCol] >= insertionTime[row][col] && parentRow != -1 && parentCol != -1) {\\n                        \\n                        // mark that the grid contains an articulation point\\n                        containsArticulationPoint = true;\\n                    }\\n                    \\n                    // increment the number of child components of the current cell\\n                    childComponents++;\\n                } else {\\n                    // if the neighbour has already been visited, update the lowest time of the current cell \\n                    // with the minimum of its current lowest time and the insertion time of the neighbour\\n                    lowestTime[row][col] = min(lowestTime[row][col], insertionTime[neighbourRow][neighbourCol]);\\n                }\\n            }\\n        }\\n\\n        // if the current cell has more than 1 child component and is the root (has no parent), mark that the grid contains an articulation point\\n        if(childComponents > 1 && parentRow == -1 && parentCol == -1) {\\n            containsArticulationPoint = true;\\n        }\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        // get the number of rows and columns in the grid\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n\\n        // 2D vector to store the visited status of each cell\\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\\n        \\n        // 2D vectors to store the insertion time and lowest time of each cell\\n        vector<vector<int>> insertionTime(rows, vector<int>(cols));\\n        vector<vector<int>> lowestTime(rows, vector<int>(cols));\\n        // variable to store whether the grid contains an articulation point\\n        bool containsArticulationPoint = false;\\n        // variable to store the timer value (incremented each time a cell is visited)\\n        int timer = 0;\\n\\n        // vectors to store the row and column offsets to visit the neighbours in the 4 directions (left, right, up, down)\\n        vector<int> dRow = {-1, 0, 1, 0};\\n        vector<int> dCol = {0, 1, 0, -1};\\n\\n        // variable to store the number of land cells (cells with a value of 1) in the grid\\n        int numberOfLandCells = 0;\\n        // variable to store the number of connected components (groups of connected 1s) in the grid\\n        int numberOfComponents = 0;\\n\\n        // iterate through the grid to identify the articulation points and count the number of land cells and connected components\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                // if the current cell is a land cell\\n                if(grid[row][col] == 1) {\\n                    // increment the number of land cells\\n                    numberOfLandCells++;\\n\\n                    // if the current cell has not been visited yet\\n                    if(!visited[row][col]) {\\n                        // perform DFS starting from the current cell to identify the articulation points and count the connected components\\n                        dfsArticulationPoint(row, col, -1, -1, insertionTime, lowestTime, containsArticulationPoint, timer, visited, grid, dRow, dCol);\\n                        \\n                        // increment the number of connected components\\n                        numberOfComponents++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // if the number of connected components is not 1, the grid is already disconnected, so return 0 days\\n        // otherwise, if the grid contains an articulation point or if there is only 1 land cell in the grid, return 1 day\\n        // otherwise, return 2 days\\n        return numberOfComponents != 1 ? 0 : containsArticulationPoint || numberOfLandCells == 1 ? 1 : 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // helper function to check if the given row and column indices are within the bounds of the grid\\n    bool isInBounds(int row, int col, int totalRows, int totalCols) {\\n        return row >= 0 && row < totalRows && col >= 0 && col < totalCols;\\n    }\\n\\n    // Depth-First Search function to identify the articulation points in the grid\\n    // An articulation point is a cell that, when removed, disconnects the grid\\n    void dfsArticulationPoint(int row, int col, int parentRow, int parentCol, vector<vector<int>>& insertionTime, vector<vector<int>>& lowestTime, bool& containsArticulationPoint, int& timer,\\n                                vector<vector<bool>>& visited, vector<vector<int>>& grid, vector<int>& dRow, vector<int>& dCol) {\\n        // mark the current cell as visited\\n        visited[row][col] = true;\\n\\n        // set the insertion time and lowest time of the current cell as the current timer value\\n        insertionTime[row][col] = lowestTime[row][col] = timer++;\\n        \\n        // variable to store the number of child components (connected 1s) of the current cell\\n        int childComponents = 0;\\n\\n        // iterate through the 4 directions (left, right, up, down) to visit the neighbours\\n        for(int direction = 0; direction < 4; direction++) {\\n            int neighbourRow = row + dRow[direction];\\n            int neighbourCol = col + dCol[direction];\\n\\n            // skip the parent cell, as it is not a neighbour\\n            if(neighbourRow == parentRow && neighbourCol == parentCol) continue;\\n\\n            // if the neighbour cell is within the bounds of the grid and is a land cell (has a value of 1)\\n            if(isInBounds(neighbourRow, neighbourCol, grid.size(), grid[0].size()) && grid[neighbourRow][neighbourCol] == 1) {\\n                \\n                // if the neighbour has not been visited yet\\n                if(!visited[neighbourRow][neighbourCol]) {\\n                    \\n                    // recursively call the DFS function on the neighbour\\n                    dfsArticulationPoint(neighbourRow, neighbourCol, row, col, insertionTime, lowestTime, containsArticulationPoint, timer, visited, grid, dRow, dCol);\\n\\n                    // update the lowest time of the current cell with the minimum of its current lowest time and the lowest time of the neighbour\\n                    lowestTime[row][col] = min(lowestTime[row][col], lowestTime[neighbourRow][neighbourCol]);\\n\\n                    // if the lowest time of the neighbour is greater than or equal to the insertion time of the current cell, and the current cell is not the root (has a parent)\\n                    if(lowestTime[neighbourRow][neighbourCol] >= insertionTime[row][col] && parentRow != -1 && parentCol != -1) {\\n                        \\n                        // mark that the grid contains an articulation point\\n                        containsArticulationPoint = true;\\n                    }\\n                    \\n                    // increment the number of child components of the current cell\\n                    childComponents++;\\n                } else {\\n                    // if the neighbour has already been visited, update the lowest time of the current cell \\n                    // with the minimum of its current lowest time and the insertion time of the neighbour\\n                    lowestTime[row][col] = min(lowestTime[row][col], insertionTime[neighbourRow][neighbourCol]);\\n                }\\n            }\\n        }\\n\\n        // if the current cell has more than 1 child component and is the root (has no parent), mark that the grid contains an articulation point\\n        if(childComponents > 1 && parentRow == -1 && parentCol == -1) {\\n            containsArticulationPoint = true;\\n        }\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        // get the number of rows and columns in the grid\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n\\n        // 2D vector to store the visited status of each cell\\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\\n        \\n        // 2D vectors to store the insertion time and lowest time of each cell\\n        vector<vector<int>> insertionTime(rows, vector<int>(cols));\\n        vector<vector<int>> lowestTime(rows, vector<int>(cols));\\n        // variable to store whether the grid contains an articulation point\\n        bool containsArticulationPoint = false;\\n        // variable to store the timer value (incremented each time a cell is visited)\\n        int timer = 0;\\n\\n        // vectors to store the row and column offsets to visit the neighbours in the 4 directions (left, right, up, down)\\n        vector<int> dRow = {-1, 0, 1, 0};\\n        vector<int> dCol = {0, 1, 0, -1};\\n\\n        // variable to store the number of land cells (cells with a value of 1) in the grid\\n        int numberOfLandCells = 0;\\n        // variable to store the number of connected components (groups of connected 1s) in the grid\\n        int numberOfComponents = 0;\\n\\n        // iterate through the grid to identify the articulation points and count the number of land cells and connected components\\n        for(int row = 0; row < rows; row++) {\\n            for(int col = 0; col < cols; col++) {\\n                // if the current cell is a land cell\\n                if(grid[row][col] == 1) {\\n                    // increment the number of land cells\\n                    numberOfLandCells++;\\n\\n                    // if the current cell has not been visited yet\\n                    if(!visited[row][col]) {\\n                        // perform DFS starting from the current cell to identify the articulation points and count the connected components\\n                        dfsArticulationPoint(row, col, -1, -1, insertionTime, lowestTime, containsArticulationPoint, timer, visited, grid, dRow, dCol);\\n                        \\n                        // increment the number of connected components\\n                        numberOfComponents++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // if the number of connected components is not 1, the grid is already disconnected, so return 0 days\\n        // otherwise, if the grid contains an articulation point or if there is only 1 land cell in the grid, return 1 day\\n        // otherwise, return 2 days\\n        return numberOfComponents != 1 ? 0 : containsArticulationPoint || numberOfLandCells == 1 ? 1 : 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945533,
                "title": "dfs-c-clean-simple-fast-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<ll>dx={1,-1,0,0};\\n    vector<ll>dy={0,0,1,-1};\\n\\n    bool issafe(ll x,ll y,ll n,ll m){\\n        return x>=0 && y>=0 && x<n && y<m;\\n    }\\n\\n    void dfs(vector<vector<int>>&grid,vector<vector<bool>>&visited,ll i,ll j,ll n,ll m,ll f1,ll f2){\\n        visited[i][j]=true;\\n        for(ll k=0;k<4;k++){\\n            ll x=i+dx[k],y=j+dy[k];\\n            if(issafe(x,y,n,m) && grid[x][y]==1 && visited[x][y]==false && !(x==f1 && y==f2)){\\n                dfs(grid,visited,x,y,n,m,f1,f2);\\n            }\\n        }\\n        return;\\n    }\\n\\n    bool check(vector<vector<int>>&grid,ll n,ll m,ll f1,ll f2){\\n        ll count=0;\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1 && visited[i][j]==false && !(i==f1 && j==f2)){\\n                    dfs(grid,visited,i,j,n,m,f1,f2);\\n                    count++;\\n                    if(count>1){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        ll n=grid.size(),m=grid[0].size(),count=0;\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    count++;\\n                }\\n            }\\n        }\\n        if(count<=1){\\n            return count;\\n        }\\n        if(check(grid,n,m,-1,-1)){\\n            return 0;\\n        }\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    if(check(grid,n,m,i,j)){\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<ll>dx={1,-1,0,0};\\n    vector<ll>dy={0,0,1,-1};\\n\\n    bool issafe(ll x,ll y,ll n,ll m){\\n        return x>=0 && y>=0 && x<n && y<m;\\n    }\\n\\n    void dfs(vector<vector<int>>&grid,vector<vector<bool>>&visited,ll i,ll j,ll n,ll m,ll f1,ll f2){\\n        visited[i][j]=true;\\n        for(ll k=0;k<4;k++){\\n            ll x=i+dx[k],y=j+dy[k];\\n            if(issafe(x,y,n,m) && grid[x][y]==1 && visited[x][y]==false && !(x==f1 && y==f2)){\\n                dfs(grid,visited,x,y,n,m,f1,f2);\\n            }\\n        }\\n        return;\\n    }\\n\\n    bool check(vector<vector<int>>&grid,ll n,ll m,ll f1,ll f2){\\n        ll count=0;\\n        vector<vector<bool>>visited(n,vector<bool>(m,false));\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1 && visited[i][j]==false && !(i==f1 && j==f2)){\\n                    dfs(grid,visited,i,j,n,m,f1,f2);\\n                    count++;\\n                    if(count>1){\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int minDays(vector<vector<int>>& grid) {\\n        ll n=grid.size(),m=grid[0].size(),count=0;\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    count++;\\n                }\\n            }\\n        }\\n        if(count<=1){\\n            return count;\\n        }\\n        if(check(grid,n,m,-1,-1)){\\n            return 0;\\n        }\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    if(check(grid,n,m,i,j)){\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832669,
                "title": "c-dfs-strongly-connected-component-code-explained-with-comments",
                "content": "**calculate no of islands using simple dfs**\\n* if no of islands is 0. return 0.\\n*  if no of islands is greater then 1. then grid already is disconnected. return 0.\\n*  **no of islands is 1 then,**   \\n\\t*  1.  we will check if flipping a single 1 can make it disconnected, if yes return 1.\\n\\t*  2. if not then we are sure by flipping any 2 (diagonally oriented )  \\'1\\' we can disconnect the grid. return 2.\\n\\nthats it. Thanks.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs( vector<vector<int>> &grid, int i, int j ){\\n        \\n        if( min(i,j) < 0 || i == grid.size() || j == grid[0].size() || grid[i][j] != 1) return;\\n        \\n        grid[i][j] = 2;\\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j-1);\\n        dfs(grid, i, j+1);\\n    }\\n    \\n\\t\\t// calculate strongly connected components or no of islands\\n\\t\\t// note that i didnt pass grid by reference, I dont want the original grid to get modified.\\n    int calcSC( vector<vector<int>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sc = 0;\\n        for( int i = 0; i < m; ++i){\\n            for( int j = 0; j < n; ++j){\\n                if( grid[i][j] == 1){\\n                    sc++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return sc;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if( calcSC(grid) != 1) return 0;\\n        \\n\\t\\t// check if by making 1 land cell into water, we get disconnected grid\\n        for( int i = 0 ; i < m; ++i){\\n            for( int j = 0; j < n; ++j){\\n                if( grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if( calcSC(grid) != 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```\\n\\nPlease upvote if you found this helpful.",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs( vector<vector<int>> &grid, int i, int j ){\\n        \\n        if( min(i,j) < 0 || i == grid.size() || j == grid[0].size() || grid[i][j] != 1) return;\\n        \\n        grid[i][j] = 2;\\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j-1);\\n        dfs(grid, i, j+1);\\n    }\\n    \\n\\t\\t// calculate strongly connected components or no of islands\\n\\t\\t// note that i didnt pass grid by reference, I dont want the original grid to get modified.\\n    int calcSC( vector<vector<int>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sc = 0;\\n        for( int i = 0; i < m; ++i){\\n            for( int j = 0; j < n; ++j){\\n                if( grid[i][j] == 1){\\n                    sc++;\\n                    dfs(grid, i, j);\\n                }\\n            }\\n        }\\n        return sc;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if( calcSC(grid) != 1) return 0;\\n        \\n\\t\\t// check if by making 1 land cell into water, we get disconnected grid\\n        for( int i = 0 ; i < m; ++i){\\n            for( int j = 0; j < n; ++j){\\n                if( grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if( calcSC(grid) != 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795846,
                "title": "python-2-solution-articulation-points-check-and-pointwise-dfs",
                "content": "If the islands are already disconnect, we return 0. Otherwise, all we need is to check whether there is a point, delete it will form two components. Such points are called articulation points, can be solved in linear time O(V + E). As the size of the problem is small, we can also use DFS to check articulation points. Please refer to [https://cp-algorithms.com/graph/cutpoints.html]().\\n\\n1. Search articulation points, O(MN)\\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        lands = dict()\\n        for x, y in product(range(len(grid)), range(len(grid[0]))):\\n            if grid[x][y]: lands[(x, y)] = len(lands)\\n        if len(lands) <= 1: return len(lands)\\n        n = len(lands)\\n        graph = [set() for _ in range(n)]\\n        for (x, y), i in lands.items():\\n            for nx, ny in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\\n                if (nx, ny) in lands:\\n                    graph[i].add(lands[(nx, ny)])\\n                    graph[lands[(nx, ny)]].add(i)\\n        timer = 0\\n        visited, tin, low = set(), [-1] * n, [-1] * n\\n        def check_cutpoint(v, p = -1):\\n            nonlocal timer\\n            visited.add(v)\\n            tin[v] = low[v] = timer\\n            timer += 1\\n            ret, children = False, 0\\n            for to in graph[v]:\\n                if to == p: continue\\n                if to in visited: low[v] = min(low[v], tin[to])\\n                else:\\n                    if check_cutpoint(to, v): ret = True\\n                    low[v] = min(low[v], low[to])\\n                    if low[to] >= tin[v] and p != -1: ret = True\\n                    children += 1\\n            return ret or p == -1 and children > 1\\n        cp = check_cutpoint(0)\\n        if len(visited) != n: return 0\\n        return 1 if cp else 2\\n```\\n2. Pointwise DFS check, O((NM) ^ 2)\\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        def connect(grid):\\n            visited, area = set(), 0\\n            def dfs(x, y):\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] and (nx, ny) not in visited:\\n                        visited.add((nx, ny))\\n                        dfs(nx, ny)\\n            for x, y in product(range(m), range(n)):\\n                if grid[x][y] and (x, y) not in visited:\\n                    if area: return False\\n                    area += 1\\n                    visited.add((x, y))\\n                    dfs(x, y)\\n            return area == 1\\n        if not connect(grid): return 0\\n        for x, y in product(range(m), range(n)):\\n                if grid[x][y]:\\n                    grid[x][y] = 0\\n                    if not connect(grid): return 1\\n                    grid[x][y] = 1\\n        return 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nfrom itertools import product\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        lands = dict()\\n        for x, y in product(range(len(grid)), range(len(grid[0]))):\\n            if grid[x][y]: lands[(x, y)] = len(lands)\\n        if len(lands) <= 1: return len(lands)\\n        n = len(lands)\\n        graph = [set() for _ in range(n)]\\n        for (x, y), i in lands.items():\\n            for nx, ny in [(x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1)]:\\n                if (nx, ny) in lands:\\n                    graph[i].add(lands[(nx, ny)])\\n                    graph[lands[(nx, ny)]].add(i)\\n        timer = 0\\n        visited, tin, low = set(), [-1] * n, [-1] * n\\n        def check_cutpoint(v, p = -1):\\n            nonlocal timer\\n            visited.add(v)\\n            tin[v] = low[v] = timer\\n            timer += 1\\n            ret, children = False, 0\\n            for to in graph[v]:\\n                if to == p: continue\\n                if to in visited: low[v] = min(low[v], tin[to])\\n                else:\\n                    if check_cutpoint(to, v): ret = True\\n                    low[v] = min(low[v], low[to])\\n                    if low[to] >= tin[v] and p != -1: ret = True\\n                    children += 1\\n            return ret or p == -1 and children > 1\\n        cp = check_cutpoint(0)\\n        if len(visited) != n: return 0\\n        return 1 if cp else 2\\n```\n```\\nfrom itertools import product\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        def connect(grid):\\n            visited, area = set(), 0\\n            def dfs(x, y):\\n                for nx, ny in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\\n                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] and (nx, ny) not in visited:\\n                        visited.add((nx, ny))\\n                        dfs(nx, ny)\\n            for x, y in product(range(m), range(n)):\\n                if grid[x][y] and (x, y) not in visited:\\n                    if area: return False\\n                    area += 1\\n                    visited.add((x, y))\\n                    dfs(x, y)\\n            return area == 1\\n        if not connect(grid): return 0\\n        for x, y in product(range(m), range(n)):\\n                if grid[x][y]:\\n                    grid[x][y] = 0\\n                    if not connect(grid): return 1\\n                    grid[x][y] = 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760752,
                "title": "python-simple-dfs",
                "content": "\\n    def minDays(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        \\n        def function(grid):\\n            m, n = len(grid), len(grid[0])\\n            \\n            total, visited = 0, set()\\n            \\n            def dfs(i,j,visited):\\n                if 0 <= i < m and 0 <= j < n and grid[i][j] == 1 and (i,j) not in visited:\\n                    visited.add((i,j))\\n                    dfs(i-1,j,visited)\\n                    dfs(i+1,j,visited)\\n                    dfs(i,j-1,visited)\\n                    dfs(i,j+1,visited)\\n                    \\n                    \\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == 1 and (i,j) not in visited:\\n                        total += 1\\n                        dfs(i,j,visited)\\n            \\n            return total\\n        \\n        if function(grid) != 1:\\n            return 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    grid[i][j] = 0\\n                    \\n                    if function(grid) != 1:\\n                        return 1\\n                    \\n                    grid[i][j] = 1\\n        \\n        return 2\\n            \\n",
                "solutionTags": [],
                "code": "\\n    def minDays(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        \\n        def function(grid):\\n            m, n = len(grid), len(grid[0])\\n            \\n            total, visited = 0, set()\\n            \\n            def dfs(i,j,visited):\\n                if 0 <= i < m and 0 <= j < n and grid[i][j] == 1 and (i,j) not in visited:\\n                    visited.add((i,j))\\n                    dfs(i-1,j,visited)\\n                    dfs(i+1,j,visited)\\n                    dfs(i,j-1,visited)\\n                    dfs(i,j+1,visited)\\n                    \\n                    \\n            for i in range(m):\\n                for j in range(n):\\n                    if grid[i][j] == 1 and (i,j) not in visited:\\n                        total += 1\\n                        dfs(i,j,visited)\\n            \\n            return total\\n        \\n        if function(grid) != 1:\\n            return 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    grid[i][j] = 0\\n                    \\n                    if function(grid) != 1:\\n                        return 1\\n                    \\n                    grid[i][j] = 1\\n        \\n        return 2\\n            \\n",
                "codeTag": "Python3"
            },
            {
                "id": 2701196,
                "title": "python-bfs-connected-components",
                "content": "```\\nfrom collections import defaultdict\\nfrom collections import deque\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        dirr=[1,0,-1,0]\\n        dirc=[0,1,0,-1]\\n        visreq=set()\\n        cntone=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    cntone+=1\\n                    \\n                    visreq.add((i,j))\\n                    \\n        if cntone==1:\\n            return 1\\n                \\n        def isvalid(i,j,m,n,visreq,gridma):\\n            if i<0 or i>m-1 or j<0 or j>n-1 or gridma[i][j]==0 :\\n                return False\\n            return True\\n        \\n        # vis=set()\\n        def bfs(source,vis,gridpa,visreqpa):\\n            q=deque()\\n            q.append(source)\\n            \\n            vis.add(source)\\n            \\n            while(q):\\n                # print(q,vis)\\n                x,y=q.popleft()\\n                \\n                # vis.add((x,y))\\n            \\n                for i in range(4):\\n                    adjx=dirr[i]+x\\n                    adjy=dirc[i]+y\\n                    \\n                    if (adjx,adjy) not in vis and isvalid(adjx,adjy,m,n,visreqpa,gridpa):\\n                        vis.add((adjx,adjy))\\n                        q.append((adjx,adjy))\\n                        \\n            return vis\\n        glovis=set()         \\n        cnt=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1 and (i,j) not in glovis:\\n                    glovis=glovis.union(bfs((i,j),set(),grid,visreq))\\n                    cnt+=1\\n                    # print(glovis,\\'ji\\')\\n                    if glovis==visreq:\\n                        break\\n                        \\n        # print(cnt)\\n                        \\n        if cnt!=1:\\n            return 0\\n        # glovis=set()\\n        # print(\\'pudhusu pa\\')\\n        for i in range(m):\\n            for j in range(n):\\n                # print(\"is it to\")\\n                if grid[i][j]==1:\\n\\n                    \\n                    \\n                    gridcopy=copy.deepcopy(grid)\\n                    gridcopy[i][j]=0\\n                    glovis=set()    \\n                    visreqpa=set()\\n                    for f in range(m):\\n                        for e in range(n):\\n                            if gridcopy[f][e]==1:\\n                                \\n                                visreqpa.add((f,e))\\n                    \\n                    \\n                    cnt=0\\n                    for f in range(m):\\n                        for e in range(n):\\n                            if gridcopy[f][e]==1 and (f,e) not in glovis:\\n                                glovis=glovis.union(bfs((f,e),set(),gridcopy,visreqpa))\\n                                \\n                                cnt+=1\\n                                # print(glovis,\\'ji\\')\\n                                if glovis==visreqpa and cnt!=1:\\n                                    return 1\\n                                \\n                                # if cnt>1:\\n                                #     break\\n                                    \\n        return 2\\n                    \\n#         bb,aa=None,None\\n#         for i,j in visreq:\\n#             if not bb:\\n#                 bb=i\\n#             elif bb!=i:\\n#                 return 2\\n#             if not aa:\\n#                 aa=j\\n#             elif aa!=j:\\n#                 return 2\\n            \\n#         return 1\\n                \\n                \\n            \\n            \\n                        \\n\\n                    \\n                    \\n                        \\n                        \\n\\n            \\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom collections import deque\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        dirr=[1,0,-1,0]\\n        dirc=[0,1,0,-1]\\n        visreq=set()\\n        cntone=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    cntone+=1\\n                    \\n                    visreq.add((i,j))\\n                    \\n        if cntone==1:\\n            return 1\\n                \\n        def isvalid(i,j,m,n,visreq,gridma):\\n            if i<0 or i>m-1 or j<0 or j>n-1 or gridma[i][j]==0 :\\n                return False\\n            return True\\n        \\n        # vis=set()\\n        def bfs(source,vis,gridpa,visreqpa):\\n            q=deque()\\n            q.append(source)\\n            \\n            vis.add(source)\\n            \\n            while(q):\\n                # print(q,vis)\\n                x,y=q.popleft()\\n                \\n                # vis.add((x,y))\\n            \\n                for i in range(4):\\n                    adjx=dirr[i]+x\\n                    adjy=dirc[i]+y\\n                    \\n                    if (adjx,adjy) not in vis and isvalid(adjx,adjy,m,n,visreqpa,gridpa):\\n                        vis.add((adjx,adjy))\\n                        q.append((adjx,adjy))\\n                        \\n            return vis\\n        glovis=set()         \\n        cnt=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1 and (i,j) not in glovis:\\n                    glovis=glovis.union(bfs((i,j),set(),grid,visreq))\\n                    cnt+=1\\n                    # print(glovis,\\'ji\\')\\n                    if glovis==visreq:\\n                        break\\n                        \\n        # print(cnt)\\n                        \\n        if cnt!=1:\\n            return 0\\n        # glovis=set()\\n        # print(\\'pudhusu pa\\')\\n        for i in range(m):\\n            for j in range(n):\\n                # print(\"is it to\")\\n                if grid[i][j]==1:\\n\\n                    \\n                    \\n                    gridcopy=copy.deepcopy(grid)\\n                    gridcopy[i][j]=0\\n                    glovis=set()    \\n                    visreqpa=set()\\n                    for f in range(m):\\n                        for e in range(n):\\n                            if gridcopy[f][e]==1:\\n                                \\n                                visreqpa.add((f,e))\\n                    \\n                    \\n                    cnt=0\\n                    for f in range(m):\\n                        for e in range(n):\\n                            if gridcopy[f][e]==1 and (f,e) not in glovis:\\n                                glovis=glovis.union(bfs((f,e),set(),gridcopy,visreqpa))\\n                                \\n                                cnt+=1\\n                                # print(glovis,\\'ji\\')\\n                                if glovis==visreqpa and cnt!=1:\\n                                    return 1\\n                                \\n                                # if cnt>1:\\n                                #     break\\n                                    \\n        return 2\\n                    \\n#         bb,aa=None,None\\n#         for i,j in visreq:\\n#             if not bb:\\n#                 bb=i\\n#             elif bb!=i:\\n#                 return 2\\n#             if not aa:\\n#                 aa=j\\n#             elif aa!=j:\\n#                 return 2\\n            \\n#         return 1\\n                \\n                \\n            \\n            \\n                        \\n\\n                    \\n                    \\n                        \\n                        \\n\\n            \\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663376,
                "title": "python-articulation-point-dfs-73ms-faster-than-100-o-m-n",
                "content": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        articulationPoint, time, numRows, numCols = False, 0, len(grid), len(grid[0])\\n        directions, lands, islands = [[1, 0], [-1, 0], [0, 1], [0, -1]], 0, 0\\n        depth = [[-1] * numCols for _ in range(numRows)]\\n        low = [[-1] * numCols for _ in range(numRows)]\\n        parent = [[-1] * numCols for _ in range(numRows)]\\n        \\n        \\n        def articulationPointDFS(row: int, col: int) -> None:\\n            nonlocal grid, depth, low, parent, numRows, numCols, time, articulationPoint\\n            depth[row][col] = time; time += 1\\n            low[row][col], children = depth[row][col], 0\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                if newRow >= 0 and newRow < numRows and newCol >= 0 and newCol < numCols and grid[newRow][newCol] == 1:\\n                    if depth[newRow][newCol] == -1:\\n                        children += 1\\n                        parent[newRow][newCol] = (row * numCols) + col\\n                        articulationPointDFS(newRow, newCol)\\n                        low[row][col] = min(low[row][col], low[newRow][newCol])\\n                        if low[newRow][newCol] >= depth[row][col] and parent[row][col] > -1:\\n                            articulationPoint = True\\n                    elif newRow * numCols + newCol != parent[row][col]:\\n                        low[row][col] = min(low[row][col], depth[newRow][newCol])\\n            if parent[row][col] == -1 and children > 1:\\n                articulationPoint = True\\n            \\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == 1:\\n                    lands += 1\\n                    if depth[row][col] == -1:\\n                        articulationPointDFS(row, col)\\n                        islands += 1\\n        if islands == 0 or islands >= 2: \\n            return 0\\n        if lands == 1: \\n            return 1\\n        if articulationPoint: \\n            return 1\\n        return 2\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        articulationPoint, time, numRows, numCols = False, 0, len(grid), len(grid[0])\\n        directions, lands, islands = [[1, 0], [-1, 0], [0, 1], [0, -1]], 0, 0\\n        depth = [[-1] * numCols for _ in range(numRows)]\\n        low = [[-1] * numCols for _ in range(numRows)]\\n        parent = [[-1] * numCols for _ in range(numRows)]\\n        \\n        \\n        def articulationPointDFS(row: int, col: int) -> None:\\n            nonlocal grid, depth, low, parent, numRows, numCols, time, articulationPoint\\n            depth[row][col] = time; time += 1\\n            low[row][col], children = depth[row][col], 0\\n            for direction in directions:\\n                newRow, newCol = row + direction[0], col + direction[1]\\n                if newRow >= 0 and newRow < numRows and newCol >= 0 and newCol < numCols and grid[newRow][newCol] == 1:\\n                    if depth[newRow][newCol] == -1:\\n                        children += 1\\n                        parent[newRow][newCol] = (row * numCols) + col\\n                        articulationPointDFS(newRow, newCol)\\n                        low[row][col] = min(low[row][col], low[newRow][newCol])\\n                        if low[newRow][newCol] >= depth[row][col] and parent[row][col] > -1:\\n                            articulationPoint = True\\n                    elif newRow * numCols + newCol != parent[row][col]:\\n                        low[row][col] = min(low[row][col], depth[newRow][newCol])\\n            if parent[row][col] == -1 and children > 1:\\n                articulationPoint = True\\n            \\n        for row in range(numRows):\\n            for col in range(numCols):\\n                if grid[row][col] == 1:\\n                    lands += 1\\n                    if depth[row][col] == -1:\\n                        articulationPointDFS(row, col)\\n                        islands += 1\\n        if islands == 0 or islands >= 2: \\n            return 0\\n        if lands == 1: \\n            return 1\\n        if articulationPoint: \\n            return 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609590,
                "title": "c-o-mn-articulation-point",
                "content": "Beautiful Question , tried AP in 2d matrix .  Need to handle extra case when there is single 1. \\n\\nImplementation took quite efforts , if it helps do upvote ;)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>v;\\n    int count1 = 0;\\n    void dfs(int i,int j,pair<int,int>parent,int timer,vector<vector<int>>& grid,\\n             vector<vector<int>>&visited,vector<vector<int>>&tin,vector<vector<int>>&low)\\n    {\\n        int n = grid.size(),m=grid[0].size();\\n        visited[i][j] = 1;\\n        tin[i][j] = low[i][j] = timer++;\\n        count1++;\\n        //cout<<i<<\" \"<<j<<endl;\\n        vector<int>dx = {0,1,0,-1};\\n        vector<int>dy = {1,0,-1,0};\\n        int child = 0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x = i+dx[k];\\n            int y = j+dy[k];\\n            if(x<0 || y<0 || x>=n || y>=m || grid[x][y] == 0)\\n                    continue;\\n            \\n            else if((x == parent.first && y==parent.second))\\n                continue;\\n            \\n            else if(!visited[x][y])\\n            {\\n                dfs(x,y,{i,j},timer,grid,visited,tin,low);\\n                low[i][j] = min(low[x][y] , low[i][j]);\\n                if(low[x][y] >= tin[i][j] && (parent.first != -1 && parent.second != -1))\\n                {\\n                    v.push_back({i,j});\\n                    //cout<<i<<\" \"<<j;\\n                }\\n                child++;    \\n                \\n            }\\n            else if(visited[x][y])\\n                low[i][j] = min(tin[x][y] , low[i][j]);\\n            \\n            \\n        }\\n        if(parent.first == -1 && parent.second == -1 && child >= 2)\\n        {\\n             v.push_back({i,j});\\n             //cout<<i<<\" \"<<j;\\n        }\\n           \\n        \\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size(),m=grid[0].size();\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        vector<vector<int>>tin(n,vector<int>(m,0));\\n        vector<vector<int>>low(n,vector<int>(m,0));\\n        \\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j] == 1 && !visited[i][j])\\n                {\\n                    dfs(i,j,{-1,-1},1,grid,visited,tin,low);\\n                    count++;\\n                    if(count >= 2)\\n                        return 0;\\n                }\\n            }\\n        }\\n        if(count == 0) \\n            return 0;\\n        \\n        if(count1 == 1 || (count == 1 && v.size() > 0 ) )\\n            return 1;\\n        \\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>v;\\n    int count1 = 0;\\n    void dfs(int i,int j,pair<int,int>parent,int timer,vector<vector<int>>& grid,\\n             vector<vector<int>>&visited,vector<vector<int>>&tin,vector<vector<int>>&low)\\n    {\\n        int n = grid.size(),m=grid[0].size();\\n        visited[i][j] = 1;\\n        tin[i][j] = low[i][j] = timer++;\\n        count1++;\\n        //cout<<i<<\" \"<<j<<endl;\\n        vector<int>dx = {0,1,0,-1};\\n        vector<int>dy = {1,0,-1,0};\\n        int child = 0;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x = i+dx[k];\\n            int y = j+dy[k];\\n            if(x<0 || y<0 || x>=n || y>=m || grid[x][y] == 0)\\n                    continue;\\n            \\n            else if((x == parent.first && y==parent.second))\\n                continue;\\n            \\n            else if(!visited[x][y])\\n            {\\n                dfs(x,y,{i,j},timer,grid,visited,tin,low);\\n                low[i][j] = min(low[x][y] , low[i][j]);\\n                if(low[x][y] >= tin[i][j] && (parent.first != -1 && parent.second != -1))\\n                {\\n                    v.push_back({i,j});\\n                    //cout<<i<<\" \"<<j;\\n                }\\n                child++;    \\n                \\n            }\\n            else if(visited[x][y])\\n                low[i][j] = min(tin[x][y] , low[i][j]);\\n            \\n            \\n        }\\n        if(parent.first == -1 && parent.second == -1 && child >= 2)\\n        {\\n             v.push_back({i,j});\\n             //cout<<i<<\" \"<<j;\\n        }\\n           \\n        \\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size(),m=grid[0].size();\\n        vector<vector<int>>visited(n,vector<int>(m,0));\\n        vector<vector<int>>tin(n,vector<int>(m,0));\\n        vector<vector<int>>low(n,vector<int>(m,0));\\n        \\n        int count = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j] == 1 && !visited[i][j])\\n                {\\n                    dfs(i,j,{-1,-1},1,grid,visited,tin,low);\\n                    count++;\\n                    if(count >= 2)\\n                        return 0;\\n                }\\n            }\\n        }\\n        if(count == 0) \\n            return 0;\\n        \\n        if(count1 == 1 || (count == 1 && v.size() > 0 ) )\\n            return 1;\\n        \\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2522493,
                "title": "c-bfs-code-with-explanation",
                "content": "Initially, the idea is to check the number of disconnected islands. If the count of such islands is NOT 1, then there would be no need to convert a land cell into a water cell to further disconnect the islands. In such cases, we return 0.\\n\\nNow, if there happens to be exactly 1 island in the grid, we convert each land cell into a water cell and check if the main island can be disintegrated into two or more smaller islands. If it is possible, by breaking any such land cell, we return 1.\\n\\nIn all the other cases, it would require (at max) 2 land cells (to be converted to water cells) to break up the main island. In this case, we return 2 :)\\n\\nProof of the last statement: A single disconnected land cell is also an island. Keeping this in mind, in order to break up an island into two (or more islands), we can make a corner land cell disconnected by converting two adjoining land cells into water cells.\\n\\n\\n**C++ Code:**\\n\\n\\n```\\nint dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n    \\n    bool check(vector < vector <int> > &grid, int i, int j, int m, int n) {\\n        return (i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1);\\n    }\\n    \\n    int solve(vector < vector <int> > &grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        vector < vector <bool> > vis(m, vector <bool>(n, false));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] && !vis[i][j]) {\\n                    ans++;\\n                    queue < pair <int, int> > q;\\n                    q.push({i, j});\\n                    vis[i][j] = true;\\n                    \\n                    while(!q.empty()) {\\n                        auto [ux, uy] = q.front();\\n                        q.pop();\\n                        for(int k = 0; k < 4; k++) {\\n                            if(check(grid, ux + dx[k], uy + dy[k], m, n) && !vis[ux + dx[k]][uy + dy[k]]) {\\n                                q.push({ux + dx[k], uy + dy[k]});\\n                                vis[ux + dx[k]][uy + dy[k]] = true;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n      return ans;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int ans = solve(grid), m = grid.size(), n = grid[0].size();\\n        if(ans != 1)\\n            return 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j]) {\\n                    grid[i][j] = 0;\\n                    int val = solve(grid);\\n                    grid[i][j] = 1;\\n                    \\n                    if(val != 1)\\n                        return 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;     \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nint dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};\\n    \\n    bool check(vector < vector <int> > &grid, int i, int j, int m, int n) {\\n        return (i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1);\\n    }\\n    \\n    int solve(vector < vector <int> > &grid) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        vector < vector <bool> > vis(m, vector <bool>(n, false));\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] && !vis[i][j]) {\\n                    ans++;\\n                    queue < pair <int, int> > q;\\n                    q.push({i, j});\\n                    vis[i][j] = true;\\n                    \\n                    while(!q.empty()) {\\n                        auto [ux, uy] = q.front();\\n                        q.pop();\\n                        for(int k = 0; k < 4; k++) {\\n                            if(check(grid, ux + dx[k], uy + dy[k], m, n) && !vis[ux + dx[k]][uy + dy[k]]) {\\n                                q.push({ux + dx[k], uy + dy[k]});\\n                                vis[ux + dx[k]][uy + dy[k]] = true;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n      return ans;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int ans = solve(grid), m = grid.size(), n = grid[0].size();\\n        if(ans != 1)\\n            return 0;\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j]) {\\n                    grid[i][j] = 0;\\n                    int val = solve(grid);\\n                    grid[i][j] = 1;\\n                    \\n                    if(val != 1)\\n                        return 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2518126,
                "title": "python-solution-using-tarjan-s-algorithm-with-explanation",
                "content": "the problem asks how many days to split one island into two, one day can turn one land into water, if there have two or more islands on the grid, return ```0``` day\\nthere are have two cornor cases, disconnected means there are two island on the grid at least or are not any island on the grid, so the solution of  ```[[1,1]]``` and ```[[1]]``` is to turn all the land into water.\\n\\nthe basic idea is to calculate how many islands on the grid first, then build undirected graph, and use Tarjan\\'s algo to detect whether the graph has critical edge or not, if have, return ```1```, if not return ```2``` to split the corner of the island\\n\\ntc of tarjan is ```O(V+E)```, ```E = 4V```, is ```O(5V)```, the upper bound of ```V``` is ```O(len(grid) * len(grid[0]))```, so tc actually is ```O(len(grid) * len(grid[0]))```, its sc is the same as tc\\n\\nbased on [200. Number of Islands solution](https://leetcode.com/problems/number-of-islands/discuss/2504106/python-dfsbfs-and-dsu-solution-with-explanation)\\ntc of finding number of island is ```O(len(grid) * len(grid[0]))```, its sc is the same as tc.\\nso total tc is ```O(len(grid) * len(grid[0]))```, total sc is the same as tc\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        numRow, numCol = len(grid), len(grid[0])\\n\\n        def numberOfIsland():\\n            directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n            visited, ans, count = [[False]*numCol for _ in range(numRow)], 0, 0\\n            def dfs(i, j):\\n                nonlocal count\\n                visited[i][j] = True\\n                count += 1\\n                for dx, dy in directions:\\n                    nx, ny = i+dx, j+dy\\n                    if nx<0 or ny<0 or nx>=numRow or ny>=numCol or visited[nx][ny] or grid[nx][ny]==0: continue\\n                    dfs(nx, ny)\\n            for i in range(numRow):\\n                for j in range(numCol):\\n                    if grid[i][j] == 1 and visited[i][j] == False:\\n                        dfs(i, j)\\n                        ans += 1\\n            return ans, count\\n\\n        num, countOf1 = numberOfIsland()\\n        if num != 1: return 0\\n        elif countOf1 == 1: return 1 #  num == 1\\n        elif countOf1 == 2: return 2 #  num == 1\\n\\n        # build undirected graph\\n        def buildGraph():\\n            graph = {}\\n            directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n            for i in range(numRow):\\n                for j in range(numCol):\\n                    if grid[i][j] == 1:\\n                        cur = i*numCol+j\\n                        graph[cur] = []\\n                        for dx, dy in directions:\\n                            nx, ny = i+dx, j+dy\\n                            if nx<0 or ny<0 or nx>=numRow or ny>=numCol or grid[nx][ny]==0: continue\\n                            neighbor = nx*numCol+ny\\n                            graph[cur].append(neighbor)\\n            return graph\\n\\n        graph = buildGraph()\\n        def Tarjan(graph, root):\\n            # the graph has not isolated nodes or node groups\\n            hasCriticalEdge = False\\n            def dfs(previous, current, time, timeMap, visited):\\n                nonlocal hasCriticalEdge\\n                visited.add(current)\\n                timeMap[current] = time\\n                for nei in graph[current]:\\n                    if nei == previous: continue\\n                    if nei not in visited: dfs(current, nei, time+1, timeMap, visited)\\n                    if time < timeMap[nei]: hasCriticalEdge = True\\n                    timeMap[current] = min(timeMap[nei], timeMap[current])\\n            \\n            dfs(-1, root, 1, {}, set())\\n            return hasCriticalEdge\\n        hasCriticalEdge = Tarjan(graph, list(graph.keys())[0])\\n\\n        return 1 if hasCriticalEdge else 2\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```0```\n```[[1,1]]```\n```[[1]]```\n```1```\n```2```\n```O(V+E)```\n```E = 4V```\n```O(5V)```\n```V```\n```O(len(grid) * len(grid[0]))```\n```O(len(grid) * len(grid[0]))```\n```O(len(grid) * len(grid[0]))```\n```O(len(grid) * len(grid[0]))```\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        numRow, numCol = len(grid), len(grid[0])\\n\\n        def numberOfIsland():\\n            directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n            visited, ans, count = [[False]*numCol for _ in range(numRow)], 0, 0\\n            def dfs(i, j):\\n                nonlocal count\\n                visited[i][j] = True\\n                count += 1\\n                for dx, dy in directions:\\n                    nx, ny = i+dx, j+dy\\n                    if nx<0 or ny<0 or nx>=numRow or ny>=numCol or visited[nx][ny] or grid[nx][ny]==0: continue\\n                    dfs(nx, ny)\\n            for i in range(numRow):\\n                for j in range(numCol):\\n                    if grid[i][j] == 1 and visited[i][j] == False:\\n                        dfs(i, j)\\n                        ans += 1\\n            return ans, count\\n\\n        num, countOf1 = numberOfIsland()\\n        if num != 1: return 0\\n        elif countOf1 == 1: return 1 #  num == 1\\n        elif countOf1 == 2: return 2 #  num == 1\\n\\n        # build undirected graph\\n        def buildGraph():\\n            graph = {}\\n            directions = [[1,0],[-1,0],[0,1],[0,-1]]\\n            for i in range(numRow):\\n                for j in range(numCol):\\n                    if grid[i][j] == 1:\\n                        cur = i*numCol+j\\n                        graph[cur] = []\\n                        for dx, dy in directions:\\n                            nx, ny = i+dx, j+dy\\n                            if nx<0 or ny<0 or nx>=numRow or ny>=numCol or grid[nx][ny]==0: continue\\n                            neighbor = nx*numCol+ny\\n                            graph[cur].append(neighbor)\\n            return graph\\n\\n        graph = buildGraph()\\n        def Tarjan(graph, root):\\n            # the graph has not isolated nodes or node groups\\n            hasCriticalEdge = False\\n            def dfs(previous, current, time, timeMap, visited):\\n                nonlocal hasCriticalEdge\\n                visited.add(current)\\n                timeMap[current] = time\\n                for nei in graph[current]:\\n                    if nei == previous: continue\\n                    if nei not in visited: dfs(current, nei, time+1, timeMap, visited)\\n                    if time < timeMap[nei]: hasCriticalEdge = True\\n                    timeMap[current] = min(timeMap[nei], timeMap[current])\\n            \\n            dfs(-1, root, 1, {}, set())\\n            return hasCriticalEdge\\n        hasCriticalEdge = Tarjan(graph, list(graph.keys())[0])\\n\\n        return 1 if hasCriticalEdge else 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461127,
                "title": "javascript-dfs-count-the-islands",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minDays = function(grid) {\\n    let cnt = numIslands(grid);\\n    console.log(cnt);\\n    if(cnt === 0 || cnt > 1) { // all water or multi-islands\\n        return 0;\\n    }\\n    // check if need to return 1\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let islands = 0;\\n    for(let i = 0; i<m; i++)\\n        for(let j = 0; j<n; j++){\\n            if(grid[i][j] === 1) {\\n                grid[i][j] = 0;\\n                count = numIslands(grid);\\n                console.log(\"count =\", count);\\n                if(count > 1 || count ===0) {\\n                    return 1;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n    return 2;\\n};\\n\\nfunction numIslands(grid) {\\n    const dir = [[1,0], [0,1],[0,-1], [-1,0]];\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = new Array(m).fill(0).map(el=>new Array(n).fill(false));\\n    let islands = 0;\\n    for(let i = 0; i<m; i++){\\n        for(let j = 0; j<n; j++) {\\n            if(grid[i][j] === 1 && !visited[i][j]){\\n                islands++;\\n                dfs(grid, i, j);\\n            }\\n        }\\n    }\\n    function dfs(arr, x, y) {\\n        visited[x][y] = true;\\n        for(const d of dir) {\\n            const xx = x + d[0];\\n            const yy = y + d[1];\\n            if(xx<0 || xx>=m || yy<0 || yy>=n || grid[xx][yy] !== 1 || visited[xx][yy]) {\\n              continue;\\n            }\\n            dfs(arr, xx ,yy);\\n        }\\n    }\\n    return islands;   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minDays = function(grid) {\\n    let cnt = numIslands(grid);\\n    console.log(cnt);\\n    if(cnt === 0 || cnt > 1) { // all water or multi-islands\\n        return 0;\\n    }\\n    // check if need to return 1\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let islands = 0;\\n    for(let i = 0; i<m; i++)\\n        for(let j = 0; j<n; j++){\\n            if(grid[i][j] === 1) {\\n                grid[i][j] = 0;\\n                count = numIslands(grid);\\n                console.log(\"count =\", count);\\n                if(count > 1 || count ===0) {\\n                    return 1;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n    return 2;\\n};\\n\\nfunction numIslands(grid) {\\n    const dir = [[1,0], [0,1],[0,-1], [-1,0]];\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    const visited = new Array(m).fill(0).map(el=>new Array(n).fill(false));\\n    let islands = 0;\\n    for(let i = 0; i<m; i++){\\n        for(let j = 0; j<n; j++) {\\n            if(grid[i][j] === 1 && !visited[i][j]){\\n                islands++;\\n                dfs(grid, i, j);\\n            }\\n        }\\n    }\\n    function dfs(arr, x, y) {\\n        visited[x][y] = true;\\n        for(const d of dir) {\\n            const xx = x + d[0];\\n            const yy = y + d[1];\\n            if(xx<0 || xx>=m || yy<0 || yy>=n || grid[xx][yy] !== 1 || visited[xx][yy]) {\\n              continue;\\n            }\\n            dfs(arr, xx ,yy);\\n        }\\n    }\\n    return islands;   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2427209,
                "title": "articulation-point",
                "content": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int>adj[n*m];\\n        int dif[]={0,1,0,-1,0};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]){\\n                    for(int k=0;k<4;k++){\\n                        int r=i+dif[k],c=j+dif[k+1];\\n                        if(r>=0 && r<n && c>=0 && c<m && grid[r][c]){\\n                            adj[i*m+j].push_back(r*m+c);\\n                            adj[r*m+c].push_back(i*m+j);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    vector<int> tin(n*m, -1);\\n\\tvector<int> low(n*m, -1); \\n\\tvector<int> vis(n*m, 0);\\n\\tvector<int> isArticulation(n*m, 0); \\n\\tint timer = 0; \\n        int land=0;\\n        int bodies=0;\\n\\tfor(int i = 0;i<n;i++) {\\n        for(int j=0;j<m;j++){\\n\\t    if(grid[i][j]) {\\n            land++;\\n            if(!vis[i*m+j]){\\n                bodies++;\\n                dfs(i*m+j, -1, vis, tin, low, timer, adj, isArticulation); \\n            }\\n\\t       \\n\\t    }\\n        }\\n\\t}\\n        cout<<land<<endl;\\n\\tif(bodies==0 || bodies>1) return 0;\\n        int art=0;\\n\\tfor(int i = 0;i<n*m;i++) {\\n\\t    if(isArticulation[i] == 1) art++;\\n\\t}\\n    if(art || land==1) return 1;\\n    \\n        return 2;\\n        \\n    }\\n    void dfs(int node, int parent, vector<int> &vis, vector<int> &tin, vector<int> &low, int &timer, vector<int> adj[], vector<int> &isArticulation) {\\n    vis[node] = 1; \\n    tin[node] = low[node] = timer++;\\n    int child = 0; \\n    for(auto it: adj[node]) {\\n        if(it == parent) continue;\\n        \\n        if(!vis[it]) {\\n            dfs(it, node, vis, tin, low, timer, adj, isArticulation); \\n            low[node] = min(low[node], low[it]); \\n\\t    child++; \\n            if(low[it] >= tin[node] && parent != -1) {\\n                isArticulation[node] = 1; \\n            }\\n        } else {\\n            low[node] = min(low[node], tin[it]); \\n        }\\n    }\\n    \\n    if(parent == -1 && child > 1) {\\n        isArticulation[node] = 1; \\n    }\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<int>adj[n*m];\\n        int dif[]={0,1,0,-1,0};\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]){\\n                    for(int k=0;k<4;k++){\\n                        int r=i+dif[k],c=j+dif[k+1];\\n                        if(r>=0 && r<n && c>=0 && c<m && grid[r][c]){\\n                            adj[i*m+j].push_back(r*m+c);\\n                            adj[r*m+c].push_back(i*m+j);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    vector<int> tin(n*m, -1);\\n\\tvector<int> low(n*m, -1); \\n\\tvector<int> vis(n*m, 0);\\n\\tvector<int> isArticulation(n*m, 0); \\n\\tint timer = 0; \\n        int land=0;\\n        int bodies=0;\\n\\tfor(int i = 0;i<n;i++) {\\n        for(int j=0;j<m;j++){\\n\\t    if(grid[i][j]) {\\n            land++;\\n            if(!vis[i*m+j]){\\n                bodies++;\\n                dfs(i*m+j, -1, vis, tin, low, timer, adj, isArticulation); \\n            }\\n\\t       \\n\\t    }\\n        }\\n\\t}\\n        cout<<land<<endl;\\n\\tif(bodies==0 || bodies>1) return 0;\\n        int art=0;\\n\\tfor(int i = 0;i<n*m;i++) {\\n\\t    if(isArticulation[i] == 1) art++;\\n\\t}\\n    if(art || land==1) return 1;\\n    \\n        return 2;\\n        \\n    }\\n    void dfs(int node, int parent, vector<int> &vis, vector<int> &tin, vector<int> &low, int &timer, vector<int> adj[], vector<int> &isArticulation) {\\n    vis[node] = 1; \\n    tin[node] = low[node] = timer++;\\n    int child = 0; \\n    for(auto it: adj[node]) {\\n        if(it == parent) continue;\\n        \\n        if(!vis[it]) {\\n            dfs(it, node, vis, tin, low, timer, adj, isArticulation); \\n            low[node] = min(low[node], low[it]); \\n\\t    child++; \\n            if(low[it] >= tin[node] && parent != -1) {\\n                isArticulation[node] = 1; \\n            }\\n        } else {\\n            low[node] = min(low[node], tin[it]); \\n        }\\n    }\\n    \\n    if(parent == -1 && child > 1) {\\n        isArticulation[node] = 1; \\n    }\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2386377,
                "title": "c-solution-using-brute-force-and-dfs",
                "content": "In this solution, I first created a graph with vertices as those cells having 1 and edges are such that two vertices have an edge between them iff their corresponding cells are neighbours horizontally or vertically.\\n\\nFirst, I performed a DFS to check if graph is already disconnected. If it is, ```return 0;```. If not, I checked whether removing any one vertex disconnects the graph. This is done by actually removing every vertex and checking if graph gets disconnected. If it does, ```return 1;```. If not, ```return 2``` as we can make the graph disconnected by removing at most 2 vertices.\\n\\nHere\\'s the code:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& visited, int m, int n, vector<int> start){\\n        int i = start[0];\\n        int j = start[1];\\n        visited[i][j] = 1;\\n        if (i != 0){\\n            if (visited[i - 1][j] == 0){\\n                vector<int> next = {i - 1, j};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (i != m - 1){\\n            if (visited[i + 1][j] == 0){\\n                vector<int> next = {i + 1, j};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (j != 0){\\n            if (visited[i][j - 1] == 0){\\n                vector<int> next = {i, j - 1};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (j != n - 1){\\n            if (visited[i][j + 1] == 0){\\n                vector<int> next = {i, j + 1};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        vector<vector<int>> visited;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for (int i = 0; i < m; i++){\\n            vector<int> row;\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1) row.push_back(0);\\n                else row.push_back(-1);\\n            }\\n            visited.push_back(row);\\n        }\\n        vector<int> start;\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1){\\n                    start.push_back(i);\\n                    start.push_back(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if (start.size() == 0) return 0;\\n        dfs(visited, m, n, start);\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (visited[i][j] == 0) return 0;\\n            }\\n        }\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                for (int k = 0; k < m; k++){\\n                    for (int l = 0; l < n; l++){\\n                        if (grid[k][l] == 1){\\n                            if (k == i && l == j) visited[k][l] = -1;\\n                            else visited[k][l] = 0;\\n                        }\\n                        else visited[k][l] = -1;\\n                    }\\n                }\\n                vector<int> start1;\\n                for (int k = 0; k < m; k++){\\n                    for (int l = 0; l < n; l++){\\n                        if (visited[k][l] == 0){\\n                            start1.push_back(k);\\n                            start1.push_back(l);\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (start1.size() == 0) return 1;\\n                dfs(visited, m, n, start1);\\n                for (int i = 0; i < m; i++){\\n                    for (int j = 0; j < n; j++){\\n                        if (visited[i][j] == 0) return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```return 0;```\n```return 1;```\n```return 2```\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& visited, int m, int n, vector<int> start){\\n        int i = start[0];\\n        int j = start[1];\\n        visited[i][j] = 1;\\n        if (i != 0){\\n            if (visited[i - 1][j] == 0){\\n                vector<int> next = {i - 1, j};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (i != m - 1){\\n            if (visited[i + 1][j] == 0){\\n                vector<int> next = {i + 1, j};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (j != 0){\\n            if (visited[i][j - 1] == 0){\\n                vector<int> next = {i, j - 1};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        if (j != n - 1){\\n            if (visited[i][j + 1] == 0){\\n                vector<int> next = {i, j + 1};\\n                dfs(visited, m, n, next);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        vector<vector<int>> visited;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for (int i = 0; i < m; i++){\\n            vector<int> row;\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1) row.push_back(0);\\n                else row.push_back(-1);\\n            }\\n            visited.push_back(row);\\n        }\\n        vector<int> start;\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] == 1){\\n                    start.push_back(i);\\n                    start.push_back(j);\\n                    break;\\n                }\\n            }\\n        }\\n        if (start.size() == 0) return 0;\\n        dfs(visited, m, n, start);\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (visited[i][j] == 0) return 0;\\n            }\\n        }\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                for (int k = 0; k < m; k++){\\n                    for (int l = 0; l < n; l++){\\n                        if (grid[k][l] == 1){\\n                            if (k == i && l == j) visited[k][l] = -1;\\n                            else visited[k][l] = 0;\\n                        }\\n                        else visited[k][l] = -1;\\n                    }\\n                }\\n                vector<int> start1;\\n                for (int k = 0; k < m; k++){\\n                    for (int l = 0; l < n; l++){\\n                        if (visited[k][l] == 0){\\n                            start1.push_back(k);\\n                            start1.push_back(l);\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (start1.size() == 0) return 1;\\n                dfs(visited, m, n, start1);\\n                for (int i = 0; i < m; i++){\\n                    for (int j = 0; j < n; j++){\\n                        if (visited[i][j] == 0) return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357360,
                "title": "c-articulation-point",
                "content": "public class Solution {\\n    int m,n;\\n    bool[,] visited;\\n    int[,] id;\\n    int[,] low;\\n    int[][] grid;\\n    int numOfOutEdge=0;\\n    bool[,] art;\\n    int numOfComponents=0;\\n    (int di,int dj)[] dir=new (int di,int dj)[4]{(1,0),(-1,0),(0,1),(0,-1)};\\n    int idc=0;\\n    int artcount=0;\\n    public int MinDays(int[][] grid) {\\n        m=grid.Length;\\n        n=grid[0].Length;\\n        visited=new bool[m,n];\\n        low=new int[m,n];\\n        id=new int[m,n];\\n        art=new bool[m,n];\\n        this.grid=grid;\\n        \\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                numOfOutEdge=0;\\n                if(!visited[i,j] &&  grid[i][j]==1){\\n\\n                    dfs((i,j),(i,j),(-1,-1) );\\n                    if(art[i,j] && numOfOutEdge<=1){\\n                        artcount--;\\n                        art[i,j]=false;\\n                    }\\n                    numOfComponents++;\\n                }\\n                if(numOfComponents>1)\\n                    return 0;\\n                \\n\\n            }\\n            if(artcount>0)\\n                    return 1;\\n                else \\n                    return Math.Min(2,idc);\\n        \\n\\n    }\\n    \\n    public void dfs((int i,int j) root, (int i,int j) at,(int i,int j) parent)\\n    {\\n        \\n        if((root.i==parent.i ) && (root.j==parent.j))\\n            numOfOutEdge++;\\n        idc++;\\n        id[at.i,at.j]=low[at.i,at.j]=idc;\\n        visited[at.i,at.j]=true;\\n        \\n        for(int d=0;d<4;d++)\\n        {\\n            (int i,int j) next=(at.i+dir[d].di,at.j+dir[d].dj);\\n            if(!isValidNode(next) || (next.i==parent.i && next.j==parent.j) || grid[next.i][next.j]!=1)\\n                continue;\\n\\n            if(visited[next.i,next.j]){\\n                low[at.i,at.j]=Math.Min(low[at.i,at.j],id[next.i,next.j]);\\n\\n            }\\n            else\\n            {\\n                dfs(root,next,at);\\n                low[at.i,at.j]=Math.Min(low[at.i,at.j],low[next.i,next.j]);\\n                if(low[next.i,next.j]>=id[at.i,at.j]){\\n                    art[at.i,at.j]=true;\\n                    artcount++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool isValidNode((int i,int j) node)\\n    {\\n        if(node.i>=m || node.i<0 || node.j>=n || node.j<0)\\n            return false;\\n        return true;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int m,n;\\n    bool[,] visited;\\n    int[,] id;\\n    int[,] low;\\n    int[][] grid;\\n    int numOfOutEdge=0;\\n    bool[,] art;\\n    int numOfComponents=0;\\n    (int di,int dj)[] dir=new (int di,int dj)[4]{(1,0),(-1,0),(0,1),(0,-1)}",
                "codeTag": "Java"
            },
            {
                "id": 2349070,
                "title": "92-76-fast-easy-to-understand-c-solution-using-articulation-points-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> steps = {{-1,0}, {1,0}, {0,-1}, {0,1}}; \\n    \\n    bool check(int r, int c, int n, int m)\\n    {\\n        return (r>=0 && r<n && c>=0 && c<m);\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, int r, int c, vector<vector<bool>>& vis, vector<vector<int>>& disc, vector<vector<int>>& low, int &isAp, int &timer, vector<vector<pair<int, int>>>& parent, int parR, int parC, int n, int m)\\n    {\\n        vis[r][c] = true;\\n        disc[r][c] = low[r][c] = ++timer;\\n        parent[r][c] = {parR, parC};\\n        int child = 0;\\n        \\n        for(auto x: steps)\\n        {\\n            int a = r + x.first;\\n            int b = c + x.second;\\n            \\n            if(check(a, b, n, m) && grid[a][b] == 1)\\n            {\\n                if(!vis[a][b])\\n                {\\n                    child++;\\n            \\n                    dfs(grid, a, b, vis, disc, low, isAp, timer, parent, r, c, n, m);\\n                    low[r][c] = min(low[r][c], low[a][b]);\\n                    \\n                    if((parent[r][c].first !=-1 && parent[r][c].second !=-1) && low[a][b] >= disc[r][c])\\n                        isAp = 1;\\n                }\\n                \\n                else if(a != parent[r][c].first || b != parent[r][c].second)\\n                {\\n                    low[r][c] = min(low[r][c], disc[a][b]);\\n                }\\n            }\\n        }\\n        \\n        if(child > 1 && parent[r][c].first == -1 && parent[r][c].second == -1)\\n            isAp = 1;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int sum = 0;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j])\\n                    sum++;\\n            }\\n        \\n        if(sum == 1)\\n            return 1;\\n        if(sum == 0)\\n            return 0;\\n        if(sum == m*n)\\n            return 2;\\n        \\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        vector<vector<int>> disc(n, vector<int>(m, 0));\\n        vector<vector<int>> low(n, vector<int>(m, 0));\\n        \\n        vector<vector<pair<int, int>>> parent(n, vector<pair<int,int>>(m));\\n        \\n        int timer = 0;\\n        int isAp = 0;\\n        \\n        int count = 0;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]==1 && !vis[i][j])\\n                {\\n                    count++;\\n                    if(count>1)\\n                        return 0;\\n                    \\n                    dfs(grid, i, j, vis, disc, low, isAp, timer, parent, -1, -1, n, m);\\n                }\\n            }\\n        \\n        if(isAp == 1)\\n            return 1;\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> steps = {{-1,0}, {1,0}, {0,-1}, {0,1}}; \\n    \\n    bool check(int r, int c, int n, int m)\\n    {\\n        return (r>=0 && r<n && c>=0 && c<m);\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid, int r, int c, vector<vector<bool>>& vis, vector<vector<int>>& disc, vector<vector<int>>& low, int &isAp, int &timer, vector<vector<pair<int, int>>>& parent, int parR, int parC, int n, int m)\\n    {\\n        vis[r][c] = true;\\n        disc[r][c] = low[r][c] = ++timer;\\n        parent[r][c] = {parR, parC};\\n        int child = 0;\\n        \\n        for(auto x: steps)\\n        {\\n            int a = r + x.first;\\n            int b = c + x.second;\\n            \\n            if(check(a, b, n, m) && grid[a][b] == 1)\\n            {\\n                if(!vis[a][b])\\n                {\\n                    child++;\\n            \\n                    dfs(grid, a, b, vis, disc, low, isAp, timer, parent, r, c, n, m);\\n                    low[r][c] = min(low[r][c], low[a][b]);\\n                    \\n                    if((parent[r][c].first !=-1 && parent[r][c].second !=-1) && low[a][b] >= disc[r][c])\\n                        isAp = 1;\\n                }\\n                \\n                else if(a != parent[r][c].first || b != parent[r][c].second)\\n                {\\n                    low[r][c] = min(low[r][c], disc[a][b]);\\n                }\\n            }\\n        }\\n        \\n        if(child > 1 && parent[r][c].first == -1 && parent[r][c].second == -1)\\n            isAp = 1;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int sum = 0;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j])\\n                    sum++;\\n            }\\n        \\n        if(sum == 1)\\n            return 1;\\n        if(sum == 0)\\n            return 0;\\n        if(sum == m*n)\\n            return 2;\\n        \\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        vector<vector<int>> disc(n, vector<int>(m, 0));\\n        vector<vector<int>> low(n, vector<int>(m, 0));\\n        \\n        vector<vector<pair<int, int>>> parent(n, vector<pair<int,int>>(m));\\n        \\n        int timer = 0;\\n        int isAp = 0;\\n        \\n        int count = 0;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]==1 && !vis[i][j])\\n                {\\n                    count++;\\n                    if(count>1)\\n                        return 0;\\n                    \\n                    dfs(grid, i, j, vis, disc, low, isAp, timer, parent, -1, -1, n, m);\\n                }\\n            }\\n        \\n        if(isAp == 1)\\n            return 1;\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339859,
                "title": "javascript-flood-fill-algorithm",
                "content": "```\\nvar minDays = function(grid) {\\n    let c=copy2Darray(grid);\\n    //console.log(c)\\n    let tmp=bfs(c);\\n    //console.log(\\'xxxx\\', tmp)\\n    if(tmp>1 || tmp==0){//\\u984C\\u610F\\u5DF2\\u7D93\\u662F\\u5206\\u96E2\\u7684\\u5CF6\\u4E86   \\n        return 0;\\n    }\\n\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j]==1){\\n                grid[i][j]=0;//\\u8A2D\\u70BA0\\n                let clone=copy2Darray(grid);\\n                let res=bfs(clone);\\n                console.log(i,j,\\'-->\\', res)\\n                if(res != 1) //\\u53EF\\u4EE5\\u4F7F\\u5CF6\\u5206\\u62101\\u500B\\u4EE5\\u4E0A\\n                    return 1;\\n                grid[i][j]=1;//\\u5FA9\\u539F\\n            }\\n        }\\n    }\\n    return 2;\\n\\n    function copy2Darray(a){\\n        let b=[];\\n        for(let i=0; i<a.length; i++){\\n            let t=[];\\n            for(let j=0; j<a[0].length; j++){\\n                t.push(a[i][j]);\\n            }\\n            b.push(t);\\n        }\\n        return b;\\n    }\\n    \\n    function bfs(gr){//\\u4F7F\\u7528flood fill, \\u6AA2\\u67E5\\u76E4\\u9762\\u4E0A\\u7684\\u5CF6\\u662F\\u4E00\\u500B\\u6216\\u5927\\u65BC\\u4E00\\u500B\\n        console.log(gr)\\n        let numberOfIslands=0;\\n        let dirs=[[-1,0],[1,0],[0,1],[0,-1]];\\n        for(let m=0; m<gr.length; m++){\\n            for(let n=0; n<gr[0].length; n++){\\n                if(gr[m][n]==1){\\n                    numberOfIslands++; //\\u7279\\u5225\\u7684\\u5730\\u65B9\\n                    if(numberOfIslands>1)\\n                        return numberOfIslands;\\n                    gr[m][n]=0;\\n                    let nc=[[m,n]];\\n                    while(nc.length>0){\\n                        let nb=nc;\\n                        nc=[];\\n                        for(let [x,y] of nb){\\n                            for(let [i,j] of dirs){\\n                                if(x+i<0 || x+i>=gr.length || y+j<0 || y+j>=gr[0].length || gr[x+i][y+j]==0)\\n                                    continue;\\n                                gr[x+i][y+j]=0;\\n                                nc.push([x+i, y+j]);\\n                            }                                \\n                        }\\n                    }\\n                }                                   \\n            }\\n        }\\n        return numberOfIslands;\\n    }   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDays = function(grid) {\\n    let c=copy2Darray(grid);\\n    //console.log(c)\\n    let tmp=bfs(c);\\n    //console.log(\\'xxxx\\', tmp)\\n    if(tmp>1 || tmp==0){//\\u984C\\u610F\\u5DF2\\u7D93\\u662F\\u5206\\u96E2\\u7684\\u5CF6\\u4E86   \\n        return 0;\\n    }\\n\\n    for(let i=0; i<grid.length; i++){\\n        for(let j=0; j<grid[0].length; j++){\\n            if(grid[i][j]==1){\\n                grid[i][j]=0;//\\u8A2D\\u70BA0\\n                let clone=copy2Darray(grid);\\n                let res=bfs(clone);\\n                console.log(i,j,\\'-->\\', res)\\n                if(res != 1) //\\u53EF\\u4EE5\\u4F7F\\u5CF6\\u5206\\u62101\\u500B\\u4EE5\\u4E0A\\n                    return 1;\\n                grid[i][j]=1;//\\u5FA9\\u539F\\n            }\\n        }\\n    }\\n    return 2;\\n\\n    function copy2Darray(a){\\n        let b=[];\\n        for(let i=0; i<a.length; i++){\\n            let t=[];\\n            for(let j=0; j<a[0].length; j++){\\n                t.push(a[i][j]);\\n            }\\n            b.push(t);\\n        }\\n        return b;\\n    }\\n    \\n    function bfs(gr){//\\u4F7F\\u7528flood fill, \\u6AA2\\u67E5\\u76E4\\u9762\\u4E0A\\u7684\\u5CF6\\u662F\\u4E00\\u500B\\u6216\\u5927\\u65BC\\u4E00\\u500B\\n        console.log(gr)\\n        let numberOfIslands=0;\\n        let dirs=[[-1,0],[1,0],[0,1],[0,-1]];\\n        for(let m=0; m<gr.length; m++){\\n            for(let n=0; n<gr[0].length; n++){\\n                if(gr[m][n]==1){\\n                    numberOfIslands++; //\\u7279\\u5225\\u7684\\u5730\\u65B9\\n                    if(numberOfIslands>1)\\n                        return numberOfIslands;\\n                    gr[m][n]=0;\\n                    let nc=[[m,n]];\\n                    while(nc.length>0){\\n                        let nb=nc;\\n                        nc=[];\\n                        for(let [x,y] of nb){\\n                            for(let [i,j] of dirs){\\n                                if(x+i<0 || x+i>=gr.length || y+j<0 || y+j>=gr[0].length || gr[x+i][y+j]==0)\\n                                    continue;\\n                                gr[x+i][y+j]=0;\\n                                nc.push([x+i, y+j]);\\n                            }                                \\n                        }\\n                    }\\n                }                                   \\n            }\\n        }\\n        return numberOfIslands;\\n    }   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2332541,
                "title": "easy-c-solution-articulation-points-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int row[4] = {-1,1,0,0};\\n    int col[4] = {0,0,-1,1};\\n    int in[31][31] , lw[31][31] , vis[31][31];\\n    bool artpt = false;\\n    int time = 0;\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        memset(vis,0,sizeof(vis));\\n        int bodies = 0 , land = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                  if(grid[i][j]==1) {\\n                       land++;\\n                       if(!vis[i][j]) {\\n                           bodies++;\\n                           dfs(i,j,-1,-1,grid,n,m);\\n                       }\\n                  }\\n            }\\n        }\\n        if(bodies == 0 || bodies>1) return 0;  // no body or more than one body , already disconnected (more than one island)\\n        else if(artpt || land==1) return 1;  // articulation pt or a single patch of land found , just remove that node!\\n        else return 2;  // otherwise its a ssc (strongly connected component) remove two nodes , one node each day , hence 2 days !\\n    }\\n\\t// learn about how to find articulation points!\\n\\t// https://youtu.be/y8hoABkFbT8\\n    void dfs(int r,int c,int pr,int pc,vector<vector<int>>&grid,int n,int m) {\\n          vis[r][c] = true;\\n          in[r][c] = lw[r][c] = ++time;\\n          int children = 0;\\n          for(int d=0; d<4; d++) {\\n               int R = r + row[d] , C = c + col[d];\\n               if(R>=0 && R<n && C>=0 && C<m && grid[R][C]) {\\n                      if(!vis[R][C]) {\\n                          children++;\\n                          dfs(R,C,r,c,grid,n,m);\\n                          lw[r][c] = min(lw[r][c],lw[R][C]);\\n                          if(in[r][c]<=lw[R][C] && pr!=-1) artpt = true;\\n                      }else {\\n                          lw[r][c] = min(lw[r][c],in[R][C]);\\n                      }\\n               }\\n          }\\n        if(pr == -1 && children>1) artpt = true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int row[4] = {-1,1,0,0};\\n    int col[4] = {0,0,-1,1};\\n    int in[31][31] , lw[31][31] , vis[31][31];\\n    bool artpt = false;\\n    int time = 0;\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size();\\n        memset(vis,0,sizeof(vis));\\n        int bodies = 0 , land = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                  if(grid[i][j]==1) {\\n                       land++;\\n                       if(!vis[i][j]) {\\n                           bodies++;\\n                           dfs(i,j,-1,-1,grid,n,m);\\n                       }\\n                  }\\n            }\\n        }\\n        if(bodies == 0 || bodies>1) return 0;  // no body or more than one body , already disconnected (more than one island)\\n        else if(artpt || land==1) return 1;  // articulation pt or a single patch of land found , just remove that node!\\n        else return 2;  // otherwise its a ssc (strongly connected component) remove two nodes , one node each day , hence 2 days !\\n    }\\n\\t// learn about how to find articulation points!\\n\\t// https://youtu.be/y8hoABkFbT8\\n    void dfs(int r,int c,int pr,int pc,vector<vector<int>>&grid,int n,int m) {\\n          vis[r][c] = true;\\n          in[r][c] = lw[r][c] = ++time;\\n          int children = 0;\\n          for(int d=0; d<4; d++) {\\n               int R = r + row[d] , C = c + col[d];\\n               if(R>=0 && R<n && C>=0 && C<m && grid[R][C]) {\\n                      if(!vis[R][C]) {\\n                          children++;\\n                          dfs(R,C,r,c,grid,n,m);\\n                          lw[r][c] = min(lw[r][c],lw[R][C]);\\n                          if(in[r][c]<=lw[R][C] && pr!=-1) artpt = true;\\n                      }else {\\n                          lw[r][c] = min(lw[r][c],in[R][C]);\\n                      }\\n               }\\n          }\\n        if(pr == -1 && children>1) artpt = true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317942,
                "title": "c-simple-solution-with-hint-explanation",
                "content": "Hint:- \\nonly these cases are possible suppose you are on the position (x, y) than\\n1- already two island so, return 0 in this case\\n2- one island but have <= 2 blocks return cnt of blocks\\n3- make island (x, y) unconnected i.e. go all 4 direction and if there is a 1 then add it to your temp-ans (final ans will be min of temp-ans)\\n4- remove this island (x, y) and check if it is now unconnected or not. If it is then return 1\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int xx[4] = {0, 0, 1, -1};\\n    int yy[4] = {1, -1, 0, 0};\\n    \\n    int n, m;\\n    vector<vector<int>> g, vis;\\n    \\n    bool cango(int x, int y){\\n        if(x < 0 || x >= n) return false;\\n        if(y < 0 || y >= m) return false;\\n        if(g[x][y] == 0) return false;\\n        return true;\\n    }\\n    \\n    int ans = INT_MAX;\\n    int cnt = 0;\\n    \\n    int tdfs(int x, int y, vector<vector<int>>&tgrid, vector<vector<int>>&tvis){\\n        int ct = 0;\\n        for(int i=0;i<4;i++){\\n            int nx = x + xx[i];\\n            int ny = y + yy[i];\\n            \\n            if(cango(nx, ny) && tgrid[nx][ny] == 1 && tvis[nx][ny] == 0){\\n                tvis[nx][ny] = 1;\\n                ct += tdfs(nx, ny, tgrid, tvis);\\n            }\\n        }\\n        \\n        return ct + 1;\\n    }\\n    \\n    bool tryremove(int x, int y){\\n        vector<vector<int>> tgrid = g;\\n        vector<vector<int>> tvis(n, vector<int>(m, 0));\\n        int tcnt = cnt - 1;\\n        \\n        tgrid[x][y] = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(tgrid[i][j] == 1){\\n                    tvis[i][j] = 1;\\n                    int tcntx = tdfs(i, j, tgrid, tvis);\\n                    // cout<<tcntx<<\" - \"<<tcnt<<endl;\\n                    if(tcntx == tcnt) return false;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int dfs(int x, int y){\\n        \\n        int temp = 0;\\n        int ct = 0;\\n        for(int i=0;i<4;i++){\\n            int nx = x + xx[i];\\n            int ny = y + yy[i];\\n            if(cango(nx, ny)){ \\n                temp++;\\n                if(vis[nx][ny] == 0){\\n                    vis[nx][ny] = 1;\\n                    ct += dfs(nx, ny);\\n                }\\n            }\\n        }\\n        \\n        if(temp == 2){\\n            if(tryremove(x, y)){\\n                // cout<<x<<\" \"<<y<<endl;\\n                ans = min(ans, 1);\\n            }\\n        }\\n        \\n        ans = min(ans, temp);\\n        return ct + 1;\\n        \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        cnt = 0;\\n        n = grid.size();\\n        m = grid[0].size();\\n        g = grid;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j] == 1) cnt++;\\n            }\\n        }\\n        \\n        vis = vector<vector<int>>(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j] == 1){\\n                    vis[i][j] = 1;\\n                    int tempcnt = dfs(i, j);\\n                    if(tempcnt != cnt) return 0;\\n                    if(tempcnt <= 2) return tempcnt;\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int xx[4] = {0, 0, 1, -1};\\n    int yy[4] = {1, -1, 0, 0};\\n    \\n    int n, m;\\n    vector<vector<int>> g, vis;\\n    \\n    bool cango(int x, int y){\\n        if(x < 0 || x >= n) return false;\\n        if(y < 0 || y >= m) return false;\\n        if(g[x][y] == 0) return false;\\n        return true;\\n    }\\n    \\n    int ans = INT_MAX;\\n    int cnt = 0;\\n    \\n    int tdfs(int x, int y, vector<vector<int>>&tgrid, vector<vector<int>>&tvis){\\n        int ct = 0;\\n        for(int i=0;i<4;i++){\\n            int nx = x + xx[i];\\n            int ny = y + yy[i];\\n            \\n            if(cango(nx, ny) && tgrid[nx][ny] == 1 && tvis[nx][ny] == 0){\\n                tvis[nx][ny] = 1;\\n                ct += tdfs(nx, ny, tgrid, tvis);\\n            }\\n        }\\n        \\n        return ct + 1;\\n    }\\n    \\n    bool tryremove(int x, int y){\\n        vector<vector<int>> tgrid = g;\\n        vector<vector<int>> tvis(n, vector<int>(m, 0));\\n        int tcnt = cnt - 1;\\n        \\n        tgrid[x][y] = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(tgrid[i][j] == 1){\\n                    tvis[i][j] = 1;\\n                    int tcntx = tdfs(i, j, tgrid, tvis);\\n                    // cout<<tcntx<<\" - \"<<tcnt<<endl;\\n                    if(tcntx == tcnt) return false;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    int dfs(int x, int y){\\n        \\n        int temp = 0;\\n        int ct = 0;\\n        for(int i=0;i<4;i++){\\n            int nx = x + xx[i];\\n            int ny = y + yy[i];\\n            if(cango(nx, ny)){ \\n                temp++;\\n                if(vis[nx][ny] == 0){\\n                    vis[nx][ny] = 1;\\n                    ct += dfs(nx, ny);\\n                }\\n            }\\n        }\\n        \\n        if(temp == 2){\\n            if(tryremove(x, y)){\\n                // cout<<x<<\" \"<<y<<endl;\\n                ans = min(ans, 1);\\n            }\\n        }\\n        \\n        ans = min(ans, temp);\\n        return ct + 1;\\n        \\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        cnt = 0;\\n        n = grid.size();\\n        m = grid[0].size();\\n        g = grid;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j] == 1) cnt++;\\n            }\\n        }\\n        \\n        vis = vector<vector<int>>(grid.size(), vector<int>(grid[0].size(), 0));\\n        \\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                if(grid[i][j] == 1){\\n                    vis[i][j] = 1;\\n                    int tempcnt = dfs(i, j);\\n                    if(tempcnt != cnt) return 0;\\n                    if(tempcnt <= 2) return tempcnt;\\n                    return ans;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2294614,
                "title": "incorrect-first-attempt",
                "content": "```\\nclass Solution {\\n  public int minDays(int[][] grid) {\\n    // return firstIncorrectAttempt(grid);\\n  }\\n  \\n  public int firstIncorrectAttempt(int[][] grid) {\\n    int[] res = smallestIsland(grid);\\n    int count = res[0];\\n    int size = res[1];\\n    if(count != 1) {\\n      return 0;\\n    }\\n    // Does not account for an island like this [[1,1,1,1,1]]\\n    if(size > 3) {\\n      return 2;\\n    } else {\\n      return size;\\n    }\\n  }\\n  \\n  public int[] smallestIsland(int[][] grid) {\\n    // returns {numsIslands, smallestIsland}\\n    int islandCount = 0;\\n    int size = Integer.MAX_VALUE;\\n    int[][] visited = new int[grid.length][grid[0].length];\\n    for(int i = 0; i < grid.length; i++) {\\n      for(int j = 0; j < grid[0].length; j++) {\\n        if(grid[i][j] == 1 && visited[i][j] != 1) {\\n          ++islandCount;\\n          size = Math.min(size, exploreIsland(grid, visited, i, j));\\n        }\\n      }\\n    }\\n    return new int[]{islandCount, size};\\n  }\\n  \\n  // returns island size\\n  public int exploreIsland(int[][] grid, int[][] visited, int i, int j) {\\n    if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length\\n      || visited[i][j] == 1 || grid[i][j] != 1) {\\n      return -1;\\n    }\\n    \\n    visited[i][j] = 1;\\n    \\n    int up = exploreIsland(grid, visited, i + 1, j);\\n    int down = exploreIsland(grid, visited, i - 1, j);\\n    int left = exploreIsland(grid, visited, i, j - 1);\\n    int right = exploreIsland(grid, visited, i, j + 1);\\n    \\n    return 1 + Math.max(0, up) + Math.max(0, down) + Math.max(0, left) + Math.max(0, right);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int minDays(int[][] grid) {\\n    // return firstIncorrectAttempt(grid);\\n  }\\n  \\n  public int firstIncorrectAttempt(int[][] grid) {\\n    int[] res = smallestIsland(grid);\\n    int count = res[0];\\n    int size = res[1];\\n    if(count != 1) {\\n      return 0;\\n    }\\n    // Does not account for an island like this [[1,1,1,1,1]]\\n    if(size > 3) {\\n      return 2;\\n    } else {\\n      return size;\\n    }\\n  }\\n  \\n  public int[] smallestIsland(int[][] grid) {\\n    // returns {numsIslands, smallestIsland}\\n    int islandCount = 0;\\n    int size = Integer.MAX_VALUE;\\n    int[][] visited = new int[grid.length][grid[0].length];\\n    for(int i = 0; i < grid.length; i++) {\\n      for(int j = 0; j < grid[0].length; j++) {\\n        if(grid[i][j] == 1 && visited[i][j] != 1) {\\n          ++islandCount;\\n          size = Math.min(size, exploreIsland(grid, visited, i, j));\\n        }\\n      }\\n    }\\n    return new int[]{islandCount, size};\\n  }\\n  \\n  // returns island size\\n  public int exploreIsland(int[][] grid, int[][] visited, int i, int j) {\\n    if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length\\n      || visited[i][j] == 1 || grid[i][j] != 1) {\\n      return -1;\\n    }\\n    \\n    visited[i][j] = 1;\\n    \\n    int up = exploreIsland(grid, visited, i + 1, j);\\n    int down = exploreIsland(grid, visited, i - 1, j);\\n    int left = exploreIsland(grid, visited, i, j - 1);\\n    int right = exploreIsland(grid, visited, i, j + 1);\\n    \\n    return 1 + Math.max(0, up) + Math.max(0, down) + Math.max(0, left) + Math.max(0, right);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2271671,
                "title": "c-dfs-count-number-of-islands",
                "content": "* **Thought Process ->**\\n* I just drew few example and figured out the logic.\\n\\n* If Number of islands in grid are more than one or there are no islands then there is no need to do anything return 0. `ans == 0`\\n\\n* Otherwise , if there is only one island , then only two possibilities arise --> \\n\\n* Suppose the grid may look something like- > `[1,1,1,1,1,1]` , `[[1,1,1,1],[1,0,1,1]]` , `[[0,1,1,0,1],[0,0,1,1,1]]` , for all these types of cases we can see that only one day is required to make it disconnected.  `ans == 1`\\n\\n* The Other case will be just take out the first two land(s) in diagonal directions.\\n say , grid = `[[1,1],[1,1],[1,1]]` , make `grid[0][1] = 0  and grid[1][1] = 0` and we are done. `ans == 2`\\n\\n```\\nclass Solution {\\npublic:\\n    int r , c ;\\n    const int dx[4] = {-1,0,1,0} ;\\n    const int dy[4] = {0,1,0,-1};\\n    void dfs(int i , int j , vector<vector<int>> &grid , vector<vector<int>> &visited ){\\n        visited[i][j] = 1;\\n        \\n        for(int itr = 0 ; itr < 4 ; ++itr ){\\n            int ii = i + dx[itr] , jj = j + dy[itr] ;\\n            if(ii >= 0 and jj >= 0 and ii < r and jj < c and grid[ii][jj] and !visited[ii][jj]) dfs(ii,jj,grid,visited);\\n        }\\n    }\\n    \\n    int find_islands(vector<vector<int>> &grid){\\n        vector<vector<int>> visited(r,vector<int>(c)) ;\\n        int ans = 0 ;\\n        for(int i = 0 ; i < r ; ++i ){\\n            for(int j = 0 ; j < c ; ++j ){\\n                if(!grid[i][j]) continue ;\\n                if(!visited[i][j]) ++ans , dfs(i,j,grid,visited);\\n            }\\n        }\\n        return ans ;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        r = grid.size() , c = grid[0].size() ;\\n        int islands = find_islands(grid) ;\\n        if(!islands || islands > 1) return 0 ; \\n        \\n        for(int i = 0 ; i < r ; ++i ){\\n            for(int j = 0 ; j < c ; ++j ){\\n                if(!grid[i][j]) continue ;\\n                \\n                grid[i][j] = 0 ;\\n                int groups = find_islands(grid) ;\\n                if(groups > 1 || !groups) return 1 ;\\n                grid[i][j] = 1 ;\\n            }\\n        }\\n        \\n        return 2 ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r , c ;\\n    const int dx[4] = {-1,0,1,0} ;\\n    const int dy[4] = {0,1,0,-1};\\n    void dfs(int i , int j , vector<vector<int>> &grid , vector<vector<int>> &visited ){\\n        visited[i][j] = 1;\\n        \\n        for(int itr = 0 ; itr < 4 ; ++itr ){\\n            int ii = i + dx[itr] , jj = j + dy[itr] ;\\n            if(ii >= 0 and jj >= 0 and ii < r and jj < c and grid[ii][jj] and !visited[ii][jj]) dfs(ii,jj,grid,visited);\\n        }\\n    }\\n    \\n    int find_islands(vector<vector<int>> &grid){\\n        vector<vector<int>> visited(r,vector<int>(c)) ;\\n        int ans = 0 ;\\n        for(int i = 0 ; i < r ; ++i ){\\n            for(int j = 0 ; j < c ; ++j ){\\n                if(!grid[i][j]) continue ;\\n                if(!visited[i][j]) ++ans , dfs(i,j,grid,visited);\\n            }\\n        }\\n        return ans ;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        r = grid.size() , c = grid[0].size() ;\\n        int islands = find_islands(grid) ;\\n        if(!islands || islands > 1) return 0 ; \\n        \\n        for(int i = 0 ; i < r ; ++i ){\\n            for(int j = 0 ; j < c ; ++j ){\\n                if(!grid[i][j]) continue ;\\n                \\n                grid[i][j] = 0 ;\\n                int groups = find_islands(grid) ;\\n                if(groups > 1 || !groups) return 1 ;\\n                grid[i][j] = 1 ;\\n            }\\n        }\\n        \\n        return 2 ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260430,
                "title": "dfs-solution-java",
                "content": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n      \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        \\n        int islandCount= findIslandCount(grid);\\n        \\n        if(islandCount==0 || islandCount>1) //means its already disconnected\\n            return 0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //make one cell to 0 and find the island count\\n                if(grid[i][j]==1){\\n                    grid[i][j]=0;\\n                    islandCount= findIslandCount(grid);\\n                    //make it again to 1\\n                    grid[i][j]=1;\\n                    if(islandCount==0 || islandCount>1) //means its already disconnected\\n                        return 1;\\n                }\\n                \\n            }\\n        }\\n        return 2;\\n    }\\n    \\n    private int findIslandCount(int[][] grid){\\n        \\n         int m=grid.length;\\n         int n=grid[0].length;\\n         boolean visited[][]=new boolean[m][n];\\n         int count=0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(!visited[i][j] && grid[i][j]==1){\\n                    count++;\\n                    if(count>1) //if count >1 then we dont need to do dfs for more nodes\\n                        return count;\\n                     doDFS(grid,visited,i,j,m,n);  \\n                }\\n            }\\n        }\\n      return count;\\n    }\\n    \\n    private void doDFS(int[][] grid,boolean[][] visited,int i,int j,int m,int n){\\n        \\n        if(i<0 || j<0 || i>=m || j>=n || visited[i][j] || grid[i][j]!=1)\\n            return;\\n        \\n        visited[i][j]=true;\\n        \\n        doDFS(grid,visited,i+1,j,m,n);        \\n        doDFS(grid,visited,i-1,j,m,n);\\n        doDFS(grid,visited,i,j+1,m,n);\\n        doDFS(grid,visited,i,j-1,m,n);\\n\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int minDays(int[][] grid) {\\n      \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        \\n        int islandCount= findIslandCount(grid);\\n        \\n        if(islandCount==0 || islandCount>1) //means its already disconnected\\n            return 0;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                //make one cell to 0 and find the island count\\n                if(grid[i][j]==1){\\n                    grid[i][j]=0;\\n                    islandCount= findIslandCount(grid);\\n                    //make it again to 1\\n                    grid[i][j]=1;\\n                    if(islandCount==0 || islandCount>1) //means its already disconnected\\n                        return 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2190052,
                "title": "fast-go-beats-100",
                "content": "```\\nvar dx = []int{1, -1, 0, 0}\\nvar dy = []int{0, 0, 1, -1}\\n\\nfunc fill(g [][]int, x, y int) {\\n    g[x][y] = 2\\n    for i := 0; i < 4; i++ {\\n        nx, ny := x + dx[i], y + dy[i]\\n        if nx < 0 || nx >= len(g) || ny < 0 || ny >= len(g[0]) || g[nx][ny] != 1 {\\n            continue\\n        }\\n        fill(g, nx, ny)        \\n    }\\n}\\n\\nfunc cnt(g [][]int) int {\\n    r := 0\\n    for i := 0; i < len(g); i++ {\\n        for j := 0; j < len(g[0]); j++ {\\n            if g[i][j] == 1 {\\n                r++\\n                fill(g, i, j)\\n            }  \\n        }\\n    }\\n    \\n    for i := 0; i < len(g); i++ {\\n        for j := 0; j < len(g[0]); j++ {\\n            if g[i][j] == 2 {\\n                g[i][j] = 1\\n            }\\n        }\\n    }\\n    \\n    return r\\n}\\n\\nfunc minDays(g [][]int) int {\\n    n, m := len(g), len(g[0])\\n    c := cnt(g)\\n    if c != 1 {\\n        return 0\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if g[i][j] == 1 {\\n                g[i][j] = 0\\n                c = cnt(g)\\n                if c != 1 {\\n                    return 1\\n                }\\n                g[i][j] = 1\\n            }\\n        }\\n    }\\n    \\n    return 2    \\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nvar dx = []int{1, -1, 0, 0}\\nvar dy = []int{0, 0, 1, -1}\\n\\nfunc fill(g [][]int, x, y int) {\\n    g[x][y] = 2\\n    for i := 0; i < 4; i++ {\\n        nx, ny := x + dx[i], y + dy[i]\\n        if nx < 0 || nx >= len(g) || ny < 0 || ny >= len(g[0]) || g[nx][ny] != 1 {\\n            continue\\n        }\\n        fill(g, nx, ny)        \\n    }\\n}\\n\\nfunc cnt(g [][]int) int {\\n    r := 0\\n    for i := 0; i < len(g); i++ {\\n        for j := 0; j < len(g[0]); j++ {\\n            if g[i][j] == 1 {\\n                r++\\n                fill(g, i, j)\\n            }  \\n        }\\n    }\\n    \\n    for i := 0; i < len(g); i++ {\\n        for j := 0; j < len(g[0]); j++ {\\n            if g[i][j] == 2 {\\n                g[i][j] = 1\\n            }\\n        }\\n    }\\n    \\n    return r\\n}\\n\\nfunc minDays(g [][]int) int {\\n    n, m := len(g), len(g[0])\\n    c := cnt(g)\\n    if c != 1 {\\n        return 0\\n    }\\n    \\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if g[i][j] == 1 {\\n                g[i][j] = 0\\n                c = cnt(g)\\n                if c != 1 {\\n                    return 1\\n                }\\n                g[i][j] = 1\\n            }\\n        }\\n    }\\n    \\n    return 2    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2163686,
                "title": "c-simple-dfs-and-finding-connected-components",
                "content": "```\\nvoid dfs(vector<vector<int>> &grid, int i, int j, vector<vector<int>> &visited){\\n    if(i>=grid.size() || j>=grid[0].size() || j<0 || i<0) return;\\n    if(!visited[i][j] && grid[i][j]){\\n        visited[i][j]=1;\\n        dfs(grid, i-1, j, visited);\\n        dfs(grid, i+1, j, visited);\\n        dfs(grid, i, j-1, visited);\\n        dfs(grid, i, j+1, visited);\\n    }\\n    return;\\n}\\n\\nint cc(vector<vector<int>> &grid, vector<vector<int>> &visited){\\n    int count=0;\\n    for(int i=0;i<grid.size();i++){\\n        for(int j=0; j<grid[i].size() ;j++){\\n            if(!visited[i][j] && grid[i][j]){\\n                count++;\\n                dfs(grid, i, j, visited);\\n            }\\n        }\\n    }\\n    return count;\\n    \\n}\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int c=0;\\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0; j<grid[i].size();j++) if(grid[i][j]) c++;\\n        if(c==1) return 1;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(),0));\\n        int x = cc(grid, visited);\\n        if(x>1 || x==0) return 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[i].size(); j++){\\n                vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(),0));\\n                if(grid[i][j] && !visited[i][j]){\\n                    grid[i][j] = 0;\\n                    x = cc(grid,visited);\\n                    if(x > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nvoid dfs(vector<vector<int>> &grid, int i, int j, vector<vector<int>> &visited){\\n    if(i>=grid.size() || j>=grid[0].size() || j<0 || i<0) return;\\n    if(!visited[i][j] && grid[i][j]){\\n        visited[i][j]=1;\\n        dfs(grid, i-1, j, visited);\\n        dfs(grid, i+1, j, visited);\\n        dfs(grid, i, j-1, visited);\\n        dfs(grid, i, j+1, visited);\\n    }\\n    return;\\n}\\n\\nint cc(vector<vector<int>> &grid, vector<vector<int>> &visited){\\n    int count=0;\\n    for(int i=0;i<grid.size();i++){\\n        for(int j=0; j<grid[i].size() ;j++){\\n            if(!visited[i][j] && grid[i][j]){\\n                count++;\\n                dfs(grid, i, j, visited);\\n            }\\n        }\\n    }\\n    return count;\\n    \\n}\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int c=0;\\n        for(int i=0;i<grid.size();i++)\\n            for(int j=0; j<grid[i].size();j++) if(grid[i][j]) c++;\\n        if(c==1) return 1;\\n        vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(),0));\\n        int x = cc(grid, visited);\\n        if(x>1 || x==0) return 0;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[i].size(); j++){\\n                vector<vector<int>> visited(grid.size(), vector<int>(grid[0].size(),0));\\n                if(grid[i][j] && !visited[i][j]){\\n                    grid[i][j] = 0;\\n                    x = cc(grid,visited);\\n                    if(x > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158527,
                "title": "c-articulation-point",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> low,dis,vis,path{{1,0},{0,1},{-1,0},{0,-1}};\\n    int ct=0;\\n    void dfs(int i, int j, vector<vector<int>> &visi,vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size(); \\n        visi[i][j] = true;\\n        for(auto it:path)\\n        {\\n            int x = i+it[0], y = j+it[1];\\n            if(x>=0 && y>=0 && x<n && y<m && visi[x][y] == false && grid[x][y]==1)\\n            {\\n                visi[x][y] = true;\\n                dfs(x,y,visi,grid);\\n            }\\n        }\\n    }\\n    void APutil(int i,int j,int &time,vector<vector<int>> &grid,int pi, int pj)\\n    {\\n        int children = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[i][j] = true;\\n        dis[i][j] = low[i][j] = ++time;\\n        for(auto it: path)\\n        {\\n            int x = i + it[0], y = j + it[1];\\n            if(x>=0 && y>=0 && x<n && y<m && grid[x][y] == 1)  \\n            {\\n                if(vis[x][y] == 0)\\n                {\\n                    children++;\\n                    APutil(x,y,time,grid,i,j);\\n                    low[i][j] = min(low[i][j],low[x][y]);\\n                    if(pi != -1 && low[x][y] >= dis[i][j]) ct++;\\n                }\\n                else \\n                    low[i][j] = min(low[i][j],dis[x][y]);\\n            }\\n        }\\n        if(pi==-1 && children>1) ct++;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        low.resize(n,vector<int>(m));\\n        dis.resize(n,vector<int>(m));\\n        vis.resize(n,vector<int>(m));\\n        int time=0;\\n        ct=0;\\n        vector<vector<int>> visi(n,vector<int>(m));\\n        int cnt=0,c=0;\\n        for(int  i =0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1) c++;\\n                if(grid[i][j]==1 && visi[i][j]==0)\\n                {\\n                    APutil(i,j,time,grid,-1,-1);\\n                    cnt++;\\n                    dfs(i,j,visi,grid);\\n                }\\n            }\\n        }\\n        if(cnt!=1) return 0;\\n        if((ct>=1 || c==1)) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> low,dis,vis,path{{1,0},{0,1},{-1,0},{0,-1}};\\n    int ct=0;\\n    void dfs(int i, int j, vector<vector<int>> &visi,vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size(); \\n        visi[i][j] = true;\\n        for(auto it:path)\\n        {\\n            int x = i+it[0], y = j+it[1];\\n            if(x>=0 && y>=0 && x<n && y<m && visi[x][y] == false && grid[x][y]==1)\\n            {\\n                visi[x][y] = true;\\n                dfs(x,y,visi,grid);\\n            }\\n        }\\n    }\\n    void APutil(int i,int j,int &time,vector<vector<int>> &grid,int pi, int pj)\\n    {\\n        int children = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis[i][j] = true;\\n        dis[i][j] = low[i][j] = ++time;\\n        for(auto it: path)\\n        {\\n            int x = i + it[0], y = j + it[1];\\n            if(x>=0 && y>=0 && x<n && y<m && grid[x][y] == 1)  \\n            {\\n                if(vis[x][y] == 0)\\n                {\\n                    children++;\\n                    APutil(x,y,time,grid,i,j);\\n                    low[i][j] = min(low[i][j],low[x][y]);\\n                    if(pi != -1 && low[x][y] >= dis[i][j]) ct++;\\n                }\\n                else \\n                    low[i][j] = min(low[i][j],dis[x][y]);\\n            }\\n        }\\n        if(pi==-1 && children>1) ct++;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        low.resize(n,vector<int>(m));\\n        dis.resize(n,vector<int>(m));\\n        vis.resize(n,vector<int>(m));\\n        int time=0;\\n        ct=0;\\n        vector<vector<int>> visi(n,vector<int>(m));\\n        int cnt=0,c=0;\\n        for(int  i =0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1) c++;\\n                if(grid[i][j]==1 && visi[i][j]==0)\\n                {\\n                    APutil(i,j,time,grid,-1,-1);\\n                    cnt++;\\n                    dfs(i,j,visi,grid);\\n                }\\n            }\\n        }\\n        if(cnt!=1) return 0;\\n        if((ct>=1 || c==1)) return 1;\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100332,
                "title": "c-clean-code-easy-to-understand-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int isLands=0,o=0,r,c;\\n    int vis[31][31];\\n    void dfs(vector<vector<int>>& g,int i,int j){\\n        if(i<0 || i>=r || j<0 || j>=c || vis[i][j] || !g[i][j]) return;\\n        vis[i][j]=1;\\n        dfs(g,i+1,j);\\n        dfs(g,i-1,j);\\n        dfs(g,i,j+1);\\n        dfs(g,i,j-1);        \\n    }\\n    void countALL(vector<vector<int>>& g){\\n        isLands=0,o=0;\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<r;++i)\\n            for(int j=0;j<c;++j){\\n                if(!vis[i][j]&&g[i][j])dfs(g,i,j),isLands++;\\n                if(g[i][j])o++;\\n            }\\n    }\\n    int minDays(vector<vector<int>>& g) {\\n        r=g.size();\\n        c=g[0].size();\\n        countALL(g);\\n        if(isLands!=1) return 0;\\n        if(r==1 || c==1 || o<=2) return o==2?2:1;\\n        for(int i=0;i<r;++i)\\n            for(int j=0;j<c;++j){\\n                if(g[i][j]){\\n                    g[i][j]=0;\\n                    countALL(g);\\n                    if(isLands>1) return 1;\\n                    g[i][j]=1;\\n                }\\n            }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isLands=0,o=0,r,c;\\n    int vis[31][31];\\n    void dfs(vector<vector<int>>& g,int i,int j){\\n        if(i<0 || i>=r || j<0 || j>=c || vis[i][j] || !g[i][j]) return;\\n        vis[i][j]=1;\\n        dfs(g,i+1,j);\\n        dfs(g,i-1,j);\\n        dfs(g,i,j+1);\\n        dfs(g,i,j-1);        \\n    }\\n    void countALL(vector<vector<int>>& g){\\n        isLands=0,o=0;\\n        memset(vis,0,sizeof(vis));\\n        for(int i=0;i<r;++i)\\n            for(int j=0;j<c;++j){\\n                if(!vis[i][j]&&g[i][j])dfs(g,i,j),isLands++;\\n                if(g[i][j])o++;\\n            }\\n    }\\n    int minDays(vector<vector<int>>& g) {\\n        r=g.size();\\n        c=g[0].size();\\n        countALL(g);\\n        if(isLands!=1) return 0;\\n        if(r==1 || c==1 || o<=2) return o==2?2:1;\\n        for(int i=0;i<r;++i)\\n            for(int j=0;j<c;++j){\\n                if(g[i][j]){\\n                    g[i][j]=0;\\n                    countALL(g);\\n                    if(isLands>1) return 1;\\n                    g[i][j]=1;\\n                }\\n            }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054513,
                "title": "c-dfs-scc-clean-code",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dir[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}}; \\n    \\n    bool valid(int i, int j, int m, int n) {\\n        return i >= 0 && i < m && j >= 0 && j < n;\\n    }\\n    \\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<bool>> &used) {\\n        used[x][y] = true;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for(int i = 0; i < 4; i++) {\\n            int a = x + dir[i][0];\\n            int b = y + dir[i][1];\\n            if(valid(a, b, m, n) && grid[a][b] == 1 && !used[a][b])\\n                dfs(a, b, grid, used);\\n        }\\n        \\n    }\\n    \\n    int total_cmpnt(vector<vector<int>> &grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> used(m, vector<bool>(n, false));\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1 && !used[i][j]) {\\n                    cnt += 1;\\n                    dfs(i, j, grid, used);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // if initially disconnected\\n        int cnt = total_cmpnt(grid);\\n        \\n        // cout << cnt << endl;\\n        \\n        if(cnt != 1)\\n            return 0;\\n        \\n        // for 1 day\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;   // flip to 0\\n                    cnt = total_cmpnt(grid);\\n                    if(cnt != 1)\\n                        return 1;\\n                    grid[i][j] = 1;   // restore to 1\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dir[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}}; \\n    \\n    bool valid(int i, int j, int m, int n) {\\n        return i >= 0 && i < m && j >= 0 && j < n;\\n    }\\n    \\n    void dfs(int x, int y, vector<vector<int>> &grid, vector<vector<bool>> &used) {\\n        used[x][y] = true;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        for(int i = 0; i < 4; i++) {\\n            int a = x + dir[i][0];\\n            int b = y + dir[i][1];\\n            if(valid(a, b, m, n) && grid[a][b] == 1 && !used[a][b])\\n                dfs(a, b, grid, used);\\n        }\\n        \\n    }\\n    \\n    int total_cmpnt(vector<vector<int>> &grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<bool>> used(m, vector<bool>(n, false));\\n        \\n        int cnt = 0;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1 && !used[i][j]) {\\n                    cnt += 1;\\n                    dfs(i, j, grid, used);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n    \\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        // if initially disconnected\\n        int cnt = total_cmpnt(grid);\\n        \\n        // cout << cnt << endl;\\n        \\n        if(cnt != 1)\\n            return 0;\\n        \\n        // for 1 day\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] == 1) {\\n                    grid[i][j] = 0;   // flip to 0\\n                    cnt = total_cmpnt(grid);\\n                    if(cnt != 1)\\n                        return 1;\\n                    grid[i][j] = 1;   // restore to 1\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2045241,
                "title": "c-articulation-points-logical-way-for-optimal-removal-at-any-point",
                "content": "Explanation in a later post.\\n\\n---\\n\\n```cpp\\n#define _CRT_SECURE_NO_WARNINGS\\n#include <algorithm>\\n#include <array>\\n#include <charconv>\\n#include <cstring>\\n#include <functional>\\n#include <iomanip>\\n#include <iostream>\\n#include <list>\\n#include <map>\\n#include <numeric>\\n#include <queue>\\n#include <random>\\n#include <set>\\n#include <stack>\\n#include <string>\\n#include <tuple>\\n#include <type_traits>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <utility>\\n#include <vector>\\nusing namespace std;\\n\\n#ifdef LC_LOCAL\\nstruct TreeNode {\\n  int val;\\n  TreeNode *left = nullptr;\\n  TreeNode *right = nullptr;\\n};\\nstruct ListNode {\\n  int val;\\n  ListNode *next = nullptr;\\n};\\n#endif\\n\\ntemplate <typename T, typename = void> struct is_container {\\n  static constexpr bool value = false;\\n};\\ntemplate <typename T>\\nstruct is_container<T, void_t<decltype(T{}.begin()), decltype(T{}.end())>> {\\n  static constexpr bool value = true;\\n};\\ntemplate <typename = void> inline constexpr bool always_false = false;\\n\\ntemplate <typename T, bool ReadEnd> T parse(FILE *f, int &c) {\\n  if constexpr (is_same_v<T, int>) {\\n    int ans = 0, neg = 0;\\n    while ((char(c = fgetc(f)) >= \\'0\\' && (char)c <= \\'9\\') || (char)c == \\'-\\') {\\n      if ((char)c == \\'-\\')\\n        neg = 1;\\n      else\\n        ans = ans * 10 + ((char)c - \\'0\\') * (1 - 2 * neg);\\n    }\\n    if constexpr (!ReadEnd)\\n      ungetc(c, f);\\n    return ans;\\n  } else if constexpr (is_same_v<T, string>) {\\n    string ans;\\n    fgetc(f);\\n    while (char(c = fgetc(f)) != \\'\"\\')\\n      ans += (char)c;\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return ans;\\n  } else if constexpr (is_same_v<T, TreeNode *>) {\\n    int e = 2;\\n    auto dummy = new TreeNode{};\\n    deque<TreeNode *> q;\\n    q.push_back(dummy);\\n    fgetc(f);\\n    while ((char)c != \\']\\') {\\n      int sz = q.size();\\n      while (sz > 0) {\\n        int val = 0, neg = 0;\\n        bool is_null = false;\\n        while (char(c = fgetc(f)) != \\',\\' && (char)c != \\']\\') {\\n          if ((char)c >= \\'0\\' && (char)c <= \\'9\\')\\n            val = val * 10 + ((char)c - \\'0\\') * (1 - 2 * neg);\\n          else if ((char)c == \\'-\\')\\n            neg = 1;\\n          else\\n            is_null = true;\\n        }\\n        if (!is_null) {\\n          auto new_node = new TreeNode{val};\\n          if (e & 1)\\n            q[0]->left = new_node;\\n          else\\n            q[0]->right = new_node;\\n          q.push_back(new_node);\\n        }\\n        if (e++ % 2 == 0) {\\n          q.pop_front();\\n          sz--;\\n        }\\n      }\\n      e = 1;\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return dummy->right;\\n  } else if constexpr (is_same_v<T, ListNode *>) {\\n    auto dummy = new ListNode{};\\n    auto cur = dummy;\\n    fgetc(f);\\n    if (char(c = fgetc(f)) != \\']\\') {\\n      ungetc(c, f);\\n      while ((char)c != \\']\\') {\\n        cur->next = new ListNode{parse<int, true>(f, c)};\\n        cur = cur->next;\\n      }\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return dummy->next;\\n  } else if constexpr (is_container<T>::value) {\\n    T ans;\\n    fgetc(f);\\n    if (char(c = fgetc(f)) != \\']\\') {\\n      ungetc(c, f);\\n      while ((char)c != \\']\\')\\n        ans.emplace_back(parse<typename T::value_type, true>(f, c));\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return ans;\\n  } else\\n    static_assert(always_false<T>, \"parsing for type not supported\");\\n}\\n\\ntemplate <bool WriteEnd, typename T> void write(FILE *f, const T &val) {\\n  static constexpr const char *end = WriteEnd ? \"\\\\n\" : \"\";\\n  if constexpr (is_same_v<T, int>)\\n    fprintf(f, \"%d%s\", val, end);\\n  else if constexpr (is_same_v<T, float>)\\n    fprintf(f, \"%.f%s\", val, end);\\n  else if constexpr (is_same_v<T, bool>)\\n    fprintf(f, \"%s%s\", val ? \"true\" : \"false\", end);\\n  else if constexpr (is_same_v<T, string>)\\n    fprintf(f, \"\\\\\"%s\\\\\"%s\", val.data(), end);\\n  else if constexpr (is_same_v<T, TreeNode *>) {\\n    deque<TreeNode *> q;\\n    fprintf(f, \"[\");\\n    if (val) {\\n      q.push_back(val);\\n      fprintf(f, \"%d\", val->val);\\n    }\\n    while (!q.empty()) {\\n      int sz = q.size();\\n      string ans;\\n      while (sz-- > 0) {\\n        auto cur = q.front();\\n        q.pop_front();\\n        if (cur->left) {\\n          q.push_back(cur->left);\\n          ans += \\',\\';\\n          ans += to_string(cur->left->val);\\n        } else\\n          ans += \",null\";\\n        if (cur->right) {\\n          q.push_back(cur->right);\\n          ans += \\',\\';\\n          ans += to_string(cur->right->val);\\n        } else\\n          ans += \",null\";\\n      }\\n      if (!q.empty())\\n        fprintf(f, ans.data());\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else if constexpr (is_same_v<T, ListNode *>) {\\n    int c = 0;\\n    auto cur = val;\\n    fprintf(f, \"[\");\\n    while (cur) {\\n      fprintf(f, \"%s%d\", c++ ? \",\" : \"\", cur->val);\\n      cur = cur->next;\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else if constexpr (is_container<T>::value) {\\n    fprintf(f, \"[\");\\n    int c = 0;\\n    for (int i = 0; i < val.size(); i++) {\\n      fprintf(f, \"%s\", c++ ? \",\" : \"\");\\n      write<false>(f, val[i]);\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else\\n    static_assert(always_false<T>, \"writing for type not supported\");\\n}\\n\\ntemplate <typename Args, size_t... Idx>\\nvoid write_args(FILE *f, const Args &args, index_sequence<Idx...>) {\\n  ((fprintf(f, \"#%lld: \", Idx + 1), write<true>(f, get<Idx + 1>(args))), ...);\\n}\\n\\ntemplate <typename Solution, typename R, typename... Ts>\\nvoid exec(R (Solution::*fn)(Ts...)) {\\n  constexpr bool returns = !is_same_v<R, void>;\\n  auto out = fopen(\"output.txt\", \"w\");\\n  if constexpr (sizeof...(Ts) == 0) {\\n    if constexpr (returns) {\\n      write<true>(out, (Solution{}.*fn)());\\n    } else\\n      (Solution{}.*fn)();\\n  } else {\\n    auto in = fopen(\"input.txt\", \"r\");\\n    int c = fgetc(in);\\n    if (c == EOF) {\\n      fclose(in);\\n      return;\\n    } else\\n      ungetc(c, in);\\n    while (true) {\\n      if (char(c = fgetc(in)) == EOF)\\n        break;\\n      else\\n        ungetc(c, in);\\n      if (char(c = fgetc(in)) == \\'/\\') {\\n        while ((c = fgetc(in)) != \\'\\\\n\\' && c != EOF) {\\n        }\\n      } else {\\n        ungetc(c, in);\\n        tuple args{Solution{}, parse<decay_t<Ts>, true>(in, c)...};\\n        if constexpr (!returns) {\\n          apply(fn, args);\\n          fprintf(out, \"New state of parameters:\\\\n\");\\n          write_args(out, args, index_sequence_for<Ts...>{});\\n        } else\\n          write<true>(out, apply(fn, args));\\n#ifdef LC_LOCAL\\n        cout << endl;\\n#endif\\n      }\\n    }\\n    fclose(in);\\n  }\\n  fclose(out);\\n}\\n\\nvoid _print(const string &x) { cout << \\'\\\\\"\\' << x << \\'\\\\\"\\'; }\\nvoid _print(bool x) { cout << (x ? \"true\" : \"false\"); }\\ntemplate <typename T> enable_if_t<is_arithmetic_v<T>> _print(const T &x) {\\n  cout << x;\\n}\\ntemplate <typename T, size_t... Idx>\\nvoid _print2(const T &x, index_sequence<Idx...>) {\\n  int c = 0;\\n  ((cout << (c++ ? \",\" : \"\"), _print(get<Idx>(x))), ...);\\n}\\ntemplate <typename T> void_t<typename tuple_size<T>::type> _print(const T &x) {\\n  cout << \\'{\\';\\n  _print2(x, make_index_sequence<tuple_size_v<T>>{});\\n  cout << \\'}\\';\\n}\\ntemplate <typename T> enable_if_t<is_container<T>::value> _print(const T &x) {\\n  cout << \\'[\\';\\n  int c = 0;\\n  for (const auto &e : x) {\\n    cout << (c++ ? \",\" : \"\");\\n    _print(e);\\n  }\\n  cout << \\']\\';\\n}\\n\\n#define CONCAT_IMPL(x, y) x##y\\n#define CONCAT(x, y) CONCAT_IMPL(x, y)\\n#define NUM_ARGS_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\\n#define NUM_ARGS(...) NUM_ARGS_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\\n#define DBG_VAL(x) cout << \\'[\\' << #x << \" = \", _print(x), cout << \"] \"\\n#define DBG_1(x) DBG_VAL(x)\\n#define DBG_2(x, ...) DBG_VAL(x), DBG_1(__VA_ARGS__)\\n#define DBG_3(x, ...) DBG_VAL(x), DBG_2(__VA_ARGS__)\\n#define DBG_4(x, ...) DBG_VAL(x), DBG_3(__VA_ARGS__)\\n#define DBG_5(x, ...) DBG_VAL(x), DBG_4(__VA_ARGS__)\\n#define DBG_6(x, ...) DBG_VAL(x), DBG_5(__VA_ARGS__)\\n#define DBG_7(x, ...) DBG_VAL(x), DBG_6(__VA_ARGS__)\\n#define DBG_8(x, ...) DBG_VAL(x), DBG_7(__VA_ARGS__)\\n#define DBG_9(x, ...) DBG_VAL(x), DBG_8(__VA_ARGS__)\\n#define DBG_10(x, ...) DBG_VAL(x), DBG_9(__VA_ARGS__)\\n// supports up to 10 arguments debugging at one time\\n\\n#ifdef LC_LOCAL\\n#define dbg(...) CONCAT(DBG_, NUM_ARGS(__VA_ARGS__))(__VA_ARGS__), cout << endl\\n#else\\n#define dbg(...)\\n#endif\\n\\n#define all(x) begin(x), end(x)\\n#define has(c, x) (c.find(x) != c.end())\\n#define umap unordered_map\\n#define uset unordered_set\\n#define vec vector\\n#define valid(i, j, m, n) (i >= 0 && i < m && j >= 0 && j < n)\\n\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\ntemplate <typename T> T &amax(T &a, const T &b) { return a = max(a, b); }\\n\\nusing pii = pair<int, int>;\\nusing pipii = pair<int, pii>;\\nusing pippiipii = pair<int, pair<pii, pii>>;\\nusing ll = long long;\\n\\nnamespace std {\\ntemplate <typename T> class hash<std::pair<T, T>> {\\npublic:\\n  size_t operator()(const pair<T, T> &x) const {\\n    // https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes\\n    ll lhs = hash<T>()(x.first), rhs = hash<T>()(x.second);\\n    lhs ^= rhs + 0x9e3779b9 + (lhs << 6) + (lhs >> 2);\\n    return lhs;\\n  }\\n};\\n} // namespace std\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, 1, -1, 0, -1, 1, -1, 1};\\nconstexpr int INF = 1e9;\\nconstexpr double EPS = 1e-9;\\n\\n// ----- CHANGE FOR PROBLEM -----\\nclass Solution {\\n\\n  void dfs(vec<vec<int>> &grid, vec<vec<vec<pii>>> &adj, vec<vec<bool>> &vis,\\n           vec<vec<int>> &disc, vec<vec<int>> &low, int ip, int jp, int i,\\n           int j, int time, bool &res) {\\n    int children = 0;\\n    disc[i][j] = low[i][j] = time;\\n    vis[i][j] = false;\\n\\n    for (auto [i2, j2] : adj[i][j]) {\\n      if (vis[i2][j2]) {\\n        children++;\\n        dfs(grid, adj, vis, disc, low, i, j, i2, j2, time + 1, res);\\n        amin(low[i][j], low[i2][j2]);\\n        if (ip != -1 && jp != -1 && low[i2][j2] >= disc[i][j])\\n          res = true;\\n      } else if (i2 != ip || j2 != jp)\\n        amin(low[i][j], disc[i2][j2]);\\n    }\\n    if (ip == -1 && jp == -1 && children > 1)\\n      res = true;\\n  }\\n\\npublic:\\n  int minDays(vector<vector<int>> &grid) {\\n    int m = grid.size(), n = grid[0].size();\\n\\n    vec<vec<bool>> vis(m, vec<bool>(n));\\n    vec<vec<vec<pii>>> adj(m, vec<vec<pii>>(n));\\n    deque<pii> s;\\n    int is = INF, js = INF, islands = 0, lands = 0;\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1) {\\n          lands++;\\n          if (!vis[i][j]) {\\n            islands++;\\n            if (islands == 2)\\n              return 0;\\n            deque<pii> q;\\n            q.push_back({i, j});\\n            vis[i][j] = true;\\n            is = i;\\n            js = j;\\n            while (!q.empty()) {\\n              auto [i2, j2] = q.front();\\n              q.pop_front();\\n              for (int k = 0; k < 4; k++) {\\n                int i3 = i2 + dx[k];\\n                int j3 = j2 + dy[k];\\n                if (valid(i3, j3, m, n) && grid[i3][j3] == 1 && !vis[i3][j3]) {\\n                  vis[i3][j3] = true;\\n                  q.push_back({i3, j3});\\n                }\\n              }\\n            }\\n          }\\n          for (int k = 0; k < 4; k++) {\\n            int i2 = i + dx[k];\\n            int j2 = j + dy[k];\\n            if (valid(i2, j2, m, n) && grid[i2][j2] == 1)\\n              adj[i][j].push_back({i2, j2});\\n          }\\n        }\\n      }\\n    }\\n    if (lands < 3)\\n      return lands;\\n    dbg(adj, is, js);\\n\\n    vec<vec<int>> disc(m, vec<int>(n));\\n    vec<vec<int>> low(m, vec<int>(n));\\n    bool res = false;\\n    dfs(grid, adj, vis, disc, low, -1, -1, is, js, 1, res);\\n    dbg(res);\\n    if (res)\\n      return 1;\\n\\n    int ans = INF;\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] != 1)\\n          continue;\\n        int res = INF, vertical = INF, horizontal = INF, slice = INF;\\n        if (i > 0 && i < m - 1) {\\n          int l = 0, r = 0;\\n          bool cut_l = false, cut_r = false;\\n          for (int k = j - 1; k >= 0 && grid[i][k] == 1; k--, l++) {\\n            cut_l = true;\\n          }\\n          for (int k = j + 1; k < n && grid[i][k] == 1; k++, r++) {\\n            cut_r = true;\\n          }\\n          if (cut_l || cut_r)\\n            horizontal = l + r + 1;\\n        }\\n        if (j > 0 && j < n - 1) {\\n          int l = 0, r = 0;\\n          bool cut_l = false, cut_r = false;\\n          for (int k = i - 1; k >= 0 && grid[k][j] == 1; k--, l++) {\\n            cut_l = true;\\n          }\\n          for (int k = i + 1; k < m && grid[k][j] == 1; k++, l++) {\\n            cut_r = true;\\n          }\\n          if (cut_l || cut_r)\\n            vertical = l + r + 1;\\n        }\\n        int l = 0, r = 0;\\n        bool cut_l = false, cut_r = false;\\n        for (int i2 = i - 1, j2 = j - 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2--, j2--, l++) {\\n          cut_l = true;\\n        }\\n        for (int i2 = i + 1, j2 = j + 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2++, j2++, r++) {\\n          cut_r = true;\\n        }\\n        if (cut_l || cut_r)\\n          amin(slice, l + r + 1);\\n        l = 0, r = 0;\\n        cut_l = false, cut_r = false;\\n        for (int i2 = i - 1, j2 = j + 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2--, j2++, l++) {\\n          cut_l = true;\\n        }\\n        for (int i2 = i + 1, j2 = j - 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2++, j2--, r++) {\\n          cut_r = true;\\n        }\\n        if (cut_l || cut_r)\\n          amin(slice, l + r + 1);\\n        ans = min({ans, horizontal, vertical, slice});\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n// ----- CHANGE FOR PROBLEM -----\\n\\n#ifdef LC_LOCAL\\nint main() {\\n  ios_base::sync_with_stdio(false);\\n  cin.tie(NULL);\\n  exec(&Solution::minDays); // CHANGE FOR PROBLEM\\n}\\n#endif\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n#define _CRT_SECURE_NO_WARNINGS\\n#include <algorithm>\\n#include <array>\\n#include <charconv>\\n#include <cstring>\\n#include <functional>\\n#include <iomanip>\\n#include <iostream>\\n#include <list>\\n#include <map>\\n#include <numeric>\\n#include <queue>\\n#include <random>\\n#include <set>\\n#include <stack>\\n#include <string>\\n#include <tuple>\\n#include <type_traits>\\n#include <unordered_map>\\n#include <unordered_set>\\n#include <utility>\\n#include <vector>\\nusing namespace std;\\n\\n#ifdef LC_LOCAL\\nstruct TreeNode {\\n  int val;\\n  TreeNode *left = nullptr;\\n  TreeNode *right = nullptr;\\n};\\nstruct ListNode {\\n  int val;\\n  ListNode *next = nullptr;\\n};\\n#endif\\n\\ntemplate <typename T, typename = void> struct is_container {\\n  static constexpr bool value = false;\\n};\\ntemplate <typename T>\\nstruct is_container<T, void_t<decltype(T{}.begin()), decltype(T{}.end())>> {\\n  static constexpr bool value = true;\\n};\\ntemplate <typename = void> inline constexpr bool always_false = false;\\n\\ntemplate <typename T, bool ReadEnd> T parse(FILE *f, int &c) {\\n  if constexpr (is_same_v<T, int>) {\\n    int ans = 0, neg = 0;\\n    while ((char(c = fgetc(f)) >= \\'0\\' && (char)c <= \\'9\\') || (char)c == \\'-\\') {\\n      if ((char)c == \\'-\\')\\n        neg = 1;\\n      else\\n        ans = ans * 10 + ((char)c - \\'0\\') * (1 - 2 * neg);\\n    }\\n    if constexpr (!ReadEnd)\\n      ungetc(c, f);\\n    return ans;\\n  } else if constexpr (is_same_v<T, string>) {\\n    string ans;\\n    fgetc(f);\\n    while (char(c = fgetc(f)) != \\'\"\\')\\n      ans += (char)c;\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return ans;\\n  } else if constexpr (is_same_v<T, TreeNode *>) {\\n    int e = 2;\\n    auto dummy = new TreeNode{};\\n    deque<TreeNode *> q;\\n    q.push_back(dummy);\\n    fgetc(f);\\n    while ((char)c != \\']\\') {\\n      int sz = q.size();\\n      while (sz > 0) {\\n        int val = 0, neg = 0;\\n        bool is_null = false;\\n        while (char(c = fgetc(f)) != \\',\\' && (char)c != \\']\\') {\\n          if ((char)c >= \\'0\\' && (char)c <= \\'9\\')\\n            val = val * 10 + ((char)c - \\'0\\') * (1 - 2 * neg);\\n          else if ((char)c == \\'-\\')\\n            neg = 1;\\n          else\\n            is_null = true;\\n        }\\n        if (!is_null) {\\n          auto new_node = new TreeNode{val};\\n          if (e & 1)\\n            q[0]->left = new_node;\\n          else\\n            q[0]->right = new_node;\\n          q.push_back(new_node);\\n        }\\n        if (e++ % 2 == 0) {\\n          q.pop_front();\\n          sz--;\\n        }\\n      }\\n      e = 1;\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return dummy->right;\\n  } else if constexpr (is_same_v<T, ListNode *>) {\\n    auto dummy = new ListNode{};\\n    auto cur = dummy;\\n    fgetc(f);\\n    if (char(c = fgetc(f)) != \\']\\') {\\n      ungetc(c, f);\\n      while ((char)c != \\']\\') {\\n        cur->next = new ListNode{parse<int, true>(f, c)};\\n        cur = cur->next;\\n      }\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return dummy->next;\\n  } else if constexpr (is_container<T>::value) {\\n    T ans;\\n    fgetc(f);\\n    if (char(c = fgetc(f)) != \\']\\') {\\n      ungetc(c, f);\\n      while ((char)c != \\']\\')\\n        ans.emplace_back(parse<typename T::value_type, true>(f, c));\\n    }\\n    if constexpr (ReadEnd)\\n      c = fgetc(f);\\n    return ans;\\n  } else\\n    static_assert(always_false<T>, \"parsing for type not supported\");\\n}\\n\\ntemplate <bool WriteEnd, typename T> void write(FILE *f, const T &val) {\\n  static constexpr const char *end = WriteEnd ? \"\\\\n\" : \"\";\\n  if constexpr (is_same_v<T, int>)\\n    fprintf(f, \"%d%s\", val, end);\\n  else if constexpr (is_same_v<T, float>)\\n    fprintf(f, \"%.f%s\", val, end);\\n  else if constexpr (is_same_v<T, bool>)\\n    fprintf(f, \"%s%s\", val ? \"true\" : \"false\", end);\\n  else if constexpr (is_same_v<T, string>)\\n    fprintf(f, \"\\\\\"%s\\\\\"%s\", val.data(), end);\\n  else if constexpr (is_same_v<T, TreeNode *>) {\\n    deque<TreeNode *> q;\\n    fprintf(f, \"[\");\\n    if (val) {\\n      q.push_back(val);\\n      fprintf(f, \"%d\", val->val);\\n    }\\n    while (!q.empty()) {\\n      int sz = q.size();\\n      string ans;\\n      while (sz-- > 0) {\\n        auto cur = q.front();\\n        q.pop_front();\\n        if (cur->left) {\\n          q.push_back(cur->left);\\n          ans += \\',\\';\\n          ans += to_string(cur->left->val);\\n        } else\\n          ans += \",null\";\\n        if (cur->right) {\\n          q.push_back(cur->right);\\n          ans += \\',\\';\\n          ans += to_string(cur->right->val);\\n        } else\\n          ans += \",null\";\\n      }\\n      if (!q.empty())\\n        fprintf(f, ans.data());\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else if constexpr (is_same_v<T, ListNode *>) {\\n    int c = 0;\\n    auto cur = val;\\n    fprintf(f, \"[\");\\n    while (cur) {\\n      fprintf(f, \"%s%d\", c++ ? \",\" : \"\", cur->val);\\n      cur = cur->next;\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else if constexpr (is_container<T>::value) {\\n    fprintf(f, \"[\");\\n    int c = 0;\\n    for (int i = 0; i < val.size(); i++) {\\n      fprintf(f, \"%s\", c++ ? \",\" : \"\");\\n      write<false>(f, val[i]);\\n    }\\n    fprintf(f, \"]%s\", end);\\n  } else\\n    static_assert(always_false<T>, \"writing for type not supported\");\\n}\\n\\ntemplate <typename Args, size_t... Idx>\\nvoid write_args(FILE *f, const Args &args, index_sequence<Idx...>) {\\n  ((fprintf(f, \"#%lld: \", Idx + 1), write<true>(f, get<Idx + 1>(args))), ...);\\n}\\n\\ntemplate <typename Solution, typename R, typename... Ts>\\nvoid exec(R (Solution::*fn)(Ts...)) {\\n  constexpr bool returns = !is_same_v<R, void>;\\n  auto out = fopen(\"output.txt\", \"w\");\\n  if constexpr (sizeof...(Ts) == 0) {\\n    if constexpr (returns) {\\n      write<true>(out, (Solution{}.*fn)());\\n    } else\\n      (Solution{}.*fn)();\\n  } else {\\n    auto in = fopen(\"input.txt\", \"r\");\\n    int c = fgetc(in);\\n    if (c == EOF) {\\n      fclose(in);\\n      return;\\n    } else\\n      ungetc(c, in);\\n    while (true) {\\n      if (char(c = fgetc(in)) == EOF)\\n        break;\\n      else\\n        ungetc(c, in);\\n      if (char(c = fgetc(in)) == \\'/\\') {\\n        while ((c = fgetc(in)) != \\'\\\\n\\' && c != EOF) {\\n        }\\n      } else {\\n        ungetc(c, in);\\n        tuple args{Solution{}, parse<decay_t<Ts>, true>(in, c)...};\\n        if constexpr (!returns) {\\n          apply(fn, args);\\n          fprintf(out, \"New state of parameters:\\\\n\");\\n          write_args(out, args, index_sequence_for<Ts...>{});\\n        } else\\n          write<true>(out, apply(fn, args));\\n#ifdef LC_LOCAL\\n        cout << endl;\\n#endif\\n      }\\n    }\\n    fclose(in);\\n  }\\n  fclose(out);\\n}\\n\\nvoid _print(const string &x) { cout << \\'\\\\\"\\' << x << \\'\\\\\"\\'; }\\nvoid _print(bool x) { cout << (x ? \"true\" : \"false\"); }\\ntemplate <typename T> enable_if_t<is_arithmetic_v<T>> _print(const T &x) {\\n  cout << x;\\n}\\ntemplate <typename T, size_t... Idx>\\nvoid _print2(const T &x, index_sequence<Idx...>) {\\n  int c = 0;\\n  ((cout << (c++ ? \",\" : \"\"), _print(get<Idx>(x))), ...);\\n}\\ntemplate <typename T> void_t<typename tuple_size<T>::type> _print(const T &x) {\\n  cout << \\'{\\';\\n  _print2(x, make_index_sequence<tuple_size_v<T>>{});\\n  cout << \\'}\\';\\n}\\ntemplate <typename T> enable_if_t<is_container<T>::value> _print(const T &x) {\\n  cout << \\'[\\';\\n  int c = 0;\\n  for (const auto &e : x) {\\n    cout << (c++ ? \",\" : \"\");\\n    _print(e);\\n  }\\n  cout << \\']\\';\\n}\\n\\n#define CONCAT_IMPL(x, y) x##y\\n#define CONCAT(x, y) CONCAT_IMPL(x, y)\\n#define NUM_ARGS_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\\n#define NUM_ARGS(...) NUM_ARGS_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\\n#define DBG_VAL(x) cout << \\'[\\' << #x << \" = \", _print(x), cout << \"] \"\\n#define DBG_1(x) DBG_VAL(x)\\n#define DBG_2(x, ...) DBG_VAL(x), DBG_1(__VA_ARGS__)\\n#define DBG_3(x, ...) DBG_VAL(x), DBG_2(__VA_ARGS__)\\n#define DBG_4(x, ...) DBG_VAL(x), DBG_3(__VA_ARGS__)\\n#define DBG_5(x, ...) DBG_VAL(x), DBG_4(__VA_ARGS__)\\n#define DBG_6(x, ...) DBG_VAL(x), DBG_5(__VA_ARGS__)\\n#define DBG_7(x, ...) DBG_VAL(x), DBG_6(__VA_ARGS__)\\n#define DBG_8(x, ...) DBG_VAL(x), DBG_7(__VA_ARGS__)\\n#define DBG_9(x, ...) DBG_VAL(x), DBG_8(__VA_ARGS__)\\n#define DBG_10(x, ...) DBG_VAL(x), DBG_9(__VA_ARGS__)\\n// supports up to 10 arguments debugging at one time\\n\\n#ifdef LC_LOCAL\\n#define dbg(...) CONCAT(DBG_, NUM_ARGS(__VA_ARGS__))(__VA_ARGS__), cout << endl\\n#else\\n#define dbg(...)\\n#endif\\n\\n#define all(x) begin(x), end(x)\\n#define has(c, x) (c.find(x) != c.end())\\n#define umap unordered_map\\n#define uset unordered_set\\n#define vec vector\\n#define valid(i, j, m, n) (i >= 0 && i < m && j >= 0 && j < n)\\n\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\ntemplate <typename T> T &amax(T &a, const T &b) { return a = max(a, b); }\\n\\nusing pii = pair<int, int>;\\nusing pipii = pair<int, pii>;\\nusing pippiipii = pair<int, pair<pii, pii>>;\\nusing ll = long long;\\n\\nnamespace std {\\ntemplate <typename T> class hash<std::pair<T, T>> {\\npublic:\\n  size_t operator()(const pair<T, T> &x) const {\\n    // https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes\\n    ll lhs = hash<T>()(x.first), rhs = hash<T>()(x.second);\\n    lhs ^= rhs + 0x9e3779b9 + (lhs << 6) + (lhs >> 2);\\n    return lhs;\\n  }\\n};\\n} // namespace std\\n\\nconstexpr int dx[] = {-1, 0, 0, 1, -1, -1, 1, 1};\\nconstexpr int dy[] = {0, 1, -1, 0, -1, 1, -1, 1};\\nconstexpr int INF = 1e9;\\nconstexpr double EPS = 1e-9;\\n\\n// ----- CHANGE FOR PROBLEM -----\\nclass Solution {\\n\\n  void dfs(vec<vec<int>> &grid, vec<vec<vec<pii>>> &adj, vec<vec<bool>> &vis,\\n           vec<vec<int>> &disc, vec<vec<int>> &low, int ip, int jp, int i,\\n           int j, int time, bool &res) {\\n    int children = 0;\\n    disc[i][j] = low[i][j] = time;\\n    vis[i][j] = false;\\n\\n    for (auto [i2, j2] : adj[i][j]) {\\n      if (vis[i2][j2]) {\\n        children++;\\n        dfs(grid, adj, vis, disc, low, i, j, i2, j2, time + 1, res);\\n        amin(low[i][j], low[i2][j2]);\\n        if (ip != -1 && jp != -1 && low[i2][j2] >= disc[i][j])\\n          res = true;\\n      } else if (i2 != ip || j2 != jp)\\n        amin(low[i][j], disc[i2][j2]);\\n    }\\n    if (ip == -1 && jp == -1 && children > 1)\\n      res = true;\\n  }\\n\\npublic:\\n  int minDays(vector<vector<int>> &grid) {\\n    int m = grid.size(), n = grid[0].size();\\n\\n    vec<vec<bool>> vis(m, vec<bool>(n));\\n    vec<vec<vec<pii>>> adj(m, vec<vec<pii>>(n));\\n    deque<pii> s;\\n    int is = INF, js = INF, islands = 0, lands = 0;\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] == 1) {\\n          lands++;\\n          if (!vis[i][j]) {\\n            islands++;\\n            if (islands == 2)\\n              return 0;\\n            deque<pii> q;\\n            q.push_back({i, j});\\n            vis[i][j] = true;\\n            is = i;\\n            js = j;\\n            while (!q.empty()) {\\n              auto [i2, j2] = q.front();\\n              q.pop_front();\\n              for (int k = 0; k < 4; k++) {\\n                int i3 = i2 + dx[k];\\n                int j3 = j2 + dy[k];\\n                if (valid(i3, j3, m, n) && grid[i3][j3] == 1 && !vis[i3][j3]) {\\n                  vis[i3][j3] = true;\\n                  q.push_back({i3, j3});\\n                }\\n              }\\n            }\\n          }\\n          for (int k = 0; k < 4; k++) {\\n            int i2 = i + dx[k];\\n            int j2 = j + dy[k];\\n            if (valid(i2, j2, m, n) && grid[i2][j2] == 1)\\n              adj[i][j].push_back({i2, j2});\\n          }\\n        }\\n      }\\n    }\\n    if (lands < 3)\\n      return lands;\\n    dbg(adj, is, js);\\n\\n    vec<vec<int>> disc(m, vec<int>(n));\\n    vec<vec<int>> low(m, vec<int>(n));\\n    bool res = false;\\n    dfs(grid, adj, vis, disc, low, -1, -1, is, js, 1, res);\\n    dbg(res);\\n    if (res)\\n      return 1;\\n\\n    int ans = INF;\\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {\\n        if (grid[i][j] != 1)\\n          continue;\\n        int res = INF, vertical = INF, horizontal = INF, slice = INF;\\n        if (i > 0 && i < m - 1) {\\n          int l = 0, r = 0;\\n          bool cut_l = false, cut_r = false;\\n          for (int k = j - 1; k >= 0 && grid[i][k] == 1; k--, l++) {\\n            cut_l = true;\\n          }\\n          for (int k = j + 1; k < n && grid[i][k] == 1; k++, r++) {\\n            cut_r = true;\\n          }\\n          if (cut_l || cut_r)\\n            horizontal = l + r + 1;\\n        }\\n        if (j > 0 && j < n - 1) {\\n          int l = 0, r = 0;\\n          bool cut_l = false, cut_r = false;\\n          for (int k = i - 1; k >= 0 && grid[k][j] == 1; k--, l++) {\\n            cut_l = true;\\n          }\\n          for (int k = i + 1; k < m && grid[k][j] == 1; k++, l++) {\\n            cut_r = true;\\n          }\\n          if (cut_l || cut_r)\\n            vertical = l + r + 1;\\n        }\\n        int l = 0, r = 0;\\n        bool cut_l = false, cut_r = false;\\n        for (int i2 = i - 1, j2 = j - 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2--, j2--, l++) {\\n          cut_l = true;\\n        }\\n        for (int i2 = i + 1, j2 = j + 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2++, j2++, r++) {\\n          cut_r = true;\\n        }\\n        if (cut_l || cut_r)\\n          amin(slice, l + r + 1);\\n        l = 0, r = 0;\\n        cut_l = false, cut_r = false;\\n        for (int i2 = i - 1, j2 = j + 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2--, j2++, l++) {\\n          cut_l = true;\\n        }\\n        for (int i2 = i + 1, j2 = j - 1;\\n             valid(i2, j2, m, n) && grid[i2][j2] == 1; i2++, j2--, r++) {\\n          cut_r = true;\\n        }\\n        if (cut_l || cut_r)\\n          amin(slice, l + r + 1);\\n        ans = min({ans, horizontal, vertical, slice});\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n// ----- CHANGE FOR PROBLEM -----\\n\\n#ifdef LC_LOCAL\\nint main() {\\n  ios_base::sync_with_stdio(false);\\n  cin.tie(NULL);\\n  exec(&Solution::minDays); // CHANGE FOR PROBLEM\\n}\\n#endif\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1803634,
                "title": "dfs-solution",
                "content": "Answer can only be 0, 1 or 2\\nCase1: If there are more than 1 islands on initial grid -> 0\\nCase2: If by changing one grid item from 1 to 0, two islands are formed -> 1\\nCase3: Else -> 2\\n\\nSteps -\\n1. Count islands\\n2. If Case1 -> 0\\n3. Else check for Case2. Loop through grid and for each 1, convert to 0. This takes one day. Use countIslands to check if more than 1 island is formed. If true return 1, else convert the position back to 1 and continue the loop\\n4. Else it\\'s Case3 -> 2\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minDays = function(grid) {\\n    if(countIslands(grid) !== 1) return 0\\n    \\n    const rows = grid.length\\n    const columns = grid[0].length\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < columns; c++) {\\n            if(grid[r][c]) {\\n                grid[r][c] = 0\\n                if(countIslands(grid) !== 1) return 1\\n                grid[r][c] = 1\\n            }\\n        }\\n    }\\n    \\n    return 2\\n};\\n\\nfunction getKey(i, j) {\\n    return `${i}-${j}`\\n}\\n\\nfunction countIslands(grid) {\\n    const visited = new Set()\\n    let islands  = 0\\n    const rows = grid.length\\n    const columns = grid[0].length\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < columns; c++) {\\n            const key = getKey(r, c)\\n            if(grid[r][c] && !visited.has(key)) {\\n                islands++\\n                dfs(grid, r, c, visited)\\n            }\\n        }\\n    }\\n    \\n    return islands\\n}\\n\\nfunction dfs(grid, r, c, visited) {\\n    const dir = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    if(isValid(grid, r, c, visited)) {\\n        const key = getKey(r, c)\\n        visited.add(key)\\n        for(const [dx, dy] of dir) {\\n            dfs(grid, r + dx, c + dy, visited)\\n        }\\n    }\\n}\\n\\nfunction isValid(grid, r, c, visited) {\\n    const key = getKey(r, c)\\n    if(r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] && !visited.has(key)) return true\\n       \\n     return false\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minDays = function(grid) {\\n    if(countIslands(grid) !== 1) return 0\\n    \\n    const rows = grid.length\\n    const columns = grid[0].length\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < columns; c++) {\\n            if(grid[r][c]) {\\n                grid[r][c] = 0\\n                if(countIslands(grid) !== 1) return 1\\n                grid[r][c] = 1\\n            }\\n        }\\n    }\\n    \\n    return 2\\n};\\n\\nfunction getKey(i, j) {\\n    return `${i}-${j}`\\n}\\n\\nfunction countIslands(grid) {\\n    const visited = new Set()\\n    let islands  = 0\\n    const rows = grid.length\\n    const columns = grid[0].length\\n    \\n    for(let r = 0; r < rows; r++) {\\n        for(let c = 0; c < columns; c++) {\\n            const key = getKey(r, c)\\n            if(grid[r][c] && !visited.has(key)) {\\n                islands++\\n                dfs(grid, r, c, visited)\\n            }\\n        }\\n    }\\n    \\n    return islands\\n}\\n\\nfunction dfs(grid, r, c, visited) {\\n    const dir = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n    if(isValid(grid, r, c, visited)) {\\n        const key = getKey(r, c)\\n        visited.add(key)\\n        for(const [dx, dy] of dir) {\\n            dfs(grid, r + dx, c + dy, visited)\\n        }\\n    }\\n}\\n\\nfunction isValid(grid, r, c, visited) {\\n    const key = getKey(r, c)\\n    if(r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] && !visited.has(key)) return true\\n       \\n     return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713905,
                "title": "c-tarjan-s-algorithm-81-faster-24-ms",
                "content": "```\\n    int time;\\n    int rootCalls;\\n    \\n    void dfs(vector<vector<int>> &gr, int u , int par, vector<int> &disc,vector<int> &low,vector<bool> &vis, vector<bool> &AP)\\n    {\\n        disc[u] = low[u] = time++;\\n        \\n        vis[u] = true;\\n        \\n        for(int v : gr[u])\\n        {\\n            if(!vis[v])\\n            {\\n                \\n                if(par == -1)\\n                    rootCalls++;\\n                \\n                dfs(gr, v , u, disc, low, vis, AP);\\n                if(disc[u] <= low[v])\\n                {\\n                    AP[u] = true;\\n                }\\n                \\n                low[u] = min(low[u], low[v]);\\n                \\n            }\\n            else if(v != par)\\n            {\\n                low[u] = min(low[u], disc[v]);\\n            }\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> gr(n * m);\\n        vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        int OneCnt = 0;\\n        \\n        //Make Graph \\n        //Each grid is numbered as (i * m + j)\\n        \\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    OneCnt++;\\n                    int num1 = j + i * m;\\n                    for(int k = 0; k < 4; k++)\\n                    {\\n                        int x = i + dir[k][0], y = j + dir[k][1];\\n                        if(x < n && x >= 0 && y < m && y >= 0 && grid[x][y] == 1)\\n                        {\\n                            int num2 = y + x * m;\\n                            gr[num1].push_back(num2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<int> disc(n * m), low(n * m);\\n        vector<bool> vis(n * m, false), AP(n * m, false);\\n        int x = 0;\\n        time = 0;\\n\\n        \\n        \\n        //Run Normal Trajan\\'s Algorithm\\n        for(int i = 0; i < n * m; i++)\\n        {\\n            rootCalls = 0;\\n            int r = i / m;\\n            int c = i % m;\\n            if(!vis[i] && grid[r][c] == 1)\\n            {\\n                dfs(gr, i , -1, disc, low, vis, AP);\\n                x++;\\n            }\\n            if(rootCalls == 1)\\n            {\\n                AP[i] = false;\\n            }\\n            \\n        }\\n        \\n        \\n        // if x > 1 means that components were disconnected from beginning\\n        if(x > 1)\\n        {\\n            return 0;\\n        }\\n        \\n        //check if there is one vertex(grid) such that it is critical/ Articulation point\\n        for(int z : AP)\\n        {\\n            if(z)return 1;\\n        }\\n        \\n        //Handle the corner cases\\n        if(OneCnt == 0)\\n        {\\n            return 0;\\n        }\\n        if(OneCnt == 1)\\n            return 1;\\n\\n        \\n        return 2;\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\n    int time;\\n    int rootCalls;\\n    \\n    void dfs(vector<vector<int>> &gr, int u , int par, vector<int> &disc,vector<int> &low,vector<bool> &vis, vector<bool> &AP)\\n    {\\n        disc[u] = low[u] = time++;\\n        \\n        vis[u] = true;\\n        \\n        for(int v : gr[u])\\n        {\\n            if(!vis[v])\\n            {\\n                \\n                if(par == -1)\\n                    rootCalls++;\\n                \\n                dfs(gr, v , u, disc, low, vis, AP);\\n                if(disc[u] <= low[v])\\n                {\\n                    AP[u] = true;\\n                }\\n                \\n                low[u] = min(low[u], low[v]);\\n                \\n            }\\n            else if(v != par)\\n            {\\n                low[u] = min(low[u], disc[v]);\\n            }\\n        }\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int>> gr(n * m);\\n        vector<vector<int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        int OneCnt = 0;\\n        \\n        //Make Graph \\n        //Each grid is numbered as (i * m + j)\\n        \\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    OneCnt++;\\n                    int num1 = j + i * m;\\n                    for(int k = 0; k < 4; k++)\\n                    {\\n                        int x = i + dir[k][0], y = j + dir[k][1];\\n                        if(x < n && x >= 0 && y < m && y >= 0 && grid[x][y] == 1)\\n                        {\\n                            int num2 = y + x * m;\\n                            gr[num1].push_back(num2);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<int> disc(n * m), low(n * m);\\n        vector<bool> vis(n * m, false), AP(n * m, false);\\n        int x = 0;\\n        time = 0;\\n\\n        \\n        \\n        //Run Normal Trajan\\'s Algorithm\\n        for(int i = 0; i < n * m; i++)\\n        {\\n            rootCalls = 0;\\n            int r = i / m;\\n            int c = i % m;\\n            if(!vis[i] && grid[r][c] == 1)\\n            {\\n                dfs(gr, i , -1, disc, low, vis, AP);\\n                x++;\\n            }\\n            if(rootCalls == 1)\\n            {\\n                AP[i] = false;\\n            }\\n            \\n        }\\n        \\n        \\n        // if x > 1 means that components were disconnected from beginning\\n        if(x > 1)\\n        {\\n            return 0;\\n        }\\n        \\n        //check if there is one vertex(grid) such that it is critical/ Articulation point\\n        for(int z : AP)\\n        {\\n            if(z)return 1;\\n        }\\n        \\n        //Handle the corner cases\\n        if(OneCnt == 0)\\n        {\\n            return 0;\\n        }\\n        if(OneCnt == 1)\\n            return 1;\\n\\n        \\n        return 2;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1659083,
                "title": "java-solution-with-tarjan-algorithm-to-find-articulation-point",
                "content": "```\\nclass Solution {\\n    int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    public int minDays(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int numOfIslands = 0;\\n        boolean hasArticulationPoint = false;\\n        int color = 1;\\n        int minIslandSize = m*n;\\n        int[][] time = new int[m][n];\\n        int[][] low = new int[m][n];\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    numOfIslands++;\\n                    color++;\\n                    List<Integer> articulationPoints = new ArrayList<>();\\n                    int[] islandSize = new int[1];\\n                    tarjan(i, j, -1, -1, 0, time, low, grid, articulationPoints, color, islandSize);\\n                    minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n                    if(articulationPoints.size()>0)hasArticulationPoint = true;\\n                }\\n            }\\n        }\\n        \\n        if(numOfIslands>=2)return 0;\\n        if(numOfIslands==0)return 0;\\n        if(numOfIslands==1 && minIslandSize == 1)return 1;\\n        return hasArticulationPoint ? 1  : 2;\\n    }\\n    \\n    public void tarjan(int x, int y, int prex, int prey, int time, int[][] times, int[][] lows, int[][] grid, List<Integer> articulationPoints, int color, int[] islandSize)\\n    {\\n        boolean log = false;\\n        if(x==1&&y==1)log = true;\\n        times[x][y] = time;\\n        lows[x][y] = time;\\n        grid[x][y] = color;\\n        islandSize[0]++;\\n        int children = 0;\\n        for(int[] dir : dirs)\\n        {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if(nx<0||ny<0||nx>=grid.length||ny>=grid[0].length)\\n            {\\n                continue;\\n            }\\n            \\n            if(grid[nx][ny]==1)\\n            {\\n                children++;\\n                tarjan(nx,ny,x,y,time+1,times,lows,grid,articulationPoints,color,islandSize);\\n                lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n                // Diff from detecting bridge: \\n                // Detecting bridge: lows[nx][ny]>times[x][y]\\n                // Detecting articulation point: lows[nx][ny]>=times[x][y]\\n                // and articulation point also requires check on if curnode is root node\\n                // if is root node, and there are more than 1 independent children, then it\\'s articulation point.\\n                // if is not root node, then check: lows[nx][ny]>=times[x][y]\\n                if(prex != -1 && lows[nx][ny]>=time)\\n                {\\n                    articulationPoints.add(x * grid.length + y);\\n                }\\n            }\\n            else if((nx!=prex||ny!=prey) && grid[nx][ny]!=0)\\n            {\\n                lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n            }\\n        }\\n        \\n        if(prex==-1 && children > 1)\\n        {\\n            articulationPoints.add(x * grid.length + y);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}};\\n    public int minDays(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int numOfIslands = 0;\\n        boolean hasArticulationPoint = false;\\n        int color = 1;\\n        int minIslandSize = m*n;\\n        int[][] time = new int[m][n];\\n        int[][] low = new int[m][n];\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    numOfIslands++;\\n                    color++;\\n                    List<Integer> articulationPoints = new ArrayList<>();\\n                    int[] islandSize = new int[1];\\n                    tarjan(i, j, -1, -1, 0, time, low, grid, articulationPoints, color, islandSize);\\n                    minIslandSize = Math.min(minIslandSize, islandSize[0]);\\n                    if(articulationPoints.size()>0)hasArticulationPoint = true;\\n                }\\n            }\\n        }\\n        \\n        if(numOfIslands>=2)return 0;\\n        if(numOfIslands==0)return 0;\\n        if(numOfIslands==1 && minIslandSize == 1)return 1;\\n        return hasArticulationPoint ? 1  : 2;\\n    }\\n    \\n    public void tarjan(int x, int y, int prex, int prey, int time, int[][] times, int[][] lows, int[][] grid, List<Integer> articulationPoints, int color, int[] islandSize)\\n    {\\n        boolean log = false;\\n        if(x==1&&y==1)log = true;\\n        times[x][y] = time;\\n        lows[x][y] = time;\\n        grid[x][y] = color;\\n        islandSize[0]++;\\n        int children = 0;\\n        for(int[] dir : dirs)\\n        {\\n            int nx = x + dir[0];\\n            int ny = y + dir[1];\\n            if(nx<0||ny<0||nx>=grid.length||ny>=grid[0].length)\\n            {\\n                continue;\\n            }\\n            \\n            if(grid[nx][ny]==1)\\n            {\\n                children++;\\n                tarjan(nx,ny,x,y,time+1,times,lows,grid,articulationPoints,color,islandSize);\\n                lows[x][y] = Math.min(lows[x][y], lows[nx][ny]);\\n                // Diff from detecting bridge: \\n                // Detecting bridge: lows[nx][ny]>times[x][y]\\n                // Detecting articulation point: lows[nx][ny]>=times[x][y]\\n                // and articulation point also requires check on if curnode is root node\\n                // if is root node, and there are more than 1 independent children, then it\\'s articulation point.\\n                // if is not root node, then check: lows[nx][ny]>=times[x][y]\\n                if(prex != -1 && lows[nx][ny]>=time)\\n                {\\n                    articulationPoints.add(x * grid.length + y);\\n                }\\n            }\\n            else if((nx!=prex||ny!=prey) && grid[nx][ny]!=0)\\n            {\\n                lows[x][y] = Math.min(lows[x][y], times[nx][ny]);\\n            }\\n        }\\n        \\n        if(prex==-1 && children > 1)\\n        {\\n            articulationPoints.add(x * grid.length + y);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655254,
                "title": "go-modularized-solution-with-dfs",
                "content": "Prior to solving this problem, I recommend checking the following two problems first:\\n\\n*  [Number of Islands](https://leetcode.com/problems/number-of-islands/)\\n*  [Critical Connections in a Network](https://leetcode.com/problems/critical-connections-in-a-network/)\\n\\nBellow are the steps to a full implementation:\\n\\n1. Find the number of islands `numIslands`.\\n2. If `numIslands != 1`, we already have disconnected islands, so return 0.\\n3. Find number of lands `numLands` (grid cells with value 1). Obviously, `numLands > 0`.\\n4. If `numLands == 1` return 1. (Just remove the land).\\n5. If `numLands == 2` return 2. (Remove both lands).\\n6. Now, we just a new graph problem: Consider land cells as nodes and their connection to adjacent lands as edges. The problem is now to find if the graph has a bridge.\\n7. If the graph has a bridge, return 1. (Just remove the bridge and get two connected components).\\n8. Else, return 2. (We can always remove two edges to increase the number of connected components.\\n\\nThe algorithm has `O(mn)` time and space complexity, where `m x n` is the grid size.\\n\\n```\\nfunc minDays(grid [][]int) int {\\n    numIslands := findNumIslands(grid)\\n    if numIslands != 1 {\\n        return 0\\n    }\\n    numLands := findNumLands(grid)\\n    if numLands < 3 {\\n        return numLands\\n    }\\n    if hasBridge(grid) {\\n        return 1\\n    }\\n    return 2\\n}\\n\\nfunc findNumIslands(grid [][]int) int  {\\n    ans := 0\\n    visited := make([][]bool, len(grid))\\n    for i := range grid {\\n        visited[i] = make([]bool, len(grid[i]))\\n    }\\n    for i := range grid {\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 && !visited[i][j] {\\n                ans++\\n                dfs(grid, i, j, visited)\\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc dfs(grid [][]int, i, j int, visited [][]bool) {\\n    visited[i][j] = true\\n    dirs := [][]int{[]int{-1,0}, []int{0,-1}, []int{0,1}, []int{1,0}}\\n    for _, dir := range dirs {\\n        x, y := i+dir[0], j+dir[1]\\n        if x < 0 || y < 0 || x >= len(grid) || y >= len(grid[i]) {\\n            continue\\n        }\\n        if grid[x][y] == 0 || visited[x][y] {\\n            continue\\n        }\\n        dfs(grid, x, y, visited)\\n    }\\n}\\n\\nfunc findNumLands(grid [][]int) int {\\n    ans := 0\\n    for i := range grid {\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 {\\n                ans++\\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc hasBridge(grid [][]int) bool {\\n    adj := makeAdj(grid)\\n    disc := map[int]int{}\\n    low := map[int]int{}\\n    var first int\\n    for k := range adj {\\n        first = k\\n        break\\n    }\\n    node, parent, time := first, -1, 1\\n    return bridgeDfs(node, parent, time, adj, disc, low)\\n}\\n\\nfunc bridgeDfs(node, parent, time int, adj map[int][]int, disc, low map[int]int) bool {\\n    disc[node] = time\\n    low[node] = time\\n    for _, next := range adj[node] {\\n        if next == parent {\\n            continue\\n        }\\n        if disc[next] == 0 {\\n            if bridgeDfs(next, node, time+1, adj, disc, low) {\\n                return true\\n            }\\n            low[node] = min(low[node], low[next])\\n            if low[next] > disc[node] {\\n                return true\\n            }\\n        } else {\\n            low[node] = min(low[node], disc[next])\\n        }\\n    }\\n    return false\\n}\\n\\nfunc makeAdj(grid [][]int) map[int][]int {\\n    ans := map[int][]int{}\\n    for i := range grid {\\n        n := len(grid[i])\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 {\\n                dirs := [][]int{[]int{-1,0}, []int{0,-1}, []int{0,1}, []int{1,0}}\\n                for _, dir := range dirs {\\n                    x, y := i+dir[0], j+dir[1]\\n                    if x < 0 || y < 0 || x >= len(grid) || y >= len(grid[i]) {\\n                        continue\\n                    }\\n                    if grid[x][y] == 1 {\\n                        ans[i*n+j] = append(ans[i*n+j], x*n+y)\\n                    }\\n                }                \\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nfunc minDays(grid [][]int) int {\\n    numIslands := findNumIslands(grid)\\n    if numIslands != 1 {\\n        return 0\\n    }\\n    numLands := findNumLands(grid)\\n    if numLands < 3 {\\n        return numLands\\n    }\\n    if hasBridge(grid) {\\n        return 1\\n    }\\n    return 2\\n}\\n\\nfunc findNumIslands(grid [][]int) int  {\\n    ans := 0\\n    visited := make([][]bool, len(grid))\\n    for i := range grid {\\n        visited[i] = make([]bool, len(grid[i]))\\n    }\\n    for i := range grid {\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 && !visited[i][j] {\\n                ans++\\n                dfs(grid, i, j, visited)\\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc dfs(grid [][]int, i, j int, visited [][]bool) {\\n    visited[i][j] = true\\n    dirs := [][]int{[]int{-1,0}, []int{0,-1}, []int{0,1}, []int{1,0}}\\n    for _, dir := range dirs {\\n        x, y := i+dir[0], j+dir[1]\\n        if x < 0 || y < 0 || x >= len(grid) || y >= len(grid[i]) {\\n            continue\\n        }\\n        if grid[x][y] == 0 || visited[x][y] {\\n            continue\\n        }\\n        dfs(grid, x, y, visited)\\n    }\\n}\\n\\nfunc findNumLands(grid [][]int) int {\\n    ans := 0\\n    for i := range grid {\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 {\\n                ans++\\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc hasBridge(grid [][]int) bool {\\n    adj := makeAdj(grid)\\n    disc := map[int]int{}\\n    low := map[int]int{}\\n    var first int\\n    for k := range adj {\\n        first = k\\n        break\\n    }\\n    node, parent, time := first, -1, 1\\n    return bridgeDfs(node, parent, time, adj, disc, low)\\n}\\n\\nfunc bridgeDfs(node, parent, time int, adj map[int][]int, disc, low map[int]int) bool {\\n    disc[node] = time\\n    low[node] = time\\n    for _, next := range adj[node] {\\n        if next == parent {\\n            continue\\n        }\\n        if disc[next] == 0 {\\n            if bridgeDfs(next, node, time+1, adj, disc, low) {\\n                return true\\n            }\\n            low[node] = min(low[node], low[next])\\n            if low[next] > disc[node] {\\n                return true\\n            }\\n        } else {\\n            low[node] = min(low[node], disc[next])\\n        }\\n    }\\n    return false\\n}\\n\\nfunc makeAdj(grid [][]int) map[int][]int {\\n    ans := map[int][]int{}\\n    for i := range grid {\\n        n := len(grid[i])\\n        for j := range grid[i] {\\n            if grid[i][j] == 1 {\\n                dirs := [][]int{[]int{-1,0}, []int{0,-1}, []int{0,1}, []int{1,0}}\\n                for _, dir := range dirs {\\n                    x, y := i+dir[0], j+dir[1]\\n                    if x < 0 || y < 0 || x >= len(grid) || y >= len(grid[i]) {\\n                        continue\\n                    }\\n                    if grid[x][y] == 1 {\\n                        ans[i*n+j] = append(ans[i*n+j], x*n+y)\\n                    }\\n                }                \\n            }\\n        }\\n    }\\n    return ans\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653252,
                "title": "java-tarjan-s-algo-to-detect-bridge-o-mn-easy-to-understand",
                "content": "Observations for the problems\\n- when number of island are more than 1, it is already disconnected. Answer is 0.\\n- When number of islands is 0, then already no land. Answer is 0.\\n- When number of islands is 1, then we have check if any bridge exists i.e. if a edge is removed from the graph, then graph becomes disconnected, such edge is called bridge.\\n\\nWe can find the bridge edge by using Tarjan\\'s algorithm to detect Articulation point or bridge. Only problem here is to construct a graph to implement tarjan\\'s alrogithm on it.\\nSo, we first build the graph, and then apply standard Tarjan\\'s algorithm to detect the bridge edge. If we find the bridge edge, then answer is 1, else 2.\\n\\n```\\nclass Solution {\\n    \\n    int nodes;\\n    int N;\\n    int M;\\n    \\n    Map<Integer, List<Integer>> adjList;\\n    boolean bridgeFound = false;\\n    \\n    int root = -1;\\n    \\n    public int minDays(int[][] grid) {\\n        \\n        N = grid.length;\\n        M = grid[0].length;\\n        \\n        adjList = new HashMap<>();\\n        \\n        boolean[][] visited = new boolean[N][M];\\n        int islands = numOfIsland(grid, visited);\\n        \\n        if(islands != 1) return 0;\\n        if(nodes == 1) return 1;\\n        if(nodes==2) return 2;\\n        \\n        buildGraph(grid);\\n        \\n        Map<Integer, Integer> low = new HashMap<>();\\n        Set<Integer> visited2 = new HashSet<>();\\n        tarjan(low, visited2, -1, root, 0);\\n\\t\\t\\n        if(bridgeFound) return 1;\\n        return 2;\\n        \\n    }\\n    \\n    void tarjan(Map<Integer, Integer> low, Set<Integer> visited, int parent, int vertex, int time) {\\n        visited.add(vertex);\\n        low.put(vertex, time);\\n        \\n        for(int t: adjList.get(vertex)){\\n            if(t==parent) continue;\\n            if(!visited.contains(t)) {\\n                tarjan(low, visited, vertex, t, time+1);\\n            }\\n            low.put(vertex, Math.min(low.get(vertex), low.get(t)));\\n            if(time < low.get(t)) {\\n                bridgeFound = true;\\n            }\\n        }\\n        \\n    }\\n    \\n    void buildGraph(int[][] grid) {\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<M;j++){\\n                if(grid[i][j] == 1){\\n                    \\n                    if(i-1>=0) addEdge(i, j, i-1, j, grid);\\n                    if(i+1<grid.length) addEdge(i, j, i+1, j, grid);\\n                    if(j-1>=0) addEdge(i, j, i, j-1, grid);\\n                    if(j+1<grid[0].length) addEdge(i, j, i, j+1, grid);\\n                    \\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(int prevX, int prevY, int x, int y, int[][] grid){\\n        if(grid[x][y] == 0) return;\\n        int u = prevX * M + prevY;\\n        int v = x*M + y;\\n        \\n        if(!adjList.containsKey(u)) adjList.put(u, new ArrayList<>());\\n        if(!adjList.containsKey(v)) adjList.put(v, new ArrayList<>());\\n        \\n        adjList.get(u).add(v);\\n        adjList.get(v).add(u);\\n    }\\n    \\n    int numOfIsland(int[][] grid, boolean[][] visited) {\\n        int islandCount = 0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++) {\\n                if(!visited[i][j] && grid[i][j] == 1){\\n                    if(root == -1) root = i*M + j;\\n                    \\n                    islandCount++;\\n                    dfs(grid, i, j, visited);\\n                    \\n                }\\n            }\\n        }\\n        return islandCount;\\n        \\n    }\\n    \\n    void dfs(int[][] grid, int i, int j, boolean[][] visited){\\n        if(visited[i][j]) return;\\n        if(grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        nodes++;    \\n        \\n        if(i-1>=0) dfs(grid, i-1, j, visited);\\n        if(i+1<grid.length) dfs(grid, i+1, j, visited);\\n        if(j-1>=0) dfs(grid, i, j-1, visited);\\n        if(j+1<grid[0].length) dfs(grid, i, j+1, visited);\\n    }\\n}\\n```\\n\\nTime Complexity: O(N*M)\\nThis can optimised more in term of space complexity, but didn\\'t for sake of easy understanding.",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int nodes;\\n    int N;\\n    int M;\\n    \\n    Map<Integer, List<Integer>> adjList;\\n    boolean bridgeFound = false;\\n    \\n    int root = -1;\\n    \\n    public int minDays(int[][] grid) {\\n        \\n        N = grid.length;\\n        M = grid[0].length;\\n        \\n        adjList = new HashMap<>();\\n        \\n        boolean[][] visited = new boolean[N][M];\\n        int islands = numOfIsland(grid, visited);\\n        \\n        if(islands != 1) return 0;\\n        if(nodes == 1) return 1;\\n        if(nodes==2) return 2;\\n        \\n        buildGraph(grid);\\n        \\n        Map<Integer, Integer> low = new HashMap<>();\\n        Set<Integer> visited2 = new HashSet<>();\\n        tarjan(low, visited2, -1, root, 0);\\n\\t\\t\\n        if(bridgeFound) return 1;\\n        return 2;\\n        \\n    }\\n    \\n    void tarjan(Map<Integer, Integer> low, Set<Integer> visited, int parent, int vertex, int time) {\\n        visited.add(vertex);\\n        low.put(vertex, time);\\n        \\n        for(int t: adjList.get(vertex)){\\n            if(t==parent) continue;\\n            if(!visited.contains(t)) {\\n                tarjan(low, visited, vertex, t, time+1);\\n            }\\n            low.put(vertex, Math.min(low.get(vertex), low.get(t)));\\n            if(time < low.get(t)) {\\n                bridgeFound = true;\\n            }\\n        }\\n        \\n    }\\n    \\n    void buildGraph(int[][] grid) {\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<M;j++){\\n                if(grid[i][j] == 1){\\n                    \\n                    if(i-1>=0) addEdge(i, j, i-1, j, grid);\\n                    if(i+1<grid.length) addEdge(i, j, i+1, j, grid);\\n                    if(j-1>=0) addEdge(i, j, i, j-1, grid);\\n                    if(j+1<grid[0].length) addEdge(i, j, i, j+1, grid);\\n                    \\n                }\\n            }\\n        }\\n    }\\n    \\n    void addEdge(int prevX, int prevY, int x, int y, int[][] grid){\\n        if(grid[x][y] == 0) return;\\n        int u = prevX * M + prevY;\\n        int v = x*M + y;\\n        \\n        if(!adjList.containsKey(u)) adjList.put(u, new ArrayList<>());\\n        if(!adjList.containsKey(v)) adjList.put(v, new ArrayList<>());\\n        \\n        adjList.get(u).add(v);\\n        adjList.get(v).add(u);\\n    }\\n    \\n    int numOfIsland(int[][] grid, boolean[][] visited) {\\n        int islandCount = 0;\\n\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++) {\\n                if(!visited[i][j] && grid[i][j] == 1){\\n                    if(root == -1) root = i*M + j;\\n                    \\n                    islandCount++;\\n                    dfs(grid, i, j, visited);\\n                    \\n                }\\n            }\\n        }\\n        return islandCount;\\n        \\n    }\\n    \\n    void dfs(int[][] grid, int i, int j, boolean[][] visited){\\n        if(visited[i][j]) return;\\n        if(grid[i][j] == 0) return;\\n        \\n        visited[i][j] = true;\\n        nodes++;    \\n        \\n        if(i-1>=0) dfs(grid, i-1, j, visited);\\n        if(i+1<grid.length) dfs(grid, i+1, j, visited);\\n        if(j-1>=0) dfs(grid, i, j-1, visited);\\n        if(j+1<grid[0].length) dfs(grid, i, j+1, visited);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631266,
                "title": "c-articulation-points",
                "content": "\\tthe number of days would be either 0, 1, or 2\\n\\n\\tif there are more than 1 componenents (or more than 1 island in the matrix), then it is already disconnected and hence 0 days are required\\n\\tif these is only one component, then\\n\\tconsitruct the graph - a cell (i, j) is represented as cols*i + j in the graph.\\n\\tCount the number of articulation points in the graph. If there exists an articulation point, then one such node exist, if when removed would disconnect the graph into more than one component\\n\\tif there are no articulation points, we would be forced to remove two nodes to make it disconnected\\n\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\tvector<vector<bool>> visMat;\\n\\n\\tint dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n\\tbool isValid(int i, int j, vector<vector<int>> &grid) {\\n\\n\\t\\treturn (i >= 0 && j >= 0 && i < grid.size() && j < grid[0].size());\\n\\t}\\n\\n\\tvector<int> parent;\\n\\tvector<int> low;\\n\\tvector<int> disc;\\n\\tvector<bool> vis;\\n\\tvector<bool> ap;\\n\\n\\n\\tvoid dfs(vector<vector<int>> &grid, int i, int j) {\\n\\n\\t\\tvisMat[i][j] = true;\\n\\t\\tfor (auto d : dirs) {\\n\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\tif (isValid(ni, nj, grid) && !visMat[ni][nj] && grid[ni][nj] == 1) {dfs(grid, ni, nj);}\\n\\t\\t}\\n\\t}\\n\\n\\n\\tint time = 0;\\n\\tvoid dfsArticulation(vector<set<int>> &graph, int u) {\\n\\n\\t\\t// cout << \"At \" << u << \" \";\\n\\n\\t\\tlow[u] = disc[u] = ++time;\\n\\t\\tvis[u] = true;\\n\\t\\tint dfsCount = 0;\\n\\n\\t\\tfor (int v : graph[u]) {\\n\\n\\t\\t\\tif (v == parent[u]) continue;\\n\\n\\t\\t\\telse if (vis[v]) low[u] = min(low[u], disc[v]);\\n\\n\\t\\t\\telse {\\n\\t\\t\\t\\tdfsCount++;\\n\\t\\t\\t\\tparent[v] = u;\\n\\t\\t\\t\\tdfsArticulation(graph, v);\\n\\t\\t\\t\\tlow[u] = min(low[u], low[v]);\\n\\n\\t\\t\\t\\tif (parent[u] == -1) {\\n\\n\\t\\t\\t\\t\\tif (dfsCount > 1) {\\n\\t\\t\\t\\t\\t\\tif (low[v] >= disc[u]) {\\n\\t\\t\\t\\t\\t\\t\\tap[u] = true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse  {\\n\\t\\t\\t\\t\\tif (low[v] >= disc[u]) ap[u] = true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t}\\n\\n\\n\\tint minDays(vector<vector<int>>& grid) {\\n\\t\\tint rows = grid.size();\\n\\t\\tint cols = grid[0].size();\\n\\t\\tint comps = 0;\\n\\t\\tint onesCount = 0;\\n\\n\\t\\tvisMat.resize(rows, vector<bool> (cols, false));\\n\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\tonesCount += grid[i][j];\\n\\t\\t\\t\\tif (grid[i][j] == 1 && !visMat[i][j]) {\\n\\t\\t\\t\\t\\tdfs(grid, i, j);\\n\\t\\t\\t\\t\\tcomps++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (onesCount == 1) return 1;\\n\\t\\t// cout << \"Comps : \" << comps << \\'\\\\n\\';\\n\\t\\tif (comps > 1) return 0;\\n\\n\\n\\t\\tvector<set<int>> graph(rows * cols + 1);\\n\\t\\tparent.resize(rows * cols + 1);\\n\\t\\tlow.resize(rows * cols + 1);\\n\\t\\tdisc.resize(rows * cols + 1);\\n\\t\\tvis.resize(rows * cols + 1, false);\\n\\t\\tap.resize(rows * cols + 1, false);\\n\\n\\t\\tint src = -1;\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\n\\t\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\n\\n\\t\\t\\t\\tif (src == -1) src = cols * i + j;\\n\\n\\t\\t\\t\\tfor (auto d : dirs) {\\n\\n\\t\\t\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\t\\t\\tif (isValid(ni, nj, grid) && grid[ni][nj] == 1) {\\n\\n\\t\\t\\t\\t\\t\\tgraph[cols * i + j].insert(cols * ni + nj);\\n\\t\\t\\t\\t\\t\\tgraph[cols * ni + nj].insert(cols * i + j);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tparent[src] = -1;\\n\\t\\tint artiPoints = 0;\\n\\t\\tdfsArticulation(graph, src);\\n\\n\\n\\t\\tfor (int i = 0; i < ap.size(); i++) {\\n\\t\\t\\tif (ap[i]) return 1;\\n\\n\\t\\t}\\n\\n\\t\\treturn 2;\\n\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\tvector<vector<bool>> visMat;\\n\\n\\tint dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};\\n\\tbool isValid(int i, int j, vector<vector<int>> &grid) {\\n\\n\\t\\treturn (i >= 0 && j >= 0 && i < grid.size() && j < grid[0].size());\\n\\t}\\n\\n\\tvector<int> parent;\\n\\tvector<int> low;\\n\\tvector<int> disc;\\n\\tvector<bool> vis;\\n\\tvector<bool> ap;\\n\\n\\n\\tvoid dfs(vector<vector<int>> &grid, int i, int j) {\\n\\n\\t\\tvisMat[i][j] = true;\\n\\t\\tfor (auto d : dirs) {\\n\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\tif (isValid(ni, nj, grid) && !visMat[ni][nj] && grid[ni][nj] == 1) {dfs(grid, ni, nj);}\\n\\t\\t}\\n\\t}\\n\\n\\n\\tint time = 0;\\n\\tvoid dfsArticulation(vector<set<int>> &graph, int u) {\\n\\n\\t\\t// cout << \"At \" << u << \" \";\\n\\n\\t\\tlow[u] = disc[u] = ++time;\\n\\t\\tvis[u] = true;\\n\\t\\tint dfsCount = 0;\\n\\n\\t\\tfor (int v : graph[u]) {\\n\\n\\t\\t\\tif (v == parent[u]) continue;\\n\\n\\t\\t\\telse if (vis[v]) low[u] = min(low[u], disc[v]);\\n\\n\\t\\t\\telse {\\n\\t\\t\\t\\tdfsCount++;\\n\\t\\t\\t\\tparent[v] = u;\\n\\t\\t\\t\\tdfsArticulation(graph, v);\\n\\t\\t\\t\\tlow[u] = min(low[u], low[v]);\\n\\n\\t\\t\\t\\tif (parent[u] == -1) {\\n\\n\\t\\t\\t\\t\\tif (dfsCount > 1) {\\n\\t\\t\\t\\t\\t\\tif (low[v] >= disc[u]) {\\n\\t\\t\\t\\t\\t\\t\\tap[u] = true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse  {\\n\\t\\t\\t\\t\\tif (low[v] >= disc[u]) ap[u] = true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t}\\n\\n\\n\\tint minDays(vector<vector<int>>& grid) {\\n\\t\\tint rows = grid.size();\\n\\t\\tint cols = grid[0].size();\\n\\t\\tint comps = 0;\\n\\t\\tint onesCount = 0;\\n\\n\\t\\tvisMat.resize(rows, vector<bool> (cols, false));\\n\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\t\\tonesCount += grid[i][j];\\n\\t\\t\\t\\tif (grid[i][j] == 1 && !visMat[i][j]) {\\n\\t\\t\\t\\t\\tdfs(grid, i, j);\\n\\t\\t\\t\\t\\tcomps++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (onesCount == 1) return 1;\\n\\t\\t// cout << \"Comps : \" << comps << \\'\\\\n\\';\\n\\t\\tif (comps > 1) return 0;\\n\\n\\n\\t\\tvector<set<int>> graph(rows * cols + 1);\\n\\t\\tparent.resize(rows * cols + 1);\\n\\t\\tlow.resize(rows * cols + 1);\\n\\t\\tdisc.resize(rows * cols + 1);\\n\\t\\tvis.resize(rows * cols + 1, false);\\n\\t\\tap.resize(rows * cols + 1, false);\\n\\n\\t\\tint src = -1;\\n\\t\\tfor (int i = 0; i < rows; i++) {\\n\\t\\t\\tfor (int j = 0; j < cols; j++) {\\n\\n\\t\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\n\\n\\t\\t\\t\\tif (src == -1) src = cols * i + j;\\n\\n\\t\\t\\t\\tfor (auto d : dirs) {\\n\\n\\t\\t\\t\\t\\tint ni = i + d[0];\\n\\t\\t\\t\\t\\tint nj = j + d[1];\\n\\n\\t\\t\\t\\t\\tif (isValid(ni, nj, grid) && grid[ni][nj] == 1) {\\n\\n\\t\\t\\t\\t\\t\\tgraph[cols * i + j].insert(cols * ni + nj);\\n\\t\\t\\t\\t\\t\\tgraph[cols * ni + nj].insert(cols * i + j);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\tparent[src] = -1;\\n\\t\\tint artiPoints = 0;\\n\\t\\tdfsArticulation(graph, src);\\n\\n\\n\\t\\tfor (int i = 0; i < ap.size(); i++) {\\n\\t\\t\\tif (ap[i]) return 1;\\n\\n\\t\\t}\\n\\n\\t\\treturn 2;\\n\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1630519,
                "title": "simple-solution-either-0-1-or-2-c-with-time-o-m-n-2-space-o-1",
                "content": "class Solution {\\npublic:\\n    \\n    void dfs(int i,int j,int m,int n,vector<vector<int>> &grid,int color){\\n        if(i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0 or grid[i][j] == color){\\n            return;\\n        }\\n        grid[i][j] = color;\\n        dfs(i+1,j,m,n,grid,color);\\n        dfs(i,j-1,m,n,grid,color);\\n        dfs(i-1,j,m,n,grid,color);\\n        dfs(i,j+1,m,n,grid,color);\\n    }\\n    \\n    int countOnes(int m,int n,vector<vector<int>> &grid){\\n        int ones = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1){\\n                    ones++;\\n                }\\n            }\\n        }\\n        return ones;\\n    }\\n    \\n    int countIslands(int m,int n,vector<vector<int>> &grid){\\n        int island = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1){\\n                    dfs(i,j,m,n,grid,2);\\n                    island++;\\n                }\\n            }\\n        }        \\n        return island;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ones = countOnes(m,n,grid);\\n        \\n        int island = countIslands(m,n,grid);\\n\\n        \\n        if(island != 1) return 0; //1st case \\n               \\n        if(m == 1 or n == 1 or ones <= 2){\\n            return ones == 2 ? 2:1; //2nd case\\n        }\\n        \\n        //Last option\\n        int islandColor = 2;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == islandColor){\\n                    grid[i][j] = 0;\\n                    island = 0;\\n                    for(int k=0;k<m;k++){\\n                        for(int l=0;l<n;l++){\\n                            if(grid[k][l] == islandColor){\\n                                dfs(k,l,m,n,grid,islandColor+1);\\n                                island++;\\n                            }\\n                        }\\n                    }\\n                    if(island > 1) return 1; // 3rd case\\n                    grid[i][j] = ++islandColor;\\n                }\\n            }\\n        }\\n        return 2; //4th case\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(int i,int j,int m,int n,vector<vector<int>> &grid,int color){\\n        if(i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 0 or grid[i][j] == color){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1581268,
                "title": "c-bfs",
                "content": "There is code repeition, so to make it more pleasing, you may write a seperate function for BFS\\n```\\n\\tint minDays(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int dy[4] = {0, -1, 0, 1};\\n        int dx[4] = {-1, 0, 1, 0};\\n        \\n        vector<vector<bool>> used;\\n        for (int i = 0; i < n; i++) {\\n            vector<bool> temp;\\n            for (int j = 0; j < m; j++) {\\n                temp.push_back(false);\\n            }\\n            used.push_back(temp);\\n        }\\n        \\n        int cnt = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (!used[i][j] && grid[i][j] == 1) {\\n                    \\n                    queue<pair<int, int>> q;\\n                    q.push(make_pair(i, j));\\n                    used[i][j] = true;\\n                    \\n                    cnt++;\\n                    \\n                    while (!q.empty()) {\\n                        pair<int, int> front = q.front();\\n                        int y = front.first;\\n                        int x = front.second;\\n                        for (int k = 0; k < 4; k++) {\\n                            int tempY = y + dy[k];\\n                            int tempX = x + dx[k];\\n                            if (tempY >= 0 && tempY < n && tempX >= 0 && tempX < m) {\\n                                if (grid[tempY][tempX] == 1 && !used[tempY][tempX]) {\\n                                    q.push(make_pair(tempY, tempX));\\n                                    used[tempY][tempX] = true;\\n                                }\\n                            }\\n                        }\\n                        q.pop();\\n                    }\\n                }\\n            }\\n        }\\n        if (cnt > 1) {\\n            return 0;\\n        }\\n        \\n        for (int _i = 0; _i < n; _i++) {\\n            for (int _j = 0; _j < m; _j++) {\\n                if (grid[_i][_j] == 1) {\\n                    grid[_i][_j] = 0;\\n                    \\n                    bool isBfs = false;\\n                    \\n                    used.clear();\\n                    for (int i = 0; i < n; i++) {\\n                        vector<bool> temp;\\n                        for (int j = 0; j < m; j++) {\\n                            temp.push_back(false);\\n                        }\\n                        used.push_back(temp);\\n                    }\\n                    \\n                    cnt = 0;\\n                    for (int i = 0; i < n; i++) {\\n                        for (int j = 0; j < m; j++) {\\n                            if (!used[i][j] && grid[i][j] == 1) {\\n\\n                                isBfs = true;\\n                                queue<pair<int, int>> q;\\n                                q.push(make_pair(i, j));\\n                                used[i][j] = true;\\n\\n                                cnt++;\\n\\n                                while (!q.empty()) {\\n                                    pair<int, int> front = q.front();\\n                                    int y = front.first;\\n                                    int x = front.second;\\n                                    for (int k = 0; k < 4; k++) {\\n                                        int tempY = y + dy[k];\\n                                        int tempX = x + dx[k];\\n                                        if (tempY >= 0 && tempY < n && tempX >= 0 && tempX < m) {\\n                                            if (grid[tempY][tempX] == 1 && !used[tempY][tempX]) {\\n                                                q.push(make_pair(tempY, tempX));\\n                                                used[tempY][tempX] = true;\\n                                            }\\n                                        }\\n                                    }\\n                                    q.pop();\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                    if (cnt > 1) {\\n                        return 1;\\n                    }\\n                    \\n                    if (!isBfs) {\\n                        return 1;\\n                    }\\n                    \\n                    grid[_i][_j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint minDays(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int dy[4] = {0, -1, 0, 1};\\n        int dx[4] = {-1, 0, 1, 0};\\n        \\n        vector<vector<bool>> used;\\n        for (int i = 0; i < n; i++) {\\n            vector<bool> temp;\\n            for (int j = 0; j < m; j++) {\\n                temp.push_back(false);\\n            }\\n            used.push_back(temp);\\n        }\\n        \\n        int cnt = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (!used[i][j] && grid[i][j] == 1) {\\n                    \\n                    queue<pair<int, int>> q;\\n                    q.push(make_pair(i, j));\\n                    used[i][j] = true;\\n                    \\n                    cnt++;\\n                    \\n                    while (!q.empty()) {\\n                        pair<int, int> front = q.front();\\n                        int y = front.first;\\n                        int x = front.second;\\n                        for (int k = 0; k < 4; k++) {\\n                            int tempY = y + dy[k];\\n                            int tempX = x + dx[k];\\n                            if (tempY >= 0 && tempY < n && tempX >= 0 && tempX < m) {\\n                                if (grid[tempY][tempX] == 1 && !used[tempY][tempX]) {\\n                                    q.push(make_pair(tempY, tempX));\\n                                    used[tempY][tempX] = true;\\n                                }\\n                            }\\n                        }\\n                        q.pop();\\n                    }\\n                }\\n            }\\n        }\\n        if (cnt > 1) {\\n            return 0;\\n        }\\n        \\n        for (int _i = 0; _i < n; _i++) {\\n            for (int _j = 0; _j < m; _j++) {\\n                if (grid[_i][_j] == 1) {\\n                    grid[_i][_j] = 0;\\n                    \\n                    bool isBfs = false;\\n                    \\n                    used.clear();\\n                    for (int i = 0; i < n; i++) {\\n                        vector<bool> temp;\\n                        for (int j = 0; j < m; j++) {\\n                            temp.push_back(false);\\n                        }\\n                        used.push_back(temp);\\n                    }\\n                    \\n                    cnt = 0;\\n                    for (int i = 0; i < n; i++) {\\n                        for (int j = 0; j < m; j++) {\\n                            if (!used[i][j] && grid[i][j] == 1) {\\n\\n                                isBfs = true;\\n                                queue<pair<int, int>> q;\\n                                q.push(make_pair(i, j));\\n                                used[i][j] = true;\\n\\n                                cnt++;\\n\\n                                while (!q.empty()) {\\n                                    pair<int, int> front = q.front();\\n                                    int y = front.first;\\n                                    int x = front.second;\\n                                    for (int k = 0; k < 4; k++) {\\n                                        int tempY = y + dy[k];\\n                                        int tempX = x + dx[k];\\n                                        if (tempY >= 0 && tempY < n && tempX >= 0 && tempX < m) {\\n                                            if (grid[tempY][tempX] == 1 && !used[tempY][tempX]) {\\n                                                q.push(make_pair(tempY, tempX));\\n                                                used[tempY][tempX] = true;\\n                                            }\\n                                        }\\n                                    }\\n                                    q.pop();\\n                                }\\n                            }\\n                        }\\n                    }\\n                    \\n                    if (cnt > 1) {\\n                        return 1;\\n                    }\\n                    \\n                    if (!isBfs) {\\n                        return 1;\\n                    }\\n                    \\n                    grid[_i][_j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1331264,
                "title": "easy-java-dfs",
                "content": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int countOne = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    countOne++;\\n                }\\n            }\\n        }\\n        if(countOne == 1) return 1;\\n       int k = countIsland(grid);\\n        if(k > 1) return 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    int g = countIsland(grid);\\n                    if(g>1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    int countIsland(int grid[][]){\\n        int c=0;\\n         boolean v[][] = new boolean[grid.length][grid[0].length];  \\n          for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j] == 1 && v[i][j] == false){\\n                    ++c;\\n                   count(grid,i,j,v);\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n    void count(int g[][],int i,int j,boolean v[][]){\\n        if(i<0 || j<0 || i>=g.length || j>=g[0].length || g[i][j] == 0 || v[i][j]){\\n            return;\\n        }\\n        v[i][j] = true;\\n        count(g,i+1,j,v);\\n        count(g,i,j+1,v);\\n        count(g,i-1,j,v);\\n        count(g,i,j-1,v);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int countOne = 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    countOne++;\\n                }\\n            }\\n        }\\n        if(countOne == 1) return 1;\\n       int k = countIsland(grid);\\n        if(k > 1) return 0;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    int g = countIsland(grid);\\n                    if(g>1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    int countIsland(int grid[][]){\\n        int c=0;\\n         boolean v[][] = new boolean[grid.length][grid[0].length];  \\n          for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j] == 1 && v[i][j] == false){\\n                    ++c;\\n                   count(grid,i,j,v);\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n    void count(int g[][],int i,int j,boolean v[][]){\\n        if(i<0 || j<0 || i>=g.length || j>=g[0].length || g[i][j] == 0 || v[i][j]){\\n            return;\\n        }\\n        v[i][j] = true;\\n        count(g,i+1,j,v);\\n        count(g,i,j+1,v);\\n        count(g,i-1,j,v);\\n        count(g,i,j-1,v);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297390,
                "title": "java-solution-easy-to-understand-dfs",
                "content": "```\\nclass Solution {\\n    \\n    int[] dir = {1,0,-1,0,1}; // dir to move in grid\\n    \\n    public void dfs(int[][] grid , int r , int c , boolean[][] visited){\\n        if(r<0 || c<0 || r>=grid.length || c>=grid[0].length || grid[r][c]== 0 || visited[r][c]) // condition to not move to grid\\n            return ;\\n        visited[r][c] = true;\\n        \\n        for(int i=0;i<4;i++){\\n            dfs(grid , r+dir[i] , c+dir[i+1] ,visited);\\n        }\\n    }\\n    \\n    public int countIsland(int[][] grid){\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int IslandNum =0;\\n        boolean[][] visited = new boolean[row][col];\\n        for(int i=0;i<row ;i++){\\n            for(int j=0;j<col ;j++){\\n                if(grid[i][j] == 1 && !visited[i][j]){\\n                    dfs(grid , i , j , visited);\\n                    IslandNum++; // counting the number of Island in grid \\n                }\\n            }\\n        }\\n        return IslandNum;\\n    }\\n    \\n    public int minDays(int[][] grid) {\\n        int cntIsland = countIsland(grid);\\n        if(cntIsland ==0 || cntIsland>1)return 0; // no connected or many connected || not singly connected\\n        \\n        \\n        for(int i =0;i<grid.length ;i++){\\n            for(int j=0;j<grid[0].length ;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    cntIsland = countIsland(grid);\\n                    if(cntIsland ==0 || cntIsland>1)return 1; // after making one Land to water , then number of connected component\\n                    grid[i][j] =1;\\n                }\\n            }\\n        }\\n        return 2; // remove the two land  from any corner to make corner element disconnected\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] dir = {1,0,-1,0,1}; // dir to move in grid\\n    \\n    public void dfs(int[][] grid , int r , int c , boolean[][] visited){\\n        if(r<0 || c<0 || r>=grid.length || c>=grid[0].length || grid[r][c]== 0 || visited[r][c]) // condition to not move to grid\\n            return ;\\n        visited[r][c] = true;\\n        \\n        for(int i=0;i<4;i++){\\n            dfs(grid , r+dir[i] , c+dir[i+1] ,visited);\\n        }\\n    }\\n    \\n    public int countIsland(int[][] grid){\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int IslandNum =0;\\n        boolean[][] visited = new boolean[row][col];\\n        for(int i=0;i<row ;i++){\\n            for(int j=0;j<col ;j++){\\n                if(grid[i][j] == 1 && !visited[i][j]){\\n                    dfs(grid , i , j , visited);\\n                    IslandNum++; // counting the number of Island in grid \\n                }\\n            }\\n        }\\n        return IslandNum;\\n    }\\n    \\n    public int minDays(int[][] grid) {\\n        int cntIsland = countIsland(grid);\\n        if(cntIsland ==0 || cntIsland>1)return 0; // no connected or many connected || not singly connected\\n        \\n        \\n        for(int i =0;i<grid.length ;i++){\\n            for(int j=0;j<grid[0].length ;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    cntIsland = countIsland(grid);\\n                    if(cntIsland ==0 || cntIsland>1)return 1; // after making one Land to water , then number of connected component\\n                    grid[i][j] =1;\\n                }\\n            }\\n        }\\n        return 2; // remove the two land  from any corner to make corner element disconnected\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273896,
                "title": "c-solution-with-explaination-in-comments",
                "content": "class Solution {\\npublic:\\n    int X[4]={0,1,0,-1};\\n    int Y[4]={1,0,-1,0};\\n    bool disconnected(vector<vector<int>>& grid,int count)\\n    {\\n        stack<pair<int,int>> st;\\n        set<pair<int,int>> visited;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j] ==1)\\n                {\\n                    st.push({i,j});\\n                    count--;\\n                    j=INT_MAX-1;\\n                    i= INT_MAX-1;\\n                }\\n            }\\n        }\\n        \\n        while(!st.empty())\\n        {\\n            pair<int,int> coordinate = st.top();\\n            st.pop();\\n            visited.insert(coordinate);\\n            \\n            int x_cor = coordinate.first,y_cor=coordinate.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                if(x_cor + X[i]<grid.size() && x_cor+X[i]>=0 && y_cor + Y[i]<grid[0].size() && y_cor+Y[i] >=0)\\n                {\\n                    if(visited.find({x_cor + X[i],y_cor+Y[i]})==visited.end() && grid[x_cor + X[i]][y_cor+Y[i]]==1)\\n                    {\\n                        count--;\\n                        visited.insert({x_cor + X[i],y_cor+Y[i]});\\n                        st.push({x_cor + X[i],y_cor+Y[i]});\\n                    }\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        if(count == 0)\\n            return false;\\n        return true;\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        set<pair<int,int>> s;\\n        int minlen=INT_MAX;\\n        \\n        // Now one observation we can make is that the ans can be at max 2 because for a 1 on corner ans will be 2\\n        // so our ans is 0,1  or 2\\n        // so check in base condition if its disconnected i.e 0\\n        // if not flip every one bit to 0 and check for each combination if disconnected else return 2;\\n        int count=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j] ==1)\\n                    count++;\\n            }\\n        }        \\n        \\n\\n        if(count==0 || disconnected(grid,count))\\n            return 0;\\n        \\n        if(count == 1)\\n            return 1;\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    grid[i][j] = 0;\\n                        if(disconnected(grid,count-1))\\n                        {   \\n                            return 1;\\n                        }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int X[4]={0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1207076,
                "title": "python-tarjan-s-algorithm-to-find-whether-there-are-critical-connections",
                "content": "```\\nfrom collections import defaultdict as ddict\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def neighbor(i, j):\\n            lst = [(i-1, j), (i, j-1), (i, j+1), (i+1, j)]\\n            return [(x, y) for x, y in lst if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1]\\n        \\n        # Tarjan\\'s algorithm to find whether there are critical connections\\n        def dfs(i, j, time):\\n            node[(i, j)] = time\\n            low[(i, j)] = time\\n            visited.add((i, j))\\n            is_crit = False\\n            size = 1\\n            for x, y in neighbor(i, j):\\n                if (x, y) not in visited:\\n                    nei_size, has_crit = dfs(x, y, time + 1)\\n                    size += nei_size\\n                    is_crit = is_crit or has_crit\\n                    low[(i, j)] = min(low[(i, j)], low[(x, y)])\\n                    if low[(x, y)] == time + 1:\\n                        # critical connection found\\n                        is_crit = True\\n                elif node[(x, y)] != time - 1:\\n                    low[(i, j)] = min(low[(i, j)], low[(x, y)])\\n            return size, is_crit\\n        \\n        # handle edge case when there is only one node\\n        grid_sum = sum([grid[i][j] for i in range(len(grid)) for j in range(len(grid[0]))])\\n        if grid_sum <= 1:\\n            return grid_sum\\n        critical = False\\n        visited = set()\\n        node = ddict(int)\\n        low = ddict(int)\\n        comp = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1 and (i, j) not in visited:\\n                    comp += 1\\n                    size, has_crit = dfs(i, j, 1)\\n                    # when there are two nodes connected together, we need to remove two even if there is a critical connection\\n                    if size > 2 and has_crit:\\n                        critical = True\\n        # more than one component, return 0\\n        if comp > 1:\\n            return 0\\n        return 1 if critical else 2\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict as ddict\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def neighbor(i, j):\\n            lst = [(i-1, j), (i, j-1), (i, j+1), (i+1, j)]\\n            return [(x, y) for x, y in lst if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 1]\\n        \\n        # Tarjan\\'s algorithm to find whether there are critical connections\\n        def dfs(i, j, time):\\n            node[(i, j)] = time\\n            low[(i, j)] = time\\n            visited.add((i, j))\\n            is_crit = False\\n            size = 1\\n            for x, y in neighbor(i, j):\\n                if (x, y) not in visited:\\n                    nei_size, has_crit = dfs(x, y, time + 1)\\n                    size += nei_size\\n                    is_crit = is_crit or has_crit\\n                    low[(i, j)] = min(low[(i, j)], low[(x, y)])\\n                    if low[(x, y)] == time + 1:\\n                        # critical connection found\\n                        is_crit = True\\n                elif node[(x, y)] != time - 1:\\n                    low[(i, j)] = min(low[(i, j)], low[(x, y)])\\n            return size, is_crit\\n        \\n        # handle edge case when there is only one node\\n        grid_sum = sum([grid[i][j] for i in range(len(grid)) for j in range(len(grid[0]))])\\n        if grid_sum <= 1:\\n            return grid_sum\\n        critical = False\\n        visited = set()\\n        node = ddict(int)\\n        low = ddict(int)\\n        comp = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1 and (i, j) not in visited:\\n                    comp += 1\\n                    size, has_crit = dfs(i, j, 1)\\n                    # when there are two nodes connected together, we need to remove two even if there is a critical connection\\n                    if size > 2 and has_crit:\\n                        critical = True\\n        # more than one component, return 0\\n        if comp > 1:\\n            return 0\\n        return 1 if critical else 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018960,
                "title": "python3-short-dfs-solution",
                "content": "number of island + brute force\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def count(g):\\n            def dfs(i, j):\\n                if 0 <= i < m and 0 <= j < n and g[i][j]:\\n                    g[i][j] = 0 \\n                    list(map(dfs, (i+1, i-1, i, i), (j, j, j+1, j-1)))\\n            return sum(g[i][j] and not dfs(i, j) for i, j in product(range(m), range(n)))\\n        \\n        m, n = len(grid), len(grid[0])\\n        if count(deepcopy(grid)) != 1: return 0\\n        \\n        for i, j in product(range(m), range(n)):\\n            g = deepcopy(grid)\\n            g[i][j] = 0\\n            if count(g) != 1: return 1\\n        return 2",
                "solutionTags": [],
                "code": "number of island + brute force\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def count(g):\\n            def dfs(i, j):\\n                if 0 <= i < m and 0 <= j < n and g[i][j]:\\n                    g[i][j] = 0 \\n                    list(map(dfs, (i+1, i-1, i, i), (j, j, j+1, j-1)))\\n            return sum(g[i][j] and not dfs(i, j) for i, j in product(range(m), range(n)))\\n        \\n        m, n = len(grid), len(grid[0])\\n        if count(deepcopy(grid)) != 1: return 0\\n        \\n        for i, j in product(range(m), range(n)):\\n            g = deepcopy(grid)\\n            g[i][j] = 0\\n            if count(g) != 1: return 1\\n        return 2",
                "codeTag": "Java"
            },
            {
                "id": 1002076,
                "title": "proof-that-we-never-need-more-than-2-deletions",
                "content": "If we have <=3 vertices, the fact that only 2 deletions is needed is trivial. So now we are left with 4 or more vertices.\\n\\nLook at the elements that are in the lowest row #. From those, consider the element with the lowest column #. Now this has to have at most 2 neighbouring vertices. Why?\\n\\nIf we could go up, the row number would be lower. If we could go left, the column number would be lower. So we have at most two edges from this vertex. Delete the two vertices at the end of the edges to disconnect the rest of the graph from this vertex. (Note: # vertices>=4 so we have at least two vertices left)\\n\\nSo this proves that we never need more than 2. It is obvious that we need two in some cases.",
                "solutionTags": [],
                "code": "If we have <=3 vertices, the fact that only 2 deletions is needed is trivial. So now we are left with 4 or more vertices.\\n\\nLook at the elements that are in the lowest row #. From those, consider the element with the lowest column #. Now this has to have at most 2 neighbouring vertices. Why?\\n\\nIf we could go up, the row number would be lower. If we could go left, the column number would be lower. So we have at most two edges from this vertex. Delete the two vertices at the end of the edges to disconnect the rest of the graph from this vertex. (Note: # vertices>=4 so we have at least two vertices left)\\n\\nSo this proves that we never need more than 2. It is obvious that we need two in some cases.",
                "codeTag": "Unknown"
            },
            {
                "id": 925185,
                "title": "c-8ms-99-o-mn-tarjan",
                "content": "The answer<=2, because corners of the island require 2 cuts at most.\\nUse Tarjan algorithm to find any bridge. If found, return 1, otherwise 2.\\nReturn 2 for cases like [[1, 1]] (i.e. single island with 2 cells) specially.\\n\\n```\\nclass Solution {\\npublic:\\n    const int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    \\n    int dfs(int x, int y, int px, int py) {\\n        int res = INT_MAX;\\n        for (int i = 0; i < 4; ++i) {\\n            int xx = x + dirs[i][0];\\n            int yy = y + dirs[i][1];\\n            if (xx < 0 || xx >= n || yy < 0 || yy >= m || g[xx][yy] != 1)\\n                continue;\\n            if (xx == px && yy == py)\\n                continue;\\n            if (depth[xx][yy] != -1) {\\n                res = min(res, depth[xx][yy]);\\n            } else {\\n                depth[xx][yy] = depth[x][y] + 1;\\n                int ret = dfs(xx, yy, x, y);\\n                if (ret == -1)\\n                    return -1;\\n                res = min(res, ret);\\n            }\\n        }\\n        return (res > depth[x][y]) ? -1 : min(depth[x][y], res);\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        if (n == 1 && m == 1)\\n            return 0;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        int ax, ay;\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (vis[i][j])\\n                    continue;\\n                if (grid[i][j] == 1) {\\n                    if (cnt)\\n                        return 0;\\n                    ax = i, ay = j;\\n                    vector<pair<int, int>> bfs = {{i, j}};\\n                    vis[i][j] = true;\\n                    ++cnt;\\n                    while (!bfs.empty()) {\\n                        int x = bfs.back().first;\\n                        int y = bfs.back().second;\\n                        bfs.pop_back();\\n                        for (int k = 0; k < 4; ++k) {\\n                            int xx = x + dirs[k][0];\\n                            int yy = y + dirs[k][1];\\n                            if (xx < 0 || xx >= n || yy < 0 || yy >= m || vis[xx][yy] || grid[xx][yy] != 1)\\n                                continue;\\n                            vis[xx][yy] = true;\\n                            ++cnt;\\n                            bfs.push_back({xx, yy});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (cnt == 0)\\n            return 0;\\n        if (cnt == 2)\\n            return 2;\\n        g = grid;\\n        depth = vector<vector<int>>(n, vector<int>(m, -1));\\n        depth[ax][ay] = 0;\\n        if (dfs(ax, ay, -1, -1) == -1)\\n            return 1;\\n        return 2;\\n    }\\n    \\n    int n, m;\\n    vector<vector<int>> g;\\n    vector<vector<int>> depth;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    \\n    int dfs(int x, int y, int px, int py) {\\n        int res = INT_MAX;\\n        for (int i = 0; i < 4; ++i) {\\n            int xx = x + dirs[i][0];\\n            int yy = y + dirs[i][1];\\n            if (xx < 0 || xx >= n || yy < 0 || yy >= m || g[xx][yy] != 1)\\n                continue;\\n            if (xx == px && yy == py)\\n                continue;\\n            if (depth[xx][yy] != -1) {\\n                res = min(res, depth[xx][yy]);\\n            } else {\\n                depth[xx][yy] = depth[x][y] + 1;\\n                int ret = dfs(xx, yy, x, y);\\n                if (ret == -1)\\n                    return -1;\\n                res = min(res, ret);\\n            }\\n        }\\n        return (res > depth[x][y]) ? -1 : min(depth[x][y], res);\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        if (n == 1 && m == 1)\\n            return 0;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        int ax, ay;\\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (vis[i][j])\\n                    continue;\\n                if (grid[i][j] == 1) {\\n                    if (cnt)\\n                        return 0;\\n                    ax = i, ay = j;\\n                    vector<pair<int, int>> bfs = {{i, j}};\\n                    vis[i][j] = true;\\n                    ++cnt;\\n                    while (!bfs.empty()) {\\n                        int x = bfs.back().first;\\n                        int y = bfs.back().second;\\n                        bfs.pop_back();\\n                        for (int k = 0; k < 4; ++k) {\\n                            int xx = x + dirs[k][0];\\n                            int yy = y + dirs[k][1];\\n                            if (xx < 0 || xx >= n || yy < 0 || yy >= m || vis[xx][yy] || grid[xx][yy] != 1)\\n                                continue;\\n                            vis[xx][yy] = true;\\n                            ++cnt;\\n                            bfs.push_back({xx, yy});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if (cnt == 0)\\n            return 0;\\n        if (cnt == 2)\\n            return 2;\\n        g = grid;\\n        depth = vector<vector<int>>(n, vector<int>(m, -1));\\n        depth[ax][ay] = 0;\\n        if (dfs(ax, ay, -1, -1) == -1)\\n            return 1;\\n        return 2;\\n    }\\n    \\n    int n, m;\\n    vector<vector<int>> g;\\n    vector<vector<int>> depth;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866762,
                "title": "simple-python",
                "content": "```\\ndef minDays(self, g: List[List[int]]) -> int:\\n    def dfs(i, j, vis):\\n        vis.add((i, j))\\n        for i1, j1 in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:\\n            if (0 <= i1 < m and 0 <= j1 < n) and (i1, j1) not in vis and g[i1][j1]: dfs(i1, j1, vis)                       \\n    if not g: return 0\\n    m, n = len(g), len(g[0])        \\n    cand = [(i,j) for i in range(m) for j in range(n) if g[i][j]]        \\n    if not cand: return 0\\n    vis = set(); dfs(cand[0][0], cand[0][1], vis) \\n    if len(vis) < len(cand): return 0\\n    if len(cand) <= 2: return len(cand)\\n\\n    for k, ij in enumerate(cand):            \\n        i, j = ij\\n        g[i][j] = 0\\n        vis = set()\\n        k = -1 if k == 0 else 0\\n        dfs(cand[k][0], cand[k][1], vis)\\n        if len(vis) < len(cand) - 1: return 1\\n        g[i][j] = 1\\n    return 2",
                "solutionTags": [],
                "code": "```\\ndef minDays(self, g: List[List[int]]) -> int:\\n    def dfs(i, j, vis):\\n        vis.add((i, j))\\n        for i1, j1 in [(i+1, j), (i-1, j), (i, j-1), (i, j+1)]:\\n            if (0 <= i1 < m and 0 <= j1 < n) and (i1, j1) not in vis and g[i1][j1]: dfs(i1, j1, vis)                       \\n    if not g: return 0\\n    m, n = len(g), len(g[0])        \\n    cand = [(i,j) for i in range(m) for j in range(n) if g[i][j]]        \\n    if not cand: return 0\\n    vis = set(); dfs(cand[0][0], cand[0][1], vis) \\n    if len(vis) < len(cand): return 0\\n    if len(cand) <= 2: return len(cand)\\n\\n    for k, ij in enumerate(cand):            \\n        i, j = ij\\n        g[i][j] = 0\\n        vis = set()\\n        k = -1 if k == 0 else 0\\n        dfs(cand[k][0], cand[k][1], vis)\\n        if len(vis) < len(cand) - 1: return 1\\n        g[i][j] = 1\\n    return 2",
                "codeTag": "Python3"
            },
            {
                "id": 859877,
                "title": "how-to-proof-at-most-2-days",
                "content": "One way to proof maybe like this, assuming every node has three or more degree of connection, then such island has infinite area, which is impossible in this problem. But, is this thoughts right, and how to formally proof this?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 848220,
                "title": "java-2-approaches-with-comments-dfs-tarjan",
                "content": "```\\n/*\\n * the matrix can be infinitely big with only ones and still be done in 2 days\\n *  day 0\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\n\\tday 1\\n\\t[1,0,1]\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\n\\tday 2\\n\\t[1,0,1]\\n\\t[0,1,1]\\n\\t[1,1,1]\\n */\\n\\n/**\\n * Approach 1: DFS\\n * \\tIf you look carefully, the result is 0, 1, or 2;\\n\\t1, if num of islands not 1, return 0;\\n\\t2, special cases, only one 1 or two 1s;\\n\\t3, try to remove any 1 that has more than 1 neighbors, if it splits the islands, return 1;\\n\\t4, otherwise return 2;\\n\\n\\n * \\tComplexity of finding noOfIsland is O(mn)\\n\\tSince in worst case we might end up calling noOfIsland function mXn times\\n\\tOverall Complexity is O((mn)^2)\\n */\\npublic int minDays(int[][] grid) {\\n\\n\\tif (numIslands(grid) != 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\tfor (int j = 0; j < grid[0].length; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\t\\tif (numIslands(grid) != 1) { // check if this pt is a cutting bridge\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 2; // \\n}\\n\\npublic int numIslands(int[][] grid) {\\n\\tint count = 0;\\n\\tboolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\n\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\tfor (int j = 0; j < grid[0].length; j++) {\\n\\t\\t\\tif (!visited[i][j] && grid[i][j] == 1) {\\n\\t\\t\\t\\tdfsUtil(visited, grid, i, j);\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn count;\\n}\\n\\nprivate void dfsUtil(boolean[][] visited, int[][] grid, int i, int j) {\\n\\tif (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\tvisited[i][j] = true;\\n\\t\\tlands++;\\n\\t\\tdfsUtil(visited, grid, i + 1, j);\\n\\t\\tdfsUtil(visited, grid, i - 1, j);\\n\\t\\tdfsUtil(visited, grid, i, j + 1);\\n\\t\\tdfsUtil(visited, grid, i, j - 1);\\n\\t}\\n}\\n\\n/**\\n * Approach 2: Tarjan\\'s Algo\\n * \\tIf there is no island or more than 1 island, return 0;\\n\\tIf there is only one land, return 1;\\n\\tIf any single cell could serve as the cut point ( divide 1 island into 2 islands), return 1;\\n\\tOtherwise, return 2 ( I haven\\'t found a formal proof yet).\\n */\\n\\npublic int lands = 0; // if we have only 1 land ie 1 cell with value one then ans is 1\\n\\npublic int minDaysApproach2(int[][] grid) {\\n\\tif (numIslands(grid) != 1)\\n\\t\\treturn 0;\\n\\t// we are here means we have only 1 island\\n\\n\\tif (lands <= 2)\\n\\t\\t// special case when we have 010 land or 0110 like this land in this case island is 1, there is no ap\\n\\t\\treturn lands;\\n\\n\\t// we are here means we have only 1 island, and land is greater then 2 which means ap/bridge is possible\\n\\tHashMap<Integer, List<Integer>> graph = buildGraphFromGrid(grid);\\n\\n\\t//return Bridge.getBridges(graph).size() > 0 ? 1 : 2;\\n\\treturn ArticulationPoints.getAP(graph).size() > 0 ? 1 : 2;\\n}\\n\\npublic HashMap<Integer, List<Integer>> buildGraphFromGrid(int[][] grid) {\\n\\t\\tHashMap<Integer, List<Integer>> adjacencyList = new HashMap<Integer, List<Integer>>();\\n\\t\\tint[][] dirs = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\t\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\t\\tfor (int j = 0; j < grid[0].length; j++)\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t\\tfor (int[] dir : dirs)\\n\\t\\t\\t\\t\\t\\tmark(grid, i, j, i + dir[0], j + dir[1], adjacencyList);\\n\\n\\t\\treturn adjacencyList;\\n\\t}\\n\\n\\tpublic static void mark(int grid[][], int prevX, int prevY, int x, int y,\\n\\t\\t\\tHashMap<Integer, List<Integer>> adjacencyList) {\\n\\t\\tif (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0)\\n\\t\\t\\treturn;\\n\\t\\tint n1 = prevX * grid[0].length + prevY;\\n\\t\\tint n2 = x * grid[0].length + y;\\n\\t\\tadjacencyList.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n\\t\\tadjacencyList.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n\\t}\\n\\n\\n\\n\\n/*************************Utilities*******************************/\\npublic class ArticulationPoints {\\n\\nprivate static int time;\\n\\n// The function to do DFS traversal. It uses recursive function APUtil() \\npublic static List<Integer> getAP(HashMap<Integer, List<Integer>> adjacencyList) {\\n\\n\\t// Initialize parent and visited, and ap(articulation point) arrays\\n\\tList<Integer> ap = new ArrayList();\\n\\tHashMap<Integer, Integer> disc = new HashMap<Integer, Integer>(); // vertex, discovery value\\n\\tHashMap<Integer, Integer> low = new HashMap<Integer, Integer>(); // vertex, low value\\n\\tHashMap<Integer, Integer> parent = new HashMap<Integer, Integer>(); // // child vertex, parent vertex\\n\\n\\tSet<Integer> visited = new HashSet<Integer>();\\n\\n\\t// Call the recursive helper function to find articulation \\n\\t// points in DFS tree\\n\\n\\tfor (Map.Entry<Integer, List<Integer>> entry : adjacencyList.entrySet()) {\\n\\t\\tint v = entry.getKey();\\n\\t\\tif (!disc.containsKey(v))\\n\\t\\t\\tAPUtil(v, visited, disc, low, parent, ap, adjacencyList);\\n\\t}\\n\\treturn ap;\\n}\\n\\n// A recursive function that find articulation points using DFS \\n// u --> The vertex to be visited next \\n// visited[] --> keeps tract of visited vertices \\n// disc[] --> Stores discovery times of visited vertices \\n// parent[] --> Stores parent vertices in DFS tree \\n// ap[] --> Store articulation points \\npublic static void APUtil(int currVertex, Set<Integer> visited, HashMap<Integer, Integer> disc,\\n\\t\\tHashMap<Integer, Integer> low, HashMap<Integer, Integer> parent, List<Integer> ap,\\n\\t\\tHashMap<Integer, List<Integer>> adjacencyList) {\\n\\n\\t// Count of children in DFS Tree \\n\\tint children = 0;\\n\\n\\t// Mark the current node as visited \\n\\tvisited.add(currVertex);\\n\\n\\t// Initialize discovery time and low value\\n\\n\\tdisc.put(currVertex, time);\\n\\tlow.put(currVertex, time);\\n\\t++time;\\n\\n\\tint neighbor;\\n\\n\\tif (adjacencyList.containsKey(currVertex)) {\\n\\t\\t// Go through all vertices adjacent to this  \\n\\t\\tIterator<Integer> itr = adjacencyList.get(currVertex).iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\n\\t\\t\\tneighbor = itr.next();\\n//\\t\\t\\t\\t//if neighbor is same as parent then just ignore this vertex.\\n//\\t            if(parent.containsKey(currVertex) && neighbor == parent.get(currVertex)) {\\n//\\t                continue;\\n//\\t            }\\n\\n\\t\\t\\t// If neighbor is not visited yet, then make it a child of currVertex \\n\\t\\t\\t// in DFS tree and recur for it \\n\\t\\t\\tif (!visited.contains(neighbor)) {\\n\\t\\t\\t\\tchildren++;\\n\\t\\t\\t\\tparent.put(neighbor, currVertex);\\n\\t\\t\\t\\tAPUtil(neighbor, visited, disc, low, parent, ap, adjacencyList);\\n\\n\\t\\t\\t\\t// Check if the subtree rooted with neighbor has a connection to \\n\\t\\t\\t\\t// one of the ancestors of currVertex \\n\\t\\t\\t\\tlow.put(currVertex, Math.min(low.get(currVertex), low.get(neighbor)));\\n\\n\\t\\t\\t\\t// currVertex is an articulation point in following cases \\n\\n\\t\\t\\t\\t// (1) currVertex is root of DFS tree and has two or more chilren. \\n\\t\\t\\t\\t// (2) If currVertex is not root and low value of one of its child is more than discovery value of currVertex.\\n\\t\\t\\t\\tif (parent.get(currVertex) == null && children > 1 || parent.get(currVertex) != null && low.get(neighbor) >= disc.get(currVertex))\\n\\t\\t\\t\\t\\tap.add(currVertex);\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update low value of u for parent function calls. \\n\\t\\t\\telse if (parent.containsKey(currVertex) && neighbor != parent.get(currVertex))\\n\\t\\t\\t\\tlow.put(currVertex, Math.min(low.get(currVertex), disc.get(neighbor)));\\n\\t\\t}\\n\\t}\\n}\\n",
                "solutionTags": [],
                "code": "```\\n/*\\n * the matrix can be infinitely big with only ones and still be done in 2 days\\n *  day 0\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\n\\tday 1\\n\\t[1,0,1]\\n\\t[1,1,1]\\n\\t[1,1,1]\\n\\n\\tday 2\\n\\t[1,0,1]\\n\\t[0,1,1]\\n\\t[1,1,1]\\n */\\n\\n/**\\n * Approach 1: DFS\\n * \\tIf you look carefully, the result is 0, 1, or 2;\\n\\t1, if num of islands not 1, return 0;\\n\\t2, special cases, only one 1 or two 1s;\\n\\t3, try to remove any 1 that has more than 1 neighbors, if it splits the islands, return 1;\\n\\t4, otherwise return 2;\\n\\n\\n * \\tComplexity of finding noOfIsland is O(mn)\\n\\tSince in worst case we might end up calling noOfIsland function mXn times\\n\\tOverall Complexity is O((mn)^2)\\n */\\npublic int minDays(int[][] grid) {\\n\\n\\tif (numIslands(grid) != 1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\tfor (int j = 0; j < grid[0].length; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\t\\tif (numIslands(grid) != 1) { // check if this pt is a cutting bridge\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn 2; // \\n}\\n\\npublic int numIslands(int[][] grid) {\\n\\tint count = 0;\\n\\tboolean[][] visited = new boolean[grid.length][grid[0].length];\\n\\n\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\tfor (int j = 0; j < grid[0].length; j++) {\\n\\t\\t\\tif (!visited[i][j] && grid[i][j] == 1) {\\n\\t\\t\\t\\tdfsUtil(visited, grid, i, j);\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn count;\\n}\\n\\nprivate void dfsUtil(boolean[][] visited, int[][] grid, int i, int j) {\\n\\tif (i >= 0 && j >= 0 && i < grid.length && j < grid[0].length && grid[i][j] == 1 && !visited[i][j]) {\\n\\t\\tvisited[i][j] = true;\\n\\t\\tlands++;\\n\\t\\tdfsUtil(visited, grid, i + 1, j);\\n\\t\\tdfsUtil(visited, grid, i - 1, j);\\n\\t\\tdfsUtil(visited, grid, i, j + 1);\\n\\t\\tdfsUtil(visited, grid, i, j - 1);\\n\\t}\\n}\\n\\n/**\\n * Approach 2: Tarjan\\'s Algo\\n * \\tIf there is no island or more than 1 island, return 0;\\n\\tIf there is only one land, return 1;\\n\\tIf any single cell could serve as the cut point ( divide 1 island into 2 islands), return 1;\\n\\tOtherwise, return 2 ( I haven\\'t found a formal proof yet).\\n */\\n\\npublic int lands = 0; // if we have only 1 land ie 1 cell with value one then ans is 1\\n\\npublic int minDaysApproach2(int[][] grid) {\\n\\tif (numIslands(grid) != 1)\\n\\t\\treturn 0;\\n\\t// we are here means we have only 1 island\\n\\n\\tif (lands <= 2)\\n\\t\\t// special case when we have 010 land or 0110 like this land in this case island is 1, there is no ap\\n\\t\\treturn lands;\\n\\n\\t// we are here means we have only 1 island, and land is greater then 2 which means ap/bridge is possible\\n\\tHashMap<Integer, List<Integer>> graph = buildGraphFromGrid(grid);\\n\\n\\t//return Bridge.getBridges(graph).size() > 0 ? 1 : 2;\\n\\treturn ArticulationPoints.getAP(graph).size() > 0 ? 1 : 2;\\n}\\n\\npublic HashMap<Integer, List<Integer>> buildGraphFromGrid(int[][] grid) {\\n\\t\\tHashMap<Integer, List<Integer>> adjacencyList = new HashMap<Integer, List<Integer>>();\\n\\t\\tint[][] dirs = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\\n\\t\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\t\\tfor (int j = 0; j < grid[0].length; j++)\\n\\t\\t\\t\\tif (grid[i][j] == 1)\\n\\t\\t\\t\\t\\tfor (int[] dir : dirs)\\n\\t\\t\\t\\t\\t\\tmark(grid, i, j, i + dir[0], j + dir[1], adjacencyList);\\n\\n\\t\\treturn adjacencyList;\\n\\t}\\n\\n\\tpublic static void mark(int grid[][], int prevX, int prevY, int x, int y,\\n\\t\\t\\tHashMap<Integer, List<Integer>> adjacencyList) {\\n\\t\\tif (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] == 0)\\n\\t\\t\\treturn;\\n\\t\\tint n1 = prevX * grid[0].length + prevY;\\n\\t\\tint n2 = x * grid[0].length + y;\\n\\t\\tadjacencyList.computeIfAbsent(n1, value -> new ArrayList<>()).add(n2);\\n\\t\\tadjacencyList.computeIfAbsent(n2, value -> new ArrayList<>()).add(n1);\\n\\t}\\n\\n\\n\\n\\n/*************************Utilities*******************************/\\npublic class ArticulationPoints {\\n\\nprivate static int time;\\n\\n// The function to do DFS traversal. It uses recursive function APUtil() \\npublic static List<Integer> getAP(HashMap<Integer, List<Integer>> adjacencyList) {\\n\\n\\t// Initialize parent and visited, and ap(articulation point) arrays\\n\\tList<Integer> ap = new ArrayList();\\n\\tHashMap<Integer, Integer> disc = new HashMap<Integer, Integer>(); // vertex, discovery value\\n\\tHashMap<Integer, Integer> low = new HashMap<Integer, Integer>(); // vertex, low value\\n\\tHashMap<Integer, Integer> parent = new HashMap<Integer, Integer>(); // // child vertex, parent vertex\\n\\n\\tSet<Integer> visited = new HashSet<Integer>();\\n\\n\\t// Call the recursive helper function to find articulation \\n\\t// points in DFS tree\\n\\n\\tfor (Map.Entry<Integer, List<Integer>> entry : adjacencyList.entrySet()) {\\n\\t\\tint v = entry.getKey();\\n\\t\\tif (!disc.containsKey(v))\\n\\t\\t\\tAPUtil(v, visited, disc, low, parent, ap, adjacencyList);\\n\\t}\\n\\treturn ap;\\n}\\n\\n// A recursive function that find articulation points using DFS \\n// u --> The vertex to be visited next \\n// visited[] --> keeps tract of visited vertices \\n// disc[] --> Stores discovery times of visited vertices \\n// parent[] --> Stores parent vertices in DFS tree \\n// ap[] --> Store articulation points \\npublic static void APUtil(int currVertex, Set<Integer> visited, HashMap<Integer, Integer> disc,\\n\\t\\tHashMap<Integer, Integer> low, HashMap<Integer, Integer> parent, List<Integer> ap,\\n\\t\\tHashMap<Integer, List<Integer>> adjacencyList) {\\n\\n\\t// Count of children in DFS Tree \\n\\tint children = 0;\\n\\n\\t// Mark the current node as visited \\n\\tvisited.add(currVertex);\\n\\n\\t// Initialize discovery time and low value\\n\\n\\tdisc.put(currVertex, time);\\n\\tlow.put(currVertex, time);\\n\\t++time;\\n\\n\\tint neighbor;\\n\\n\\tif (adjacencyList.containsKey(currVertex)) {\\n\\t\\t// Go through all vertices adjacent to this  \\n\\t\\tIterator<Integer> itr = adjacencyList.get(currVertex).iterator();\\n\\t\\twhile (itr.hasNext()) {\\n\\n\\t\\t\\tneighbor = itr.next();\\n//\\t\\t\\t\\t//if neighbor is same as parent then just ignore this vertex.\\n//\\t            if(parent.containsKey(currVertex) && neighbor == parent.get(currVertex)) {\\n//\\t                continue;\\n//\\t            }\\n\\n\\t\\t\\t// If neighbor is not visited yet, then make it a child of currVertex \\n\\t\\t\\t// in DFS tree and recur for it \\n\\t\\t\\tif (!visited.contains(neighbor)) {\\n\\t\\t\\t\\tchildren++;\\n\\t\\t\\t\\tparent.put(neighbor, currVertex);\\n\\t\\t\\t\\tAPUtil(neighbor, visited, disc, low, parent, ap, adjacencyList);\\n\\n\\t\\t\\t\\t// Check if the subtree rooted with neighbor has a connection to \\n\\t\\t\\t\\t// one of the ancestors of currVertex \\n\\t\\t\\t\\tlow.put(currVertex, Math.min(low.get(currVertex), low.get(neighbor)));\\n\\n\\t\\t\\t\\t// currVertex is an articulation point in following cases \\n\\n\\t\\t\\t\\t// (1) currVertex is root of DFS tree and has two or more chilren. \\n\\t\\t\\t\\t// (2) If currVertex is not root and low value of one of its child is more than discovery value of currVertex.\\n\\t\\t\\t\\tif (parent.get(currVertex) == null && children > 1 || parent.get(currVertex) != null && low.get(neighbor) >= disc.get(currVertex))\\n\\t\\t\\t\\t\\tap.add(currVertex);\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update low value of u for parent function calls. \\n\\t\\t\\telse if (parent.containsKey(currVertex) && neighbor != parent.get(currVertex))\\n\\t\\t\\t\\tlow.put(currVertex, Math.min(low.get(currVertex), disc.get(neighbor)));\\n\\t\\t}\\n\\t}\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 833776,
                "title": "c-reset-bit-solution-for-1568",
                "content": "The solution first tests how many islands are there.\\n\\n-> If there is a single island, it resets every set bit and tests if resetting the bit disconnects the island. If it disconnects the single island into 2 or more islands OR removes a single bit island so that there are no islands left, we return \"one day\" as answer. \\n\\n-> If none of the bits tested could disconnect the single island, then we deduce that at least 2 bits are needed to do the job. It is provable that 2 bits can disconnect any island in any configuration. So, we return \"2 days\" as answer.\\n\\n-> If in the first test, we find no islands or there are already disconnected islands, we simply return \"0 days\" as answer.\\n\\n```\\n/*tktripathy*/\\nclass Solution {\\npublic:\\n    int dir[4][2] = { {-1, 0}, { 1, 0}, { 0, -1}, { 0, 1} };\\n    /* Accumulate adjacent ones to form an island */\\n    void dfs(vector<vector<int>>& g, int r, int c, vector<vector<bool>>& v, int rsz, int csz) \\n    {\\n        v[r][c] = true;                \\n        for (auto d : dir) {\\n            int x = r + d[0], y = c + d[1];\\n            if ((x >= 0 && x < rsz) && (y >= 0 && y < csz) && (g[x][y] && !v[x][y]) )         \\n                dfs(g, x, y, v, rsz, csz);\\n        }\\n    }\\n    /* Count islands */\\n    int ci(vector<vector<int>>& g, int rsz, int csz) {\\n        int ic = 0; vector<vector<bool>> v(rsz, vector<bool>(csz, 0)); \\n        for (int i = 0; i < rsz; i++) {\\n            for (int j = 0; j < csz; j++) {\\n                if (g[i][j] && !v[i][j]) { dfs(g, i, j, v, rsz, csz); ++ic; }\\n            }\\n        }\\n        return ic;\\n    }\\n    int minDays(vector<vector<int>>& g) {\\n        int single = 0, rsz = g.size(), csz = g[0].size();\\n        for (int i = 0; i < rsz; i++) {\\n            for (int j = 0; j < csz; j++) {\\n                if (g[i][j]) {\\n                    if (!single && ci(g, rsz, csz) == 1) single++; /* found a single island */\\n                    if (single) {       /* if so, reset every set bit and test if resetting */\\n                        g[i][j] = 0;    /* ... a bit might disconnect the island */\\n                        int r = ci(g, rsz, csz); if (r >= 2 /* disconnected */ || !r /* no island left */) return 1 /* one day */;\\n                        g[i][j] = 1;\\n                    } else return 0; /* no islands or already disconnected - zero days */\\n                }\\n            }\\n        }\\n        return 2; /* two days */\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*tktripathy*/\\nclass Solution {\\npublic:\\n    int dir[4][2] = { {-1, 0}, { 1, 0}, { 0, -1}, { 0, 1} };\\n    /* Accumulate adjacent ones to form an island */\\n    void dfs(vector<vector<int>>& g, int r, int c, vector<vector<bool>>& v, int rsz, int csz) \\n    {\\n        v[r][c] = true;                \\n        for (auto d : dir) {\\n            int x = r + d[0], y = c + d[1];\\n            if ((x >= 0 && x < rsz) && (y >= 0 && y < csz) && (g[x][y] && !v[x][y]) )         \\n                dfs(g, x, y, v, rsz, csz);\\n        }\\n    }\\n    /* Count islands */\\n    int ci(vector<vector<int>>& g, int rsz, int csz) {\\n        int ic = 0; vector<vector<bool>> v(rsz, vector<bool>(csz, 0)); \\n        for (int i = 0; i < rsz; i++) {\\n            for (int j = 0; j < csz; j++) {\\n                if (g[i][j] && !v[i][j]) { dfs(g, i, j, v, rsz, csz); ++ic; }\\n            }\\n        }\\n        return ic;\\n    }\\n    int minDays(vector<vector<int>>& g) {\\n        int single = 0, rsz = g.size(), csz = g[0].size();\\n        for (int i = 0; i < rsz; i++) {\\n            for (int j = 0; j < csz; j++) {\\n                if (g[i][j]) {\\n                    if (!single && ci(g, rsz, csz) == 1) single++; /* found a single island */\\n                    if (single) {       /* if so, reset every set bit and test if resetting */\\n                        g[i][j] = 0;    /* ... a bit might disconnect the island */\\n                        int r = ci(g, rsz, csz); if (r >= 2 /* disconnected */ || !r /* no island left */) return 1 /* one day */;\\n                        g[i][j] = 1;\\n                    } else return 0; /* no islands or already disconnected - zero days */\\n                }\\n            }\\n        }\\n        return 2; /* two days */\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833465,
                "title": "c-count-the-number-of-islands-time-complexity-o-mn-2-space-complexity-o-mn",
                "content": "```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        int size = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (grid[i][j] == 1) \\n                {\\n                    size++;\\n                }\\n                \\n                if (size > 1)\\n                {\\n                    break;\\n                }\\n            }\\n            \\n            if (size > 1) \\n            {\\n                break;\\n            }\\n        }\\n        \\n        int islandCount = GetNumberOfIslands(grid);\\n        if (islandCount == 0 || islandCount > 1) \\n        {\\n            return 0;\\n        }\\n        \\n        if (size == 1) \\n        {\\n            return 1;\\n        }\\n        \\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    grid[i][j] = 0;\\n                    if (GetNumberOfIslands(grid) > 1)\\n                    {\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int GetNumberOfIslands(int[][] grid)\\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        bool[,] visited= new bool[m,n];\\n        List<int[]> dirs = new List<int[]>() {\\n            new int[2] { 0, 1},\\n            new int[2] { 0, -1},\\n            new int[2] { 1, 0}, \\n            new int[2] { -1, 0}\\n        };\\n        \\n        int count = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (grid[i][j] == 1 && !visited[i,j])\\n                {\\n                    dfs(grid, i, j, visited, dirs);\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, bool[,] visited, List<int[]> dirs)\\n    {\\n        visited[i, j] = true;\\n        foreach (int[] dir in dirs)\\n        {\\n            int nexti = i + dir[0];\\n            int nextj = j + dir[1];\\n            if (IsInBoundary(grid, nexti, nextj) && grid[nexti][nextj] == 1 && !visited[nexti, nextj])\\n            {\\n                dfs(grid, nexti, nextj, visited, dirs);\\n            }\\n        }\\n    }\\n    \\n    private bool IsInBoundary(int[][] grid, int i, int j)\\n    {\\n        return i >= 0 && j >= 0 && i < grid.Length && j < grid[0].Length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinDays(int[][] grid) {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        int size = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (grid[i][j] == 1) \\n                {\\n                    size++;\\n                }\\n                \\n                if (size > 1)\\n                {\\n                    break;\\n                }\\n            }\\n            \\n            if (size > 1) \\n            {\\n                break;\\n            }\\n        }\\n        \\n        int islandCount = GetNumberOfIslands(grid);\\n        if (islandCount == 0 || islandCount > 1) \\n        {\\n            return 0;\\n        }\\n        \\n        if (size == 1) \\n        {\\n            return 1;\\n        }\\n        \\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 1)\\n                {\\n                    grid[i][j] = 0;\\n                    if (GetNumberOfIslands(grid) > 1)\\n                    {\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int GetNumberOfIslands(int[][] grid)\\n    {\\n        int m = grid.Length;\\n        int n = grid[0].Length;\\n        bool[,] visited= new bool[m,n];\\n        List<int[]> dirs = new List<int[]>() {\\n            new int[2] { 0, 1},\\n            new int[2] { 0, -1},\\n            new int[2] { 1, 0}, \\n            new int[2] { -1, 0}\\n        };\\n        \\n        int count = 0;\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (grid[i][j] == 1 && !visited[i,j])\\n                {\\n                    dfs(grid, i, j, visited, dirs);\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private void dfs(int[][] grid, int i, int j, bool[,] visited, List<int[]> dirs)\\n    {\\n        visited[i, j] = true;\\n        foreach (int[] dir in dirs)\\n        {\\n            int nexti = i + dir[0];\\n            int nextj = j + dir[1];\\n            if (IsInBoundary(grid, nexti, nextj) && grid[nexti][nextj] == 1 && !visited[nexti, nextj])\\n            {\\n                dfs(grid, nexti, nextj, visited, dirs);\\n            }\\n        }\\n    }\\n    \\n    private bool IsInBoundary(int[][] grid, int i, int j)\\n    {\\n        return i >= 0 && j >= 0 && i < grid.Length && j < grid[0].Length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826428,
                "title": "rust-translated-0ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_days(g: Vec<Vec<i32>>) -> i32 {\\n        const DIR: [i32; 5] = [0, 1, 0, -1, 0];\\n\\n        fn dfs(\\n            grid: &Vec<Vec<i32>>,\\n            i: i32,\\n            j: i32,\\n            depth: &mut Vec<Vec<i32>>,\\n            low: &mut Vec<Vec<i32>>,\\n            parent: &mut Vec<Vec<i32>>,\\n            time: &mut i32,\\n            is_articulation_point: &mut bool,\\n        ) {\\n            let m = grid.len();\\n            let n = grid[0].len();\\n            depth[i as usize][j as usize] = *time;\\n            *time += 1;\\n            low[i as usize][j as usize] = depth[i as usize][j as usize];\\n            let mut children = 0;\\n            for k in 0..4 {\\n                let ni = i + DIR[k as usize];\\n                let nj = j + DIR[k as usize + 1];\\n                if ni >= 0\\n                    && ni < m as i32\\n                    && nj >= 0\\n                    && nj < n as i32\\n                    && grid[ni as usize][nj as usize] == 1\\n                {\\n                    //valid connection\\n                    if depth[ni as usize][nj as usize] == -1 {\\n                        children += 1;\\n                        parent[ni as usize][nj as usize] = i * n as i32 + j;\\n                        dfs(\\n                            grid,\\n                            ni,\\n                            nj,\\n                            depth,\\n                            low,\\n                            parent,\\n                            time,\\n                            is_articulation_point,\\n                        );\\n                        low[i as usize][j as usize] = std::cmp::min(\\n                            low[i as usize][j as usize],\\n                            low[ni as usize][nj as usize],\\n                        );\\n                        if low[ni as usize][nj as usize] >= depth[i as usize][j as usize]\\n                            && parent[i as usize][j as usize] > -1\\n                        {\\n                            *is_articulation_point = true;\\n                        }\\n                    } else if ni * n as i32 + nj != parent[i as usize][j as usize] {\\n                        //ignore the incoming path\\n                        low[i as usize][j as usize] = std::cmp::min(\\n                            low[i as usize][j as usize],\\n                            depth[ni as usize][nj as usize],\\n                        );\\n                    }\\n                }\\n            }\\n            if parent[i as usize][j as usize] == -1 && children > 1 {\\n                *is_articulation_point = true;\\n            }\\n        }\\n\\n        let m = g.len();\\n        let n = g[0].len();\\n        let mut is_articulation_point = false;\\n        let mut time = 0;\\n\\n        let mut lands = 0;\\n        let mut islands = 0;\\n\\n        let mut depth = vec![vec![-1; n]; m];\\n        let mut low = vec![vec![-1; n]; m];\\n        let mut parent = vec![vec![-1; n]; m];\\n\\n        for i in 0..m {\\n            for j in 0..n {\\n                if g[i][j] == 1 {\\n                    lands += 1;\\n                    if depth[i][j] == -1 {\\n                        dfs(\\n                            &g,\\n                            i as i32,\\n                            j as i32,\\n                            &mut depth,\\n                            &mut low,\\n                            &mut parent,\\n                            &mut time,\\n                            &mut is_articulation_point,\\n                        );\\n                        islands += 1;\\n                    }\\n                }\\n            }\\n        }\\n        if islands == 0 || islands >= 2 {\\n            return 0;\\n        }\\n        if lands == 1 {\\n            return 1;\\n        }\\n        if is_articulation_point {\\n            return 1;\\n        }\\n        return 2;\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_days() {\\n        assert_eq!(\\n            Solution::min_days(vec![vec![0, 1, 1, 0], vec![0, 1, 1, 0], vec![0, 0, 0, 0]]),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_days_02() {\\n        assert_eq!(Solution::min_days(vec![vec![1, 1]]), 2)\\n    }\\n\\n    #[test]\\n    fn test_min_days_03() {\\n        assert_eq!(Solution::min_days(vec![vec![1, 0, 1, 0]]), 0)\\n    }\\n\\n    #[test]\\n    fn test_min_days_04() {\\n        assert_eq!(\\n            Solution::min_days(vec![\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1],\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 0, 1, 1]\\n            ]),\\n            1\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_days_05() {\\n        assert_eq!(\\n            Solution::min_days(vec![\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1],\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1]\\n            ]),\\n            2\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_days(g: Vec<Vec<i32>>) -> i32 {\\n        const DIR: [i32; 5] = [0, 1, 0, -1, 0];\\n\\n        fn dfs(\\n            grid: &Vec<Vec<i32>>,\\n            i: i32,\\n            j: i32,\\n            depth: &mut Vec<Vec<i32>>,\\n            low: &mut Vec<Vec<i32>>,\\n            parent: &mut Vec<Vec<i32>>,\\n            time: &mut i32,\\n            is_articulation_point: &mut bool,\\n        ) {\\n            let m = grid.len();\\n            let n = grid[0].len();\\n            depth[i as usize][j as usize] = *time;\\n            *time += 1;\\n            low[i as usize][j as usize] = depth[i as usize][j as usize];\\n            let mut children = 0;\\n            for k in 0..4 {\\n                let ni = i + DIR[k as usize];\\n                let nj = j + DIR[k as usize + 1];\\n                if ni >= 0\\n                    && ni < m as i32\\n                    && nj >= 0\\n                    && nj < n as i32\\n                    && grid[ni as usize][nj as usize] == 1\\n                {\\n                    //valid connection\\n                    if depth[ni as usize][nj as usize] == -1 {\\n                        children += 1;\\n                        parent[ni as usize][nj as usize] = i * n as i32 + j;\\n                        dfs(\\n                            grid,\\n                            ni,\\n                            nj,\\n                            depth,\\n                            low,\\n                            parent,\\n                            time,\\n                            is_articulation_point,\\n                        );\\n                        low[i as usize][j as usize] = std::cmp::min(\\n                            low[i as usize][j as usize],\\n                            low[ni as usize][nj as usize],\\n                        );\\n                        if low[ni as usize][nj as usize] >= depth[i as usize][j as usize]\\n                            && parent[i as usize][j as usize] > -1\\n                        {\\n                            *is_articulation_point = true;\\n                        }\\n                    } else if ni * n as i32 + nj != parent[i as usize][j as usize] {\\n                        //ignore the incoming path\\n                        low[i as usize][j as usize] = std::cmp::min(\\n                            low[i as usize][j as usize],\\n                            depth[ni as usize][nj as usize],\\n                        );\\n                    }\\n                }\\n            }\\n            if parent[i as usize][j as usize] == -1 && children > 1 {\\n                *is_articulation_point = true;\\n            }\\n        }\\n\\n        let m = g.len();\\n        let n = g[0].len();\\n        let mut is_articulation_point = false;\\n        let mut time = 0;\\n\\n        let mut lands = 0;\\n        let mut islands = 0;\\n\\n        let mut depth = vec![vec![-1; n]; m];\\n        let mut low = vec![vec![-1; n]; m];\\n        let mut parent = vec![vec![-1; n]; m];\\n\\n        for i in 0..m {\\n            for j in 0..n {\\n                if g[i][j] == 1 {\\n                    lands += 1;\\n                    if depth[i][j] == -1 {\\n                        dfs(\\n                            &g,\\n                            i as i32,\\n                            j as i32,\\n                            &mut depth,\\n                            &mut low,\\n                            &mut parent,\\n                            &mut time,\\n                            &mut is_articulation_point,\\n                        );\\n                        islands += 1;\\n                    }\\n                }\\n            }\\n        }\\n        if islands == 0 || islands >= 2 {\\n            return 0;\\n        }\\n        if lands == 1 {\\n            return 1;\\n        }\\n        if is_articulation_point {\\n            return 1;\\n        }\\n        return 2;\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_days() {\\n        assert_eq!(\\n            Solution::min_days(vec![vec![0, 1, 1, 0], vec![0, 1, 1, 0], vec![0, 0, 0, 0]]),\\n            2\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_days_02() {\\n        assert_eq!(Solution::min_days(vec![vec![1, 1]]), 2)\\n    }\\n\\n    #[test]\\n    fn test_min_days_03() {\\n        assert_eq!(Solution::min_days(vec![vec![1, 0, 1, 0]]), 0)\\n    }\\n\\n    #[test]\\n    fn test_min_days_04() {\\n        assert_eq!(\\n            Solution::min_days(vec![\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1],\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 0, 1, 1]\\n            ]),\\n            1\\n        )\\n    }\\n\\n    #[test]\\n    fn test_min_days_05() {\\n        assert_eq!(\\n            Solution::min_days(vec![\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1],\\n                vec![1, 1, 0, 1, 1],\\n                vec![1, 1, 1, 1, 1]\\n            ]),\\n            2\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 826021,
                "title": "c-easy-to-understand-dfs-solution",
                "content": "Answer can never be greater than 2 because it takes only two diagonal blocks to detach corner block from rest of the island. Just make each block with value one to zero and search in rest of the matrix, when for a particular block you can get island disconnected it is 1 else 2.\\nAlso for peaople using C++, here time constraints are tight, so instead of visited set use a 2D vector, send calls only when size and value checks are satisified, else it will give TLE.\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int rows, int cols, int i, int j, vector<vector<int>>& visited){\\n        visited[i][j] = 1;\\n        if(i<rows-1 && visited[i+1][j]==0 && grid[i+1][j]==1 )dfs(grid, rows, cols, i+1, j, visited);\\n        if(i>0 && visited[i-1][j]==0 && grid[i-1][j]==1 )dfs(grid, rows, cols, i-1, j, visited);\\n        if(j<cols-1 && visited[i][j+1]==0 && grid[i][j+1]==1 )dfs(grid, rows, cols, i, j+1, visited);\\n        if(j>0 && visited[i][j-1]==0 && grid[i][j-1]==1 )dfs(grid, rows, cols, i, j-1, visited);\\n        return;\\n    }\\n    \\n    int countIslands(vector<vector<int>>& grid, int rows, int cols){\\n        vector<vector<int>> visited(rows, vector<int>(cols,0));\\n        int count = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j]==1 && visited[i][j]==0){\\n                    dfs(grid, rows, cols, i, j, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        if(countIslands(grid,rows,cols)!=1){\\n            return 0;\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(countIslands(grid,rows,cols)!=1){\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid, int rows, int cols, int i, int j, vector<vector<int>>& visited){\\n        visited[i][j] = 1;\\n        if(i<rows-1 && visited[i+1][j]==0 && grid[i+1][j]==1 )dfs(grid, rows, cols, i+1, j, visited);\\n        if(i>0 && visited[i-1][j]==0 && grid[i-1][j]==1 )dfs(grid, rows, cols, i-1, j, visited);\\n        if(j<cols-1 && visited[i][j+1]==0 && grid[i][j+1]==1 )dfs(grid, rows, cols, i, j+1, visited);\\n        if(j>0 && visited[i][j-1]==0 && grid[i][j-1]==1 )dfs(grid, rows, cols, i, j-1, visited);\\n        return;\\n    }\\n    \\n    int countIslands(vector<vector<int>>& grid, int rows, int cols){\\n        vector<vector<int>> visited(rows, vector<int>(cols,0));\\n        int count = 0;\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j]==1 && visited[i][j]==0){\\n                    dfs(grid, rows, cols, i, j, visited);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        if(countIslands(grid,rows,cols)!=1){\\n            return 0;\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(countIslands(grid,rows,cols)!=1){\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825911,
                "title": "c-time-n-3-space-n",
                "content": "1. C# deep copy for 2D array.\\n2. DFS along with dp.\\n\\'\\'\\'\\'\\npublic class Solution {\\n    int[] ax = new int[4]{1,-1,0,0};\\n    int[] ay = new int[4]{0,0,-1,1};\\n    public int MinDays(int[][] grid) {\\n        int days = 0;\\n        if(CountIslands(grid.Select(a => a.ToArray()).ToArray()) != 1)\\n            return days;\\n      \\n        days = 1;        \\n        for(int i =0; i<grid.Count(); i++)\\n        {\\n            for(int j = 0; j<grid[0].Count(); j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j] = 0;                                 \\n                    if(CountIslands(grid.Select(e=>e.ToArray()).ToArray()) != 1) \\n                        return days;\\n                    grid[i][j] = 1;\\n                }\\n               \\n            }\\n        }        \\n        \\n        return 2;\\n    }\\n    \\n    public int CountIslands(int[][] grid)\\n    {\\n        int ret = 0;\\n        for(int i = 0; i<grid.Count(); i++)\\n        {\\n            for( int j = 0; j<grid[0].Count(); j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    Dfs(grid, i, j);                    \\n                    ret++;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    \\n    public void Dfs(int[][] grid, int i, int j)\\n    {\\n        if(grid[i][j]==0) return;\\n        grid[i][j] = 0;\\n        for(int a = 0; a<4; a++)\\n        {\\n            int nx = i + ax[a];\\n            int ny = j + ay[a];\\n            if(nx>=0 && ny>=0 && nx<grid.Count() && ny<grid[0].Count())\\n                Dfs(grid, nx, ny);\\n        }\\n        return;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] ax = new int[4]{1,-1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 824919,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minDays(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tpath = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t\\tidx = []\\n\\t\\t\\tseen = set()\\n\\t\\t\\tfor i in range(r):\\n\\t\\t\\t\\tfor j in range(c):\\n\\t\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\t\\tidx.append((i, j))\\n\\t\\t\\tif not idx:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif len(idx) == 1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tdef check(stack, seen):\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\ta, b = stack.pop()\\n\\t\\t\\t\\t\\tif (a, b) not in seen:\\n\\t\\t\\t\\t\\t\\tseen.add((a, b))\\n\\t\\t\\t\\t\\t\\tfor i in path:\\n\\t\\t\\t\\t\\t\\t\\tx = a + i[0]\\n\\t\\t\\t\\t\\t\\t\\ty = b + i[1]\\n\\t\\t\\t\\t\\t\\t\\tif 0 <= x < r and 0 <= y < c and grid[x][y] == 1 and (x, y) not in seen:\\n\\t\\t\\t\\t\\t\\t\\t\\tstack.append((x, y))            \\n\\t\\t\\t\\treturn len(seen)\\n\\t\\t\\tif check([idx[0]], seen) < len(idx):\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tfor i in range(len(idx)):\\n\\t\\t\\t\\tgrid[idx[i][0]][idx[i][1]] = 0\\n\\t\\t\\t\\ttmp = idx[:i] + idx[i + 1:]\\n\\t\\t\\t\\tseen = set()\\n\\t\\t\\t\\tif (check([tmp[0]], seen)) < len(tmp):\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tgrid[idx[i][0]][idx[i][1]] = 1\\n\\t\\t\\treturn 2",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minDays(self, grid: List[List[int]]) -> int:\\n\\t\\t\\tr = len(grid)\\n\\t\\t\\tc = len(grid[0])\\n\\t\\t\\tpath = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t\\tidx = []\\n\\t\\t\\tseen = set()\\n\\t\\t\\tfor i in range(r):\\n\\t\\t\\t\\tfor j in range(c):\\n\\t\\t\\t\\t\\tif grid[i][j] == 1:\\n\\t\\t\\t\\t\\t\\tidx.append((i, j))\\n\\t\\t\\tif not idx:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif len(idx) == 1:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\tdef check(stack, seen):\\n\\t\\t\\t\\twhile stack:\\n\\t\\t\\t\\t\\ta, b = stack.pop()\\n\\t\\t\\t\\t\\tif (a, b) not in seen:\\n\\t\\t\\t\\t\\t\\tseen.add((a, b))\\n\\t\\t\\t\\t\\t\\tfor i in path:\\n\\t\\t\\t\\t\\t\\t\\tx = a + i[0]\\n\\t\\t\\t\\t\\t\\t\\ty = b + i[1]\\n\\t\\t\\t\\t\\t\\t\\tif 0 <= x < r and 0 <= y < c and grid[x][y] == 1 and (x, y) not in seen:\\n\\t\\t\\t\\t\\t\\t\\t\\tstack.append((x, y))            \\n\\t\\t\\t\\treturn len(seen)\\n\\t\\t\\tif check([idx[0]], seen) < len(idx):\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tfor i in range(len(idx)):\\n\\t\\t\\t\\tgrid[idx[i][0]][idx[i][1]] = 0\\n\\t\\t\\t\\ttmp = idx[:i] + idx[i + 1:]\\n\\t\\t\\t\\tseen = set()\\n\\t\\t\\t\\tif (check([tmp[0]], seen)) < len(tmp):\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tgrid[idx[i][0]][idx[i][1]] = 1\\n\\t\\t\\treturn 2",
                "codeTag": "Java"
            },
            {
                "id": 824206,
                "title": "java-dfs-25ms-faster-than-90-72",
                "content": "```\\npublic int minDays(int[][] grid) {\\n\\tint r = grid.length;\\n\\tint c = grid[0].length;\\n\\tboolean[][] used = new boolean[r][c];\\n\\tint count = 0, size = 0;\\n\\tfor (int i = 0; i < r; i++) {\\n\\t\\tfor (int j = 0; j < c; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\tsize++; //size the vaule 1\\n\\t\\t\\t//get the max island \\n\\t\\t\\tcount = Math.max(count, dfs(grid, used, i, j));\\n\\t\\t}\\n\\t}\\n\\t// if size of vaule 1 is not equal count  , so it is disconntected reutrn 0.\\n\\tif (size != count) return 0;\\n\\t//if just one vaule 1, return 1\\n\\tif (size == 1) return 1;\\n\\t\\n\\t// check if remove one value 1,  if can made it is disconntected return 1;  otherwise return 2.\\n\\tfor (int i = 0; i < r; i++) {\\n\\t\\tfor (int j = 0; j < c; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tboolean[][] t = new boolean[r][c];\\n\\t\\t\\tif (i > 0 && grid[i - 1][j] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i - 1, j);\\n\\t\\t\\t} else if (i + 1 < grid.length && grid[i + 1][j] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i + 1, j);\\n\\t\\t\\t} else if (j > 0 && grid[i][j - 1] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i, j - 1);\\n\\t\\t\\t} else if (j + 1 < grid[i].length && grid[i][j + 1] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i, j + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif (res + 1 != size) return 1;\\n\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t}\\n\\t}\\n\\treturn 2;\\n}\\n\\nint dfs(int[][] grid, boolean[][] used, int i, int j) {\\n\\tif (used[i][j]) return 0;\\n\\tint res = grid[i][j];\\n\\tused[i][j] = true;\\n\\tif (i > 0 && grid[i - 1][j] == 1) {\\n\\t\\tres += dfs(grid, used, i - 1, j);\\n\\t}\\n\\tif (i + 1 < grid.length && grid[i + 1][j] == 1) {\\n\\t\\tres += dfs(grid, used, i + 1, j);\\n\\t}\\n\\tif (j > 0 && grid[i][j - 1] == 1) {\\n\\t\\tres += dfs(grid, used, i, j - 1);\\n\\t}\\n\\tif (j + 1 < grid[i].length && grid[i][j + 1] == 1) {\\n\\t\\tres += dfs(grid, used, i, j + 1);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic int minDays(int[][] grid) {\\n\\tint r = grid.length;\\n\\tint c = grid[0].length;\\n\\tboolean[][] used = new boolean[r][c];\\n\\tint count = 0, size = 0;\\n\\tfor (int i = 0; i < r; i++) {\\n\\t\\tfor (int j = 0; j < c; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\tsize++; //size the vaule 1\\n\\t\\t\\t//get the max island \\n\\t\\t\\tcount = Math.max(count, dfs(grid, used, i, j));\\n\\t\\t}\\n\\t}\\n\\t// if size of vaule 1 is not equal count  , so it is disconntected reutrn 0.\\n\\tif (size != count) return 0;\\n\\t//if just one vaule 1, return 1\\n\\tif (size == 1) return 1;\\n\\t\\n\\t// check if remove one value 1,  if can made it is disconntected return 1;  otherwise return 2.\\n\\tfor (int i = 0; i < r; i++) {\\n\\t\\tfor (int j = 0; j < c; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) continue;\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tboolean[][] t = new boolean[r][c];\\n\\t\\t\\tif (i > 0 && grid[i - 1][j] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i - 1, j);\\n\\t\\t\\t} else if (i + 1 < grid.length && grid[i + 1][j] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i + 1, j);\\n\\t\\t\\t} else if (j > 0 && grid[i][j - 1] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i, j - 1);\\n\\t\\t\\t} else if (j + 1 < grid[i].length && grid[i][j + 1] == 1) {\\n\\t\\t\\t\\tres = dfs(grid, t, i, j + 1);\\n\\t\\t\\t}\\n\\t\\t\\tif (res + 1 != size) return 1;\\n\\t\\t\\tgrid[i][j] = 1;\\n\\t\\t}\\n\\t}\\n\\treturn 2;\\n}\\n\\nint dfs(int[][] grid, boolean[][] used, int i, int j) {\\n\\tif (used[i][j]) return 0;\\n\\tint res = grid[i][j];\\n\\tused[i][j] = true;\\n\\tif (i > 0 && grid[i - 1][j] == 1) {\\n\\t\\tres += dfs(grid, used, i - 1, j);\\n\\t}\\n\\tif (i + 1 < grid.length && grid[i + 1][j] == 1) {\\n\\t\\tres += dfs(grid, used, i + 1, j);\\n\\t}\\n\\tif (j > 0 && grid[i][j - 1] == 1) {\\n\\t\\tres += dfs(grid, used, i, j - 1);\\n\\t}\\n\\tif (j + 1 < grid[i].length && grid[i][j + 1] == 1) {\\n\\t\\tres += dfs(grid, used, i, j + 1);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 824175,
                "title": "c-dfs-with-explanation",
                "content": "Basically, the answer <= 2;\\nIf there are more than 1 islands or there are no islands.  \\n&nbsp;&nbsp;&nbsp;&nbsp;return 0,\\nelse, \\n&nbsp;&nbsp;&nbsp;&nbsp;try to erase some points then count how many islands are there now.\\n&nbsp;&nbsp;&nbsp;&nbsp;there are only few points we should test,\\n1. a point connecting to two points, and they are on the same line.\\n111 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 1\\n111 (1) 1 1 \\n111 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 1\\n\\n2. a point connecting with several points, and one of them connecting only 1 other point.\\n1 1 &nbsp;1\\n1 1 (1) 1\\n1 1 &nbsp;1\\n\\n3. a point connecting with no other points(an island it self)\\n0 &nbsp;0&nbsp; 0\\n0 (1) 0\\n0&nbsp; 0&nbsp; 0\\n\\n(The 1 surrended in brackets should be test). \\n\\nIf there are 0 or more than 1 islands,\\n&nbsp;&nbsp;&nbsp;&nbsp;return 1\\nelse \\n&nbsp;&nbsp;&nbsp;&nbsp;return 2\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> directions = {{-1,0}, {1, 0}, {0, -1}, {0,1}};\\nvoid dfs(vector<vector<int>>& grid, int row, int col, vector<vector<int>>* points = NULL)\\n{\\n\\tint count = 0;\\n\\tvector<int> dir(4);\\n\\tfor (int i = 0; i < directions.size(); i++)\\n\\t{\\n\\t\\tint r = row + directions[i][0];\\n\\t\\tint c = col + directions[i][1];\\n\\n\\t\\tif (r >= 0 && r < grid.size() && c >= 0 && c < grid[r].size() && grid[r][c])\\n\\t\\t{\\n\\t\\t\\tdir[i] = 1;\\n\\t\\t\\t++count;\\n\\t\\t\\tif (grid[r][c] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgrid[r][c] = 2;\\t\\t\\t\\t\\n\\t\\t\\t\\tdfs(grid, r, c, points);\\n\\t\\t\\t}\\t\\t\\t\\n\\t\\t}\\n\\t}\\n\\n\\tif(points)\\n\\t{\\n\\t\\tif (count == 0 || (count == 2 && ((dir[0] & dir[1]) ^ (dir[2] & dir[3]))))\\n\\t\\t\\tpoints->push_back({row, col});\\n\\t\\telse if(count == 1) \\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < dir.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dir[i]) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpoints->push_back({row + directions[i][0], col + directions[i][1]});\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t}\\n}\\n\\nint islandCount(vector<vector<int>> grid, vector<vector<int>>* points = NULL)\\n{\\n\\tint cnt = 0;\\n\\tfor(int i = 0; i < grid.size(); i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < grid[i].size(); j++)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tdfs(grid, i, j, points);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt;\\n}\\n\\nint minDays(vector<vector<int>>& grid)\\n{\\n\\tvector<vector<int>> points;\\n\\n\\tint cnt = islandCount(grid, &points);\\n\\tif(cnt > 1 || cnt == 0)\\n\\t\\treturn 0;\\n\\n\\tfor(int i = 0; i < points.size(); i++)\\n\\t{\\n\\t\\tgrid[points[i][0]][points[i][1]] = 0;\\n        int cnt = islandCount(grid);\\n\\t\\tif(cnt > 1 || cnt == 0)\\n\\t\\t\\treturn 1;\\n\\t\\tgrid[points[i][0]][points[i][1]] = 1;\\n\\t}\\n\\treturn 2;\\n}\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> directions = {{-1,0}, {1, 0}, {0, -1}, {0,1}};\\nvoid dfs(vector<vector<int>>& grid, int row, int col, vector<vector<int>>* points = NULL)\\n{\\n\\tint count = 0;\\n\\tvector<int> dir(4);\\n\\tfor (int i = 0; i < directions.size(); i++)\\n\\t{\\n\\t\\tint r = row + directions[i][0];\\n\\t\\tint c = col + directions[i][1];\\n\\n\\t\\tif (r >= 0 && r < grid.size() && c >= 0 && c < grid[r].size() && grid[r][c])\\n\\t\\t{\\n\\t\\t\\tdir[i] = 1;\\n\\t\\t\\t++count;\\n\\t\\t\\tif (grid[r][c] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgrid[r][c] = 2;\\t\\t\\t\\t\\n\\t\\t\\t\\tdfs(grid, r, c, points);\\n\\t\\t\\t}\\t\\t\\t\\n\\t\\t}\\n\\t}\\n\\n\\tif(points)\\n\\t{\\n\\t\\tif (count == 0 || (count == 2 && ((dir[0] & dir[1]) ^ (dir[2] & dir[3]))))\\n\\t\\t\\tpoints->push_back({row, col});\\n\\t\\telse if(count == 1) \\n\\t\\t{\\n\\t\\t\\tfor(int i = 0; i < dir.size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dir[i]) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpoints->push_back({row + directions[i][0], col + directions[i][1]});\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n\\t\\t}\\n\\t}\\n}\\n\\nint islandCount(vector<vector<int>> grid, vector<vector<int>>* points = NULL)\\n{\\n\\tint cnt = 0;\\n\\tfor(int i = 0; i < grid.size(); i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < grid[i].size(); j++)\\n\\t\\t{\\n\\t\\t\\tif(grid[i][j] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tdfs(grid, i, j, points);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt;\\n}\\n\\nint minDays(vector<vector<int>>& grid)\\n{\\n\\tvector<vector<int>> points;\\n\\n\\tint cnt = islandCount(grid, &points);\\n\\tif(cnt > 1 || cnt == 0)\\n\\t\\treturn 0;\\n\\n\\tfor(int i = 0; i < points.size(); i++)\\n\\t{\\n\\t\\tgrid[points[i][0]][points[i][1]] = 0;\\n        int cnt = islandCount(grid);\\n\\t\\tif(cnt > 1 || cnt == 0)\\n\\t\\t\\treturn 1;\\n\\t\\tgrid[points[i][0]][points[i][1]] = 1;\\n\\t}\\n\\treturn 2;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822473,
                "title": "c-dfs-1-4-positive",
                "content": "The answer is:\\n1. Zero if there is no islands or more than one island.\\n2. One when there is a single piece of land that connects two or more semi-islands. \\n3. Two otherwise.\\n\\nHow to tell if a land connects semi-islands? If it does not, doing DFS in one direction will explore the entire island. If it does, we need to do DFS in more directions.\\n\\nIn other words, if a land does not connect semi-islands, the result of DFS will be positive for only one direction.\\n\\n```cpp\\nint fill(vector<vector<int>>& g, int i, int j, int col, bool top = false) {\\n    if (i < 0 || j < 0 || i >= g.size() || j >= g[i].size() || g[i][j] != col)\\n        return 0;\\n    g[i][j] = col + 1;\\n    int r = fill(g, i + 1, j, col), l = fill(g, i - 1, j, col);\\n    int d = fill(g, i, j + 1, col), u = fill(g, i, j - 1, col);\\n    if (top)\\n        return max({r, l, d, u}) == r + l + d + u ? 2 : 1;\\n    else \\n        return 1 + r + l + d + u;\\n}\\nint minDays(vector<vector<int>>& g) {\\n    int res = 0;\\n    for (auto i = 0; i < g.size(); ++i)\\n        for (auto j = 0; j < g[i].size(); ++j) {\\n            if (g[i][j]) {\\n                if (g[i][j] == 1 && res != 0)\\n                    return 0;\\n                res = res == 1 ? 1 : fill(g, i, j, g[i][j], true);\\n            }\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint fill(vector<vector<int>>& g, int i, int j, int col, bool top = false) {\\n    if (i < 0 || j < 0 || i >= g.size() || j >= g[i].size() || g[i][j] != col)\\n        return 0;\\n    g[i][j] = col + 1;\\n    int r = fill(g, i + 1, j, col), l = fill(g, i - 1, j, col);\\n    int d = fill(g, i, j + 1, col), u = fill(g, i, j - 1, col);\\n    if (top)\\n        return max({r, l, d, u}) == r + l + d + u ? 2 : 1;\\n    else \\n        return 1 + r + l + d + u;\\n}\\nint minDays(vector<vector<int>>& g) {\\n    int res = 0;\\n    for (auto i = 0; i < g.size(); ++i)\\n        for (auto j = 0; j < g[i].size(); ++j) {\\n            if (g[i][j]) {\\n                if (g[i][j] == 1 && res != 0)\\n                    return 0;\\n                res = res == 1 ? 1 : fill(g, i, j, g[i][j], true);\\n            }\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 822411,
                "title": "python",
                "content": "```\\nimport copy\\n\\n# function that returns how many island in the given grid\\ndef num_island(grid):\\n    neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n    def adjacent(x, y):\\n        return [[x+nx, y+ny] for nx, ny in neighbors if 0 <= x+nx < len(grid) and 0 <= y+ny < len(grid[0])]\\n        \\n    def recur(grid, r, c):\\n        if grid[r][c] == 0:\\n            pass\\n            \\n        grid[r][c] = 0\\n        \\n        neighbor = adjacent(r, c)\\n        \\n        for x, y in neighbor:\\n            if grid[x][y] == 1:\\n                recur(grid, x, y)\\n        return grid\\n        \\n    ret = 0\\n    for i, r in enumerate(grid):\\n        for j, c in enumerate(r):\\n            if c == 1:\\n                ret += 1\\n                grid = recur(grid, i, j)\\n    return ret\\n\\nclass Solution(object):\\n    def minDays(self, grid):\\n        grid_cpy = copy.deepcopy(grid)\\n        target = num_island(grid_cpy)\\n\\n        # island is already diconnected\\n        if target >= 2 or target == 0:\\n            return 0\\n\\n        # one island case\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    grid_cpy = copy.deepcopy(grid)\\n                    grid_cpy[i][j] = 0\\n                    if num_island(grid_cpy) == 2:\\n                        return 1\\n        return 2\\n```\\nsource: https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/discuss/819303/Python-you-need-at-most-2-days",
                "solutionTags": [],
                "code": "```\\nimport copy\\n\\n# function that returns how many island in the given grid\\ndef num_island(grid):\\n    neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]]\\n    def adjacent(x, y):\\n        return [[x+nx, y+ny] for nx, ny in neighbors if 0 <= x+nx < len(grid) and 0 <= y+ny < len(grid[0])]\\n        \\n    def recur(grid, r, c):\\n        if grid[r][c] == 0:\\n            pass\\n            \\n        grid[r][c] = 0\\n        \\n        neighbor = adjacent(r, c)\\n        \\n        for x, y in neighbor:\\n            if grid[x][y] == 1:\\n                recur(grid, x, y)\\n        return grid\\n        \\n    ret = 0\\n    for i, r in enumerate(grid):\\n        for j, c in enumerate(r):\\n            if c == 1:\\n                ret += 1\\n                grid = recur(grid, i, j)\\n    return ret\\n\\nclass Solution(object):\\n    def minDays(self, grid):\\n        grid_cpy = copy.deepcopy(grid)\\n        target = num_island(grid_cpy)\\n\\n        # island is already diconnected\\n        if target >= 2 or target == 0:\\n            return 0\\n\\n        # one island case\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    grid_cpy = copy.deepcopy(grid)\\n                    grid_cpy[i][j] = 0\\n                    if num_island(grid_cpy) == 2:\\n                        return 1\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821826,
                "title": "javascript-tarjan-s-algorithm",
                "content": "General\\n```\\nvar minDays = function(grid) {\\n  \\n    let initIsland = getNumIsland(grid);\\n    \\n    if(initIsland == 0 || initIsland == 2) return 0;\\n    \\n    for(let i = 0; i < grid.length ; i++){\\n        for(let j = 0; j < grid[0].length; j++){\\n            if(grid[i][j] == 1) {\\n                if(getNumIsland(grid,i,j) != 1) return 1;\\n            }\\n        }\\n    }\\n    \\n    return 2;\\n    \\n    function getNumIsland(grid,row=-1,col=-1){\\n        let count = 0;\\n        let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n\\n        if(0 <= row) dp[row][col] = 1;\\n        \\n        for(let i = 0; i < grid.length ; i++){\\n            for(let j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1 && 0 == dp[i][j]){\\n                    count++;\\n                    if(1 < count) return 2;\\n                    journeyIsland(i,j,dp);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    function journeyIsland(row, col, dp){\\n        if(row < 0 || dp.length <= row || col < 0 || dp[0].length <= col) return;\\n        if(!(grid[row][col] == 1 && dp[row][col] == 0)) return;\\n\\n        dp[row][col] = 1;\\n        journeyIsland(row - 1, col, dp);\\n        journeyIsland(row + 1, col, dp);\\n        journeyIsland(row, col - 1, dp);\\n        journeyIsland(row, col + 1, dp); \\n    }\\n};\\n```\\n\\nTarjan\\n```\\nvar minDays = function(grid) {\\n    let cellsCount = 0;\\n    let bridge = new Array();\\n    \\n    let initIsland = getNumIsland(grid);\\n    \\n    if(initIsland == 0 || initIsland == 2) return 0;\\n    if(cellsCount == 2) return 2;\\n        \\n    let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n    \\n    for(let i = 0; i < grid.length ; i++){\\n        for(let j = 0; j < grid[0].length; j++){\\n            if(grid[i][j] == 1) {\\n                tarjan(grid,i,j,dp,1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n\\n    if(0 < bridge.length) return 1;\\n    \\n    return 2;\\n    \\n    function tarjan(grid,row,col,dp,count,dir=-1){\\n        \\n        if(0 < dp[row][col]) return dp[row][col];\\n        \\n        dp[row][col] = count;\\n        \\n        let min = Number.MAX_VALUE;\\n        \\n        if(col + 1 < grid[0].length && grid[row][col+1] == 1 && dir != 1) {\\n            min = Math.min(min, tarjan(grid, row,col + 1,dp,count+1,3));\\n        }\\n        if(row + 1 < grid.length && grid[row+1][col] == 1 && dir != 0) {\\n            min = Math.min(min, tarjan(grid, row+1,col,dp,count+1,2));\\n        }\\n        if(0 <= col - 1 && grid[row][col-1] == 1 && dir != 3) {\\n            min = Math.min(min, tarjan(grid, row,col - 1,dp,count+1,1));\\n        }\\n        if(0 <= row - 1 && grid[row-1][col] == 1 && dir != 2) {\\n            min = Math.min(min, tarjan(grid, row-1,col,dp,count+1,0));\\n        }\\n        if(count < min) bridge.push([row,col]);\\n        else dp[row][col] = min;\\n        \\n        return Math.min(count, min);\\n    }\\n    \\n    function getNumIsland(grid,row=-1,col=-1){\\n        let count = 0;\\n        let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n\\n        if(0 <= row) dp[row][col] = 1;\\n        \\n        for(let i = 0; i < grid.length ; i++){\\n            for(let j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1) cellsCount++;\\n                if(grid[i][j] == 1 && 0 == dp[i][j]){\\n                    count++;\\n                    if(1 < count) return 2;\\n                    journeyIsland(i,j,dp);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    function journeyIsland(row, col, dp){\\n        if(row < 0 || dp.length <= row || col < 0 || dp[0].length <= col) return;\\n        if(!(grid[row][col] == 1 && dp[row][col] == 0)) return;\\n\\n        dp[row][col] = 1;\\n        journeyIsland(row - 1, col, dp);\\n        journeyIsland(row + 1, col, dp);\\n        journeyIsland(row, col - 1, dp);\\n        journeyIsland(row, col + 1, dp); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minDays = function(grid) {\\n  \\n    let initIsland = getNumIsland(grid);\\n    \\n    if(initIsland == 0 || initIsland == 2) return 0;\\n    \\n    for(let i = 0; i < grid.length ; i++){\\n        for(let j = 0; j < grid[0].length; j++){\\n            if(grid[i][j] == 1) {\\n                if(getNumIsland(grid,i,j) != 1) return 1;\\n            }\\n        }\\n    }\\n    \\n    return 2;\\n    \\n    function getNumIsland(grid,row=-1,col=-1){\\n        let count = 0;\\n        let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n\\n        if(0 <= row) dp[row][col] = 1;\\n        \\n        for(let i = 0; i < grid.length ; i++){\\n            for(let j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1 && 0 == dp[i][j]){\\n                    count++;\\n                    if(1 < count) return 2;\\n                    journeyIsland(i,j,dp);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    function journeyIsland(row, col, dp){\\n        if(row < 0 || dp.length <= row || col < 0 || dp[0].length <= col) return;\\n        if(!(grid[row][col] == 1 && dp[row][col] == 0)) return;\\n\\n        dp[row][col] = 1;\\n        journeyIsland(row - 1, col, dp);\\n        journeyIsland(row + 1, col, dp);\\n        journeyIsland(row, col - 1, dp);\\n        journeyIsland(row, col + 1, dp); \\n    }\\n};\\n```\n```\\nvar minDays = function(grid) {\\n    let cellsCount = 0;\\n    let bridge = new Array();\\n    \\n    let initIsland = getNumIsland(grid);\\n    \\n    if(initIsland == 0 || initIsland == 2) return 0;\\n    if(cellsCount == 2) return 2;\\n        \\n    let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n    \\n    for(let i = 0; i < grid.length ; i++){\\n        for(let j = 0; j < grid[0].length; j++){\\n            if(grid[i][j] == 1) {\\n                tarjan(grid,i,j,dp,1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n\\n    if(0 < bridge.length) return 1;\\n    \\n    return 2;\\n    \\n    function tarjan(grid,row,col,dp,count,dir=-1){\\n        \\n        if(0 < dp[row][col]) return dp[row][col];\\n        \\n        dp[row][col] = count;\\n        \\n        let min = Number.MAX_VALUE;\\n        \\n        if(col + 1 < grid[0].length && grid[row][col+1] == 1 && dir != 1) {\\n            min = Math.min(min, tarjan(grid, row,col + 1,dp,count+1,3));\\n        }\\n        if(row + 1 < grid.length && grid[row+1][col] == 1 && dir != 0) {\\n            min = Math.min(min, tarjan(grid, row+1,col,dp,count+1,2));\\n        }\\n        if(0 <= col - 1 && grid[row][col-1] == 1 && dir != 3) {\\n            min = Math.min(min, tarjan(grid, row,col - 1,dp,count+1,1));\\n        }\\n        if(0 <= row - 1 && grid[row-1][col] == 1 && dir != 2) {\\n            min = Math.min(min, tarjan(grid, row-1,col,dp,count+1,0));\\n        }\\n        if(count < min) bridge.push([row,col]);\\n        else dp[row][col] = min;\\n        \\n        return Math.min(count, min);\\n    }\\n    \\n    function getNumIsland(grid,row=-1,col=-1){\\n        let count = 0;\\n        let dp = new Array(grid.length).fill(0).map(()=>new Array(grid[0].length).fill(0));\\n\\n        if(0 <= row) dp[row][col] = 1;\\n        \\n        for(let i = 0; i < grid.length ; i++){\\n            for(let j = 0; j < grid[0].length; j++){\\n                if(grid[i][j] == 1) cellsCount++;\\n                if(grid[i][j] == 1 && 0 == dp[i][j]){\\n                    count++;\\n                    if(1 < count) return 2;\\n                    journeyIsland(i,j,dp);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    function journeyIsland(row, col, dp){\\n        if(row < 0 || dp.length <= row || col < 0 || dp[0].length <= col) return;\\n        if(!(grid[row][col] == 1 && dp[row][col] == 0)) return;\\n\\n        dp[row][col] = 1;\\n        journeyIsland(row - 1, col, dp);\\n        journeyIsland(row + 1, col, dp);\\n        journeyIsland(row, col - 1, dp);\\n        journeyIsland(row, col + 1, dp); \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 821665,
                "title": "c-tarjan",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> idx(m, vector<int>(n, -1));\\n        vector<vector<int>> low(m, vector<int>(n, INT_MAX));\\n        vector<vector<int>> dr({{0,1},{1,0},{0,-1},{-1,0}});\\n        int index = 0;\\n        bool foundCut = false;\\n        function<void(int,int,int,int)> dfs = [&](int i, int j, int fi, int fj) {\\n            idx[i][j] = index++;\\n            low[i][j] = idx[i][j];\\n            int count = 0;\\n            for (const auto &d : dr) {\\n                int ni = i + d[0], nj = j + d[1];\\n                if (ni == fi && nj == fj) continue;\\n                if (ni >= 0 && ni < m && nj >= 0 && nj < n && grid[ni][nj] == 1) {\\n                    if (idx[ni][nj] == -1) {\\n                        dfs(ni, nj, i, j);\\n                        if (low[ni][nj] < low[i][j])\\n                            low[i][j] = low[ni][nj];\\n                        if (fi != -1 && low[ni][nj] >= idx[i][j]) foundCut = true;\\n                        count++;\\n                    } else if (idx[ni][nj] < low[i][j]) \\n                        low[i][j] = idx[ni][nj];\\n                }\\n            }\\n            if (fi == -1 && count >= 2) foundCut = true;\\n        };\\n        bool first = true;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && idx[i][j] == -1) {\\n                    if (!first) return 0;\\n                    dfs(i, j, -1, -1);\\n                    first = false;\\n                }\\n            }\\n        }\\n        return foundCut ? 1 : 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minDays(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> idx(m, vector<int>(n, -1));\\n        vector<vector<int>> low(m, vector<int>(n, INT_MAX));\\n        vector<vector<int>> dr({{0,1},{1,0},{0,-1},{-1,0}});\\n        int index = 0;\\n        bool foundCut = false;\\n        function<void(int,int,int,int)> dfs = [&](int i, int j, int fi, int fj) {\\n            idx[i][j] = index++;\\n            low[i][j] = idx[i][j];\\n            int count = 0;\\n            for (const auto &d : dr) {\\n                int ni = i + d[0], nj = j + d[1];\\n                if (ni == fi && nj == fj) continue;\\n                if (ni >= 0 && ni < m && nj >= 0 && nj < n && grid[ni][nj] == 1) {\\n                    if (idx[ni][nj] == -1) {\\n                        dfs(ni, nj, i, j);\\n                        if (low[ni][nj] < low[i][j])\\n                            low[i][j] = low[ni][nj];\\n                        if (fi != -1 && low[ni][nj] >= idx[i][j]) foundCut = true;\\n                        count++;\\n                    } else if (idx[ni][nj] < low[i][j]) \\n                        low[i][j] = idx[ni][nj];\\n                }\\n            }\\n            if (fi == -1 && count >= 2) foundCut = true;\\n        };\\n        bool first = true;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1 && idx[i][j] == -1) {\\n                    if (!first) return 0;\\n                    dfs(i, j, -1, -1);\\n                    first = false;\\n                }\\n            }\\n        }\\n        return foundCut ? 1 : 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821152,
                "title": "c-clean-code",
                "content": "```\\nclass Solution {\\n    int find(vector<int> &dp, int tar) {\\n        if (dp[tar] == tar) return tar;\\n        else {\\n            dp[tar] = find(dp, dp[tar]);\\n            return dp[tar];\\n        }\\n    }\\n\\n    void merge(vector<int> &dp, int p, int q) {\\n        auto a = find(dp, p);\\n        auto b = find(dp, q);\\n        dp[b] = dp[a];\\n    }\\n\\n\\n    bool solve(const vector<vector<int>> &grid, int n, int m) {\\n        vector<int> dp(n * m, -1);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) dp[i * m + j] = i * m + j;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    if (i - 1 >= 0 && grid[i - 1][j] == 1) merge(dp, i * m + j, i * m - m + j);\\n                    if (i + 1 < n && grid[i + 1][j] == 1) merge(dp, i * m + j, i * m + m + j);\\n                    if (j - 1 >= 0 && grid[i][j - 1] == 1) merge(dp, i * m + j, i * m + j - 1);\\n                    if (j + 1 < m && grid[i][j + 1] == 1) merge(dp, i * m + j, i * m + j + 1);\\n                }\\n            }\\n        }\\n        int num = 0;\\n        for (int i = 0; i < n * m; ++i)\\n            if (dp[i] == i) num++;\\n        return num != 1;\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>> &grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        bool ans = solve(grid, n, m);\\n        if (ans) return 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    ans = solve(grid, n, m);\\n                    if (ans) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int find(vector<int> &dp, int tar) {\\n        if (dp[tar] == tar) return tar;\\n        else {\\n            dp[tar] = find(dp, dp[tar]);\\n            return dp[tar];\\n        }\\n    }\\n\\n    void merge(vector<int> &dp, int p, int q) {\\n        auto a = find(dp, p);\\n        auto b = find(dp, q);\\n        dp[b] = dp[a];\\n    }\\n\\n\\n    bool solve(const vector<vector<int>> &grid, int n, int m) {\\n        vector<int> dp(n * m, -1);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) dp[i * m + j] = i * m + j;\\n            }\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    if (i - 1 >= 0 && grid[i - 1][j] == 1) merge(dp, i * m + j, i * m - m + j);\\n                    if (i + 1 < n && grid[i + 1][j] == 1) merge(dp, i * m + j, i * m + m + j);\\n                    if (j - 1 >= 0 && grid[i][j - 1] == 1) merge(dp, i * m + j, i * m + j - 1);\\n                    if (j + 1 < m && grid[i][j + 1] == 1) merge(dp, i * m + j, i * m + j + 1);\\n                }\\n            }\\n        }\\n        int num = 0;\\n        for (int i = 0; i < n * m; ++i)\\n            if (dp[i] == i) num++;\\n        return num != 1;\\n    }\\n\\npublic:\\n    int minDays(vector<vector<int>> &grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        bool ans = solve(grid, n, m);\\n        if (ans) return 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 1) {\\n                    grid[i][j] = 0;\\n                    ans = solve(grid, n, m);\\n                    if (ans) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821094,
                "title": "java-solution-25ms-simple",
                "content": "```\\nclass Solution {\\n    // deep copy the grid\\n    int[][] copy(int[][] grid){\\n        int[][] copy = new int[grid.length][grid[0].length];\\n        for(int i=0; i<grid.length; i++){\\n            copy[i] = new int[grid[0].length];\\n            System.arraycopy(grid[i], 0, copy[i], 0, grid[0].length);\\n        }\\n        return copy;\\n    }\\n    // make the whole island to 0\\n    void f(int[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0) return;\\n        grid[i][j]=0; \\n        f(grid, i+1, j);\\n        f(grid, i-1, j);\\n        f(grid, i, j+1);\\n        f(grid, i, j-1);\\n    }\\n    // Check if the grid still connect. Make one island to 0 and check if still has 1.\\n    boolean connect(int[][] grid){\\n        boolean flag = false;\\n        for(int i=0; i<grid.length; i++)\\n            for(int j=0; j<grid[0].length; j++)\\n                if(grid[i][j]==1){\\n                    if(flag) return false;\\n                    f(grid, i, j);\\n                    flag=true;\\n                }\\n        return true;\\n    }\\n\\t\\n    public int minDays(int[][] grid) {\\n        int[][] copy = copy(grid);\\n        if(!connect(copy)) return 0; // case 1, already disconnect\\n        for(int i=0; i<grid.length; i++)\\n            for(int j=0; j<grid[0].length; j++)\\n                if(grid[i][j]==1){\\n                    copy = copy(grid);\\n                    copy[i][j]=0;\\n                    if(!connect(copy)) return 1; // case 2, set one cell to 0 then disconnct\\n                }\\n        return 2; // case 3, set 2 cells 0 then disconnect. You can ensure to make an edge cell disconnect by at most 2 \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // deep copy the grid\\n    int[][] copy(int[][] grid){\\n        int[][] copy = new int[grid.length][grid[0].length];\\n        for(int i=0; i<grid.length; i++){\\n            copy[i] = new int[grid[0].length];\\n            System.arraycopy(grid[i], 0, copy[i], 0, grid[0].length);\\n        }\\n        return copy;\\n    }\\n    // make the whole island to 0\\n    void f(int[][] grid, int i, int j){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0) return;\\n        grid[i][j]=0; \\n        f(grid, i+1, j);\\n        f(grid, i-1, j);\\n        f(grid, i, j+1);\\n        f(grid, i, j-1);\\n    }\\n    // Check if the grid still connect. Make one island to 0 and check if still has 1.\\n    boolean connect(int[][] grid){\\n        boolean flag = false;\\n        for(int i=0; i<grid.length; i++)\\n            for(int j=0; j<grid[0].length; j++)\\n                if(grid[i][j]==1){\\n                    if(flag) return false;\\n                    f(grid, i, j);\\n                    flag=true;\\n                }\\n        return true;\\n    }\\n\\t\\n    public int minDays(int[][] grid) {\\n        int[][] copy = copy(grid);\\n        if(!connect(copy)) return 0; // case 1, already disconnect\\n        for(int i=0; i<grid.length; i++)\\n            for(int j=0; j<grid[0].length; j++)\\n                if(grid[i][j]==1){\\n                    copy = copy(grid);\\n                    copy[i][j]=0;\\n                    if(!connect(copy)) return 1; // case 2, set one cell to 0 then disconnct\\n                }\\n        return 2; // case 3, set 2 cells 0 then disconnect. You can ensure to make an edge cell disconnect by at most 2 \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820534,
                "title": "python-remove-one-1-bfs-count-islands-o-n-2",
                "content": "if bfs find 2 or 0 island, return 0\\nremove one 1, if bfs find 2 or 0 island, return 1\\nelse: return 2\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        # if bfs find 2 or 0 island, return 0\\n        # remove one 1, if bfs find 2 or 0 island, return 1\\n        # else: return 2\\n        g = grid\\n        R, C = len(g), len(g[0])\\n        if self.cnt(g) != 1:\\n            return 0\\n        self.reset(g)\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] == 0:\\n                    continue\\n                g[r][c] = 0\\n                if self.cnt(g) != 1:\\n                    return 1\\n                g[r][c] = 1\\n                self.reset(g)\\n        return 2 \\n    \\n    def cnt(self, g):\\n        R, C = len(g), len(g[0])\\n        ans = 0\\n        dirs = (0,1),(1,0),(0,-1),(-1,0)\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] != 1:\\n                    continue\\n                ans += 1\\n                g[r][c] = 2\\n                q, q2 = [(r,c)], []\\n                while q:\\n                    for r1, c1 in q:\\n                        for dr, dc in dirs:\\n                            r2, c2 = r1 + dr, c1 + dc\\n                            if not (0 <= r2 < R and 0 <= c2 < C):\\n                                continue\\n                            if g[r2][c2] != 1:\\n                                continue\\n                            q2.append((r2,c2))\\n                            g[r2][c2] = 2\\n                    q, q2 = q2, []\\n        return ans\\n    \\n    def reset(self, g):\\n        R, C = len(g), len(g[0])\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] > 0:\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        ans = 0\\n        # if bfs find 2 or 0 island, return 0\\n        # remove one 1, if bfs find 2 or 0 island, return 1\\n        # else: return 2\\n        g = grid\\n        R, C = len(g), len(g[0])\\n        if self.cnt(g) != 1:\\n            return 0\\n        self.reset(g)\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] == 0:\\n                    continue\\n                g[r][c] = 0\\n                if self.cnt(g) != 1:\\n                    return 1\\n                g[r][c] = 1\\n                self.reset(g)\\n        return 2 \\n    \\n    def cnt(self, g):\\n        R, C = len(g), len(g[0])\\n        ans = 0\\n        dirs = (0,1),(1,0),(0,-1),(-1,0)\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] != 1:\\n                    continue\\n                ans += 1\\n                g[r][c] = 2\\n                q, q2 = [(r,c)], []\\n                while q:\\n                    for r1, c1 in q:\\n                        for dr, dc in dirs:\\n                            r2, c2 = r1 + dr, c1 + dc\\n                            if not (0 <= r2 < R and 0 <= c2 < C):\\n                                continue\\n                            if g[r2][c2] != 1:\\n                                continue\\n                            q2.append((r2,c2))\\n                            g[r2][c2] = 2\\n                    q, q2 = q2, []\\n        return ans\\n    \\n    def reset(self, g):\\n        R, C = len(g), len(g[0])\\n        for r in range(R):\\n            for c in range(C):\\n                if g[r][c] > 0:\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820385,
                "title": "c-brute-force-dfs-solution",
                "content": "```\\nint minDays(vector<vector<int>>& grid)\\n{\\n\\tif(getIslandCount(grid) != 1)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor(int row = 0; row < grid.size(); ++row)\\n\\t{\\n\\t\\tfor(int col = 0; col < grid[0].size(); ++col)\\n\\t\\t{\\n\\t\\t\\tif(grid[row][col] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgrid[row][col] = 0;\\n\\n\\t\\t\\t\\tif(getIslandCount(grid) != 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgrid[row][col] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn 2;\\n}\\n\\nint getIslandCount(const vector<vector<int>>& grid)\\n{\\n\\tvector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n\\tint count = 0;\\n\\n\\tfor(int row = 0; row < grid.size(); ++row)\\n\\t{\\n\\t\\tfor(int col = 0; col < grid[0].size(); ++col)\\n\\t\\t{\\n\\t\\t\\tif(!visited[row][col] && grid[row][col] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdfs(grid, visited, row, col);\\n\\t\\t\\t\\t++count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n\\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int row, int col)\\n{\\n\\tif(row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != 1 || visited[row][col])\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\n\\tvisited[row][col] = true;\\n\\n\\tdfs(grid, visited, row + 1, col);\\n\\tdfs(grid, visited, row - 1, col);\\n\\tdfs(grid, visited, row, col + 1);\\n\\tdfs(grid, visited, row, col - 1);\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nint minDays(vector<vector<int>>& grid)\\n{\\n\\tif(getIslandCount(grid) != 1)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tfor(int row = 0; row < grid.size(); ++row)\\n\\t{\\n\\t\\tfor(int col = 0; col < grid[0].size(); ++col)\\n\\t\\t{\\n\\t\\t\\tif(grid[row][col] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tgrid[row][col] = 0;\\n\\n\\t\\t\\t\\tif(getIslandCount(grid) != 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgrid[row][col] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn 2;\\n}\\n\\nint getIslandCount(const vector<vector<int>>& grid)\\n{\\n\\tvector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size()));\\n\\tint count = 0;\\n\\n\\tfor(int row = 0; row < grid.size(); ++row)\\n\\t{\\n\\t\\tfor(int col = 0; col < grid[0].size(); ++col)\\n\\t\\t{\\n\\t\\t\\tif(!visited[row][col] && grid[row][col] == 1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdfs(grid, visited, row, col);\\n\\t\\t\\t\\t++count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n\\nvoid dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int row, int col)\\n{\\n\\tif(row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || grid[row][col] != 1 || visited[row][col])\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\n\\tvisited[row][col] = true;\\n\\n\\tdfs(grid, visited, row + 1, col);\\n\\tdfs(grid, visited, row - 1, col);\\n\\tdfs(grid, visited, row, col + 1);\\n\\tdfs(grid, visited, row, col - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820141,
                "title": "python-easy-to-understand-simple-code",
                "content": "**Answer can only be 0,1,2 **\\n\\n0 -> Initially when there are multiple islands and when there is no islands\\n1 and 2 -> when there is only 1 island \\nWe check only for the case when in only one disconnectivety can make it into more than 1 island oterwise it is 2\\nCode is just simple traversal of the grid and lastly count the number of islands present in it, most important is to get the intution behind that that.\\n\\n```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        m=len(grid[0])\\n        \\n        def count(grid):\\n            vis=[[False]*m for i in range(n)]\\n            \\n            def isValid(i,j):\\n                if i<0 or i>=n or j<0 or j>=m or vis[i][j] or not grid[i][j]:\\n                    return False\\n                return True\\n            \\n            def dfs(i,j):\\n                if isValid(i,j):\\n                    vis[i][j]=True\\n                    dfs(i+1,j)\\n                    dfs(i-1,j)\\n                    dfs(i,j+1)\\n                    dfs(i,j-1)\\n\\n            cnt=0\\n            for i in range(n):\\n                for j in range(m):\\n                    if grid[i][j] and not vis[i][j]:\\n                        cnt+=1\\n                        dfs(i,j)\\n\\n            return cnt\\n        \\n        islands=count(grid)\\n        if islands!=1:\\n            return 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]:\\n                    grid[i][j]=0\\n                    islands=count(grid)\\n                    if islands!=1:\\n                        return 1\\n                    grid[i][j]=1\\n        return 2\\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        m=len(grid[0])\\n        \\n        def count(grid):\\n            vis=[[False]*m for i in range(n)]\\n            \\n            def isValid(i,j):\\n                if i<0 or i>=n or j<0 or j>=m or vis[i][j] or not grid[i][j]:\\n                    return False\\n                return True\\n            \\n            def dfs(i,j):\\n                if isValid(i,j):\\n                    vis[i][j]=True\\n                    dfs(i+1,j)\\n                    dfs(i-1,j)\\n                    dfs(i,j+1)\\n                    dfs(i,j-1)\\n\\n            cnt=0\\n            for i in range(n):\\n                for j in range(m):\\n                    if grid[i][j] and not vis[i][j]:\\n                        cnt+=1\\n                        dfs(i,j)\\n\\n            return cnt\\n        \\n        islands=count(grid)\\n        if islands!=1:\\n            return 0\\n        for i in range(n):\\n            for j in range(m):\\n                if grid[i][j]:\\n                    grid[i][j]=0\\n                    islands=count(grid)\\n                    if islands!=1:\\n                        return 1\\n                    grid[i][j]=1\\n        return 2\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 820094,
                "title": "c-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> vis;\\n    vector<int> x = {1, 0, -1, 0};\\n    vector<int> y = {0, -1, 0, 1};\\n    \\n    void dfs(int r, int c, vector<vector<int>>& grid){\\n        vis[r][c] = true;\\n        \\n        for(int i=0;i<4;i++){\\n            if(r+x[i]<0 || r+x[i]>=grid.size() || c+y[i]<0 || c+y[i]>=grid[0].size()) continue;\\n            if(vis[r+x[i]][c+y[i]] || !grid[r+x[i]][c+y[i]]) continue;\\n            dfs(r+x[i], c+y[i], grid);\\n        }\\n        return;\\n    }\\n    \\n    int helper(vector<vector<int>>& grid){\\n        int count = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis.clear();\\n        vis.resize(n, vector<bool>(m, 0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j] || !grid[i][j]) continue;\\n                count++;\\n                dfs(i, j, grid);\\n            }\\n        } \\n        \\n        return count;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        if(helper(grid)!=1) return 0;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!grid[i][j]) continue;\\n                grid[i][j] = 0;\\n                int k = helper(grid);\\n                if(k>1) return 1;\\n                grid[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>> vis;\\n    vector<int> x = {1, 0, -1, 0};\\n    vector<int> y = {0, -1, 0, 1};\\n    \\n    void dfs(int r, int c, vector<vector<int>>& grid){\\n        vis[r][c] = true;\\n        \\n        for(int i=0;i<4;i++){\\n            if(r+x[i]<0 || r+x[i]>=grid.size() || c+y[i]<0 || c+y[i]>=grid[0].size()) continue;\\n            if(vis[r+x[i]][c+y[i]] || !grid[r+x[i]][c+y[i]]) continue;\\n            dfs(r+x[i], c+y[i], grid);\\n        }\\n        return;\\n    }\\n    \\n    int helper(vector<vector<int>>& grid){\\n        int count = 0;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vis.clear();\\n        vis.resize(n, vector<bool>(m, 0));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j] || !grid[i][j]) continue;\\n                count++;\\n                dfs(i, j, grid);\\n            }\\n        } \\n        \\n        return count;\\n    }\\n    \\n    int minDays(vector<vector<int>>& grid) {\\n        \\n        if(helper(grid)!=1) return 0;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!grid[i][j]) continue;\\n                grid[i][j] = 0;\\n                int k = helper(grid);\\n                if(k>1) return 1;\\n                grid[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819825,
                "title": "java-with-explanation-minimum-number-of-days-to-disconnect-island",
                "content": "**intuition:**\\nThere can be maximum 2 days to disconnect the island\\nex:\\n```\\n1 1 1      1 1 1\\n1 1 1  ->  1 1 *\\n1 1 1      1 * 1\\n ```\\n\\n1. so, number of days will always be <= 2\\n2. now, we want to check can we disconnect island in 0 or 1 day\\n   * Island can be disconnected in 0 days\\n\\t\\t* if there is no island or there are more than 1 island. i.e. there is nothing to disconnect if there is no island. \\n\\t\\t* if there are two islands that means they are already disconnected.\\n \\n 3. if there is only one island, as we have seen above, in max two days, we can disconnect it. Now we need to check if we can disconnect the island in just 1 day.\\n 4. To check, if we can disconnect the island in one day, we iterate over the grid and set grid[r][c] = 0, and count the islands,\\n\\t * if island count is > 1, that means we can disconnect island in just one day.\\n\\t * else ans is 2.\\n\\n```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        if (noOfIsland(grid) != 1) { // we already have two or zero islands, i.e. already disconnected\\n            return 0;\\n        }\\n\\n        for (int r = 0; r < nr; r++) {\\n            for (int c = 0; c < nc; c++) {\\n                if (grid[r][c] == 1) {\\n                    grid[r][c] = 0;\\n                    if (noOfIsland(grid) > 1) { // we can disconnect island in one day.\\n                        return 1;\\n                    }\\n                    grid[r][c] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2; // two days are required to disconnect the island\\n    }\\n    \\n    private static int noOfIsland(int[][] grid) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        boolean[][] seen = new boolean[nr][nc];\\n        int islands = 0;\\n        for (int r = 0; r < nr; r++) {\\n            for (int c = 0; c < nc; c++) {\\n                if (grid[r][c] == 1 && !seen[r][c]) {\\n                    islands++;\\n                    dfs(grid, seen, r, c);\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    private static void dfs(int[][] grid, boolean[][] seen, int r, int c) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        if (r < 0 || r >= nr || c < 0 || c >= nc || grid[r][c] == 0 || seen[r][c])\\n            return;\\n\\n        seen[r][c] = true;\\n        dfs(grid, seen, r + 1, c);\\n        dfs(grid, seen, r - 1, c);\\n        dfs(grid, seen, r, c + 1);\\n        dfs(grid, seen, r, c - 1);\\n    }\\n}\\n```\\n\\n**Time Complexity:** \\nr = no. of rows, c = no. of cols\\nO((rc)^2)\\n\\n**Space Complexity**\\nO(rc)",
                "solutionTags": [],
                "code": "```\\n1 1 1      1 1 1\\n1 1 1  ->  1 1 *\\n1 1 1      1 * 1\\n ```\n```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        if (noOfIsland(grid) != 1) { // we already have two or zero islands, i.e. already disconnected\\n            return 0;\\n        }\\n\\n        for (int r = 0; r < nr; r++) {\\n            for (int c = 0; c < nc; c++) {\\n                if (grid[r][c] == 1) {\\n                    grid[r][c] = 0;\\n                    if (noOfIsland(grid) > 1) { // we can disconnect island in one day.\\n                        return 1;\\n                    }\\n                    grid[r][c] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2; // two days are required to disconnect the island\\n    }\\n    \\n    private static int noOfIsland(int[][] grid) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        boolean[][] seen = new boolean[nr][nc];\\n        int islands = 0;\\n        for (int r = 0; r < nr; r++) {\\n            for (int c = 0; c < nc; c++) {\\n                if (grid[r][c] == 1 && !seen[r][c]) {\\n                    islands++;\\n                    dfs(grid, seen, r, c);\\n                }\\n            }\\n        }\\n        return islands;\\n    }\\n\\n    private static void dfs(int[][] grid, boolean[][] seen, int r, int c) {\\n        int nr = grid.length;\\n        int nc = grid[0].length;\\n\\n        if (r < 0 || r >= nr || c < 0 || c >= nc || grid[r][c] == 0 || seen[r][c])\\n            return;\\n\\n        seen[r][c] = true;\\n        dfs(grid, seen, r + 1, c);\\n        dfs(grid, seen, r - 1, c);\\n        dfs(grid, seen, r, c + 1);\\n        dfs(grid, seen, r, c - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819814,
                "title": "java-0-or-1-or-2",
                "content": "```\\nclass Solution {\\n    int m,n;\\n    public int minDays(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int conn = count(grid);\\n        if(conn > 1 || conn == 0) return 0;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(count(grid) > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    public int count(int[][] grid){\\n        boolean[][] vis = new boolean[m][n];\\n        int conn = 0;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(grid[i][j] == 1 && !vis[i][j]){\\n                    dfs(i,j,vis,grid);\\n                    conn++;\\n                }\\n            }\\n        }\\n        return conn;\\n    }\\n    \\n    public void dfs(int r,int c,boolean[][] vis,int[][] grid){\\n        if(r >= m || r < 0 || c >= n || c < 0 || vis[r][c] || grid[r][c] == 0) return;\\n        vis[r][c] = true;\\n        dfs(r + 1,c,vis,grid);\\n        dfs(r - 1,c,vis,grid);\\n        dfs(r,c + 1,vis,grid);\\n        dfs(r,c - 1,vis,grid);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m,n;\\n    public int minDays(int[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        int conn = count(grid);\\n        if(conn > 1 || conn == 0) return 0;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(count(grid) > 1) return 1;\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n    public int count(int[][] grid){\\n        boolean[][] vis = new boolean[m][n];\\n        int conn = 0;\\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                if(grid[i][j] == 1 && !vis[i][j]){\\n                    dfs(i,j,vis,grid);\\n                    conn++;\\n                }\\n            }\\n        }\\n        return conn;\\n    }\\n    \\n    public void dfs(int r,int c,boolean[][] vis,int[][] grid){\\n        if(r >= m || r < 0 || c >= n || c < 0 || vis[r][c] || grid[r][c] == 0) return;\\n        vis[r][c] = true;\\n        dfs(r + 1,c,vis,grid);\\n        dfs(r - 1,c,vis,grid);\\n        dfs(r,c + 1,vis,grid);\\n        dfs(r,c - 1,vis,grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819777,
                "title": "java-bruteforce-solution",
                "content": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        \\n        int m = grid.length, n = grid[0].length;\\n                \\n        int cnt = count(grid, m, n);\\n        if (cnt != 1) {\\n            \\n            return cnt == -1 ? 2 : 0;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if (grid[i][j] == 1) {\\n                    \\n                    grid[i][j] = 0;\\n                    \\n                    if (count(grid, m, n) > 1) {\\n                        \\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int countIsland(int[][] grid, int i, int j, int m, int n, \\n                            boolean[][] visited) {\\n        \\n        if (i < 0 || j < 0 || i >= m || j >= n || visited[i][j] \\n            || grid[i][j] == 0) return 0;\\n        \\n        visited[i][j] = true;\\n        \\n        return countIsland(grid, i, j + 1, m, n, visited) +\\n            countIsland(grid, i + 1, j, m, n, visited) +\\n            countIsland(grid, i - 1, j, m, n, visited) +\\n            countIsland(grid, i, j - 1, m, n, visited);\\n    }\\n    \\n    private int count(int[][] grid, int m, int n) {\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        int count = 0, g = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if (grid[i][j] == 1) {\\n                    ++g;\\n                    if (!visited[i][j]) {\\n                        countIsland(grid, i, j, m, n, visited);\\n                        ++count;\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        if (g == (m * n)) {\\n            \\n            count = -1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minDays(int[][] grid) {\\n        \\n        int m = grid.length, n = grid[0].length;\\n                \\n        int cnt = count(grid, m, n);\\n        if (cnt != 1) {\\n            \\n            return cnt == -1 ? 2 : 0;\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if (grid[i][j] == 1) {\\n                    \\n                    grid[i][j] = 0;\\n                    \\n                    if (count(grid, m, n) > 1) {\\n                        \\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        return 2;\\n    }\\n    \\n    private int countIsland(int[][] grid, int i, int j, int m, int n, \\n                            boolean[][] visited) {\\n        \\n        if (i < 0 || j < 0 || i >= m || j >= n || visited[i][j] \\n            || grid[i][j] == 0) return 0;\\n        \\n        visited[i][j] = true;\\n        \\n        return countIsland(grid, i, j + 1, m, n, visited) +\\n            countIsland(grid, i + 1, j, m, n, visited) +\\n            countIsland(grid, i - 1, j, m, n, visited) +\\n            countIsland(grid, i, j - 1, m, n, visited);\\n    }\\n    \\n    private int count(int[][] grid, int m, int n) {\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        int count = 0, g = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                \\n                if (grid[i][j] == 1) {\\n                    ++g;\\n                    if (!visited[i][j]) {\\n                        countIsland(grid, i, j, m, n, visited);\\n                        ++count;\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        if (g == (m * n)) {\\n            \\n            count = -1;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819654,
                "title": "c-3-steps-solution",
                "content": "1. Check if there is only 1 island (if not, then return 0)\\n2. Check if remove 1 land can leads to disconnected (if yes, return 1)\\n3. return 2\\n```\\nclass Solution \\n{\\n    public:\\n    int lands=0;\\n    int m,n;\\n    void count_islands(vector<vector<int>>& grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        grid[i][j]=0;\\n        lands++;\\n        count_islands(grid,i+1,j);\\n        count_islands(grid,i-1,j);\\n        count_islands(grid,i,j+1);\\n        count_islands(grid,i,j-1);\\n    }\\n    int number_of_islands(vector<vector<int>> grid)\\n    {\\n        int result=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    count_islands(grid,i,j);\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int islands=number_of_islands(grid);\\n        if(islands!=1)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    if(number_of_islands(grid)>1)\\n                    {\\n                        return 1;\\n                    }\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int lands=0;\\n    int m,n;\\n    void count_islands(vector<vector<int>>& grid,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        grid[i][j]=0;\\n        lands++;\\n        count_islands(grid,i+1,j);\\n        count_islands(grid,i-1,j);\\n        count_islands(grid,i,j+1);\\n        count_islands(grid,i,j-1);\\n    }\\n    int number_of_islands(vector<vector<int>> grid)\\n    {\\n        int result=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    count_islands(grid,i,j);\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    int minDays(vector<vector<int>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        int islands=number_of_islands(grid);\\n        if(islands!=1)\\n        {\\n            return 0;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    grid[i][j]=0;\\n                    if(number_of_islands(grid)>1)\\n                    {\\n                        return 1;\\n                    }\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819622,
                "title": "python-1492ms-beat-100",
                "content": "```python\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def bfs():\\n            count = 1\\n            mask = 1 << nodes[0]\\n            pool = [nodes[0]]\\n            while pool:\\n                n = pool.pop()\\n                for nei in adj[n]:\\n                    if mask & (1 << nei) == 0:\\n                        pool.append(nei)\\n                        mask |= 1 << nei\\n                        count += 1\\n            if count < len(nodes):\\n                return True\\n            return False\\n\\n        adj = defaultdict(set)\\n        height = len(grid)\\n        width = len(grid[0])\\n        move = [[-1, 0], [1, 0], [0, 1], [0, -1]]\\n        nodes = []\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j]:\\n                    isolate = True\\n                    node = i * width + j\\n                    nodes.append(node)\\n                    for i1, j1 in move:\\n                        i1 += i\\n                        j1 += j\\n                        if 0 <= i1 < height and 0 <= j1 < width and grid[i1][j1]:\\n                            adj[node].add(i1 * width + j1)\\n                            isolate = False\\n                    if isolate:\\n                        return 0\\n        if len(nodes) <= 2:\\n            return len(nodes)\\n        if bfs():\\n            return 0\\n        for k in list(nodes):\\n            v = adj[k]\\n            for node in v:\\n                adj[node].remove(k)\\n            nodes.remove(k)\\n            if bfs():\\n                return 1\\n            nodes.append(k)\\n            for node in v:\\n                adj[node].add(k)\\n        return 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minDays(self, grid: List[List[int]]) -> int:\\n        def bfs():\\n            count = 1\\n            mask = 1 << nodes[0]\\n            pool = [nodes[0]]\\n            while pool:\\n                n = pool.pop()\\n                for nei in adj[n]:\\n                    if mask & (1 << nei) == 0:\\n                        pool.append(nei)\\n                        mask |= 1 << nei\\n                        count += 1\\n            if count < len(nodes):\\n                return True\\n            return False\\n\\n        adj = defaultdict(set)\\n        height = len(grid)\\n        width = len(grid[0])\\n        move = [[-1, 0], [1, 0], [0, 1], [0, -1]]\\n        nodes = []\\n        for i in range(height):\\n            for j in range(width):\\n                if grid[i][j]:\\n                    isolate = True\\n                    node = i * width + j\\n                    nodes.append(node)\\n                    for i1, j1 in move:\\n                        i1 += i\\n                        j1 += j\\n                        if 0 <= i1 < height and 0 <= j1 < width and grid[i1][j1]:\\n                            adj[node].add(i1 * width + j1)\\n                            isolate = False\\n                    if isolate:\\n                        return 0\\n        if len(nodes) <= 2:\\n            return len(nodes)\\n        if bfs():\\n            return 0\\n        for k in list(nodes):\\n            v = adj[k]\\n            for node in v:\\n                adj[node].remove(k)\\n            nodes.remove(k)\\n            if bfs():\\n                return 1\\n            nodes.append(k)\\n            for node in v:\\n                adj[node].add(k)\\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819607,
                "title": "simple-c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>>vis;\\n    int n,m;\\n    void dfs(int x,int y,vector<vector<int>>&adj){\\n        if(x<0 || x>=n || y<0 || y>=m || vis[x][y] || adj[x][y]==0)return ;\\n        vis[x][y]=true;\\n        dfs(x+1,y,adj);\\n        dfs(x-1,y,adj);\\n        dfs(x,y+1,adj);\\n        dfs(x,y-1,adj);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n=grid.size(),m=grid[0].size();\\n        vis.resize(n,vector<bool>(m,false));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]){\\n                    island++;\\n                    dfs(i,j,grid);\\n                }\\n            }\\n        }\\n        if(island>1 || island==0)return 0;\\n        //either 1 or 2;\\n        //..checking for 1..\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]){\\n                    grid[i][j]=0;\\n                    vis.clear();\\n                    island=0;\\n                    vis.resize(n,vector<bool>(m,false));\\n                    int island=0;\\n                    for(int i=0;i<n;i++){\\n                        for(int j=0;j<m;j++){\\n                            if(!vis[i][j] && grid[i][j]){\\n                                island++;\\n                                dfs(i,j,grid);\\n                            }\\n                        }\\n                    }\\n                    if(island>1)return 1;\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        //one not possible answer is 2\\n        return 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<bool>>vis;\\n    int n,m;\\n    void dfs(int x,int y,vector<vector<int>>&adj){\\n        if(x<0 || x>=n || y<0 || y>=m || vis[x][y] || adj[x][y]==0)return ;\\n        vis[x][y]=true;\\n        dfs(x+1,y,adj);\\n        dfs(x-1,y,adj);\\n        dfs(x,y+1,adj);\\n        dfs(x,y-1,adj);\\n    }\\n    int minDays(vector<vector<int>>& grid) {\\n        n=grid.size(),m=grid[0].size();\\n        vis.resize(n,vector<bool>(m,false));\\n        int island=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j] && grid[i][j]){\\n                    island++;\\n                    dfs(i,j,grid);\\n                }\\n            }\\n        }\\n        if(island>1 || island==0)return 0;\\n        //either 1 or 2;\\n        //..checking for 1..\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]){\\n                    grid[i][j]=0;\\n                    vis.clear();\\n                    island=0;\\n                    vis.resize(n,vector<bool>(m,false));\\n                    int island=0;\\n                    for(int i=0;i<n;i++){\\n                        for(int j=0;j<m;j++){\\n                            if(!vis[i][j] && grid[i][j]){\\n                                island++;\\n                                dfs(i,j,grid);\\n                            }\\n                        }\\n                    }\\n                    if(island>1)return 1;\\n                    grid[i][j]=1;\\n                }\\n            }\\n        }\\n        //one not possible answer is 2\\n        return 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819597,
                "title": "java-code-union-find",
                "content": "```\\nclass UF {\\n    int[] parent;\\n    int[][] grid;\\n    UF(int n, int[][] g) {\\n        parent = new int[n];\\n        grid = g;\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n        }\\n    }\\n    public int find(int v) {\\n        while (v != parent[v]) {\\n            parent[v] = parent[parent[v]];\\n            v = parent[v];\\n        }\\n        return v;\\n    }\\n    public void union(int k, int v) {\\n        parent[find(v)] = find(k);\\n    }\\n    public boolean multiIsland() {\\n        int t = -1;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                if (t == -1) {\\n                    t = find(i*n+j);\\n                } else {\\n                    if (t!=find(i*n+j)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\nclass Solution {\\n    public boolean isOneIsland(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        UF uf = new UF(m*n,grid);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                int cur = n*i+j;\\n                if (i-1>=0 && grid[i-1][j]==1) {\\n                    uf.union(cur, cur-n);\\n                }\\n                if (j-1>=0 && grid[i][j-1]==1) {\\n                    uf.union(cur, cur-1);\\n                }\\n            }\\n        }\\n        return !uf.multiIsland();\\n    }\\n    public int minDays(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (!isOneIsland(grid)) {\\n            return 0;\\n        }\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                grid[i][j] = 0;\\n                if (!isOneIsland(grid)) {\\n                    return 1;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass UF {\\n    int[] parent;\\n    int[][] grid;\\n    UF(int n, int[][] g) {\\n        parent = new int[n];\\n        grid = g;\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n        }\\n    }\\n    public int find(int v) {\\n        while (v != parent[v]) {\\n            parent[v] = parent[parent[v]];\\n            v = parent[v];\\n        }\\n        return v;\\n    }\\n    public void union(int k, int v) {\\n        parent[find(v)] = find(k);\\n    }\\n    public boolean multiIsland() {\\n        int t = -1;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                if (t == -1) {\\n                    t = find(i*n+j);\\n                } else {\\n                    if (t!=find(i*n+j)) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n\\nclass Solution {\\n    public boolean isOneIsland(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        UF uf = new UF(m*n,grid);\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                int cur = n*i+j;\\n                if (i-1>=0 && grid[i-1][j]==1) {\\n                    uf.union(cur, cur-n);\\n                }\\n                if (j-1>=0 && grid[i][j-1]==1) {\\n                    uf.union(cur, cur-1);\\n                }\\n            }\\n        }\\n        return !uf.multiIsland();\\n    }\\n    public int minDays(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        if (!isOneIsland(grid)) {\\n            return 0;\\n        }\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                grid[i][j] = 0;\\n                if (!isOneIsland(grid)) {\\n                    return 1;\\n                }\\n                grid[i][j] = 1;\\n            }\\n        }\\n        return 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819533,
                "title": "python-3-o-m-n-80ms",
                "content": "The approach is different and more optimal compared to most of the other suggested solutions here. Specifically, the part that is different is: how we check if a land cell is critical meaning that we can split the island by removing just this one cell. \\nOther solutions do it by removing the cell and recounting islands on the map, whereas my approach is to look at each cell\\'s neighbors and count how many of them are water cells that are connected to the edge of the greed (referred to as \"open waters\" in the code). \\nThe idea is that if there are >=2 non-adjacent open water openings around the land cell, then we can say that there also are >=2 non-adjacent land neighbors, and since waters are \"open\", the are connected to the edge of the grid, so we can draw a line that goes from edge of the grid through the land cell and back to edge of the grid splitting the island.\\n\\n\\n```\\nclass Solution:\\n    def markLand(self, grid: List[List[int]], row, col, color) -> int:\\n        if grid[row][col] != 1:\\n            return\\n        grid[row][col] = color\\n        for d in [[0,1],[1,0],[0,-1],[-1,0]]:\\n            if 0 <= row + d[0] < len(grid) and 0 <= col + d[1] < len(grid[0]):\\n                self.markLand(grid, row+d[0], col + d[1], color)        \\n                \\n    def markWater(self, grid: List[List[int]], row, col, color, open_waters) -> int:\\n        if grid[row][col] != 0:\\n            return\\n        grid[row][col] = color\\n        # water can be connected diagonally\\n        for d in [[0,1],[1,0],[0,-1],[-1,0], [-1,-1], [-1,1], [1,-1], [1,1]]:\\n            if 0 <= row + d[0] < len(grid) and 0 <= col + d[1] < len(grid[0]):\\n                self.markWater(grid, row+d[0], col + d[1], color, open_waters)\\n            else:\\n                open_waters.add(color)\\n            \\n    \\n    def minDays(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        land_color = 2\\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 1:\\n                    self.markLand(grid, row, col, land_color)\\n                    land_color += 1\\n        if land_color == 2 or land_color > 3:\\n            # return if there are 0 or 2+ islands\\n            return 0\\n        \\n        water_color = -1\\n        # set of colors of waters that are connected to edge of the grid\\n        open_waters = set()\\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 0:\\n                    self.markWater(grid, row, col, water_color, open_waters)\\n                    water_color -= 1\\n        \\n        \\n        def is_open_water(r, c):\\n            # cells out of the grid are considered open_water too            \\n            return not(0 <= r < rows and 0 <= c < cols) or grid[r][c] in open_waters\\n        \\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 2: # land color\\n                    water_seq_count = 0\\n                    water_count = 0\\n                    is_water = False\\n                    # go clockwise and count how many sequences of water we there are\\n                    circle = [[-1, 0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]\\n                    for t in circle:\\n                        r = row + t[0] \\n                        c = col + t[1]\\n                        if is_open_water(r, c):\\n                            water_count += 1\\n                            if not is_water:\\n                                is_water = True\\n                                water_seq_count += 1\\n                        else:\\n                            is_water = False\\n                                \\n                    \\n                    \\n                    # subtract 1 if first and last cells on the circle are both open waters\\n                    if is_water and is_open_water(row-1, col):\\n                        water_seq_count -= 1\\n                    \\n                    # if the land cell is in between of 2 waters, which are connected to edge of the grid, then\\n                    # removing this cell should split the island\\n                    if water_seq_count >= 2:\\n                        return 1\\n                    # if the island consists of a single cell, return 1\\n                    if water_count == 8:\\n                        return 1\\n                    \\n        return 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def markLand(self, grid: List[List[int]], row, col, color) -> int:\\n        if grid[row][col] != 1:\\n            return\\n        grid[row][col] = color\\n        for d in [[0,1],[1,0],[0,-1],[-1,0]]:\\n            if 0 <= row + d[0] < len(grid) and 0 <= col + d[1] < len(grid[0]):\\n                self.markLand(grid, row+d[0], col + d[1], color)        \\n                \\n    def markWater(self, grid: List[List[int]], row, col, color, open_waters) -> int:\\n        if grid[row][col] != 0:\\n            return\\n        grid[row][col] = color\\n        # water can be connected diagonally\\n        for d in [[0,1],[1,0],[0,-1],[-1,0], [-1,-1], [-1,1], [1,-1], [1,1]]:\\n            if 0 <= row + d[0] < len(grid) and 0 <= col + d[1] < len(grid[0]):\\n                self.markWater(grid, row+d[0], col + d[1], color, open_waters)\\n            else:\\n                open_waters.add(color)\\n            \\n    \\n    def minDays(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        land_color = 2\\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 1:\\n                    self.markLand(grid, row, col, land_color)\\n                    land_color += 1\\n        if land_color == 2 or land_color > 3:\\n            # return if there are 0 or 2+ islands\\n            return 0\\n        \\n        water_color = -1\\n        # set of colors of waters that are connected to edge of the grid\\n        open_waters = set()\\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 0:\\n                    self.markWater(grid, row, col, water_color, open_waters)\\n                    water_color -= 1\\n        \\n        \\n        def is_open_water(r, c):\\n            # cells out of the grid are considered open_water too            \\n            return not(0 <= r < rows and 0 <= c < cols) or grid[r][c] in open_waters\\n        \\n        for row in range(rows):\\n            for col in range(cols):\\n                if grid[row][col] == 2: # land color\\n                    water_seq_count = 0\\n                    water_count = 0\\n                    is_water = False\\n                    # go clockwise and count how many sequences of water we there are\\n                    circle = [[-1, 0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]\\n                    for t in circle:\\n                        r = row + t[0] \\n                        c = col + t[1]\\n                        if is_open_water(r, c):\\n                            water_count += 1\\n                            if not is_water:\\n                                is_water = True\\n                                water_seq_count += 1\\n                        else:\\n                            is_water = False\\n                                \\n                    \\n                    \\n                    # subtract 1 if first and last cells on the circle are both open waters\\n                    if is_water and is_open_water(row-1, col):\\n                        water_seq_count -= 1\\n                    \\n                    # if the land cell is in between of 2 waters, which are connected to edge of the grid, then\\n                    # removing this cell should split the island\\n                    if water_seq_count >= 2:\\n                        return 1\\n                    # if the island consists of a single cell, return 1\\n                    if water_count == 8:\\n                        return 1\\n                    \\n        return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819528,
                "title": "java-bfs-number-of-islands-days-at-most-2",
                "content": "Credits to [@GSAN](https://leetcode.com/gsan/). Smart and tricky thought ! \\n\\nWe can disconnect island at most 2 days.\\n\\nImagine a grid full of 1, we can use at most 2 days to disconnect it like the following graph.\\n\\n```\\n1 1 1 1 1         1 . 1 1 1 \\n1 1 1 1 1  -----> . 1 1 1 1\\n1 1 1 1 1         1 1 1 1 1\\n```\\n\\nSo what we need to do is just trying only 1 step to change 1 to 0, and check whether current num of islands is bigger than 1. \\nIf in the first step we don\\'t achieve more than 1 island we just return 2.\\nIf in the first step we achieve more than 1 island we can return 1.\\n\\n```java\\nclass Solution {\\n    int m, n;\\n    int[][] dirs = {{0,1},{0,-1},{-1,0},{1,0}};\\n    public int minDays(int[][] grid) {\\n        if(grid == null || grid.length == 0)return 0;\\n        m = grid.length;\\n        n = grid[0].length;\\n        if(numIslands(grid) != 1)return 0;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1){\\n                    grid[i][j] = 0;\\n                    if(numIslands(grid) != 1){\\n                        return 1;\\n                    }\\n                    grid[i][j] = 1;\\n                }\\n            }\\n        }\\n        return 2;\\n        \\n    }\\n    public int numIslands(int[][] grid) {\\n        if(grid == null || grid.length == 0)return 0;\\n        boolean[][] seen = new boolean[m][n];\\n        int count = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1 && !seen[i][j]){\\n                    queue.add(new int[]{i,j});\\n                    seen[i][j] = true;\\n                    while(!queue.isEmpty()){\\n                        int[] temp = queue.poll();\\n                        for(int[] dir : dirs){\\n                            int x = temp[0] + dir[0];\\n                            int y = temp[1] + dir[1];\\n                            if(x>=0 && x<m && y>=0 && y<n && grid[x][y] == 1 && !seen[x][y]){\\n                                seen[x][y] = true;\\n                                queue.add(new int[]{x,y});\\n                            }\\n                        }\\n                    }\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }             \\n}\\n\\n",
                "solutionTags": [],
                "code": "```\\n1 1 1 1 1         1 . 1 1 1 \\n1 1 1 1 1  -----> . 1 1 1 1\\n1 1 1 1 1         1 1 1 1 1\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570146,
                "content": [
                    {
                        "username": "hemant_dhanuka",
                        "content": "** An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s.**\\nwhat does this line mean and \\n\\nand please some one explain first test case \\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\nOutput: 2\\nExplanation: We need at least 2 days to get a disconnected grid.\\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island."
                    },
                    {
                        "username": "crosslives",
                        "content": "It looks like that we need to find a minimal set of vertex and make graph unconnected."
                    },
                    {
                        "username": "jacksci",
                        "content": "First, notice the answer can only be 0,1, or 2\\nThen, to check if 1 is the answer you just need to check if it\\'s disconnected after removing one site.\\nAnd the one site being removed must be a site with exactly 2 opposite neighbors(left&right or up&down). This will give you a very small subset of sites to search. The algorithm can be:\\n1.check if disconnected initially, if yes return 0\\n2.check if one site from above set is removed we can get disconnected, if anyone yes, return 1\\n3.return 2"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "In my opinion, question description is not really clear. What do they actually asks:\\nHow many minimal nodes you should delete, if you need to have at least two islands on the map. "
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "[[0,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,0]]\\nhow is the ouput :1 for this test cases ??\\nisn\\'t the answer 2"
                    },
                    {
                        "username": "ichu_03",
                        "content": "if we convert the land at (1,0) to water then there will be 2 islands in total making the graph disconnected."
                    }
                ]
            },
            {
                "id": 1566978,
                "content": [
                    {
                        "username": "hemant_dhanuka",
                        "content": "** An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s.**\\nwhat does this line mean and \\n\\nand please some one explain first test case \\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\nOutput: 2\\nExplanation: We need at least 2 days to get a disconnected grid.\\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island."
                    },
                    {
                        "username": "crosslives",
                        "content": "It looks like that we need to find a minimal set of vertex and make graph unconnected."
                    },
                    {
                        "username": "jacksci",
                        "content": "First, notice the answer can only be 0,1, or 2\\nThen, to check if 1 is the answer you just need to check if it\\'s disconnected after removing one site.\\nAnd the one site being removed must be a site with exactly 2 opposite neighbors(left&right or up&down). This will give you a very small subset of sites to search. The algorithm can be:\\n1.check if disconnected initially, if yes return 0\\n2.check if one site from above set is removed we can get disconnected, if anyone yes, return 1\\n3.return 2"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "In my opinion, question description is not really clear. What do they actually asks:\\nHow many minimal nodes you should delete, if you need to have at least two islands on the map. "
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "[[0,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,0]]\\nhow is the ouput :1 for this test cases ??\\nisn\\'t the answer 2"
                    },
                    {
                        "username": "ichu_03",
                        "content": "if we convert the land at (1,0) to water then there will be 2 islands in total making the graph disconnected."
                    }
                ]
            },
            {
                "id": 1574301,
                "content": [
                    {
                        "username": "hemant_dhanuka",
                        "content": "** An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s.**\\nwhat does this line mean and \\n\\nand please some one explain first test case \\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\nOutput: 2\\nExplanation: We need at least 2 days to get a disconnected grid.\\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island."
                    },
                    {
                        "username": "crosslives",
                        "content": "It looks like that we need to find a minimal set of vertex and make graph unconnected."
                    },
                    {
                        "username": "jacksci",
                        "content": "First, notice the answer can only be 0,1, or 2\\nThen, to check if 1 is the answer you just need to check if it\\'s disconnected after removing one site.\\nAnd the one site being removed must be a site with exactly 2 opposite neighbors(left&right or up&down). This will give you a very small subset of sites to search. The algorithm can be:\\n1.check if disconnected initially, if yes return 0\\n2.check if one site from above set is removed we can get disconnected, if anyone yes, return 1\\n3.return 2"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "In my opinion, question description is not really clear. What do they actually asks:\\nHow many minimal nodes you should delete, if you need to have at least two islands on the map. "
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "[[0,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,0]]\\nhow is the ouput :1 for this test cases ??\\nisn\\'t the answer 2"
                    },
                    {
                        "username": "ichu_03",
                        "content": "if we convert the land at (1,0) to water then there will be 2 islands in total making the graph disconnected."
                    }
                ]
            },
            {
                "id": 2072412,
                "content": [
                    {
                        "username": "hemant_dhanuka",
                        "content": "** An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s.**\\nwhat does this line mean and \\n\\nand please some one explain first test case \\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\nOutput: 2\\nExplanation: We need at least 2 days to get a disconnected grid.\\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island."
                    },
                    {
                        "username": "crosslives",
                        "content": "It looks like that we need to find a minimal set of vertex and make graph unconnected."
                    },
                    {
                        "username": "jacksci",
                        "content": "First, notice the answer can only be 0,1, or 2\\nThen, to check if 1 is the answer you just need to check if it\\'s disconnected after removing one site.\\nAnd the one site being removed must be a site with exactly 2 opposite neighbors(left&right or up&down). This will give you a very small subset of sites to search. The algorithm can be:\\n1.check if disconnected initially, if yes return 0\\n2.check if one site from above set is removed we can get disconnected, if anyone yes, return 1\\n3.return 2"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "In my opinion, question description is not really clear. What do they actually asks:\\nHow many minimal nodes you should delete, if you need to have at least two islands on the map. "
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "[[0,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,0]]\\nhow is the ouput :1 for this test cases ??\\nisn\\'t the answer 2"
                    },
                    {
                        "username": "ichu_03",
                        "content": "if we convert the land at (1,0) to water then there will be 2 islands in total making the graph disconnected."
                    }
                ]
            },
            {
                "id": 1928951,
                "content": [
                    {
                        "username": "hemant_dhanuka",
                        "content": "** An island is a maximal 4-directionally (horizontal or vertical) connected group of 1s.**\\nwhat does this line mean and \\n\\nand please some one explain first test case \\nInput: grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]\\nOutput: 2\\nExplanation: We need at least 2 days to get a disconnected grid.\\nChange land grid[1][1] and grid[0][2] to water and get 2 disconnected island."
                    },
                    {
                        "username": "crosslives",
                        "content": "It looks like that we need to find a minimal set of vertex and make graph unconnected."
                    },
                    {
                        "username": "jacksci",
                        "content": "First, notice the answer can only be 0,1, or 2\\nThen, to check if 1 is the answer you just need to check if it\\'s disconnected after removing one site.\\nAnd the one site being removed must be a site with exactly 2 opposite neighbors(left&right or up&down). This will give you a very small subset of sites to search. The algorithm can be:\\n1.check if disconnected initially, if yes return 0\\n2.check if one site from above set is removed we can get disconnected, if anyone yes, return 1\\n3.return 2"
                    },
                    {
                        "username": "AleksandrT",
                        "content": "In my opinion, question description is not really clear. What do they actually asks:\\nHow many minimal nodes you should delete, if you need to have at least two islands on the map. "
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "[[0,1,0,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,0]]\\nhow is the ouput :1 for this test cases ??\\nisn\\'t the answer 2"
                    },
                    {
                        "username": "ichu_03",
                        "content": "if we convert the land at (1,0) to water then there will be 2 islands in total making the graph disconnected."
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Ways to Reorder Array to Get Same BST",
        "question_content": "<p>Given an array <code>nums</code> that represents a permutation of integers from <code>1</code> to <code>n</code>. We are going to construct a binary search tree (BST) by inserting the elements of <code>nums</code> in order into an initially empty BST. Find the number of different ways to reorder <code>nums</code> so that the constructed BST is identical to that formed from the original array <code>nums</code>.</p>\n\n<ul>\n\t<li>For example, given <code>nums = [2,1,3]</code>, we will have 2 as the root, 1 as a left child, and 3 as a right child. The array <code>[2,3,1]</code> also yields the same BST but <code>[3,2,1]</code> yields a different BST.</li>\n</ul>\n\n<p>Return <em>the number of ways to reorder</em> <code>nums</code> <em>such that the BST formed is identical to the original BST formed from</em> <code>nums</code>.</p>\n\n<p>Since the answer may be very large, <strong>return it modulo </strong><code>10<sup>9</sup> + 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/12/bb.png\" style=\"width: 121px; height: 101px;\" />\n<pre>\n<strong>Input:</strong> nums = [2,1,3]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/12/ex1.png\" style=\"width: 241px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> nums = [3,4,5,1,2]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The following 5 arrays will yield the same BST: \n[3,1,2,4,5]\n[3,1,4,2,5]\n[3,1,4,5,2]\n[3,4,1,2,5]\n[3,4,1,5,2]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/12/ex4.png\" style=\"width: 121px; height: 161px;\" />\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no other orderings of nums that will yield the same BST.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= nums.length</code></li>\n\t<li>All integers in <code>nums</code> are <strong>distinct</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 819369,
                "title": "c-just-using-recursion-very-clean-and-easy-to-understand-o-n-2",
                "content": "So, we can know that for a fixed root, the left subtree elements and the right subtree elements are also fixed.\\n\\nWe can find the ``left subtree elements`` which are all the elements that is **smaller** than root value, and ``right subtree elements`` which are **greater** than root value.\\n\\nAnd in order to make it identical with original BST, we should **keep the relative order** in left subtree elements and in right subtree elements.\\n\\nAssume the lenght of left subtree elements is ``left_len`` and right is ``right_len``, they **can change their absolute position** but **need to keep their relative position** in either left subtree or right right subtree. \\n\\nSo as the subtree, so we use recursion.\\n\\n**Example**\\n```\\n[3, 4, 5, 1, 2] // original array with root value is 3\\n\\n[1, 2] // left sub-sequence, left_len = 2\\n[4, 5] // right sub-sequence, right_len = 2\\n\\n// the left sub-sequence and right sub-sequence take 4 position, because left_len + right_len = 4\\n\\n// keep relative order  in left sub-sequence and in right-sequence, but can change absolute position.\\n[1, 2, 4, 5]\\n[1, 4, 2, 5]\\n[1, 4, 5, 2]\\n[4, 1, 2, 5]\\n[4, 1, 5, 2]\\n[4, 5, 1, 2]\\n// number of permutation: 6\\n\\n// in code, we use Pascal triangle to keep a table of permutations, so we can look up the table and get permutation result in O(1)\\n```\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        long long mod = 1e9 + 7;\\n\\t\\tint n = nums.size();\\n        \\n\\t\\t// Pascal triangle\\n        table.resize(n + 1);\\n        for(int i = 0; i < n + 1; ++i){\\n            table[i] = vector<long long>(i + 1, 1);\\n            for(int j = 1; j < i; ++j){\\n                table[i][j] = (table[i-1][j-1] + table[i-1][j]) % mod;\\n            }\\n        }\\n        \\n        long long ans = dfs(nums, mod);\\n        return ans % mod - 1;\\n    }\\n    \\nprivate:\\n    vector<vector<long long>> table;\\n    long long dfs(vector<int> &nums, long long mod){\\n        int n = nums.size();\\n        if(n <= 2) return 1;\\n        \\n\\t\\t// find left sub-sequence elements and right sub-sequence elements\\n        vector<int> left, right;\\n        for(int i = 1; i < nums.size(); ++i){\\n            if(nums[i] < nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n\\t\\t\\n\\t\\t// recursion with left subtree and right subtree\\n        long long left_res = dfs(left, mod) % mod;\\n        long long right_res = dfs(right, mod) % mod;\\n\\t\\t\\n\\t\\t// look up table and multiple them together\\n\\t\\tint left_len = left.size(), right_len = right.size();\\n        return (((table[n - 1][left_len] * left_res) % mod) * right_res) % mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[3, 4, 5, 1, 2] // original array with root value is 3\\n\\n[1, 2] // left sub-sequence, left_len = 2\\n[4, 5] // right sub-sequence, right_len = 2\\n\\n// the left sub-sequence and right sub-sequence take 4 position, because left_len + right_len = 4\\n\\n// keep relative order  in left sub-sequence and in right-sequence, but can change absolute position.\\n[1, 2, 4, 5]\\n[1, 4, 2, 5]\\n[1, 4, 5, 2]\\n[4, 1, 2, 5]\\n[4, 1, 5, 2]\\n[4, 5, 1, 2]\\n// number of permutation: 6\\n\\n// in code, we use Pascal triangle to keep a table of permutations, so we can look up the table and get permutation result in O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        long long mod = 1e9 + 7;\\n\\t\\tint n = nums.size();\\n        \\n\\t\\t// Pascal triangle\\n        table.resize(n + 1);\\n        for(int i = 0; i < n + 1; ++i){\\n            table[i] = vector<long long>(i + 1, 1);\\n            for(int j = 1; j < i; ++j){\\n                table[i][j] = (table[i-1][j-1] + table[i-1][j]) % mod;\\n            }\\n        }\\n        \\n        long long ans = dfs(nums, mod);\\n        return ans % mod - 1;\\n    }\\n    \\nprivate:\\n    vector<vector<long long>> table;\\n    long long dfs(vector<int> &nums, long long mod){\\n        int n = nums.size();\\n        if(n <= 2) return 1;\\n        \\n\\t\\t// find left sub-sequence elements and right sub-sequence elements\\n        vector<int> left, right;\\n        for(int i = 1; i < nums.size(); ++i){\\n            if(nums[i] < nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n\\t\\t\\n\\t\\t// recursion with left subtree and right subtree\\n        long long left_res = dfs(left, mod) % mod;\\n        long long right_res = dfs(right, mod) % mod;\\n\\t\\t\\n\\t\\t// look up table and multiple them together\\n\\t\\tint left_len = left.size(), right_len = right.size();\\n        return (((table[n - 1][left_len] * left_res) % mod) * right_res) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819326,
                "title": "python-in-6-short-lines-with-easy-explanation",
                "content": "We separate all the elements into two lists, depending on whether they are less than or more than the root.  Then we recurse on those left and right sublists.  The combination is for the macro ordering between left and right, and the recursive factors are for the internal ordering of left and right themselves.  I minus 1 from the result because we don\\'t count the original ordering.\\n\\n```\\ndef numOfWays(self, nums: List[int]) -> int:\\n    def f(nums):\\n        if len(nums) <= 2: return 1\\n        left = [v for v in nums if v < nums[0]]\\n        right = [v for v in nums if v > nums[0]]\\n        return comb(len(left)+len(right), len(right)) * f(left) * f(right)\\n    return (f(nums)-1) % (10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\ndef numOfWays(self, nums: List[int]) -> int:\\n    def f(nums):\\n        if len(nums) <= 2: return 1\\n        left = [v for v in nums if v < nums[0]]\\n        right = [v for v in nums if v > nums[0]]\\n        return comb(len(left)+len(right), len(right)) * f(left) * f(right)\\n    return (f(nums)-1) % (10**9+7)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3643494,
                "title": "python-easy-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nHere are my initial thoughts on how to solve this problem:\\n\\n- The base case of the recursive function f is when the length of the input list nums is less than or equal to 2, in which case there is only one way to arrange the numbers. This is returned as 1.\\n\\n- The recursive case involves splitting the list nums into two sublists: left and right. The left sublist contains numbers smaller than the first element of nums, while the right sublist contains numbers greater than the first element.\\n\\n- The number of ways to arrange the numbers in nums is calculated as the product of three factors:\\n\\n- The number of ways to choose the positions for the right sublist among the total number of positions (i.e., combinations of the lengths of left and right).\\n- The number of ways to arrange the numbers in the left sublist.\\n- The number of ways to arrange the numbers in the right sublist.\\n\\n- The recursive calls to f are made on the left and right sublists to compute the number of ways to arrange their respective numbers.\\n\\n- Finally, the result is obtained by subtracting 1 from the total number of ways and taking the modulus with (10**9 + 7).\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe numOfWays function calculates the number of ways to arrange the given list of numbers by recursively calling the helper function f.\\n\\nThe recursive function f performs the following steps:\\n\\n- It checks for the base case: if the length of the input list nums is less than or equal to 2, indicating that there is only one way to arrange the numbers, it returns 1.\\n\\n- For the recursive case, the function splits the input list nums into two sublists: left and right. The left sublist contains all the numbers smaller than the first element of nums, while the right sublist contains all the numbers greater than the first element.\\n\\n- The number of ways to arrange the numbers in nums is calculated as follows:\\n\\n- Determine the number of positions available for the right sublist by combining the lengths of the left and right sublists using the comb function from the math module.\\n\\n- Multiply the above value by the number of ways to arrange the numbers in the left sublist (by making a recursive call to f).\\n\\n- Multiply the result by the number of ways to arrange the numbers in the right sublist (also by making a recursive call to f).\\n\\n- The final result is obtained by subtracting 1 from the total number of ways calculated and taking the modulus with (10**9 + 7).\\n\\n## To improve the code:\\n\\nImport the comb function from the math module.\\nUse proper formatting and indentation to enhance code readability.\\nTesting the code with different inputs and comparing the results against expected outcomes would be crucial to ensure the correctness of the implementation.\\n\\n\\n# Complexity\\n- Time complexity:$$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import comb\\nfrom typing import List\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def f(nums):\\n            if len(nums) <= 2:\\n                return 1\\n            left = [v for v in nums if v < nums[0]]\\n            right = [v for v in nums if v > nums[0]]\\n            return comb(len(left) + len(right), len(right)) * f(left) * f(right)\\n        \\n        return (f(nums) - 1) % (10**9 + 7)\\n\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/090d4226-0fbd-4c7f-a545-4bc816d92153_1686881740.5216572.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom math import comb\\nfrom typing import List\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def f(nums):\\n            if len(nums) <= 2:\\n                return 1\\n            left = [v for v in nums if v < nums[0]]\\n            right = [v for v in nums if v > nums[0]]\\n            return comb(len(left) + len(right), len(right)) * f(left) * f(right)\\n        \\n        return (f(nums) - 1) % (10**9 + 7)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819858,
                "title": "c-python-question-explained-then-detailed-solution-short-fast-readable",
                "content": "Question can seem confusing. Note that we are inserting the numbers in the binary search tree in *exactly the same order as they occur in the input array*. \\n\\nThis is a good time to recall a fact which may seem very obvious but is crucial to understand the question: *For a fixed sequence of insertion, the number of binary search trees generated is exactly one.*\\n\\n### Approach\\n\\nKey insight:  as long as the root of the binary search tree is inserted first (and recursively, other parents are inserted before their subtrees), any permutation of other elements will generate the same BST. This may feel a bit mouthful, so let\\'s understand with an example.\\n\\nFor BST given in example, as long as 3 comes before others, 4 comes before 5, 1 comes before 2, we can generate the same BST.\\n![image](https://assets.leetcode.com/users/images/c450a9aa-7b50-4fe4-b041-f1f4328c957c_1598773056.857656.png)\\n\\nThis is true for all of the following arrays:\\n```python\\n[3,1,2,4,5]\\n[3,1,4,2,5]\\n[3,1,4,5,2]\\n[3,4,1,2,5]\\n[3,4,1,5,2]\\n```\\nLet\\'s see an example of [3, 4, 1, 5, 2]\\n\\nFirst to insert is 3. Tree is just a single node 3.\\n\\nThen we insert 4. Has to go on right of 3. Tree is\\n```\\n    3\\n\\t \\\\\\n\\t  4\\n```\\n\\nThen we insert 1. (Again note that we have to insert in the same order as input array. I\\'ll repeat this several times :D)\\n\\n```\\n      3\\n\\t / \\\\\\n\\t1  4\\n```\\n\\nThen 5\\n```\\n       3\\n\\t  / \\\\\\n\\t1   4\\n\\t      \\\\\\n\\t\\t   5\\n```\\n\\nThen 2\\n\\n```\\n       3\\n\\t  / \\\\\\n\\t1   4\\n  \\t \\\\     \\\\\\n\\t  2\\t   5\\n```\\n\\nTry other arrays listed above and convince yourself that it will generate identical BST.\\n\\nSo, for this BST, \\n\\n- choose 3 as root (the element which is first in insertion order)\\n- `[1,2]` will be in the `left` subtree. Maintaining order is important to ensure that we generate the same BST.  Let `m = left.size()`\\n- `[4,5]` in `right` subtree. Let `n = right.size()`\\n- find ways to interleave them.\\nThe number of ways are just interleavings of left and right.  Similar to https://leetcode.com/problems/interleaving-string/\\nHow many ways are there to interleave left and right?\\n\\nThere are `m + n` total positions. If we put `m` elements from `left` in randomly chosen `m` positions (but, in order), we can put the rest in other (right ;-)) positions. (Equivalently, we could also have chosen to fill `n` arbitrary positions from `right` and fill remaining from whatever positions are left.)\\n\\nThat\\u2019s just:\\n![image](https://assets.leetcode.com/users/images/7e8c309e-7a08-49a7-a86e-8e3600ec8a95_1598774425.5294194.png)\\n\\n\\nSo algorithm would be\\n\\n- Fix the root (first element of the input)\\n- Find smaller and larger elements than root. These would be left and right subtrees (meh)\\n- Combine, which is an interleaving as explained above.\\n\\nFollow up: If you actually want to [generate all the arrays](https://stackoverflow.com/questions/21211701/given-a-bst-and-its-root-print-all-sequences-of-nodes-which-give-rise-to-the-sa/24398114#24398114)\\n\\n### Python\\n```python\\nclass Solution:\\n\\n    def numOfWays(self, numbers):\\n        mod = 10 ** 9 + 7\\n\\n        def ways_to_interleave(sequence_1, sequence_2):\\n            \"\"\"\\n            Number of ways to interleave two sequences (i.e. maintaining the order)\\n            \"\"\"\\n            total_things = len(sequence_1) + len(sequence_2)\\n            things_to_choose = len(sequence_1)  # or len(sequence_2), doesn\\'t matter.\\n            return math.comb(total_things, things_to_choose)\\n\\n        def helper(subsequence):\\n            if not subsequence:\\n                return 1\\n            root_value = subsequence[0]\\n            left = [number for number in subsequence if number < root_value]\\n            right = [number for number in subsequence if number > root_value]\\n            ways_to_arrange_left = helper(left)\\n            ways_to_arrange_right = helper(right)\\n            return ways_to_arrange_left * ways_to_arrange_right * ways_to_interleave(left, right)\\n        return (helper(numbers) - 1) % mod\\n\\n```\\nThis surprisingly beats all other python solutions so far (but speed is not the aim of this code, it\\'s readability)\\n\\n### C++\\n\\nPeople who build numerical libraries have my huge respect. Getting [`combinations` method (ommitted) without overflow is tricky for a C++ noob like me. I\\'ve lifted the version from here](https://stackoverflow.com/questions/11809502/which-is-better-way-to-calculate-ncr?noredirect=1&lq=1). Others have used pascal triangle methods, which are easiest to implement in interview and worth a look.\\n\\n```cpp\\n#include <vector>\\n#include <cmath>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int numOfWays(std::vector<int>& numbers) {\\n\\t\\t\\treturn (helper(numbers) - 1) % mod;\\n    }\\n\\nprivate:\\n\\t\\tint mod = std::pow(10, 9) + 7;\\n\\n\\t\\tint ways_to_interleave(int sequence_1_length, int sequence_2_length) {\\n\\t\\t\\treturn combinations(sequence_1_length + sequence_2_length, sequence_2_length, mod); // combinations function is omitted as it\\'s not really relevant to core issue of the question.\\n\\t\\t}\\n\\n\\t\\tlong helper(const std::vector<int>& numbers) {\\n\\t\\t\\tif (numbers.empty()) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tint root_value = numbers[0];\\n\\t\\t\\tstd::vector<int> left, right;\\n\\t\\t\\tstd::copy_if(numbers.begin(), numbers.end(), std::back_inserter(left), [root_value](int number){return number < root_value;});\\n\\t\\t\\tstd::copy_if(numbers.begin(), numbers.end(), std::back_inserter(right), [root_value](int number){return number > root_value;});\\n\\t\\t\\tlong  ways_to_arrange_left = helper(left) % mod;\\n\\t\\t\\tlong ways_to_arrange_right = helper(right) % mod;\\n            long duck_this = (ways_to_arrange_left * ways_to_arrange_right) % mod;\\n\\t\\t\\tlong duck_this_too = (duck_this * ways_to_interleave(left.size(), right.size())) % mod;\\n            return duck_this_too;\\n\\t\\t\\t\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```python\\n[3,1,2,4,5]\\n[3,1,4,2,5]\\n[3,1,4,5,2]\\n[3,4,1,2,5]\\n[3,4,1,5,2]\\n```\n```\\n    3\\n\\t \\\\\\n\\t  4\\n```\n```\\n      3\\n\\t / \\\\\\n\\t1  4\\n```\n```\\n       3\\n\\t  / \\\\\\n\\t1   4\\n\\t      \\\\\\n\\t\\t   5\\n```\n```\\n       3\\n\\t  / \\\\\\n\\t1   4\\n  \\t \\\\     \\\\\\n\\t  2\\t   5\\n```\n```python\\nclass Solution:\\n\\n    def numOfWays(self, numbers):\\n        mod = 10 ** 9 + 7\\n\\n        def ways_to_interleave(sequence_1, sequence_2):\\n            \"\"\"\\n            Number of ways to interleave two sequences (i.e. maintaining the order)\\n            \"\"\"\\n            total_things = len(sequence_1) + len(sequence_2)\\n            things_to_choose = len(sequence_1)  # or len(sequence_2), doesn\\'t matter.\\n            return math.comb(total_things, things_to_choose)\\n\\n        def helper(subsequence):\\n            if not subsequence:\\n                return 1\\n            root_value = subsequence[0]\\n            left = [number for number in subsequence if number < root_value]\\n            right = [number for number in subsequence if number > root_value]\\n            ways_to_arrange_left = helper(left)\\n            ways_to_arrange_right = helper(right)\\n            return ways_to_arrange_left * ways_to_arrange_right * ways_to_interleave(left, right)\\n        return (helper(numbers) - 1) % mod\\n\\n```\n```cpp\\n#include <vector>\\n#include <cmath>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int numOfWays(std::vector<int>& numbers) {\\n\\t\\t\\treturn (helper(numbers) - 1) % mod;\\n    }\\n\\nprivate:\\n\\t\\tint mod = std::pow(10, 9) + 7;\\n\\n\\t\\tint ways_to_interleave(int sequence_1_length, int sequence_2_length) {\\n\\t\\t\\treturn combinations(sequence_1_length + sequence_2_length, sequence_2_length, mod); // combinations function is omitted as it\\'s not really relevant to core issue of the question.\\n\\t\\t}\\n\\n\\t\\tlong helper(const std::vector<int>& numbers) {\\n\\t\\t\\tif (numbers.empty()) {\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t\\tint root_value = numbers[0];\\n\\t\\t\\tstd::vector<int> left, right;\\n\\t\\t\\tstd::copy_if(numbers.begin(), numbers.end(), std::back_inserter(left), [root_value](int number){return number < root_value;});\\n\\t\\t\\tstd::copy_if(numbers.begin(), numbers.end(), std::back_inserter(right), [root_value](int number){return number > root_value;});\\n\\t\\t\\tlong  ways_to_arrange_left = helper(left) % mod;\\n\\t\\t\\tlong ways_to_arrange_right = helper(right) % mod;\\n            long duck_this = (ways_to_arrange_left * ways_to_arrange_right) % mod;\\n\\t\\t\\tlong duck_this_too = (duck_this * ways_to_interleave(left.size(), right.size())) % mod;\\n            return duck_this_too;\\n\\t\\t\\t\\t\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 819725,
                "title": "java-clean-code-uses-yang-hui-s-pascal-s-triangle-with-explanation",
                "content": "This is actually a mathematical problem that can be solved by combination calculation, what\\'d you do is basically arranging left and right sub-trees in correct order but in all possible combinations.\\nFor example for array ```[3,6,4,1]```\\n```\\n[3,6,4,1] left sub tree is [1], right tree is [6,4], \\nwe just need to keep 6 appear in front of 4 to make permutation a valid one,\\nso combinations can be [6,4,1], [6,1,4], [1,6,4]\\nObviously, if left sub tree length is 1 and total length is 3, combination is 3C1 which is 3\\n```\\nExpand to a more complicated case ```[3,6,4,1,7]```\\n```\\nleft sub tree is [1], right tree is [6,4,7], \\npermutations for right tree itself is [6,4,7], [6,7,4] which means it\\'s 2C1 (combination of [4] and [7])\\nfor every permuration of right tree you can also combine it with left tree [1] so total # is 4C1*2C1=8\\n```\\nTseudo code:\\n```\\ndef dfs(nums):\\n\\tif len(nums) <= 2:\\n\\t\\treturn 1\\n\\tleft = [x in nums which < nums[0]]\\n\\tright = [x in nums which > nums[0]]\\n\\treturn combination(len(lefft+right), len(left)) * dfs(left) * dfs(right)\\n```\\nHere comes the tricky part for Java, doing mathematical stuff in Java is really a PAIN in the ass since it doesn\\'t have ```comb()``` function in python and it doesn\\'t support ```long long```, I didn\\'t know why the hint is dynamic programming, now I get it, I can use Yang Hui/Pascal\\'s triangle to speed up calculation and get rid of overflow, are you serious leetcode? \\n```\\nclass Solution {\\n    private static final long MOD = 1000000007;\\n    public int numOfWays(int[] nums) {\\n        int len = nums.length;\\n        List<Integer> arr = new ArrayList<>();\\n        for (int n : nums) {\\n            arr.add(n);\\n        }\\n        return (int)getCombs(arr, getTriangle(len + 1)) - 1;\\n    }\\n    \\n    private long getCombs(List<Integer> nums, long[][] combs) {\\n        if (nums.size() <= 2) {\\n            return 1;\\n        }\\n        int root = nums.get(0);\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for (int n : nums) {\\n            if (n < root) {\\n                left.add(n);\\n            } else if (n > root) {\\n                right.add(n);\\n            }\\n        }\\n        // mod every number to avoid overflow\\n        return (combs[left.size() + right.size()][left.size()] * (getCombs(left, combs) % MOD) % MOD) * getCombs(right, combs) % MOD;\\n    }\\n    \\n    private long[][] getTriangle(int n) {\\n        // Yang Hui (Pascle) triangle\\n        // 4C2 = triangle[4][2] = 6\\n        long[][] triangle = new long[n][n];\\n        for (int i = 0; i < n; i++) {\\n            triangle[i][0] = triangle[i][i] = 1;\\n        }\\n        for (int i = 2; i < n; i++) {\\n            for (int j = 1; j < i; j++) {\\n                triangle[i][j] = (triangle[i - 1][j] + triangle[i - 1][j - 1]) % MOD;\\n            }\\n        }\\n        return triangle;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```[3,6,4,1]```\n```\\n[3,6,4,1] left sub tree is [1], right tree is [6,4], \\nwe just need to keep 6 appear in front of 4 to make permutation a valid one,\\nso combinations can be [6,4,1], [6,1,4], [1,6,4]\\nObviously, if left sub tree length is 1 and total length is 3, combination is 3C1 which is 3\\n```\n```[3,6,4,1,7]```\n```\\nleft sub tree is [1], right tree is [6,4,7], \\npermutations for right tree itself is [6,4,7], [6,7,4] which means it\\'s 2C1 (combination of [4] and [7])\\nfor every permuration of right tree you can also combine it with left tree [1] so total # is 4C1*2C1=8\\n```\n```\\ndef dfs(nums):\\n\\tif len(nums) <= 2:\\n\\t\\treturn 1\\n\\tleft = [x in nums which < nums[0]]\\n\\tright = [x in nums which > nums[0]]\\n\\treturn combination(len(lefft+right), len(left)) * dfs(left) * dfs(right)\\n```\n```comb()```\n```long long```\n```\\nclass Solution {\\n    private static final long MOD = 1000000007;\\n    public int numOfWays(int[] nums) {\\n        int len = nums.length;\\n        List<Integer> arr = new ArrayList<>();\\n        for (int n : nums) {\\n            arr.add(n);\\n        }\\n        return (int)getCombs(arr, getTriangle(len + 1)) - 1;\\n    }\\n    \\n    private long getCombs(List<Integer> nums, long[][] combs) {\\n        if (nums.size() <= 2) {\\n            return 1;\\n        }\\n        int root = nums.get(0);\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for (int n : nums) {\\n            if (n < root) {\\n                left.add(n);\\n            } else if (n > root) {\\n                right.add(n);\\n            }\\n        }\\n        // mod every number to avoid overflow\\n        return (combs[left.size() + right.size()][left.size()] * (getCombs(left, combs) % MOD) % MOD) * getCombs(right, combs) % MOD;\\n    }\\n    \\n    private long[][] getTriangle(int n) {\\n        // Yang Hui (Pascle) triangle\\n        // 4C2 = triangle[4][2] = 6\\n        long[][] triangle = new long[n][n];\\n        for (int i = 0; i < n; i++) {\\n            triangle[i][0] = triangle[i][i] = 1;\\n        }\\n        for (int i = 2; i < n; i++) {\\n            for (int j = 1; j < i; j++) {\\n                triangle[i][j] = (triangle[i - 1][j] + triangle[i - 1][j - 1]) % MOD;\\n            }\\n        }\\n        return triangle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643610,
                "title": "bst-hard-to-easy-c-java-python-clear",
                "content": "# Intuition\\n- To construct a BST, we need to select a root node and divide the remaining elements into two groups: the left subtree (containing elements smaller than the root) and the right subtree (containing elements larger than the root). The order of elements within each subtree doesn\\'t matter as long as the relative order of the elements with respect to the root is maintained.\\n\\n- Based on this observation, we can approach the problem recursively. For a given array nums, we can select the first element as the root and divide the remaining elements into the left and right subtrees. Then, we recursively count the number of BSTs for the left and right subtrees and multiply them by the number of possible combinations of left and right subtrees. The total count is the product of these values.\\n\\n---\\n# Kindly Vote Sir Please \\n![images.jpeg](https://assets.leetcode.com/users/images/41c9663f-37cb-45c2-861f-d6c75bc319b9_1686885458.72043.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The problem requires counting the number of ways to reorder the given array such that the resulting order yields the same binary search tree (BST). To solve the problem, we can use a recursive approach combined with the concept of Catalan numbers.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n# Time complexity: O(N^3).\\nThe time complexity of the solution is determined by the number of recursive calls made to the countBST function. In the worst case, the recursive function will be called for every possible division of the array into left and right subtrees. Since each recursive call reduces the size of the array by one, the number of recursive calls is proportional to the number of elements in the array, which is O(N). Additionally, calculating the binomial coefficients using dynamic programming takes O(N^2) time. Therefore, the overall time complexity is O(N^3).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Space complexity: O(N^2)\\nThe space complexity is determined by the recursion stack used for the recursive calls. In the worst case, the recursion depth can be equal to the number of elements in the array, which is O(N). Additionally, the dynamic programming approach for calculating binomial coefficients requires O(N^2) space for the 2D dp array. Therefore, the overall space complexity is O(N^2).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n# Note \\nThe space complexity can be further optimized by using memoization techniques to avoid redundant calculations of binomial coefficients. This can be achieved by storing previously computed values in a memoization table. With memoization, the space complexity can be reduced to O(N) for both time and space.\\n\\n# Code\\n```C++ []\\n\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        const int MOD = 1e9 + 7;\\n        return (countBST(nums) - 1 + MOD) % MOD;  // Subtract 1 to exclude the original ordering\\n    }\\n\\nprivate:\\n    int countBST(vector<int>& nums) {\\n        if (nums.size() <= 2)\\n            return 1;\\n\\n        vector<int> left, right;\\n        int root = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] < root)\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }\\n\\n        long long leftCount = countBST(left);    // Count the number of BSTs for the left subtree\\n        long long rightCount = countBST(right);  // Count the number of BSTs for the right subtree\\n\\n        // Calculate the number of combinations using the Catalan number formula\\n        long long totalCount = binomialCoefficient(left.size() + right.size(), left.size());\\n\\n        return (leftCount * rightCount % 1000000007 * totalCount % 1000000007);\\n    }\\n\\n    long long binomialCoefficient(int n, int k) {\\n        const int MOD = 1e9 + 7;\\n\\n        vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, 0));\\n        dp[0][0] = 1;\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i][0] = 1;\\n            for (int j = 1; j <= min(i, k); j++) {\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n};\\n\\n```\\n```Java []\\n\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        const int MOD = 1e9 + 7;\\n        return (countBST(nums) - 1 + MOD) % MOD;  // Subtract 1 to exclude the original ordering\\n    }\\n\\nprivate:\\n    int countBST(vector<int>& nums) {\\n        if (nums.size() <= 2)\\n            return 1;\\n\\n        vector<int> left, right;\\n        int root = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] < root)\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }\\n\\n        long long leftCount = countBST(left);    // Count the number of BSTs for the left subtree\\n        long long rightCount = countBST(right);  // Count the number of BSTs for the right subtree\\n\\n        // Calculate the number of combinations using the Catalan number formula\\n        long long totalCount = binomialCoefficient(left.size() + right.size(), left.size());\\n\\n        return (leftCount * rightCount % 1000000007 * totalCount % 1000000007);\\n    }\\n\\n    long long binomialCoefficient(int n, int k) {\\n        const int MOD = 1e9 + 7;\\n\\n        vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, 0));\\n        dp[0][0] = 1;\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i][0] = 1;\\n            for (int j = 1; j <= min(i, k); j++) {\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n};\\n\\n```\\n```Python []\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        return (self.countBST(nums) - 1 + MOD) % MOD\\n\\n    def countBST(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return 1\\n\\n        left = []\\n        right = []\\n        root = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < root:\\n                left.append(nums[i])\\n            else:\\n                right.append(nums[i])\\n\\n        leftCount = self.countBST(left)\\n        rightCount = self.countBST(right)\\n\\n        totalCount = self.binomialCoefficient(len(left) + len(right), len(left))\\n\\n        return (leftCount * rightCount * totalCount) % MOD\\n\\n    def binomialCoefficient(self, n: int, k: int) -> int:\\n        MOD = 10**9 + 7\\n\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        dp[0][0] = 1\\n\\n        for i in range(1, n + 1):\\n            dp[i][0] = 1\\n            for j in range(1, min(i, k) + 1):\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD\\n\\n        return dp[n][k]\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\n\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        const int MOD = 1e9 + 7;\\n        return (countBST(nums) - 1 + MOD) % MOD;  // Subtract 1 to exclude the original ordering\\n    }\\n\\nprivate:\\n    int countBST(vector<int>& nums) {\\n        if (nums.size() <= 2)\\n            return 1;\\n\\n        vector<int> left, right;\\n        int root = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] < root)\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }\\n\\n        long long leftCount = countBST(left);    // Count the number of BSTs for the left subtree\\n        long long rightCount = countBST(right);  // Count the number of BSTs for the right subtree\\n\\n        // Calculate the number of combinations using the Catalan number formula\\n        long long totalCount = binomialCoefficient(left.size() + right.size(), left.size());\\n\\n        return (leftCount * rightCount % 1000000007 * totalCount % 1000000007);\\n    }\\n\\n    long long binomialCoefficient(int n, int k) {\\n        const int MOD = 1e9 + 7;\\n\\n        vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, 0));\\n        dp[0][0] = 1;\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i][0] = 1;\\n            for (int j = 1; j <= min(i, k); j++) {\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n};\\n\\n```\n```Java []\\n\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        const int MOD = 1e9 + 7;\\n        return (countBST(nums) - 1 + MOD) % MOD;  // Subtract 1 to exclude the original ordering\\n    }\\n\\nprivate:\\n    int countBST(vector<int>& nums) {\\n        if (nums.size() <= 2)\\n            return 1;\\n\\n        vector<int> left, right;\\n        int root = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] < root)\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }\\n\\n        long long leftCount = countBST(left);    // Count the number of BSTs for the left subtree\\n        long long rightCount = countBST(right);  // Count the number of BSTs for the right subtree\\n\\n        // Calculate the number of combinations using the Catalan number formula\\n        long long totalCount = binomialCoefficient(left.size() + right.size(), left.size());\\n\\n        return (leftCount * rightCount % 1000000007 * totalCount % 1000000007);\\n    }\\n\\n    long long binomialCoefficient(int n, int k) {\\n        const int MOD = 1e9 + 7;\\n\\n        vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, 0));\\n        dp[0][0] = 1;\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i][0] = 1;\\n            for (int j = 1; j <= min(i, k); j++) {\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n};\\n\\n```\n```Python []\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        return (self.countBST(nums) - 1 + MOD) % MOD\\n\\n    def countBST(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return 1\\n\\n        left = []\\n        right = []\\n        root = nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] < root:\\n                left.append(nums[i])\\n            else:\\n                right.append(nums[i])\\n\\n        leftCount = self.countBST(left)\\n        rightCount = self.countBST(right)\\n\\n        totalCount = self.binomialCoefficient(len(left) + len(right), len(left))\\n\\n        return (leftCount * rightCount * totalCount) % MOD\\n\\n    def binomialCoefficient(self, n: int, k: int) -> int:\\n        MOD = 10**9 + 7\\n\\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\\n        dp[0][0] = 1\\n\\n        for i in range(1, n + 1):\\n            dp[i][0] = 1\\n            for j in range(1, min(i, k) + 1):\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD\\n\\n        return dp[n][k]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819282,
                "title": "python-o-n-2-post-order-traversal",
                "content": "## Idea\\nThe key idea is to maintain the topological order of the BST. \\nMore specifically, this solution works in this way. \\n\\n**Step 1**\\nFor every node, given that its left subtree has `L` children and its right subtree has `R` children. We denote the number of way to schedule the placement of `L + R` nodes as `N(L, R)`. We then have the following relation.\\n- `N(L, R) = N(L - 1, R) + N(L, R - 1)`, if we want to place 2 subtrees simultaneously, we can place one element either from the left, or from the right.\\n- `N(L, 0) = 1` and `N(0, R) = 1`, if we only have one subtree to place, we have only 1 option, that is to place this subtree directly.\\n\\n**Step 2**\\nWe then compute the product of all `N` values for all the nodes.\\n\\nPlease leave an upvote if you like my post. It means a lot to me.\\n\\n## Complexity\\n- Time and Space: `O(n^2)`\\n\\n## Python\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        @lru_cache(None)\\n        def combine(x, y):\\n            if x == 0 or y == 0: return 1\\n            return combine(x, y - 1) + combine(x - 1, y)\\n        \\n        bst = TreeNode(nums[0])\\n        for n in nums[1:]:\\n            bst.add(n)\\n        \\n        res = 1\\n        def traverse(root):\\n            nonlocal res\\n            if not root: return 0\\n            lc = traverse(root.left)\\n            rc = traverse(root.right)\\n            res = res * combine(lc, rc) % 1000000007\\n            return lc + rc + 1\\n        traverse(bst)\\n        \\n        return res - 1\\n        \\nclass TreeNode:\\n    def __init__(self, v):\\n        self.val = v\\n        self.left = None\\n        self.right = None\\n        \\n    def add(self, v):        \\n        curr = self\\n        node = TreeNode(v)\\n        while 1:\\n            if v < curr.val:\\n                if not curr.left:\\n                    curr.left = node\\n                    break\\n                curr = curr.left\\n            else:                \\n                if not curr.right:\\n                    curr.right = node\\n                    break\\n                curr = curr.right\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        @lru_cache(None)\\n        def combine(x, y):\\n            if x == 0 or y == 0: return 1\\n            return combine(x, y - 1) + combine(x - 1, y)\\n        \\n        bst = TreeNode(nums[0])\\n        for n in nums[1:]:\\n            bst.add(n)\\n        \\n        res = 1\\n        def traverse(root):\\n            nonlocal res\\n            if not root: return 0\\n            lc = traverse(root.left)\\n            rc = traverse(root.right)\\n            res = res * combine(lc, rc) % 1000000007\\n            return lc + rc + 1\\n        traverse(bst)\\n        \\n        return res - 1\\n        \\nclass TreeNode:\\n    def __init__(self, v):\\n        self.val = v\\n        self.left = None\\n        self.right = None\\n        \\n    def add(self, v):        \\n        curr = self\\n        node = TreeNode(v)\\n        while 1:\\n            if v < curr.val:\\n                if not curr.left:\\n                    curr.left = node\\n                    break\\n                curr = curr.left\\n            else:                \\n                if not curr.right:\\n                    curr.right = node\\n                    break\\n                curr = curr.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839559,
                "title": "o-n-simple-fast",
                "content": "First, the answer can be expressed as n!/Product(size(i),i=1..n)-1, where size(i) denotes the size of subtree with root i.\\nThen we have some observations:\\n1. any node in subtree must be inserted after the root\\n2. any subtree contains a consecutive interval\\n3. after any insertion step, any remaining interval will finally form a subtree\\n\\nNow if we invert the insertion process, it becomes deleting nodes from a BST. The observations\\n1. the root of a subtree is the last deleted node in that subtree\\n2. any deleted subtree contains a consecutive interval\\n3. after any deletion step, any removed interval form a subtree\\n\\nWhen a node p is deleted, both of its subtree are already deleted. And if p+1(or p-1) is deleted, it must belong to the right(or left) subtree of p. Otherwise their LCA is not deleted yet and must have value between them, which is impossible. So the deleted interval that contains p+1(or p-1) just forms the right(or left) subtree of p. Adding p to the set of deleted nodes will possibly connect two intervals or extend one interval, which corresponds to the two subtrees of p being non-empty or only one subtree being non-empty. Therefore, using a doubly linked list, we can easily merge intervals and calculate their length, which is the size of subtrees.\\nTake [3,4,5,1,2] as an example:\\nStep 0. complete BST, no deleted nodes yet\\nThe doubly linked list is like 1--2--3--4--5\\nStep 1. delete 2\\nNow we know that the subtree with root 2 has size 1. The node itself form an interval.\\nThe doubly linked list is now 1--[2,2]--3--4--5\\nStep 2. delete 1\\nWe find that 2 is already deleted, so we extend the deleted interval. Now we know that the subtree with root 1 has size 2. The two nodes form an interval.\\nThe doubly linked list is now [1,2]--3--4--5\\nStep 3. delete 5\\nNow we know that the subtree with root 5 has size 1.\\nThe doubly linked list is now [1,2]--3--4--[5,5]\\nStep 4. delete 4\\nNow we know that the subtree with root 4 has size 2.\\nThe doubly linked list is now [1,2]--3--[4,5]\\nStep 5. delete 3\\nNote that both 2 and 4 are deleted, so we connect the two intervals with 3, and find that the subtree with root 3 has size 5.\\nThe doubly linked list is now [1,5].\\nNow we calculate the answer: 5!/(1x2x1x2x5)-1=5.\\nThe inverse element of 1..n under modulo can be calculated in O(n), and there are n operations in doubly linked list each with O(1) time cost, so the overall time complexity is O(n).\\n```\\n#define MOD 1000000007\\n\\nclass Node {\\npublic:\\n    int size,flag;\\n    Node *l,*r;\\n    Node(int s=1,Node* a=NULL,Node* b=NULL):size(s),flag(0),l(a),r(b){}\\n};\\n\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int n=nums.size();\\n        int inv[n+1];inv[1]=1;\\n        long long s=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            inv[i]=((long long)(MOD-MOD/i)*inv[MOD%i])%MOD;\\n            s=(s*i)%MOD;\\n        }\\n        Node p[n+2];\\n        for(int i=0;i<=n+1;i++)\\n        {\\n            p[i].l=p+i-1;\\n            p[i].r=p+i+1;\\n        }\\n        for(auto it=nums.rbegin();it<nums.rend();it++)\\n        {\\n            Node& t=p[*it];t.flag=1;\\n            if(t.l->flag){t.l->l->r=&t;t.size+=t.l->size;t.l=t.l->l;}\\n            if(t.r->flag){t.r->r->l=&t;t.size+=t.r->size;t.r=t.r->r;}\\n            if(t.size>1)s=(s*inv[t.size])%MOD;\\n        }\\n        return (s+MOD-1)%MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define MOD 1000000007\\n\\nclass Node {\\npublic:\\n    int size,flag;\\n    Node *l,*r;\\n    Node(int s=1,Node* a=NULL,Node* b=NULL):size(s),flag(0),l(a),r(b){}\\n};\\n\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int n=nums.size();\\n        int inv[n+1];inv[1]=1;\\n        long long s=1;\\n        for(int i=2;i<=n;i++)\\n        {\\n            inv[i]=((long long)(MOD-MOD/i)*inv[MOD%i])%MOD;\\n            s=(s*i)%MOD;\\n        }\\n        Node p[n+2];\\n        for(int i=0;i<=n+1;i++)\\n        {\\n            p[i].l=p+i-1;\\n            p[i].r=p+i+1;\\n        }\\n        for(auto it=nums.rbegin();it<nums.rend();it++)\\n        {\\n            Node& t=p[*it];t.flag=1;\\n            if(t.l->flag){t.l->l->r=&t;t.size+=t.l->size;t.l=t.l->l;}\\n            if(t.r->flag){t.r->r->l=&t;t.size+=t.r->size;t.r=t.r->r;}\\n            if(t.size>1)s=(s*inv[t.size])%MOD;\\n        }\\n        return (s+MOD-1)%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643613,
                "title": "java-solution-for-number-of-ways-to-reorder-array-to-get-same-bst-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks for the number of different ways to reorder the given array nums such that the constructed Binary Search Tree (BST) is identical to the original BST formed from nums. We can solve this problem recursively by considering the root element of the BST and splitting the remaining elements into two groups: the left subtree elements (less than the root) and the right subtree elements (greater than the root). The total number of ways to reorder nums can be calculated by multiplying the number of ways to reorder the left subtree, the number of ways to reorder the right subtree, and the number of possible combinations of left and right subtrees.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a helper function countWays that takes a list of integers (nums) as input and returns the number of ways to reorder nums to form the same BST.\\n1. In the countWays function:\\n- If the size of nums is less than or equal to 2, return 1 since there is only one way to reorder 0 or 1 element.\\n- Create two empty lists: left and right.\\n- Set the first element of nums as the root value.\\n- Iterate through the remaining elements of nums (starting from the second element):\\n- If the current element is less than the root value, add it to the left list.\\n- Otherwise, add it to the right list.\\n- Calculate the number of ways to reorder the left list (recursively) and store it in leftCount.\\n- Calculate the number of ways to reorder the right list (recursively) and store it in rightCount.\\n- Calculate the number of possible combinations of left and right subtrees using the comb function.\\n- Return the product of comb, leftCount, and rightCount.\\n3. Create a numOfWays function that converts the input array into a list and calls the countWays function. Subtract 1 from the result and return it as the final output.\\n1. Test the program with provided test cases or additional test cases.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n^2), where n is the size of the nums array. This is because for each recursive call, we split the list into left and right subtrees, and in the worst case, the number of elements in the subtrees can be O(n). The comb function also has a time complexity of O(n^2) because it calculates combinations using dynamic programming.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) because we use additional space to store the left and right subtrees. The depth of the recursion can be at most n, so the space required for recursion is also O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int numOfWays(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        return countWays(list) - 1;\\n    }\\n    private int countWays(List<Integer> nums) {\\n        if (nums.size() <= 2) {\\n            return 1;\\n        }\\n        \\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        int root = nums.get(0);\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums.get(i) < root) {\\n                left.add(nums.get(i));\\n            } else {\\n                right.add(nums.get(i));\\n            }\\n        }\\n        \\n        long leftCount = countWays(left);\\n        long rightCount = countWays(right);\\n        \\n        return (int) ((comb(nums.size() - 1, left.size()) % MOD) * (leftCount % MOD) % MOD * (rightCount % MOD) % MOD);\\n    }\\n    \\n    private long comb(int n, int k) {\\n        long[][] dp = new long[n + 1][k + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 1;\\n            for (int j = 1; j <= Math.min(i, k); j++) {\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    public int numOfWays(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int num : nums) {\\n            list.add(num);\\n        }\\n        return countWays(list) - 1;\\n    }\\n    private int countWays(List<Integer> nums) {\\n        if (nums.size() <= 2) {\\n            return 1;\\n        }\\n        \\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        int root = nums.get(0);\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums.get(i) < root) {\\n                left.add(nums.get(i));\\n            } else {\\n                right.add(nums.get(i));\\n            }\\n        }\\n        \\n        long leftCount = countWays(left);\\n        long rightCount = countWays(right);\\n        \\n        return (int) ((comb(nums.size() - 1, left.size()) % MOD) * (leftCount % MOD) % MOD * (rightCount % MOD) % MOD);\\n    }\\n    \\n    private long comb(int n, int k) {\\n        long[][] dp = new long[n + 1][k + 1];\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 1;\\n            for (int j = 1; j <= Math.min(i, k); j++) {\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643434,
                "title": "2-easiest-c-solution-dp-fastest",
                "content": "\\n# Approach : Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code 1\\n```\\nclass Solution {\\n    vector<vector<long long int>> dp;\\n    long long MOD = 1e9 + 7;\\n\\n    unsigned long long solve(vector<int> &nums) {\\n        if (nums.size() <= 1) return 1;\\n        vector<int> l, r;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] > nums[0]) r.push_back(nums[i]);\\n            else l.push_back(nums[i]);\\n        }\\n        int n = l.size(), m = r.size();\\n        return solve(l) * solve(r) % MOD * dp[n + m][n] % MOD;\\n    }\\n\\npublic:\\n    int numOfWays(vector<int> &nums) {\\n        dp = vector<vector<long long>>(nums.size() + 1, vector<long long>(nums.size() + 1, 0));\\n        for (int i = 1; i < nums.size() + 1; ++i) {\\n            dp[i][0] = 1;\\n            dp[i][1] = i;\\n            dp[i][i - 1] = i;\\n            dp[i][i] = 1;\\n        }\\n        for (int i = 2; i < nums.size() + 1; ++i) {\\n            for (int j = 2; j < nums.size() + 1; ++j) {\\n                if (i >= j) dp[i][j] = (dp[i - 1][j - 1] % MOD + dp[i - 1][j] % MOD) % MOD;\\n                else break;\\n            }\\n        }\\n        return solve(nums) - 1;\\n    }\\n};\\n```\\n\\n\\n# Approach : Pascal Triangle\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code 2\\n```\\nclass Solution {\\npublic:\\n    vector < vector < long long > > pascal;\\n    int MOD = 1e9 + 7;\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int N = nums.size();\\n        pascal = vector < vector < long long > > (N + 1);\\n        for (int i = 0; i < N + 1; i ++){\\n            pascal[i] = vector < long long > (i + 1, 1);\\n            for (int j = 1; j < i; j ++){\\n                pascal[i][j] = (pascal[i - 1][j] + pascal[i - 1][j - 1])%MOD;\\n            }\\n        }\\n        return dfs(nums) - 1;\\n    }\\n    \\n    int dfs(vector < int > nums){\\n        if (nums.size() <= 2)\\n            return 1;\\n        vector < int > left, right;\\n        for (int i = 1; i < int(nums.size()); i ++){\\n            if (nums[i] < nums[0])\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }\\n        return (((dfs(left) * pascal[nums.size() - 1][left.size()]) % MOD) * dfs(right))%MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<long long int>> dp;\\n    long long MOD = 1e9 + 7;\\n\\n    unsigned long long solve(vector<int> &nums) {\\n        if (nums.size() <= 1) return 1;\\n        vector<int> l, r;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] > nums[0]) r.push_back(nums[i]);\\n            else l.push_back(nums[i]);\\n        }\\n        int n = l.size(), m = r.size();\\n        return solve(l) * solve(r) % MOD * dp[n + m][n] % MOD;\\n    }\\n\\npublic:\\n    int numOfWays(vector<int> &nums) {\\n        dp = vector<vector<long long>>(nums.size() + 1, vector<long long>(nums.size() + 1, 0));\\n        for (int i = 1; i < nums.size() + 1; ++i) {\\n            dp[i][0] = 1;\\n            dp[i][1] = i;\\n            dp[i][i - 1] = i;\\n            dp[i][i] = 1;\\n        }\\n        for (int i = 2; i < nums.size() + 1; ++i) {\\n            for (int j = 2; j < nums.size() + 1; ++j) {\\n                if (i >= j) dp[i][j] = (dp[i - 1][j - 1] % MOD + dp[i - 1][j] % MOD) % MOD;\\n                else break;\\n            }\\n        }\\n        return solve(nums) - 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector < vector < long long > > pascal;\\n    int MOD = 1e9 + 7;\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int N = nums.size();\\n        pascal = vector < vector < long long > > (N + 1);\\n        for (int i = 0; i < N + 1; i ++){\\n            pascal[i] = vector < long long > (i + 1, 1);\\n            for (int j = 1; j < i; j ++){\\n                pascal[i][j] = (pascal[i - 1][j] + pascal[i - 1][j - 1])%MOD;\\n            }\\n        }\\n        return dfs(nums) - 1;\\n    }\\n    \\n    int dfs(vector < int > nums){\\n        if (nums.size() <= 2)\\n            return 1;\\n        vector < int > left, right;\\n        for (int i = 1; i < int(nums.size()); i ++){\\n            if (nums[i] < nums[0])\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }\\n        return (((dfs(left) * pascal[nums.size() - 1][left.size()]) % MOD) * dfs(right))%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822418,
                "title": "c-dfs-comb",
                "content": "```cpp\\nint dp[1001][1001] = {};\\nint comb(int n, int m) {\\n    return n == 0 || m == 0 ? 1 :\\n        dp[n][m] ? dp[n][m] : \\n            dp[n][m] = (comb(n - 1, m) + comb(n, m - 1)) % 1000000007;\\n}\\nlong dfs(vector<int>& n) {\\n    if (n.size() <= 1)\\n        return 1;\\n    vector<int> n1, n2;\\n    copy_if(begin(n), end(n), back_inserter(n1), [&] (int i) { return i < n.front(); });\\n    copy_if(begin(n), end(n), back_inserter(n2), [&] (int i) { return i > n.front(); });\\n    return dfs(n1) * dfs(n2) % 1000000007 * comb(n1.size(), n2.size()) % 1000000007;\\n}\\nint numOfWays(vector<int>& n) { return dfs(n) - 1; }\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[1001][1001] = {};\\nint comb(int n, int m) {\\n    return n == 0 || m == 0 ? 1 :\\n        dp[n][m] ? dp[n][m] : \\n            dp[n][m] = (comb(n - 1, m) + comb(n, m - 1)) % 1000000007;\\n}\\nlong dfs(vector<int>& n) {\\n    if (n.size() <= 1)\\n        return 1;\\n    vector<int> n1, n2;\\n    copy_if(begin(n), end(n), back_inserter(n1), [&] (int i) { return i < n.front(); });\\n    copy_if(begin(n), end(n), back_inserter(n2), [&] (int i) { return i > n.front(); });\\n    return dfs(n1) * dfs(n2) % 1000000007 * comb(n1.size(), n2.size()) % 1000000007;\\n}\\nint numOfWays(vector<int>& n) { return dfs(n) - 1; }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 819413,
                "title": "didn-t-see-any-java-solution-here-because-nobody-knows-how-to-mod",
                "content": "Sadly me neither\\n```\\nclass Solution {\\n    long mod = (int) 1e9 + 7;\\n    public int numOfWays(int[] nums) {\\n        List<Integer> list = new LinkedList<>();\\n        for(int i:nums){\\n            list.add(i);\\n        }\\n\\n        return (int)(((helper(list)-1)%mod) % mod);\\n    }\\n    \\n    private long helper(List<Integer> list){\\n        if(list.size() == 0 || list.size() == 1) return 1;\\n        \\n        int root = list.get(0);\\n        List<Integer> bigger = new LinkedList<>();\\n        List<Integer> smaller = new LinkedList<>();\\n\\n        for(int i:list){\\n            if(i > root){\\n                bigger.add(i);\\n            }\\n            if(i < root){\\n                smaller.add(i);\\n            }\\n        }\\n        int n = list.size();\\n        int left = smaller.size();\\n        long temp = (fac(n-1) / (fac(left)));\\n        temp = temp/fac(n-1-left);\\n        \\n        return (temp * helper(smaller) * helper(bigger));\\n    }\\n    \\n    private long fac(int n){\\n        long res = 1;\\n        while(n > 1){\\n            res = res * n;\\n            n--;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    long mod = (int) 1e9 + 7;\\n    public int numOfWays(int[] nums) {\\n        List<Integer> list = new LinkedList<>();\\n        for(int i:nums){\\n            list.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3643973,
                "title": "c-recursion-imp-ncr",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>>ncr;\\n    long long mod=1e9+7;\\n    long long ways(vector<int>&v,int n){\\n        if(n<=2)return 1;\\n        vector<int>left,right;\\n        for(int i=1;i<n;i++){\\n            if(v[0]>v[i])left.push_back(v[i]);\\n            else right.push_back(v[i]);\\n        }\\n        long long ans_left=ways(left,left.size());\\n        long long ans_right=ways(right,right.size());\\n\\n        long long ans = (((ncr[n-1][left.size()]*ans_left)%mod)*ans_right)%mod;\\n        return ans;\\n    }\\n    int numOfWays(vector<int>& v) {\\n        int n=v.size();\\n        ncr.resize(n + 1);\\n         for(int i = 0; i < n + 1; ++i){\\n        ncr[i] = vector<long long>(i + 1, 1);\\n        for(int j = 1; j < i; ++j){\\n            ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j]) % mod;\\n            }\\n            }\\n            \\n        return (ways(v,n)-1)%mod;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/eb696ebe-1bf3-432f-84ff-8bea0433995b_1686894294.3087947.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Tree",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>>ncr;\\n    long long mod=1e9+7;\\n    long long ways(vector<int>&v,int n){\\n        if(n<=2)return 1;\\n        vector<int>left,right;\\n        for(int i=1;i<n;i++){\\n            if(v[0]>v[i])left.push_back(v[i]);\\n            else right.push_back(v[i]);\\n        }\\n        long long ans_left=ways(left,left.size());\\n        long long ans_right=ways(right,right.size());\\n\\n        long long ans = (((ncr[n-1][left.size()]*ans_left)%mod)*ans_right)%mod;\\n        return ans;\\n    }\\n    int numOfWays(vector<int>& v) {\\n        int n=v.size();\\n        ncr.resize(n + 1);\\n         for(int i = 0; i < n + 1; ++i){\\n        ncr[i] = vector<long long>(i + 1, 1);\\n        for(int j = 1; j < i; ++j){\\n            ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j]) % mod;\\n            }\\n            }\\n            \\n        return (ways(v,n)-1)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643640,
                "title": "javascript-with-comments-and-explanation-100-100-combination-mathematics",
                "content": "# Approach\\nFind the number of ways to sort a list by replacing two elements at a time in given array\\n```\\nPlease upvote me if you like this solution\\n```\\n\\n# Code\\n```\\n// Main Function\\nvar numOfWays = function(nums) {\\n    return (helper(nums) - 1n) % BigInt(1e9+7) // Return modulo value\\n};\\n\\n// Function return combination (Mathematics) [Formula = n!/( k!*(n-k)!)]\\nvar nCr = (n,r) => {\\n    if(n < 2) return 1n;\\n    n = BigInt(n), r = BigInt(r);\\n    return fact(n) / (fact(n-r) * fact(r));\\n}\\n\\nconst cache = new Map(); // Chache for factorials\\n// Returns factorial of n [Formula = n!]\\nvar fact = (n) => {\\n    if(n < 2) return 1n;\\n    if(cache.has(n)) return cache.get(n);\\n    const res = BigInt(n) * fact(n - 1n);\\n    cache.set(n, res);\\n    return res;\\n}\\n\\nvar helper = (nums) => {\\n    if(nums.length < 3) return 1n;\\n\\n    const left = [], right = []\\n    // Separate lower and higher values than first element in nums\\n    for(let i=1; i<nums.length; ++i) {\\n        if(nums[i] < nums[0]) left.push(nums[i])\\n        if(nums[i] > nums[0]) right.push(nums[i])\\n    }\\n\\n    // Number of possible combinations to get left and right separated\\n    const comb = nCr(nums.length-1, left.length)\\n    return comb * helper(left) * helper(right);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nPlease upvote me if you like this solution\\n```\n```\\n// Main Function\\nvar numOfWays = function(nums) {\\n    return (helper(nums) - 1n) % BigInt(1e9+7) // Return modulo value\\n};\\n\\n// Function return combination (Mathematics) [Formula = n!/( k!*(n-k)!)]\\nvar nCr = (n,r) => {\\n    if(n < 2) return 1n;\\n    n = BigInt(n), r = BigInt(r);\\n    return fact(n) / (fact(n-r) * fact(r));\\n}\\n\\nconst cache = new Map(); // Chache for factorials\\n// Returns factorial of n [Formula = n!]\\nvar fact = (n) => {\\n    if(n < 2) return 1n;\\n    if(cache.has(n)) return cache.get(n);\\n    const res = BigInt(n) * fact(n - 1n);\\n    cache.set(n, res);\\n    return res;\\n}\\n\\nvar helper = (nums) => {\\n    if(nums.length < 3) return 1n;\\n\\n    const left = [], right = []\\n    // Separate lower and higher values than first element in nums\\n    for(let i=1; i<nums.length; ++i) {\\n        if(nums[i] < nums[0]) left.push(nums[i])\\n        if(nums[i] > nums[0]) right.push(nums[i])\\n    }\\n\\n    // Number of possible combinations to get left and right separated\\n    const comb = nCr(nums.length-1, left.length)\\n    return comb * helper(left) * helper(right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1258592,
                "title": "simple-divide-and-conquer-python-solution-with-explanation",
                "content": "Consider example 2 in the problem:\\n\\n![image](https://assets.leetcode.com/users/images/6653ee40-694e-42dd-b7c9-698513924b94_1623134884.6523626.png)\\n\\n```\\nInput: nums = [3,4,5,1,2]\\nOutput: 5\\nExplanation: The following 5 arrays will yield the same BST: \\n[3,1,2,4,5]\\n[3,1,4,2,5]\\n[3,1,4,5,2]\\n[3,4,1,2,5]\\n[3,4,1,5,2]\\n```\\n\\n### Observations\\n1. The first number cannot be rearranged because moving it will change the root of the tree.\\n2. Swapping any numbers between left and right subarrays will yield the same tree.\\n\\n### Key\\nFocus on observation #2:\\n - The left subarray is `[1,2]` (all numbers after the root (`3`) that are smaller than the root)\\n - The right subarray is `[4,5]` (all numbers after the root (`3`) that are larger than the root)\\n\\nHow many ways can we merge these 2 subarrays while keeping the order within each subarray?\\n```\\nL:          1          2\\nR:                                4          5                    => [1,2,4,5]\\n-----------------------------------------------\\nL:          1                     2\\nR:                     4                     5                    => [1,4,2,5]\\n-----------------------------------------------\\nL:                     1          2\\nR:          4                                5                    => [4,1,2,5]\\n-----------------------------------------------\\n...\\n```\\nThe number of ways to \"interleave\" the 2 arrays is `{len(L) + len(R)}    choose    {len(L)}` (or, `{len(L) + len(R)}    choose    {len(R)}`), i.e. `(2+2) choose (2) = 6` ways. (You can think of it as number of ways to put 2 identical items in 4 slots)\\n\\nWe know that (from observation #2) these rearrangements of the numbers after the root (`3`) will yield the same tree.\\nWhat this means is, if we know the numbers of permutations (`numOfWays`) of the left and right subarrays, then we can calculate the overall permutations for the current tree:\\n```\\nchoose(len(left_subarray)*len(right_subarray), len(left_subarray))           # (call this K)\\nX\\nnumOfWays(left_subarray)\\nX\\nnumOfWays(right_subarray)\\n```\\nbecause for each arrangement pair of the left and right subarrays, there are `K` ways to merge them.\\n\\nSo, we can recursively compute the permutations in each subtree/subarray, and then calculate the overall permutations based on the above formula.\\n\\n### Divide and conquer\\n\\n```python\\nimport operator as op\\nfrom functools import reduce\\n\\n\\ndef choose(n, r):\\n    \"\"\"https://stackoverflow.com/a/4941932\\n    \"\"\"\\n    r = min(r, n-r)\\n    numer = reduce(op.mul, range(n, n-r, -1), 1)\\n    denom = reduce(op.mul, range(1, r+1), 1)\\n    return numer // denom\\n\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def divideAndConquer(sublist):\\n            if len(sublist) <= 1:  # base case\\n                return 1\\n            \\n            root = sublist[0]\\n            left = [n for n in sublist if n < root]   # left subarray\\n            right = [n for n in sublist if n > root]  # right subarray\\n            \\n            leftWays = divideAndConquer(left)\\n            rightWays = divideAndConquer(right)\\n            \\n            return choose(len(left)+len(right), len(left)) * leftWays * rightWays\\n        \\n        # minus 1 because the answer needs to exclude the input\\n        return (divideAndConquer(nums) - 1) % 1000000007\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nInput: nums = [3,4,5,1,2]\\nOutput: 5\\nExplanation: The following 5 arrays will yield the same BST: \\n[3,1,2,4,5]\\n[3,1,4,2,5]\\n[3,1,4,5,2]\\n[3,4,1,2,5]\\n[3,4,1,5,2]\\n```\n```\\nL:          1          2\\nR:                                4          5                    => [1,2,4,5]\\n-----------------------------------------------\\nL:          1                     2\\nR:                     4                     5                    => [1,4,2,5]\\n-----------------------------------------------\\nL:                     1          2\\nR:          4                                5                    => [4,1,2,5]\\n-----------------------------------------------\\n...\\n```\n```\\nchoose(len(left_subarray)*len(right_subarray), len(left_subarray))           # (call this K)\\nX\\nnumOfWays(left_subarray)\\nX\\nnumOfWays(right_subarray)\\n```\n```python\\nimport operator as op\\nfrom functools import reduce\\n\\n\\ndef choose(n, r):\\n    \"\"\"https://stackoverflow.com/a/4941932\\n    \"\"\"\\n    r = min(r, n-r)\\n    numer = reduce(op.mul, range(n, n-r, -1), 1)\\n    denom = reduce(op.mul, range(1, r+1), 1)\\n    return numer // denom\\n\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def divideAndConquer(sublist):\\n            if len(sublist) <= 1:  # base case\\n                return 1\\n            \\n            root = sublist[0]\\n            left = [n for n in sublist if n < root]   # left subarray\\n            right = [n for n in sublist if n > root]  # right subarray\\n            \\n            leftWays = divideAndConquer(left)\\n            rightWays = divideAndConquer(right)\\n            \\n            return choose(len(left)+len(right), len(left)) * leftWays * rightWays\\n        \\n        # minus 1 because the answer needs to exclude the input\\n        return (divideAndConquer(nums) - 1) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819448,
                "title": "java-accepted-java-solution",
                "content": "Didn\\'t really enjoy the puzzle, started with long data type and kept MOD\\'ing whenever I can but still overflow. I thought it was my algorithm but switching to BigInteger got it accepted.\\n\\nWell.. I guess it\\'s simply not so java-friendly?\\n\\n**If LeetCode can hear me, I would really suggest we limit test cases below Long.MAX_VALUE. Going beyond that doesn\\'t bring much meanful value IMO.**\\n\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    int MOD = 1000000007;\\n    public int numOfWays(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        List<Integer> list = new ArrayList<>();\\n        for(int num : nums) list.add(num);\\n        return (int)(helper(list).longValue() - 1);\\n    }\\n\\n    private BigInteger helper(List<Integer> nums) {\\n        if(nums.size() <= 2) return BigInteger.ONE;\\n        int root = nums.get(0);\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for(int i=1; i<nums.size(); i++) {\\n            if(nums.get(i) < root) {\\n                left.add(nums.get(i));\\n            } else {\\n                right.add(nums.get(i));\\n            }\\n        }\\n        BigInteger count = combination(nums.size() - 1, left.size());\\n        BigInteger leftCount = helper(left);\\n        BigInteger rightCount = helper(right);\\n        return count.multiply(leftCount).multiply(rightCount).mod(BigInteger.valueOf(MOD));\\n    }\\n\\n    private BigInteger combination(int total, int num) {\\n        num = Math.min(num, total - num);\\n        if(num == 0) return BigInteger.ONE;\\n\\n        BigInteger res = BigInteger.ONE;\\n        int limit = num;\\n        long multi = total;\\n        long did = 1;\\n        for(int i=0; i<limit; i++) {\\n            res = res.multiply(BigInteger.valueOf(multi--));\\n            res = res.divide(BigInteger.valueOf(did++));\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    int MOD = 1000000007;\\n    public int numOfWays(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        List<Integer> list = new ArrayList<>();\\n        for(int num : nums) list.add(num);\\n        return (int)(helper(list).longValue() - 1);\\n    }\\n\\n    private BigInteger helper(List<Integer> nums) {\\n        if(nums.size() <= 2) return BigInteger.ONE;\\n        int root = nums.get(0);\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for(int i=1; i<nums.size(); i++) {\\n            if(nums.get(i) < root) {\\n                left.add(nums.get(i));\\n            } else {\\n                right.add(nums.get(i));\\n            }\\n        }\\n        BigInteger count = combination(nums.size() - 1, left.size());\\n        BigInteger leftCount = helper(left);\\n        BigInteger rightCount = helper(right);\\n        return count.multiply(leftCount).multiply(rightCount).mod(BigInteger.valueOf(MOD));\\n    }\\n\\n    private BigInteger combination(int total, int num) {\\n        num = Math.min(num, total - num);\\n        if(num == 0) return BigInteger.ONE;\\n\\n        BigInteger res = BigInteger.ONE;\\n        int limit = num;\\n        long multi = total;\\n        long did = 1;\\n        for(int i=0; i<limit; i++) {\\n            res = res.multiply(BigInteger.valueOf(multi--));\\n            res = res.divide(BigInteger.valueOf(did++));\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643806,
                "title": "video-solution-java-c-python",
                "content": "\\n\\n\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/N8MDBYhF4dM\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n\\n\\n```\\nclass Solution {\\n    long mod = (long)1e9 + 7;\\n    long[][] table;\\n    public int numOfWays(int[] nums) {\\n        int n = nums.length;\\n        table = new long[n][n];\\n        for (int i = 0; i < n; ++i) {\\n            table[i][0] = table[i][i] = 1;\\n        }\\n        for (int i = 2; i < n; i++) {\\n            for (int j = 1; j < i; j++) {\\n                table[i][j] = (table[i - 1][j - 1] + table[i - 1][j]) % mod;\\n            }\\n        }\\n        List<Integer> arrList = new ArrayList();\\n        for(int i: nums) arrList.add(i);\\n        return (int)((helper(arrList) - 1) % mod);\\n        \\n    }\\n    \\n    public long helper(List<Integer> arr){\\n        int n = arr.size();\\n        if(n<3) return 1;\\n        List<Integer> leftNodes = new ArrayList<>();\\n        List<Integer> rightNodes = new ArrayList<>();\\n        for (int i  = 1; i<n;i++) {\\n            int element = arr.get(i);\\n            if (element < arr.get(0)) {\\n                leftNodes.add(element);\\n            } else {\\n                rightNodes.add(element);\\n            }\\n        }\\n        long leftWays = helper(leftNodes)%mod;\\n        long rightWays = helper(rightNodes) % mod;\\n        return (((leftWays * rightWays) % mod) * table[n - 1][leftNodes.size()]) % mod;\\n    }\\n}\\n```\\n\\n```\\n\\n\\nclass Solution {\\n    long long mod = 1000000007;\\n    std::vector<std::vector<long long>> table;\\n    \\npublic:\\n    int numOfWays(std::vector<int>& nums) {\\n        int n = nums.size();\\n        table.resize(n, std::vector<long long>(n));\\n        \\n        for (int i = 0; i < n; ++i) {\\n            table[i][0] = table[i][i] = 1;\\n        }\\n        \\n        for (int i = 2; i < n; i++) {\\n            for (int j = 1; j < i; j++) {\\n                table[i][j] = (table[i - 1][j - 1] + table[i - 1][j]) % mod;\\n            }\\n        }\\n        \\n        std::vector<int> arrList;\\n        for (int i : nums)\\n            arrList.push_back(i);\\n            \\n        return (int)((helper(arrList) - 1) % mod);\\n    }\\n    \\n    long long helper(std::vector<int>& arr) {\\n        int n = arr.size();\\n        if (n < 3)\\n            return 1;\\n            \\n        std::vector<int> leftNodes;\\n        std::vector<int> rightNodes;\\n        \\n        for (int i = 1; i < n; i++) {\\n            int element = arr[i];\\n            if (element < arr[0]) {\\n                leftNodes.push_back(element);\\n            } else {\\n                rightNodes.push_back(element);\\n            }\\n        }\\n        \\n        long long leftWays = helper(leftNodes) % mod;\\n        long long rightWays = helper(rightNodes) % mod;\\n        \\n        return (((leftWays * rightWays) % mod) * table[n - 1][leftNodes.size()]) % mod;\\n    }\\n};\\n\\n```\\n\\n```\\nclass Solution:\\n    mod = 10**9 + 7\\n    table = []\\n\\n    def numOfWays(self, nums):\\n        n = len(nums)\\n        self.table = [[0] * n for _ in range(n)]\\n\\n        for i in range(n):\\n            self.table[i][0] = self.table[i][i] = 1\\n\\n        for i in range(2, n):\\n            for j in range(1, i):\\n                self.table[i][j] = (self.table[i - 1][j - 1] + self.table[i - 1][j]) % self.mod\\n\\n        arrList = nums\\n        return (self.helper(arrList) - 1) % self.mod\\n\\n    def helper(self, arr):\\n        n = len(arr)\\n        if n < 3:\\n            return 1\\n\\n        leftNodes = []\\n        rightNodes = []\\n        for i in range(1, n):\\n            element = arr[i]\\n            if element < arr[0]:\\n                leftNodes.append(element)\\n            else:\\n                rightNodes.append(element)\\n\\n        leftWays = self.helper(leftNodes) % self.mod\\n        rightWays = self.helper(rightNodes) % self.mod\\n\\n        return (((leftWays * rightWays) % self.mod) * self.table[n - 1][len(leftNodes)]) % self.mod\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    long mod = (long)1e9 + 7;\\n    long[][] table;\\n    public int numOfWays(int[] nums) {\\n        int n = nums.length;\\n        table = new long[n][n];\\n        for (int i = 0; i < n; ++i) {\\n            table[i][0] = table[i][i] = 1;\\n        }\\n        for (int i = 2; i < n; i++) {\\n            for (int j = 1; j < i; j++) {\\n                table[i][j] = (table[i - 1][j - 1] + table[i - 1][j]) % mod;\\n            }\\n        }\\n        List<Integer> arrList = new ArrayList();\\n        for(int i: nums) arrList.add(i);\\n        return (int)((helper(arrList) - 1) % mod);\\n        \\n    }\\n    \\n    public long helper(List<Integer> arr){\\n        int n = arr.size();\\n        if(n<3) return 1;\\n        List<Integer> leftNodes = new ArrayList<>();\\n        List<Integer> rightNodes = new ArrayList<>();\\n        for (int i  = 1; i<n;i++) {\\n            int element = arr.get(i);\\n            if (element < arr.get(0)) {\\n                leftNodes.add(element);\\n            } else {\\n                rightNodes.add(element);\\n            }\\n        }\\n        long leftWays = helper(leftNodes)%mod;\\n        long rightWays = helper(rightNodes) % mod;\\n        return (((leftWays * rightWays) % mod) * table[n - 1][leftNodes.size()]) % mod;\\n    }\\n}\\n```\n```\\n\\n\\nclass Solution {\\n    long long mod = 1000000007;\\n    std::vector<std::vector<long long>> table;\\n    \\npublic:\\n    int numOfWays(std::vector<int>& nums) {\\n        int n = nums.size();\\n        table.resize(n, std::vector<long long>(n));\\n        \\n        for (int i = 0; i < n; ++i) {\\n            table[i][0] = table[i][i] = 1;\\n        }\\n        \\n        for (int i = 2; i < n; i++) {\\n            for (int j = 1; j < i; j++) {\\n                table[i][j] = (table[i - 1][j - 1] + table[i - 1][j]) % mod;\\n            }\\n        }\\n        \\n        std::vector<int> arrList;\\n        for (int i : nums)\\n            arrList.push_back(i);\\n            \\n        return (int)((helper(arrList) - 1) % mod);\\n    }\\n    \\n    long long helper(std::vector<int>& arr) {\\n        int n = arr.size();\\n        if (n < 3)\\n            return 1;\\n            \\n        std::vector<int> leftNodes;\\n        std::vector<int> rightNodes;\\n        \\n        for (int i = 1; i < n; i++) {\\n            int element = arr[i];\\n            if (element < arr[0]) {\\n                leftNodes.push_back(element);\\n            } else {\\n                rightNodes.push_back(element);\\n            }\\n        }\\n        \\n        long long leftWays = helper(leftNodes) % mod;\\n        long long rightWays = helper(rightNodes) % mod;\\n        \\n        return (((leftWays * rightWays) % mod) * table[n - 1][leftNodes.size()]) % mod;\\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    mod = 10**9 + 7\\n    table = []\\n\\n    def numOfWays(self, nums):\\n        n = len(nums)\\n        self.table = [[0] * n for _ in range(n)]\\n\\n        for i in range(n):\\n            self.table[i][0] = self.table[i][i] = 1\\n\\n        for i in range(2, n):\\n            for j in range(1, i):\\n                self.table[i][j] = (self.table[i - 1][j - 1] + self.table[i - 1][j]) % self.mod\\n\\n        arrList = nums\\n        return (self.helper(arrList) - 1) % self.mod\\n\\n    def helper(self, arr):\\n        n = len(arr)\\n        if n < 3:\\n            return 1\\n\\n        leftNodes = []\\n        rightNodes = []\\n        for i in range(1, n):\\n            element = arr[i]\\n            if element < arr[0]:\\n                leftNodes.append(element)\\n            else:\\n                rightNodes.append(element)\\n\\n        leftWays = self.helper(leftNodes) % self.mod\\n        rightWays = self.helper(rightNodes) % self.mod\\n\\n        return (((leftWays * rightWays) % self.mod) * self.table[n - 1][len(leftNodes)]) % self.mod\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827554,
                "title": "java-simple-dfs",
                "content": "1, once root is fixed, find all following nums < root, list<Integer> left, to form left subtree;\\nfind all following nums >root, list<Integer> right, to form left subtree;\\n2, find all combinations, comb, to select left.size() positions for left from all following positions after root, left.size() + right.size().\\n3, result will be comb * dfs(left) * dfs(right);\\n4, to calculate comb, you can either use [combination formula](https://www.mathplanet.com/education/algebra-2/discrete-mathematics-and-probability/permutations-and-combinations#:~:text=The%20number%20of%20combinations%20of,r!), or [Yang Hui Triangle](https://en.wikipedia.org/wiki/Yang_Hui) \\n```\\nclass Solution {\\n    long mod = 1_000_000_007, dp[][];\\n    public int numOfWays(int[] nums) {\\n        dp = getYang(nums.length);\\n        List<Integer> list = new ArrayList<>();      \\n        for (int n : nums) list.add(n);\\n        return (int) (dfs(list) - 1);\\n    }\\n    \\n    private long dfs(List<Integer> l) {\\n        if (l.size() < 3) return 1;\\n        int root = l.get(0);\\n        List<Integer> left = new ArrayList<>(), right = new ArrayList<>();\\n        for (int i = 1; i < l.size(); i++) {\\n            if (l.get(i) < root) left.add(l.get(i));\\n            else right.add(l.get(i));\\n        }\\n        return dp[left.size() + right.size()][left.size()] % mod * dfs(left) % mod * dfs(right) % mod;\\n    }\\n    \\n    private long[][] getYang(int n) {\\n        long[][] res = new long[n + 1][n + 1];\\n        for (int i = 1; i <= n; i++) res[i][0] = res[i][i] = 1;\\n        for (int i = 2; i <= n; i++) \\n            for (int j = 1; j < i; j++) \\n                res[i][j] = (res[i - 1][j] + res[i - 1][j - 1]) % mod; \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long mod = 1_000_000_007, dp[][];\\n    public int numOfWays(int[] nums) {\\n        dp = getYang(nums.length);\\n        List<Integer> list = new ArrayList<>();      \\n        for (int n : nums) list.add(n);\\n        return (int) (dfs(list) - 1);\\n    }\\n    \\n    private long dfs(List<Integer> l) {\\n        if (l.size() < 3) return 1;\\n        int root = l.get(0);\\n        List<Integer> left = new ArrayList<>(), right = new ArrayList<>();\\n        for (int i = 1; i < l.size(); i++) {\\n            if (l.get(i) < root) left.add(l.get(i));\\n            else right.add(l.get(i));\\n        }\\n        return dp[left.size() + right.size()][left.size()] % mod * dfs(left) % mod * dfs(right) % mod;\\n    }\\n    \\n    private long[][] getYang(int n) {\\n        long[][] res = new long[n + 1][n + 1];\\n        for (int i = 1; i <= n; i++) res[i][0] = res[i][i] = 1;\\n        for (int i = 2; i <= n; i++) \\n            for (int j = 1; j < i; j++) \\n                res[i][j] = (res[i - 1][j] + res[i - 1][j - 1]) % mod; \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467240,
                "title": "detailed-explanation-java-simple-recursive-divide-and-conquer-solution",
                "content": "***PLEASE UPVOTE IF THE SOLUTION WAS USEFUL !!***\\n\\n\\nThere are different steps in order to come up with this solution:\\n1.  logic\\n2.  maths formula(permutation and combination)\\n3.  algorithm - divide and conquer\\n4.  optimisation(space) - modular inverse\\n5.  optimisation(time) - moduler exponentiation\\n\\nI will explain the first 3 steps : \\n\\n**Logic**\\nConsider base case for array  ``` 5 1 3 2 4 7 9 8 6```\\n-> 5 would be the root\\n-> ```1 3 2 4 ``` say ```A``` are less than 5 and ```7 9 8 7 ```  say ```B``` are greater than 5\\n-> at this point you can say that  ```A``` will always be to left of ```5``` and ```B``` will always be to the right in the constructed binary tree.\\n->So, relative positions of ```A``` and ```B``` dont matter. (don\\'t mix elements within A and within B yet, we will solve this as a part of sub problems)\\n-> how many ways can you mix in ```A``` and ```B``` so that relative positions within their respective sub arrays remains the same ?\\n\\n**Math Formula**\\n-> size of ```A``` is ```na``` and ```B``` is ```nb``` respectively.\\n-> You can look up for ```Identical objects into distinct bins``` on google and relate it to this question. \\n-> Numbers in ```A``` can be considered as identical since you cannot permute amongst themselves\\n-> There are ```nb + 1```  distinct bins because ```na``` identical nums can be in any of these ```nb+1``` distinct bins. (.ie. say ```B``` is ```1 2 3``` , there are ```4``` places where you can keep other numbers from ```A```)\\n->The formula for such a senario is ```Suppose there are n identical objects to be distributed among r distinct bins. This can be done in precisely (n+r-1) C (r-1) ways.```\\n\\n***Algorithm***\\n\\n--> We have solved only for the case considering the root. Now, all you need to do is figure out how many ways with which ```A``` and ```B``` can be permuted independently and multiply everything.\\n--> ```(na+nb+1-1) C (nb+1-1) * ans for A * ans for B```\\n\\n\\n```\\nclass Solution {\\n    \\n    private static long mod = 1000000007;\\n    private long[] inverse = new long[10001];\\n    \\n    public int numOfWays(int[] nums) {\\n        inverseFunc();\\n        \\n        List<Integer> list =new ArrayList<>();\\n        for(int n : nums){\\n            list.add(n);\\n        }\\n        return (int)((num(list)-1)%mod);\\n    }\\n    \\n    public long num(List<Integer> nums){\\n        \\n        if(nums == null || nums.size() <= 2) return 1;\\n        \\n        \\n        int root = nums.get(0);\\n        List<Integer> lessThan = new ArrayList<>();\\n        List<Integer> greaterThan = new ArrayList<>();\\n        \\n        for(int val : nums){\\n            if(val > root){\\n                greaterThan.add(val);\\n            } else if(val < root){\\n                lessThan.add(val);\\n            }\\n        }\\n        \\n        return ((((comb(lessThan.size() + greaterThan.size(), greaterThan.size()))%mod) * num(lessThan))%mod * num(greaterThan))%mod;\\n    }\\n    \\n    \\n    public long comb(int a, int b){\\n        if(a <= 0 || b <= 0) return 1;\\n        \\n        long ans = 1;\\n        for(int i = 1; i<=b;i++){\\n            ans = (ans * a)%mod;\\n            a--;\\n        }\\n        \\n        while(b>=1){\\n            ans = (ans * inverse[b--])%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\nvoid inverseFunc(){\\n    for(int i = 1; i<= 1000;i++){\\n        inverse[i] = power(i, mod-2, mod)%mod;\\n    }\\n}    \\n    \\n    \\nlong power(long x, long y, long p){\\n    long res = 1;\\n \\n    x = x % p; \\n \\n    if (x == 0)\\n      return 0;\\n \\n    while (y > 0)\\n    {\\n \\n      if ((y & 1) != 0)\\n        res = (res * x) % p;\\n \\n      y = y >> 1;\\n      x = (x * x) % p;\\n    }\\n    return res;\\n  }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "``` 5 1 3 2 4 7 9 8 6```\n```1 3 2 4 ```\n```A```\n```7 9 8 7 ```\n```B```\n```A```\n```5```\n```B```\n```A```\n```B```\n```A```\n```B```\n```A```\n```na```\n```B```\n```nb```\n```Identical objects into distinct bins```\n```A```\n```nb + 1```\n```na```\n```nb+1```\n```B```\n```1 2 3```\n```4```\n```A```\n```Suppose there are n identical objects to be distributed among r distinct bins. This can be done in precisely (n+r-1) C (r-1) ways.```\n```A```\n```B```\n```(na+nb+1-1) C (nb+1-1) * ans for A * ans for B```\n```\\nclass Solution {\\n    \\n    private static long mod = 1000000007;\\n    private long[] inverse = new long[10001];\\n    \\n    public int numOfWays(int[] nums) {\\n        inverseFunc();\\n        \\n        List<Integer> list =new ArrayList<>();\\n        for(int n : nums){\\n            list.add(n);\\n        }\\n        return (int)((num(list)-1)%mod);\\n    }\\n    \\n    public long num(List<Integer> nums){\\n        \\n        if(nums == null || nums.size() <= 2) return 1;\\n        \\n        \\n        int root = nums.get(0);\\n        List<Integer> lessThan = new ArrayList<>();\\n        List<Integer> greaterThan = new ArrayList<>();\\n        \\n        for(int val : nums){\\n            if(val > root){\\n                greaterThan.add(val);\\n            } else if(val < root){\\n                lessThan.add(val);\\n            }\\n        }\\n        \\n        return ((((comb(lessThan.size() + greaterThan.size(), greaterThan.size()))%mod) * num(lessThan))%mod * num(greaterThan))%mod;\\n    }\\n    \\n    \\n    public long comb(int a, int b){\\n        if(a <= 0 || b <= 0) return 1;\\n        \\n        long ans = 1;\\n        for(int i = 1; i<=b;i++){\\n            ans = (ans * a)%mod;\\n            a--;\\n        }\\n        \\n        while(b>=1){\\n            ans = (ans * inverse[b--])%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    \\nvoid inverseFunc(){\\n    for(int i = 1; i<= 1000;i++){\\n        inverse[i] = power(i, mod-2, mod)%mod;\\n    }\\n}    \\n    \\n    \\nlong power(long x, long y, long p){\\n    long res = 1;\\n \\n    x = x % p; \\n \\n    if (x == 0)\\n      return 0;\\n \\n    while (y > 0)\\n    {\\n \\n      if ((y & 1) != 0)\\n        res = (res * x) % p;\\n \\n      y = y >> 1;\\n      x = (x * x) % p;\\n    }\\n    return res;\\n  }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644120,
                "title": "c-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon reviewing the provided code, it appears to be a solution to a problem that involves counting the number of ways to arrange a given sequence of numbers. The solution seems to be using a combination formula and a recursive approach to calculate the desired result.\\n\\nThe code initializes a 2D vector called `comb` with dimensions `(n + 1) \\xD7 (n + 1)`, where `n` is the size of the input vector `nums`. This vector will be used to store the combination values for later calculations.\\n\\nThe outer loop iterates from 1 to `n` and the inner loop iterates from 1 to `i`. It populates the `comb` vector using the formula `(comb[i - 1][j - 1] + comb[i - 1][j]) % 1000000007`. This formula calculates the combination value `C(i, j)` by summing the combination values of the previous row and the previous row with an offset of -1.\\n\\nAfter initializing the `comb` vector, the code defines a lambda function `dfs` that takes a reference to a vector `nums` and returns an integer. This function recursively divides the input vector into two parts, `left` and `right`, based on whether each element is less than or greater than the first element of the vector. It calculates the number of arrangements for each subvector and multiplies them together, considering the combination values from the `comb` vector.\\n\\nFinally, the main function `numOfWays` calls the `dfs` function on the input vector `nums` and subtracts 1 from the result before returning it.\\n\\nOverall, the code aims to count the number of ways to arrange the elements of the `nums` vector according to certain conditions, using a combination formula and a recursive approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The given code is implementing a recursive approach to solve a problem related to counting the number of ways to arrange a sequence of numbers. Let\\'s break down the approach:\\n\\n1. The code initializes a 2D vector called `comb` with dimensions `(n + 1) \\xD7 (n + 1)`, where `n` is the size of the input vector `nums`. This vector will be used to store precalculated combination values.\\n\\n2. The `comb` vector is populated using a combination formula `(comb[i - 1][j - 1] + comb[i - 1][j]) % 1000000007`. This formula calculates the combination value `C(i, j)` by summing the combination values of the previous row and the previous row with an offset of -1.\\n\\n3. The code defines a lambda function called `dfs` that takes a reference to a vector `nums` and returns an integer. This function is responsible for the recursive division of the input vector into two parts, `left` and `right`, based on whether each element is less than or greater than the first element of the vector.\\n\\n4. Within the `dfs` function, the base case is when the size of the input vector `nums` is less than or equal to 2. In this case, the function returns 1, indicating that there is only one possible arrangement.\\n\\n5. If the input vector size is greater than 2, the function proceeds to divide the vector into two subvectors, `left` and `right`, by comparing each element to the first element of the vector. Elements smaller than the first element are added to the `left` subvector, while elements greater than or equal to the first element are added to the `right` subvector.\\n\\n6. The function then calculates the number of arrangements for each subvector by recursively calling itself on the `left` and `right` subvectors. It multiplies these results together.\\n\\n7. Additionally, the function multiplies the result by the combination value `comb[n - 1][left.size()]`, which is obtained from the precalculated `comb` vector. This combination value represents the number of ways to arrange the elements in the subvectors `left` and `right` relative to each other.\\n\\n8. The final result is returned as `(int)res`, where `res` is a long long integer, and it is subtracted by 1 outside the `dfs` function before returning from the `numOfWays` function.\\n\\nThe approach combines the use of combination formulas and recursion to count the number of arrangements based on certain conditions. The recursive division of the vector into subvectors allows for exploring all possible arrangements and calculating the number of ways for each arrangement.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int numOfWays(vector<int>& nums) \\n        {\\n        int n = nums.size();\\n        vector<vector<int>> comb(n + 1, vector<int>(n + 1));\\n        comb[0][0] = 1;\\n        for (int i = 1; i <= n; ++i) \\n        {\\n            comb[i][0] = 1;\\n            for (int j = 1; j <= i; ++j)\\n             {\\n                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % 1000000007;\\n            }\\n        }\\n        function<int(vector<int>&)> dfs = [&](vector<int>& nums)\\n         {\\n            int n = nums.size();\\n            if (n <= 2) return 1;\\n            vector<int> left, right;\\n            for (int i = 1; i < n; ++i) \\n            {\\n                if (nums[i] < nums[0]) left.push_back(nums[i]);\\n                else right.push_back(nums[i]);\\n            }\\n            long long res = comb[n - 1][left.size()];\\n            res = res * dfs(left) % 1000000007;\\n            res = res * dfs(right) % 1000000007;\\n            return (int)res;\\n        };\\n        return dfs(nums) - 1;\\n    }\\n};\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/aa253232-46b2-42c2-8335-fe8118d4eda6_1686897124.426299.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int numOfWays(vector<int>& nums) \\n        {\\n        int n = nums.size();\\n        vector<vector<int>> comb(n + 1, vector<int>(n + 1));\\n        comb[0][0] = 1;\\n        for (int i = 1; i <= n; ++i) \\n        {\\n            comb[i][0] = 1;\\n            for (int j = 1; j <= i; ++j)\\n             {\\n                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % 1000000007;\\n            }\\n        }\\n        function<int(vector<int>&)> dfs = [&](vector<int>& nums)\\n         {\\n            int n = nums.size();\\n            if (n <= 2) return 1;\\n            vector<int> left, right;\\n            for (int i = 1; i < n; ++i) \\n            {\\n                if (nums[i] < nums[0]) left.push_back(nums[i]);\\n                else right.push_back(nums[i]);\\n            }\\n            long long res = comb[n - 1][left.size()];\\n            res = res * dfs(left) % 1000000007;\\n            res = res * dfs(right) % 1000000007;\\n            return (int)res;\\n        };\\n        return dfs(nums) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819920,
                "title": "combination-formula-c-m-n-c-m-1-n-c-m-1-n-1-pre-compute",
                "content": "C(m,n) = C(m-1,n) + C(m-1,n-1)\\nC(m,n) represents the formula for combinations.\\n\\n```\\npublic class Solution\\n{\\n    long mod = (long)Math.Pow(10, 9) + 7;\\n    public int NumOfWays(int[] nums)\\n    {\\n        int n = nums.Length;\\n        long[,] dp = new long[n, n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            dp[i, 0] = 1;\\n            for (int j = 1; j <= i; j++)\\n            {\\n                dp[i, j] = (dp[i - 1, j - 1] + dp[i - 1, j]) % mod;\\n            }\\n        }\\n        return (int)Helper(nums, dp) - 1;\\n    }\\n\\n    private long Helper(IList<int> nums, long[,] dp)\\n    {\\n        if (nums.Count < 2) return 1;\\n        var left = nums.Where(x => x < nums[0]).ToList();\\n        var right = nums.Where(x => x > nums[0]).ToList();\\n\\n        long res = dp[nums.Count - 1, left.Count] % mod;\\n        res = res * Helper(left, dp) % mod;\\n        res = res * Helper(right, dp) % mod;\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    long mod = (long)Math.Pow(10, 9) + 7;\\n    public int NumOfWays(int[] nums)\\n    {\\n        int n = nums.Length;\\n        long[,] dp = new long[n, n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            dp[i, 0] = 1;\\n            for (int j = 1; j <= i; j++)\\n            {\\n                dp[i, j] = (dp[i - 1, j - 1] + dp[i - 1, j]) % mod;\\n            }\\n        }\\n        return (int)Helper(nums, dp) - 1;\\n    }\\n\\n    private long Helper(IList<int> nums, long[,] dp)\\n    {\\n        if (nums.Count < 2) return 1;\\n        var left = nums.Where(x => x < nums[0]).ToList();\\n        var right = nums.Where(x => x > nums[0]).ToList();\\n\\n        long res = dp[nums.Count - 1, left.Count] % mod;\\n        res = res * Helper(left, dp) % mod;\\n        res = res * Helper(right, dp) % mod;\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644831,
                "title": "simple-python-solution-o-n-2",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def numOfWays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        self.ans = 1\\n        mod = 1000000007\\n        class BST:\\n            self.right = None\\n            self.left = None\\n            self.val = None\\n            self.below_count = None\\n            self.cont_ans = None\\n\\n            def __init__(self,left=None,right=None,val=None):\\n                self.right = right\\n                self.left = left\\n                self.val = val\\n\\n        def insert(root,val):\\n            if root.val == None:\\n                root.val = val\\n                return\\n            if val < root.val:\\n                if root.left == None:\\n                    root.left = BST(val=val)\\n                else:\\n                    insert(root.left,val)\\n            else:\\n                if root.right == None:\\n                    root.right = BST(val=val)\\n                else:\\n                    insert(root.right,val)\\n\\n        def bel_count(root):\\n            if root is None:\\n                return 0\\n            root.below_count = 1\\n            root.below_count += bel_count(root.left)\\n            root.below_count += bel_count(root.right)\\n            return root.below_count\\n\\n        def iot(root):\\n            if root is None:\\n                return\\n            iot(root.left)\\n            self.ans = (self.ans*root.cont_ans)%mod\\n            iot(root.right)\\n\\n\\n        def nck(n,k):\\n            if n<=0 or k<=0 or k>=n:\\n                return 1\\n            return factorial(n)/(factorial(k)*(factorial(n-k)))\\n\\n\\n        def get_ans(root,remain):\\n            if root is None:\\n                return\\n            root.cont_ans = 1\\n            root.cont_ans *= nck(remain,root.below_count)%mod\\n            root.cont_ans = root.cont_ans%mod\\n            get_ans(root.left,root.below_count-1)\\n            remain1 = root.below_count-1\\n            if root.left is not None:\\n                remain1 = remain1 - root.left.below_count\\n            get_ans(root.right,remain1)\\n\\n        root = BST()\\n        for num in nums:\\n            insert(root,num)\\n        bel_count(root)\\n        get_ans(root,len(nums))\\n        iot(root)\\n\\n        return self.ans-1\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution(object):\\n    def numOfWays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        self.ans = 1\\n        mod = 1000000007\\n        class BST:\\n            self.right = None\\n            self.left = None\\n            self.val = None\\n            self.below_count = None\\n            self.cont_ans = None\\n\\n            def __init__(self,left=None,right=None,val=None):\\n                self.right = right\\n                self.left = left\\n                self.val = val\\n\\n        def insert(root,val):\\n            if root.val == None:\\n                root.val = val\\n                return\\n            if val < root.val:\\n                if root.left == None:\\n                    root.left = BST(val=val)\\n                else:\\n                    insert(root.left,val)\\n            else:\\n                if root.right == None:\\n                    root.right = BST(val=val)\\n                else:\\n                    insert(root.right,val)\\n\\n        def bel_count(root):\\n            if root is None:\\n                return 0\\n            root.below_count = 1\\n            root.below_count += bel_count(root.left)\\n            root.below_count += bel_count(root.right)\\n            return root.below_count\\n\\n        def iot(root):\\n            if root is None:\\n                return\\n            iot(root.left)\\n            self.ans = (self.ans*root.cont_ans)%mod\\n            iot(root.right)\\n\\n\\n        def nck(n,k):\\n            if n<=0 or k<=0 or k>=n:\\n                return 1\\n            return factorial(n)/(factorial(k)*(factorial(n-k)))\\n\\n\\n        def get_ans(root,remain):\\n            if root is None:\\n                return\\n            root.cont_ans = 1\\n            root.cont_ans *= nck(remain,root.below_count)%mod\\n            root.cont_ans = root.cont_ans%mod\\n            get_ans(root.left,root.below_count-1)\\n            remain1 = root.below_count-1\\n            if root.left is not None:\\n                remain1 = remain1 - root.left.below_count\\n            get_ans(root.right,remain1)\\n\\n        root = BST()\\n        for num in nums:\\n            insert(root,num)\\n        bel_count(root)\\n        get_ans(root,len(nums))\\n        iot(root)\\n\\n        return self.ans-1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831319,
                "title": "c-explanation-for-1569",
                "content": "How does this work? Explaining it so that it might help some folks.\\n\\n```\\nCase I: Consider a BST: [4,2,1,3,5] \\n         4                     [ level 0 ]\\n    2         5                [ level 1 ]\\n 1     3 \\nWe get these valid ways at level 0:\\n  [4,2,1,3,5] \\n  [4,2,1,5,3]\\n  [4,2,5,1,3]\\n  [4,5,2,1,3]\\n  \\n  [4,2,3,1,5]\\n  [4,2,3,5,1]\\n  [4,2,5,3,1]\\n  [4,5,2,3,1]\\n  \\nThe root, 4, stays fixed.\\n\\nCase II: If we look at the left subtree, [2,1,3] at level 1:\\n      2\\n  1      3 \\n... has the following valid ways:\\n  [2,1,3]\\n  [2,3,1]\\n\\nThe root, 2, stays fixed.\\n\\nCase III. Right subtree, [5] at level 1 has no children.\\n     5\\n... has the following valid ways:\\n   [5]\\n```\\nClearly, Case I is dependent on case II and III.\\n\\nAt the crux of this problem is a fundamental math problem of merging two sequences to generate a number of new sequences where the order of the two sequences are not disturbed. This explains the problem: https://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences/ - the formula to use is *nCr* where n is the number of all elements in the two sequences and r is the number of elements in the first sequence.\\n\\n```\\nMapping it to our problem (Case II), given the ordered sequences [1] and [3] how many ways to create a valid sequence \\n(without disturbing the order of the first and second sequence):\\n  [1, 3]\\n  [3, 1]\\n\\nn = 2, r = 1, 2C1 = 2          <--- x (i.e n = number of left and right subtree nodes, r = number of left subtree nodes)\\n\\nIn Case III, there are no children.\\nn = 0, r = 0, 0C0 = 1          <--- y (i.e n = number of left and right subtree nodes, r = number of left subtree nodes)\\n\\nMapping it to Case I, given the ordered sequences [2,1,3] and [5] how many ways to create a valid sequence \\n(without disturbing the order of the first and second sequence):\\n  [2,1,3,5] \\n  [2,1,5,3]\\n  [2,5,1,3]\\n  [5,2,1,3]\\n\\nn = 4, r = 3. 4C3 = 4           <--- z (i.e n = number of left and right subtree nodes, r = number of left subtree nodes)\\n\\n... and given the ordered sequences [2,3,1] and [5]:\\n  [2,3,1,5]\\n  [2,3,5,1]\\n  [2,5,3,1]\\n  [5,2,3,1]\\n\\nn = 4, r = 3. 4C3 = 4\\n```\\nAs can be observed, the total number of valid sequences at any node can be derived by multiplying the sequences computed at itself and its children subtrees. At the root of the tree in Case I, this is simply x * y * z = 8. This is reflected in the recursion:\\n```\\n        return c * DFS(l) % M * DFS(r) % M;\\n```\\nThe code follows:\\n```\\nclass Solution {\\npublic:\\n    /*\\n     * Formula for nCr = n! / r! * (n - r)!\\n     * We will use Pascal\\'s triangle\\n     */\\n    int M = 1000000007; /* calculations bounded by this */\\n    long l[1001][1001] = { 0 }; bool init = false;\\n\\n    long combination(int n, int r) {\\n        if (init/*ialized*/ == true) return l[n][r];\\n        l[0][0] = 1;        /* We know 0C0 = 1, otherwise l[0] row is all 0s */\\n        for (int i = 1; i < 1001; i++) {\\n            l[i][0] = 1;    /* Set every nCr = 1 where r = 0 */\\n            /* Set value for the current cell of Pascal\\'s triangle i.e iC{1 ... i} */\\n            for (int j = 1; j < i + 1; j++) {    \\n                l[i][j] = (l[i - 1][j - 1] + l[i - 1][j]) % M; \\n            } \\n        }\\n        init = true;\\n        return l[n][r];\\n    }\\n\\n    long DFS(vector<int>& nums)\\n    {\\n        if (nums.size() < 3) return 1; /* 1C1, 1C0, 0C0 */\\n        vector<int> l, r;\\n        /* Separate into left subtree sequence and right subtree sequence of nodes */\\n        for (auto e : nums) { if (e > nums[0]) l.push_back(e); if (e < nums[0]) r.push_back(e); }\\n        /* Use nCr formula for merging sequences */\\n        long c = combination(l.size() + r.size(), l.size());\\n        /* Recur down */\\n        return c * DFS(l) % M * DFS(r) % M;\\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        return (int)DFS(nums) - 1 /* one sequence already given in nums */;\\n    }\\n};\\n```\\nPS: I initially wanted to use:\\n```\\n    /* Factorial */\\n    long factorial(long n) { return (n == 1 || n == 0) ? 1 : (n * factorial(n - 1)); }\\n    \\n    long combination1(int n, int r) {\\n        if (l[n][r]) return l[n][r];\\n        /* Formula for nCr = n! / r! * (n - r)! */\\n        l[n][r] = factorial(n) / (factorial(r) * factorial(n - r));    /* memoize */\\n        return l[n][r];\\n    }\\n```\\nThis works up to certain test cases and breaks because of no mod in it. Adding a mod in factorial() does not give the correct answer. So, it looks like this problem only works if the Pascal\\'s triangle method is used and mod is done during addition and not at multiplication.",
                "solutionTags": [],
                "code": "```\\nCase I: Consider a BST: [4,2,1,3,5] \\n         4                     [ level 0 ]\\n    2         5                [ level 1 ]\\n 1     3 \\nWe get these valid ways at level 0:\\n  [4,2,1,3,5] \\n  [4,2,1,5,3]\\n  [4,2,5,1,3]\\n  [4,5,2,1,3]\\n  \\n  [4,2,3,1,5]\\n  [4,2,3,5,1]\\n  [4,2,5,3,1]\\n  [4,5,2,3,1]\\n  \\nThe root, 4, stays fixed.\\n\\nCase II: If we look at the left subtree, [2,1,3] at level 1:\\n      2\\n  1      3 \\n... has the following valid ways:\\n  [2,1,3]\\n  [2,3,1]\\n\\nThe root, 2, stays fixed.\\n\\nCase III. Right subtree, [5] at level 1 has no children.\\n     5\\n... has the following valid ways:\\n   [5]\\n```\n```\\nMapping it to our problem (Case II), given the ordered sequences [1] and [3] how many ways to create a valid sequence \\n(without disturbing the order of the first and second sequence):\\n  [1, 3]\\n  [3, 1]\\n\\nn = 2, r = 1, 2C1 = 2          <--- x (i.e n = number of left and right subtree nodes, r = number of left subtree nodes)\\n\\nIn Case III, there are no children.\\nn = 0, r = 0, 0C0 = 1          <--- y (i.e n = number of left and right subtree nodes, r = number of left subtree nodes)\\n\\nMapping it to Case I, given the ordered sequences [2,1,3] and [5] how many ways to create a valid sequence \\n(without disturbing the order of the first and second sequence):\\n  [2,1,3,5] \\n  [2,1,5,3]\\n  [2,5,1,3]\\n  [5,2,1,3]\\n\\nn = 4, r = 3. 4C3 = 4           <--- z (i.e n = number of left and right subtree nodes, r = number of left subtree nodes)\\n\\n... and given the ordered sequences [2,3,1] and [5]:\\n  [2,3,1,5]\\n  [2,3,5,1]\\n  [2,5,3,1]\\n  [5,2,3,1]\\n\\nn = 4, r = 3. 4C3 = 4\\n```\n```\\n        return c * DFS(l) % M * DFS(r) % M;\\n```\n```\\nclass Solution {\\npublic:\\n    /*\\n     * Formula for nCr = n! / r! * (n - r)!\\n     * We will use Pascal\\'s triangle\\n     */\\n    int M = 1000000007; /* calculations bounded by this */\\n    long l[1001][1001] = { 0 }; bool init = false;\\n\\n    long combination(int n, int r) {\\n        if (init/*ialized*/ == true) return l[n][r];\\n        l[0][0] = 1;        /* We know 0C0 = 1, otherwise l[0] row is all 0s */\\n        for (int i = 1; i < 1001; i++) {\\n            l[i][0] = 1;    /* Set every nCr = 1 where r = 0 */\\n            /* Set value for the current cell of Pascal\\'s triangle i.e iC{1 ... i} */\\n            for (int j = 1; j < i + 1; j++) {    \\n                l[i][j] = (l[i - 1][j - 1] + l[i - 1][j]) % M; \\n            } \\n        }\\n        init = true;\\n        return l[n][r];\\n    }\\n\\n    long DFS(vector<int>& nums)\\n    {\\n        if (nums.size() < 3) return 1; /* 1C1, 1C0, 0C0 */\\n        vector<int> l, r;\\n        /* Separate into left subtree sequence and right subtree sequence of nodes */\\n        for (auto e : nums) { if (e > nums[0]) l.push_back(e); if (e < nums[0]) r.push_back(e); }\\n        /* Use nCr formula for merging sequences */\\n        long c = combination(l.size() + r.size(), l.size());\\n        /* Recur down */\\n        return c * DFS(l) % M * DFS(r) % M;\\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        return (int)DFS(nums) - 1 /* one sequence already given in nums */;\\n    }\\n};\\n```\n```\\n    /* Factorial */\\n    long factorial(long n) { return (n == 1 || n == 0) ? 1 : (n * factorial(n - 1)); }\\n    \\n    long combination1(int n, int r) {\\n        if (l[n][r]) return l[n][r];\\n        /* Formula for nCr = n! / r! * (n - r)! */\\n        l[n][r] = factorial(n) / (factorial(r) * factorial(n - r));    /* memoize */\\n        return l[n][r];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819327,
                "title": "number-of-ways-to-reorder-array-to-get-same-bst-c-recursive",
                "content": "The problem could be solved using recusion as the problem could be broken down into smaller overlapping subproblems.\\n\\nThe first node would always be the root node so it can\\'t be rearranged to any other place. For the rest of the nodes the nodes smaller than the root node would have the same ordering and the nodes larger than the root node would also have the same ordering in the final array but the nodes could be rearranged between the larger nodes and smaller nodes.\\n\\n\\n\\nThe problem then simply becomes to find in how many ways can we c(elements smaller than root) numbers in n-1(total available places after removing the roor) places which could be calculated using nCr.\\n```\\nFor [3,4,5,1,2], in all arrays 3 would always stay at nums[0] as it has to be the root node\\nNow, in all arrays [1,2] and [4,5] needs to be in same order as changing the order would result in change in the corresponding subtree.\\n\\nBut the two arrays [1,2] and [4,5] could be arranged among themselves.\\nThat would simply mean we have to find 2 places for [1,2] out of the 4 availble places which means the answer would be 4C2.\\n\\nThen we need to recusively find the answer for [1,2] and [4,5]\\n\\n```\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9+7;\\n    vector<long long> fact;\\n    void calcFact()\\n    {\\n        fact[0]=1;\\n        fact[1]=1;\\n        for(long long i=2;i<1001;i++)\\n            fact[i]=(fact[i-1]*i)%mod;\\n    }\\n    \\n    long long modInv(long long n,long long p)\\n    {\\n        if(p==0)\\n            return 1LL;\\n        long long ans=modInv(n,p/2);\\n        if(p&1)\\n            return (((ans*ans)%mod)*n)%mod;\\n        else\\n            return (ans*ans)%mod;\\n    }\\n    \\n    long long helper(vector<int> &nums)\\n    {\\n        if(nums.size()<=2)  // if the length of array is less than equal to 2 there is only 1 way to arrange it\\n            return 1LL;\\n        vector<int> small,large;  // store elements smaller and larger than the root node\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]>nums[0])\\n                large.push_back(nums[i]);\\n            else small.push_back(nums[i]);\\n        }\\n        long long ans=1;\\n        ans=(ans*fact[(int)nums.size()-1])%mod;\\n        ans=(ans*modInv(fact[(int)nums.size()-(int)small.size()-1],mod-2))%mod;  // if m is prime, modular inverse is simply pow(n,m-2)\\n        ans=(ans*modInv(fact[(int)small.size()],mod-2))%mod;  // find nCr\\n        ans=(ans*helper(small))%mod;  //recursively solve for smaller array \\n        ans=(ans*helper(large))%mod;  //recursively solve for smaller array\\n        return ans;\\n    }\\n    \\n    \\n    int numOfWays(vector<int>& nums) {\\n        fact=vector<long long> (1001);\\n        calcFact(); // maintain a factorial array to find nCr\\n        long long ans= helper(nums);\\n        ans--;  // subtract 1 for the original array\\n        ans=(ans+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nFor [3,4,5,1,2], in all arrays 3 would always stay at nums[0] as it has to be the root node\\nNow, in all arrays [1,2] and [4,5] needs to be in same order as changing the order would result in change in the corresponding subtree.\\n\\nBut the two arrays [1,2] and [4,5] could be arranged among themselves.\\nThat would simply mean we have to find 2 places for [1,2] out of the 4 availble places which means the answer would be 4C2.\\n\\nThen we need to recusively find the answer for [1,2] and [4,5]\\n\\n```\n```\\nclass Solution {\\npublic:\\n    const long long mod = 1e9+7;\\n    vector<long long> fact;\\n    void calcFact()\\n    {\\n        fact[0]=1;\\n        fact[1]=1;\\n        for(long long i=2;i<1001;i++)\\n            fact[i]=(fact[i-1]*i)%mod;\\n    }\\n    \\n    long long modInv(long long n,long long p)\\n    {\\n        if(p==0)\\n            return 1LL;\\n        long long ans=modInv(n,p/2);\\n        if(p&1)\\n            return (((ans*ans)%mod)*n)%mod;\\n        else\\n            return (ans*ans)%mod;\\n    }\\n    \\n    long long helper(vector<int> &nums)\\n    {\\n        if(nums.size()<=2)  // if the length of array is less than equal to 2 there is only 1 way to arrange it\\n            return 1LL;\\n        vector<int> small,large;  // store elements smaller and larger than the root node\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]>nums[0])\\n                large.push_back(nums[i]);\\n            else small.push_back(nums[i]);\\n        }\\n        long long ans=1;\\n        ans=(ans*fact[(int)nums.size()-1])%mod;\\n        ans=(ans*modInv(fact[(int)nums.size()-(int)small.size()-1],mod-2))%mod;  // if m is prime, modular inverse is simply pow(n,m-2)\\n        ans=(ans*modInv(fact[(int)small.size()],mod-2))%mod;  // find nCr\\n        ans=(ans*helper(small))%mod;  //recursively solve for smaller array \\n        ans=(ans*helper(large))%mod;  //recursively solve for smaller array\\n        return ans;\\n    }\\n    \\n    \\n    int numOfWays(vector<int>& nums) {\\n        fact=vector<long long> (1001);\\n        calcFact(); // maintain a factorial array to find nCr\\n        long long ans= helper(nums);\\n        ans--;  // subtract 1 for the original array\\n        ans=(ans+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645703,
                "title": "approach-explained-with-observation-easy-to-understand",
                "content": "# Intuition\\n```\\nDifferent permutation that yield same bst as given \\n        OBSERVATION :- \\n        [1] ROOT IS SAME \\n        [2] NOW, COMES LEFT AND RIGHT PART \\n        [3] RELATIVE POSITION IS FIXED OF LEFT AND RIGHT PART\\n        [4] COUNT NO OF PERMUTATION \\n        [5] LEFT N-1 PLACE TO BE FILLED \\n        [6] LET NO. OF ELEMENT IN RIGHT or LEFT BE X THAN n-1Cx -1  COMBINATION POSSIBLE\\n            ALSO NEED TO TAKE IN COUNT LEFT AND RIGHT SUBTREE COMBINATION FURTHER\\n        [7] -1 BECAUSE GIVEN BST ALSO COUNTED IN VALID \\n        [8] EVERY SUBTREE CAN BE CONSIDERED INDIVIDUALLY AND COMBINATION FOR IT \\n            CAN BE FOUND RECURSIVELY\\n        [9] PRECOMPUTE COMBINATION LOGIC EFFECTIVELY USING PASCAL TRIANGLE LOGIC\\n    \\n```\\n# Approach\\n``` \\nRECURSION + DP + MATHS\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(N^2)[RECURSION]+O(N^2) [PASCAL]$$ \\n\\n- Space complexity:\\n$$O(N^2)$$ \\n\\n# Code\\n```\\nconst int mod = 1e9+7;\\nclass Solution {\\npublic:\\n   void PascalTriangle(int n,vector<vector<int>>&dp){\\n       for(int i=0;i<=n;i++){\\n          dp[i] =  vector<int>(i+1,1); //initially all 1 \\n          //Now Apply combination logic of adding prev_row and prev_col \\n          for(int j=1;j<i;j++){\\n              dp[i][j] = (dp[i-1][j-1] + dp[i-1][j])%mod;\\n          }\\n       }\\n   }\\n    int dfs(vector<int>&nums,vector<vector<int>>&dp){\\n        vector<int>leftSubTree , rightSubTree ; \\n         int n = nums.size() ; \\n\\n        //1 COMBINATION OF BST POSSIBLE\\n        if(n<3)  return 1;\\n\\n        //FIND LEFT AND RIGHT SUBTREE FOR ROOT I.E nums[0] \\n        for(int i=1;i<n;i++){\\n            if(nums[i]>=nums[0]) rightSubTree.push_back(nums[i]);\\n            if(nums[i]<nums[0]) leftSubTree.push_back(nums[i]);\\n        } \\n\\n        int left = dfs(leftSubTree,dp)%mod ; \\n        int right = dfs(rightSubTree,dp)%mod ; \\n        int ele_atLeft = leftSubTree.size() ; \\n\\n        // n-1Cele_atLeft * left * right \\n         return (1ll * (1ll * dp[n-1][ele_atLeft]*1ll * left)%mod * right)%mod ; \\n    }\\n    int numOfWays(vector<int>& nums) {\\n        // Different permutation that yield same bst as given \\n        //T.C -> O(N^2)[RECURSION]+O(N^2) [PASCAL]\\n        //S.C -> O(N^2)[D.P]\\n        int n = nums.size() ; \\n        vector<vector<int>>dp(n+1) ; \\n        PascalTriangle(n,dp);\\n        int ways = dfs(nums,dp)-1; // -1 BECAUSE GIVEN BST ALSO COUNTED IN VALID \\n        return ways;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nDifferent permutation that yield same bst as given \\n        OBSERVATION :- \\n        [1] ROOT IS SAME \\n        [2] NOW, COMES LEFT AND RIGHT PART \\n        [3] RELATIVE POSITION IS FIXED OF LEFT AND RIGHT PART\\n        [4] COUNT NO OF PERMUTATION \\n        [5] LEFT N-1 PLACE TO BE FILLED \\n        [6] LET NO. OF ELEMENT IN RIGHT or LEFT BE X THAN n-1Cx -1  COMBINATION POSSIBLE\\n            ALSO NEED TO TAKE IN COUNT LEFT AND RIGHT SUBTREE COMBINATION FURTHER\\n        [7] -1 BECAUSE GIVEN BST ALSO COUNTED IN VALID \\n        [8] EVERY SUBTREE CAN BE CONSIDERED INDIVIDUALLY AND COMBINATION FOR IT \\n            CAN BE FOUND RECURSIVELY\\n        [9] PRECOMPUTE COMBINATION LOGIC EFFECTIVELY USING PASCAL TRIANGLE LOGIC\\n    \\n```\n``` \\nRECURSION + DP + MATHS\\n```\n```\\nconst int mod = 1e9+7;\\nclass Solution {\\npublic:\\n   void PascalTriangle(int n,vector<vector<int>>&dp){\\n       for(int i=0;i<=n;i++){\\n          dp[i] =  vector<int>(i+1,1); //initially all 1 \\n          //Now Apply combination logic of adding prev_row and prev_col \\n          for(int j=1;j<i;j++){\\n              dp[i][j] = (dp[i-1][j-1] + dp[i-1][j])%mod;\\n          }\\n       }\\n   }\\n    int dfs(vector<int>&nums,vector<vector<int>>&dp){\\n        vector<int>leftSubTree , rightSubTree ; \\n         int n = nums.size() ; \\n\\n        //1 COMBINATION OF BST POSSIBLE\\n        if(n<3)  return 1;\\n\\n        //FIND LEFT AND RIGHT SUBTREE FOR ROOT I.E nums[0] \\n        for(int i=1;i<n;i++){\\n            if(nums[i]>=nums[0]) rightSubTree.push_back(nums[i]);\\n            if(nums[i]<nums[0]) leftSubTree.push_back(nums[i]);\\n        } \\n\\n        int left = dfs(leftSubTree,dp)%mod ; \\n        int right = dfs(rightSubTree,dp)%mod ; \\n        int ele_atLeft = leftSubTree.size() ; \\n\\n        // n-1Cele_atLeft * left * right \\n         return (1ll * (1ll * dp[n-1][ele_atLeft]*1ll * left)%mod * right)%mod ; \\n    }\\n    int numOfWays(vector<int>& nums) {\\n        // Different permutation that yield same bst as given \\n        //T.C -> O(N^2)[RECURSION]+O(N^2) [PASCAL]\\n        //S.C -> O(N^2)[D.P]\\n        int n = nums.size() ; \\n        vector<vector<int>>dp(n+1) ; \\n        PascalTriangle(n,dp);\\n        int ways = dfs(nums,dp)-1; // -1 BECAUSE GIVEN BST ALSO COUNTED IN VALID \\n        return ways;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644347,
                "title": "python-3-9-lines-recursion-t-m-95-80",
                "content": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n\\n        def dp(nums: List[int]) -> int:\\n\\n            n = len(nums)\\n            if n < 3: return 1\\n            root, left, right = nums[0], [], []\\n\\n            for x in nums:\\n                if   x < root: left .append(x)\\n                elif x > root: right.append(x)\\n\\n            return dp(left) * dp(right) * comb(n-1, len(left))\\n\\n        return (dp(nums)-1) %1000000007\\n```\\n[https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/submissions/972434217/](http://)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n\\n        def dp(nums: List[int]) -> int:\\n\\n            n = len(nums)\\n            if n < 3: return 1\\n            root, left, right = nums[0], [], []\\n\\n            for x in nums:\\n                if   x < root: left .append(x)\\n                elif x > root: right.append(x)\\n\\n            return dp(left) * dp(right) * comb(n-1, len(left))\\n\\n        return (dp(nums)-1) %1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643477,
                "title": "dp-recursion-using-python-layman-s-code",
                "content": "**An upvote would be appreciating...**\\n--\\n# Intuition\\nThe problem asks us to find the number of ways to reorder an array in order to obtain the same binary search tree (BST) structure. We can approach this problem by counting the number of valid BSTs that can be formed from the given array.\\n\\n# Approach\\nTo solve this problem, we can use a recursive approach. We define a helper function `countBST` that takes an array of numbers as input and returns the count of valid BSTs that can be formed from that array. The base case occurs when the array has two or fewer elements, in which case there is only one valid BST.\\n\\nIn the recursive case, we choose the first element of the array as the root of the BST. We partition the remaining elements into two subarrays: one containing elements smaller than the root and the other containing elements greater than the root. We then recursively count the number of valid BSTs that can be formed from each subarray and multiply them together. Finally, we multiply this count by the number of combinations of choosing positions for the smaller and larger elements in the array.\\n\\nTo calculate the number of combinations, we define two helper functions: `fact` and `combs`. The `fact` function calculates the factorial of a given number modulo `10^9 + 7`. The `combs` function calculates the combination of choosing `r` elements from `n` elements using the factorial function and modular arithmetic.\\n\\nFinally, we subtract 1 from the total count of BSTs since we are not considering the original ordering of the array.\\n\\n# Complexity\\n- Time complexity: O(n^2), where n is the number of elements in the input array. This is because for each recursive call, we partition the array into two subarrays, resulting in a total of n recursive calls.\\n- Space complexity: O(n), where n is the number of elements in the input array. This is because we use recursion, which consumes memory on the call stack proportional to the depth of the recursion.\\n\\nHere is my code:\\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        m = (10**9) + 7\\n\\n        def fact(n):\\n            r = 1\\n            for i in range(1, n+1):\\n                r = (r * i) % m\\n            return r\\n\\n        def combs(n, r):\\n            nr = fact(n)\\n            dr = (fact(r) * fact(n - r)) % m\\n            return (nr * pow(dr, m - 2, m)) % m\\n\\n        def countBST(nums):\\n            if len(nums) <= 2:\\n                return 1\\n\\n            left_nums = [n for n in nums if n < nums[0]]\\n            right_nums = [n for n in nums if n > nums[0]]\\n\\n            left_count = countBST(left_nums)\\n            right_count = countBST(right_nums)\\n\\n            return (combs(len(nums) - 1, len(left_nums)) * left_count * right_count) % m\\n\\n        return (countBST(nums) - 1) % m\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        m = (10**9) + 7\\n\\n        def fact(n):\\n            r = 1\\n            for i in range(1, n+1):\\n                r = (r * i) % m\\n            return r\\n\\n        def combs(n, r):\\n            nr = fact(n)\\n            dr = (fact(r) * fact(n - r)) % m\\n            return (nr * pow(dr, m - 2, m)) % m\\n\\n        def countBST(nums):\\n            if len(nums) <= 2:\\n                return 1\\n\\n            left_nums = [n for n in nums if n < nums[0]]\\n            right_nums = [n for n in nums if n > nums[0]]\\n\\n            left_count = countBST(left_nums)\\n            right_count = countBST(right_nums)\\n\\n            return (combs(len(nums) - 1, len(left_nums)) * left_count * right_count) % m\\n\\n        return (countBST(nums) - 1) % m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643370,
                "title": "best-solution",
                "content": "# Approach\\nThe approach used in the code involves a depth-first search (DFS) algorithm. The dfs function takes three parameters: i represents the current index, l represents the lower bound, and h represents the upper bound.\\n\\nThe function checks if the upper bound h is one greater than the lower bound l. If so, it means there are no more elements to consider, and the function returns 1.\\n\\nOtherwise, the function checks if the value at index i is between l and h. If it is, it recursively calls dfs twice: once with the left subarray (from l to A[i]) and once with the right subarray (from A[i] to h). It also calculates the number of combinations between the left and right subarrays using math.comb and multiplies it with the recursive results.\\n\\nIf the value at index i is not between l and h, the function makes a recursive call with the same index but updates only the upper bound.\\n\\nFinally, the function returns the result of the recursive calls subtracted by 1.\\n\\nThe numOfWays function initializes some variables and then calls dfs with the initial parameters.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: The time complexity depends on the number of recursive calls made. Each recursive call reduces the problem size, so the time complexity can be expressed as O(2^n), where n is the length of the input list A.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity is determined by the depth of the recursive calls, which can go up to n. Therefore, the space complexity is O(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfWays(self, A):\\n        n = len(A)\\n        mod = 10 ** 9 + 7\\n\\n        def dfs(i, l, h):\\n            if h == l + 1:\\n                return 1\\n            if l < A[i] < h:\\n                return (dfs(i + 1, l, A[i]) * dfs(i + 1, A[i], h) * math.comb(h - l - 2, A[i] - l - 1)) % mod\\n            return dfs(i + 1, l, h)\\n            \\n        return dfs(0, 0, n + 1) - 1\\n\\n```\\n\\n### *Kindly Upvote\\u270C\\uD83C\\uDFFC*",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, A):\\n        n = len(A)\\n        mod = 10 ** 9 + 7\\n\\n        def dfs(i, l, h):\\n            if h == l + 1:\\n                return 1\\n            if l < A[i] < h:\\n                return (dfs(i + 1, l, A[i]) * dfs(i + 1, A[i], h) * math.comb(h - l - 2, A[i] - l - 1)) % mod\\n            return dfs(i + 1, l, h)\\n            \\n        return dfs(0, 0, n + 1) - 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820768,
                "title": "o-nlogn-asymptotically-optimal-solution",
                "content": "**O(N^2) isn\\'t optimal**\\n\\nBefore reading this, you should understand the recursive solution by reading other posts ([C++](https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/discuss/819369/C%2B%2B-Just-using-recursion-very-Clean-and-Easy-to-understand-O(n2)), [Java](https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/discuss/819725/Java-Clean-code-uses-Yang-Hui\\'sPascal\\'s-Triangle-With-Explanation), [Python](https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/discuss/819282/Python-O(n2)-post-order-traversal)).\\n\\nOnce the BST is built, the recursion only takes O(N) steps and is optimal. However, most of the solutions here are O(N^2) because of two suboptimal steps:\\n1. Naive insertion into unbalanced BST is O(N) in the worst case, so tree-building is O(N^2).\\n2. Pre-computing all combination C(m,n) (aka Pascal\\'s triangle) takes O(N^2)\\n\\nIn this post I\\'ll show the optimal algorithms to the above two steps, the first one O(NlogN) and the second O(NlogP) (where P=10^9+7), making the overall complexity O(NlogN) (since P is a constant).\\n\\n**Building unbalanced BST with the help of balanced BST**\\n\\nReflecting on the BST insertion algorithm, it\\'s not hard to notice that **the parent of the newly inserted number is either the next larger number or the next smaller number**.\\n\\nFor example, if numbers in the BST are [1,2,4,5], and the new number is 3, then regardless of the shape of the BST, 3\\'s parent must be either 2 or 4.\\n\\nProof by contradiction is simple: if that\\'s not true, there are numbers between the new number and its parent, which by the definition of BST have to be the children of the new number, violating the BST insertion algorithm that the new number is a leaf node.\\n\\nFurthermore, **there is always one and only one available position for insertion** between the two possibilities: \"right child of the next smaller number\" and \"left child of the next larger number\". Proof: since there are no number between \"the next smaller number\" and \"the next larger number\", either \"the next larger number\" is in the right subtree of \"the next smaller number\", or \"the next smaller number\" is in the left subtree of \"the next larger number\". In both cases, one of the two possible positions is occupied by an existing subtree.\\n\\nWith the observations above, we can use a balanced BST (`map` in C++ or `TreeMap` in Java) that can find \"next larger/smaller number\" in O(logN). With the help of a balanced BST, we can insert a number into an unbalanced BST in O(logN), thus building the whole unbalanced BST in O(NlogN). Below is my C++ code for tree-buliding:\\n\\n```C++\\nclass Solution {\\n    struct Tree{\\n        Solution::Tree *l,*r;\\n        int v;\\n        Tree(int v):l(nullptr),r(nullptr),v(v){}\\n    };\\n    void insert(map<int,Tree*>& mp,int v){\\n        Tree* leaf=new Tree(v);\\n        auto it=mp.lower_bound(v);\\n        if(it!=mp.end()&&!it->second->l){\\n            it->second->l=leaf;\\n        }\\n        else{\\n            it--;\\n            it->second->r=leaf;\\n        }\\n        mp[v]=leaf;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        map<int,Tree*> mp;\\n        Tree* root=new Tree(nums[0]);\\n        mp[nums[0]]=root;\\n        for(int i=1;i<nums.size();i++)\\n            insert(mp,nums[i]);\\n        // ...\\n    }\\n};\\n```\\n**Combinations formula and modular inverse**\\n\\nWe all know the formular for combinations, or number of ways of selecting `m` items from `n` items: `C(m,n)=n!/m!/(n-m)!`. If we pre-compute all factorials from 1 to N, we can compute any `C(m,n)` in O(1) with this formula.\\n\\nHowever, in modular arithmetics (\"return the result modulo P\"), doing division is a bit complicated. Unlike addition/subtraction/multiplication, `(a/b)%P` is not equal to `(a%P)/(b%P)`. It turns out that you need to compute `a*inv(b,P)%P` instead, where `inv(b,P)` is called the [modular inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) of b modulo P.\\n\\nThere are  [two algorithms modular inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Computation), both of which are O(logP) for small P that fits in a machine word. Thus, we can pre-compute all factorials and their modular inverses from 1 to N in O(NlogP), and then compute any `C(m,n)` in O(1).\\n1. Extended Euclidean algorithm\\n2. Exponentiation by squaring and Fermat\\'s Little Theorem (`a^(P-2)=a^-1 (mod P)`)\\n\\nI personally prefer the second one, although it only works when P is prime. Below is the C++ code.\\n```C++\\ntypedef long long ll;\\nconst ll P=1000000007;\\nll pow(ll a,ll n){\\n\\tif(n==1)return a;\\n\\tll half=pow(a,n/2);\\n\\tll ret=half*half%P;\\n\\tif(n%2)ret=ret*a%P;\\n\\treturn ret;\\n}\\nll inv(ll a){\\n\\treturn pow(a,P-2);\\n}\\n```\\n**Full code in C++**\\n```C++\\nclass Solution {\\n    struct Tree{\\n        Solution::Tree *l,*r;\\n        int v;\\n        Tree(int v):l(nullptr),r(nullptr),v(v){}\\n    };\\n    void insert(map<int,Tree*>& mp,int v){\\n        Tree* leaf=new Tree(v);\\n        auto it=mp.lower_bound(v);\\n        if(it!=mp.end()&&!it->second->l){\\n            it->second->l=leaf;\\n        }\\n        else{\\n            it--;\\n            it->second->r=leaf;\\n        }\\n        mp[v]=leaf;\\n    }\\n    typedef long long ll;\\n    const ll P=1000000007;\\n    vector<ll> fac,invfac;\\n    ll pow(ll a,ll n){\\n        if(n==1)return a;\\n        ll half=pow(a,n/2);\\n        ll ret=half*half%P;\\n        if(n%2)ret=ret*a%P;\\n        return ret;\\n    }\\n    ll inv(ll a){\\n        return pow(a,P-2);\\n    }\\n    ll comb(int m,int n){\\n        if(m==0||m==n)return 1;\\n        else return fac[n]*invfac[m]%P*invfac[n-m]%P;\\n    }\\n    pair<int,ll> dfs(Tree* t){\\n        if(!t)return {0,1};\\n        int sl,sr;\\n        ll wl,wr;\\n        tie(sl,wl)=dfs(t->l);\\n        tie(sr,wr)=dfs(t->r);\\n        ll w=(wl*wr%P)*comb(sl,sl+sr)%P;\\n        return {sl+sr+1,w};\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        fac.push_back(1);\\n        invfac.push_back(1);\\n        for(int i=1;i<=nums.size();i++){\\n            fac.push_back(fac.back()*i%P);\\n            invfac.push_back(inv(fac.back()));\\n        }\\n        map<int,Tree*> mp;\\n        Tree* root=new Tree(nums[0]);\\n        mp[nums[0]]=root;\\n        for(int i=1;i<nums.size();i++)\\n            insert(mp,nums[i]);\\n        return (dfs(root).second+P-1)%P;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\n    struct Tree{\\n        Solution::Tree *l,*r;\\n        int v;\\n        Tree(int v):l(nullptr),r(nullptr),v(v){}\\n    };\\n    void insert(map<int,Tree*>& mp,int v){\\n        Tree* leaf=new Tree(v);\\n        auto it=mp.lower_bound(v);\\n        if(it!=mp.end()&&!it->second->l){\\n            it->second->l=leaf;\\n        }\\n        else{\\n            it--;\\n            it->second->r=leaf;\\n        }\\n        mp[v]=leaf;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        map<int,Tree*> mp;\\n        Tree* root=new Tree(nums[0]);\\n        mp[nums[0]]=root;\\n        for(int i=1;i<nums.size();i++)\\n            insert(mp,nums[i]);\\n        // ...\\n    }\\n};\\n```\n```C++\\ntypedef long long ll;\\nconst ll P=1000000007;\\nll pow(ll a,ll n){\\n\\tif(n==1)return a;\\n\\tll half=pow(a,n/2);\\n\\tll ret=half*half%P;\\n\\tif(n%2)ret=ret*a%P;\\n\\treturn ret;\\n}\\nll inv(ll a){\\n\\treturn pow(a,P-2);\\n}\\n```\n```C++\\nclass Solution {\\n    struct Tree{\\n        Solution::Tree *l,*r;\\n        int v;\\n        Tree(int v):l(nullptr),r(nullptr),v(v){}\\n    };\\n    void insert(map<int,Tree*>& mp,int v){\\n        Tree* leaf=new Tree(v);\\n        auto it=mp.lower_bound(v);\\n        if(it!=mp.end()&&!it->second->l){\\n            it->second->l=leaf;\\n        }\\n        else{\\n            it--;\\n            it->second->r=leaf;\\n        }\\n        mp[v]=leaf;\\n    }\\n    typedef long long ll;\\n    const ll P=1000000007;\\n    vector<ll> fac,invfac;\\n    ll pow(ll a,ll n){\\n        if(n==1)return a;\\n        ll half=pow(a,n/2);\\n        ll ret=half*half%P;\\n        if(n%2)ret=ret*a%P;\\n        return ret;\\n    }\\n    ll inv(ll a){\\n        return pow(a,P-2);\\n    }\\n    ll comb(int m,int n){\\n        if(m==0||m==n)return 1;\\n        else return fac[n]*invfac[m]%P*invfac[n-m]%P;\\n    }\\n    pair<int,ll> dfs(Tree* t){\\n        if(!t)return {0,1};\\n        int sl,sr;\\n        ll wl,wr;\\n        tie(sl,wl)=dfs(t->l);\\n        tie(sr,wr)=dfs(t->r);\\n        ll w=(wl*wr%P)*comb(sl,sl+sr)%P;\\n        return {sl+sr+1,w};\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        fac.push_back(1);\\n        invfac.push_back(1);\\n        for(int i=1;i<=nums.size();i++){\\n            fac.push_back(fac.back()*i%P);\\n            invfac.push_back(inv(fac.back()));\\n        }\\n        map<int,Tree*> mp;\\n        Tree* root=new Tree(nums[0]);\\n        mp[nums[0]]=root;\\n        for(int i=1;i<nums.size();i++)\\n            insert(mp,nums[i]);\\n        return (dfs(root).second+P-1)%P;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643910,
                "title": "c-with-full-explanation-easy",
                "content": "We know that in bst all the nodes to the left are less than the root node and all the nodes to the right are greater than the root node. So in order to create same bst we will have to use same root as first node and consider relative ordering independently of left and right sub part.\\n\\nIt took me while to understand the concept so this is the explanation!\\nlets consider example\\n[3,4,5,1,2]\\nhere root=3;\\nleft=[1,2];\\nright=[4,5];\\nnow to get same bst 1 should always appear before 2.\\nin right part 4 should appear before 5.\\nbut there is no restriction on order of left and right ordering.Like 4 and 2 can occur in any order.\\nNow to get total results first of all the the length of left=l;\\nlength of right= r;\\ntotal length= l+r;\\nwe have l+r position out of which l position has to be selected for the left elements and they will appear in same order.\\nso no of ways= length(c)left\\nnow for left and right subtree we call the recursive function and multiply the total result.\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n        int countBST(vector<int>& nums) {\\n        if (nums.size() <= 2)\\n            return 1;\\n\\n        vector<int> left, right;\\n        int root = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] < root)\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }\\n\\n        long long l = countBST(left);  \\n        long long r = countBST(right);\\n\\n        // Calculate the number of combinations using the Catalan number formula\\n        long long tc = binomialCoefficient(left.size() + right.size(), left.size());\\n\\n        return (l * r % 1000000007 * tc % 1000000007);\\n    }\\n    \\n\\n    long long binomialCoefficient(int n, int k) {\\n        const int MOD = 1e9 + 7;\\n\\n        vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, 0));\\n        dp[0][0] = 1;\\n\\n        for (int i = 1; i <= n; i++) {\\n            dp[i][0] = 1;\\n            for (int j = 1; j <= min(i, k); j++) {\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        const int MOD = 1e9 + 7;\\n        return (countBST(nums) - 1 + MOD) % MOD;\\n        \\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "class Solution {\\npublic:\\n    int mod=1e9+7;\\n        int countBST(vector<int>& nums) {\\n        if (nums.size() <= 2)\\n            return 1;\\n\\n        vector<int> left, right;\\n        int root = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] < root)\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3643892,
                "title": "w-explanation-c-python-using-math-pascal-s-triangle-comb-beats-96-74",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first element in array must be the root. Then divide the array into left subtree and right subtree! \\n\\nUse recursion, if the subproblems for left subtree and right subtree are solved, with the returning number l and r, Use the following formula:\\n$$\\nTotalNumber=l\\\\times r\\\\times C^{N-1}_{Len(left\\\\_subtree)}-1\\n$$\\nto solve the problem! Remember modulo 10**9+7 \\n\\nPlease turn on the English subtitles if neccessary!\\n[https://youtu.be/eS-Po5QJE24](https://youtu.be/eS-Po5QJE24)\\n# Why multiplication? The fundamental principle of counting/rule of product or multiplication principle says:\\n>  if there are a ways of doing something and b ways of doing another thing, then there are a \\xB7 b ways of performing both actions.\\n\\n# Why the binomial number $C^{N-1}_{Len(left\\\\_subtree)}$?\\nQ: Let N = len(nums). The position for the root is always at index 0. While you can change the positions of elements in the left and right subtrees, you need to maintain the orderings within each subtree. Therefore, there are N-1 available places to position either the left or right subtree. The count of possible arrangements is exactly given by   $C^{N-1}_{Len(left\\\\_subtree)}$!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe computation for the binomial number $C^n_k$ from n choose k is using [Pascal\\'s triangle](https://leetcode.com/problems/pascals-triangle/solutions/3201092/best-c-solution-via-pascal-s-identity-c-i-j-c-i-i-j-beats-100/)!\\n\\nThis test case makes using direct method computing  $C^{N-1}_{Len(left\\\\_subtree)}$ impossible in C++, even using unsigned long long! But in python there is a function comb. \\n```\\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\\n```\\n![Pascal.png](https://assets.leetcode.com/users/images/0b85189f-ed0d-4b24-af86-7166ff978740_1686921922.1673555.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    long Mod = 1e9 + 7;\\n    // Calculate C_{n} choose k using Pascal\\'s equation\\n    vector<vector<long>> C; // Matrix to store calculated binomial coefficients\\n    \\n    long compute_C_N_choose_K(int N, int K) {\\n        if (K > N / 2)\\n            K = N - K; // C_N choose K = C_N choose N-K\\n        \\n        C.assign(N + 1, vector<long>(K + 1, 0)); \\n        // Initialize the matrix with zeros\\n        \\n        for (int i = 0; i <= N; i++) {\\n            C[i][0] = 1; // Set the first column of each row to 1\\n            \\n            for (int j = 1; j <= min(i, K); j++)\\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % Mod; \\n            // Calculate binomial coefficient using Pascal\\'s equation\\n        }\\n        \\n        return C[N][K]; // Return the computed binomial coefficient\\n    }\\n\\n    long Subproblem(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 2)\\n            return 1; \\n// Base case: If the number of elements is less than or equal to 2, \\n//there is only one way to split\\n        \\n        vector<int> left, right;\\n        int root = nums[0]; // Choose the first element as the root\\n        \\n        // Split the remaining elements into left and \\n        //right parts based on their values compared to the root\\n        for (int i = 1; i < n; i++) {\\n            if (root < nums[i])\\n                right.push_back(nums[i]); \\n// Add the element to the right part if it is greater than the root\\n\\n            else\\n                left.push_back(nums[i]); \\n// Add the element to the left part if \\n//it is less than or equal to the root\\n        }\\n        \\n        long r = Subproblem(right) % Mod; \\n// Recursively calculate the number of ways for the right part\\n\\n        long l = Subproblem(left) % Mod; \\n// Recursively calculate the number of ways for the left part\\n        \\n        return compute_C_N_choose_K(n - 1, left.size()) * r % Mod * l % Mod; \\n// Compute the total number of ways based on binomial coefficients \\n// and the number of ways for left and right parts\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        return Subproblem(nums); \\n// Start the recursive computation by calling the Subproblem function\\n    }\\n};\\n\\n```\\n# 2nd Solution w SC O(N) & twice faster than 1st one\\n```\\nclass Solution {\\npublic:\\n    int Mod=1e9+7;\\n    //Calcute C_{n} choose k by Pascal\\'s equation\\n    \\n    int compute_C_N_choose_K(int N, int K){\\n        if (K>N/2) K=N-K;//C_N choose K =C_N choose N-K\\n        vector<int> C_N(K+1, 0), prevC(K+1, 0);\\n        for(int i=0; i<=N; i++){\\n            C_N[0]=1;\\n            for(int j=1; j<=min(i, K);j++){\\n                C_N[j]=((long)prevC[j-1]+prevC[j])%Mod;  \\n            }\\n            prevC=C_N;  \\n        }\\n        return C_N[K];\\n    }\\n\\n    long Subproblem(vector<int>& nums){\\n        int n=nums.size();\\n        if (n<=2) return 1;\\n        vector<int> left, right;\\n        int root=nums[0];\\n        for (int i=1; i<n; i++){\\n            if (root<nums[i]) right.push_back(nums[i]);\\n            else left.push_back(nums[i]);\\n        }\\n        long r=Subproblem(right), l=Subproblem(left);\\n        return compute_C_N_choose_K(n-1, left.size())*r%Mod*l%Mod;\\n\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        return (Subproblem(nums)-1)%Mod;\\n    }\\n};\\n```\\n# Python solution Runtime 155 ms Beats 96.74%\\n```\\nclass Solution:   \\n    def numOfWays(self, nums: List[int]) -> int:\\n        Mod=10**9+7\\n        import math\\n        def Subproblem(nums: List[int]):\\n            n=len(nums)\\n            if n<=2: return 1\\n            root=nums[0]\\n            left=[]\\n            right=[]\\n            for y in nums[1:]:\\n                if y<root: left.append(y)\\n                else: right.append(y)\\n            return Subproblem(right)*Subproblem(left)%Mod*math.comb(len(nums)-1, len(left))%Mod\\n        return int((Subproblem(nums)-1)%Mod)\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Math",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\\n```\n```\\nclass Solution {\\npublic:\\n    long Mod = 1e9 + 7;\\n    // Calculate C_{n} choose k using Pascal\\'s equation\\n    vector<vector<long>> C; // Matrix to store calculated binomial coefficients\\n    \\n    long compute_C_N_choose_K(int N, int K) {\\n        if (K > N / 2)\\n            K = N - K; // C_N choose K = C_N choose N-K\\n        \\n        C.assign(N + 1, vector<long>(K + 1, 0)); \\n        // Initialize the matrix with zeros\\n        \\n        for (int i = 0; i <= N; i++) {\\n            C[i][0] = 1; // Set the first column of each row to 1\\n            \\n            for (int j = 1; j <= min(i, K); j++)\\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % Mod; \\n            // Calculate binomial coefficient using Pascal\\'s equation\\n        }\\n        \\n        return C[N][K]; // Return the computed binomial coefficient\\n    }\\n\\n    long Subproblem(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 2)\\n            return 1; \\n// Base case: If the number of elements is less than or equal to 2, \\n//there is only one way to split\\n        \\n        vector<int> left, right;\\n        int root = nums[0]; // Choose the first element as the root\\n        \\n        // Split the remaining elements into left and \\n        //right parts based on their values compared to the root\\n        for (int i = 1; i < n; i++) {\\n            if (root < nums[i])\\n                right.push_back(nums[i]); \\n// Add the element to the right part if it is greater than the root\\n\\n            else\\n                left.push_back(nums[i]); \\n// Add the element to the left part if \\n//it is less than or equal to the root\\n        }\\n        \\n        long r = Subproblem(right) % Mod; \\n// Recursively calculate the number of ways for the right part\\n\\n        long l = Subproblem(left) % Mod; \\n// Recursively calculate the number of ways for the left part\\n        \\n        return compute_C_N_choose_K(n - 1, left.size()) * r % Mod * l % Mod; \\n// Compute the total number of ways based on binomial coefficients \\n// and the number of ways for left and right parts\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        return Subproblem(nums); \\n// Start the recursive computation by calling the Subproblem function\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int Mod=1e9+7;\\n    //Calcute C_{n} choose k by Pascal\\'s equation\\n    \\n    int compute_C_N_choose_K(int N, int K){\\n        if (K>N/2) K=N-K;//C_N choose K =C_N choose N-K\\n        vector<int> C_N(K+1, 0), prevC(K+1, 0);\\n        for(int i=0; i<=N; i++){\\n            C_N[0]=1;\\n            for(int j=1; j<=min(i, K);j++){\\n                C_N[j]=((long)prevC[j-1]+prevC[j])%Mod;  \\n            }\\n            prevC=C_N;  \\n        }\\n        return C_N[K];\\n    }\\n\\n    long Subproblem(vector<int>& nums){\\n        int n=nums.size();\\n        if (n<=2) return 1;\\n        vector<int> left, right;\\n        int root=nums[0];\\n        for (int i=1; i<n; i++){\\n            if (root<nums[i]) right.push_back(nums[i]);\\n            else left.push_back(nums[i]);\\n        }\\n        long r=Subproblem(right), l=Subproblem(left);\\n        return compute_C_N_choose_K(n-1, left.size())*r%Mod*l%Mod;\\n\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        return (Subproblem(nums)-1)%Mod;\\n    }\\n};\\n```\n```\\nclass Solution:   \\n    def numOfWays(self, nums: List[int]) -> int:\\n        Mod=10**9+7\\n        import math\\n        def Subproblem(nums: List[int]):\\n            n=len(nums)\\n            if n<=2: return 1\\n            root=nums[0]\\n            left=[]\\n            right=[]\\n            for y in nums[1:]:\\n                if y<root: left.append(y)\\n                else: right.append(y)\\n            return Subproblem(right)*Subproblem(left)%Mod*math.comb(len(nums)-1, len(left))%Mod\\n        return int((Subproblem(nums)-1)%Mod)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643832,
                "title": "rust-i-dont-like-trees-faster-then-editorial-approach",
                "content": "# Intuition\\nThe answer will be the product for all nodes of $\\\\binom{k+m}{m}$ where $k$ and $m$ are sizes of left and right subtree of the node, respectively.\\n\\nWe want to compute the sizes of subtrees somehow. The easiest way would be to either build the tree directly or somehow iterate through it via function recursion.\\n\\nBut we are not going to do this for two reasons. First, we don\\'t like trees. Second, this will take worst-case quadratic time (we are talking `[1, 2, 3, ..., 1000]` case here).\\n\\n(As evident from the editorial, a quadratic time solution will work. But we can to better than this.)\\n\\n# Approach\\nInstead we can just reverse the permutation and notice the answer immediately. For any value $i$ in the reversed permutation, if we locate values $j$ and $k$ that are less than $i$ and are closest to $i$ from right and left respectively, i.e.\\n$[\\u2026, j, \\\\underbrace{\\u2026}_{\\\\text{values}\\u2265i}, i, \\\\underbrace{\\u2026}_{\\\\text{values}\\u2265i}, k, \\u2026]$\\nthen the values between $j$ and $i$ are the indices (in the original array) of values in the left subtree of $i$, and the values between $i$ and $k$ are the indices of values in the right subtree.\\n\\nTherefore we only need to reverse the permutation (which is essentially sorting the original array) and then have a pass though it noting for each value $i$ the distances to the closest values that are less than $i$ (this will need a stack of previous smaller values).\\n\\nAfter that only the problem of computing the binomial coefficients remains. Unlike editorial, which uses a quadratic solution by precomputing Pascal\\'s triangle, we will use $\\\\binom{k+m}{m} = \\\\frac{(k+m)!}{k! \\\\cdot m!}$ formula, and only precompute the factorials. In fact, since factorials are constants, we can precompute them compile-time (up to $999!$) using Rust\\'s const expressions.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log(n))$, where $n = nums.\\\\mathrm{length}$.\\n\\n- Space complexity: $O(n)$.\\n\\nLeetCode shows `4 ms` and `2.3 MB`.\\n\\n# Code\\n```\\n/// Standard \\u201Cgive the answer modulo 10\\u2079\\xA0+\\xA07\\u201D thing\\nmod modulo {\\n\\nuse std::{ops::{Add, Sub, Mul, Div, AddAssign, MulAssign}, iter::Sum};\\n\\n#[derive(Clone, Copy, PartialEq, Eq, Debug)]\\npub struct I32Mod(i32);\\n\\nfn ext_gcd(a: i32, b: i32) -> (i32, i32, i32) {\\n    let (mut a, mut b) = (a, b);\\n    let (mut ma, mut na, mut mb, mut nb) = (1_i32, 0_i32, 0_i32, 1_i32);\\n    assert!(a > 0 && b > 0);\\n    while b > 0 {\\n        let (k, r) = (a / b, a % b);\\n        let (mr, nr) = (\\n            ma - k * mb,\\n            na - k * nb,\\n        );\\n        a = b;\\n        ma = mb; na = nb;\\n        b = r;\\n        mb = mr; nb = nr;\\n    }\\n    return (a, ma, na);\\n}\\n\\nimpl I32Mod {\\n    pub const MOD: i32 = 10_i32.pow(9) + 7;\\n\\n    #[inline]\\n    pub fn inverse(self) -> Self {\\n        assert!(self.0 != 0, \"only nonzero elements are inversible\");\\n        let (d, _, n) = ext_gcd(Self::MOD, self.0);\\n        assert!(d == 1, \"element should be inversible\");\\n        return n.into()\\n    }\\n\\n    pub const fn const_from(value: i32) -> Self {\\n        Self((value % Self::MOD + Self::MOD) % Self::MOD)\\n    }\\n\\n    pub const fn const_mul(self, other: I32Mod) -> I32Mod {\\n        Self((\\n            (self.0 as i64 * other.0 as i64) % (Self::MOD as i64)\\n        ) as i32)\\n    }\\n\\n}\\n\\nimpl From<i32> for I32Mod {\\n    #[inline]\\n    fn from(value: i32) -> Self {\\n        Self((value % Self::MOD + Self::MOD) % Self::MOD)\\n    }\\n}\\n\\nimpl From<I32Mod> for i32 {\\n    #[inline]\\n    fn from(value: I32Mod) -> i32 {\\n        value.0\\n    }\\n}\\n\\nimpl Add<I32Mod> for I32Mod {\\n    type Output = I32Mod;\\n    #[inline]\\n    fn add(self, other: I32Mod) -> I32Mod {\\n        Self((self.0 + other.0) % Self::MOD)\\n    }\\n}\\n\\nimpl Sub<I32Mod> for I32Mod {\\n    type Output = I32Mod;\\n    #[inline]\\n    fn sub(self, other: I32Mod) -> I32Mod {\\n        Self((self.0 - other.0 + Self::MOD) % Self::MOD)\\n    }\\n}\\n\\nimpl Mul<I32Mod> for I32Mod {\\n    type Output = I32Mod;\\n    #[inline]\\n    fn mul(self, other: I32Mod) -> I32Mod {\\n        Self((\\n            (self.0 as i64 * other.0 as i64) % (Self::MOD as i64)\\n        ) as i32)\\n    }\\n}\\n\\nimpl Div<I32Mod> for I32Mod {\\n    type Output = I32Mod;\\n    // #[inline]\\n    fn div(self, rhs: I32Mod) -> Self::Output {\\n        self * rhs.inverse()\\n    }\\n}\\n\\nimpl AddAssign<I32Mod> for I32Mod {\\n    #[inline]\\n    fn add_assign(&mut self, other: I32Mod) {\\n        *self = *self + other;\\n    }\\n}\\n\\nimpl MulAssign<I32Mod> for I32Mod {\\n    #[inline]\\n    fn mul_assign(&mut self, other: I32Mod) {\\n        *self = *self * other;\\n    }\\n}\\n\\n} // mod modulo\\n\\nuse modulo::I32Mod;\\n\\nconst MAX_N: usize = 1000;\\n\\nconst factorials: [I32Mod; MAX_N] = { // compile-time precompute\\n    let mut result: [I32Mod; MAX_N] = [I32Mod::const_from(0); MAX_N];\\n    result[0] = I32Mod::const_from(1);\\n    let mut i = 1;\\n    while i < MAX_N {\\n        result[i] = result[i-1].const_mul(I32Mod::const_from(i as i32));\\n        i += 1;\\n    }\\n    result\\n};\\n\\nimpl Solution {\\n    pub fn num_of_ways(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        assert!(n <= MAX_N);\\n        let inv_nums = { // permutation inverse\\n            let mut inv_nums = (0..(n as i32)).collect::<Vec<_>>();\\n            inv_nums.sort_unstable_by_key(|&i| nums[i as usize]);\\n            inv_nums.push(-1); // add guard\\n            inv_nums\\n        };\\n        let margins = {\\n            let mut margins = Vec::<(i32,i32)>::with_capacity(n + 1);\\n            let mut stack = Vec::with_capacity(20);\\n            for (j, i) in inv_nums.into_iter().enumerate() {\\n                let j = j as i32;\\n                // clear the stack from values that are larger than us\\n                // (guard will wipe the stack on last iteration)\\n                loop { match stack.last() {\\n                    Some(&(j1, i1)) if i1 > i => {\\n                        margins[j1 as usize].1 = j - j1 - 1;\\n                        stack.pop();\\n                    },\\n                    _ => break,\\n                } }\\n                margins.push((\\n                    match stack.last() {\\n                        Some(&(j1, _)) => j - j1 - 1,\\n                        None => j,\\n                    },\\n                    -1, // must get overwritten later\\n                ));\\n                stack.push((j, i));\\n            }\\n            margins.pop(); // remove guard\\n            margins\\n        };\\n        let mut result_frac = (I32Mod::from(1), I32Mod::from(1));\\n        for (left, right) in margins {\\n            result_frac.0 *= factorials[(left + right) as usize];\\n            result_frac.1 *= factorials[left as usize];\\n            result_frac.1 *= factorials[right as usize];\\n        }\\n        return (result_frac.0 / result_frac.1 - 1.into()).into();\\n    }\\n}\\n```\\n\\nP.S. It\\'s a joke. I like trees. Just not in this problem.",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n/// Standard \\u201Cgive the answer modulo 10\\u2079\\xA0+\\xA07\\u201D thing\\nmod modulo {\\n\\nuse std::{ops::{Add, Sub, Mul, Div, AddAssign, MulAssign}, iter::Sum};\\n\\n#[derive(Clone, Copy, PartialEq, Eq, Debug)]\\npub struct I32Mod(i32);\\n\\nfn ext_gcd(a: i32, b: i32) -> (i32, i32, i32) {\\n    let (mut a, mut b) = (a, b);\\n    let (mut ma, mut na, mut mb, mut nb) = (1_i32, 0_i32, 0_i32, 1_i32);\\n    assert!(a > 0 && b > 0);\\n    while b > 0 {\\n        let (k, r) = (a / b, a % b);\\n        let (mr, nr) = (\\n            ma - k * mb,\\n            na - k * nb,\\n        );\\n        a = b;\\n        ma = mb; na = nb;\\n        b = r;\\n        mb = mr; nb = nr;\\n    }\\n    return (a, ma, na);\\n}\\n\\nimpl I32Mod {\\n    pub const MOD: i32 = 10_i32.pow(9) + 7;\\n\\n    #[inline]\\n    pub fn inverse(self) -> Self {\\n        assert!(self.0 != 0, \"only nonzero elements are inversible\");\\n        let (d, _, n) = ext_gcd(Self::MOD, self.0);\\n        assert!(d == 1, \"element should be inversible\");\\n        return n.into()\\n    }\\n\\n    pub const fn const_from(value: i32) -> Self {\\n        Self((value % Self::MOD + Self::MOD) % Self::MOD)\\n    }\\n\\n    pub const fn const_mul(self, other: I32Mod) -> I32Mod {\\n        Self((\\n            (self.0 as i64 * other.0 as i64) % (Self::MOD as i64)\\n        ) as i32)\\n    }\\n\\n}\\n\\nimpl From<i32> for I32Mod {\\n    #[inline]\\n    fn from(value: i32) -> Self {\\n        Self((value % Self::MOD + Self::MOD) % Self::MOD)\\n    }\\n}\\n\\nimpl From<I32Mod> for i32 {\\n    #[inline]\\n    fn from(value: I32Mod) -> i32 {\\n        value.0\\n    }\\n}\\n\\nimpl Add<I32Mod> for I32Mod {\\n    type Output = I32Mod;\\n    #[inline]\\n    fn add(self, other: I32Mod) -> I32Mod {\\n        Self((self.0 + other.0) % Self::MOD)\\n    }\\n}\\n\\nimpl Sub<I32Mod> for I32Mod {\\n    type Output = I32Mod;\\n    #[inline]\\n    fn sub(self, other: I32Mod) -> I32Mod {\\n        Self((self.0 - other.0 + Self::MOD) % Self::MOD)\\n    }\\n}\\n\\nimpl Mul<I32Mod> for I32Mod {\\n    type Output = I32Mod;\\n    #[inline]\\n    fn mul(self, other: I32Mod) -> I32Mod {\\n        Self((\\n            (self.0 as i64 * other.0 as i64) % (Self::MOD as i64)\\n        ) as i32)\\n    }\\n}\\n\\nimpl Div<I32Mod> for I32Mod {\\n    type Output = I32Mod;\\n    // #[inline]\\n    fn div(self, rhs: I32Mod) -> Self::Output {\\n        self * rhs.inverse()\\n    }\\n}\\n\\nimpl AddAssign<I32Mod> for I32Mod {\\n    #[inline]\\n    fn add_assign(&mut self, other: I32Mod) {\\n        *self = *self + other;\\n    }\\n}\\n\\nimpl MulAssign<I32Mod> for I32Mod {\\n    #[inline]\\n    fn mul_assign(&mut self, other: I32Mod) {\\n        *self = *self * other;\\n    }\\n}\\n\\n} // mod modulo\\n\\nuse modulo::I32Mod;\\n\\nconst MAX_N: usize = 1000;\\n\\nconst factorials: [I32Mod; MAX_N] = { // compile-time precompute\\n    let mut result: [I32Mod; MAX_N] = [I32Mod::const_from(0); MAX_N];\\n    result[0] = I32Mod::const_from(1);\\n    let mut i = 1;\\n    while i < MAX_N {\\n        result[i] = result[i-1].const_mul(I32Mod::const_from(i as i32));\\n        i += 1;\\n    }\\n    result\\n};\\n\\nimpl Solution {\\n    pub fn num_of_ways(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        assert!(n <= MAX_N);\\n        let inv_nums = { // permutation inverse\\n            let mut inv_nums = (0..(n as i32)).collect::<Vec<_>>();\\n            inv_nums.sort_unstable_by_key(|&i| nums[i as usize]);\\n            inv_nums.push(-1); // add guard\\n            inv_nums\\n        };\\n        let margins = {\\n            let mut margins = Vec::<(i32,i32)>::with_capacity(n + 1);\\n            let mut stack = Vec::with_capacity(20);\\n            for (j, i) in inv_nums.into_iter().enumerate() {\\n                let j = j as i32;\\n                // clear the stack from values that are larger than us\\n                // (guard will wipe the stack on last iteration)\\n                loop { match stack.last() {\\n                    Some(&(j1, i1)) if i1 > i => {\\n                        margins[j1 as usize].1 = j - j1 - 1;\\n                        stack.pop();\\n                    },\\n                    _ => break,\\n                } }\\n                margins.push((\\n                    match stack.last() {\\n                        Some(&(j1, _)) => j - j1 - 1,\\n                        None => j,\\n                    },\\n                    -1, // must get overwritten later\\n                ));\\n                stack.push((j, i));\\n            }\\n            margins.pop(); // remove guard\\n            margins\\n        };\\n        let mut result_frac = (I32Mod::from(1), I32Mod::from(1));\\n        for (left, right) in margins {\\n            result_frac.0 *= factorials[(left + right) as usize];\\n            result_frac.1 *= factorials[left as usize];\\n            result_frac.1 *= factorials[right as usize];\\n        }\\n        return (result_frac.0 / result_frac.1 - 1.into()).into();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643667,
                "title": "c-solution-because-there-weren-t-any-others",
                "content": "# Approach\\nGenerates a table of all binomial coefficients to reference, then calculates the number of combinations for all subtrees with recursion. \\nSame as the editorial suggests.\\n\\nI first tried a solution calculating and caching factorials, but it was not fun trying to work with values as large as 35!\\nThis one is better.\\n\\n# Code\\n```\\n    public class Solution\\n    {\\n        readonly int mod = 1000000007; //% 10^9 + 7 is requirement of problem\\n        long[,] coefficientTable;\\n        public int NumOfWays(int[] nums)\\n        {\\n            GenerateBinomialCoefficientTable(nums.Length);\\n            return (NumOfWays(nums.ToList()) - 1) % mod;\\n        }\\n        public int NumOfWays(List<int> nums)\\n        {\\n            if (nums.Count <= 2)\\n                return 1;\\n\\n            List<int> left = new List<int>();\\n            List<int> right = new List<int>();\\n            int root = nums[0];\\n\\n            for (int i = 1; i < nums.Count; i++)\\n            {\\n                if (nums[i] < root)\\n                    left.Add(nums[i]);\\n                else\\n                    right.Add(nums[i]);\\n            }\\n\\n            long waysLeft = NumOfWays(left);\\n            long waysRight = NumOfWays(right);\\n            long subtrees = (waysLeft * waysRight) % mod;\\n            long binomialCoefficient = coefficientTable[nums.Count - 1, left.Count];\\n            return (int)((binomialCoefficient * subtrees) % mod);\\n        }\\n        public void GenerateBinomialCoefficientTable(int size)\\n        {\\n            coefficientTable = new long[size, size];\\n            for (int i = 0; i < size; ++i)\\n            {\\n                coefficientTable[i, 0] = 1;\\n                coefficientTable[i, i] = 1;\\n            }\\n            for (int i = 2; i < size; i++)           \\n                for (int j = 1; j < i; j++)                \\n                    coefficientTable[i, j] = (coefficientTable[i - 1, j - 1] + coefficientTable[i - 1, j]) % mod;                            \\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        readonly int mod = 1000000007; //% 10^9 + 7 is requirement of problem\\n        long[,] coefficientTable;\\n        public int NumOfWays(int[] nums)\\n        {\\n            GenerateBinomialCoefficientTable(nums.Length);\\n            return (NumOfWays(nums.ToList()) - 1) % mod;\\n        }\\n        public int NumOfWays(List<int> nums)\\n        {\\n            if (nums.Count <= 2)\\n                return 1;\\n\\n            List<int> left = new List<int>();\\n            List<int> right = new List<int>();\\n            int root = nums[0];\\n\\n            for (int i = 1; i < nums.Count; i++)\\n            {\\n                if (nums[i] < root)\\n                    left.Add(nums[i]);\\n                else\\n                    right.Add(nums[i]);\\n            }\\n\\n            long waysLeft = NumOfWays(left);\\n            long waysRight = NumOfWays(right);\\n            long subtrees = (waysLeft * waysRight) % mod;\\n            long binomialCoefficient = coefficientTable[nums.Count - 1, left.Count];\\n            return (int)((binomialCoefficient * subtrees) % mod);\\n        }\\n        public void GenerateBinomialCoefficientTable(int size)\\n        {\\n            coefficientTable = new long[size, size];\\n            for (int i = 0; i < size; ++i)\\n            {\\n                coefficientTable[i, 0] = 1;\\n                coefficientTable[i, i] = 1;\\n            }\\n            for (int i = 2; i < size; i++)           \\n                for (int j = 1; j < i; j++)                \\n                    coefficientTable[i, j] = (coefficientTable[i - 1, j - 1] + coefficientTable[i - 1, j]) % mod;                            \\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643518,
                "title": "c-explained",
                "content": "\\n\\n# Approach\\n The solution first calculates the binomial coefficients using dynamic programming and stores them in a 2D vector comb. \\nThen, it defines a recursive function dfs that takes as input a subarray of nums and returns the number of ways to reorder that subarray such that the BST formed is identical to the original BST.\\n The function dfs first checks if the size of the input subarray is less than or equal to 2, in which case it returns 1.\\n Then, it separates the elements of the input subarray into two subarrays left and right, where left contains all elements that are less than the first element of the input subarray and right contains all elements that are greater than or equal to the first element of the input subarray. \\nThe function then calculates the result as the product of the binomial coefficient comb[n - 1][left.size()], dfs(left), and dfs(right), modulo 1000000007. Finally, it returns the result cast to an integer. The main function calls dfs(nums) and returns its result minus 1\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> comb(n + 1, vector<int>(n + 1));\\n        comb[0][0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            comb[i][0] = 1;\\n            for (int j = 1; j <= i; ++j) {\\n                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % 1000000007;\\n            }\\n        }\\n        function<int(vector<int>&)> dfs = [&](vector<int>& nums) {\\n            int n = nums.size();\\n            if (n <= 2) return 1;\\n            vector<int> left, right;\\n            for (int i = 1; i < n; ++i) {\\n                if (nums[i] < nums[0]) left.push_back(nums[i]);\\n                else right.push_back(nums[i]);\\n            }\\n            long long res = comb[n - 1][left.size()];\\n            res = res * dfs(left) % 1000000007;\\n            res = res * dfs(right) % 1000000007;\\n            return (int)res;\\n        };\\n        return dfs(nums) - 1;\\n    }\\n};\\n   \\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> comb(n + 1, vector<int>(n + 1));\\n        comb[0][0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            comb[i][0] = 1;\\n            for (int j = 1; j <= i; ++j) {\\n                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % 1000000007;\\n            }\\n        }\\n        function<int(vector<int>&)> dfs = [&](vector<int>& nums) {\\n            int n = nums.size();\\n            if (n <= 2) return 1;\\n            vector<int> left, right;\\n            for (int i = 1; i < n; ++i) {\\n                if (nums[i] < nums[0]) left.push_back(nums[i]);\\n                else right.push_back(nums[i]);\\n            }\\n            long long res = comb[n - 1][left.size()];\\n            res = res * dfs(left) % 1000000007;\\n            res = res * dfs(right) % 1000000007;\\n            return (int)res;\\n        };\\n        return dfs(nums) - 1;\\n    }\\n};\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349368,
                "title": "ruby-array-partitioning-and-combinatorics",
                "content": "# Code\\n```ruby\\nMOD = 1_000_000_007\\n\\ndef num_of_ways(nums) = bst_permutations(nums) - 1\\n\\ndef bst_permutations(nums)\\n  if nums.empty?\\n    1\\n  else\\n    root_val = nums.shift\\n    partitions = nums.partition { _1 < root_val }\\n    comb(*partitions.map(&:size)) * partitions.map { bst_permutations _1 }.reduce(:*) % MOD\\n  end\\nend\\n\\ndef comb(a, b)\\n  if a > b\\n    comb(b, a)\\n  else\\n    (b + 1..b + a).reduce(1, :*) / (1..a).reduce(1, :*)\\n  end\\nend\\n```\\n\\n# Time complexity\\n\\n$$\\\\mathcal{O}(n^2)$$\\n\\n# Space complexity\\n\\n$$\\\\mathcal{O}(n^2)$$",
                "solutionTags": [
                    "Ruby",
                    "Array",
                    "Math",
                    "Combinatorics"
                ],
                "code": "```ruby\\nMOD = 1_000_000_007\\n\\ndef num_of_ways(nums) = bst_permutations(nums) - 1\\n\\ndef bst_permutations(nums)\\n  if nums.empty?\\n    1\\n  else\\n    root_val = nums.shift\\n    partitions = nums.partition { _1 < root_val }\\n    comb(*partitions.map(&:size)) * partitions.map { bst_permutations _1 }.reduce(:*) % MOD\\n  end\\nend\\n\\ndef comb(a, b)\\n  if a > b\\n    comb(b, a)\\n  else\\n    (b + 1..b + a).reduce(1, :*) / (1..a).reduce(1, :*)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3120607,
                "title": "python3-solution-fast-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can approach the problem by using a recursive approach. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use a recursive approach. We start from the first element of the array, and find the number of elements smaller and larger than the current node. We then make use of the combination formula to calculate the number of combinations with the current node. We then recursively call the same function for the left and right subarrays, and multiply the results together. Finally, we subtract one and take the modulo of the result with 10^9 + 7 to get our final answer. \\n\\n```\\ndef comb(n, r):\\n    return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))\\n```\\n# Complexity\\n- Time complexity:  $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def dfs(nums):\\n            if len(nums) <= 2: return 1\\n            left = [n for n in nums if n < nums[0]]\\n            right = [n for n in nums if n > nums[0]]\\n            return comb(len(nums) - 1, len(left)) * dfs(left) * dfs(right)\\n        return (dfs(nums) - 1) % (10 ** 9 + 7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef comb(n, r):\\n    return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))\\n```\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def dfs(nums):\\n            if len(nums) <= 2: return 1\\n            left = [n for n in nums if n < nums[0]]\\n            right = [n for n in nums if n > nums[0]]\\n            return comb(len(nums) - 1, len(left)) * dfs(left) * dfs(right)\\n        return (dfs(nums) - 1) % (10 ** 9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109371,
                "title": "detailed-explanation-hopefully-easy-to-understand-python-solution",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s start small\\n\\nLook at this Binary Search Tree\\n```\\n   2\\n  / \\\\\\n 1   3\\n```\\nWhat do you think is the valid array to form this BST?\\n`[2,1,3]` and `[2,3,1]` both are correct here.\\n\\nLet\\'s look at another BST\\n```\\n   6\\n  / \\\\\\n 5   7\\n```\\nWhat do you think is the valid array to form this tree?\\nI guess, you got it right - `[6,5,7]` and `[6,7,5]`.\\n\\nWhat **observations** have you concluded from the above two examples?(I strongly suggest you to think, before you move ahead)\\n-> The **root** is always **first** (This is our **Observation #1**)\\n-> Also, if nodes are on the same level, their relative ordering does not matter (**Obs #2**)\\n\\nLet\\'s take a look at a bigger BST\\n```\\n        4 \\n     /    \\\\\\n    2      6\\n  /  \\\\    /  \\\\\\n 1    3  5    7\\n```\\nWhat do you think is the valid array to form this tree?\\n\\nThis Might look difficult at first. But if we properly **observe**, we can use the above two examples to get some solution here.\\n\\nUsing Observation #1, 4 will be the first element.\\n\\nLet\\'s break down the problem to left and right subtree. Since, it is a BST all the elements smaller than root will be on the left subtree and vice versa.\\n\\nUsing Obs #2, the relative order of `1,3,5,7` won\\'t matter. But from Obs #1, `1,3` has to be **after** `2` and `5,7` has to be **after** `6`. And similarly, the relative order of `2` and `6` won\\'t matter.\\n\\nSo, how do we get the permutations of subtrees?\\n\\n****\\n**Before moving down further, I highly encourage to solve these Problems first to get the grasp of what is coming ahead:**\\n1. [Permutations](https://leetcode.com/problems/permutations/description/)\\n2. [Permutations II](https://leetcode.com/problems/permutations-ii/)\\n3. [Permutations of a String](https://leetcode.com/problems/permutation-in-string/description/) (Optional)\\n****\\n\\n$$Continuing....$$\\nSo, how do we get the permutations of subtrees?\\nTo tackle this problem let\\'s mark left subtree nodes as **0** and right subtree nodes as **1**. Because with that, the relative ordering of the subtree will stay the same.\\n\\nFor example, `[2,1,3,6,5,7]` = `[0,0,0,1,1,1]`. Now if we generate different permutations of this, let\\'s say `[1,0,1,0,1,0]`, we can unmark zeros and ones with the respective subtree values i.e., `[6,2,5,1,7,5]`. Observe that the relative order of subtree nodes remains intact.\\n\\nNow, the permutation [6,2,5,**1**,7,**5**] and [6,2,5,**5**,7,**1**] (Obeserve postiion of `1` and `5`) both are correct, but since we repalce them with **0s** and **1s** both of them are considered same only. To get that value, we follow the same process on the subtree as well i.e.,\\n`[1,5]` = `[0,1]` (left subtree as **0** and right as **1**). Which generates 2 permutations.\\n\\nThis part -- `[2,1,3,6,5,7]` = `[0,0,0,1,1,1]` -- will generate `(6!/(3! * 3!))` permutations (For proof - You can try this on a smaller number say, `[0,0,1,1]`). \\n\\nWell, how is the above formula concluded? You can think of it as chosing 3 places from 6 available places (`6 C 3`) (Or formula of permutations having duplicate values). Also, to note that we also have to get the permutations of the subtree, so we multiply it with permutations of subtrees.\\n\\nSo, it will become `(6!/(3! * 3!)) * 2! * 2!` (`2!` for left and `2!` for permutations of right subtree)\\n\\nHence, we keep on doing the same recursively for all subtrees and multiply their corresponding permutations.\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfWays(self, numList: List[int]) -> int:\\n        def find_no_of_combinations_of(nums):\\n            # having a single num has just 1! permutations\\n            if len(nums) < 2:\\n                return 1\\n            # get the left subtree\\n            left_subtree = [num for num in nums if num < nums[0]]  \\n            # get the right subtree\\n            right_subtree = [num for num in nums if num > nums[0]]\\n            \\n            # The (6!/ (3! * 3!)) * 2! * 2! step\\n            return (comb(len(left_subtree) + len(right_subtree), len(left_subtree)) *\\\\\\n                    find_no_of_combinations_of(left_subtree) *\\\\\\n                    find_no_of_combinations_of(right_subtree)) % (10**9 + 7)\\n        \\n        # at last we minus 1 because our ans permutations \\n        # has the permutation from the question as well\\n        return find_no_of_combinations_of(numList) - 1\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Combinatorics",
                    "Binary Tree"
                ],
                "code": "```\\n   2\\n  / \\\\\\n 1   3\\n```\n```\\n   6\\n  / \\\\\\n 5   7\\n```\n```\\n        4 \\n     /    \\\\\\n    2      6\\n  /  \\\\    /  \\\\\\n 1    3  5    7\\n```\n```\\nclass Solution:\\n    def numOfWays(self, numList: List[int]) -> int:\\n        def find_no_of_combinations_of(nums):\\n            # having a single num has just 1! permutations\\n            if len(nums) < 2:\\n                return 1\\n            # get the left subtree\\n            left_subtree = [num for num in nums if num < nums[0]]  \\n            # get the right subtree\\n            right_subtree = [num for num in nums if num > nums[0]]\\n            \\n            # The (6!/ (3! * 3!)) * 2! * 2! step\\n            return (comb(len(left_subtree) + len(right_subtree), len(left_subtree)) *\\\\\\n                    find_no_of_combinations_of(left_subtree) *\\\\\\n                    find_no_of_combinations_of(right_subtree)) % (10**9 + 7)\\n        \\n        # at last we minus 1 because our ans permutations \\n        # has the permutation from the question as well\\n        return find_no_of_combinations_of(numList) - 1\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650559,
                "title": "c-math-combination-theory-dynamic-programming",
                "content": "**1569. Number of Ways to Reorder Array to Get Same BST**\\n\\nIt\\'s a interesting math problem. \\n\\nWe will solve this problem by recursion, it\\'s a little similar to dynamic programming.\\n\\n+ On the top level, there is no doubt that `nums[0]` is the root of BST.\\n+ Remind that in BST, we have `left < root < right`.\\n+ Thus, those numbers who are smaller than `nums[0]`, we put them in the vector `left` (which are the left children). And the others who greater than `nums[0]`, we put them in vector `right` (which are the right children).\\n+ There are `n` position, index-0 is occupied by `nums[0]`. And we should put `left` in the remained `n-1` positions, there are `C[n-1][k]` cases, where `k` is the length of `left`.\\n  > Remind the combination formula:\\n  > `C[n][k] = C[n-1][k] + C[n-1][k-1]`\\n\\n+ Let `f(nums)` denote the number of cases, if we get the `left, right` vector mentioned above, then we can have:\\n```cpp\\nf(nums) = f(left) * f(right) * C[n - 1][k]\\n```\\nwhere `k` is the length of `left` vector, and `n` is the length of vector `nums`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    const int mod = (int)(1e9) + 7;\\n    vector<vector<int>> C;\\n    int numOfWays(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        C.resize(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; ++i)\\n        {\\n            C[i][0] = 1;\\n            for (int j = 1; j <= i; ++j)\\n                C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;\\n        }\\n        return f(nums) % mod - 1;\\n    }\\n    \\n    int64_t f(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        if (n <= 1) return 1;\\n        vector<int> left, right;\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (nums[i] > nums[0]) right.emplace_back(nums[i]);\\n            else left.emplace_back(nums[i]);\\n        }\\n        int64_t lval = f(left) % mod, rval = f(right) % mod;\\n        return ((C[n - 1][left.size()] * lval) % mod * rval) % mod;\\n    }\\n};\\n```\\n\\nThis solution is slow, but it can work :-D !\\n",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "```cpp\\nf(nums) = f(left) * f(right) * C[n - 1][k]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    const int mod = (int)(1e9) + 7;\\n    vector<vector<int>> C;\\n    int numOfWays(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        C.resize(n, vector<int>(n, 0));\\n        for (int i = 0; i < n; ++i)\\n        {\\n            C[i][0] = 1;\\n            for (int j = 1; j <= i; ++j)\\n                C[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;\\n        }\\n        return f(nums) % mod - 1;\\n    }\\n    \\n    int64_t f(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        if (n <= 1) return 1;\\n        vector<int> left, right;\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (nums[i] > nums[0]) right.emplace_back(nums[i]);\\n            else left.emplace_back(nums[i]);\\n        }\\n        int64_t lval = f(left) % mod, rval = f(right) % mod;\\n        return ((C[n - 1][left.size()] * lval) % mod * rval) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429536,
                "title": "python3-original-counting-and-if-we-want-to-print-all-bst-list",
                "content": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        \\n        # Time O(N^2)\\n        # Space O(N) for recursion stack\\n        \\n        def combine(n, k):\\n            \\n            def fac(n):\\n                s = 1\\n                for i in range(1, n + 1):\\n                    s *= i\\n                return s\\n            \\n            return fac(n) // (fac(n - k) * fac(k))\\n        \\n            \\n        def recur(nums):\\n            if len(nums) <= 2: \\n                return 1\\n            left = []\\n            right = []\\n            for n in nums[1:]:\\n                if n < nums[0]:\\n                    left.append(n)\\n                elif n > nums[0]:\\n                    right.append(n)\\n            curr = combine(len(left)+len(right), len(right))\\n            return curr * recur(left) * recur(right)\\n        \\n        return (recur(nums)-1) % (10**9+7)\\n    \\n        \"\"\"\\n        print all bst\\n        # Time O(2^N)\\n        # Space O(2^N)\\n        def get_all_bst(nums):\\n            candidates = []\\n            \\n            def recur(l, li, r, ri, temp):\\n                nonlocal candidates\\n                \\n                if len(temp) == len(l) + len(r):\\n                    candidates.append(temp[:])\\n                    return\\n                if li < len(l):\\n                    temp.append(l[li])\\n                    recur(l, li+1, r, ri, temp)\\n                    temp.pop()\\n                if ri < len(r):\\n                    temp.append(r[ri])\\n                    recur(l, li, r, ri+1, temp)\\n                    temp.pop()\\n            \\n            start = nums[0]\\n            left = [v for v in nums if v < start]\\n            right = [v for v in nums if v > start]\\n            recur(left, 0, right, 0, [])\\n            res = []\\n            for candidate in candidates:\\n                r = [start] + candidate\\n                if r != nums:\\n                    res.append(r)\\n            \\n            return res\\n        \"\"\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        \\n        # Time O(N^2)\\n        # Space O(N) for recursion stack\\n        \\n        def combine(n, k):\\n            \\n            def fac(n):\\n                s = 1\\n                for i in range(1, n + 1):\\n                    s *= i\\n                return s\\n            \\n            return fac(n) // (fac(n - k) * fac(k))\\n        \\n            \\n        def recur(nums):\\n            if len(nums) <= 2: \\n                return 1\\n            left = []\\n            right = []\\n            for n in nums[1:]:\\n                if n < nums[0]:\\n                    left.append(n)\\n                elif n > nums[0]:\\n                    right.append(n)\\n            curr = combine(len(left)+len(right), len(right))\\n            return curr * recur(left) * recur(right)\\n        \\n        return (recur(nums)-1) % (10**9+7)\\n    \\n        \"\"\"\\n        print all bst\\n        # Time O(2^N)\\n        # Space O(2^N)\\n        def get_all_bst(nums):\\n            candidates = []\\n            \\n            def recur(l, li, r, ri, temp):\\n                nonlocal candidates\\n                \\n                if len(temp) == len(l) + len(r):\\n                    candidates.append(temp[:])\\n                    return\\n                if li < len(l):\\n                    temp.append(l[li])\\n                    recur(l, li+1, r, ri, temp)\\n                    temp.pop()\\n                if ri < len(r):\\n                    temp.append(r[ri])\\n                    recur(l, li, r, ri+1, temp)\\n                    temp.pop()\\n            \\n            start = nums[0]\\n            left = [v for v in nums if v < start]\\n            right = [v for v in nums if v > start]\\n            recur(left, 0, right, 0, [])\\n            res = []\\n            for candidate in candidates:\\n                r = [start] + candidate\\n                if r != nums:\\n                    res.append(r)\\n            \\n            return res\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820884,
                "title": "python-short-dp",
                "content": "<h4> Explanation: </h4>\\nI used recursive + dp to solve this problem. \\nIf there is regulation by not using any library to generate Permutation Count, DP can come to help to get the Permutation Count. Here is the code:\\n\\n\\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        dp = [[1 for r in range(len(nums)+1)] for l in range(len(nums)+1)]\\n        \\n        for i in range(1, len(nums)):\\n            for j in range(1, len(nums)):\\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j])\\n        \\n        return (self.getNum(nums, dp) - 1)%(10**9+7)\\n    \\n    def getNum(self, nums, dp):\\n        if len(nums) <= 2:\\n            return 1\\n        left, right = [num for num in nums if num < nums[0]], [num for num in nums if num > nums[0]]\\n        return (self.getNum(left, dp)*dp[len(left)][len(right)]*self.getNum(right, dp))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        dp = [[1 for r in range(len(nums)+1)] for l in range(len(nums)+1)]\\n        \\n        for i in range(1, len(nums)):\\n            for j in range(1, len(nums)):\\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j])\\n        \\n        return (self.getNum(nums, dp) - 1)%(10**9+7)\\n    \\n    def getNum(self, nums, dp):\\n        if len(nums) <= 2:\\n            return 1\\n        left, right = [num for num in nums if num < nums[0]], [num for num in nums if num > nums[0]]\\n        return (self.getNum(left, dp)*dp[len(left)][len(right)]*self.getNum(right, dp))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820263,
                "title": "python3-divide-and-conquer-detailed-explanation",
                "content": "The idea is divide and conquer:\\n1) To get the same BST,  we must first insert the root(the first element in the array), then we can insert its left subtree and right subtree.\\n\\n2) For both subtrees, we need to first insert root as well;\\n\\n3) when we have numbers of ways to arrange left subtree and right subtree, we only have to calculate the number of ways to arrange them into one array that does not change both subarrays\\' original relative order within its elements.\\n\\nFor example, \\n\\n`nums = [3, 4, 5, 1, 2]`, `total_length` for both subtrees elements is `4`.\\n\\nFor left subtree, lnum = 1, only 1 arrangement: `[1, 2]`, `left_length = 2`\\n\\nFor right subtree, rnum = 1, only 1 arrangement: `[4, 5]`, `right_length = 2`\\n\\nThus, the total number of arrangements when put into one array should be equal to number of ways to take `left_length` positions out of `total_length`, which is `combinations(total_length, left_length)`. Here, we have `combinations(4, 2) = 6`, and the arrangements are:\\n\\n`[1,2,4,5]`\\n\\n`[1,4,2,5]`\\n\\n`[1,4,5,2]`\\n\\n`[4,1,2,5]`\\n\\n`[4,1,5,2]`\\n\\n`[4,5,1,2]`\\n\\nAlso, both subtrees could have more valid arragements, thus, the recurrence equation should be:\\n\\n`num(A) = num(left_subtree) * num(right_subtree) * combinations(total_length, left_length)`.\\n\\nFinally,  we need to `-1` because the input array should not be counted.\\n\\n```\\nclass Solution:\\n    def numOfWays(self, A: List[int]) -> int:\\n        mod =10 ** 9 + 7\\n        \\n        def split(left, right):\\n            lnum, rnum = 1, 1\\n            if left:\\n                lroot = left[0]\\n                lnum = split([l for l in left if l < lroot], [r for r in left if r > lroot])\\n            if right:\\n                rroot = right[0]\\n                rnum = split([l for l in right if l < rroot], [r for r in right if r > rroot])\\n            return lnum * rnum * comb(len(left) + len(right), len(left))\\n        \\n        root = A[0]\\n        return  split([l for l in A if l < root], [r for r in A if r > root]) % mod - 1\\n```\\n\\nTime: `O(nlogn)`, similar to quick sort, each time we call `split`, we choose the the first element to be the pivot and split the input array to be two subarrays(one contains all the elements less than pivot, the other one contains all the elements larger than pivot).\\nSpace: `O(nlogn)`.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, A: List[int]) -> int:\\n        mod =10 ** 9 + 7\\n        \\n        def split(left, right):\\n            lnum, rnum = 1, 1\\n            if left:\\n                lroot = left[0]\\n                lnum = split([l for l in left if l < lroot], [r for r in left if r > lroot])\\n            if right:\\n                rroot = right[0]\\n                rnum = split([l for l in right if l < rroot], [r for r in right if r > rroot])\\n            return lnum * rnum * comb(len(left) + len(right), len(left))\\n        \\n        root = A[0]\\n        return  split([l for l in A if l < root], [r for r in A if r > root]) % mod - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819349,
                "title": "python3-math-ish",
                "content": "\\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        \\n        def fn(nums): \\n            \"\"\"Post-order traversal.\"\"\"\\n            if len(nums) <= 1: return len(nums) # boundary condition \\n            ll = [x for x in nums if x < nums[0]]\\n            rr = [x for x in nums if x > nums[0]]\\n            left, right = fn(ll), fn(rr)\\n            if not left or not right: return left or right\\n            ans = comb(len(rr)+len(ll), len(rr))\\n            return ans*left*right\\n            \\n        return (fn(nums)-1) % 1_000_000_007\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        \\n        def fn(nums): \\n            \"\"\"Post-order traversal.\"\"\"\\n            if len(nums) <= 1: return len(nums) # boundary condition \\n            ll = [x for x in nums if x < nums[0]]\\n            rr = [x for x in nums if x > nums[0]]\\n            left, right = fn(ll), fn(rr)\\n            if not left or not right: return left or right\\n            ans = comb(len(rr)+len(ll), len(rr))\\n            return ans*left*right\\n            \\n        return (fn(nums)-1) % 1_000_000_007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646483,
                "title": "python-3-recursion-comb-beats-95",
                "content": "# Intuition\\nThe first idea I had here was that each root has to come before any of its children in the list, otherwise the tree will be out of order. This then made me think of splitting the problem into subtrees (recursion). For each tree, the total number of combinations possible is the number of ways to shuffle its child subtrees directly, then multiplied by the number of ways to shuffle each child subtree.\\n\\nFor more clarity, in the example `[3,4,5,1,2]`, we can obtain `[3,1,4,5,2]` by shuffling directly, and then we note that we cannot shuffle the individual subtrees `[4,5]` or `[1,2]` further.\\n\\n# Approach\\nThe recursion is not too complex once we have the idea. The base case here is a tree with two or less nodes (only one way to order the elements). \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is $$O(n^2)$$; each recursive layer requires an iteration through a linear array (pretty much.)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is also $$O(n^2)$$.\\n\\n# Code\\n```\\nfrom math import comb\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        # each root must come before any of its children\\n        # recursive call on each root given nodes in subtree\\n        # for each tree - total number of nodes - 1 choose the number of nodes in one subtree\\n        # multiply by the result for both subtrees\\n\\n        def recurse(nodes):\\n            if len(nodes) <= 2:\\n                return 1\\n            else:\\n                l = []\\n                r = []\\n                for val in nodes[1:]:\\n                    if val > nodes[0]:\\n                        r.append(val)\\n                    else:\\n                        l.append(val)\\n                # comb calculates nCk\\n                return comb(len(nodes) - 1, len(l)) * recurse(l) * recurse(r)\\n\\n        return (recurse(nums) - 1) % 1000000007\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nfrom math import comb\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        # each root must come before any of its children\\n        # recursive call on each root given nodes in subtree\\n        # for each tree - total number of nodes - 1 choose the number of nodes in one subtree\\n        # multiply by the result for both subtrees\\n\\n        def recurse(nodes):\\n            if len(nodes) <= 2:\\n                return 1\\n            else:\\n                l = []\\n                r = []\\n                for val in nodes[1:]:\\n                    if val > nodes[0]:\\n                        r.append(val)\\n                    else:\\n                        l.append(val)\\n                # comb calculates nCk\\n                return comb(len(nodes) - 1, len(l)) * recurse(l) * recurse(r)\\n\\n        return (recurse(nums) - 1) % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646455,
                "title": "the-world-needs-another-python-solution",
                "content": "# Approach\\n\\nWe use recursion. The steps below explain the solution.\\n\\n1. The root must be inserted first.\\n2. The order of nodes inserted in the left subtree is independent of the order of nodes inserted in the right subtree.\\n3. The nodes in the left subtree can be inserted in any order relative to the nodes in the right subtree.\\n4. The recursive relationship is therefore \\n`f(nums) = f(left subtree nodes list)*f(right subtree nodes list)*C(len(left subtree)+len(right subtree), len(left subtree))`\\nwhere C(n, k) is the binomial coefficient, also called \"n choose k\". In this expression, the product `f(left subtree nodes list)*f(right subtree nodes list)` comes from  observation (2), and the binomial coefficient `C(len(left subtree)+len(right subtree), len(left subtree))` comes from observation (3).\\n5. The base case is f([]) == 1.\\n6. Since we\\'re returning the number of ways of reordering the list, we need to exclude the present ordering. This means we need to subtract 1 from the final result. The need to subtract 1 at the end is also the only reason why we need to define a separate function inside of our function body to perform the recursion. (We don\\'t want to subtract 1 on recursive calls.)\\n7. Don\\'t forget to give the result modulo 10**9 + 7.\\n\\n# Complexity\\n- Time and space complexity are both O(n^2) in the worst case, O(n*log(n)) in the average case.\\n- The worst case occurs when the list is mostly sorted.\\n\\n# Code\\n```\\nfrom math import comb\\n\\nB = 10**9 + 7\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def f(nums):\\n            if len(nums) == 0:\\n                return 1\\n            \\n            left = [n for n in nums if n < nums[0]]\\n            right = [n for n in nums if n > nums[0]]\\n\\n            return f(left)*f(right)*comb(len(left) + len(right), len(left)) % B\\n\\n        return (f(nums)-1) % B\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import comb\\n\\nB = 10**9 + 7\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def f(nums):\\n            if len(nums) == 0:\\n                return 1\\n            \\n            left = [n for n in nums if n < nums[0]]\\n            right = [n for n in nums if n > nums[0]]\\n\\n            return f(left)*f(right)*comb(len(left) + len(right), len(left)) % B\\n\\n        return (f(nums)-1) % B\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646235,
                "title": "java-python-2-approch-faster-than-96-8-using-pascal-s-tringle-in-java-and-combinatories-bst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **Intuition for Java:(using Pascal\\'s Tringle)**\\nwe uses a recursive approach combined with the Pascal\\'s Triangle to calculate the number of ways to arrange the elements in the input array. It separates the elements into two sublists based on their values and recursively calculates the number of ways for each sublist. The final result is obtained by multiplying the number of ways for the sublists and the corresponding combination from the Pascal\\'s Triangle.\\n\\n- **Intuition for Python:(by recursively)**\\nWe uses a recursive approach to calculate the number of ways to arrange the elements in the input array. It separates the elements into two sublists based on their values and then recursively calculates the number of ways for each sublist. The final result is obtained by multiplying the number of ways for the sublists and the appropriate combination value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **Approach for Java-using Pascal\\'s Tringle:**\\n\\nThe code defines a Solution class that contains the necessary methods and variables.\\n\\nThe code initializes a constant MOD with the value 1000000007. This constant is used to perform modulo arithmetic.\\n\\nThe code initializes a constant 2D array pascal_triangle using the BuildPascalsTriangle function. This array stores the Pascal\\'s Triangle up to a size of 1000. Each element of the array represents the combination of choosing j elements from a set of i elements.\\n\\nThe numOfWays method takes an input array nums and converts it to a list. It then calls the NumsOfWays method to calculate the number of ways to arrange the array.\\n\\nThe NumsOfWays method recursively calculates the number of ways to arrange the elements in the input list nums. It first checks if the size of nums is less than or equal to 2. If so, it returns 1 since there is only one way to arrange 0 or 1 elements.\\n\\nIf nums has more than 2 elements, the method separates the elements into two lists: leftNodes and rightNodes. The leftNodes list contains elements smaller than the first element (root), and the rightNodes list contains elements greater than the first element.\\n\\nThe method recursively calls NumsOfWays on leftNodes and rightNodes to calculate the number of ways to arrange the elements in each sublist.\\n\\nThe method uses the formula: (NumsOfWays(leftNodes) * NumsOfWays(rightNodes) * pascal_triangle[n-1][leftNodes.size()]) % MOD to calculate the total number of ways to arrange the elements in nums. It multiplies the number of ways to arrange the left sublist by the number of ways to arrange the right sublist, and multiplies the result by the corresponding combination from the Pascal\\'s Triangle.\\n\\nFinally, the method returns the calculated number of ways modulo MOD.\\n\\nThe BuildPascalsTriangle method constructs the Pascal\\'s Triangle as a 2D array. It initializes the edges of the triangle with 1, and then fills in the remaining elements using the formula: pascal_triangle[i][j] = (pascal_triangle[i-1][j] + pascal_triangle[i-1][j-1]) % MOD.\\n\\n- **Approch for Python:**\\n\\nThe code defines a Solution class that contains the necessary methods and variables.\\n\\nThe code initializes a variable mod with the value 10 ** 9 + 7. This variable is used to perform modulo arithmetic.\\n\\nThe code defines a helper function combination(nl, nr) that calculates the combination of choosing nr elements from a set of nl + nr elements. It uses a precalculated array factorial to efficiently compute the combination.\\n\\nThe code defines a recursive helper function ways(arr) that calculates the number of ways to arrange the elements in the input list arr.\\n\\nIf the length of arr is less than or equal to 2, there is only one way to arrange the elements, so the function returns 1.\\n\\nOtherwise, the function selects the first element of arr as the root. It then separates the remaining elements into two sublists: left (containing elements smaller than the root) and right (containing elements greater than the root).\\n\\nThe function recursively calls itself on left and right to calculate the number of ways to arrange the elements in each sublist.\\n\\nThe function multiplies the number of ways for left and right by the combination of choosing the appropriate number of elements from each sublist. This is done using the combination function.\\n\\nFinally, the function returns the product of the calculated number of ways for left and right, modulo mod.\\n\\nThe main function numOfWays initializes a variable n with the length of the input array nums.\\n\\nIt also initializes an array factorial with length n and fills it with factorial values from 1 to n. This array is used to efficiently calculate combinations in the combination function.\\n\\nThe function calls ways(nums) to calculate the number of ways to arrange the elements in nums and subtracts 1 from it.\\n\\nFinally, the function returns the result modulo mod.\\n\\n# Complexity\\n- Time complexity:O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- **for java code**\\n\\nThe numOfWays method initially converts the nums array to a List<Integer>. This conversion takes O(n) time, where n is the size of the nums array.\\n\\nThe NumsOfWays method recursively splits the input list into two sublists, leftNodes and rightNodes. The size of each sublist can be at most n-1, where n is the size of the original list. The recursion continues until the sublist size becomes 2 or less. Therefore, the time complexity of the NumsOfWays method is O(2^n).\\n\\nThe BuildPascalsTriangle method constructs a 2D array of size n x n, where n is set to 1000. The nested loops iterate n times each, resulting in a time complexity of O(n^2), which can be considered constant as 1000 is a fixed value.\\n\\nOverall, the time complexity of the code is dominated by the NumsOfWays method, which is O(2^n).\\n\\n- **for python code**\\nThe combination function calculates the factorial of the sum of two inputs and performs two divisions. This takes constant time, so its time complexity is O(1).\\n\\nThe ways function recursively calls itself for left and right sublists. The size of each sublist can be at most n-1, where n is the size of the original list. Therefore, the recurrence relation for the time complexity of the ways function can be expressed as T(n) = 2T(n-1) + O(1), where T(n) is the time complexity for an input of size n. By expanding the recursion, we can see that T(n) is exponential, specifically O(2^n).\\n\\nThe loop in the numOfWays method iterates n times to calculate the factorial array. Each iteration performs multiplication, so the time complexity of this loop is O(n).\\n\\nOverall, the time complexity of the code is dominated by the ways function, which is O(2^n).\\n\\n- Space complexity:O(2^n) for java / O(n^2) for python\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- **for java code**\\nThe numOfWays method takes an input array nums of size n. It creates two additional lists, leftNodes and rightNodes, which can potentially store all n elements of nums. Therefore, the space complexity of the numOfWays method is O(n).\\n\\nThe BuildPascalsTriangle method creates a 2D array pascal_tringle of size n x n, where n is set to 1000. Hence, the space complexity of this method is O(n^2), which can be considered constant as 1000 is a fixed value.\\n\\nOverall, the space complexity of the code is O(n + n^2), which simplifies to O(n^2) as the dominant term.\\n\\n- **for python code**\\nThe combination function takes constant space, so its space complexity is O(1).\\n\\nThe ways function recursively creates new lists for the left and right sublists. The maximum depth of recursion can be n, and at each recursion level, two new lists are created. Therefore, the space complexity of the ways function is O(2^n).\\n\\nThe numOfWays method creates the factorial array of size n. Hence, the space complexity for this array is O(n).\\n\\nOverall, the space complexity of the code is O(2^n) due to the ways function and O(n) for the factorial array, resulting in a total space complexity of O(2^n + n).\\n\\n\\n# Code\\n```Java []\\nclass Solution {\\n\\n    private static final long MOD = 1000000007;\\n    private static final long[][] pascal_tringle = BuildPascalsTriangle();\\n\\n    public int numOfWays(int[] nums) {\\n        List<Integer> arr = Arrays.stream(nums).boxed().collect(Collectors.toList()) ;\\n        \\n        return (int)((NumsOfWays(arr)-1) % MOD);\\n    }\\n\\n    private long NumsOfWays(List<Integer> nums) {\\n        int n = nums.size();\\n        if (n <= 2) return 1;\\n\\n        List<Integer> leftNodes = new ArrayList<>();\\n        List<Integer> rightNodes = new ArrayList<>();\\n\\n        int root = nums.get(0);\\n        for (int i=1; i<n; i++) {\\n            if (nums.get(i) < root) {\\n                leftNodes.add(nums.get(i));\\n            } else {\\n                rightNodes.add(nums.get(i));\\n            }\\n        }\\n\\n        return (((NumsOfWays(leftNodes) % MOD * NumsOfWays(rightNodes) % MOD) % MOD) * \\n        pascal_tringle[n-1][leftNodes.size()]) % MOD;\\n    }\\n\\n    private static long[][] BuildPascalsTriangle() {\\n        int n=1000;\\n        long[][] pascal_tringle = new long[n][n];\\n\\n        for (int i=0; i<n; i++) {\\n            pascal_tringle[i][0] = pascal_tringle[i][i] = 1;\\n        }\\n        for (int i=2; i<n; i++) {\\n            for (int j=1; j<i; j++) {\\n                pascal_tringle[i][j] =\\n                 (pascal_tringle[i-1][j] + pascal_tringle[i-1][j-1]) % MOD;\\n            }\\n        }\\n        return pascal_tringle;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n\\n        mod = 10 ** 9 + 7\\n\\n        def combination(nl,nr):\\n            return factorial[nl+nr] // factorial[nl] // factorial[nr]\\n\\n\\n        def ways(arr):\\n           if len(arr)<=2:\\n               return 1\\n\\n           root = arr[0]\\n\\n           left = [num for num in arr if num < root ]\\n           right = [ num for num in arr if num > root]\\n          \\n           return ways(left) * ways(right) * combination(len(left), len(right))\\n\\n        n = len(nums)\\n        factorial = [1] * (n)\\n\\n        for i in range(1,n):\\n            factorial[i]= factorial[i-1] * i\\n\\n        return (ways(nums)-1) % mod;  \\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```Java []\\nclass Solution {\\n\\n    private static final long MOD = 1000000007;\\n    private static final long[][] pascal_tringle = BuildPascalsTriangle();\\n\\n    public int numOfWays(int[] nums) {\\n        List<Integer> arr = Arrays.stream(nums).boxed().collect(Collectors.toList()) ;\\n        \\n        return (int)((NumsOfWays(arr)-1) % MOD);\\n    }\\n\\n    private long NumsOfWays(List<Integer> nums) {\\n        int n = nums.size();\\n        if (n <= 2) return 1;\\n\\n        List<Integer> leftNodes = new ArrayList<>();\\n        List<Integer> rightNodes = new ArrayList<>();\\n\\n        int root = nums.get(0);\\n        for (int i=1; i<n; i++) {\\n            if (nums.get(i) < root) {\\n                leftNodes.add(nums.get(i));\\n            } else {\\n                rightNodes.add(nums.get(i));\\n            }\\n        }\\n\\n        return (((NumsOfWays(leftNodes) % MOD * NumsOfWays(rightNodes) % MOD) % MOD) * \\n        pascal_tringle[n-1][leftNodes.size()]) % MOD;\\n    }\\n\\n    private static long[][] BuildPascalsTriangle() {\\n        int n=1000;\\n        long[][] pascal_tringle = new long[n][n];\\n\\n        for (int i=0; i<n; i++) {\\n            pascal_tringle[i][0] = pascal_tringle[i][i] = 1;\\n        }\\n        for (int i=2; i<n; i++) {\\n            for (int j=1; j<i; j++) {\\n                pascal_tringle[i][j] =\\n                 (pascal_tringle[i-1][j] + pascal_tringle[i-1][j-1]) % MOD;\\n            }\\n        }\\n        return pascal_tringle;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n\\n        mod = 10 ** 9 + 7\\n\\n        def combination(nl,nr):\\n            return factorial[nl+nr] // factorial[nl] // factorial[nr]\\n\\n\\n        def ways(arr):\\n           if len(arr)<=2:\\n               return 1\\n\\n           root = arr[0]\\n\\n           left = [num for num in arr if num < root ]\\n           right = [ num for num in arr if num > root]\\n          \\n           return ways(left) * ways(right) * combination(len(left), len(right))\\n\\n        n = len(nums)\\n        factorial = [1] * (n)\\n\\n        for i in range(1,n):\\n            factorial[i]= factorial[i-1] * i\\n\\n        return (ways(nums)-1) % mod;  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646233,
                "title": "python-short-and-clean",
                "content": "# Approach\\nTL;DR, Similar to [Editorial solution](https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/editorial/).\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def numOfWays(self, nums: list[int]) -> int:\\n        M = 1_000_000_007\\n\\n        def num_ways(bst: Sequence[int]) -> int:\\n            if len(bst) <= 2: return 1\\n            lefts, rights = [x for x in bst if x < bst[0]], [x for x in bst if x > bst[0]]\\n            return num_ways(lefts) * num_ways(rights) * comb(len(lefts) + len(rights), len(lefts)) % M\\n        \\n        return (num_ways(nums) - 1) % M\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "```python\\nclass Solution:\\n    def numOfWays(self, nums: list[int]) -> int:\\n        M = 1_000_000_007\\n\\n        def num_ways(bst: Sequence[int]) -> int:\\n            if len(bst) <= 2: return 1\\n            lefts, rights = [x for x in bst if x < bst[0]], [x for x in bst if x > bst[0]]\\n            return num_ways(lefts) * num_ways(rights) * comb(len(lefts) + len(rights), len(lefts)) % M\\n        \\n        return (num_ways(nums) - 1) % M\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646114,
                "title": "100-fast-c-easy-to-understand-clean-approach-tc-o-n-bst-factorial-precomputation",
                "content": "# Intuition\\nPrecomputation of factorial of a number till 1000 is required.\\nDeclare a global variable to keep the final answer(say ans).\\n \\nStep1: Create a binary search tree.\\nStep2: For every node, find the no of nodes in left subtree(say L) and no of nodes in right subtree(say R) then do **ans  = ans* (L+R combination L);** //calculating the total number of permutations possible\\nStep3: return ans-1 as the final result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrecomputation of factorial of a number till 1000 is required.\\nDeclare a global variable to keep the final answer(say ans).\\n \\nStep1: Create a binary search tree.\\nStep2: For every node, find the no of nodes in left subtree(say L) and no of nodes in right subtree(say R) then do **ans  = ans* (L+R combination L);** //calculating the total number of permutations possible\\nStep3: return ans-1 as the final result.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N\\\\*h) to create a BST, where h is the maximum height of a tree\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll mod = 1e9+7;\\n    struct Node{\\n        int value;\\n        Node* left;\\n        Node* right;\\n        Node(int val){\\n            value = val;\\n            left = NULL;\\n            right = NULL;\\n        }\\n    };\\n\\n    ll fact[1001];\\n    void precalc() {\\n        fact[0] = 1;\\n        for(ll i = 1; i < 1001; i++)\\n            fact[i] =(fact[i - 1]*i)%mod;\\n            // fact[i]=fact[i-1]*i;\\n    }\\n\\n    ll inv(ll x) {\\n        return x <= 1 ? x : mod - (long long)(mod/x) * inv(mod % x) % mod;\\n    }\\n    \\n    ll mul(ll x, ll y) {\\n        return ((x%mod) * 1ll * (y%mod)) % mod;\\n    }\\n\\n    ll divide(ll x, ll y) {\\n        return mul(x, inv(y));\\n    }\\n\\n    void insertBST(Node* root,int val){\\n        if(root->value>val){\\n            if(root->left==NULL){\\n                root->left = new Node(val);\\n            }\\n            else{\\n                insertBST(root->left,val);\\n            }\\n        }\\n        else if(root->value<val){\\n            if(root->right==NULL){\\n                root->right = new Node(val);\\n            }\\n            else{\\n                insertBST(root->right,val);\\n            }\\n        }\\n    }\\n    \\n    void printBST(Node* root){\\n        if(root==NULL) return;\\n        printBST(root->left);\\n        cout<<root->value<<\" \";\\n        printBST(root->right);\\n    }\\n\\n    \\n    ll compute(ll left,ll right){\\n        if(left==0 or right == 0) return 1LL;\\n        return divide(fact[left+right],mul(fact[left],fact[right]));\\n    }\\n\\n    ll ans = 1;\\n    ll calculatePermutations(Node* root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        ll left = calculatePermutations(root->left);\\n        ll right = calculatePermutations(root->right);\\n        ll pnc = compute(left,right)%mod;\\n        ans = mul(ans,pnc);\\n        return 1+left+right;\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        Node* root = new Node(nums[0]);\\n        //create BST\\n        for(int i = 0;i<nums.size();i++){\\n            insertBST(root,nums[i]);\\n        }\\n\\n        precalc(); //precalculating the factorial till 1000\\n        calculatePermutations(root);\\n        return ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll mod = 1e9+7;\\n    struct Node{\\n        int value;\\n        Node* left;\\n        Node* right;\\n        Node(int val){\\n            value = val;\\n            left = NULL;\\n            right = NULL;\\n        }\\n    };\\n\\n    ll fact[1001];\\n    void precalc() {\\n        fact[0] = 1;\\n        for(ll i = 1; i < 1001; i++)\\n            fact[i] =(fact[i - 1]*i)%mod;\\n            // fact[i]=fact[i-1]*i;\\n    }\\n\\n    ll inv(ll x) {\\n        return x <= 1 ? x : mod - (long long)(mod/x) * inv(mod % x) % mod;\\n    }\\n    \\n    ll mul(ll x, ll y) {\\n        return ((x%mod) * 1ll * (y%mod)) % mod;\\n    }\\n\\n    ll divide(ll x, ll y) {\\n        return mul(x, inv(y));\\n    }\\n\\n    void insertBST(Node* root,int val){\\n        if(root->value>val){\\n            if(root->left==NULL){\\n                root->left = new Node(val);\\n            }\\n            else{\\n                insertBST(root->left,val);\\n            }\\n        }\\n        else if(root->value<val){\\n            if(root->right==NULL){\\n                root->right = new Node(val);\\n            }\\n            else{\\n                insertBST(root->right,val);\\n            }\\n        }\\n    }\\n    \\n    void printBST(Node* root){\\n        if(root==NULL) return;\\n        printBST(root->left);\\n        cout<<root->value<<\" \";\\n        printBST(root->right);\\n    }\\n\\n    \\n    ll compute(ll left,ll right){\\n        if(left==0 or right == 0) return 1LL;\\n        return divide(fact[left+right],mul(fact[left],fact[right]));\\n    }\\n\\n    ll ans = 1;\\n    ll calculatePermutations(Node* root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n\\n        ll left = calculatePermutations(root->left);\\n        ll right = calculatePermutations(root->right);\\n        ll pnc = compute(left,right)%mod;\\n        ans = mul(ans,pnc);\\n        return 1+left+right;\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        Node* root = new Node(nums[0]);\\n        //create BST\\n        for(int i = 0;i<nums.size();i++){\\n            insertBST(root,nums[i]);\\n        }\\n\\n        precalc(); //precalculating the factorial till 1000\\n        calculatePermutations(root);\\n        return ans - 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3645537,
                "title": "java-7ms-dfs-with-pascal-s-triangle",
                "content": "```\\nclass Solution {\\n    // Pascal\\'s Triangle is built only once per SUBMIT, and then can be \\n    // used for all other test cases of the SUBMIT.\\n    private static int[][] pascalsTriangle = createPascalsTriangle(1001);\\n    private static final int MOD = 1_000_000_007;\\n\\n    \\n    // Main method called by leetcode.\\n    public int numOfWays(int[] nums) {\\n        return dfs(nums, nums.length) - 1;\\n    }\\n\\n    \\n    // Use an array representing a root followed by the values below that root, \\n    // to calculate the number of combinations, by recursively breaking the \\n    // array into smaller tree problems.\\n    private int dfs(int[] nums, int n) {\\n        if (n <= 2)  return 1;\\n        final int[] left = new int[n - 1];\\n        final int[] right = new int[n - 1];\\n        final int rootVal = nums[0];\\n        int leftIdx = 0;\\n        int rightIdx = 0;\\n        for (int i = 1; i < n; i++) \\n            if (nums[i] < rootVal) \\n                left[leftIdx++] = nums[i];\\n            else\\n                right[rightIdx++] = nums[i];\\n        return (int)(((((long)dfs(left, leftIdx) * dfs(right, rightIdx)) % MOD) * \\n                pascalsTriangle[n - 1][leftIdx]) % MOD);\\n    }\\n    \\n    \\n    // Build table of Pascal\\'s triangle values.  Only have to build \\n    // it once per SUBMIT, then all test cases can use the same triangle.\\n    static private int[][] createPascalsTriangle(int maxN) {\\n        int[][] pt = new int[maxN][];\\n        for (int i = 0; i < maxN; i++) {\\n            pt[i] = new int[i + 1];\\n            pt[i][0] = pt[i][i] = 1;\\n            for (int j = 1; j < i; j++) \\n                pt[i][j] = (pt[i - 1][j - 1] + pt[i - 1][j]) % MOD;\\n        }\\n        return pt;\\n    }\\n}\\n```\\n\\n**--- Update: June 20, 2023 ---**\\nSomeone has some code that runs at 4ms and uses a different algorithm.  My code ran at 7ms.  I like this faster code.  It still uses the trick of creating a fixed value table only once per SUBMIT, then the other test cases can use that generated table.  This code show a different and better method for initializing a fixed value table called `mults[]`, from the method used in the above code for `pascalsTriangle[][]`.\\n```\\nclass Solution {\\n    static final int MAX = 1000;\\n\\tstatic final int MOD = 1_000_000_007;\\n\\tstatic final TreeNode[] q = new TreeNode[MAX];\\n\\tstatic final long[] mults = new long[MAX + 1];\\n\\tstatic {\\n\\t\\tmults[0] = 1;\\n\\t\\tfor (int i = 1; i <= MAX; i++) \\n\\t\\t\\tmults[i] = (mults[i - 1] * i) % MOD;\\n\\t}\\n\\n\\tpublic int numOfWays(int[] nums) {\\n\\t\\tTreeNode root = new TreeNode(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\troot.add(nums[i]);\\n\\t\\t}\\n\\t\\tint len = 0;\\n\\t\\tq[len++] = root;\\n\\t\\tlong d = 1;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tfinal TreeNode node = q[i];\\n\\t\\t\\td = (d * node.count) % MOD;\\n\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\tq[len++] = node.left;\\n\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\tq[len++] = node.right;\\n\\t\\t}\\n\\t\\treturn (int) ((mults[len] * inverse(d) + MOD - 1) % MOD);\\n\\t}\\n\\n\\tstatic long inverse(long y) {\\n\\t\\tlong e = MOD - 2, a = 1;\\n\\t\\twhile (e > 0) {\\n\\t\\t\\tif (e % 2 == 1) {\\n\\t\\t\\t\\ta = (a * y) % MOD;\\n\\t\\t\\t}\\n\\t\\t\\te /= 2;\\n\\t\\t\\ty = (y * y) % MOD;\\n\\t\\t}\\n\\t\\treturn a;\\n\\t}\\n\\t\\n\\tstatic final class TreeNode {\\n\\t\\tint val;\\n\\t\\tint count;\\n\\n\\t\\tTreeNode left;\\n\\t\\tTreeNode right;\\n\\n\\t\\tpublic TreeNode(int val) {\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.count = 1;\\n\\t\\t}\\n\\n\\t\\tvoid add(int val) {\\n\\t\\t\\tfor (TreeNode node = this;;) {\\n\\t\\t\\t\\tnode.count++;\\n\\t\\t\\t\\tfinal TreeNode next = val < node.val ? node.left : node.right;\\n\\t\\t\\t\\tif (next == null) {\\n\\t\\t\\t\\t\\tif (val < node.val) {\\n\\t\\t\\t\\t\\t\\tnode.left = new TreeNode(val);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tnode.right = new TreeNode(val);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnode = next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Pascal\\'s Triangle is built only once per SUBMIT, and then can be \\n    // used for all other test cases of the SUBMIT.\\n    private static int[][] pascalsTriangle = createPascalsTriangle(1001);\\n    private static final int MOD = 1_000_000_007;\\n\\n    \\n    // Main method called by leetcode.\\n    public int numOfWays(int[] nums) {\\n        return dfs(nums, nums.length) - 1;\\n    }\\n\\n    \\n    // Use an array representing a root followed by the values below that root, \\n    // to calculate the number of combinations, by recursively breaking the \\n    // array into smaller tree problems.\\n    private int dfs(int[] nums, int n) {\\n        if (n <= 2)  return 1;\\n        final int[] left = new int[n - 1];\\n        final int[] right = new int[n - 1];\\n        final int rootVal = nums[0];\\n        int leftIdx = 0;\\n        int rightIdx = 0;\\n        for (int i = 1; i < n; i++) \\n            if (nums[i] < rootVal) \\n                left[leftIdx++] = nums[i];\\n            else\\n                right[rightIdx++] = nums[i];\\n        return (int)(((((long)dfs(left, leftIdx) * dfs(right, rightIdx)) % MOD) * \\n                pascalsTriangle[n - 1][leftIdx]) % MOD);\\n    }\\n    \\n    \\n    // Build table of Pascal\\'s triangle values.  Only have to build \\n    // it once per SUBMIT, then all test cases can use the same triangle.\\n    static private int[][] createPascalsTriangle(int maxN) {\\n        int[][] pt = new int[maxN][];\\n        for (int i = 0; i < maxN; i++) {\\n            pt[i] = new int[i + 1];\\n            pt[i][0] = pt[i][i] = 1;\\n            for (int j = 1; j < i; j++) \\n                pt[i][j] = (pt[i - 1][j - 1] + pt[i - 1][j]) % MOD;\\n        }\\n        return pt;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    static final int MAX = 1000;\\n\\tstatic final int MOD = 1_000_000_007;\\n\\tstatic final TreeNode[] q = new TreeNode[MAX];\\n\\tstatic final long[] mults = new long[MAX + 1];\\n\\tstatic {\\n\\t\\tmults[0] = 1;\\n\\t\\tfor (int i = 1; i <= MAX; i++) \\n\\t\\t\\tmults[i] = (mults[i - 1] * i) % MOD;\\n\\t}\\n\\n\\tpublic int numOfWays(int[] nums) {\\n\\t\\tTreeNode root = new TreeNode(nums[0]);\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\troot.add(nums[i]);\\n\\t\\t}\\n\\t\\tint len = 0;\\n\\t\\tq[len++] = root;\\n\\t\\tlong d = 1;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tfinal TreeNode node = q[i];\\n\\t\\t\\td = (d * node.count) % MOD;\\n\\t\\t\\tif (node.left != null)\\n\\t\\t\\t\\tq[len++] = node.left;\\n\\t\\t\\tif (node.right != null)\\n\\t\\t\\t\\tq[len++] = node.right;\\n\\t\\t}\\n\\t\\treturn (int) ((mults[len] * inverse(d) + MOD - 1) % MOD);\\n\\t}\\n\\n\\tstatic long inverse(long y) {\\n\\t\\tlong e = MOD - 2, a = 1;\\n\\t\\twhile (e > 0) {\\n\\t\\t\\tif (e % 2 == 1) {\\n\\t\\t\\t\\ta = (a * y) % MOD;\\n\\t\\t\\t}\\n\\t\\t\\te /= 2;\\n\\t\\t\\ty = (y * y) % MOD;\\n\\t\\t}\\n\\t\\treturn a;\\n\\t}\\n\\t\\n\\tstatic final class TreeNode {\\n\\t\\tint val;\\n\\t\\tint count;\\n\\n\\t\\tTreeNode left;\\n\\t\\tTreeNode right;\\n\\n\\t\\tpublic TreeNode(int val) {\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.count = 1;\\n\\t\\t}\\n\\n\\t\\tvoid add(int val) {\\n\\t\\t\\tfor (TreeNode node = this;;) {\\n\\t\\t\\t\\tnode.count++;\\n\\t\\t\\t\\tfinal TreeNode next = val < node.val ? node.left : node.right;\\n\\t\\t\\t\\tif (next == null) {\\n\\t\\t\\t\\t\\tif (val < node.val) {\\n\\t\\t\\t\\t\\t\\tnode.left = new TreeNode(val);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tnode.right = new TreeNode(val);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnode = next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645099,
                "title": "finding-topological-sorts-clean-code-explanation",
                "content": "# Intuition\\nThis problem can be rephrased as finding the number of ways to topological sort the BST. We are given one, which can be used to build a tree, and the task is to find the rest.\\n\\n# Approach\\nAfter building our tree, define a helper function `h(x)` that returns the number of topological sortings for the tree node `x`. If number of nodes in the subtree `x` is less than or equal to 1, then `h(x) = 1` (Base case).\\n\\nFor an arbitrary tree node, the goal is to work out how many ways there are of interleaving the topological sorts of the left and right subtrees. For the time being, lets assume that both the left and right subtrees have exactly one topological sort each, and lengths `m` and `n` respectively (like example 2 in the problem where `x` is the root). Assume these sequences are $l=(l_1, l_2, ..., l_m)$ and $r=(r_1, r_2, ..., r_n)$.\\n\\nWe know the total length of the ordering is $m + n$, and if we can figure out where all of the values from $l$ go, those for $r$ will fall out. In other words, we need to choose $m$ indices from $m + n$; therefore the answer is $\\\\frac{(m + n)!}{m! n!}$ (combination formula).\\n\\nWhen there are more than 1 topological sorts for each subtree, we have to multiply the above formula by the product of these values (since the orderings are independent of each other... different subtrees):\\n$$ \\\\frac{(m +n)!}{m!n!}\\\\times h(x_{left}) \\\\times h(x_{right}) $$.\\n\\n# Code\\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n        self.size = 1\\n\\n    def insert(self, x):\\n        self.size += 1\\n        if x < self.val:\\n            if self.left: self.left.insert(x)\\n            else: self.left = Node(x)\\n        else:\\n            if self.right: self.right.insert(x)\\n            else: self.right = Node(x)\\n\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        root = Node(nums[0])\\n        for i in range(1, len(nums)):\\n            # Insert\\n            root.insert(nums[i])\\n\\n        # Return num topsorts\\n        def h(root):\\n            if not node or (not root.left and not root.right): return 1\\n            L = h(root.left)\\n            R = h(root.right)\\n            return math.comb(root.size - 1, root.left.size if root.left else 0) * L * R\\n\\n        return (h(root) - 1) % 1_000_000_007\\n\\n```\\n\\n# References\\n\\n- https://cs.stackexchange.com/questions/12713/find-the-number-of-topological-sorts-in-a-tree\\n- https://cs.stackexchange.com/questions/12713/find-the-number-of-topological-sorts-in-a-tree",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Tree",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n        self.size = 1\\n\\n    def insert(self, x):\\n        self.size += 1\\n        if x < self.val:\\n            if self.left: self.left.insert(x)\\n            else: self.left = Node(x)\\n        else:\\n            if self.right: self.right.insert(x)\\n            else: self.right = Node(x)\\n\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        root = Node(nums[0])\\n        for i in range(1, len(nums)):\\n            # Insert\\n            root.insert(nums[i])\\n\\n        # Return num topsorts\\n        def h(root):\\n            if not node or (not root.left and not root.right): return 1\\n            L = h(root.left)\\n            R = h(root.right)\\n            return math.comb(root.size - 1, root.left.size if root.left else 0) * L * R\\n\\n        return (h(root) - 1) % 1_000_000_007\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644344,
                "title": "java-solution-permutations-combinations",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numOfWays(int[] nums) {\\n        List<Integer> arr=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++) {\\n            arr.add(nums[i]);\\n        }\\n\\n        int n=nums.length;\\n        pascal=new long[n+1][n+1];\\n        pascal[0][0]=1;\\n        //nCr = n-1Cr-1 + n-1Cr\\n        for(int i=1; i<=n; i++) {\\n            pascal[i][0]=1;\\n            for(int j=1; j<i; j++) {\\n                pascal[i][j] = (pascal[i-1][j-1]+pascal[i-1][j])%MOD;\\n            }\\n            pascal[i][i]=1;\\n        }\\n        /*\\n        //print pascal\\'s triangle for debugging\\n        // for(int i=0;i<pascal.length;i++) \\n            // System.out.println(Arrays.toString(pascal[i]));\\n        */\\n\\n        return (int)(util(arr)-1);\\n    }\\n\\n    private final long MOD=(long)1e9+7;\\n\\n    //calculating nCR using pascal\\'s triangle because factorial will cause long overflow\\n    private long pascal[][];\\n    private long nCr(int n, int r) { \\n        return pascal[n][r];\\n    }\\n    \\n    private long util(List<Integer> arr) {\\n        if(arr.size()<=2) return 1;\\n\\n        List<Integer> left=new ArrayList<>();\\n        List<Integer> right=new ArrayList<>();\\n        int root=arr.get(0);\\n        for(int child: arr) {\\n            if(child==root) continue;\\n            if(child<root) {\\n                left.add(child);\\n            }else {\\n                right.add(child);\\n            }\\n        }\\n\\n        int x=left.size();\\n        int y=right.size();\\n        long combi=nCr(x+y, x)%MOD;\\n        long get=(util(left)*util(right))%MOD;\\n        long ret=(combi*get)%MOD;\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Combinatorics",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfWays(int[] nums) {\\n        List<Integer> arr=new ArrayList<>();\\n        for(int i=0; i<nums.length; i++) {\\n            arr.add(nums[i]);\\n        }\\n\\n        int n=nums.length;\\n        pascal=new long[n+1][n+1];\\n        pascal[0][0]=1;\\n        //nCr = n-1Cr-1 + n-1Cr\\n        for(int i=1; i<=n; i++) {\\n            pascal[i][0]=1;\\n            for(int j=1; j<i; j++) {\\n                pascal[i][j] = (pascal[i-1][j-1]+pascal[i-1][j])%MOD;\\n            }\\n            pascal[i][i]=1;\\n        }\\n        /*\\n        //print pascal\\'s triangle for debugging\\n        // for(int i=0;i<pascal.length;i++) \\n            // System.out.println(Arrays.toString(pascal[i]));\\n        */\\n\\n        return (int)(util(arr)-1);\\n    }\\n\\n    private final long MOD=(long)1e9+7;\\n\\n    //calculating nCR using pascal\\'s triangle because factorial will cause long overflow\\n    private long pascal[][];\\n    private long nCr(int n, int r) { \\n        return pascal[n][r];\\n    }\\n    \\n    private long util(List<Integer> arr) {\\n        if(arr.size()<=2) return 1;\\n\\n        List<Integer> left=new ArrayList<>();\\n        List<Integer> right=new ArrayList<>();\\n        int root=arr.get(0);\\n        for(int child: arr) {\\n            if(child==root) continue;\\n            if(child<root) {\\n                left.add(child);\\n            }else {\\n                right.add(child);\\n            }\\n        }\\n\\n        int x=left.size();\\n        int y=right.size();\\n        long combi=nCr(x+y, x)%MOD;\\n        long get=(util(left)*util(right))%MOD;\\n        long ret=(combi*get)%MOD;\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643407,
                "title": "c-dynamic-programming-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int combination(int k, int n, int mod) {\\n        if (k > n - k) k = n - k;\\n        vector<int> dp(k + 1);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = min(i, k); j > 0; --j) dp[j] = (dp[j] + dp[j - 1]) % mod;\\n        }\\n        return dp[k];\\n    }\\n    int dfs(vector<int> &A)  {\\n        if (A.size() <= 1) return 1;\\n        int root = A[0];\\n        vector<int> left, right;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (A[i] < root) left.push_back(A[i]);\\n            else right.push_back(A[i]);\\n        }\\n        return ((long)combination(left.size(), A.size() - 1, mod) * dfs(left)) % mod * dfs(right) % mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& A) {\\n        return (dfs(A) - 1 + mod) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    int combination(int k, int n, int mod) {\\n        if (k > n - k) k = n - k;\\n        vector<int> dp(k + 1);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = min(i, k); j > 0; --j) dp[j] = (dp[j] + dp[j - 1]) % mod;\\n        }\\n        return dp[k];\\n    }\\n    int dfs(vector<int> &A)  {\\n        if (A.size() <= 1) return 1;\\n        int root = A[0];\\n        vector<int> left, right;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (A[i] < root) left.push_back(A[i]);\\n            else right.push_back(A[i]);\\n        }\\n        return ((long)combination(left.size(), A.size() - 1, mod) * dfs(left)) % mod * dfs(right) % mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& A) {\\n        return (dfs(A) - 1 + mod) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643354,
                "title": "fastest-solution-yet",
                "content": "# Intuition\\nGiven an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.\\n\\nThe code works as follows:\\n1. It first defines a function ```cnr()``` that calculates the combination of two numbers. This function is used later in the code to calculate the number of ways to split a range of numbers into two smaller ranges.\\n\\n2. It then defines two arrays, ```leng``` and ```cnt```, which store the length and count of each range of numbers, respectively.\\n\\n3. It then iterates through the array ```nums``` in reverse order. For each number ```p```, it calculates the length of the range of numbers to the left of ```p``` (stored in ```h```) and the length of the range of numbers to the right of ```p``` (stored in ```k```).\\n\\n4. It then calculates the number of ways to split the range of numbers from ```p-h``` to ```p+k``` into two smaller ranges (left sub-tree and right sub-tree). This is done by multiplying the count of the range of numbers to the left of ```p``` (stored in ```cnt[p-1]```), the count of the range of numbers to the right of ```p``` (stored in ```cnt[p+1]```), and the combination of ```h+k``` and ```h```.\\n\\n5. It then updates the length and count of the range of numbers from ```p-h``` to ```p+k``` to be ```h+k+1``` and ```t```, respectively.\\n\\n6. It repeats steps 3-5 for each number in ```nums```.\\n\\n7. It then returns the count of the range of numbers from ```1 to n```, which is stored in ```cnt[1]```.\\n\\n\\n\\n\\n# Approach\\nUse bottom-up recursion with merge interval.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$. This is because the code iterates through the array nums once, and for each number in the array, it calculates the length and count of the range of numbers to the left and right of the number. The space complexity of the code is O(n), because it stores the arrays leng and cnt.\\n\\n- Space complexity:$$O(n^2)$$.  This is because the two arrays leng and cnt both have a size of n+2, and each element in the arrays takes up constant space. Therefore, the total space complexity is O(n^2).\\n\\nHere is a breakdown of the space complexity of each of the two arrays:\\n\\n    - leng: This array stores the lengths of the intervals that have been processed so far. The size of this array is n+2 because we need to store the lengths of all intervals, including the empty interval at the beginning and end.\\n    \\n    - cnt: This array stores the number of ways to partition the intervals that have been processed so far. The size of this array is also n+2 because we need to store the number of ways to partition all intervals, including the empty partition at the beginning and end.\\n\\n\\nThe total space complexity is then the sum of the space complexities of the two arrays, which is O(n^2).\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        mod = 1000000007\\n        n = len(nums)\\n\\n\\n        # stores the length of each range of numbers, respectively.\\n        leng = [0]*(n+2) \\n\\n        # stores the count of each range of numbers, respectively.\\n        cnt = [1]*(n+2) \\n\\n        # Iterate the array in reverse order\\n        for p in nums[::-1]: \\n            # k consecutive values larger than p (on the left) are already in BST if leng[p+1] > 0 indicates that. Length [p+1] and h are the respective integers in the right child BST of p.\\n            h,k = leng[p-1],leng[p+1] \\n\\n            # The size of the BST rooted at p should be used to update the lengths at the rightmost and leftmost numbers in the BST (consecutive intervals). Because it won\\'t be needed in the subsequent computation of length and cnt, the numbers in between (p-h, p+k) don\\'t need to be updated.\\n            leng[p-h]=leng[p+k]=h+k+1 \\n\\n            # The number of permutated arrays that can construct the BST of the left child and the right child of p is given by dp(BST rooted at p) = dp(left(p-1))*dp(right(p+1))*C(left+right,right).\\n            t = (cnt[p-1]*cnt[p+1]%mod)*comb(h+k,h)%mod \\n\\n            # Only the cnt\\'s rightmost and leftmost elements should be updated because those two numbers will be the only ones used in the next merge interval.\\n            cnt[p-h]=cnt[p+k]=t \\n\\n            # return the number of ways to reorder nums\\n        return (cnt[1]-1)%mod           \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Binary Search Tree",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```cnr()```\n```leng```\n```cnt```\n```nums```\n```p```\n```p```\n```h```\n```p```\n```k```\n```p-h```\n```p+k```\n```p```\n```cnt[p-1]```\n```p```\n```cnt[p+1]```\n```h+k```\n```h```\n```p-h```\n```p+k```\n```h+k+1```\n```t```\n```nums```\n```1 to n```\n```cnt[1]```\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        mod = 1000000007\\n        n = len(nums)\\n\\n\\n        # stores the length of each range of numbers, respectively.\\n        leng = [0]*(n+2) \\n\\n        # stores the count of each range of numbers, respectively.\\n        cnt = [1]*(n+2) \\n\\n        # Iterate the array in reverse order\\n        for p in nums[::-1]: \\n            # k consecutive values larger than p (on the left) are already in BST if leng[p+1] > 0 indicates that. Length [p+1] and h are the respective integers in the right child BST of p.\\n            h,k = leng[p-1],leng[p+1] \\n\\n            # The size of the BST rooted at p should be used to update the lengths at the rightmost and leftmost numbers in the BST (consecutive intervals). Because it won\\'t be needed in the subsequent computation of length and cnt, the numbers in between (p-h, p+k) don\\'t need to be updated.\\n            leng[p-h]=leng[p+k]=h+k+1 \\n\\n            # The number of permutated arrays that can construct the BST of the left child and the right child of p is given by dp(BST rooted at p) = dp(left(p-1))*dp(right(p+1))*C(left+right,right).\\n            t = (cnt[p-1]*cnt[p+1]%mod)*comb(h+k,h)%mod \\n\\n            # Only the cnt\\'s rightmost and leftmost elements should be updated because those two numbers will be the only ones used in the next merge interval.\\n            cnt[p-h]=cnt[p+k]=t \\n\\n            # return the number of ways to reorder nums\\n        return (cnt[1]-1)%mod           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463012,
                "title": "c-o-n-2-but-easy-to-understand",
                "content": "# Intuition\\nThe problem asks us to find the number of ways to reorder an input array nums such that a binary search tree (BST) constructed from the reordered array is identical to the BST formed from the original array. This problem can be solved by first understanding the properties of a BST, and then using dynamic programming to recursively count the number of ways to construct the BST.\\n\\n# Approach\\nWe can start by observing that the root of the BST should always be the first element, let\\'s call it `ref_val`. We can then partition the remaining elements of nums into two subarrays - one containing the elements smaller than the root, let\\'s call it `x`, and the other containing the elements greater than the root, let\\'s call it `y`. \\n\\nNow, for the BST construction to be valid, we can merge `x` and `y` in any order as long as we maintain the relative order within `x` and `y`. In other words, if we keep the relative order in `x` and `y`, however we choose to merge `x` and `y`, it is a valid answer. The number of ways to merge `x` and `y` can be calculated using the binomial coefficient (n choose k), where n is the total number of elements in x and y, and k is the number of elements in any of subarrays (since $$ncr(x+y,x) = ncr(x+y,y)$$). \\nThis yields to: \\n$$result = ncr(x.size()+y.size(), x.size())$$\\nas the `result` would be a very large number, we utilize `nCrModp` to calculate a moded `ncr`. \\n\\n*BUT*, there is an issue in the solution, what if `x` or `y` could be reordered and again BST construction would be the same? We should multiply previously calculated `result` by number of possible reorders of `x` and `y` and this is done by recursively calling `numOfWays` on `x` and `y` to calculate `multiply_factor`\\n\\nNotice that we counted ALL possible ways including the one in the input, so we should subtract final result by one to get correct answer.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\nThe time complexity of the solution is $$O(n^2)$$, where `n` is the length of the input array `nums`. This is because the `numOfWays` function recursively calls itself on the subarrays of `nums`, and the size of the subarrays being processed in each recursive call can be as large as `n`. In addition, the `nCrModp` function used to calculate the binomial coefficient has a time complexity of $$O(r)$$, where r is the size of the smaller subarray, which can also be as large as `n`.\\n\\n- Space complexity: $$O(n^2)$$\\n\\nThe space complexity of the solution is also $$O(n^2)$$, as the `nCrModp` function uses an array of size `r+1`, where `r` is the size of the smaller subarray, which can again be as large as `n`. In addition, the recursive calls to `numOfWays` create additional space for the call stack.\\n# Code\\n```\\n#define ll long long\\n#define MOD ((ll) (1e9+7))\\n\\nclass Solution {\\npublic:\\n    // https://www.geeksforgeeks.org/introduction-and-dynamic-programming-solution-to-compute-ncrp/\\n    // Returns nCr % p\\n    ll nCrModp(ll n, ll r, ll p)\\n    {\\n        // Optimization for the cases when r is large\\n        if (r > n - r)\\n            r = n - r;\\n    \\n        // The array C is going to store last row of\\n        // pascal triangle at the end. And last entry\\n        // of last row is nCr\\n        ll C[r + 1];\\n        memset(C, 0, sizeof(C));\\n    \\n        C[0] = 1; // Top row of Pascal Triangle\\n    \\n        // One by constructs remaining rows of Pascal\\n        // Triangle from top to bottom\\n        for (ll i = 1; i <= n; i++) {\\n    \\n            // Fill entries of current row using previous\\n            // row values\\n            for (ll j = min(i, r); j > 0; j--)\\n    \\n                // nCj = (n-1)Cj + (n-1)C(j-1);\\n                C[j] = (C[j] + C[j - 1]) % p;\\n        }\\n        return C[r];\\n    }\\n  \\n    int numOfWays(vector<int>& nums) {\\n        if(nums.size() < 1 ) return 0;\\n\\n        int ref_val=nums[0];\\n        vector<int> greater_than, smaller_than;\\n\\n        //dividing to smaller and bigger vector\\n        for(auto &a:nums){\\n            if(a<ref_val) smaller_than.push_back(a); \\n            else if(a>ref_val) greater_than.push_back(a); \\n        }\\n\\n        //FOR THE SAKE OF SIMPLICTY, EXTRA VARIABLES ARE CREATED\\n\\n        //counting how many ways we can reorder `smaller_than` and `greater_than` themselves \\n        ll multiply_factor=1ll*(numOfWays(smaller_than)+1)*(numOfWays(greater_than)+1);\\n        \\n        //keeping moded value of `multiply_factor` as result\\n        ll result = multiply_factor % MOD;\\n\\n        //counting how many ways we can merge `smaller_than` and `greater_than`, and multipling it by result \\n        result*= nCrModp(smaller_than.size()+ greater_than.size(), smaller_than.size(), MOD);\\n\\n        //subtracting input from all possible values and return final result\\n        return (result-1)%MOD;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\n#define ll long long\\n#define MOD ((ll) (1e9+7))\\n\\nclass Solution {\\npublic:\\n    // https://www.geeksforgeeks.org/introduction-and-dynamic-programming-solution-to-compute-ncrp/\\n    // Returns nCr % p\\n    ll nCrModp(ll n, ll r, ll p)\\n    {\\n        // Optimization for the cases when r is large\\n        if (r > n - r)\\n            r = n - r;\\n    \\n        // The array C is going to store last row of\\n        // pascal triangle at the end. And last entry\\n        // of last row is nCr\\n        ll C[r + 1];\\n        memset(C, 0, sizeof(C));\\n    \\n        C[0] = 1; // Top row of Pascal Triangle\\n    \\n        // One by constructs remaining rows of Pascal\\n        // Triangle from top to bottom\\n        for (ll i = 1; i <= n; i++) {\\n    \\n            // Fill entries of current row using previous\\n            // row values\\n            for (ll j = min(i, r); j > 0; j--)\\n    \\n                // nCj = (n-1)Cj + (n-1)C(j-1);\\n                C[j] = (C[j] + C[j - 1]) % p;\\n        }\\n        return C[r];\\n    }\\n  \\n    int numOfWays(vector<int>& nums) {\\n        if(nums.size() < 1 ) return 0;\\n\\n        int ref_val=nums[0];\\n        vector<int> greater_than, smaller_than;\\n\\n        //dividing to smaller and bigger vector\\n        for(auto &a:nums){\\n            if(a<ref_val) smaller_than.push_back(a); \\n            else if(a>ref_val) greater_than.push_back(a); \\n        }\\n\\n        //FOR THE SAKE OF SIMPLICTY, EXTRA VARIABLES ARE CREATED\\n\\n        //counting how many ways we can reorder `smaller_than` and `greater_than` themselves \\n        ll multiply_factor=1ll*(numOfWays(smaller_than)+1)*(numOfWays(greater_than)+1);\\n        \\n        //keeping moded value of `multiply_factor` as result\\n        ll result = multiply_factor % MOD;\\n\\n        //counting how many ways we can merge `smaller_than` and `greater_than`, and multipling it by result \\n        result*= nCrModp(smaller_than.size()+ greater_than.size(), smaller_than.size(), MOD);\\n\\n        //subtracting input from all possible values and return final result\\n        return (result-1)%MOD;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085262,
                "title": "c-simple-and-short-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    long inverse(long num) {\\n        if (num == 1) {\\n            return 1;\\n        }\\n        return mod - mod / num * inverse(mod % num) % mod;\\n    }\\n\\n    int dfs(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 2) {\\n            return 1;\\n        }\\n        vector<int> left, right;\\n        for (int i = 1; i < N; i++) {\\n            if (nums[i] < nums[0]) {\\n                left.push_back(nums[i]);\\n            } else {\\n                right.push_back(nums[i]);\\n            }\\n        }\\n\\n        int a = left.size();\\n        int b = right.size();\\n        long res = 1;\\n\\n        // relative order between left and right\\n        // (a+b)! / (b! * a!)\\n        for (int i = b+1; i <= a + b; i++) {\\n            res = res * i % mod;\\n        }\\n        for (int i = 1; i <= a; i++) {\\n            // res * inverse(i) == res / i\\n            res = res * inverse(i) % mod;\\n        }\\n\\n         // order within left: dfs(left)\\n         // order within right: dfs(right)\\n        return res * dfs(left) % mod * dfs(right) % mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        return dfs(nums) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    long inverse(long num) {\\n        if (num == 1) {\\n            return 1;\\n        }\\n        return mod - mod / num * inverse(mod % num) % mod;\\n    }\\n\\n    int dfs(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 2) {\\n            return 1;\\n        }\\n        vector<int> left, right;\\n        for (int i = 1; i < N; i++) {\\n            if (nums[i] < nums[0]) {\\n                left.push_back(nums[i]);\\n            } else {\\n                right.push_back(nums[i]);\\n            }\\n        }\\n\\n        int a = left.size();\\n        int b = right.size();\\n        long res = 1;\\n\\n        // relative order between left and right\\n        // (a+b)! / (b! * a!)\\n        for (int i = b+1; i <= a + b; i++) {\\n            res = res * i % mod;\\n        }\\n        for (int i = 1; i <= a; i++) {\\n            // res * inverse(i) == res / i\\n            res = res * inverse(i) % mod;\\n        }\\n\\n         // order within left: dfs(left)\\n         // order within right: dfs(right)\\n        return res * dfs(left) % mod * dfs(right) % mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        return dfs(nums) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938080,
                "title": "python3-solution-combination",
                "content": "# Code\\n```\\nclass Solution:\\n    def numOfWays(self, A):\\n        n = len(A)\\n        mod = 10 ** 9 + 7\\n        def dfs(i, l, h):\\n            if h == l + 1: return 1\\n            if l < A[i] < h:\\n                return (dfs(i + 1, l, A[i]) * dfs(i + 1, A[i], h) * math.comb(h - l - 2, A[i] - l - 1)) % mod\\n            return dfs(i + 1, l, h)\\n        return dfs(0, 0, n + 1) - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, A):\\n        n = len(A)\\n        mod = 10 ** 9 + 7\\n        def dfs(i, l, h):\\n            if h == l + 1: return 1\\n            if l < A[i] < h:\\n                return (dfs(i + 1, l, A[i]) * dfs(i + 1, A[i], h) * math.comb(h - l - 2, A[i] - l - 1)) % mod\\n            return dfs(i + 1, l, h)\\n        return dfs(0, 0, n + 1) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484798,
                "title": "java-recursive-solution-88-fast",
                "content": "```  \\npublic class Solution {\\n    private Map<TreeNode, Integer> map;\\n    private int mod = 1000000007;\\n    \\n    public Solution() {\\n        map = new HashMap<>();\\n    }\\n    class TreeNode {\\n        public int val;\\n        public TreeNode left;\\n        public TreeNode right;\\n\\n        public TreeNode(int val) {\\n            this.val = val;\\n            left = null;\\n            right = null;\\n        }\\n    }\\n\\n    public int numOfWays(int[] nums) {\\n        TreeNode root = buildTree(nums);\\n        return (int) (numOfWays(root) % mod) - 1;\\n    }\\n    \\n    private long numOfWays(TreeNode node) {\\n        if (node == null)\\n            return 1;\\n        int n = numOfNodes(node.left);\\n        int m = numOfNodes(node.right);\\n        \\n        return ((((binomialCoeff(n + m, n) % mod) * numOfWays(node.left)) % mod) * numOfWays(node.right)) % mod;\\n    }\\n\\n\\t// calulate the number of descendants of this node including the node itself\\n    private int numOfNodes(TreeNode node) {\\n\\t\\t// dp to decrease the runtime\\n        if (map.containsKey(node))\\n            return map.get(node);\\n        if (node == null) \\n            return 0;\\n        \\n        int num = 1 + numOfNodes(node.left) + numOfNodes(node.right);\\n        map.put(node, num);\\n        return num;\\n    }\\n    \\n\\t// method to calculate the value of nCk\\n    private int binomialCoeff(int n, int k) {\\n        int[] c = new int[k + 1];\\n        c[0] = 1;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = Math.min(i, k); j > 0; j--) \\n                c[j] = (c[j] + c[j - 1]) % mod;\\n        }\\n        return c[k] % mod;\\n    }\\n\\n  \\n    private TreeNode buildTree(int[] nums) {\\n        TreeNode tree = null;\\n        for (int num : nums)\\n            tree = insert(tree, num);\\n        return tree;\\n    }\\n\\n    private TreeNode insert(TreeNode root, int val) {\\n        if (root == null)\\n            return new TreeNode(val);\\n\\n        if (val < root.val)\\n            root.left = insert(root.left, val);\\n        else if (val > root.val)\\n            root.right = insert(root.right, val);\\n\\n        return root;\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "```  \\npublic class Solution {\\n    private Map<TreeNode, Integer> map;\\n    private int mod = 1000000007;\\n    \\n    public Solution() {\\n        map = new HashMap<>();\\n    }\\n    class TreeNode {\\n        public int val;\\n        public TreeNode left;\\n        public TreeNode right;\\n\\n        public TreeNode(int val) {\\n            this.val = val;\\n            left = null;\\n            right = null;\\n        }\\n    }\\n\\n    public int numOfWays(int[] nums) {\\n        TreeNode root = buildTree(nums);\\n        return (int) (numOfWays(root) % mod) - 1;\\n    }\\n    \\n    private long numOfWays(TreeNode node) {\\n        if (node == null)\\n            return 1;\\n        int n = numOfNodes(node.left);\\n        int m = numOfNodes(node.right);\\n        \\n        return ((((binomialCoeff(n + m, n) % mod) * numOfWays(node.left)) % mod) * numOfWays(node.right)) % mod;\\n    }\\n\\n\\t// calulate the number of descendants of this node including the node itself\\n    private int numOfNodes(TreeNode node) {\\n\\t\\t// dp to decrease the runtime\\n        if (map.containsKey(node))\\n            return map.get(node);\\n        if (node == null) \\n            return 0;\\n        \\n        int num = 1 + numOfNodes(node.left) + numOfNodes(node.right);\\n        map.put(node, num);\\n        return num;\\n    }\\n    \\n\\t// method to calculate the value of nCk\\n    private int binomialCoeff(int n, int k) {\\n        int[] c = new int[k + 1];\\n        c[0] = 1;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = Math.min(i, k); j > 0; j--) \\n                c[j] = (c[j] + c[j - 1]) % mod;\\n        }\\n        return c[k] % mod;\\n    }\\n\\n  \\n    private TreeNode buildTree(int[] nums) {\\n        TreeNode tree = null;\\n        for (int num : nums)\\n            tree = insert(tree, num);\\n        return tree;\\n    }\\n\\n    private TreeNode insert(TreeNode root, int val) {\\n        if (root == null)\\n            return new TreeNode(val);\\n\\n        if (val < root.val)\\n            root.left = insert(root.left, val);\\n        else if (val > root.val)\\n            root.right = insert(root.right, val);\\n\\n        return root;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652710,
                "title": "javascript-solution-recursion-combination",
                "content": "```\\nvar numOfWays = function(nums) {\\n    const x = numOfWaysHelper(nums) - 1n;\\n    return x % 1_000_000_007n;\\n}\\nvar numOfWaysHelper = function(nums) {\\n    if(nums.length < 3)\\n        return 1n;\\n    \\n    const root  = nums[0];\\n    const left  = nums.filter(p => p < root);\\n    const right = nums.filter(p => p > root);\\n    return BigInt(comb(left.length + right.length, left.length) * numOfWaysHelper(left) * numOfWaysHelper(right));\\n};\\n\\nfunction comb(n, k){\\n    n = BigInt(n);\\n    k = BigInt(k);\\n    if(n < 2)\\n        return 1n;\\n    return fact(n)/fact(n-k)/fact(k);\\n}\\n\\nconst factCache = new Map();\\n\\nfunction fact(n){\\n    if(n<2)\\n        return 1n;\\n    if(factCache.has(n))\\n        return factCache.get(n);\\n    \\n    var result = BigInt(n) * fact(n - 1n);\\n    factCache.set(n, result);\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numOfWays = function(nums) {\\n    const x = numOfWaysHelper(nums) - 1n;\\n    return x % 1_000_000_007n;\\n}\\nvar numOfWaysHelper = function(nums) {\\n    if(nums.length < 3)\\n        return 1n;\\n    \\n    const root  = nums[0];\\n    const left  = nums.filter(p => p < root);\\n    const right = nums.filter(p => p > root);\\n    return BigInt(comb(left.length + right.length, left.length) * numOfWaysHelper(left) * numOfWaysHelper(right));\\n};\\n\\nfunction comb(n, k){\\n    n = BigInt(n);\\n    k = BigInt(k);\\n    if(n < 2)\\n        return 1n;\\n    return fact(n)/fact(n-k)/fact(k);\\n}\\n\\nconst factCache = new Map();\\n\\nfunction fact(n){\\n    if(n<2)\\n        return 1n;\\n    if(factCache.has(n))\\n        return factCache.get(n);\\n    \\n    var result = BigInt(n) * fact(n - 1n);\\n    factCache.set(n, result);\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1258932,
                "title": "python3-solution",
                "content": "```\\nclass node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n\\nclass Solution:\\n    def BST(self, root, cur):\\n        if cur.val < root.val:\\n            if root.left == None:\\n                root.left = cur\\n                return\\n            else:\\n                self.BST(root.left, cur)\\n        elif cur.val > root.val:\\n            if root.right == None:\\n                root.right = cur\\n                return\\n            else:\\n                self.BST(root.right, cur)\\n    \\n    def solve(self, root):\\n        if root.left == None and root.right == None:\\n            return 1\\n        left = 0 ; right = 0\\n        if root.left is not None:\\n            left = self.solve(root.left)\\n        if root.right is not None:\\n            right = self.solve(root.right)\\n        self.total *= math.comb(left + right, left)\\n        return left + right + 1\\n    \\n    def numOfWays(self, nums: List[int]) -> int:\\n        import math\\n        self.total = 1\\n        root = node(nums[0])\\n        for i in range(1, len(nums)):\\n            self.BST(root, node(nums[i]))\\n        self.solve(root)\\n        return (self.total - 1) % (int(1e9) + 7)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n\\nclass Solution:\\n    def BST(self, root, cur):\\n        if cur.val < root.val:\\n            if root.left == None:\\n                root.left = cur\\n                return\\n            else:\\n                self.BST(root.left, cur)\\n        elif cur.val > root.val:\\n            if root.right == None:\\n                root.right = cur\\n                return\\n            else:\\n                self.BST(root.right, cur)\\n    \\n    def solve(self, root):\\n        if root.left == None and root.right == None:\\n            return 1\\n        left = 0 ; right = 0\\n        if root.left is not None:\\n            left = self.solve(root.left)\\n        if root.right is not None:\\n            right = self.solve(root.right)\\n        self.total *= math.comb(left + right, left)\\n        return left + right + 1\\n    \\n    def numOfWays(self, nums: List[int]) -> int:\\n        import math\\n        self.total = 1\\n        root = node(nums[0])\\n        for i in range(1, len(nums)):\\n            self.BST(root, node(nums[i]))\\n        self.solve(root)\\n        return (self.total - 1) % (int(1e9) + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224631,
                "title": "c-algebra-module-inverse-comb-n-k",
                "content": "```\\nclass Solution {\\n    const int64_t MOD = 1000000007;\\n    \\n    int64_t comb(int N, int K) {\\n        int64_t nx = 1;\\n        // i!\\n        for (int64_t i = 2; i <= N; ++i) nx = nx * i % MOD;\\n\\n        const int M = max(K, N - K) + 1;\\n        vector<int64_t> inv(M, 0), inv_kx(M, 0);\\n        inv[0] = inv_kx[0] = inv[1] = inv_kx[1] = 1;\\n        // https://cp-algorithms.com/algebra/module-inverse.html\\n        // 1 / i!\\n        for (int64_t i = 2; i < M; ++i) {\\n            inv[i] = MOD - (MOD / i) * inv[MOD % i] % MOD;\\n            inv_kx[i] = inv_kx[i - 1] * inv[i] % MOD;\\n            // cout << i << \":\" << inv_kx[i] << \"  \";\\n        }\\n        \\n        // N! / (K! * (N - K)!)\\n        return nx * inv_kx[K] % MOD * inv_kx[N - K] % MOD;\\n    }\\n    \\n    int64_t ways(vector<int>& nums) {\\n        if (nums.size() <= 2) return 1;\\n        \\n        vector<int> l, r;\\n        for (int i = 1; i < nums.size(); ++i)\\n            nums[i] < nums[0] ? l.push_back(nums[i]) : r.push_back(nums[i]);\\n        int64_t c = comb(l.size() + r.size(), l.size()), lw = ways(l), rw = ways(r);\\n        return c * lw % MOD * rw % MOD;\\n    }\\n    \\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        // root = nums[0]\\n        // l[i] < root; r[i] > root\\n        // comb(l.size + r.size, l.size) * numOfWays(l) * numOfWays(r) - 1\\n        \\n        return ways(nums) - 1; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int64_t MOD = 1000000007;\\n    \\n    int64_t comb(int N, int K) {\\n        int64_t nx = 1;\\n        // i!\\n        for (int64_t i = 2; i <= N; ++i) nx = nx * i % MOD;\\n\\n        const int M = max(K, N - K) + 1;\\n        vector<int64_t> inv(M, 0), inv_kx(M, 0);\\n        inv[0] = inv_kx[0] = inv[1] = inv_kx[1] = 1;\\n        // https://cp-algorithms.com/algebra/module-inverse.html\\n        // 1 / i!\\n        for (int64_t i = 2; i < M; ++i) {\\n            inv[i] = MOD - (MOD / i) * inv[MOD % i] % MOD;\\n            inv_kx[i] = inv_kx[i - 1] * inv[i] % MOD;\\n            // cout << i << \":\" << inv_kx[i] << \"  \";\\n        }\\n        \\n        // N! / (K! * (N - K)!)\\n        return nx * inv_kx[K] % MOD * inv_kx[N - K] % MOD;\\n    }\\n    \\n    int64_t ways(vector<int>& nums) {\\n        if (nums.size() <= 2) return 1;\\n        \\n        vector<int> l, r;\\n        for (int i = 1; i < nums.size(); ++i)\\n            nums[i] < nums[0] ? l.push_back(nums[i]) : r.push_back(nums[i]);\\n        int64_t c = comb(l.size() + r.size(), l.size()), lw = ways(l), rw = ways(r);\\n        return c * lw % MOD * rw % MOD;\\n    }\\n    \\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        // root = nums[0]\\n        // l[i] < root; r[i] > root\\n        // comb(l.size + r.size, l.size) * numOfWays(l) * numOfWays(r) - 1\\n        \\n        return ways(nums) - 1; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 931515,
                "title": "java-bottom-up-dp-recursion-o-n-2-time-complexity",
                "content": "```\\n/*\\n\\nSuppose we have \\'m\\' elements in one array and \\'n\\' elements in another and we need to arrange \\'n\\' elemnts around \\'m\\' elements of first array without breaking the order of elements in any of the arrays.\\n\\narray first = _ l1 _ l2 _ l3 _ ..... _ li-2 _ li-1 _ li _ li+1 _ ..... _ lm-2 _ lm-1 _ lm _\\n\\narray second = r1 r2 r3 ..... rj-2 rj-1 rj rj+1 ..... rn-1 rn\\n\\nLet DP[i][j] = # of ways to arrange \\'j\\'th elements of second array around \\'i\\' elements of first array without breaking the order of elements in any of the arrays.\\n\\nFor placing the \\'j\\'th element (rj) of second array we have DP[i][j - 1] ways as \\'j\\'th element will follow order and will be placed only after \\'j-1\\'th element.\\nAnd this \\'j\\' element could have occurred after \\'i\\'th element (li) of first array or after \\'i-1\\'th element (li-1) of first array or after \\'i-2\\'th element (li-2) of first array and so on.\\n\\nHence, we have\\nDP[i][j] = DP[i][j - 1] + DP[i - 1][j - 1] + DP[i - 2][j - 1] + ..... + DP[0][j - 1] ; i E [1, m], j E [1, n], k E [0, i]\\n\\nIn General :\\nDP[i][j] = sum(DP[i - k][j - 1])                                                     ; i E [1, m], j E [1, n], k E [0, i]\\nDP[i][j] = 1                                                                         ; i == 0, j E [1, n]\\nDP[i][j] = 1                                                                         ; i [1, m], j == 0\\n\\nresult = use DP to get solution by calling recursively for each subtree and multiply each combination.\\nThen \\'1\\' is subtrated as we already have one combination given as input.\\n\\n-----------------------------------------------------------------------------------------------------------------\\n\\nMore formally :\\nDP[i][j] = DP[i][j - 1] + DP[i - 1][j - 1] + DP[i - 2][j - 1] + ..... + DP[1][j - 1] + DP[0][j - 1] ; ..... (equation 1)\\n\\nPut \\'i-1\\' in place of \\'i\\' to get DP[i - 1][j]\\nDP[i - 1][j] = DP[i - 1][j - 1] + DP[i - 2][j - 1] + DP[i - 3][j - 1] + ..... + DP[1][j - 1] + DP[0][j - 1] ; ..... (equation 2)\\n\\nSubtracting both above equations, we get\\n(equation 1) - (equation 2)\\n=> DP[i][j] - DP[i - 1][j] = DP[i][j - 1] ;\\n=> DP[i][j] = DP[i][j - 1] + DP[i - 1][j] ;\\n\\n-----------------------------------------------------------------------------------------------------------------\\n\\nFinal equations :\\nDP[i][j] = DP[i][j - 1] + DP[i - 1][j] ; i E [1, m], j E [1, n] ----- here m and n both are equal to length of the input array\\nDP[i][j] = 1                           ; i == 0, j E [1, n]\\nDP[i][j] = 1                           ; i [1, m], j == 0\\n\\nresult = use DP to get solution by calling recursively for each subtree and multiply each combination. Then \\'1\\' is subtrated as we already have one combination given as input.\\n\\n*/\\n\\nclass Solution {\\n    public int numOfWays(int[] nums) {\\n        int length = nums.length, MOD = 1000000007;\\n        long[][] DP = new long[length + 1][length + 1];\\n        for(int j = 0; j <= length; j++) {\\n            DP[0][j] = 1;\\n        }\\n        for(int i = 0; i <= length; i++) {\\n            DP[i][0] = 1;\\n        }\\n        for(int i = 1; i <= length; i++) {\\n            for(int j = 1; j <= length; j++) {\\n                DP[i][j] = ((DP[i][j - 1] + DP[i - 1][j]) % MOD);\\n            }\\n        }\\n        return ((int) getNumberOfWays(nums, DP) - 1);\\n    }\\n\\n    private long getNumberOfWays(int[] nums, long[][] DP) {\\n        int length = nums.length, m = 0, n = 0, MOD = 1000000007;\\n        if(length == 0) {\\n            return 1;\\n        }\\n        for(int i = 2; i <= length; i++) {\\n            if(nums[i - 1] < nums[0]) {\\n                m++;\\n            } else {\\n                n++;\\n            }\\n        }\\n        int[] leftNodes = new int[m];\\n        int[] rightNodes = new int[n];\\n        m = 0;\\n        n = 0;\\n        for(int i = 2; i <= length; i++) {\\n            if(nums[i - 1] < nums[0]) {\\n                leftNodes[m++] = nums[i - 1];\\n            } else {\\n                rightNodes[n++] = nums[i - 1];\\n            }\\n        }\\n        return (((DP[m][n] * getNumberOfWays(leftNodes, DP) % MOD) * getNumberOfWays(rightNodes, DP)) % MOD);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\nSuppose we have \\'m\\' elements in one array and \\'n\\' elements in another and we need to arrange \\'n\\' elemnts around \\'m\\' elements of first array without breaking the order of elements in any of the arrays.\\n\\narray first = _ l1 _ l2 _ l3 _ ..... _ li-2 _ li-1 _ li _ li+1 _ ..... _ lm-2 _ lm-1 _ lm _\\n\\narray second = r1 r2 r3 ..... rj-2 rj-1 rj rj+1 ..... rn-1 rn\\n\\nLet DP[i][j] = # of ways to arrange \\'j\\'th elements of second array around \\'i\\' elements of first array without breaking the order of elements in any of the arrays.\\n\\nFor placing the \\'j\\'th element (rj) of second array we have DP[i][j - 1] ways as \\'j\\'th element will follow order and will be placed only after \\'j-1\\'th element.\\nAnd this \\'j\\' element could have occurred after \\'i\\'th element (li) of first array or after \\'i-1\\'th element (li-1) of first array or after \\'i-2\\'th element (li-2) of first array and so on.\\n\\nHence, we have\\nDP[i][j] = DP[i][j - 1] + DP[i - 1][j - 1] + DP[i - 2][j - 1] + ..... + DP[0][j - 1] ; i E [1, m], j E [1, n], k E [0, i]\\n\\nIn General :\\nDP[i][j] = sum(DP[i - k][j - 1])                                                     ; i E [1, m], j E [1, n], k E [0, i]\\nDP[i][j] = 1                                                                         ; i == 0, j E [1, n]\\nDP[i][j] = 1                                                                         ; i [1, m], j == 0\\n\\nresult = use DP to get solution by calling recursively for each subtree and multiply each combination.\\nThen \\'1\\' is subtrated as we already have one combination given as input.\\n\\n-----------------------------------------------------------------------------------------------------------------\\n\\nMore formally :\\nDP[i][j] = DP[i][j - 1] + DP[i - 1][j - 1] + DP[i - 2][j - 1] + ..... + DP[1][j - 1] + DP[0][j - 1] ; ..... (equation 1)\\n\\nPut \\'i-1\\' in place of \\'i\\' to get DP[i - 1][j]\\nDP[i - 1][j] = DP[i - 1][j - 1] + DP[i - 2][j - 1] + DP[i - 3][j - 1] + ..... + DP[1][j - 1] + DP[0][j - 1] ; ..... (equation 2)\\n\\nSubtracting both above equations, we get\\n(equation 1) - (equation 2)\\n=> DP[i][j] - DP[i - 1][j] = DP[i][j - 1] ;\\n=> DP[i][j] = DP[i][j - 1] + DP[i - 1][j] ;\\n\\n-----------------------------------------------------------------------------------------------------------------\\n\\nFinal equations :\\nDP[i][j] = DP[i][j - 1] + DP[i - 1][j] ; i E [1, m], j E [1, n] ----- here m and n both are equal to length of the input array\\nDP[i][j] = 1                           ; i == 0, j E [1, n]\\nDP[i][j] = 1                           ; i [1, m], j == 0\\n\\nresult = use DP to get solution by calling recursively for each subtree and multiply each combination. Then \\'1\\' is subtrated as we already have one combination given as input.\\n\\n*/\\n\\nclass Solution {\\n    public int numOfWays(int[] nums) {\\n        int length = nums.length, MOD = 1000000007;\\n        long[][] DP = new long[length + 1][length + 1];\\n        for(int j = 0; j <= length; j++) {\\n            DP[0][j] = 1;\\n        }\\n        for(int i = 0; i <= length; i++) {\\n            DP[i][0] = 1;\\n        }\\n        for(int i = 1; i <= length; i++) {\\n            for(int j = 1; j <= length; j++) {\\n                DP[i][j] = ((DP[i][j - 1] + DP[i - 1][j]) % MOD);\\n            }\\n        }\\n        return ((int) getNumberOfWays(nums, DP) - 1);\\n    }\\n\\n    private long getNumberOfWays(int[] nums, long[][] DP) {\\n        int length = nums.length, m = 0, n = 0, MOD = 1000000007;\\n        if(length == 0) {\\n            return 1;\\n        }\\n        for(int i = 2; i <= length; i++) {\\n            if(nums[i - 1] < nums[0]) {\\n                m++;\\n            } else {\\n                n++;\\n            }\\n        }\\n        int[] leftNodes = new int[m];\\n        int[] rightNodes = new int[n];\\n        m = 0;\\n        n = 0;\\n        for(int i = 2; i <= length; i++) {\\n            if(nums[i - 1] < nums[0]) {\\n                leftNodes[m++] = nums[i - 1];\\n            } else {\\n                rightNodes[n++] = nums[i - 1];\\n            }\\n        }\\n        return (((DP[m][n] * getNumberOfWays(leftNodes, DP) % MOD) * getNumberOfWays(rightNodes, DP)) % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820580,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector < vector < long long > > pascal;\\n    int MOD = 1e9 + 7;\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int N = nums.size();\\n        pascal = vector < vector < long long > > (N + 1);\\n        for (int i = 0; i < N + 1; i ++){\\n            pascal[i] = vector < long long > (i + 1, 1);\\n            for (int j = 1; j < i; j ++){\\n                pascal[i][j] = (pascal[i - 1][j] + pascal[i - 1][j - 1])%MOD;\\n            }\\n        }\\n        return dfs(nums) - 1;\\n    }\\n    \\n    int dfs(vector < int > nums){\\n        if (nums.size() <= 2)\\n            return 1;\\n        vector < int > left, right;\\n        for (int i = 1; i < int(nums.size()); i ++){\\n            if (nums[i] < nums[0])\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }\\n        return (((dfs(left) * pascal[nums.size() - 1][left.size()]) % MOD) * dfs(right))%MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector < vector < long long > > pascal;\\n    int MOD = 1e9 + 7;\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int N = nums.size();\\n        pascal = vector < vector < long long > > (N + 1);\\n        for (int i = 0; i < N + 1; i ++){\\n            pascal[i] = vector < long long > (i + 1, 1);\\n            for (int j = 1; j < i; j ++){\\n                pascal[i][j] = (pascal[i - 1][j] + pascal[i - 1][j - 1])%MOD;\\n            }\\n        }\\n        return dfs(nums) - 1;\\n    }\\n    \\n    int dfs(vector < int > nums){\\n        if (nums.size() <= 2)\\n            return 1;\\n        vector < int > left, right;\\n        for (int i = 1; i < int(nums.size()); i ++){\\n            if (nums[i] < nums[0])\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }\\n        return (((dfs(left) * pascal[nums.size() - 1][left.size()]) % MOD) * dfs(right))%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819378,
                "title": "c-explanation",
                "content": "Took me quite a while to get it, but the \\nnumber of ways to arrange nums = ways to arrange the numbers in the left subtree * ways to arrange numbers in right subtree * positions to fit the left/right subtree back into the original array\\n\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long power(long long a, long long b) {\\n        long long res=1;\\n        while (b>0) {\\n            if (b&1) res*=a, res%=mod;\\n            b/=2;\\n            a*=a;\\n            a%=mod;\\n        }\\n        return res;\\n    }\\n    long long choose(long long a, long long b) {\\n        long long res=1;\\n        for (long long i=1; i<=b; i++) {\\n            res*=(a-i+1);\\n            res%=mod;\\n            res*=power(i, mod-2);\\n            res%=mod;\\n        }\\n        return res;\\n    }\\n    long long solve(vector<int> nums) {\\n        if (nums.size()<=2) return 1;\\n        vector<int> left, right;\\n        for (int i=1; i<nums.size(); i++) {\\n            if (nums[i]<nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        return ((choose(nums.size()-1, right.size())*solve(right)%mod)*solve(left))%mod;\\n    }\\n    int numOfWays(vector<int> &nums) {\\n        return solve(nums)-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long long power(long long a, long long b) {\\n        long long res=1;\\n        while (b>0) {\\n            if (b&1) res*=a, res%=mod;\\n            b/=2;\\n            a*=a;\\n            a%=mod;\\n        }\\n        return res;\\n    }\\n    long long choose(long long a, long long b) {\\n        long long res=1;\\n        for (long long i=1; i<=b; i++) {\\n            res*=(a-i+1);\\n            res%=mod;\\n            res*=power(i, mod-2);\\n            res%=mod;\\n        }\\n        return res;\\n    }\\n    long long solve(vector<int> nums) {\\n        if (nums.size()<=2) return 1;\\n        vector<int> left, right;\\n        for (int i=1; i<nums.size(); i++) {\\n            if (nums[i]<nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        return ((choose(nums.size()-1, right.size())*solve(right)%mod)*solve(left))%mod;\\n    }\\n    int numOfWays(vector<int> &nums) {\\n        return solve(nums)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701916,
                "title": "combinations-dfs-c",
                "content": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    long dfs(vector<int> &nums, vector<vector<int>> &ncr) {\\n        int n = nums.size();\\n        if(n <= 2) return 1;\\n\\n        vector<int> l, r;\\n        for(int i=1; i<n; i++) {\\n            if(nums[i] < nums[0]) l.push_back(nums[i]);\\n            else r.push_back(nums[i]);\\n        }\\n\\n        long left = dfs(l, ncr) % mod;\\n        long right = dfs(r, ncr) % mod;\\n\\n        return ((ncr[n - 1][l.size()] * left) % mod * right) % mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ncr(n + 1, vector<int>(n + 1, 1));\\n\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<i; j++) {\\n                ncr[i][j] = (ncr[i - 1][j - 1] + ncr[i - 1][j]) % mod;\\n            }\\n        }\\n        \\n        return (dfs(nums, ncr) - 1) % mod;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    long dfs(vector<int> &nums, vector<vector<int>> &ncr) {\\n        int n = nums.size();\\n        if(n <= 2) return 1;\\n\\n        vector<int> l, r;\\n        for(int i=1; i<n; i++) {\\n            if(nums[i] < nums[0]) l.push_back(nums[i]);\\n            else r.push_back(nums[i]);\\n        }\\n\\n        long left = dfs(l, ncr) % mod;\\n        long right = dfs(r, ncr) % mod;\\n\\n        return ((ncr[n - 1][l.size()] * left) % mod * right) % mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ncr(n + 1, vector<int>(n + 1, 1));\\n\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<i; j++) {\\n                ncr[i][j] = (ncr[i - 1][j - 1] + ncr[i - 1][j]) % mod;\\n            }\\n        }\\n        \\n        return (dfs(nums, ncr) - 1) % mod;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649306,
                "title": "clear-explanation-of-an-easy-recursive-combinatorics-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs with most tree problems, we repeatedly explore the left and right subtrees of the tree to arrive at our solution. In this case, we look at how many permutations of a subtree array correspond to the same subtree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter noting that the first element in the array is the root of the (sub)tree, we can also conclude that all the elements in num[1:] which are smaller than the root will be in the left subtree and all the elements in nums[1:] which are greater than the root will be in the right subtree. \\n\\nFor example, if the BST array is [3, 2, 1, 4, 5], then the root is 3 and the left subtree is [2, 1] with root node 2 and the right subtree is [4, 5] with root node 4. Notice that the subarray [2, 3] can be permuted in any position in nums[1:] as along as their relative permutation to each other is the same. For example, the array [3, 4, 2, 5, 1] will also give us the left subtree [2, 1] and the right subtree [4, 5]. Let $m$ be the length of the array, and let $k$ be the number of nodes in the left subtree. We need to choose $k$ spots out of $m-1$ positions to place our left subtree nodes in the array. This can done in $\\\\binom{m-1}{k}$ ways where $\\\\binom{x}{y}$ is the binomial coefficient which is equal to  $\\\\frac{x!}{y!(x-y!)}$. \\n\\nHowever, our final answer is not $\\\\binom{m-1}{k}$. This only tells us the number of ways the children of the current root node can be permuted in the array. It does not tell us about the children nodes of the current root node\\'s children i.e. it does not tell us about deeper subtrees. For example, consider the BST array [3, 1, 5, 2, 4, 7]. The left subtree here is [1, 2] and the right subtree is [5, 4, 7]. Notice how the right subtree can be [5, 7, 4] or [5, 4, 7] and still correspond to the same BST. This implies that we must traverse each subtree and calculate the valid permutations for its children node as well. The final answer will be the valid permutation of the left subtree multiplied by the valid permutations of the right subtree multiplied by the valid permutations of the current tree. \\n\\n# Complexity\\n- Time complexity: $O(n^2)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis is because we are calling the dfs function twice for each node in the tree. \\n\\n- Space complexity:$O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFirst, we are storing the left and right subtrees which have linear space. Next, our recursive call stack can have at most $n-1$ calls.\\n\\n# Code\\n```\\n\\nclass Solution:\\n\\tdef numOfWays(self, nums: List[int]) -> int:\\n\\t\\t\"\"\"\\n\\t\\tCalculates the number of ways an array can be rearranged and\\n\\t\\tstill correspond to the same BST. \\n\\n\\t\\tArgs:\\n\\t\\t\\tnums: List[int] = array of integers which correspond to a BST \\n\\n\\t\\tReturns:\\n\\t\\t\\tcount: int = number of ways the array can be rearranged and \\n\\t\\t\\t\\t\\t\\t still correspond to the same BST\\n\\t\\t\"\"\"\\n\\n\\t\\t# Since the answer might be very large, we return it modulo 10**9 + 7\\n\\t\\tmod = 10 ** 9 + 7 \\n\\n\\t\\t# define a recursive function which repeatedly calculates the answer\\n\\t\\t# for each level of the binary search tree\\n\\n\\t\\tdef dfs(arr):\\n\\n\\t\\t\\t# if the length of the current subtree is less than or equal to\\n\\t\\t\\t# two, then we can\\'t rearrange the array in more ways since the \\n\\t\\t\\t# first element is the root of the subtree\\n\\n\\t\\t\\tlength = len(arr)\\n\\t\\t\\tif length <= 2:\\n\\t\\t\\t\\treturn 1 \\n\\n\\t\\t\\t# we collect the array representation of the left subtree and the\\n\\t\\t\\t# right subtree\\n\\t\\t\\tleft_nodes = [num for num in arr if num < arr[0]]\\n\\t\\t\\tright_nodes = [num for num in arr if num > arr[0]]\\n\\n\\t\\t\\t# at this current level, we can permute the left and right subtree\\n\\t\\t\\t# nodes by choosing len(left_nodes) spots from the arr[1:]\\n\\t\\t\\tcurrent_level_permutation = comb(length-1, len(left_nodes))\\n\\n\\t\\t\\t# we have calculated the permutations for the current level of the BST,\\n\\t\\t\\t# we need to calculate the permutations for the left subtree and the right\\n\\t\\t\\t# subtree. We multiply all the factors together and return the final answer.\\n\\t\\t\\treturn dfs(left_nodes) * dfs(right_nodes) *current_level_permutation\\n\\n\\t\\t# we call the function for the BST, subtract one since the argument passed in is\\n\\t\\t# not considered, and return the answer modulo 10 ** 9 + 7\\n\\t\\treturn (dfs(nums) - 1) % mod  \\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\n\\nclass Solution:\\n\\tdef numOfWays(self, nums: List[int]) -> int:\\n\\t\\t\"\"\"\\n\\t\\tCalculates the number of ways an array can be rearranged and\\n\\t\\tstill correspond to the same BST. \\n\\n\\t\\tArgs:\\n\\t\\t\\tnums: List[int] = array of integers which correspond to a BST \\n\\n\\t\\tReturns:\\n\\t\\t\\tcount: int = number of ways the array can be rearranged and \\n\\t\\t\\t\\t\\t\\t still correspond to the same BST\\n\\t\\t\"\"\"\\n\\n\\t\\t# Since the answer might be very large, we return it modulo 10**9 + 7\\n\\t\\tmod = 10 ** 9 + 7 \\n\\n\\t\\t# define a recursive function which repeatedly calculates the answer\\n\\t\\t# for each level of the binary search tree\\n\\n\\t\\tdef dfs(arr):\\n\\n\\t\\t\\t# if the length of the current subtree is less than or equal to\\n\\t\\t\\t# two, then we can\\'t rearrange the array in more ways since the \\n\\t\\t\\t# first element is the root of the subtree\\n\\n\\t\\t\\tlength = len(arr)\\n\\t\\t\\tif length <= 2:\\n\\t\\t\\t\\treturn 1 \\n\\n\\t\\t\\t# we collect the array representation of the left subtree and the\\n\\t\\t\\t# right subtree\\n\\t\\t\\tleft_nodes = [num for num in arr if num < arr[0]]\\n\\t\\t\\tright_nodes = [num for num in arr if num > arr[0]]\\n\\n\\t\\t\\t# at this current level, we can permute the left and right subtree\\n\\t\\t\\t# nodes by choosing len(left_nodes) spots from the arr[1:]\\n\\t\\t\\tcurrent_level_permutation = comb(length-1, len(left_nodes))\\n\\n\\t\\t\\t# we have calculated the permutations for the current level of the BST,\\n\\t\\t\\t# we need to calculate the permutations for the left subtree and the right\\n\\t\\t\\t# subtree. We multiply all the factors together and return the final answer.\\n\\t\\t\\treturn dfs(left_nodes) * dfs(right_nodes) *current_level_permutation\\n\\n\\t\\t# we call the function for the BST, subtract one since the argument passed in is\\n\\t\\t# not considered, and return the answer modulo 10 ** 9 + 7\\n\\t\\treturn (dfs(nums) - 1) % mod  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648653,
                "title": "c-neat-and-clean-code-rare-solution-must-watch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst int mod = 1e9+7;\\nvector<int> pascals[1000];\\nclass Solution {\\nprivate:\\n    int solver(vector<int> nums, vector<int> pascals[]){\\n        int n = nums.size();\\n        if(n < 3) return 1;\\n\\n        vector<int> left;\\n        vector<int> right;\\n\\n        for(int i=1; i<n; i++){\\n            if(nums[i] < nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n\\n        int left_ways = solver(left,pascals);\\n        int right_ways = solver(right,pascals);\\n\\n        return ((1LL * pascals[n-1][left.size()] * left_ways%mod)%mod * right_ways%mod)%mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        if(pascals[0].size() == 0){\\n            for(int i=0; i<1000; i++){\\n                vector<int> temp(i+1,1);\\n                pascals[i] = temp;\\n                for(int j=1; j<i; j++){\\n                    pascals[i][j] = (pascals[i-1][j-1]%mod + pascals[i-1][j]%mod)%mod;\\n                }\\n            }\\n        }\\n        return solver(nums,pascals) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Divide and Conquer",
                    "Binary Search Tree"
                ],
                "code": "```\\nconst int mod = 1e9+7;\\nvector<int> pascals[1000];\\nclass Solution {\\nprivate:\\n    int solver(vector<int> nums, vector<int> pascals[]){\\n        int n = nums.size();\\n        if(n < 3) return 1;\\n\\n        vector<int> left;\\n        vector<int> right;\\n\\n        for(int i=1; i<n; i++){\\n            if(nums[i] < nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n\\n        int left_ways = solver(left,pascals);\\n        int right_ways = solver(right,pascals);\\n\\n        return ((1LL * pascals[n-1][left.size()] * left_ways%mod)%mod * right_ways%mod)%mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        if(pascals[0].size() == 0){\\n            for(int i=0; i<1000; i++){\\n                vector<int> temp(i+1,1);\\n                pascals[i] = temp;\\n                for(int j=1; j<i; j++){\\n                    pascals[i][j] = (pascals[i-1][j-1]%mod + pascals[i-1][j]%mod)%mod;\\n                }\\n            }\\n        }\\n        return solver(nums,pascals) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647097,
                "title": "explained-beginer-friendly-recursion-c-90-fast-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIf you are not familiar with how to form a BST form the array, you should definitely check it out online. [resource link](https://devcamp.com/trails/development-soft-skills/campsites/understanding-algorithms/guides/how-to-create-binary-search-tree-array)  - idk if this is the best, but this looks good enough to establish a basic understanding.\\n\\nNext, we have to observe that arrays which satisfy topological ordering of the input array will produce the same tree. In other words, for the tree produced, there can be multiple valid topological sorts. All there arrays will still produce the same tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nI have implemented the idea given in [this](https://codeforces.com/blog/entry/75627) blog post in code forces. It basically tells us that for a tree, the first element of the topological sort is gonna be the node itself. Next, we need to look at the topological sort of the left and right subtrees ( you can see the recursion forming now... ). When creating the rest of the topological sort for the currennt node, we need to preserve the ordering among the elements of these two lists.\\n\\nLet us say the n1, n2 are the length of the topological sorts of each subtree (which is also the number of nodes in the subtree), and t1, t2 be the number of topological sorts possible for each subtree. \\n\\nThe remaining part of the topo-sort should be n1+n2 long. First we select n1 positions from n1+n2 positions, which is (n1+n2)C(n1) number of ways. Now these n1 positions can be filled in t1 ways, and the remaining n2 positinos in t2 ways, resulting in the number of topo sorts for current node to be **(n1+n2)C(n1) * t1 * t2**. The number of nodes in the subtree naturally is **n1+n2+1**\\n\\n# Complexity\\n- Time complexity: O(n^2) - Creating BST\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n) - facts array to store factorials\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote the solutions if you find it helpful :)\\n# Code\\n```\\nclass Solution {\\n    struct BSTNode{\\n        int val;\\n        BSTNode *left, *right;\\n    \\n        BSTNode( int x ) {\\n            val = x;\\n            left = NULL, right = NULL;\\n        }\\n    };\\n\\n    void insert_into_BST( int val, BSTNode* root ) {\\n        BSTNode* prev = NULL;\\n\\n        while( root ) {\\n            prev = root;\\n            if( val > root->val ) root = root->right;\\n            else root = root->left;\\n        }\\n\\n        if( val > prev->val ) prev->right = new BSTNode( val );\\n        else prev->left = new BSTNode( val );\\n    }\\n\\n    const int mod = 1e9+7;\\n    vector<long long> facts;\\n\\n    pair<int,long long> solve( BSTNode* curr ) {\\n        if( curr==NULL ) return {0,1};\\n\\n        auto [n1, t1] = solve( curr->left );\\n        auto [n2, t2] = solve( curr->right );\\n\\n        t1 = (t1*t2) % mod;\\n        return { n1+n2+1, (t1*comb(n1+n2, n1))%mod };\\n    }\\n\\n    int comb( int n, int r ) {\\n        long long num = facts[n],\\n            denom = ( facts[n-r] * facts[r] ) % mod;\\n\\n        // when p is prime, a^-1 mod p = a^p-2 mod p\\n        long long inv = fast_exponent( denom, mod-2 );\\n\\n        return (num*inv)%mod;\\n    }\\n\\n    long long fast_exponent( long long base, int exp ) {\\n        if( exp==0 ) return 1;\\n        if( exp%2==0 ) {\\n            long long t = fast_exponent( base, exp/2 );\\n            return (t*t)%mod;\\n        }\\n        return (fast_exponent(base, exp-1 )*base) % mod;\\n    }   \\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        BSTNode* root = new BSTNode( nums[0] );\\n\\n        facts.resize(n+1);\\n        facts[0]=1;\\n        for( int i=1; i<=n; i++ ) facts[i] = (i*facts[i-1])%mod;\\n\\n        for( int i=1; i<n; i++ ) insert_into_BST( nums[i], root );\\n\\n        return solve( root ).second-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    struct BSTNode{\\n        int val;\\n        BSTNode *left, *right;\\n    \\n        BSTNode( int x ) {\\n            val = x;\\n            left = NULL, right = NULL;\\n        }\\n    };\\n\\n    void insert_into_BST( int val, BSTNode* root ) {\\n        BSTNode* prev = NULL;\\n\\n        while( root ) {\\n            prev = root;\\n            if( val > root->val ) root = root->right;\\n            else root = root->left;\\n        }\\n\\n        if( val > prev->val ) prev->right = new BSTNode( val );\\n        else prev->left = new BSTNode( val );\\n    }\\n\\n    const int mod = 1e9+7;\\n    vector<long long> facts;\\n\\n    pair<int,long long> solve( BSTNode* curr ) {\\n        if( curr==NULL ) return {0,1};\\n\\n        auto [n1, t1] = solve( curr->left );\\n        auto [n2, t2] = solve( curr->right );\\n\\n        t1 = (t1*t2) % mod;\\n        return { n1+n2+1, (t1*comb(n1+n2, n1))%mod };\\n    }\\n\\n    int comb( int n, int r ) {\\n        long long num = facts[n],\\n            denom = ( facts[n-r] * facts[r] ) % mod;\\n\\n        // when p is prime, a^-1 mod p = a^p-2 mod p\\n        long long inv = fast_exponent( denom, mod-2 );\\n\\n        return (num*inv)%mod;\\n    }\\n\\n    long long fast_exponent( long long base, int exp ) {\\n        if( exp==0 ) return 1;\\n        if( exp%2==0 ) {\\n            long long t = fast_exponent( base, exp/2 );\\n            return (t*t)%mod;\\n        }\\n        return (fast_exponent(base, exp-1 )*base) % mod;\\n    }   \\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        BSTNode* root = new BSTNode( nums[0] );\\n\\n        facts.resize(n+1);\\n        facts[0]=1;\\n        for( int i=1; i<=n; i++ ) facts[i] = (i*facts[i-1])%mod;\\n\\n        for( int i=1; i<n; i++ ) insert_into_BST( nums[i], root );\\n\\n        return solve( root ).second-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646433,
                "title": "the-competitive-programming-solution-c",
                "content": "This is not a typical DSA solution, and leans more towards CP. Please don\\'t downvote -- I already warned you :)\\n\\n# Approach\\n-> Fix the root and then think about combinations.\\n-> Every node has two sides; left and right\\n-> At the top most level, we cannot change the order ordering among the left side elements or the right side elements, but we can change the ordering of how a combination of these left side and right side element is present.\\n```\\n-> For eg: [3,4,5,1,2]\\n-> root is 3\\n-> Left side: [1,2]\\n-> Right side: [4,5]\\n-> Now we cant change the ordering among (1 and 2) and (4 and 5)\\n-> But we can change between their combination (1,2,4,5), (1,4,2,5), (4,5,1,2) etc.\\n```\\n\\n-> For each node we will see combinations this way i.e. left side and right side.\\n-> With some observation you\\'ll understand that if the number of elements on the right side is denoted by `l[node]` and right side `r[node]`, there can be a total of \\n\\n$$\\\\Large~~~~~~~~~~~~~~~~~{l[node]+r[node]-1 \\\\choose l[node]} + {l[node]+r[node]-1 \\\\choose r[node]}$$ \\n\\n\\ncombinations are possible corresponding to this node. \\n***[** ASK IF YOU DON\\'T UNDERSTAND THIS, I CAN EXPLAIN WITH A DIAGRAM **]***\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> l;\\n    unordered_map<int,int> r;\\n\\nint modMul(int a, int b,int mod)\\n{\\n    int res = 0; \\n \\n    a %= mod;\\n \\n    while (b) {\\n        if (b & 1)\\n            res = (res + a) % mod;\\n \\n        a = (2 * a) % mod;\\n \\n        b >>= 1; \\n    }\\n \\n    return res;\\n}\\n \\n\\n    int power(int x, int y, int p)\\n{\\n    int res = 1;\\n \\n    x = x % p; \\n \\n    while (y > 0)\\n    {\\n     \\n        if (y & 1)\\n            res = modMul(res,x,p);\\n \\n        y = y >> 1; \\n        x = modMul(x, x, p);\\n    }\\n    return res;\\n}\\n \\nint modInverse(int n, int p)\\n{\\n    return power(n, p - 2, p);\\n}\\n \\n\\nint nCr(int n, int r, int p)\\n{\\n    if (n < r)\\n        return 0;\\n    if (r == 0)\\n        return 1;\\n \\n\\n    int fac[n + 1];\\n    fac[0] = 1;\\n    for (int i = 1; i <= n; i++)\\n        fac[i] = modMul(fac[i - 1],i,p);\\n \\n    return modMul(modMul(fac[n],modInverse(fac[r], p),p),modInverse(fac[n - r], p),p);\\n}\\n\\n    void createBST(vector<vector<int>>& v, int root, int num){\\n        if(num<root){\\n            l[root]++;\\n            if(v[root][0]==0){\\n                v[root][0]=num;\\n            }\\n            else createBST(v,v[root][0],num);\\n        }\\n        else{\\n            r[root]++;\\n            if(v[root][1]==0){\\n                v[root][1]=num;\\n            }\\n            else createBST(v,v[root][1],num);\\n        }\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        // l.clear();\\n        // r.clear();\\n        vector<vector<int>> v(nums.size()+1, vector<int>(2,0));\\n        for(int i = 1; i<nums.size(); i++){\\n            createBST(v,nums[0],nums[i]);\\n        }\\n        int count = 1;\\n        int mod = 1e9+7;\\n        for(int i = 1; i<nums.size()+1; i++){\\n            if((l[i]!=0)&&(r[i]!=0))count = modMul(count,(nCr(l[i]+r[i]-1,l[i],1e9+7)+nCr(l[i]+r[i]-1,r[i],1e9+7))%(mod),mod);\\n        }\\n        return count-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Divide and Conquer",
                    "Combinatorics"
                ],
                "code": "```\\n-> For eg: [3,4,5,1,2]\\n-> root is 3\\n-> Left side: [1,2]\\n-> Right side: [4,5]\\n-> Now we cant change the ordering among (1 and 2) and (4 and 5)\\n-> But we can change between their combination (1,2,4,5), (1,4,2,5), (4,5,1,2) etc.\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> l;\\n    unordered_map<int,int> r;\\n\\nint modMul(int a, int b,int mod)\\n{\\n    int res = 0; \\n \\n    a %= mod;\\n \\n    while (b) {\\n        if (b & 1)\\n            res = (res + a) % mod;\\n \\n        a = (2 * a) % mod;\\n \\n        b >>= 1; \\n    }\\n \\n    return res;\\n}\\n \\n\\n    int power(int x, int y, int p)\\n{\\n    int res = 1;\\n \\n    x = x % p; \\n \\n    while (y > 0)\\n    {\\n     \\n        if (y & 1)\\n            res = modMul(res,x,p);\\n \\n        y = y >> 1; \\n        x = modMul(x, x, p);\\n    }\\n    return res;\\n}\\n \\nint modInverse(int n, int p)\\n{\\n    return power(n, p - 2, p);\\n}\\n \\n\\nint nCr(int n, int r, int p)\\n{\\n    if (n < r)\\n        return 0;\\n    if (r == 0)\\n        return 1;\\n \\n\\n    int fac[n + 1];\\n    fac[0] = 1;\\n    for (int i = 1; i <= n; i++)\\n        fac[i] = modMul(fac[i - 1],i,p);\\n \\n    return modMul(modMul(fac[n],modInverse(fac[r], p),p),modInverse(fac[n - r], p),p);\\n}\\n\\n    void createBST(vector<vector<int>>& v, int root, int num){\\n        if(num<root){\\n            l[root]++;\\n            if(v[root][0]==0){\\n                v[root][0]=num;\\n            }\\n            else createBST(v,v[root][0],num);\\n        }\\n        else{\\n            r[root]++;\\n            if(v[root][1]==0){\\n                v[root][1]=num;\\n            }\\n            else createBST(v,v[root][1],num);\\n        }\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        // l.clear();\\n        // r.clear();\\n        vector<vector<int>> v(nums.size()+1, vector<int>(2,0));\\n        for(int i = 1; i<nums.size(); i++){\\n            createBST(v,nums[0],nums[i]);\\n        }\\n        int count = 1;\\n        int mod = 1e9+7;\\n        for(int i = 1; i<nums.size()+1; i++){\\n            if((l[i]!=0)&&(r[i]!=0))count = modMul(count,(nCr(l[i]+r[i]-1,l[i],1e9+7)+nCr(l[i]+r[i]-1,r[i],1e9+7))%(mod),mod);\\n        }\\n        return count-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646209,
                "title": "c-java-easy-and-clean-code-divide-and-conquer-beats",
                "content": "# Please Upvote if you like my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n\\n# Complexity \\n- Time complexity: $$O(N^2)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# C++ Code\\n```\\n#define ll long long\\n\\nclass Solution {\\n    int mod = 1e9+7;\\n    vector<vector<ll>> pascal;\\n    \\n    ll numOfWaysHelp(vector<int>& nums) {\\n        if(nums.size() <= 2) return 1;\\n\\n        vector<int> leftSubtree, rightSubtree;\\n        int n = nums.size();\\n        for(int i=1; i<n; i++){\\n            if( nums[i] < nums[0] ) leftSubtree.push_back(nums[i]);\\n            else rightSubtree.push_back(nums[i]);\\n        }\\n\\n        ll leftWays = numOfWaysHelp(leftSubtree), rightWays = numOfWaysHelp(rightSubtree);\\n        int leftLen = leftSubtree.size(), rightLen = rightSubtree.size();\\n        return (pascal[n-1][leftLen] * ((leftWays * rightWays)%mod))%mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        // calculate pascal triangle for calculating nCr in O(1)\\n        int n = nums.size();\\n        pascal.resize(n+1);\\n        for(int i=0; i<n+1; i++){\\n            pascal[i] = vector<ll>(i+1, 1);\\n            for(int j=1; j<i; j++)\\n                pascal[i][j] = (pascal[i-1][j-1] + pascal[i-1][j] )%mod;\\n        }\\n        \\n        return numOfWaysHelp(nums)%mod - 1;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    int mod = (int)1e9+7;\\n\\n    private long numOfWaysHelp(List<Integer> nums, List<List<Integer>> pascal ) {\\n        if(nums.size() <= 2) return 1;\\n\\n        List<Integer> leftSubtree = new ArrayList<>(), rightSubtree = new ArrayList<>();\\n        int n = nums.size();\\n        for(int i=1; i<n; i++){\\n            if( nums.get(i) < nums.get(0) ) leftSubtree.add(nums.get(i));\\n            else rightSubtree.add(nums.get(i));\\n        }\\n\\n        long leftWays = numOfWaysHelp(leftSubtree, pascal), rightWays = numOfWaysHelp(rightSubtree, pascal);\\n        int leftLen = leftSubtree.size(), rightLen = rightSubtree.size();\\n        return (pascal.get(n-1).get(leftLen) * ((leftWays * rightWays)%mod))%mod;\\n    }\\n\\n    public int numOfWays(int[] nums) {\\n        // calculate pascal triangle for calculating nCr in O(1)\\n        int n = nums.length;\\n        List<List<Integer>> pascal = new ArrayList<>();\\n\\n        for(int i=0; i<n+1; i++){\\n            Integer row[] = new Integer[i+1];\\n            Arrays.fill(row, 1);\\n            pascal.add(Arrays.asList(row));\\n            for(int j=1; j<i; j++)\\n                pascal.get(i).set(j, (pascal.get(i-1).get(j-1) + pascal.get(i-1).get(j) )%mod);\\n        }\\n\\n        List<Integer> tmp = new ArrayList<>();\\n        for(int x : nums) tmp.add(x);\\n        return (int)numOfWaysHelp(tmp, pascal) - 1;\\n    }\\n}\\n```\\n\\n![upvote-img.jpg](https://assets.leetcode.com/users/images/d20562b8-5ddb-40b3-8b8a-5d7a0a6f0b57_1684136359.2221565.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\n    int mod = 1e9+7;\\n    vector<vector<ll>> pascal;\\n    \\n    ll numOfWaysHelp(vector<int>& nums) {\\n        if(nums.size() <= 2) return 1;\\n\\n        vector<int> leftSubtree, rightSubtree;\\n        int n = nums.size();\\n        for(int i=1; i<n; i++){\\n            if( nums[i] < nums[0] ) leftSubtree.push_back(nums[i]);\\n            else rightSubtree.push_back(nums[i]);\\n        }\\n\\n        ll leftWays = numOfWaysHelp(leftSubtree), rightWays = numOfWaysHelp(rightSubtree);\\n        int leftLen = leftSubtree.size(), rightLen = rightSubtree.size();\\n        return (pascal[n-1][leftLen] * ((leftWays * rightWays)%mod))%mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        // calculate pascal triangle for calculating nCr in O(1)\\n        int n = nums.size();\\n        pascal.resize(n+1);\\n        for(int i=0; i<n+1; i++){\\n            pascal[i] = vector<ll>(i+1, 1);\\n            for(int j=1; j<i; j++)\\n                pascal[i][j] = (pascal[i-1][j-1] + pascal[i-1][j] )%mod;\\n        }\\n        \\n        return numOfWaysHelp(nums)%mod - 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int mod = (int)1e9+7;\\n\\n    private long numOfWaysHelp(List<Integer> nums, List<List<Integer>> pascal ) {\\n        if(nums.size() <= 2) return 1;\\n\\n        List<Integer> leftSubtree = new ArrayList<>(), rightSubtree = new ArrayList<>();\\n        int n = nums.size();\\n        for(int i=1; i<n; i++){\\n            if( nums.get(i) < nums.get(0) ) leftSubtree.add(nums.get(i));\\n            else rightSubtree.add(nums.get(i));\\n        }\\n\\n        long leftWays = numOfWaysHelp(leftSubtree, pascal), rightWays = numOfWaysHelp(rightSubtree, pascal);\\n        int leftLen = leftSubtree.size(), rightLen = rightSubtree.size();\\n        return (pascal.get(n-1).get(leftLen) * ((leftWays * rightWays)%mod))%mod;\\n    }\\n\\n    public int numOfWays(int[] nums) {\\n        // calculate pascal triangle for calculating nCr in O(1)\\n        int n = nums.length;\\n        List<List<Integer>> pascal = new ArrayList<>();\\n\\n        for(int i=0; i<n+1; i++){\\n            Integer row[] = new Integer[i+1];\\n            Arrays.fill(row, 1);\\n            pascal.add(Arrays.asList(row));\\n            for(int j=1; j<i; j++)\\n                pascal.get(i).set(j, (pascal.get(i-1).get(j-1) + pascal.get(i-1).get(j) )%mod);\\n        }\\n\\n        List<Integer> tmp = new ArrayList<>();\\n        for(int x : nums) tmp.add(x);\\n        return (int)numOfWaysHelp(tmp, pascal) - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645804,
                "title": "combination-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long int >> comb;\\n    int mod = 1e9+7;\\n    \\n    long long int solve(vector<int>& v)\\n    {\\n        int n = v.size();\\n        if(n<=2)\\n            return 1;\\n        \\n        vector<int > l ,r;\\n        for(int i=1;i<n;i++){\\n            if(v[i]<v[0])\\n                l.push_back(v[i]);\\n            else\\n                r.push_back(v[i]);\\n        }\\n        \\n        \\n        long long int lans = solve(l)%mod;\\n        long long int rans = solve(r)%mod;\\n        \\n        int llen = l.size();\\n        return ((((comb[n-1][llen] * lans ) %mod)*rans)%mod);\\n    }\\n    \\n    int numOfWays(vector<int>& v) {\\n        \\n        int n = v.size();\\n        comb.resize(n+1);\\n        for(int i=0;i<n+1;i++)\\n        {\\n            comb[i] = vector<long long int>(i+1,1);\\n            for(int j=1;j<i;j++)\\n            {\\n                comb[i][j] = (comb[i-1][j-1]+comb[i-1][j]) %mod;\\n            }\\n        }\\n        \\n        long long int ans = solve(v);\\n        return ans%mod - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long int >> comb;\\n    int mod = 1e9+7;\\n    \\n    long long int solve(vector<int>& v)\\n    {\\n        int n = v.size();\\n        if(n<=2)\\n            return 1;\\n        \\n        vector<int > l ,r;\\n        for(int i=1;i<n;i++){\\n            if(v[i]<v[0])\\n                l.push_back(v[i]);\\n            else\\n                r.push_back(v[i]);\\n        }\\n        \\n        \\n        long long int lans = solve(l)%mod;\\n        long long int rans = solve(r)%mod;\\n        \\n        int llen = l.size();\\n        return ((((comb[n-1][llen] * lans ) %mod)*rans)%mod);\\n    }\\n    \\n    int numOfWays(vector<int>& v) {\\n        \\n        int n = v.size();\\n        comb.resize(n+1);\\n        for(int i=0;i<n+1;i++)\\n        {\\n            comb[i] = vector<long long int>(i+1,1);\\n            for(int j=1;j<i;j++)\\n            {\\n                comb[i][j] = (comb[i-1][j-1]+comb[i-1][j]) %mod;\\n            }\\n        }\\n        \\n        long long int ans = solve(v);\\n        return ans%mod - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645639,
                "title": "go-22ms-solution",
                "content": "# Approach\\nRecursive function (compute): This function divides the given array into two sub-arrays (namely \\'smaller\\' and \\'larger\\') based on the first element, simulating the creation of a BST. If there is only one or no element left, it simply returns 1 (base case of recursion). It then recursively calculates the number of ways for both the \\'smaller\\' and \\'larger\\' sub-arrays and multiplies them together. Lastly, it multiplies the result by the number of ways to choose the elements for the sub-arrays (calculated by the choose function), which gives the total number of ways to reorder the given array.\\n\\nChoosing function (choose): This function calculates the number of ways to choose k elements from n elements (i.e., binomial coefficient). It does this using the [multiplicative inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) method, which is a common way to handle large factorials while avoiding overflow. Here, the multiplicative inverse is calculated using the ModInverse function from the math/big package in Go.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$ Each call to compute triggers $$O(n)$$ calls to itself.and this could happen up to n times \\n\\n- Space complexity:\\n$$O(n)$$ as there would be $$n$$ recursive calls.\\n\\n# Code\\n```\\nconst mod = 1e9 + 7\\nvar cache = make([][]int, 1001)\\n\\nfunc init() {\\n    for i := range cache {\\n        cache[i] = make([]int, 1001)\\n    }\\n}\\n\\nfunc numOfWays(nums []int) int {\\n    return compute(nums) - 1\\n}\\n\\nfunc compute(nums []int) int {\\n    if len(nums) <= 1 {\\n        return 1\\n    }\\n\\n    smaller, larger := splitNums(nums)\\n\\n    n := len(nums) - 1\\n    k := len(larger)\\n    \\n    kn := choose(n, k)\\n    small := compute(smaller) % mod\\n    large := compute(larger) % mod\\n\\n    res := ((small * large % mod) * kn) % mod\\n    return res\\n}\\n\\nfunc splitNums(nums []int) (smaller, larger []int) {\\n    for _, x := range nums[1:] {\\n        if x > nums[0] {\\n            larger = append(larger, x)\\n        }\\n        if x < nums[0] {\\n            smaller = append(smaller, x)\\n        }\\n    }\\n    return smaller, larger\\n}\\n\\nfunc choose(n, k int) int {\\n    if k == 0 || k == n {\\n        return 1\\n    }\\n    if cache[n][k] != 0 {\\n        return cache[n][k]\\n    }\\n\\n    a, b := 1, 1\\n\\n    for x := n; x > k; x-- {\\n        a = (a * x) % mod\\n    }\\n    for x := n - k; x > 1; x-- {\\n        b = (b * x) % mod\\n    }\\n\\n    inv := big.NewInt(int64(b)).ModInverse(big.NewInt(int64(b)), big.NewInt(int64(mod)))\\n    modinv := inv.Int64()\\n\\n    cache[n][k] = (a * int(modinv)) % mod\\n    return cache[n][k]\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst mod = 1e9 + 7\\nvar cache = make([][]int, 1001)\\n\\nfunc init() {\\n    for i := range cache {\\n        cache[i] = make([]int, 1001)\\n    }\\n}\\n\\nfunc numOfWays(nums []int) int {\\n    return compute(nums) - 1\\n}\\n\\nfunc compute(nums []int) int {\\n    if len(nums) <= 1 {\\n        return 1\\n    }\\n\\n    smaller, larger := splitNums(nums)\\n\\n    n := len(nums) - 1\\n    k := len(larger)\\n    \\n    kn := choose(n, k)\\n    small := compute(smaller) % mod\\n    large := compute(larger) % mod\\n\\n    res := ((small * large % mod) * kn) % mod\\n    return res\\n}\\n\\nfunc splitNums(nums []int) (smaller, larger []int) {\\n    for _, x := range nums[1:] {\\n        if x > nums[0] {\\n            larger = append(larger, x)\\n        }\\n        if x < nums[0] {\\n            smaller = append(smaller, x)\\n        }\\n    }\\n    return smaller, larger\\n}\\n\\nfunc choose(n, k int) int {\\n    if k == 0 || k == n {\\n        return 1\\n    }\\n    if cache[n][k] != 0 {\\n        return cache[n][k]\\n    }\\n\\n    a, b := 1, 1\\n\\n    for x := n; x > k; x-- {\\n        a = (a * x) % mod\\n    }\\n    for x := n - k; x > 1; x-- {\\n        b = (b * x) % mod\\n    }\\n\\n    inv := big.NewInt(int64(b)).ModInverse(big.NewInt(int64(b)), big.NewInt(int64(mod)))\\n    modinv := inv.Int64()\\n\\n    cache[n][k] = (a * int(modinv)) % mod\\n    return cache[n][k]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3645222,
                "title": "easy-and-simple-solution-with-explanation",
                "content": "**If you not understand problem clearly then here is explanation**\\nLet\\'s suppose we have given *array* [3,4,5,1,2] and empty tree\\nthen we have to place element in tree by order they comes i.e.\\nwe get first element 3 make it root then we have element 4 make it to right child of 3,now element 5 come make it to right child of 4 then element 1 come make it to left child of 3 which is its correct position according to BST rule (i.e. smaller element left side and larger element right side) now 2 come make it to right child of 1.\\nNow we have to find how many arrangements of give permutation give same BST.```\\n\\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\\nHint: writes all arrangement of array try to find pattern in this.\\n(Sorry for poor English).\\n\\n```\\nint mode=1e9+7;\\nclass Solution {\\npublic:\\n    vector<vector<long long>> bio;\\n    long long dfs(vector<int> &nums){\\n        if(nums.size()<3){\\n            return 1;\\n        }\\n        vector<int> left,right;\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<nums[0]){\\n                left.push_back(nums[i]);\\n            }else{\\n                right.push_back(nums[i]);\\n            }\\n        }\\n        int k=left.size();\\n        return bio[n][k]*dfs(left)%mode *dfs(right)%mode;\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        int n=nums.size();\\n        bio.resize(0);\\n        bio.resize(n+4);\\n        bio[1]={1};\\n        bio[2]={1,1};\\n        for(int i=3;i<=n;i++){\\n            bio[i].resize(i,1);\\n            for(int j=1;j<i-1;j++){\\n                bio[i][j]=(bio[i-1][j-1]+bio[i-1][j])%mode;\\n            }\\n        }\\n        return (dfs(nums)-1)%mode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\\nHint: writes all arrangement of array try to find pattern in this.\\n(Sorry for poor English).\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3645205,
                "title": "easy-well-explained-dp-combination-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to recursively divide the array into two parts, a left part and a right part. The left part contains numbers smaller than the first element of the array,i.e root of the tree, and the right part contains numbers greater than or equal to the first element. The number of ways to split the array can be calculated by multiplying the number of ways to split the left part and the right part with the total number of combinations possible for the remaining elements.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe numOfWays function takes an input array nums and returns the number of ways to split the array as described above.\\nIt initializes a variable mod with the value 1e9 + 7, which will be used for modular arithmetic.\\nIt creates a 2D vector dp of size (n + 1) x (n + 1), where n is the size of the input array. This vector will be used to store precomputed values of binomial coefficients.\\nIt then calls a helper function sol with the input array nums and the dp vector.\\nInside the sol function, if the size of the input array is less than or equal to 2, it returns 1 since there is only one way to split such arrays.\\nOtherwise, it initializes two vectors left and right to store the numbers that are smaller and greater than or equal to the first element of the array, respectively.\\nIt recursively calculates the number of ways to split the left and right parts by calling sol with the respective vectors.\\nFinally, it returns the result by multiplying the number of ways to split the left and right parts with the binomial coefficient calculated using the dp vector. It uses modular arithmetic to avoid integer overflow.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code initializes the dp vector with binomial coefficients in O(n^2) time, where n is the size of the input array.\\nThe sol function is called recursively, and at each recursion level, it splits the array into two parts, which takes O(n) time.\\nOverall, the time complexity of the code is O(n^3) because the sol function is called recursively for each element in the array, and calculating binomial coefficients takes O(n^2) time.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a 2D vector dp of size (n + 1) x (n + 1), which requires O(n^2) space.\\nThe recursion depth of the sol function is at most n, so the space complexity of the recursion stack is O(n).\\nOverall, the space complexity of the code is O(n^2) due to the dp vector.dp\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long mod=1e9+7;\\nint sol(vector<int>&num,vector<vector<long long>> &dp){\\n    int n=num.size();\\n    if(n<=2) return 1;\\n     vector<int> left,right;\\n       for(int i=1;i<n;i++){\\n       if(num[i]<num[0]) left.push_back(num[i]);\\n       else right.push_back(num[i]);\\n       }\\n       return (((dp[n-1][left.size()]*(sol(left,dp)))%mod)*(sol(right,dp)))%mod;//nCr-->dp\\n}\\n    int numOfWays(vector<int>& nums) {\\n        int n=nums.size();\\n         vector<vector<long long>> dp(n + 1, vector<long long>(n + 1, 0));\\n        for (int i=0;i<=n;i++){\\n            dp[i][0]=1;\\n            dp[i][i]=1;\\n            for (int j=1;j<i;j++)\\n               dp[i][j]=(dp[i-1][j-1] + dp[i-1][j])%mod;\\n        }\\n        return sol(nums,dp)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long mod=1e9+7;\\nint sol(vector<int>&num,vector<vector<long long>> &dp){\\n    int n=num.size();\\n    if(n<=2) return 1;\\n     vector<int> left,right;\\n       for(int i=1;i<n;i++){\\n       if(num[i]<num[0]) left.push_back(num[i]);\\n       else right.push_back(num[i]);\\n       }\\n       return (((dp[n-1][left.size()]*(sol(left,dp)))%mod)*(sol(right,dp)))%mod;//nCr-->dp\\n}\\n    int numOfWays(vector<int>& nums) {\\n        int n=nums.size();\\n         vector<vector<long long>> dp(n + 1, vector<long long>(n + 1, 0));\\n        for (int i=0;i<=n;i++){\\n            dp[i][0]=1;\\n            dp[i][i]=1;\\n            for (int j=1;j<i;j++)\\n               dp[i][j]=(dp[i-1][j-1] + dp[i-1][j])%mod;\\n        }\\n        return sol(nums,dp)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645189,
                "title": "easy-to-understand-code-with-ncr-c-recursion-fastest",
                "content": "# Approach\\nAs mention in the problem we have to find the number of ways to reorder the given array which generates the same tree.\\nThe first element can not be rearranged because if we change its position the tree will change.\\n\\nThe dfs function is a recursive helper function that takes in the nums array and a 2D vector comb as input. It performs a depth-first search to calculate the number of different reorderings.\\n\\nThe base case for the recursion is when the size of the nums array is less than or equal to 2. In this case, there is only one way to reorder the elements, so the function returns 1.\\n\\nIf the size of the nums array is greater than 2, the function continues with the recursive approach. It splits the nums array into two parts: left and right. The left array contains all the elements smaller than the first element of nums, and the right array contains all the elements greater than the first element.\\n\\n# Complexity\\n- Time complexity:\\nO(n<sup>2</sup>)\\ndfs(nums) recursively calls itself. In each call it find the number of elements greater than the first element which require O(n) time.\\n Since the total call will be n. Thus the total time complexity of the recursive solution is O(n<sup>2</sup>)\\n\\n\\n- Space complexity:\\nO(n<sup>2</sup>)\\nAs we vector of vector to store the combinations\\n\\n# If find usefull please upvote |\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   int dfs(vector<int>& nums,vector<vector<int>>&comb) {\\n            int n = nums.size(),md=1e9+7;\\n            if (n <= 2) return 1;\\n            vector<int> left, right;\\n            for (int i = 1; i < n; ++i) {\\n                if (nums[i] < nums[0]) left.push_back(nums[i]);\\n                else right.push_back(nums[i]);\\n            }\\n            long long res = comb[n - 1][left.size()];\\n            res = res * dfs(left,comb) % md;\\n            res = res * dfs(right,comb) % md;\\n            return (int)res;\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        int md=1e9+7;\\n        vector<vector<int>> comb(n + 1, vector<int>(n + 1));\\n        comb[0][0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            comb[i][0] = 1;\\n            for (int j = 1; j <= i; ++j) {\\n                comb[i][j]=(comb[i-1][j-1]+comb[i-1][j]) % md;\\n            }\\n        }\\n        \\n        return dfs(nums,comb) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   int dfs(vector<int>& nums,vector<vector<int>>&comb) {\\n            int n = nums.size(),md=1e9+7;\\n            if (n <= 2) return 1;\\n            vector<int> left, right;\\n            for (int i = 1; i < n; ++i) {\\n                if (nums[i] < nums[0]) left.push_back(nums[i]);\\n                else right.push_back(nums[i]);\\n            }\\n            long long res = comb[n - 1][left.size()];\\n            res = res * dfs(left,comb) % md;\\n            res = res * dfs(right,comb) % md;\\n            return (int)res;\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        int md=1e9+7;\\n        vector<vector<int>> comb(n + 1, vector<int>(n + 1));\\n        comb[0][0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            comb[i][0] = 1;\\n            for (int j = 1; j <= i; ++j) {\\n                comb[i][j]=(comb[i-1][j-1]+comb[i-1][j]) % md;\\n            }\\n        }\\n        \\n        return dfs(nums,comb) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645074,
                "title": "combinations-modular-inverse-using-fermat-s-little-theorem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe position for the root is fixed at the first position, the left and the right sub-trees can be mixed with each other but without changing the order in each sub-tree.\\n\\nWe can get an initial answer, which is the number of combinations $$C^n_k$$, where $$n$$ is the length of the array and $$k$$ is the number of nodes in either the left sub-tree or the right sub-tree (the result should be the same because $$C^n_k = C^n_{n-k}$$).\\n\\nFor the order of each sub-tree, we can use a recursive approach and multiplying them into the initial answer we can get the final answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. `inverse`: Get the modular inverse using *Fermat\\'s Little Theorem*: $$a^{-1} = a^{M - 2}\\\\mod M$$\\n    - `power`: Get the power efficiently.\\n2. `c`: Calculate $$C^n_k$$. Use `inverse` to convert division to multiply so that we can perform the modulo.\\n    - `numerator`: The numerator is the product from `n - k + 1` to `n` inclusively.\\n    - `denominator`: The denominator is the product from `1` to `k` inclusively.\\n\\n# Complexity\\nComplexity is calculated in average occasions, for dividing into two parts and recursively solve each part.\\n\\nIn each iteration, we used $$O(n)$$ to get each sub-tree and $$O(n)$$ to calculate the number of combinations (with $$log_2M$$ to get the power), so $$O(n)$$ is the answer.\\n\\nWe perform recursions based on the input, if the numbers of nodes in the left and right sub-trees are approximetely equal, we can get a recursion depth of $$O(log_2n)$$.\\n- Time complexity: $$O(n\\\\log_2n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n\\\\log_2n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst int mod = 1e9+7;\\n\\nstatic int power(int x, int y) { return y == 0 ? 1 : (y % 2 == 0 ? power((long)x * x % mod, y / 2) : (long)x * power(x, y - 1) % mod); }\\nint inverse(int a) { return power(a, mod - 2); }\\n\\nstatic int numerator(int i, int n) { return i <= n ? (long)numerator(i + 1, n) * i % mod : 1; }\\nstatic int denominator(int i, int k) { return i <= k ? (long)denominator(i + 1, k) * i % mod : 1; }\\nint c(int n, int k) { return (long)numerator(n - k + 1, n) * inverse(denominator(1, k)) % mod; }\\n\\nstatic void count(int i, int n, int *cg, int *cl, int *nums) { i < n ? ((nums[i] > nums[0] ? (*cg)++ : (*cl)++), count(i+1, n, cg, cl, nums)) : (void)0; }\\nstatic void subs(int i, int n, int *g, int ig, int *l, int il, int *nums) { i < n ? ((nums[i] > nums[0] ? (g[ig++] = nums[i]) : (l[il++] = nums[i])), subs(i+1, n, g, ig, l, il, nums)) : (void)0; }\\nint numOfWays(int *nums, int numsSize)\\n{\\n    int *g, cg = 0, *l, cl = 0;\\n    int ans, i;\\n\\n    return count(1, numsSize, &cg, &cl, nums),\\n        g = (cg > 0 ? calloc(cg, sizeof *g) : NULL),\\n        l = (cl > 0 ? calloc(cl, sizeof *l) : NULL),\\n        subs(1, numsSize, g, 0, l, 0, nums),\\n        ans = (long)c(numsSize-1, cg) * (cg > 2 ? numOfWays(g, cg) + 1 : 1) % mod * (cl > 2 ? numOfWays(l, cl) + 1 : 1) % mod,\\n        free(g),\\n        free(l),\\n        (ans - 1) % mod;\\n}   \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nconst int mod = 1e9+7;\\n\\nstatic int power(int x, int y) { return y == 0 ? 1 : (y % 2 == 0 ? power((long)x * x % mod, y / 2) : (long)x * power(x, y - 1) % mod); }\\nint inverse(int a) { return power(a, mod - 2); }\\n\\nstatic int numerator(int i, int n) { return i <= n ? (long)numerator(i + 1, n) * i % mod : 1; }\\nstatic int denominator(int i, int k) { return i <= k ? (long)denominator(i + 1, k) * i % mod : 1; }\\nint c(int n, int k) { return (long)numerator(n - k + 1, n) * inverse(denominator(1, k)) % mod; }\\n\\nstatic void count(int i, int n, int *cg, int *cl, int *nums) { i < n ? ((nums[i] > nums[0] ? (*cg)++ : (*cl)++), count(i+1, n, cg, cl, nums)) : (void)0; }\\nstatic void subs(int i, int n, int *g, int ig, int *l, int il, int *nums) { i < n ? ((nums[i] > nums[0] ? (g[ig++] = nums[i]) : (l[il++] = nums[i])), subs(i+1, n, g, ig, l, il, nums)) : (void)0; }\\nint numOfWays(int *nums, int numsSize)\\n{\\n    int *g, cg = 0, *l, cl = 0;\\n    int ans, i;\\n\\n    return count(1, numsSize, &cg, &cl, nums),\\n        g = (cg > 0 ? calloc(cg, sizeof *g) : NULL),\\n        l = (cl > 0 ? calloc(cl, sizeof *l) : NULL),\\n        subs(1, numsSize, g, 0, l, 0, nums),\\n        ans = (long)c(numsSize-1, cg) * (cg > 2 ? numOfWays(g, cg) + 1 : 1) % mod * (cl > 2 ? numOfWays(l, cl) + 1 : 1) % mod,\\n        free(g),\\n        free(l),\\n        (ans - 1) % mod;\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3644860,
                "title": "python-3-solution-with-real-bst",
                "content": "# Code\\n```\\nfrom math import comb\\n\\nMOD = 10**9+7\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        root = self._build_bst(nums)\\n        return self.perms(root)[1] - 1\\n\\n    def perms(self, node):\\n        \"\"\" returns (size, perms) \"\"\"\\n        if node is None:\\n            return 0, 1\\n        \\n        left_size, left_perms = self.perms(node.left)\\n        right_size, right_perms = self.perms(node.right)\\n        size = left_size + right_size + 1\\n\\n        res = comb(size-1, left_size) * left_perms * right_perms\\n    \\n        return size, res % MOD\\n    \\n    def _build_bst(self, nums):\\n        bst = BST()\\n        for x in nums:\\n            bst.insert(x)\\n        return bst.root\\n\\n\\nclass BST:\\n    def __init__(self):\\n        self.root = None\\n    \\n    def insert(self, val):\\n        self.root = self._insert(self.root, val)\\n    \\n    def _insert(self, node, val):\\n        if node is None:\\n            return TreeNode(val)\\n\\n        if val < node.val:\\n            node.left = self._insert(node.left, val)\\n        else:\\n            node.right = self._insert(node.right, val)\\n        return node\\n\\n\\nclass TreeNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import comb\\n\\nMOD = 10**9+7\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        root = self._build_bst(nums)\\n        return self.perms(root)[1] - 1\\n\\n    def perms(self, node):\\n        \"\"\" returns (size, perms) \"\"\"\\n        if node is None:\\n            return 0, 1\\n        \\n        left_size, left_perms = self.perms(node.left)\\n        right_size, right_perms = self.perms(node.right)\\n        size = left_size + right_size + 1\\n\\n        res = comb(size-1, left_size) * left_perms * right_perms\\n    \\n        return size, res % MOD\\n    \\n    def _build_bst(self, nums):\\n        bst = BST()\\n        for x in nums:\\n            bst.insert(x)\\n        return bst.root\\n\\n\\nclass BST:\\n    def __init__(self):\\n        self.root = None\\n    \\n    def insert(self, val):\\n        self.root = self._insert(self.root, val)\\n    \\n    def _insert(self, node, val):\\n        if node is None:\\n            return TreeNode(val)\\n\\n        if val < node.val:\\n            node.left = self._insert(node.left, val)\\n        else:\\n            node.right = self._insert(node.right, val)\\n        return node\\n\\n\\nclass TreeNode:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644853,
                "title": "easiest-explanation-hard-easy-codestorywithmik",
                "content": "YouTube video link - [Number of Ways to Reorder Array to Get Same BST](https://www.youtube.com/watch?v=YMe9Q2yZvBo)\\nMy Github Treasure - [Number of Ways to Reorder Array to Get Same BST](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Mathematical/Number%20of%20Ways%20to%20Reorder%20Array%20to%20Get%20Same%20BST.cpp)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll MOD = 1e9 + 7;\\n    \\n    vector<vector<ll>> PT;\\n    \\n    int solve(vector<int>& nums) {\\n        int m = nums.size();\\n        \\n        if(m < 3)\\n            return 1;\\n        \\n        vector<int> left, right;\\n        \\n        int root = nums[0];\\n        for(int i = 1; i < m; i++) {\\n            \\n            if(nums[i] < root) {\\n                left.push_back(nums[i]);\\n            } else {\\n                right.push_back(nums[i]);\\n            }\\n            \\n        }\\n        \\n        ll leftways  = solve(left)  % MOD;\\n        ll rightways = solve(right) % MOD;\\n        \\n        return (((leftways * rightways)%MOD) * PT[m-1][left.size()]) % MOD;\\n        \\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        \\n        PT.resize(n+1);\\n        \\n        for(int i = 0; i <= n; i++) {\\n            \\n            PT[i] = vector<long long>(i+1, 1);\\n            \\n            for(int j = 1; j < i; j++) {\\n                PT[i][j] = (PT[i-1][j-1] + PT[i-1][j]) % MOD;\\n            }\\n        }\\n        \\n        \\n        return (solve(nums)-1) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll MOD = 1e9 + 7;\\n    \\n    vector<vector<ll>> PT;\\n    \\n    int solve(vector<int>& nums) {\\n        int m = nums.size();\\n        \\n        if(m < 3)\\n            return 1;\\n        \\n        vector<int> left, right;\\n        \\n        int root = nums[0];\\n        for(int i = 1; i < m; i++) {\\n            \\n            if(nums[i] < root) {\\n                left.push_back(nums[i]);\\n            } else {\\n                right.push_back(nums[i]);\\n            }\\n            \\n        }\\n        \\n        ll leftways  = solve(left)  % MOD;\\n        ll rightways = solve(right) % MOD;\\n        \\n        return (((leftways * rightways)%MOD) * PT[m-1][left.size()]) % MOD;\\n        \\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        \\n        PT.resize(n+1);\\n        \\n        for(int i = 0; i <= n; i++) {\\n            \\n            PT[i] = vector<long long>(i+1, 1);\\n            \\n            for(int j = 1; j < i; j++) {\\n                PT[i][j] = (PT[i-1][j-1] + PT[i-1][j]) % MOD;\\n            }\\n        }\\n        \\n        \\n        return (solve(nums)-1) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644789,
                "title": "easy-c-solution-it-s-mainly-about-ncr",
                "content": "I have calculated nCr using binary exponentiation and Class 12th nCr formula and Modular multiplicative inverse.\\n\\n```\\nnCr= n! / r!*(n-r)!\\n\\nclass Solution {\\npublic:\\n    long long fac[1001];\\n    int mod=1e9+7;\\n    void fact() {     // To calculate the Factorial and mod for value in range\\n        fac[0]=1;\\n        for(int i=1;i<=1000;i++) {\\n            fac[i]=1LL*fac[i-1]*i;\\n            fac[i]%=mod;\\n        }\\n    }\\n    long long bin(long long n, long long m) {   //Binary Exponentiaition (log n calculation)\\n        long long ans=1;\\n        while(m) {\\n            if(m&1) {\\n                ans*=n; ans%=mod;\\n            }\\n            n*=n; n%=mod;\\n            m/=2;\\n        }\\n        return ans;\\n    }\\n    long long ncr(int n, int k) {   // Calculating nCr using the above formula\\n        long long ans=fac[n];\\n        long long den=1LL*fac[k]*fac[n-k]%mod;\\n        return 1LL*(ans%mod*bin(den, mod-2)%mod)%mod;   \\n    }\\n    long long dfs(vector<int>&nums) {\\n        int n=nums.size();\\n        if(n<3) return 1;\\n        vector<int> left, right;\\n        for(int i=1;i<n;i++) if(nums[i]<nums[0]) left.push_back(nums[i]);\\n        else right.push_back(nums[i]);\\n        long long l1=dfs(left);\\n        long long r1=dfs(right);\\n        return 1LL*ncr(n-1, left.size())%mod*l1%mod*r1%mod;\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        fact();\\n        return (int) dfs(nums)-1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\npublic:\\n    long long fac[1001];\\n    int mod=1e9+7;\\n    void fact() {     // To calculate the Factorial and mod for value in range\\n        fac[0]=1;\\n        for(int i=1;i<=1000;i++) {\\n            fac[i]=1LL*fac[i-1]*i;\\n            fac[i]%=mod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3644711,
                "title": "simple-recursive-approach-c-code",
                "content": "# Intuition\\nDivide and Conquer technique via recursion \\n\\n# Approach\\nstoring left subtree in left array and right subtree in right array\\ntotal number of ways can be achieved by no of arranging left subtree * no of ways of arranging right subtree * nCr\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int mod=1e9+7;\\npublic:\\n    long long power(long long x,int y, int p)\\n    {\\n    long long res = 1; \\n    x = x % p; \\n    while (y > 0)\\n    {\\n        if (y & 1)\\n            res = (res * x) % p;\\n        y = y >> 1; \\n        x = (x * x) % p;\\n    }\\n    return res;\\n}\\n\\nlong long modInverse(unsigned long long n,int p)\\n{\\n    return power(n, p - 2, p);\\n}\\n\\nlong long nCrModPFermat(long long n, int r, int p)\\n{\\n    if (n < r)\\n        return 0;\\n    if (r == 0)\\n        return 1;\\n     \\n    long long fac[n + 1];\\n    fac[0] = 1;\\n    for (int i = 1; i <= n; i++)\\n        fac[i] = (fac[i - 1] * i) % p;\\n \\n    return (fac[n] * modInverse(fac[r], p) % p\\n            * modInverse(fac[n - r], p) % p)\\n           % p;\\n}\\n    long long lrbst(vector<int>& nums){\\n        int n=nums.size();\\n        if(n<=2) return 1;\\n        int root=nums[0];\\n        vector<int> left;\\n        vector<int> right;\\n        for(int i=1; i<n; i++){\\n            if(nums[i]<root) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        int l=left.size();\\n        int r=right.size();\\n\\n        long long lb=lrbst(left);\\n        long long rb=lrbst(right);\\n        return ((lb%mod*rb%mod)%mod*nCrModPFermat(n-1,l,mod))%mod;\\n    }\\n\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        long long ans=lrbst(nums);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int mod=1e9+7;\\npublic:\\n    long long power(long long x,int y, int p)\\n    {\\n    long long res = 1; \\n    x = x % p; \\n    while (y > 0)\\n    {\\n        if (y & 1)\\n            res = (res * x) % p;\\n        y = y >> 1; \\n        x = (x * x) % p;\\n    }\\n    return res;\\n}\\n\\nlong long modInverse(unsigned long long n,int p)\\n{\\n    return power(n, p - 2, p);\\n}\\n\\nlong long nCrModPFermat(long long n, int r, int p)\\n{\\n    if (n < r)\\n        return 0;\\n    if (r == 0)\\n        return 1;\\n     \\n    long long fac[n + 1];\\n    fac[0] = 1;\\n    for (int i = 1; i <= n; i++)\\n        fac[i] = (fac[i - 1] * i) % p;\\n \\n    return (fac[n] * modInverse(fac[r], p) % p\\n            * modInverse(fac[n - r], p) % p)\\n           % p;\\n}\\n    long long lrbst(vector<int>& nums){\\n        int n=nums.size();\\n        if(n<=2) return 1;\\n        int root=nums[0];\\n        vector<int> left;\\n        vector<int> right;\\n        for(int i=1; i<n; i++){\\n            if(nums[i]<root) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        int l=left.size();\\n        int r=right.size();\\n\\n        long long lb=lrbst(left);\\n        long long rb=lrbst(right);\\n        return ((lb%mod*rb%mod)%mod*nCrModPFermat(n-1,l,mod))%mod;\\n    }\\n\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        long long ans=lrbst(nums);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644536,
                "title": "most-complicated-but-faster-than-93-users-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI dare you to find the intuition in this programme.\\n\\nUsed (dp + divide and conquer + combinatorics + Tree + dfs + math).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExtremely Complicated Approach consisting of making of the BST then\\nsolving the problme with the help of divide and conquer approch and to solve for one segment use the the combinatorics with finding all the nCr\\'s int only O(n)(for all combined).\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> fac;\\n    int MOD = 1e9 + 7;\\n    long long power(long long a, long long b,int m)\\n{\\n    if(b == 0) return 1;\\n\\n    a = a % m;\\n    long long temp = power(a, b/2,m);\\n    if(b&1)\\n        return (((temp * temp) % m) * a) % m;\\n    else\\n        return (temp * temp) % m;\\n}\\n\\nlong long modInverse(long long n, int p)\\n{\\n    return power(n, p - 2, p);\\n}\\nlong long mul(long long x,\\n                       long long y, int p)\\n{\\n    return x * 1ull * y % p;\\n}\\nlong long divide(long long x,\\n                          long long y, int p)\\n{\\n    return mul(x, modInverse(y, p), p);\\n}\\n    class bst{\\n        public:\\n            int val;\\n            bst* l;\\n            bst* r;\\n            bst(int v){\\n                val = v;\\n                l = NULL;\\n                r = NULL;\\n            }\\n    };\\n    pair<int,long long> dfs(bst* root){\\n        if(!root) return {0,1};\\n        pair<int,long long> a = dfs(root->l);\\n        pair<int,long long> b = dfs(root->r);\\n        long long ans = divide(fac[a.first+b.first],mul(fac[b.first],fac[a.first],MOD),MOD);\\n        ans = mul(ans,a.second,MOD);\\n        ans = mul(ans,b.second,MOD);\\n        return {(a.first+b.first+1),ans};\\n    }\\n    int numOfWays(vector<int>& arr) {\\n        bst* root = new bst(arr[0]);\\n        fac.push_back(1);\\n        for(int i = 1;i<arr.size();i++){\\n            fac.push_back((fac[i-1]*i)%MOD);\\n            int a = arr[i];\\n            bst* node = root;\\n            bst* t = new bst(a);\\n            while(1){\\n                if(a > node->val){\\n                    if(node->r == NULL){\\n                        node->r = t;\\n                        break;\\n                    }\\n                    node = node->r;\\n                }\\n                else{\\n                    if(node->l == NULL){\\n                        node->l = t;\\n                        break;\\n                    }\\n                    node = node->l;\\n                }\\n            }\\n        }\\n        return (int)(dfs(root).second - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> fac;\\n    int MOD = 1e9 + 7;\\n    long long power(long long a, long long b,int m)\\n{\\n    if(b == 0) return 1;\\n\\n    a = a % m;\\n    long long temp = power(a, b/2,m);\\n    if(b&1)\\n        return (((temp * temp) % m) * a) % m;\\n    else\\n        return (temp * temp) % m;\\n}\\n\\nlong long modInverse(long long n, int p)\\n{\\n    return power(n, p - 2, p);\\n}\\nlong long mul(long long x,\\n                       long long y, int p)\\n{\\n    return x * 1ull * y % p;\\n}\\nlong long divide(long long x,\\n                          long long y, int p)\\n{\\n    return mul(x, modInverse(y, p), p);\\n}\\n    class bst{\\n        public:\\n            int val;\\n            bst* l;\\n            bst* r;\\n            bst(int v){\\n                val = v;\\n                l = NULL;\\n                r = NULL;\\n            }\\n    };\\n    pair<int,long long> dfs(bst* root){\\n        if(!root) return {0,1};\\n        pair<int,long long> a = dfs(root->l);\\n        pair<int,long long> b = dfs(root->r);\\n        long long ans = divide(fac[a.first+b.first],mul(fac[b.first],fac[a.first],MOD),MOD);\\n        ans = mul(ans,a.second,MOD);\\n        ans = mul(ans,b.second,MOD);\\n        return {(a.first+b.first+1),ans};\\n    }\\n    int numOfWays(vector<int>& arr) {\\n        bst* root = new bst(arr[0]);\\n        fac.push_back(1);\\n        for(int i = 1;i<arr.size();i++){\\n            fac.push_back((fac[i-1]*i)%MOD);\\n            int a = arr[i];\\n            bst* node = root;\\n            bst* t = new bst(a);\\n            while(1){\\n                if(a > node->val){\\n                    if(node->r == NULL){\\n                        node->r = t;\\n                        break;\\n                    }\\n                    node = node->r;\\n                }\\n                else{\\n                    if(node->l == NULL){\\n                        node->l = t;\\n                        break;\\n                    }\\n                    node = node->l;\\n                }\\n            }\\n        }\\n        return (int)(dfs(root).second - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644435,
                "title": "editorial-solution-typescript-pascal-triangle",
                "content": "# \\n```\\nfunction numOfWays(nums: number[]): number {\\n  const mod = BigInt(10 ** 9 + 7);\\n  const table: number[][] = [];\\n\\n  // Fill Pascal Table\\n  for (let i = 0; i < nums.length; i++) {\\n    table[i] = new Array(i + 1).fill(1);\\n    for (let j = 1; j < nums.length; j++) {\\n      if (j > i) continue;\\n      const a = table[i - 1][j - 1] ?? 0;\\n      const b = table[i - 1][j] ?? 0;\\n      table[i][j] = (a + b) % Number(mod);\\n    }\\n  }\\n\\n  function getWaysHelper(nums: number[]): bigint {\\n    const m = nums.length;\\n    if (m < 3) return 1n;\\n\\n    const leftNodes: number[] = [];\\n    const rightNodes: number[] = [];\\n\\n    for (let i = 1; i < m; i++) {\\n      if (nums[i] < nums[0]) leftNodes.push(nums[i]);\\n      else rightNodes.push(nums[i]);\\n    }\\n\\n    const leftWays = getWaysHelper(leftNodes) % mod;\\n    const rightWays = getWaysHelper(rightNodes) % mod;\\n\\n    return (((leftWays * rightWays) % mod) * BigInt(table[m - 1][leftNodes.length])) % mod;\\n  }\\n\\n  const ways = getWaysHelper(nums) - 1n; // -1 original order\\n\\n  return Number(ways % mod);\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numOfWays(nums: number[]): number {\\n  const mod = BigInt(10 ** 9 + 7);\\n  const table: number[][] = [];\\n\\n  // Fill Pascal Table\\n  for (let i = 0; i < nums.length; i++) {\\n    table[i] = new Array(i + 1).fill(1);\\n    for (let j = 1; j < nums.length; j++) {\\n      if (j > i) continue;\\n      const a = table[i - 1][j - 1] ?? 0;\\n      const b = table[i - 1][j] ?? 0;\\n      table[i][j] = (a + b) % Number(mod);\\n    }\\n  }\\n\\n  function getWaysHelper(nums: number[]): bigint {\\n    const m = nums.length;\\n    if (m < 3) return 1n;\\n\\n    const leftNodes: number[] = [];\\n    const rightNodes: number[] = [];\\n\\n    for (let i = 1; i < m; i++) {\\n      if (nums[i] < nums[0]) leftNodes.push(nums[i]);\\n      else rightNodes.push(nums[i]);\\n    }\\n\\n    const leftWays = getWaysHelper(leftNodes) % mod;\\n    const rightWays = getWaysHelper(rightNodes) % mod;\\n\\n    return (((leftWays * rightWays) % mod) * BigInt(table[m - 1][leftNodes.length])) % mod;\\n  }\\n\\n  const ways = getWaysHelper(nums) - 1n; // -1 original order\\n\\n  return Number(ways % mod);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3644113,
                "title": "lets-make-it-easy-its-really-easy",
                "content": "\\n\\n# Approach\\nStep 1\\nWe split the array into root, leftsubtree elements, rightsubtree elements.\\nA simple filter loop would do that.\\n\\nWhy?\\n        We know the fundamentals of Binary Search Tree.\\n        1. All the elements in Left SubTree(lst) are smaller than Right SubTree(rst) elements.\\n        So the ordering of those elements in the array which belong to different subtree would be independent.\\n        2. Ordering of the elements in the same subtree matters and will be the same relativLY.\\n    Say a, b, c belong to lst, and d, e, f belong to rst. and the root of the tree is z\\n    So z, a,b,c,d,e,f will do fine and so will z, d,e,f,a,b,c.\\n    z, a,d,e,f,b,c will do fine (notice the relative orders)\\n    z, a,d,b,e,c,f will too be fine.\\n    These two sets are independent. Hence ordering wont affect the subtree\\'s invariant property.\\n    Now is the time to realize why ordering affects within the same subtree? (Take pen and paper to prove;)\\n\\n    So the problem turns out to be Leetcode Hard -> Leetcode easy naa?\\n\\n    Step 2:(Recursive thinking ;) )\\n    After splitting, we compute recursivel the same for left subtree and right subtree.\\n    We obtain the the no of orderings possiblefrom left subtree by abstracting a leftsubtree(a subproblem) into a tree itself.\\n    We obtain the the no of orderings possiblefrom right subtree by abstracting the right subtree(a subproblem) into a tree itself.\\n\\n\\n    Step3 : Conquer your subproblems!! ;) Understand the combinatorics very carefully.\\n    By Fundamental theorem of counting the total possible orderings are \\n    sl = size_of_left_subtree, sr = size_of_right_subtree;\\n    n  = sl + sr + 1(root) w here n is total size of the tree.    \\n    table[n - 1][left_subtree_size] * left_recusrsion_result * right_recursion_result;\\n    since pascal table is zero index based, ncr = table[n][r];\\n    where out of n - 1 places left_subtree_size places are fixed so we choose to maintain order. And \\n    left_recusrsion_result * right_recursion_result orderings can be places in such choices of arrangements.\\n\\n\\n    Side Note: \\n    To access ncr effectively, we use the pascals table and retrieve table[n + 1][r + 1]\\n    If we wish to compute say 4c2 then table[5][3] would return us the computation in O(1) time.Its necessary to use O(1) time instead of O(n) by the brute force approach which involves the computation over factorials.\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<long long>> table;\\n    long long mod;\\n    int solve(vector<int> &nums) {\\n        int n = nums.size();\\n        if(n <= 2) return 1;\\n\\n        vector<int> right, left;\\n        for(int i = 1; i < n; ++i) {\\n            if(nums[i] < nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }  \\n\\n        long long left_size = left.size(), right_size = right.size();\\n\\n        int left_orderings = solve(left) ;\\n        int right_orderings = solve(right) ;\\n\\n        return (((table[n - 1][left_size] * left_orderings) % mod) * right_orderings) % mod ;      \\n    }\\n    \\npublic:\\n    int numOfWays(vector<int>& nums) {  \\n\\n        int n = nums.size();\\n        mod = 1e9 + 7;\\n        for(int i = 0; i < n; ++i) {\\n            vector<long long> row(i + 1, 1);\\n            for(int j = 1; j < i; ++j) {\\n                row[j] = (table[i - 1][j] + table[i - 1][j - 1]) % mod;                 \\n            }\\n            table.push_back(row);\\n        }\\n        \\n        return solve(nums) - 1;\\n    \\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<long long>> table;\\n    long long mod;\\n    int solve(vector<int> &nums) {\\n        int n = nums.size();\\n        if(n <= 2) return 1;\\n\\n        vector<int> right, left;\\n        for(int i = 1; i < n; ++i) {\\n            if(nums[i] < nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }  \\n\\n        long long left_size = left.size(), right_size = right.size();\\n\\n        int left_orderings = solve(left) ;\\n        int right_orderings = solve(right) ;\\n\\n        return (((table[n - 1][left_size] * left_orderings) % mod) * right_orderings) % mod ;      \\n    }\\n    \\npublic:\\n    int numOfWays(vector<int>& nums) {  \\n\\n        int n = nums.size();\\n        mod = 1e9 + 7;\\n        for(int i = 0; i < n; ++i) {\\n            vector<long long> row(i + 1, 1);\\n            for(int j = 1; j < i; ++j) {\\n                row[j] = (table[i - 1][j] + table[i - 1][j - 1]) % mod;                 \\n            }\\n            table.push_back(row);\\n        }\\n        \\n        return solve(nums) - 1;\\n    \\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644031,
                "title": "c-dynamic-programming-divide-and-conquer-combinational-easy-to-understand-100ms",
                "content": "```\\nclass Solution {\\npublic:\\nconst long long mod = 1e9+7;\\nvector<long long>fact;\\nvoid calcFact(){\\n    fact[0] =1;\\n    fact[1] =1;\\n    for(long long i=2;i<1001;i++)\\n    fact[i] = (fact[i-1]*i)%mod;\\n}\\n\\nlong long modInv(long long n,long long p){\\n    if(p==0)\\n    return 1LL;\\n    long long ans = modInv(n,p/2);\\n    if(p&1)\\n    return (((ans*ans)%mod)*n)%mod;\\n    else\\n    return (ans*ans)%mod;\\n}\\n\\nlong long help(vector<int>&nums){\\n    if(nums.size()<=2)\\n    return 1LL;\\n    vector<int>small,large;\\n    for(int i=1;i<nums.size();i++){\\n        if(nums[i]>nums[0])\\n        large.push_back(nums[i]);\\n        else\\n        small.push_back(nums[i]);\\n    }\\n    long long ans =1;\\n    ans = (ans*fact[(int)nums.size()-1])%mod;\\n    ans =(ans*modInv(fact[(int)nums.size()-(int)small.size()-1],mod-2))%mod;\\n    ans = (ans*modInv(fact[(int)small.size()],mod-2))%mod;\\n    ans = (ans*help(small))%mod;\\n    ans = (ans*help(large))%mod;\\n    return ans;\\n}\\n    int numOfWays(vector<int>& nums) {\\n        fact = vector<long long>(1001);\\n        calcFact();\\n        long long ans = help(nums);\\n        ans--;\\n        ans = (ans+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nconst long long mod = 1e9+7;\\nvector<long long>fact;\\nvoid calcFact(){\\n    fact[0] =1;\\n    fact[1] =1;\\n    for(long long i=2;i<1001;i++)\\n    fact[i] = (fact[i-1]*i)%mod;\\n}\\n\\nlong long modInv(long long n,long long p){\\n    if(p==0)\\n    return 1LL;\\n    long long ans = modInv(n,p/2);\\n    if(p&1)\\n    return (((ans*ans)%mod)*n)%mod;\\n    else\\n    return (ans*ans)%mod;\\n}\\n\\nlong long help(vector<int>&nums){\\n    if(nums.size()<=2)\\n    return 1LL;\\n    vector<int>small,large;\\n    for(int i=1;i<nums.size();i++){\\n        if(nums[i]>nums[0])\\n        large.push_back(nums[i]);\\n        else\\n        small.push_back(nums[i]);\\n    }\\n    long long ans =1;\\n    ans = (ans*fact[(int)nums.size()-1])%mod;\\n    ans =(ans*modInv(fact[(int)nums.size()-(int)small.size()-1],mod-2))%mod;\\n    ans = (ans*modInv(fact[(int)small.size()],mod-2))%mod;\\n    ans = (ans*help(small))%mod;\\n    ans = (ans*help(large))%mod;\\n    return ans;\\n}\\n    int numOfWays(vector<int>& nums) {\\n        fact = vector<long long>(1001);\\n        calcFact();\\n        long long ans = help(nums);\\n        ans--;\\n        ans = (ans+mod)%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643755,
                "title": "c-easy-understanding-recursion",
                "content": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    long inverse(long num) {\\n        if (num == 1) {\\n            return 1;\\n        }\\n        return mod - mod / num * inverse(mod % num) % mod;\\n    }\\n\\n    int dfs(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 2)  return 1;\\n        \\n        vector<int> left, right;\\n        for (int i = 1; i < N; i++) \\n        {\\n            if (nums[i] < nums[0]) \\n                left.push_back(nums[i]);\\n            else \\n                right.push_back(nums[i]);\\n         }\\n\\n        int a = left.size();\\n        int b = right.size();\\n        long res = 1;\\n        for (int i = b+1; i <= a + b; i++) res = res * i % mod;\\n        \\n        for (int i = 1; i <= a; i++)  res = res * inverse(i) % mod;\\n        \\n        return res * dfs(left) % mod * dfs(right) % mod;\\n    }\\n    \\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        return dfs(nums) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    const int mod = 1e9 + 7;\\n    long inverse(long num) {\\n        if (num == 1) {\\n            return 1;\\n        }\\n        return mod - mod / num * inverse(mod % num) % mod;\\n    }\\n\\n    int dfs(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N <= 2)  return 1;\\n        \\n        vector<int> left, right;\\n        for (int i = 1; i < N; i++) \\n        {\\n            if (nums[i] < nums[0]) \\n                left.push_back(nums[i]);\\n            else \\n                right.push_back(nums[i]);\\n         }\\n\\n        int a = left.size();\\n        int b = right.size();\\n        long res = 1;\\n        for (int i = b+1; i <= a + b; i++) res = res * i % mod;\\n        \\n        for (int i = 1; i <= a; i++)  res = res * inverse(i) % mod;\\n        \\n        return res * dfs(left) % mod * dfs(right) % mod;\\n    }\\n    \\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        return dfs(nums) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643725,
                "title": "dp-combinatrics-recursion-c",
                "content": "**Trick to find nCr using dp is**    nCr = n-1Cr-1 + n-1Cr\\n\\nlets suppose that we know the answer to rearrange the elements of left subtree and of the right subtree and now we want to construct our final answer for current root\\n\\nout of ```n-1``` places we need to choose ```left.size( ) ``` places and put left subtree elements permutation on those places and right subtree elements in the remaining places.\\n\\n**so, ans = (n-1) C ( left.size( ) ) * left * right**\\n\\nleft is numbers of ways to rearrange the elements of left subree so that it generates the same bst as the left subtree of the original bst and similarly for the right.\\nbasically left is the answer for our recursion call for left subtree and right is the answer for recursion call on right subtree.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    long long dp[1001][1001] = {};\\n    \\n    int helper(vector<int> & nums){\\n        if(nums.size() <= 2)\\n            return 1;\\n        \\n        int n = nums.size(); \\n        vector<int> left, right;\\n        for(int i = 1; i<n; i++){\\n            if(nums[i] < nums[0])\\n                left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        \\n        int leftAns = helper(left), rightAns = helper(right);\\n                \\n        return (((dp[n-1][left.size()] * leftAns)%mod) * rightAns)%mod;\\n    \\n    }\\n    \\n    \\n    int numOfWays(vector<int>& nums) {\\n        for(int n = 0; n <= 1000; n++){\\n            dp[n][0] = 1;\\n        }\\n        for(int n = 1; n <= 1000; n++){\\n            for(int r = 1; r <= n; r++){\\n\\t\\t\\t\\t// nCr = n-1Cr-1 + n-1Cr\\n                dp[n][r] = (dp[n-1][r-1] + dp[n-1][r])%mod;\\n            }\\n        }\\n        \\n        int res = (helper(nums) - 1 + mod)%mod;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```n-1```\n```left.size( ) ```\n```\\nclass Solution {\\npublic:\\n    \\n    int mod = 1e9 + 7;\\n    long long dp[1001][1001] = {};\\n    \\n    int helper(vector<int> & nums){\\n        if(nums.size() <= 2)\\n            return 1;\\n        \\n        int n = nums.size(); \\n        vector<int> left, right;\\n        for(int i = 1; i<n; i++){\\n            if(nums[i] < nums[0])\\n                left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        \\n        int leftAns = helper(left), rightAns = helper(right);\\n                \\n        return (((dp[n-1][left.size()] * leftAns)%mod) * rightAns)%mod;\\n    \\n    }\\n    \\n    \\n    int numOfWays(vector<int>& nums) {\\n        for(int n = 0; n <= 1000; n++){\\n            dp[n][0] = 1;\\n        }\\n        for(int n = 1; n <= 1000; n++){\\n            for(int r = 1; r <= n; r++){\\n\\t\\t\\t\\t// nCr = n-1Cr-1 + n-1Cr\\n                dp[n][r] = (dp[n-1][r-1] + dp[n-1][r])%mod;\\n            }\\n        }\\n        \\n        int res = (helper(nums) - 1 + mod)%mod;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643594,
                "title": "editorial-solution-c-100-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*Following the steps from the \\'Editorial\\' of the problem.*\\nhttps://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/editorial/\\n\\n***We can either implement a function to form Pascal Triangle..\\n[or]\\nDefine a function to calculate nCr -> n! / ((n-r)! * r!) with help of caching to avoid TLE due to same function being called over-and-over again during recursion***\\n\\n![Screenshot 2023-06-16 084304.png](https://assets.leetcode.com/users/images/31770ba5-575f-4213-9342-ca63d1a77e58_1686885266.3785398.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N ^ 2) - as we form Pascal Triangle\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N ^ 2) - as we form Pascal Triangle\\n\\n# Code\\n```\\npublic class Solution {\\n    Dictionary<long, double> cache = new Dictionary<long, double>();\\n    int mod = 1000000007;\\n    long[][] table;\\n\\n    public int NumOfWays(int[] nums) {\\n        FormPascalTriagle(nums.Length);\\n        return (int)DFS(nums.ToList()) - 1;\\n    }\\n\\n    private long DFS(List<int> nums)\\n    {\\n        int n = nums.Count;\\n        if (n <= 2)\\n            return 1;\\n        \\n        List<int> smaller = new List<int>();\\n        List<int> greater = new List<int>();\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (nums[i] < nums[0])\\n                smaller.Add(nums[i]);\\n            else\\n                greater.Add(nums[i]);\\n        }\\n\\n        //apply mod after every product to avoid overflow\\n        return (table[n - 1][smaller.Count] * \\n            (DFS(smaller) % mod) % mod) *\\n            DFS(greater) % mod;\\n\\n    }\\n\\n    //Either form a Pascal triangle in the beginning..\\n    //or\\n    //implement a function to calculate nCr = n!/ ((n-r)! * r!)\\n\\n    //For the second approach, we\\'ll have to have Cache in place...\\n    //...to avoid TLE due to recursion calling same methods over and over again\\n    private void FormPascalTriagle(int n) {\\n        table = new long[n][];\\n        for (int i = 0; i < n; i++)\\n            table[i] = new long[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            table[i][0] = 1;\\n            table[i][i] = 1;\\n        }\\n\\n        for (int i = 2; i < n; i++)\\n        {\\n            for (int j = 1; j < i; j++)\\n            {\\n                table[i][j] = (table[i - 1][j] + table[i - 1][j - 1]) % mod;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Math",
                    "Dynamic Programming",
                    "Binary Search Tree"
                ],
                "code": "```\\npublic class Solution {\\n    Dictionary<long, double> cache = new Dictionary<long, double>();\\n    int mod = 1000000007;\\n    long[][] table;\\n\\n    public int NumOfWays(int[] nums) {\\n        FormPascalTriagle(nums.Length);\\n        return (int)DFS(nums.ToList()) - 1;\\n    }\\n\\n    private long DFS(List<int> nums)\\n    {\\n        int n = nums.Count;\\n        if (n <= 2)\\n            return 1;\\n        \\n        List<int> smaller = new List<int>();\\n        List<int> greater = new List<int>();\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (nums[i] < nums[0])\\n                smaller.Add(nums[i]);\\n            else\\n                greater.Add(nums[i]);\\n        }\\n\\n        //apply mod after every product to avoid overflow\\n        return (table[n - 1][smaller.Count] * \\n            (DFS(smaller) % mod) % mod) *\\n            DFS(greater) % mod;\\n\\n    }\\n\\n    //Either form a Pascal triangle in the beginning..\\n    //or\\n    //implement a function to calculate nCr = n!/ ((n-r)! * r!)\\n\\n    //For the second approach, we\\'ll have to have Cache in place...\\n    //...to avoid TLE due to recursion calling same methods over and over again\\n    private void FormPascalTriagle(int n) {\\n        table = new long[n][];\\n        for (int i = 0; i < n; i++)\\n            table[i] = new long[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            table[i][0] = 1;\\n            table[i][i] = 1;\\n        }\\n\\n        for (int i = 2; i < n; i++)\\n        {\\n            for (int j = 1; j < i; j++)\\n            {\\n                table[i][j] = (table[i - 1][j] + table[i - 1][j - 1]) % mod;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643589,
                "title": "rust",
                "content": "When computing `(a / b) % m` in function `Combination(a, b)`, we cannot treat it as `a % m / (b % m)`, we can only apply `% m` to the final result, but overflow may happen when multiplying.\\nWe can use `mod inserse` to transform it into `a * mod_inverse(b) % m`, then apply `% m` anywhere as we want.\\n\\n```\\nimpl Solution {\\n    pub fn num_of_ways(nums: Vec<i32>) -> i32 {\\n        Self::count(nums) as i32 - 1\\n    }\\n\\n    fn count(nums: Vec<i32>) -> usize {\\n        if nums.len() <= 2 {\\n            return 1;\\n        }\\n\\n        let mut left = vec![];\\n        let mut right = vec![];\\n        let root = nums[0];\\n        for n in nums.into_iter().skip(1) {\\n            if n > root {\\n                right.push(n);\\n            } else {\\n                left.push(n);\\n            }\\n        }\\n        let m = 1_000_000_007;\\n        let mut ret = Self::foo(left.len(), right.len());\\n        if ret == 0 {\\n            ret = 1;\\n        }\\n        let left = Self::count(left);\\n        let right = Self::count(right);\\n        ret = ret * left % m * right % m;\\n        ret\\n    }\\n\\n    // for example:\\n    // n is 2: [1, 2]\\n    // m is 2: [3, 4]\\n    // merge m array into a array, keep themselies order\\n    // [3, 4, 1, 2], [1, 3, 4, 2], [1, 2, 3, 4]\\n    // [3, 1, 4, 2], [3, 1, 2, 4], [1, 3, 2, 4]\\n    fn foo(mut n: usize, mut m: usize) -> usize {\\n        Self::C(n + m, n)\\n    }\\n\\n    // Combination number, pick r from n\\n    fn C(n: usize, r: usize) -> usize {\\n        (1..=r.min(n - r)).fold(1, |acc, i| acc * (n - i + 1) % 1_000_000_007 * Self::mod_inverse(i) % 1_000_000_007)\\n    }\\n\\n    // modular inverse, use Fermat\\'s little theorem\\n    // a^(M - 1) === 1 (mod M) => a^-1 === a^(M - 2) (mod M)\\n    fn mod_inverse(mut a: usize) -> usize {\\n        Self::power(a, 1_000_000_005)\\n    }\\n\\n    // a ^ b % M\\n    fn power(mut a: usize, mut b: usize) -> usize {\\n        let mut ret = 1;\\n        let m = 1_000_000_007;\\n        while b > 0 {\\n            if b & 1 == 1 {\\n                ret = (ret * a) % m;\\n            }\\n            a = (a * a) % m;\\n            b >>= 1;\\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_of_ways(nums: Vec<i32>) -> i32 {\\n        Self::count(nums) as i32 - 1\\n    }\\n\\n    fn count(nums: Vec<i32>) -> usize {\\n        if nums.len() <= 2 {\\n            return 1;\\n        }\\n\\n        let mut left = vec![];\\n        let mut right = vec![];\\n        let root = nums[0];\\n        for n in nums.into_iter().skip(1) {\\n            if n > root {\\n                right.push(n);\\n            } else {\\n                left.push(n);\\n            }\\n        }\\n        let m = 1_000_000_007;\\n        let mut ret = Self::foo(left.len(), right.len());\\n        if ret == 0 {\\n            ret = 1;\\n        }\\n        let left = Self::count(left);\\n        let right = Self::count(right);\\n        ret = ret * left % m * right % m;\\n        ret\\n    }\\n\\n    // for example:\\n    // n is 2: [1, 2]\\n    // m is 2: [3, 4]\\n    // merge m array into a array, keep themselies order\\n    // [3, 4, 1, 2], [1, 3, 4, 2], [1, 2, 3, 4]\\n    // [3, 1, 4, 2], [3, 1, 2, 4], [1, 3, 2, 4]\\n    fn foo(mut n: usize, mut m: usize) -> usize {\\n        Self::C(n + m, n)\\n    }\\n\\n    // Combination number, pick r from n\\n    fn C(n: usize, r: usize) -> usize {\\n        (1..=r.min(n - r)).fold(1, |acc, i| acc * (n - i + 1) % 1_000_000_007 * Self::mod_inverse(i) % 1_000_000_007)\\n    }\\n\\n    // modular inverse, use Fermat\\'s little theorem\\n    // a^(M - 1) === 1 (mod M) => a^-1 === a^(M - 2) (mod M)\\n    fn mod_inverse(mut a: usize) -> usize {\\n        Self::power(a, 1_000_000_005)\\n    }\\n\\n    // a ^ b % M\\n    fn power(mut a: usize, mut b: usize) -> usize {\\n        let mut ret = 1;\\n        let m = 1_000_000_007;\\n        while b > 0 {\\n            if b & 1 == 1 {\\n                ret = (ret * a) % m;\\n            }\\n            a = (a * a) % m;\\n            b >>= 1;\\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643588,
                "title": "ruby-from-editorial-somewhat-easy-to-understand",
                "content": "```\\nMOD = 10 ** 9 + 7\\n\\ndef factorial (n)\\n    n.downto(1).inject(:*) || 1\\nend \\n\\ndef comb (n, k)\\n    return factorial(n) / (factorial(k) * factorial(n - k))\\nend\\n\\ndef dfs(nums)\\n    return 1 if (nums.length < 3)\\n    left_nodes = nums.filter {|a| a < nums[0]}\\n    right_nodes = nums.filter {|a| a > nums[0]}\\n    return dfs(left_nodes) * dfs(right_nodes) * comb(nums.length - 1, left_nodes.length) % MOD\\nend \\n\\ndef num_of_ways(nums)\\n    (dfs(nums) - 1) % MOD\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nMOD = 10 ** 9 + 7\\n\\ndef factorial (n)\\n    n.downto(1).inject(:*) || 1\\nend \\n\\ndef comb (n, k)\\n    return factorial(n) / (factorial(k) * factorial(n - k))\\nend\\n\\ndef dfs(nums)\\n    return 1 if (nums.length < 3)\\n    left_nodes = nums.filter {|a| a < nums[0]}\\n    right_nodes = nums.filter {|a| a > nums[0]}\\n    return dfs(left_nodes) * dfs(right_nodes) * comb(nums.length - 1, left_nodes.length) % MOD\\nend \\n\\ndef num_of_ways(nums)\\n    (dfs(nums) - 1) % MOD\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3643567,
                "title": "c-recursion-combinatorics-using-pascal-table-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    vector<vector<int64>> table;\\n    const int MOD = (int)1e9 + 7;\\n    \\n    // ways(nums) = ways(leftNodes) * ways(rightNodes) * (nums.size() - 1)C(leftNodes.size())\\n    // (nums.size() - 1)C(leftNodes.size()) = num of ways to keep leftNodes in same order keeping the root\\'s position unchanged.\\n\\n    int64 solve(vector<int> &nums) {\\n        int n = nums.size();\\n        if(n <= 2) {\\n            return 1;\\n        }\\n        vector<int> leftNodes, rightNodes;\\n        for(int i = 1; i < n; i++) {\\n            if(nums[i] < nums[0]) {\\n                leftNodes.push_back(nums[i]);\\n            } else {\\n                rightNodes.push_back(nums[i]);\\n            }\\n        }\\n        int64 leftWays = solve(leftNodes) % MOD;\\n        int64 rightWays = solve(rightNodes) % MOD;\\n        return ((leftWays * rightWays) % MOD) * table[n - 1][leftNodes.size()] % MOD;\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        table.resize(n + 1); // pascal triangle\\n        for(int i = 0; i < (n + 1); i++) {\\n            table[i] = vector<int64> (i + 1, 1);\\n            for(int j = 1; j < i; j++) {\\n                // nCr + nCr-1 = n+1Cr\\n                table[i][j] = (table[i - 1][j] + table[i - 1][j - 1]) % MOD;\\n            }\\n        }\\n\\n        return (solve(nums) - 1) % MOD;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    vector<vector<int64>> table;\\n    const int MOD = (int)1e9 + 7;\\n    \\n    // ways(nums) = ways(leftNodes) * ways(rightNodes) * (nums.size() - 1)C(leftNodes.size())\\n    // (nums.size() - 1)C(leftNodes.size()) = num of ways to keep leftNodes in same order keeping the root\\'s position unchanged.\\n\\n    int64 solve(vector<int> &nums) {\\n        int n = nums.size();\\n        if(n <= 2) {\\n            return 1;\\n        }\\n        vector<int> leftNodes, rightNodes;\\n        for(int i = 1; i < n; i++) {\\n            if(nums[i] < nums[0]) {\\n                leftNodes.push_back(nums[i]);\\n            } else {\\n                rightNodes.push_back(nums[i]);\\n            }\\n        }\\n        int64 leftWays = solve(leftNodes) % MOD;\\n        int64 rightWays = solve(rightNodes) % MOD;\\n        return ((leftWays * rightWays) % MOD) * table[n - 1][leftNodes.size()] % MOD;\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        table.resize(n + 1); // pascal triangle\\n        for(int i = 0; i < (n + 1); i++) {\\n            table[i] = vector<int64> (i + 1, 1);\\n            for(int j = 1; j < i; j++) {\\n                // nCr + nCr-1 = n+1Cr\\n                table[i][j] = (table[i - 1][j] + table[i - 1][j - 1]) % MOD;\\n            }\\n        }\\n\\n        return (solve(nums) - 1) % MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643493,
                "title": "c-solution",
                "content": "# Code\\n```\\n#define MOD 1000000007\\nlong long dfs(int *nums, int numsSize, int **combination_table)\\n{\\n  if(numsSize<3)\\n    return 1;\\n  int *large = (int*)malloc(sizeof(int)*10000);\\n  int *small = (int*)malloc(sizeof(int)*10000);\\n  int lidx=0, sidx=0;\\n  for(int i=1;i<numsSize;i++)\\n  {\\n    if(nums[i]>nums[0])\\n      large[lidx++] = nums[i];\\n    else\\n      small[sidx++] = nums[i];\\n  }\\n  large = realloc(large, sizeof(int)*lidx);\\n  small = realloc(small, sizeof(int)*sidx);\\n  long long largeway = dfs(large, lidx, combination_table)%MOD;\\n  long long smallway = dfs(small, sidx, combination_table)%MOD;\\n\\n  return ((largeway*smallway)%MOD)*(combination_table[numsSize-1][lidx])%MOD;\\n}\\n\\n\\nint numOfWays(int* nums, int numsSize){\\n  int i, j;\\n\\n  int **combination_table = (int**)malloc(sizeof(int*)*numsSize);\\n  for(i=0;i<numsSize;i++)\\n    combination_table[i] = (int*)malloc(sizeof(int)*numsSize);\\n  \\n  for(i=0;i<numsSize;i++)\\n  {\\n    for(j=0;j<=i;j++)\\n    {\\n      if(j==0 || i==j)\\n        combination_table[i][j] = 1;\\n      else\\n        combination_table[i][j] = (combination_table[i-1][j] + combination_table[i-1][j-1])%MOD;\\n    }\\n  }\\n\\n  return (dfs(nums, numsSize, combination_table)-1)%MOD;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MOD 1000000007\\nlong long dfs(int *nums, int numsSize, int **combination_table)\\n{\\n  if(numsSize<3)\\n    return 1;\\n  int *large = (int*)malloc(sizeof(int)*10000);\\n  int *small = (int*)malloc(sizeof(int)*10000);\\n  int lidx=0, sidx=0;\\n  for(int i=1;i<numsSize;i++)\\n  {\\n    if(nums[i]>nums[0])\\n      large[lidx++] = nums[i];\\n    else\\n      small[sidx++] = nums[i];\\n  }\\n  large = realloc(large, sizeof(int)*lidx);\\n  small = realloc(small, sizeof(int)*sidx);\\n  long long largeway = dfs(large, lidx, combination_table)%MOD;\\n  long long smallway = dfs(small, sidx, combination_table)%MOD;\\n\\n  return ((largeway*smallway)%MOD)*(combination_table[numsSize-1][lidx])%MOD;\\n}\\n\\n\\nint numOfWays(int* nums, int numsSize){\\n  int i, j;\\n\\n  int **combination_table = (int**)malloc(sizeof(int*)*numsSize);\\n  for(i=0;i<numsSize;i++)\\n    combination_table[i] = (int*)malloc(sizeof(int)*numsSize);\\n  \\n  for(i=0;i<numsSize;i++)\\n  {\\n    for(j=0;j<=i;j++)\\n    {\\n      if(j==0 || i==j)\\n        combination_table[i][j] = 1;\\n      else\\n        combination_table[i][j] = (combination_table[i-1][j] + combination_table[i-1][j-1])%MOD;\\n    }\\n  }\\n\\n  return (dfs(nums, numsSize, combination_table)-1)%MOD;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643445,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        mod=10**9+7\\n        \\n        def f(nums):\\n            n=len(nums)\\n            if n<=1:\\n                return len(nums) \\n\\n            left=[i for i in nums if i<nums[0]]\\n            right=[i for i in nums if i>nums[0]]\\n\\n            Left=f(left)\\n            Right=f(right)\\n\\n            if not Left or not Right :\\n                return Left or Right\\n            ans=comb(len(right)+len(left),len(right))\\n            return ans*Left*Right\\n\\n        return (f(nums)-1)%mod    \\n\\n        return (f(nums)-1)%mod        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        mod=10**9+7\\n        \\n        def f(nums):\\n            n=len(nums)\\n            if n<=1:\\n                return len(nums) \\n\\n            left=[i for i in nums if i<nums[0]]\\n            right=[i for i in nums if i>nums[0]]\\n\\n            Left=f(left)\\n            Right=f(right)\\n\\n            if not Left or not Right :\\n                return Left or Right\\n            ans=comb(len(right)+len(left),len(right))\\n            return ans*Left*Right\\n\\n        return (f(nums)-1)%mod    \\n\\n        return (f(nums)-1)%mod        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643411,
                "title": "easiest-java-solution-using-biginteger-class-of-java",
                "content": "# Intuition\\nFirst element is always fixed , now take rest elements and divide array in two arrays and repeat same process for each array. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTake first element as root, not divide array in two parts which contains lesser elments and greater elements than the root node respectively and put in new array in same order. \\nNow except first place we can use rest all places to put the elements, we will find this by taking any required place ant put it in order, now we repeat the same operation for the two divided arrays. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    int ans = 0;\\n    BigInteger[] b = new BigInteger[1001];\\n    BigInteger m = new BigInteger(\"1000000007\");\\n    BigInteger m2 = factorial(1000);\\n    public int numOfWays(int[] nums) {\\n        b[0] = BigInteger.ONE;\\n        b[1] = BigInteger.ONE;\\n        int n = nums.length;\\n        if(n<=2) return 0;\\n        return (solve(nums).subtract(BigInteger.ONE)).mod(m).intValue();\\n    }\\n    public BigInteger solve(int[] nums){\\n        int n = nums.length;\\n        if(n<=2) return BigInteger.ONE;;\\n        int[] ar , br;\\n        int l = 0, h = 0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[0]){\\n                h++;\\n            }else{\\n                l++;\\n            }\\n        }\\n        ar = new int[h];\\n        br = new int[l];\\n        h = 0;\\n        l = 0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[0]){\\n                ar[h] = nums[i];\\n                h++;\\n            }else{\\n                br[l] = nums[i];\\n                l++;\\n            }\\n        }\\n        return ((b[n-1].divide(b[h]).divide(b[n-1-h]).mod(m).multiply(solve(ar)).multiply(solve(br)).mod(m))).mod(m);\\n    }\\n    public BigInteger factorial(int num){\\n    if (num<=1)\\n        return BigInteger.ONE;\\n    else\\n        return b[num] = factorial(num-1).multiply(BigInteger.valueOf(num));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\nclass Solution {\\n    int ans = 0;\\n    BigInteger[] b = new BigInteger[1001];\\n    BigInteger m = new BigInteger(\"1000000007\");\\n    BigInteger m2 = factorial(1000);\\n    public int numOfWays(int[] nums) {\\n        b[0] = BigInteger.ONE;\\n        b[1] = BigInteger.ONE;\\n        int n = nums.length;\\n        if(n<=2) return 0;\\n        return (solve(nums).subtract(BigInteger.ONE)).mod(m).intValue();\\n    }\\n    public BigInteger solve(int[] nums){\\n        int n = nums.length;\\n        if(n<=2) return BigInteger.ONE;;\\n        int[] ar , br;\\n        int l = 0, h = 0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[0]){\\n                h++;\\n            }else{\\n                l++;\\n            }\\n        }\\n        ar = new int[h];\\n        br = new int[l];\\n        h = 0;\\n        l = 0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[0]){\\n                ar[h] = nums[i];\\n                h++;\\n            }else{\\n                br[l] = nums[i];\\n                l++;\\n            }\\n        }\\n        return ((b[n-1].divide(b[h]).divide(b[n-1-h]).mod(m).multiply(solve(ar)).multiply(solve(br)).mod(m))).mod(m);\\n    }\\n    public BigInteger factorial(int num){\\n    if (num<=1)\\n        return BigInteger.ONE;\\n    else\\n        return b[num] = factorial(num-1).multiply(BigInteger.valueOf(num));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643400,
                "title": "ruby-solution-with-memoization-and-explanation-100-100",
                "content": "# Intuition\\nUse recursion: for each tree, split it into the left subtree and the right subtree, then calculate the number of ways based on the length and structure of each subtree.\\n\\n# Approach\\n0. Create a class memo to return the number of arrangements of normalized arrays.  (Normalized here means it uses the numbers 1-n.)\\n\\nFind the number of ways to form a tree from the original array with a helper function, subtract 1, and do modulo.\\n\\nMain helper function:\\n1. Return a memoized version if it\\'s stored.\\n\\n2. Divide the elements other than the root into the left subtree and right subtree, keeping them in the same order.\\n3. Normalize the right subtree (e.g., if it\\'s [5,7,6], convert it to [1,3,2]).  We do this with a helper function.  (Note that we don\\'t have to normalize the left; since it\\'s the smaller section of a normalized array, it will always go 1-n.)\\n4. Find the number of ways to arrange each subtree.\\n\\n5. Multiply the number of ways to arrange each subtree for result.\\n6. Multiply this result by the orderings helper function.\\n\\nAs an example, if the left subtree had 3 elements and the right subtree had 5 elements, they would have 8 elements in total.  The left elements have to keep relative order, as do the right elements, but we can changes when we do left elements versus right elements.  Essentially, we have 8 spots and want to find how many ways we can choose 3 of them to be elements from the left subtree.  This is just combinations, which we can calculate with factorials.  (Look up combinations/factorials if this part doesn\\'t make sense.)\\n\\n7. Mod the result, memoize, and return.\\n\\n# Complexity\\n- Time complexity:\\nThis is pretty from quick sort, but it divides the array the same way in the recursive step, so time complexity is the same: $$O(n *log(n))$$ average case, $$O(n^2)$$ worst case.\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n@memo = {[] => 1, [1] => 1, [1,2] => 1}\\n\\ndef num_of_ways(nums)\\n    (num_ways(nums) - 1) % 1000000007\\nend\\n\\ndef num_ways(nums)\\n    return @memo[nums] if @memo[nums]\\n\\n    left = nums.select { |num| num < nums[0] }\\n    right = nums.select { |num| num > nums[0] }\\n    right = normalize(right)\\n    left_ways,right_ways = num_ways(left),num_ways(right)\\n\\n    res = left_ways * right_ways\\n    res *= orderings(left.length,right.length)\\n\\n    @memo[nums] = res % 1000000007\\nend\\n\\ndef orderings(a,b)\\n    fact(a+b) / fact(a) / fact(b)\\nend\\n\\ndef fact(n)\\n    return 1 if n < 2\\n    i = 1\\n    (2..n).each { |k| i *= k }\\n    i\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n@memo = {[] => 1, [1] => 1, [1,2] => 1}\\n\\ndef num_of_ways(nums)\\n    (num_ways(nums) - 1) % 1000000007\\nend\\n\\ndef num_ways(nums)\\n    return @memo[nums] if @memo[nums]\\n\\n    left = nums.select { |num| num < nums[0] }\\n    right = nums.select { |num| num > nums[0] }\\n    right = normalize(right)\\n    left_ways,right_ways = num_ways(left),num_ways(right)\\n\\n    res = left_ways * right_ways\\n    res *= orderings(left.length,right.length)\\n\\n    @memo[nums] = res % 1000000007\\nend\\n\\ndef orderings(a,b)\\n    fact(a+b) / fact(a) / fact(b)\\nend\\n\\ndef fact(n)\\n    return 1 if n < 2\\n    i = 1\\n    (2..n).each { |k| i *= k }\\n    i\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3643383,
                "title": "c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9+7;\\n    vector<vector<long long>> table;\\n\\n    void insert(TreeNode *root, int num){\\n    \\n        if(root->val == -1){\\n            root->val = num;\\n        }\\n        else{\\n            if(root->val < num){\\n                if(!root->right)root->right = new TreeNode(-1);\\n                insert(root->right, num);\\n            }\\n            else{\\n                if(!root->left)root->left = new TreeNode(-1);\\n                insert(root->left, num);\\n            }\\n        }\\n\\n    }\\n\\n    pair<int, int> dp(TreeNode *root){\\n        if(!root)return {0, 1};\\n        else{\\n\\n            auto l = dp(root->left);\\n            auto r = dp(root->right);\\n\\n            pair<int, int> p;\\n            p.first = l.first + r.first + 1;\\n            p.second = ((( table[p.first - 1][l.first] * l.second) % mod) * r.second) % mod;\\n            \\n            return p;\\n        }\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n>2){\\n            TreeNode *root = new TreeNode(-1);\\n            for(int x: nums){\\n                insert(root, x);\\n            }\\n\\n            table.resize(n + 1);\\n            for(int i = 0; i < n + 1; ++i){\\n                table[i] = vector<long long>(i + 1, 1);\\n                for(int j = 1; j < i; ++j){\\n                    table[i][j] = (table[i-1][j-1] + table[i-1][j]) % mod;\\n                }\\n            }\\n\\n            return dp(root).second - 1;\\n        }\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Tree",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int mod = 1e9+7;\\n    vector<vector<long long>> table;\\n\\n    void insert(TreeNode *root, int num){\\n    \\n        if(root->val == -1){\\n            root->val = num;\\n        }\\n        else{\\n            if(root->val < num){\\n                if(!root->right)root->right = new TreeNode(-1);\\n                insert(root->right, num);\\n            }\\n            else{\\n                if(!root->left)root->left = new TreeNode(-1);\\n                insert(root->left, num);\\n            }\\n        }\\n\\n    }\\n\\n    pair<int, int> dp(TreeNode *root){\\n        if(!root)return {0, 1};\\n        else{\\n\\n            auto l = dp(root->left);\\n            auto r = dp(root->right);\\n\\n            pair<int, int> p;\\n            p.first = l.first + r.first + 1;\\n            p.second = ((( table[p.first - 1][l.first] * l.second) % mod) * r.second) % mod;\\n            \\n            return p;\\n        }\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        if(n>2){\\n            TreeNode *root = new TreeNode(-1);\\n            for(int x: nums){\\n                insert(root, x);\\n            }\\n\\n            table.resize(n + 1);\\n            for(int i = 0; i < n + 1; ++i){\\n                table[i] = vector<long long>(i + 1, 1);\\n                for(int j = 1; j < i; ++j){\\n                    table[i][j] = (table[i-1][j-1] + table[i-1][j]) % mod;\\n                }\\n            }\\n\\n            return dp(root).second - 1;\\n        }\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270351,
                "title": "golang-solution-with-memoized-comb-function",
                "content": "```\\nconst MOD = 1000000007\\n\\nfunc numOfWays(nums []int) int {\\n    cf := combFunc()\\n    return int((helper(nums, cf) - 1) % MOD)\\n}\\n\\nfunc helper(n []int, comb func(x, y int64) int64) int64 {\\n    if len(n) <= 2 {\\n        return 1\\n    }\\n    left,right := []int{}, []int{}\\n\\n    // Split elements compared to root (n[0])\\n    for _, el := range n {\\n        if el < n[0] {\\n            left = append(left, el)\\n        } else if el > n[0]{\\n            right = append(right, el)\\n        }\\n    }\\n\\n    ll := int64(len(left))\\n    lr := int64(len(right))\\n    // 1. Find all combinations of possible arrangements of left and right\\n    //     without losing relative order \\n    // 2. Find result for left and right elements recursively \\n    // 3. Multiply all\\n    ways := ((comb(ll + lr, lr) * helper(left, comb)) % MOD) * helper(right, comb) \\n    return ways % MOD\\n}\\n\\nfunc combFunc() func(x, y int64) int64 {\\n    type item struct {\\n        x, y int64\\n    }\\n    var cache = map[item]int64{}\\n    var comb func(x, y int64) int64 \\n    // https://dotnettutorials.net/lesson/combination-formula-using-recursion-in-c/\\n    comb = func(x, y int64) int64 {\\n        if y == 0 || x == y {\\n            return 1\\n        }\\n        \\n        it := item{x, y}\\n        if cache[it] != 0 {\\n            return cache[it]\\n        }\\n        res := comb(x - 1, y - 1) + comb(x - 1, y)\\n        cache[it] = res % MOD\\n        return cache[it]\\n    }\\n\\n    return comb\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst MOD = 1000000007\\n\\nfunc numOfWays(nums []int) int {\\n    cf := combFunc()\\n    return int((helper(nums, cf) - 1) % MOD)\\n}\\n\\nfunc helper(n []int, comb func(x, y int64) int64) int64 {\\n    if len(n) <= 2 {\\n        return 1\\n    }\\n    left,right := []int{}, []int{}\\n\\n    // Split elements compared to root (n[0])\\n    for _, el := range n {\\n        if el < n[0] {\\n            left = append(left, el)\\n        } else if el > n[0]{\\n            right = append(right, el)\\n        }\\n    }\\n\\n    ll := int64(len(left))\\n    lr := int64(len(right))\\n    // 1. Find all combinations of possible arrangements of left and right\\n    //     without losing relative order \\n    // 2. Find result for left and right elements recursively \\n    // 3. Multiply all\\n    ways := ((comb(ll + lr, lr) * helper(left, comb)) % MOD) * helper(right, comb) \\n    return ways % MOD\\n}\\n\\nfunc combFunc() func(x, y int64) int64 {\\n    type item struct {\\n        x, y int64\\n    }\\n    var cache = map[item]int64{}\\n    var comb func(x, y int64) int64 \\n    // https://dotnettutorials.net/lesson/combination-formula-using-recursion-in-c/\\n    comb = func(x, y int64) int64 {\\n        if y == 0 || x == y {\\n            return 1\\n        }\\n        \\n        it := item{x, y}\\n        if cache[it] != 0 {\\n            return cache[it]\\n        }\\n        res := comb(x - 1, y - 1) + comb(x - 1, y)\\n        cache[it] = res % MOD\\n        return cache[it]\\n    }\\n\\n    return comb\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3237963,
                "title": "12ms-beat-100-o-n-logn-most-efficient-solution-detailed-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nAs many other solutions have already explained, the number of ways can be calculated using *recursive combinations*. Given the tree structure:\\n```\\nNumberOfWays(node) = Choose(left_node_size + right_node_size, left_size) *\\n    NumberOfWays(left_node) * NumberOfWays(right_node);\\n```\\nThe *node_size* above means the size of the substree starting at that node. We will use this expression throughout below.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe key here is the `n choose k` combinatoric number, which is `n!/(k!(n-k)!)`, or in our case\\n```\\n(left_node_size + right_node_size)! / (left_node_size!right_node_size!)\\n```\\nIt is not easy to calculate factorial efficiently, so if we use a **math trick to optimize** it.\\n\\nNote that the size of tree starting this node is `left_node_size + right_node_size + 1`, we can transform our initial formula:\\n\\n```\\nNumberOfWays(node) = \\n    (left_node_size + right_node_size)! / (left_node_size!right_node_size!) *\\n    NumberOfWays(left_node) * NumberOfWays(right_node)\\n  = this_node_size! / (left_node_size!right_node_size!) / this_node_size *\\n    NumberOfWays(left_node) * NumberOfWays(right_node);\\n  = ... // recursively expands all sub nodes\\n  = this_node_size!/ (\\\\Prod_{all node} node_size)\\n```\\n`\\\\Prod_{all node} node size` means to multiple all *node_size* together, for each node.\\nBasically we managed to cancel all factorial except one. We got **only one** factorial to calculate and a bunch of denominators to divide.\\n\\nFor the factorial, we simply multiply each number and immediately do th mod to reduce the size of the number to prevent overflow.\\nFor the divsion, we can use efficient [modular inverse algorithm](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse) since `10^9 + 7` is a prime number. Here we choose extended euclid algorithm.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorse case $$\\\\Theta(N^2)$$, average $$\\\\Theta(N \\\\log N)$$\\nThe worse case part only happens in the \"tree building\" process, for the actually calculation this is always O(N logN). The logN comes from the extended euclid algorith, while the outer post order tree visit is linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\n\\n# Code\\n```\\nnamespace {\\n\\nconstexpr int kMod = 1000\\'000\\'007;\\n\\n// REQUIRES: a >=0, b >= 0\\nint ExtendedEuclid(int a, int b, int& x, int& y) {\\n  if (a < b) {\\n    swap(a, b);\\n  }\\n  int xa = 1;\\n  int xb = 0;\\n  int ya = 0;\\n  int yb = 1;\\n  while (b > 0) {\\n    auto r = std::div(a, b);\\n    a = b;\\n    b = r.rem;\\n    xa -= xb * r.quot;\\n    swap(xa, xb);\\n    ya -= yb * r.quot;\\n    swap(ya, yb); \\n  }\\n  x = xa;\\n  y = ya;\\n  return a;\\n}\\n\\n// Requires that P is a prime and 2P < int32max\\ntemplate <int P>\\nclass Num {\\n public:\\n  Num(int v) : v_(v) {}\\n\\n  Num operator+(Num n) const {\\n    return (v_ + n.v_) % P;\\n  }\\n\\n  Num operator-(Num n) const {\\n    return (v_ - n.v_ + P) % P;\\n  }\\n\\n  Num operator*(Num n) const {\\n    return static_cast<int64_t>(v_) * n.v_ % P;\\n  }\\n\\n  Num operator/(Num n) const {\\n    return (*this) * n.Inverse();\\n  }\\n\\n  Num Inverse() const {\\n    int x = 0;\\n    int y = 0;\\n    ExtendedEuclid(P, v_, x, y);  // Must be 1\\n    return (y + P) % P;\\n  }\\n\\n  int value() const {\\n    return v_;\\n  }\\n\\n private:\\n  int v_;\\n};\\n\\ntemplate <int P>\\nstd::ostream& operator<<(std::ostream& s, Num<P> n) {\\n  return s << n.value();\\n}\\n\\nusing Number = Num<kMod>;\\n\\nstruct Node {\\n  int value;\\n  int left;\\n  int right;\\n\\n  Node(int value) : value(value), left(-1), right(-1) {}\\n};\\n\\nvoid Insert(vector<Node>& nodes, int num) {\\n  if (nodes.empty()) {\\n    nodes.push_back(num);\\n    return;\\n  }\\n  int index = 0;\\n  int prev_index = -1;\\n  while (index != -1) {\\n    Node& node = nodes[index];\\n    prev_index = index;\\n    if (node.value < num) {\\n      index = node.right;\\n    } else {\\n      index = node.left;\\n    }\\n  }\\n  Node& p = nodes[prev_index];\\n  (p.value < num ? p.right : p.left) = nodes.size();\\n  nodes.push_back(num);\\n}\\n\\nint TreeSize(const vector<Node>& nodes, int index, Number& ways) {\\n  if (index == -1) {\\n    return 0;\\n  }\\n  int left = TreeSize(nodes, nodes[index].left, ways);\\n  int right = TreeSize(nodes, nodes[index].right, ways);\\n  int total = 1 + left + right;\\n  // cout << \"[\" << index << \"] \" << total << endl;\\n  // cout << \"    \" << ways;\\n  ways = ways / total;\\n  // cout << \" => \" << ways << endl;\\n  return total;\\n}\\n\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n  int numOfWays(vector<int>& nums) {\\n    const int N = nums.size();\\n    vector<Node> nodes;\\n    nodes.reserve(N);\\n    for (int num : nums) {\\n      Insert(nodes, num);\\n    }\\n    Number ways = 1;\\n    for (int i = 1; i <= N; ++i) {\\n      ways = ways * i;\\n    }\\n    // cout << \"N! = \" << ways << endl;\\n    TreeSize(nodes, 0, ways);\\n    return (ways - 1).value();\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nNumberOfWays(node) = Choose(left_node_size + right_node_size, left_size) *\\n    NumberOfWays(left_node) * NumberOfWays(right_node);\\n```\n```\\n(left_node_size + right_node_size)! / (left_node_size!right_node_size!)\\n```\n```\\nNumberOfWays(node) = \\n    (left_node_size + right_node_size)! / (left_node_size!right_node_size!) *\\n    NumberOfWays(left_node) * NumberOfWays(right_node)\\n  = this_node_size! / (left_node_size!right_node_size!) / this_node_size *\\n    NumberOfWays(left_node) * NumberOfWays(right_node);\\n  = ... // recursively expands all sub nodes\\n  = this_node_size!/ (\\\\Prod_{all node} node_size)\\n```\n```\\nnamespace {\\n\\nconstexpr int kMod = 1000\\'000\\'007;\\n\\n// REQUIRES: a >=0, b >= 0\\nint ExtendedEuclid(int a, int b, int& x, int& y) {\\n  if (a < b) {\\n    swap(a, b);\\n  }\\n  int xa = 1;\\n  int xb = 0;\\n  int ya = 0;\\n  int yb = 1;\\n  while (b > 0) {\\n    auto r = std::div(a, b);\\n    a = b;\\n    b = r.rem;\\n    xa -= xb * r.quot;\\n    swap(xa, xb);\\n    ya -= yb * r.quot;\\n    swap(ya, yb); \\n  }\\n  x = xa;\\n  y = ya;\\n  return a;\\n}\\n\\n// Requires that P is a prime and 2P < int32max\\ntemplate <int P>\\nclass Num {\\n public:\\n  Num(int v) : v_(v) {}\\n\\n  Num operator+(Num n) const {\\n    return (v_ + n.v_) % P;\\n  }\\n\\n  Num operator-(Num n) const {\\n    return (v_ - n.v_ + P) % P;\\n  }\\n\\n  Num operator*(Num n) const {\\n    return static_cast<int64_t>(v_) * n.v_ % P;\\n  }\\n\\n  Num operator/(Num n) const {\\n    return (*this) * n.Inverse();\\n  }\\n\\n  Num Inverse() const {\\n    int x = 0;\\n    int y = 0;\\n    ExtendedEuclid(P, v_, x, y);  // Must be 1\\n    return (y + P) % P;\\n  }\\n\\n  int value() const {\\n    return v_;\\n  }\\n\\n private:\\n  int v_;\\n};\\n\\ntemplate <int P>\\nstd::ostream& operator<<(std::ostream& s, Num<P> n) {\\n  return s << n.value();\\n}\\n\\nusing Number = Num<kMod>;\\n\\nstruct Node {\\n  int value;\\n  int left;\\n  int right;\\n\\n  Node(int value) : value(value), left(-1), right(-1) {}\\n};\\n\\nvoid Insert(vector<Node>& nodes, int num) {\\n  if (nodes.empty()) {\\n    nodes.push_back(num);\\n    return;\\n  }\\n  int index = 0;\\n  int prev_index = -1;\\n  while (index != -1) {\\n    Node& node = nodes[index];\\n    prev_index = index;\\n    if (node.value < num) {\\n      index = node.right;\\n    } else {\\n      index = node.left;\\n    }\\n  }\\n  Node& p = nodes[prev_index];\\n  (p.value < num ? p.right : p.left) = nodes.size();\\n  nodes.push_back(num);\\n}\\n\\nint TreeSize(const vector<Node>& nodes, int index, Number& ways) {\\n  if (index == -1) {\\n    return 0;\\n  }\\n  int left = TreeSize(nodes, nodes[index].left, ways);\\n  int right = TreeSize(nodes, nodes[index].right, ways);\\n  int total = 1 + left + right;\\n  // cout << \"[\" << index << \"] \" << total << endl;\\n  // cout << \"    \" << ways;\\n  ways = ways / total;\\n  // cout << \" => \" << ways << endl;\\n  return total;\\n}\\n\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n  int numOfWays(vector<int>& nums) {\\n    const int N = nums.size();\\n    vector<Node> nodes;\\n    nodes.reserve(N);\\n    for (int num : nums) {\\n      Insert(nodes, num);\\n    }\\n    Number ways = 1;\\n    for (int i = 1; i <= N; ++i) {\\n      ways = ways * i;\\n    }\\n    // cout << \"N! = \" << ways << endl;\\n    TreeSize(nodes, 0, ways);\\n    return (ways - 1).value();\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2877762,
                "title": "o-n-2-divide-and-conquer-solution",
                "content": "### Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s think first why `[2,1,3]` has the same BST as `[2,3,1]` ?\\nBy looking at the BST, we see that `2` is at the left side of the root and `3` is at the right side of the root. So, they will be eventually in two different directions of the root.\\n\\nLet\\'s take `[2, 1, 3, 4]`, the order between `3` and `4` matters, because they are both at the right side of the root. However, we can put `1` at any position after `2` in the array and the BST remains the same.\\n\\n### Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrom the previous intuition, we can construct the following solution:\\n- Count how many numbers are less than the root (the number at index 0), let\\'s call `sCnt`\\n- Count how many numbers are greater than the root. let\\'s call it `gCnt`\\n-  $${sCnt + gCnt \\\\choose sCnt}$$ gets the number of permutations to put together the numbers smaller than the root and the numbers bigger that the root where the order of each group is the same as gived in the initial permutation. \\n- Solve the left subtree and right subtree recursively\\n- The total answer will be $${sCnt + gCnt \\\\choose sCnt}$$ * `numberOfWaysToSolveLeftSubTree` * `numberOfWaysToSolveRightSubtree`\\n\\n\\nNotice that `sCnt` + `gCnt` = `N`-`1` where N is the number of nodes in the current subtree. \\n\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    const int Mod = 1e9 + 7;\\n\\n    int memo[1001][1001];\\n    int nCr(int n, int r){\\n        assert(n >= r);\\n        if (r == 0 || n == r) \\n            return 1;\\n        else if (r == 1 ) \\n            return n;\\n        else if (memo[n][r] != 0) { \\n            return memo[n][r];\\n        }\\n        else \\n            return memo[n][r] = (nCr(n-1, r) + nCr(n-1, r-1))%Mod;\\n    }\\n\\n    // Divide and Conquer \\n    int numOfWaysHelper(vector<int>& a) {\\n        if (a.empty()) {\\n            return 1; // base case\\n        }\\n        vector<int> greater, smaller; \\n        int n = (int)a.size(); \\n        for(int i=1;i<n;i++){\\n            if(a[i] > a[0]) {\\n                greater.push_back(a[i]);\\n            } else { \\n                smaller.push_back(a[i]);\\n            }\\n        }\\n        int gcnt = (int)greater.size();\\n        int scnt = (int)smaller.size(); \\n        return ((nCr(gcnt + scnt, gcnt) * 1LL * numOfWaysHelper(greater))%Mod * 1LL * numOfWaysHelper(smaller))%Mod ;\\n    }\\n\\n    int numOfWays(vector<int> &nums){\\n        return ((numOfWaysHelper(nums) - 1)%Mod + Mod)%Mod;\\n    };\\n    \\n};\\n```\\n### Complexity\\n##### Time complexity:\\n$$O(n^2)$$\\n\\nNotice that at each call of `NumOfWaysHelper`method, the size of the array will decrement by at least one element. So, at worst case we can get `T(n) = T(1) + T(n-1) + O(n)`, which leads to an $$O(n^2)$$ solution. \\n\\nBy the way, If this BST is balanced, this means that almost half of the numbers are less than the root and the other are greater that it. \\nThis will make the formula `T(n) = 2T(n/2) + O(n)` which is of $$ O(n log(n)) $$\\n##### Space complexity:\\n$$O(n^2)$$\\n\\nFinally, I didn\\'t focus on the part where we get nCr since it\\'s not so important. However, there were other ways of getting nCr:\\n- Instead of constructing them recursively, we could have instead precompute all the values at first using nCr = n-1Cr-1 + n-1Cr\\n- Also we can get nCr using $$ \\\\frac{n!}{r! (n-r)!} $$. We can precompute the factorial of all numbers less than 2000 and precomute the factorial inverse using fermat little theorem\\n",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int Mod = 1e9 + 7;\\n\\n    int memo[1001][1001];\\n    int nCr(int n, int r){\\n        assert(n >= r);\\n        if (r == 0 || n == r) \\n            return 1;\\n        else if (r == 1 ) \\n            return n;\\n        else if (memo[n][r] != 0) { \\n            return memo[n][r];\\n        }\\n        else \\n            return memo[n][r] = (nCr(n-1, r) + nCr(n-1, r-1))%Mod;\\n    }\\n\\n    // Divide and Conquer \\n    int numOfWaysHelper(vector<int>& a) {\\n        if (a.empty()) {\\n            return 1; // base case\\n        }\\n        vector<int> greater, smaller; \\n        int n = (int)a.size(); \\n        for(int i=1;i<n;i++){\\n            if(a[i] > a[0]) {\\n                greater.push_back(a[i]);\\n            } else { \\n                smaller.push_back(a[i]);\\n            }\\n        }\\n        int gcnt = (int)greater.size();\\n        int scnt = (int)smaller.size(); \\n        return ((nCr(gcnt + scnt, gcnt) * 1LL * numOfWaysHelper(greater))%Mod * 1LL * numOfWaysHelper(smaller))%Mod ;\\n    }\\n\\n    int numOfWays(vector<int> &nums){\\n        return ((numOfWaysHelper(nums) - 1)%Mod + Mod)%Mod;\\n    };\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783524,
                "title": "a-cheating-way",
                "content": "# Code\\n```\\nclass Solution:\\n      \\n\\n    def numOfWays(self, nums: List[int]) -> int:\\n        FACT = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 227020758, 178290591, 674358851, 789741546, 425606191, 660911389, 557316307, 146326063, 72847302, 602640637, 860734560, 657629300, 440732388, 459042011, 394134213, 35757887, 36978716, 109361473, 390205642, 486580460, 57155068, 943272305, 14530444, 523095984, 354551275, 472948359, 444985875, 799434881, 776829897, 626855450, 954784168, 10503098, 472639410, 741412713, 846397273, 627068824, 726372166, 318608048, 249010336, 948537388, 272481214, 713985458, 269199917, 75195247, 286129051, 595484846, 133605669, 16340084, 996745124, 798197261, 286427093, 331333826, 536698543, 422103593, 280940535, 103956247, 172980994, 108669496, 715534167, 518459667, 847555432, 719101534, 932614679, 878715114, 661063309, 562937745, 472081547, 766523501, 88403147, 249058005, 671814275, 432398708, 753889928, 834533360, 604401816, 187359437, 674989781, 749079870, 166267694, 296627743, 586379910, 119711155, 372559648, 765725963, 275417893, 990953332, 104379182, 437918130, 229730822, 432543683, 551999041, 407899865, 829485531, 925465677, 24826746, 681288554, 260451868, 649705284, 117286020, 136034149, 371858732, 391895154, 67942395, 881317771, 114178486, 473061257, 294289191, 314702675, 79023409, 640855835, 825267159, 333127002, 640874963, 750244778, 281086141, 979025803, 294327705, 262601384, 400781066, 903100348, 112345444, 54289391, 329067736, 753211788, 190014235, 221964248, 853030262, 424235847, 817254014, 50069176, 159892119, 24464975, 547421354, 923517131, 757017312, 38561392, 745647373, 847105173, 912880234, 757794602, 942573301, 156287339, 224537377, 27830567, 369398991, 365040172, 41386942, 621910678, 127618458, 674190056, 892978365, 448450838, 994387759, 68366839, 417262036, 100021558, 903643190, 619341229, 907349424, 64099836, 89271551, 533249769, 318708924, 92770232, 420330952, 818908938, 584698880, 245797665, 489377057, 66623751, 192146349, 354927971, 661674180, 71396619, 351167662, 19519994, 689278845, 962979640, 929109959, 389110882, 98399701, 89541861, 460662776, 289903466, 110982403, 974515647, 928612402, 722479105, 218299090, 96415872, 572421883, 774063320, 682979494, 693774784, 611379287, 166890807, 880178425, 837467962, 705738750, 616613957, 338771924, 497191232, 896114138, 560652457, 661582322, 224945188, 262995829, 859081981, 857116478, 279856786, 408062844, 406076419, 367193638, 985761614, 767884817, 77737051, 801784560, 410447512, 813374614, 702909132, 777826615, 11426636, 685259446, 721228129, 931065383, 593559607, 860745086, 578819198, 495425745, 893029457, 6156532, 502193801, 37480384, 220174401, 383076669, 3013247, 750298503, 574624441, 230733683, 144887710, 656590378, 773954850, 358485371, 772254339, 469363737, 95843299, 823414273, 87709482, 892174648, 749756145, 185864756, 68295241, 98238739, 131504392, 111672419, 928208089, 687974198, 753032165, 71715287, 506557931, 290314197, 546089425, 174590825, 187067364, 817659471, 309331349, 303445769, 964814732, 112937795, 848457973, 113604679, 263728612, 162653895, 519013648, 956915940, 591788795, 26960558, 818561771, 201473695, 830318534, 283328761, 298655153, 103269519, 567777414, 629890782, 707451727, 528064896, 419467694, 259775012, 452053078, 972081682, 512829263, 412924123, 354780756, 917691336, 648929514, 519218426, 957710940, 848100261, 607279584, 78508462, 651656900, 271922065, 927371945, 976904514, 655633282, 147015495, 44958071, 431540693, 956102180, 821001984, 4640954, 508310043, 709072863, 866824584, 318461564, 773853828, 371761455, 53040744, 609526889, 972452623, 799173814, 723225821, 3874155, 305590228, 289496343, 139259591, 348260611, 756867525, 848691744, 101266155, 835557082, 267191274, 448180160, 518514435, 443022120, 614718802, 151579195, 204297074, 912569551, 137049249, 515433810, 979001276, 524451820, 229298431, 88837724, 892742699, 387369393, 840349900, 206661672, 18186411, 619853562, 246548548, 236767938, 893832644, 930410696, 321544423, 971435684, 402636244, 780681725, 194281388, 661238608, 964476271, 643075362, 439409780, 96895678, 723461710, 915447882, 785640606, 114709392, 933696835, 539582134, 739120141, 300372431, 244129985, 722433522, 26638091, 388855420, 42468156, 647517040, 474194942, 832805846, 958306874, 489519451, 339220689, 9833277, 923477502, 390998217, 790283925, 694135631, 736657340, 609563281, 873127083, 489593220, 264439147, 891171227, 489029295, 502009550, 325923608, 280525558, 857054649, 820622208, 558213940, 216997416, 487921842, 951328535, 606653379, 794417402, 449723904, 783486165, 414645478, 809681447, 114612567, 824953206, 255016498, 147060381, 88903008, 228293174, 394357308, 362355866, 900088886, 638573794, 779598451, 904922263, 451026166, 549459329, 212643744, 563246709, 391796933, 174243175, 189725986, 238337196, 60051478, 782959006, 982673239, 237607992, 685987666, 694447544, 195840153, 519748540, 446086975, 523485236, 185780714, 716004996, 214280883, 140643728, 555470704, 516522055, 116665689, 899547947, 490696549, 683197147, 686671136, 988747143, 744912554, 619072836, 345158054, 224284246, 637879131, 78947725, 342273666, 237716550, 915360466, 711578771, 423071394, 228124918, 271834959, 480779410, 254894593, 859192972, 990202578, 258044399, 151532640, 644862529, 48049425, 448119239, 130306338, 850105179, 401639970, 606863861, 183881380, 837401090, 513536652, 714177614, 946271680, 243293343, 403377310, 688653593, 15447678, 754734307, 631353768, 202296846, 159906516, 912696536, 737140518, 467380526, 896686075, 309895051, 356369955, 461415686, 706245266, 10064183, 183054210, 455971702, 737368289, 956771035, 564163693, 365118309, 226637659, 304857172, 440299843, 717116122, 485961418, 615704083, 476049473, 354119987, 329471814, 620060202, 251964959, 45357250, 175414082, 671119137, 48735782, 122378970, 717506435, 18459328, 949577729, 771970076, 635808197, 608040366, 165916428, 258536202, 902229110, 617090616, 548564593, 613394864, 753777984, 577888302, 416452176, 881599549, 524547188, 599140122, 522765386, 657552586, 256787840, 287613719, 776067801, 597965522, 458655497, 764387515, 350167935, 494713961, 513386012, 576480762, 864589772, 86987059, 495636228, 512647986, 721997962, 982831380, 162376799, 204281975, 462134806, 189646394, 425968575, 209834628, 494248765, 664281698, 947663843, 540352769, 25662122, 986679150, 207298711, 477043799, 24708053, 528335066, 189351697, 717500453, 42764755, 316734785, 823726196, 293357001, 547414377, 258966410, 602945692, 561521296, 351253952, 752369730, 174204566, 871148004, 302242737, 554611874, 540181425, 349941261, 414343943, 921115587, 959388563, 227019335, 708812719, 793380997, 342547759, 324322556, 458370547, 356254978, 809319893, 159690374, 848340820, 971304725, 180230004, 103061704, 207441144, 443272953, 45593686, 541647240, 612817107, 849140508, 109375794, 906749744, 159084460, 541378020, 692284266, 908221578, 720697998, 363923522, 819281897, 701846632, 479994712, 196613531, 29272489, 792937812, 859009553, 202148261, 385627435, 115321267, 612859231, 132778909, 173511339, 782369566, 322583903, 324703286, 31244274, 433755056, 109559692, 871157455, 350443931, 592104988, 197184362, 141678010, 649163959, 746537855, 954594407, 850681817, 703404350, 467293824, 684978431, 565588709, 378843675, 825260479, 749777538, 850502015, 387852091, 412307507, 307565279, 914127155, 864079609, 845970807, 414173935, 638273833, 664477235, 173471099, 480759791, 839694748, 190898355, 956270620, 957911348, 43002811, 628936576, 966234409, 667971950, 236586166, 954211897, 223051884, 21058295, 656573222, 631532535, 809706350, 984734695, 314281677, 311454037, 640732448, 434907794, 175084834, 434807109, 973816812, 488481268, 844735329, 917344075, 314288693, 459259162, 992521062, 667512257, 603748166, 679935673, 833938466, 933875943, 522922384, 981191471, 457854178, 112860028, 484939649, 611363777, 627371454, 844300972, 962501388, 738504183, 631041465, 29224765, 334078303, 211237785, 626057542, 900175080, 728504100, 450509755, 575177363, 905713570, 416609984, 874776027, 334255451, 683287462, 999293262, 474888472, 317020697, 180417613, 591538360, 879151833, 605566485, 569294094, 970567518, 896200922, 943088633, 145735679, 884701203, 949403596, 749113557, 78958680, 850679027, 665376978, 686499745, 426302291, 842343474, 708066168, 962548572, 349652428, 833757979, 492365420, 136639914, 76093131, 591710464, 208764552, 166233017, 498121245, 545840935, 26721664, 736011124, 880639351, 137410283, 42609708, 235572009, 981737748, 718913567, 909319027, 906112184, 298059463, 274736280, 217450848, 351267027, 149682364, 249066734, 11785215, 333890217, 774940233, 302540697, 519852435, 802535369, 620684620, 306323295, 752310997, 848793393, 883503040, 569433124, 254795373, 855478464, 660158704, 87911700, 944741410, 351053939, 2634663, 134077016, 736459220, 4882454, 969435081, 120150411, 922584286, 828772112, 106810765, 371205161, 17024731, 960279329, 389323593, 23991206, 744762405, 684217429, 479374977, 963728237, 3246420, 688035746, 381629444, 752436308, 274567573, 440219140, 702541058, 919238277, 563955926, 467150839, 5249506, 399086000, 833151662, 847391187, 655983283, 337920422, 866913758, 675206635, 549602585, 963783662, 324756002, 393087771, 731515248, 787956453, 550936813, 398161393, 631665856, 442637251, 454846959, 348994181, 88011024, 513458067, 60476466, 9760396, 403700900, 990173371, 519613195, 945797344, 114696834, 327457551, 905694736, 143025346, 289024806, 451579463, 325709522, 18701196, 326143996, 49850509, 619195074, 414881030, 850660769, 880149960, 651809429, 592293509, 810577782, 929598726, 835669318, 731671946, 529667681, 285562083, 293565850, 686472980, 274474950, 282703792, 889076915, 56602629, 546147347, 255724802, 873696194, 831784350, 110556728, 279941051, 667003092, 302778600, 803516696, 772054724, 165410893, 531446229, 958833885, 703493734, 68812272, 481542542, 722167619, 172528691, 173636402, 356397518, 390931659, 311533827, 53449710, 959934024, 259493848, 215350798, 907381983, 791418522, 896453666, 530274270, 443147787, 468552325, 410897594, 491169384, 314015783, 406644587, 772818684, 721371094, 596483817, 922913559, 78344520, 173781169, 485391881, 326797438, 209197264, 227032260, 183290649, 293208856, 909531571, 778733890, 346053132, 674154326, 75833611, 738595509, 449942130, 545136258, 334305223, 589959631, 51605154, 128106265, 85269691, 347284647, 656835568, 934798619, 602272125, 976691718, 647351010, 456965253, 143605060, 148066754, 588283108, 104912143, 240217288, 49898584, 251930392, 868617755, 690598708, 880742077, 200550782, 935358746, 104053488, 348096605, 394187502, 726999264, 278275958, 153885020, 653433530, 364854920, 922674021, 65882280, 762280792, 84294078, 29666249, 250921311, 659332228, 420236707, 614100318, 959310571, 676769211, 355052615, 567244231, 840761673, 557858783, 627343983, 461946676, 22779421, 756641425, 641419708]\\n\\n        MMI = [0, 1, 500000004, 333333336, 250000002, 400000003, 166666668, 142857144, 125000001, 111111112, 700000005, 818181824, 83333334, 153846155, 71428572, 466666670, 562500004, 352941179, 55555556, 157894738, 850000006, 47619048, 409090912, 739130440, 41666667, 280000002, 576923081, 370370373, 35714286, 758620695, 233333335, 129032259, 281250002, 939393946, 676470593, 628571433, 27777778, 621621626, 78947369, 717948723, 425000003, 658536590, 23809524, 395348840, 204545456, 822222228, 369565220, 404255322, 520833337, 448979595, 140000001, 784313731, 788461544, 56603774, 685185190, 763636369, 17857143, 385964915, 879310351, 50847458, 616666671, 688524595, 564516133, 15873016, 140625001, 30769231, 469696973, 686567169, 838235300, 579710149, 814285720, 98591550, 13888889, 410958907, 310810813, 93333334, 539473688, 831168837, 858974365, 202531647, 712500005, 123456791, 329268295, 84337350, 11904762, 670588240, 197674420, 252873565, 102272728, 415730340, 411111114, 164835166, 184782610, 43010753, 202127661, 231578949, 760416672, 268041239, 724489801, 646464651, 570000004, 940594066, 892156869, 572815538, 394230772, 209523811, 28301887, 224299067, 342592595, 9174312, 881818188, 873873880, 508928575, 893805316, 692982461, 147826088, 939655179, 239316241, 25423729, 478991600, 808333339, 438016532, 844262301, 886178868, 782258070, 856000006, 7936508, 480314964, 570312504, 798449618, 515384619, 190839696, 734848490, 165413535, 843283588, 274074076, 419117650, 58394161, 789855078, 604316551, 407142860, 134751774, 49295775, 832167838, 506944448, 151724139, 705479457, 149659865, 655405410, 530201346, 46666667, 483443712, 269736844, 594771246, 915584422, 625806456, 929487186, 343949047, 601265827, 685534596, 856250006, 962732926, 561728399, 116564418, 664634151, 587878792, 42168675, 5988024, 5952381, 242603552, 335294120, 795321643, 98837210, 791907520, 626436786, 325714288, 51136364, 683615824, 207865170, 435754193, 205555557, 933701664, 82417583, 562841534, 92391305, 524324328, 521505380, 577540111, 601063834, 338624341, 615789478, 439790579, 380208336, 694300523, 634020623, 343589746, 862244904, 969543154, 823232329, 507537692, 285000002, 228855723, 470297033, 108374385, 946078438, 131707318, 286407769, 526570052, 197115386, 832535891, 604761909, 90047394, 514150947, 32863850, 612149537, 79069768, 671296301, 875576043, 4587156, 470319638, 440909094, 950226251, 436936940, 125560539, 754464291, 364444447, 446902658, 35242291, 846491234, 711790398, 73913044, 277056279, 969827593, 90128756, 619658124, 880851070, 512711868, 67510549, 239495800, 280334730, 904166673, 406639007, 219008266, 707818935, 922131154, 89795919, 443089434, 165991904, 391129035, 28112450, 428000003, 912350604, 3968254, 339920951, 240157482, 556862749, 285156252, 70038911, 399224809, 517374521, 757692313, 417624524, 95419848, 836501907, 367424245, 611320759, 582706771, 138576780, 421641794, 743494429, 137037038, 450184505, 209558825, 388278391, 529197084, 752727278, 394927539, 252707583, 802158279, 681003589, 203571430, 718861215, 67375887, 650176683, 524647891, 77192983, 416083919, 808362375, 253472224, 961937723, 575862073, 756013751, 852739732, 522184304, 574829936, 210169493, 327702705, 215488217, 265100673, 441471575, 523333337, 770764125, 241721856, 646864691, 134868422, 137704919, 297385623, 749185673, 457792211, 857605184, 312903228, 787781356, 464743593, 492012783, 671974527, 403174606, 800632917, 652996850, 342767298, 614420067, 428125003, 741433027, 481366463, 597523224, 780864203, 406153849, 58282209, 3058104, 832317079, 343465048, 293939396, 631419944, 521084341, 624624629, 2994012, 737313438, 502976194, 41543027, 121301776, 631268441, 167647060, 284457480, 897660825, 206997086, 49418605, 715942034, 395953760, 985590785, 313218393, 521489975, 162857144, 413105416, 25568182, 175637395, 341807912, 19718310, 103932585, 826330538, 717877100, 713091927, 602777782, 113573408, 466850832, 812672182, 541208795, 882191787, 281420767, 376021801, 546195656, 295392956, 262162164, 436657685, 260752690, 16085791, 788770059, 618666671, 300531917, 212201593, 669312174, 195250661, 307894739, 160104988, 719895293, 172323761, 190104168, 966233773, 847150265, 932816544, 817010315, 951156819, 171794873, 102301791, 431122452, 63613232, 484771577, 840506335, 911616168, 760705295, 253768846, 55137845, 142500001, 855361602, 614427865, 779156333, 735148520, 424691361, 554187196, 238329240, 473039219, 188264060, 65853659, 352798056, 643203888, 578692498, 263285026, 16867470, 98557693, 534772186, 916267949, 844868741, 802380958, 966745850, 45023697, 44917258, 757075477, 134117648, 16431925, 526932088, 806074772, 610722615, 39534884, 761020887, 835648154, 614318711, 937788025, 50574713, 2293578, 354691078, 235159819, 642369025, 220454547, 716553293, 975113129, 88036118, 218468470, 83146068, 562780273, 176733782, 877232149, 285077953, 682222227, 605321512, 223451329, 161147904, 517621149, 432967036, 423245617, 172866522, 355895199, 198257082, 36956522, 321041217, 638528143, 820734347, 984913800, 208602152, 45064378, 775160605, 309829062, 240938168, 440425535, 447983018, 256355934, 763213536, 533755278, 646315794, 119747900, 228511532, 140167365, 206680586, 952083340, 355509358, 703319507, 654244311, 109504133, 653608252, 853909471, 607802879, 461065577, 38854806, 544897963, 641547866, 221544717, 632860045, 82995952, 529292933, 695564521, 156941651, 14056225, 266533068, 714000005, 1996008, 456175302, 282306165, 1984127, 588118816, 669960479, 747534522, 120078741, 491159139, 778431378, 344422703, 142578126, 598440550, 535019459, 314563109, 699612408, 400386850, 758687264, 597302509, 878846160, 191938581, 208812262, 921606125, 47709924, 441904765, 918250957, 301707782, 683712126, 510396979, 805660383, 561205277, 791353389, 589118203, 69288390, 844859819, 210820897, 811918069, 871747218, 404452693, 68518519, 60998152, 725092256, 311233888, 604779416, 801834868, 694139199, 541133459, 264598542, 854280516, 376363639, 39927405, 697463773, 457504524, 626353795, 174774776, 901079143, 457809698, 840501798, 491949914, 101785715, 525846706, 859430611, 433392543, 533687947, 578761066, 825088345, 446208116, 762323949, 732864680, 538596495, 334500878, 708041963, 813263531, 904181191, 229565219, 126736112, 771230508, 980968865, 898100179, 787931040, 869191056, 878006879, 732418530, 426369866, 447863251, 261092152, 724020448, 287414968, 585738544, 605084750, 656514387, 663851356, 160202362, 607744112, 95798320, 632550340, 835845902, 720735791, 410684477, 761666672, 296173047, 885382066, 76285241, 120860928, 887603312, 823432349, 729818786, 67434211, 36124795, 568852463, 492635028, 648692815, 696574230, 874592840, 377235775, 728896109, 716369535, 428802592, 953150249, 156451614, 842190022, 393890678, 630818624, 732371800, 571200004, 746006395, 944178635, 835987267, 36565978, 201587303, 438985740, 900316462, 30015798, 326498425, 696062997, 171383649, 880690744, 807210037, 677621288, 714062505, 720748835, 870716517, 43545879, 740683235, 359689925, 298761612, 119010820, 890432105, 640986137, 703076928, 291858681, 529141108, 29096478, 1529052, 438167942, 916158543, 823439884, 171732524, 698027319, 146969698, 216338882, 315709972, 983408755, 760542174, 33082707, 812312318, 163418292, 1497006, 41853513, 368656719, 62593145, 251488097, 493313525, 520771517, 454814818, 60650888, 320531760, 815634224, 609720181, 83823530, 345080766, 142228740, 530014645, 948830416, 411678835, 103498543, 237263466, 524709306, 927431066, 357971017, 444283650, 197976880, 92352093, 992795396, 520863313, 656609200, 862266864, 760744991, 696709590, 81428572, 489301002, 206552708, 85348507, 12784091, 626950359, 587818701, 991513444, 170903956, 385049368, 9859155, 355836852, 551966296, 701262277, 413165269, 366433569, 358938550, 93444910, 856545967, 318497916, 301388891, 224687935, 56786704, 802213007, 233425416, 630344832, 406336091, 696011009, 770604401, 235939645, 941095897, 729138172, 640710387, 66848568, 688010904, 29931973, 273097828, 698778838, 147696478, 538565633, 131081082, 721997306, 718328846, 590847918, 130376345, 506040272, 508042899, 676037488, 894385033, 889185587, 809333339, 215712385, 650265962, 304116868, 606100800, 896688748, 334656087, 952443864, 597625334, 779973655, 653947373, 582128782, 80052494, 1310616, 859947650, 518954252, 586161884, 850065195, 95052084, 855656703, 983116890, 690012975, 923575136, 648124196, 466408272, 525161294, 908505161, 839124845, 975578413, 613607193, 585897440, 645326509, 551150899, 805874846, 215561226, 868789815, 31806616, 419313853, 742385792, 278833969, 920253171, 841972193, 455808084, 822194205, 880352651, 537106922, 126884423, 877038902, 527568926, 964956202, 571250004, 46192260, 427680801, 764632633, 807213936, 592546588, 889578170, 581164812, 367574260, 102595798, 712345684, 755856972, 277093598, 816728173, 119164620, 223312885, 736519613, 73439413, 94132030, 462759466, 532926833, 618757617, 176399028, 52247874, 321601944, 917575764, 289346249, 617896014, 131642513, 712907122, 8433735, 84235861, 549278850, 496998803, 267386093, 601197609, 958133978, 560334532, 922434374, 696066751, 401190479, 853745547, 483372925, 239620405, 522511852, 848520716, 22458629, 348288078, 878537742, 216725561, 67058824, 722679206, 508215966, 690504108, 263466044, 359064330, 403037386, 792298722, 805361311, 67520373, 19767442, 269454125, 880510447, 718424107, 417824077, 158381504, 807159359, 987312579, 968894016, 200230151, 525287360, 360505169, 1146789, 918671255, 177345539, 265142859, 617579913, 891676175, 821184516, 840728106, 610227277, 759364364, 858276650, 612684036, 987556568, 736723169, 44018059, 559188279, 109234235, 497187855, 41573034, 738496077, 781390140, 705487127, 88366891, 287150840, 938616078, 813823863, 642538980, 314794218, 841111117, 591564932, 302660756, 256921375, 611725668, 786740337, 80573952, 324145537, 758810578, 882288235, 216483518, 963776077, 711622812, 371303398, 86433261, 712568311, 677947603, 741548533, 99128541, 41349293, 18478261, 916395229, 660520612, 776814740, 819264075, 304864867, 910367177, 952535066, 492456900, 252960174, 104301076, 23630505, 22532189, 595927121, 887580306, 515508025, 154914531, 16008538, 120469084, 164004261, 720212771, 568544106, 223991509, 115588548, 128177967, 467724871, 381606768, 551214365, 266877639, 262381456, 323157897, 884332288, 59873950, 383001052, 114255766, 687958120, 570083686, 204806689, 103340293, 8342023, 476041670, 746097820, 177754679, 580477678, 851659757, 338860106, 827122159, 260599795, 554752070, 199174408, 326804126, 669412981, 926954739, 943473799, 803901443, 468717952, 730532792, 584442174, 19427403, 492339125, 772448985, 1019368, 320773933, 399796544, 610772362, 793908635, 816430026, 447821685, 41497976, 17189080, 764646470, 172552978, 847782264, 877139986, 578470829, 901507544, 507028116, 911735212, 133266534, 874874881, 857000006]\\n        n = len(nums)\\n        lis = [0] * n\\n        def count(subnums):\\n            nonlocal lis\\n            if subnums:\\n                low = [num for num in subnums if num < subnums[0]]\\n                high = [num for num in subnums if num > subnums[0]]\\n                lis[subnums[0]-1] = len(subnums)\\n                count(low)\\n                count(high)\\n        \\n        count(nums)\\n\\n\\n\\n\\n        M = 10 ** 9 + 7\\n        denum = 1\\n        for k in range(1,n+1):\\n            denum = (denum * MMI[lis[k-1]]) % M\\n        return (FACT[n] * denum) % M - 1\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n      \\n\\n    def numOfWays(self, nums: List[int]) -> int:\\n        FACT = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 227020758, 178290591, 674358851, 789741546, 425606191, 660911389, 557316307, 146326063, 72847302, 602640637, 860734560, 657629300, 440732388, 459042011, 394134213, 35757887, 36978716, 109361473, 390205642, 486580460, 57155068, 943272305, 14530444, 523095984, 354551275, 472948359, 444985875, 799434881, 776829897, 626855450, 954784168, 10503098, 472639410, 741412713, 846397273, 627068824, 726372166, 318608048, 249010336, 948537388, 272481214, 713985458, 269199917, 75195247, 286129051, 595484846, 133605669, 16340084, 996745124, 798197261, 286427093, 331333826, 536698543, 422103593, 280940535, 103956247, 172980994, 108669496, 715534167, 518459667, 847555432, 719101534, 932614679, 878715114, 661063309, 562937745, 472081547, 766523501, 88403147, 249058005, 671814275, 432398708, 753889928, 834533360, 604401816, 187359437, 674989781, 749079870, 166267694, 296627743, 586379910, 119711155, 372559648, 765725963, 275417893, 990953332, 104379182, 437918130, 229730822, 432543683, 551999041, 407899865, 829485531, 925465677, 24826746, 681288554, 260451868, 649705284, 117286020, 136034149, 371858732, 391895154, 67942395, 881317771, 114178486, 473061257, 294289191, 314702675, 79023409, 640855835, 825267159, 333127002, 640874963, 750244778, 281086141, 979025803, 294327705, 262601384, 400781066, 903100348, 112345444, 54289391, 329067736, 753211788, 190014235, 221964248, 853030262, 424235847, 817254014, 50069176, 159892119, 24464975, 547421354, 923517131, 757017312, 38561392, 745647373, 847105173, 912880234, 757794602, 942573301, 156287339, 224537377, 27830567, 369398991, 365040172, 41386942, 621910678, 127618458, 674190056, 892978365, 448450838, 994387759, 68366839, 417262036, 100021558, 903643190, 619341229, 907349424, 64099836, 89271551, 533249769, 318708924, 92770232, 420330952, 818908938, 584698880, 245797665, 489377057, 66623751, 192146349, 354927971, 661674180, 71396619, 351167662, 19519994, 689278845, 962979640, 929109959, 389110882, 98399701, 89541861, 460662776, 289903466, 110982403, 974515647, 928612402, 722479105, 218299090, 96415872, 572421883, 774063320, 682979494, 693774784, 611379287, 166890807, 880178425, 837467962, 705738750, 616613957, 338771924, 497191232, 896114138, 560652457, 661582322, 224945188, 262995829, 859081981, 857116478, 279856786, 408062844, 406076419, 367193638, 985761614, 767884817, 77737051, 801784560, 410447512, 813374614, 702909132, 777826615, 11426636, 685259446, 721228129, 931065383, 593559607, 860745086, 578819198, 495425745, 893029457, 6156532, 502193801, 37480384, 220174401, 383076669, 3013247, 750298503, 574624441, 230733683, 144887710, 656590378, 773954850, 358485371, 772254339, 469363737, 95843299, 823414273, 87709482, 892174648, 749756145, 185864756, 68295241, 98238739, 131504392, 111672419, 928208089, 687974198, 753032165, 71715287, 506557931, 290314197, 546089425, 174590825, 187067364, 817659471, 309331349, 303445769, 964814732, 112937795, 848457973, 113604679, 263728612, 162653895, 519013648, 956915940, 591788795, 26960558, 818561771, 201473695, 830318534, 283328761, 298655153, 103269519, 567777414, 629890782, 707451727, 528064896, 419467694, 259775012, 452053078, 972081682, 512829263, 412924123, 354780756, 917691336, 648929514, 519218426, 957710940, 848100261, 607279584, 78508462, 651656900, 271922065, 927371945, 976904514, 655633282, 147015495, 44958071, 431540693, 956102180, 821001984, 4640954, 508310043, 709072863, 866824584, 318461564, 773853828, 371761455, 53040744, 609526889, 972452623, 799173814, 723225821, 3874155, 305590228, 289496343, 139259591, 348260611, 756867525, 848691744, 101266155, 835557082, 267191274, 448180160, 518514435, 443022120, 614718802, 151579195, 204297074, 912569551, 137049249, 515433810, 979001276, 524451820, 229298431, 88837724, 892742699, 387369393, 840349900, 206661672, 18186411, 619853562, 246548548, 236767938, 893832644, 930410696, 321544423, 971435684, 402636244, 780681725, 194281388, 661238608, 964476271, 643075362, 439409780, 96895678, 723461710, 915447882, 785640606, 114709392, 933696835, 539582134, 739120141, 300372431, 244129985, 722433522, 26638091, 388855420, 42468156, 647517040, 474194942, 832805846, 958306874, 489519451, 339220689, 9833277, 923477502, 390998217, 790283925, 694135631, 736657340, 609563281, 873127083, 489593220, 264439147, 891171227, 489029295, 502009550, 325923608, 280525558, 857054649, 820622208, 558213940, 216997416, 487921842, 951328535, 606653379, 794417402, 449723904, 783486165, 414645478, 809681447, 114612567, 824953206, 255016498, 147060381, 88903008, 228293174, 394357308, 362355866, 900088886, 638573794, 779598451, 904922263, 451026166, 549459329, 212643744, 563246709, 391796933, 174243175, 189725986, 238337196, 60051478, 782959006, 982673239, 237607992, 685987666, 694447544, 195840153, 519748540, 446086975, 523485236, 185780714, 716004996, 214280883, 140643728, 555470704, 516522055, 116665689, 899547947, 490696549, 683197147, 686671136, 988747143, 744912554, 619072836, 345158054, 224284246, 637879131, 78947725, 342273666, 237716550, 915360466, 711578771, 423071394, 228124918, 271834959, 480779410, 254894593, 859192972, 990202578, 258044399, 151532640, 644862529, 48049425, 448119239, 130306338, 850105179, 401639970, 606863861, 183881380, 837401090, 513536652, 714177614, 946271680, 243293343, 403377310, 688653593, 15447678, 754734307, 631353768, 202296846, 159906516, 912696536, 737140518, 467380526, 896686075, 309895051, 356369955, 461415686, 706245266, 10064183, 183054210, 455971702, 737368289, 956771035, 564163693, 365118309, 226637659, 304857172, 440299843, 717116122, 485961418, 615704083, 476049473, 354119987, 329471814, 620060202, 251964959, 45357250, 175414082, 671119137, 48735782, 122378970, 717506435, 18459328, 949577729, 771970076, 635808197, 608040366, 165916428, 258536202, 902229110, 617090616, 548564593, 613394864, 753777984, 577888302, 416452176, 881599549, 524547188, 599140122, 522765386, 657552586, 256787840, 287613719, 776067801, 597965522, 458655497, 764387515, 350167935, 494713961, 513386012, 576480762, 864589772, 86987059, 495636228, 512647986, 721997962, 982831380, 162376799, 204281975, 462134806, 189646394, 425968575, 209834628, 494248765, 664281698, 947663843, 540352769, 25662122, 986679150, 207298711, 477043799, 24708053, 528335066, 189351697, 717500453, 42764755, 316734785, 823726196, 293357001, 547414377, 258966410, 602945692, 561521296, 351253952, 752369730, 174204566, 871148004, 302242737, 554611874, 540181425, 349941261, 414343943, 921115587, 959388563, 227019335, 708812719, 793380997, 342547759, 324322556, 458370547, 356254978, 809319893, 159690374, 848340820, 971304725, 180230004, 103061704, 207441144, 443272953, 45593686, 541647240, 612817107, 849140508, 109375794, 906749744, 159084460, 541378020, 692284266, 908221578, 720697998, 363923522, 819281897, 701846632, 479994712, 196613531, 29272489, 792937812, 859009553, 202148261, 385627435, 115321267, 612859231, 132778909, 173511339, 782369566, 322583903, 324703286, 31244274, 433755056, 109559692, 871157455, 350443931, 592104988, 197184362, 141678010, 649163959, 746537855, 954594407, 850681817, 703404350, 467293824, 684978431, 565588709, 378843675, 825260479, 749777538, 850502015, 387852091, 412307507, 307565279, 914127155, 864079609, 845970807, 414173935, 638273833, 664477235, 173471099, 480759791, 839694748, 190898355, 956270620, 957911348, 43002811, 628936576, 966234409, 667971950, 236586166, 954211897, 223051884, 21058295, 656573222, 631532535, 809706350, 984734695, 314281677, 311454037, 640732448, 434907794, 175084834, 434807109, 973816812, 488481268, 844735329, 917344075, 314288693, 459259162, 992521062, 667512257, 603748166, 679935673, 833938466, 933875943, 522922384, 981191471, 457854178, 112860028, 484939649, 611363777, 627371454, 844300972, 962501388, 738504183, 631041465, 29224765, 334078303, 211237785, 626057542, 900175080, 728504100, 450509755, 575177363, 905713570, 416609984, 874776027, 334255451, 683287462, 999293262, 474888472, 317020697, 180417613, 591538360, 879151833, 605566485, 569294094, 970567518, 896200922, 943088633, 145735679, 884701203, 949403596, 749113557, 78958680, 850679027, 665376978, 686499745, 426302291, 842343474, 708066168, 962548572, 349652428, 833757979, 492365420, 136639914, 76093131, 591710464, 208764552, 166233017, 498121245, 545840935, 26721664, 736011124, 880639351, 137410283, 42609708, 235572009, 981737748, 718913567, 909319027, 906112184, 298059463, 274736280, 217450848, 351267027, 149682364, 249066734, 11785215, 333890217, 774940233, 302540697, 519852435, 802535369, 620684620, 306323295, 752310997, 848793393, 883503040, 569433124, 254795373, 855478464, 660158704, 87911700, 944741410, 351053939, 2634663, 134077016, 736459220, 4882454, 969435081, 120150411, 922584286, 828772112, 106810765, 371205161, 17024731, 960279329, 389323593, 23991206, 744762405, 684217429, 479374977, 963728237, 3246420, 688035746, 381629444, 752436308, 274567573, 440219140, 702541058, 919238277, 563955926, 467150839, 5249506, 399086000, 833151662, 847391187, 655983283, 337920422, 866913758, 675206635, 549602585, 963783662, 324756002, 393087771, 731515248, 787956453, 550936813, 398161393, 631665856, 442637251, 454846959, 348994181, 88011024, 513458067, 60476466, 9760396, 403700900, 990173371, 519613195, 945797344, 114696834, 327457551, 905694736, 143025346, 289024806, 451579463, 325709522, 18701196, 326143996, 49850509, 619195074, 414881030, 850660769, 880149960, 651809429, 592293509, 810577782, 929598726, 835669318, 731671946, 529667681, 285562083, 293565850, 686472980, 274474950, 282703792, 889076915, 56602629, 546147347, 255724802, 873696194, 831784350, 110556728, 279941051, 667003092, 302778600, 803516696, 772054724, 165410893, 531446229, 958833885, 703493734, 68812272, 481542542, 722167619, 172528691, 173636402, 356397518, 390931659, 311533827, 53449710, 959934024, 259493848, 215350798, 907381983, 791418522, 896453666, 530274270, 443147787, 468552325, 410897594, 491169384, 314015783, 406644587, 772818684, 721371094, 596483817, 922913559, 78344520, 173781169, 485391881, 326797438, 209197264, 227032260, 183290649, 293208856, 909531571, 778733890, 346053132, 674154326, 75833611, 738595509, 449942130, 545136258, 334305223, 589959631, 51605154, 128106265, 85269691, 347284647, 656835568, 934798619, 602272125, 976691718, 647351010, 456965253, 143605060, 148066754, 588283108, 104912143, 240217288, 49898584, 251930392, 868617755, 690598708, 880742077, 200550782, 935358746, 104053488, 348096605, 394187502, 726999264, 278275958, 153885020, 653433530, 364854920, 922674021, 65882280, 762280792, 84294078, 29666249, 250921311, 659332228, 420236707, 614100318, 959310571, 676769211, 355052615, 567244231, 840761673, 557858783, 627343983, 461946676, 22779421, 756641425, 641419708]\\n\\n        MMI = [0, 1, 500000004, 333333336, 250000002, 400000003, 166666668, 142857144, 125000001, 111111112, 700000005, 818181824, 83333334, 153846155, 71428572, 466666670, 562500004, 352941179, 55555556, 157894738, 850000006, 47619048, 409090912, 739130440, 41666667, 280000002, 576923081, 370370373, 35714286, 758620695, 233333335, 129032259, 281250002, 939393946, 676470593, 628571433, 27777778, 621621626, 78947369, 717948723, 425000003, 658536590, 23809524, 395348840, 204545456, 822222228, 369565220, 404255322, 520833337, 448979595, 140000001, 784313731, 788461544, 56603774, 685185190, 763636369, 17857143, 385964915, 879310351, 50847458, 616666671, 688524595, 564516133, 15873016, 140625001, 30769231, 469696973, 686567169, 838235300, 579710149, 814285720, 98591550, 13888889, 410958907, 310810813, 93333334, 539473688, 831168837, 858974365, 202531647, 712500005, 123456791, 329268295, 84337350, 11904762, 670588240, 197674420, 252873565, 102272728, 415730340, 411111114, 164835166, 184782610, 43010753, 202127661, 231578949, 760416672, 268041239, 724489801, 646464651, 570000004, 940594066, 892156869, 572815538, 394230772, 209523811, 28301887, 224299067, 342592595, 9174312, 881818188, 873873880, 508928575, 893805316, 692982461, 147826088, 939655179, 239316241, 25423729, 478991600, 808333339, 438016532, 844262301, 886178868, 782258070, 856000006, 7936508, 480314964, 570312504, 798449618, 515384619, 190839696, 734848490, 165413535, 843283588, 274074076, 419117650, 58394161, 789855078, 604316551, 407142860, 134751774, 49295775, 832167838, 506944448, 151724139, 705479457, 149659865, 655405410, 530201346, 46666667, 483443712, 269736844, 594771246, 915584422, 625806456, 929487186, 343949047, 601265827, 685534596, 856250006, 962732926, 561728399, 116564418, 664634151, 587878792, 42168675, 5988024, 5952381, 242603552, 335294120, 795321643, 98837210, 791907520, 626436786, 325714288, 51136364, 683615824, 207865170, 435754193, 205555557, 933701664, 82417583, 562841534, 92391305, 524324328, 521505380, 577540111, 601063834, 338624341, 615789478, 439790579, 380208336, 694300523, 634020623, 343589746, 862244904, 969543154, 823232329, 507537692, 285000002, 228855723, 470297033, 108374385, 946078438, 131707318, 286407769, 526570052, 197115386, 832535891, 604761909, 90047394, 514150947, 32863850, 612149537, 79069768, 671296301, 875576043, 4587156, 470319638, 440909094, 950226251, 436936940, 125560539, 754464291, 364444447, 446902658, 35242291, 846491234, 711790398, 73913044, 277056279, 969827593, 90128756, 619658124, 880851070, 512711868, 67510549, 239495800, 280334730, 904166673, 406639007, 219008266, 707818935, 922131154, 89795919, 443089434, 165991904, 391129035, 28112450, 428000003, 912350604, 3968254, 339920951, 240157482, 556862749, 285156252, 70038911, 399224809, 517374521, 757692313, 417624524, 95419848, 836501907, 367424245, 611320759, 582706771, 138576780, 421641794, 743494429, 137037038, 450184505, 209558825, 388278391, 529197084, 752727278, 394927539, 252707583, 802158279, 681003589, 203571430, 718861215, 67375887, 650176683, 524647891, 77192983, 416083919, 808362375, 253472224, 961937723, 575862073, 756013751, 852739732, 522184304, 574829936, 210169493, 327702705, 215488217, 265100673, 441471575, 523333337, 770764125, 241721856, 646864691, 134868422, 137704919, 297385623, 749185673, 457792211, 857605184, 312903228, 787781356, 464743593, 492012783, 671974527, 403174606, 800632917, 652996850, 342767298, 614420067, 428125003, 741433027, 481366463, 597523224, 780864203, 406153849, 58282209, 3058104, 832317079, 343465048, 293939396, 631419944, 521084341, 624624629, 2994012, 737313438, 502976194, 41543027, 121301776, 631268441, 167647060, 284457480, 897660825, 206997086, 49418605, 715942034, 395953760, 985590785, 313218393, 521489975, 162857144, 413105416, 25568182, 175637395, 341807912, 19718310, 103932585, 826330538, 717877100, 713091927, 602777782, 113573408, 466850832, 812672182, 541208795, 882191787, 281420767, 376021801, 546195656, 295392956, 262162164, 436657685, 260752690, 16085791, 788770059, 618666671, 300531917, 212201593, 669312174, 195250661, 307894739, 160104988, 719895293, 172323761, 190104168, 966233773, 847150265, 932816544, 817010315, 951156819, 171794873, 102301791, 431122452, 63613232, 484771577, 840506335, 911616168, 760705295, 253768846, 55137845, 142500001, 855361602, 614427865, 779156333, 735148520, 424691361, 554187196, 238329240, 473039219, 188264060, 65853659, 352798056, 643203888, 578692498, 263285026, 16867470, 98557693, 534772186, 916267949, 844868741, 802380958, 966745850, 45023697, 44917258, 757075477, 134117648, 16431925, 526932088, 806074772, 610722615, 39534884, 761020887, 835648154, 614318711, 937788025, 50574713, 2293578, 354691078, 235159819, 642369025, 220454547, 716553293, 975113129, 88036118, 218468470, 83146068, 562780273, 176733782, 877232149, 285077953, 682222227, 605321512, 223451329, 161147904, 517621149, 432967036, 423245617, 172866522, 355895199, 198257082, 36956522, 321041217, 638528143, 820734347, 984913800, 208602152, 45064378, 775160605, 309829062, 240938168, 440425535, 447983018, 256355934, 763213536, 533755278, 646315794, 119747900, 228511532, 140167365, 206680586, 952083340, 355509358, 703319507, 654244311, 109504133, 653608252, 853909471, 607802879, 461065577, 38854806, 544897963, 641547866, 221544717, 632860045, 82995952, 529292933, 695564521, 156941651, 14056225, 266533068, 714000005, 1996008, 456175302, 282306165, 1984127, 588118816, 669960479, 747534522, 120078741, 491159139, 778431378, 344422703, 142578126, 598440550, 535019459, 314563109, 699612408, 400386850, 758687264, 597302509, 878846160, 191938581, 208812262, 921606125, 47709924, 441904765, 918250957, 301707782, 683712126, 510396979, 805660383, 561205277, 791353389, 589118203, 69288390, 844859819, 210820897, 811918069, 871747218, 404452693, 68518519, 60998152, 725092256, 311233888, 604779416, 801834868, 694139199, 541133459, 264598542, 854280516, 376363639, 39927405, 697463773, 457504524, 626353795, 174774776, 901079143, 457809698, 840501798, 491949914, 101785715, 525846706, 859430611, 433392543, 533687947, 578761066, 825088345, 446208116, 762323949, 732864680, 538596495, 334500878, 708041963, 813263531, 904181191, 229565219, 126736112, 771230508, 980968865, 898100179, 787931040, 869191056, 878006879, 732418530, 426369866, 447863251, 261092152, 724020448, 287414968, 585738544, 605084750, 656514387, 663851356, 160202362, 607744112, 95798320, 632550340, 835845902, 720735791, 410684477, 761666672, 296173047, 885382066, 76285241, 120860928, 887603312, 823432349, 729818786, 67434211, 36124795, 568852463, 492635028, 648692815, 696574230, 874592840, 377235775, 728896109, 716369535, 428802592, 953150249, 156451614, 842190022, 393890678, 630818624, 732371800, 571200004, 746006395, 944178635, 835987267, 36565978, 201587303, 438985740, 900316462, 30015798, 326498425, 696062997, 171383649, 880690744, 807210037, 677621288, 714062505, 720748835, 870716517, 43545879, 740683235, 359689925, 298761612, 119010820, 890432105, 640986137, 703076928, 291858681, 529141108, 29096478, 1529052, 438167942, 916158543, 823439884, 171732524, 698027319, 146969698, 216338882, 315709972, 983408755, 760542174, 33082707, 812312318, 163418292, 1497006, 41853513, 368656719, 62593145, 251488097, 493313525, 520771517, 454814818, 60650888, 320531760, 815634224, 609720181, 83823530, 345080766, 142228740, 530014645, 948830416, 411678835, 103498543, 237263466, 524709306, 927431066, 357971017, 444283650, 197976880, 92352093, 992795396, 520863313, 656609200, 862266864, 760744991, 696709590, 81428572, 489301002, 206552708, 85348507, 12784091, 626950359, 587818701, 991513444, 170903956, 385049368, 9859155, 355836852, 551966296, 701262277, 413165269, 366433569, 358938550, 93444910, 856545967, 318497916, 301388891, 224687935, 56786704, 802213007, 233425416, 630344832, 406336091, 696011009, 770604401, 235939645, 941095897, 729138172, 640710387, 66848568, 688010904, 29931973, 273097828, 698778838, 147696478, 538565633, 131081082, 721997306, 718328846, 590847918, 130376345, 506040272, 508042899, 676037488, 894385033, 889185587, 809333339, 215712385, 650265962, 304116868, 606100800, 896688748, 334656087, 952443864, 597625334, 779973655, 653947373, 582128782, 80052494, 1310616, 859947650, 518954252, 586161884, 850065195, 95052084, 855656703, 983116890, 690012975, 923575136, 648124196, 466408272, 525161294, 908505161, 839124845, 975578413, 613607193, 585897440, 645326509, 551150899, 805874846, 215561226, 868789815, 31806616, 419313853, 742385792, 278833969, 920253171, 841972193, 455808084, 822194205, 880352651, 537106922, 126884423, 877038902, 527568926, 964956202, 571250004, 46192260, 427680801, 764632633, 807213936, 592546588, 889578170, 581164812, 367574260, 102595798, 712345684, 755856972, 277093598, 816728173, 119164620, 223312885, 736519613, 73439413, 94132030, 462759466, 532926833, 618757617, 176399028, 52247874, 321601944, 917575764, 289346249, 617896014, 131642513, 712907122, 8433735, 84235861, 549278850, 496998803, 267386093, 601197609, 958133978, 560334532, 922434374, 696066751, 401190479, 853745547, 483372925, 239620405, 522511852, 848520716, 22458629, 348288078, 878537742, 216725561, 67058824, 722679206, 508215966, 690504108, 263466044, 359064330, 403037386, 792298722, 805361311, 67520373, 19767442, 269454125, 880510447, 718424107, 417824077, 158381504, 807159359, 987312579, 968894016, 200230151, 525287360, 360505169, 1146789, 918671255, 177345539, 265142859, 617579913, 891676175, 821184516, 840728106, 610227277, 759364364, 858276650, 612684036, 987556568, 736723169, 44018059, 559188279, 109234235, 497187855, 41573034, 738496077, 781390140, 705487127, 88366891, 287150840, 938616078, 813823863, 642538980, 314794218, 841111117, 591564932, 302660756, 256921375, 611725668, 786740337, 80573952, 324145537, 758810578, 882288235, 216483518, 963776077, 711622812, 371303398, 86433261, 712568311, 677947603, 741548533, 99128541, 41349293, 18478261, 916395229, 660520612, 776814740, 819264075, 304864867, 910367177, 952535066, 492456900, 252960174, 104301076, 23630505, 22532189, 595927121, 887580306, 515508025, 154914531, 16008538, 120469084, 164004261, 720212771, 568544106, 223991509, 115588548, 128177967, 467724871, 381606768, 551214365, 266877639, 262381456, 323157897, 884332288, 59873950, 383001052, 114255766, 687958120, 570083686, 204806689, 103340293, 8342023, 476041670, 746097820, 177754679, 580477678, 851659757, 338860106, 827122159, 260599795, 554752070, 199174408, 326804126, 669412981, 926954739, 943473799, 803901443, 468717952, 730532792, 584442174, 19427403, 492339125, 772448985, 1019368, 320773933, 399796544, 610772362, 793908635, 816430026, 447821685, 41497976, 17189080, 764646470, 172552978, 847782264, 877139986, 578470829, 901507544, 507028116, 911735212, 133266534, 874874881, 857000006]\\n        n = len(nums)\\n        lis = [0] * n\\n        def count(subnums):\\n            nonlocal lis\\n            if subnums:\\n                low = [num for num in subnums if num < subnums[0]]\\n                high = [num for num in subnums if num > subnums[0]]\\n                lis[subnums[0]-1] = len(subnums)\\n                count(low)\\n                count(high)\\n        \\n        count(nums)\\n\\n\\n\\n\\n        M = 10 ** 9 + 7\\n        denum = 1\\n        for k in range(1,n+1):\\n            denum = (denum * MMI[lis[k-1]]) % M\\n        return (FACT[n] * denum) % M - 1\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311308,
                "title": "c-17-ways-to-interleave-two-sequences-and-dfs",
                "content": "# [C++17] ways to interleave two sequences, and DFS\\n1. Let D(x, y) be the count of distinct ways to interleave two sequences\\n  with length x and y respectively, while preserving the relative order of\\n  elements from the same sequence.\\n  * D(0, y) = D(x, 0) = 1\\n  * D(x, y) = D(x-1, y) + D(x, y-1).\\n  * we can precompute a table for D().\\n2. For a subtree\\n   whose left-subtree has  x nodes and L equivalent combinations, and\\n   whose right-subtree has y nodes and R equivalent combinations,\\n  we know the subtree has L * R * D(x,y) combinations, and x + y + 1 nodes.\\n3. We can apply rule #2 from the bottom up, that is, from the leaves up toward the root.\\n   And the final result will be the total combinations - 1.\\n4. Since the problem concerns about binary search trees, we\\'ll actually construct the BST, and do recursion on the tree.\\n5. \\n```   \\nclass Solution {\\n    struct Node {\\n        unique_ptr<Node> left;\\n        unique_ptr<Node> right;\\n        int val = 0;\\n\\n        void insert(int x) {\\n            if (x < val) {\\n                if (left) {\\n                    left->insert(x);\\n                } else {\\n                    left = make_unique<Node>();\\n                    left->val = x;\\n                }\\n            } else {\\n                if (right) {\\n                    right->insert(x);\\n                } else {\\n                    right = make_unique<Node>();\\n                    right->val = x;\\n                }\\n            }\\n        }\\n\\n        bool isLeaf() const {\\n            return !left && !right;\\n        }\\n    };\\n\\n    constexpr static const int ModBase = 1\\'000\\'000\\'007;\\n\\n    /// the number of ways to interleave two sequences of length x and y respectively.\\n    /// this feels like very similar to combinations C(x+y, x).\\n    static int interleaves(int x, int y) {\\n        static int memo[1001][1001] = {-123};\\n        if (memo[0][0] == -123) {\\n            // initialize the memo elements to non-zero,\\n            // because zero can be a valid value after the modulo op.\\n            memset(memo, -1, sizeof(memo));\\n        }\\n        // todo: or just compute this table bottom-up.\\n        if (x == 0 || y == 0) {\\n            return 1;\\n        }\\n        if (x > y) {\\n            swap(x, y);\\n        }\\n        if (memo[x][y] != memo[0][0]) {\\n            return memo[x][y];\\n        }\\n        return memo[x][y] = (interleaves(x - 1, y) + interleaves(x, y - 1)) % ModBase;\\n    }\\n\\n    /// return a tuple which represents <CountOfNodes, Combinations>\\n    tuple<int, int> traverseNode(Node* node) {\\n        if (!node) {\\n            return {0, 0};\\n        }\\n        if (node->isLeaf()) {\\n            return {1, 1};\\n        }\\n        if (node->left) {\\n            auto [leftNodeCount, leftCombos] = traverseNode(node->left.get());\\n            if (node->right) {\\n                auto [rightNodeCount, rightCombos] = traverseNode(node->right.get());\\n                int totalCombos = ((int64_t)leftCombos * rightCombos) % ModBase;\\n                totalCombos = ((int64_t)totalCombos * interleaves(leftNodeCount, rightNodeCount))\\n                        % ModBase;\\n                return {1 + leftNodeCount + rightNodeCount, totalCombos};\\n            } else { // right side is empty\\n                return {1 + leftNodeCount, leftCombos};\\n            }\\n        } else { // left side is empty, but it must have the right side, because it\\'s not a leaf.\\n            auto [rightNodeCount, rightCombos] = traverseNode(node->right.get());\\n            return {1 + rightNodeCount, rightCombos};\\n        }\\n    }\\n\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        // create the BST.\\n        auto root = make_unique<Node>();\\n        root->val = nums[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            root->insert(nums[i]);\\n        }\\n\\n        auto [nodeCount, combos] = traverseNode(root.get());\\n        return combos - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```   \\nclass Solution {\\n    struct Node {\\n        unique_ptr<Node> left;\\n        unique_ptr<Node> right;\\n        int val = 0;\\n\\n        void insert(int x) {\\n            if (x < val) {\\n                if (left) {\\n                    left->insert(x);\\n                } else {\\n                    left = make_unique<Node>();\\n                    left->val = x;\\n                }\\n            } else {\\n                if (right) {\\n                    right->insert(x);\\n                } else {\\n                    right = make_unique<Node>();\\n                    right->val = x;\\n                }\\n            }\\n        }\\n\\n        bool isLeaf() const {\\n            return !left && !right;\\n        }\\n    };\\n\\n    constexpr static const int ModBase = 1\\'000\\'000\\'007;\\n\\n    /// the number of ways to interleave two sequences of length x and y respectively.\\n    /// this feels like very similar to combinations C(x+y, x).\\n    static int interleaves(int x, int y) {\\n        static int memo[1001][1001] = {-123};\\n        if (memo[0][0] == -123) {\\n            // initialize the memo elements to non-zero,\\n            // because zero can be a valid value after the modulo op.\\n            memset(memo, -1, sizeof(memo));\\n        }\\n        // todo: or just compute this table bottom-up.\\n        if (x == 0 || y == 0) {\\n            return 1;\\n        }\\n        if (x > y) {\\n            swap(x, y);\\n        }\\n        if (memo[x][y] != memo[0][0]) {\\n            return memo[x][y];\\n        }\\n        return memo[x][y] = (interleaves(x - 1, y) + interleaves(x, y - 1)) % ModBase;\\n    }\\n\\n    /// return a tuple which represents <CountOfNodes, Combinations>\\n    tuple<int, int> traverseNode(Node* node) {\\n        if (!node) {\\n            return {0, 0};\\n        }\\n        if (node->isLeaf()) {\\n            return {1, 1};\\n        }\\n        if (node->left) {\\n            auto [leftNodeCount, leftCombos] = traverseNode(node->left.get());\\n            if (node->right) {\\n                auto [rightNodeCount, rightCombos] = traverseNode(node->right.get());\\n                int totalCombos = ((int64_t)leftCombos * rightCombos) % ModBase;\\n                totalCombos = ((int64_t)totalCombos * interleaves(leftNodeCount, rightNodeCount))\\n                        % ModBase;\\n                return {1 + leftNodeCount + rightNodeCount, totalCombos};\\n            } else { // right side is empty\\n                return {1 + leftNodeCount, leftCombos};\\n            }\\n        } else { // left side is empty, but it must have the right side, because it\\'s not a leaf.\\n            auto [rightNodeCount, rightCombos] = traverseNode(node->right.get());\\n            return {1 + rightNodeCount, rightCombos};\\n        }\\n    }\\n\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        // create the BST.\\n        auto root = make_unique<Node>();\\n        root->val = nums[0];\\n        for (int i = 1; i < nums.size(); ++i) {\\n            root->insert(nums[i]);\\n        }\\n\\n        auto [nodeCount, combos] = traverseNode(root.get());\\n        return combos - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258726,
                "title": "c-o-n-2-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    \\n    long long getNumOfWays(vector<int>& nums, vector<vector<long long>>& comb){\\n        if(nums.size() <= 2){\\n            return 1;\\n        }\\n        \\n        vector<int> less;\\n        vector<int> more;\\n        \\n        int x = nums[0];\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] < x){\\n                less.push_back(nums[i]);\\n            }\\n            else{\\n                more.push_back(nums[i]);\\n            }\\n        }\\n        \\n        long long ans = comb[more.size() + less.size()][less.size()];\\n        ans *= getNumOfWays(less, comb);\\n        ans %= mod;\\n        ans *= getNumOfWays(more, comb);\\n        ans %= mod;\\n        return ans;\\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int i, j, n = nums.size();        \\n        vector<vector<long long>> comb(n + 1, vector<long long> (n + 1));\\n        \\n        for(i = 0; i <= n; i++){\\n            comb[i][0] = 1;\\n        }\\n        \\n        for(i = 1; i <= n; i++){\\n            for(j = 1; j <= i; j++){\\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod;\\n            }\\n        }\\n        \\n        return getNumOfWays(nums, comb) - 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    \\n    long long getNumOfWays(vector<int>& nums, vector<vector<long long>>& comb){\\n        if(nums.size() <= 2){\\n            return 1;\\n        }\\n        \\n        vector<int> less;\\n        vector<int> more;\\n        \\n        int x = nums[0];\\n        for(int i = 1; i < nums.size(); i++){\\n            if(nums[i] < x){\\n                less.push_back(nums[i]);\\n            }\\n            else{\\n                more.push_back(nums[i]);\\n            }\\n        }\\n        \\n        long long ans = comb[more.size() + less.size()][less.size()];\\n        ans *= getNumOfWays(less, comb);\\n        ans %= mod;\\n        ans *= getNumOfWays(more, comb);\\n        ans %= mod;\\n        return ans;\\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int i, j, n = nums.size();        \\n        vector<vector<long long>> comb(n + 1, vector<long long> (n + 1));\\n        \\n        for(i = 0; i <= n; i++){\\n            comb[i][0] = 1;\\n        }\\n        \\n        for(i = 1; i <= n; i++){\\n            for(j = 1; j <= i; j++){\\n                comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % mod;\\n            }\\n        }\\n        \\n        return getNumOfWays(nums, comb) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211153,
                "title": "cpp-very-good-explanation-significance-of-pascal-triangle",
                "content": "This question is a very good example for the significance of **pascal triangle** the pascal triangle is used for the finding the combination in o(1) though using space but reducing  much more time for us \\nso we already know that the first element is always be the root and we just have to  find the number of ways to reorder the element in nums and maintaing the **relative order**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> pascal;   \\n    int mod = 1e9 + 7;\\n    \\n    long long dfs(vector<int> &nums){\\n        \\n        int n = nums.size();\\n        if(n <= 2) return 1;\\n        \\n        vector<int> left,right;\\n        \\n        for(int i = 1;i < n;i++){\\n            if(nums[i] > nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        \\n        long long left_res = dfs(left);\\n        long long right_res = dfs(right);\\n        \\n        int left_size = left.size() , right_size = right.size();\\n        \\n        return ((pascal[n - 1][left_size] * left_res)  % mod *right_res) % mod;\\n        \\n    }\\n    \\n    int numOfWays(vector<int>& nums){\\n       \\n        int n = nums.size();\\n        pascal.resize(n+1);\\n        // creating the pascal triangle\\n        \\n        for(int i = 0;i <= n;i++){\\n            pascal[i] = vector<long long>(i + 1,1);\\n            for(int j = 1 ;j < i; j++){\\n                pascal[i][j] = (pascal[i - 1][j - 1] + pascal[i - 1][j]) % mod;\\n            }\\n        }\\n       return dfs(nums) - 1;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> pascal;   \\n    int mod = 1e9 + 7;\\n    \\n    long long dfs(vector<int> &nums){\\n        \\n        int n = nums.size();\\n        if(n <= 2) return 1;\\n        \\n        vector<int> left,right;\\n        \\n        for(int i = 1;i < n;i++){\\n            if(nums[i] > nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        \\n        long long left_res = dfs(left);\\n        long long right_res = dfs(right);\\n        \\n        int left_size = left.size() , right_size = right.size();\\n        \\n        return ((pascal[n - 1][left_size] * left_res)  % mod *right_res) % mod;\\n        \\n    }\\n    \\n    int numOfWays(vector<int>& nums){\\n       \\n        int n = nums.size();\\n        pascal.resize(n+1);\\n        // creating the pascal triangle\\n        \\n        for(int i = 0;i <= n;i++){\\n            pascal[i] = vector<long long>(i + 1,1);\\n            for(int j = 1 ;j < i; j++){\\n                pascal[i][j] = (pascal[i - 1][j - 1] + pascal[i - 1][j]) % mod;\\n            }\\n        }\\n       return dfs(nums) - 1;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1885652,
                "title": "c-99-fast",
                "content": "```\\n#define ll long long int\\n\\nconst ll mod = 1e9+7;\\nvector<ll> fac, sz, dp;\\nvector<vector<int>> adj;\\n\\nstruct Node{\\n    int data;\\n    Node *left = NULL, *right = NULL;\\n    Node(int val):data(val){}\\n};\\nclass Solution {\\npublic:\\n    ll power(ll x, ll y){\\n        x %= mod;\\n        if(!x)  return x;\\n        ll res = 1;\\n        while(y){\\n            if(y&1)\\n                res = (res*x)%mod;\\n            y >>= 1;\\n            x = (x*x)%mod;\\n        }\\n        return res;\\n    }\\n    ll inverse(ll x){\\n        return power(x, mod-2);\\n    }\\n    Node* insert(Node *root, int val){\\n        if(!root){\\n            Node *tmp = new Node(val);\\n            return tmp;\\n        }\\n        if(root->data < val)\\n            root->right = insert(root->right, val);\\n        else\\n            root->left = insert(root->left, val);\\n        return root;\\n    }\\n    void inorder(Node *root, Node *par){\\n        if(!root)\\n            return;\\n        inorder(root->left, root);\\n        inorder(root->right, root);\\n        if(par != NULL){\\n            sz[par->data] += sz[root->data];\\n        }\\n        ll val = fac[sz[root->data]-1];\\n        if(root->left != NULL){\\n            val = (val*inverse(fac[sz[root->left->data]]))%mod;\\n            dp[root->data] = (dp[root->data]*dp[root->left->data])%mod;\\n        }\\n        if(root->right != NULL){\\n            val = (val*inverse(fac[sz[root->right->data]]))%mod;\\n            dp[root->data] = (dp[root->data]*dp[root->right->data])%mod;\\n        }\\n        dp[root->data] = (dp[root->data]*val)%mod;\\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        fac.assign(n+10,1);\\n        for(int i = 2; i <= n; i++)\\n            fac[i] = (fac[i-1]*i)%mod;\\n        sz.assign(n+10,1);\\n        dp.assign(n+10,1);\\n        adj.assign(n+1,vector<int>());\\n        Node *root = new Node(nums[0]);\\n        for(int i = 1; i < n; i++)\\n            insert(root, nums[i]);\\n        inorder(root, NULL);\\n        dp[nums[0]]--;\\n        dp[nums[0]] += mod;\\n        dp[nums[0]] %= mod;\\n        return dp[nums[0]];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "```\\n#define ll long long int\\n\\nconst ll mod = 1e9+7;\\nvector<ll> fac, sz, dp;\\nvector<vector<int>> adj;\\n\\nstruct Node{\\n    int data;\\n    Node *left = NULL, *right = NULL;\\n    Node(int val):data(val){}\\n};\\nclass Solution {\\npublic:\\n    ll power(ll x, ll y){\\n        x %= mod;\\n        if(!x)  return x;\\n        ll res = 1;\\n        while(y){\\n            if(y&1)\\n                res = (res*x)%mod;\\n            y >>= 1;\\n            x = (x*x)%mod;\\n        }\\n        return res;\\n    }\\n    ll inverse(ll x){\\n        return power(x, mod-2);\\n    }\\n    Node* insert(Node *root, int val){\\n        if(!root){\\n            Node *tmp = new Node(val);\\n            return tmp;\\n        }\\n        if(root->data < val)\\n            root->right = insert(root->right, val);\\n        else\\n            root->left = insert(root->left, val);\\n        return root;\\n    }\\n    void inorder(Node *root, Node *par){\\n        if(!root)\\n            return;\\n        inorder(root->left, root);\\n        inorder(root->right, root);\\n        if(par != NULL){\\n            sz[par->data] += sz[root->data];\\n        }\\n        ll val = fac[sz[root->data]-1];\\n        if(root->left != NULL){\\n            val = (val*inverse(fac[sz[root->left->data]]))%mod;\\n            dp[root->data] = (dp[root->data]*dp[root->left->data])%mod;\\n        }\\n        if(root->right != NULL){\\n            val = (val*inverse(fac[sz[root->right->data]]))%mod;\\n            dp[root->data] = (dp[root->data]*dp[root->right->data])%mod;\\n        }\\n        dp[root->data] = (dp[root->data]*val)%mod;\\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        fac.assign(n+10,1);\\n        for(int i = 2; i <= n; i++)\\n            fac[i] = (fac[i-1]*i)%mod;\\n        sz.assign(n+10,1);\\n        dp.assign(n+10,1);\\n        adj.assign(n+1,vector<int>());\\n        Node *root = new Node(nums[0]);\\n        for(int i = 1; i < n; i++)\\n            insert(root, nums[i]);\\n        inorder(root, NULL);\\n        dp[nums[0]]--;\\n        dp[nums[0]] += mod;\\n        dp[nums[0]] %= mod;\\n        return dp[nums[0]];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682008,
                "title": "python-solution-using-ncr",
                "content": "```\\nclass Solution:\\n    def build(self,dp,n):\\n        for i in range(n+1):\\n            dp[i][0]=1\\n            dp[i][i]=1\\n            dp[i][1]=i\\n            dp[i][i-1]=i\\n        \\n        for i in range(4,n+1):\\n            for j in range(2,i):\\n                dp[i][j]= dp[i-1][j-1]+dp[i-1][j]     \\n    def helper(self,nums,dp):\\n        n=len(nums)\\n        if n<=2:\\n            return 1\\n        left=[]\\n        right=[]\\n        root=nums[0]\\n        left=[n for n in nums if n < root]\\n        right=[n for n in nums if n> root]\\n        countLeft = self.helper(left,dp)\\n        countRight = self.helper(right,dp)\\n        return (dp[len(left)+len(right)][len(left)] *  countRight * countLeft    ) \\n                \\n    def numOfWays(self, nums) -> int:\\n        n=len(nums)\\n        dp=[[0 for i in range(n+1)]for j in range(n+1)]\\n        self.build(dp,n) #used to buil dp matrix\\n        ans=self.helper(nums,dp)          \\n        return ans % (10**9+7)-1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def build(self,dp,n):\\n        for i in range(n+1):\\n            dp[i][0]=1\\n            dp[i][i]=1\\n            dp[i][1]=i\\n            dp[i][i-1]=i\\n        \\n        for i in range(4,n+1):\\n            for j in range(2,i):\\n                dp[i][j]= dp[i-1][j-1]+dp[i-1][j]     \\n    def helper(self,nums,dp):\\n        n=len(nums)\\n        if n<=2:\\n            return 1\\n        left=[]\\n        right=[]\\n        root=nums[0]\\n        left=[n for n in nums if n < root]\\n        right=[n for n in nums if n> root]\\n        countLeft = self.helper(left,dp)\\n        countRight = self.helper(right,dp)\\n        return (dp[len(left)+len(right)][len(left)] *  countRight * countLeft    ) \\n                \\n    def numOfWays(self, nums) -> int:\\n        n=len(nums)\\n        dp=[[0 for i in range(n+1)]for j in range(n+1)]\\n        self.build(dp,n) #used to buil dp matrix\\n        ans=self.helper(nums,dp)          \\n        return ans % (10**9+7)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655142,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    import math\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def nCr(n,r):\\n            f = math.factorial\\n            return f(n) // (f(r) * f(n-r))\\n        def helper(nums):\\n            if len(nums)<=2:\\n                return 1\\n            left = []\\n            right = []\\n            for i in range(1,len(nums)):\\n                if nums[i]>nums[0]:\\n                    right.append(nums[i])\\n                if nums[i]<nums[0]:\\n                    left.append(nums[i])\\n\\n            return nCr(len(left)+len(right),len(left))*helper(left)*helper(right)\\n        return (helper(nums)-1) % (10**9+7)\\n```\\nNothing magical here just following similar to cracking the coding interview solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    import math\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def nCr(n,r):\\n            f = math.factorial\\n            return f(n) // (f(r) * f(n-r))\\n        def helper(nums):\\n            if len(nums)<=2:\\n                return 1\\n            left = []\\n            right = []\\n            for i in range(1,len(nums)):\\n                if nums[i]>nums[0]:\\n                    right.append(nums[i])\\n                if nums[i]<nums[0]:\\n                    left.append(nums[i])\\n\\n            return nCr(len(left)+len(right),len(left))*helper(left)*helper(right)\\n        return (helper(nums)-1) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652698,
                "title": "c-solution-recursive-combination",
                "content": "```\\npublic class Solution {\\n    public int NumOfWays(int[] nums) {\\n         return (int)(numOfWaysHelper(nums) % (1_000_000_007)) - 1;\\n    }\\n    BigInteger numOfWaysHelper (int[] nums) {\\n        if(nums.Length < 3)\\n            return 1;\\n\\n        var root  = nums[0];\\n        var left  = nums.Where(p => p < root).ToArray();\\n        var right = nums.Where(p => p > root).ToArray();\\n \\n        return comb(right.Count() + left.Count(), right.Count()) * numOfWaysHelper(left) * numOfWaysHelper(right);\\n    }\\n\\n    BigInteger comb(BigInteger n, BigInteger k){\\n        if(n < 2)\\n            return 1;\\n        return fact(n)/fact(n-k)/fact(k);\\n    }\\n\\n    BigInteger fact(BigInteger n){\\n        if(n<2)\\n            return 1L;\\n\\n        var result = n * fact(n-1);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumOfWays(int[] nums) {\\n         return (int)(numOfWaysHelper(nums) % (1_000_000_007)) - 1;\\n    }\\n    BigInteger numOfWaysHelper (int[] nums) {\\n        if(nums.Length < 3)\\n            return 1;\\n\\n        var root  = nums[0];\\n        var left  = nums.Where(p => p < root).ToArray();\\n        var right = nums.Where(p => p > root).ToArray();\\n \\n        return comb(right.Count() + left.Count(), right.Count()) * numOfWaysHelper(left) * numOfWaysHelper(right);\\n    }\\n\\n    BigInteger comb(BigInteger n, BigInteger k){\\n        if(n < 2)\\n            return 1;\\n        return fact(n)/fact(n-k)/fact(k);\\n    }\\n\\n    BigInteger fact(BigInteger n){\\n        if(n<2)\\n            return 1L;\\n\\n        var result = n * fact(n-1);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535547,
                "title": "simple-python-o-n-2-solution-quicksort-technique",
                "content": "\\n\\n```\\nfrom math import comb\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def quicksort(arr):\\n            if(len(arr) <= 1 or len(arr) == 2):\\n                return 1\\n            pivot = arr[0]\\n            left = []\\n            right = []\\n            for i in range(1, len(arr)):\\n                if(arr[i] < pivot):\\n                    left.append(arr[i])\\n                else:\\n                    right.append(arr[i])\\n            l = len(left)\\n            r = len(right)\\n            ans = comb(l+r,l);\\n            return ((ans)*quicksort(left)*quicksort(right))\\n            \\n            \\n        return (quicksort(nums)% (10**9 + 7)) -1\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import comb\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def quicksort(arr):\\n            if(len(arr) <= 1 or len(arr) == 2):\\n                return 1\\n            pivot = arr[0]\\n            left = []\\n            right = []\\n            for i in range(1, len(arr)):\\n                if(arr[i] < pivot):\\n                    left.append(arr[i])\\n                else:\\n                    right.append(arr[i])\\n            l = len(left)\\n            r = len(right)\\n            ans = comb(l+r,l);\\n            return ((ans)*quicksort(left)*quicksort(right))\\n            \\n            \\n        return (quicksort(nums)% (10**9 + 7)) -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458940,
                "title": "python-o-n-2",
                "content": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        dp=[1]\\n        mod=(10**9)+7\\n        for i in range(1,len(nums)+1):\\n            dp.append((dp[-1]*i))\\n        def dfs(num):\\n            if len(num)<=1:return 1\\n            else:\\n                root=num[0]\\n                l,r=[],[]\\n                for i in num :\\n                    if i<root:l.append(i)\\n                    elif i==root:pass\\n                    else:r.append(i)\\n                form =(dp[(len(l)+len(r))])//dp[len(l)]//dp[len(r)]\\n                return ((form%mod)*(dfs(r)%mod)*(dfs(l)%mod))%mod\\n        return dfs(nums)-1\\n        \\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        dp=[1]\\n        mod=(10**9)+7\\n        for i in range(1,len(nums)+1):\\n            dp.append((dp[-1]*i))\\n        def dfs(num):\\n            if len(num)<=1:return 1\\n            else:\\n                root=num[0]\\n                l,r=[],[]\\n                for i in num :\\n                    if i<root:l.append(i)\\n                    elif i==root:pass\\n                    else:r.append(i)\\n                form =(dp[(len(l)+len(r))])//dp[len(l)]//dp[len(r)]\\n                return ((form%mod)*(dfs(r)%mod)*(dfs(l)%mod))%mod\\n        return dfs(nums)-1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307079,
                "title": "simple-fast-divide-conquer-c",
                "content": "```\\nusing ll = unsigned long long;\\nll power(ll x, int y, int p){\\n    ll res = 1;\\n    x = x % p; \\n    while (y > 0) {\\n        if (y & 1) res = (res * x) % p;\\n        y = y >> 1; \\n        x = (x * x) % p;\\n    }\\n    return res;\\n}\\n \\n\\nll modInverse(ll n, int p){\\n    return power(n, p - 2, p);\\n}\\n \\n\\nll nCrModPFermat(ll n, int r, int p){\\n    if (n < r) return 0;\\n    if (r == 0) return 1;\\n \\n    ll fac[n + 1];\\n    fac[0] = 1;\\n    for (int i = 1; i <= n; i++)\\n        fac[i] = (fac[i - 1] * i) % p;\\n \\n    ll res = (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7, N = 0;\\n    int numOfWays(vector<int>& nums) {\\n        N = max(N, (int)nums.size());\\n        ll ans = 0;\\n        \\n        if(nums.empty() || nums.size() == 1) ans = 1;\\n        else {\\n            vector<int> sm, lg;\\n            for(int i : nums) {\\n                if(i < nums[0]) sm.push_back(i);\\n                else if(i > nums[0]) lg.push_back(i);\\n            }\\n\\n            int x = sm.size(), y = lg.size();\\n            int n = x + y;\\n            ans = (ll)nCrModPFermat(n, x, mod) * (((ll)numOfWays(sm) * numOfWays(lg)) % mod);\\n        }\\n        \\n        if(N == nums.size()) return ((ans - 1) % mod);\\n        return (ans % mod);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll = unsigned long long;\\nll power(ll x, int y, int p){\\n    ll res = 1;\\n    x = x % p; \\n    while (y > 0) {\\n        if (y & 1) res = (res * x) % p;\\n        y = y >> 1; \\n        x = (x * x) % p;\\n    }\\n    return res;\\n}\\n \\n\\nll modInverse(ll n, int p){\\n    return power(n, p - 2, p);\\n}\\n \\n\\nll nCrModPFermat(ll n, int r, int p){\\n    if (n < r) return 0;\\n    if (r == 0) return 1;\\n \\n    ll fac[n + 1];\\n    fac[0] = 1;\\n    for (int i = 1; i <= n; i++)\\n        fac[i] = (fac[i - 1] * i) % p;\\n \\n    ll res = (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7, N = 0;\\n    int numOfWays(vector<int>& nums) {\\n        N = max(N, (int)nums.size());\\n        ll ans = 0;\\n        \\n        if(nums.empty() || nums.size() == 1) ans = 1;\\n        else {\\n            vector<int> sm, lg;\\n            for(int i : nums) {\\n                if(i < nums[0]) sm.push_back(i);\\n                else if(i > nums[0]) lg.push_back(i);\\n            }\\n\\n            int x = sm.size(), y = lg.size();\\n            int n = x + y;\\n            ans = (ll)nCrModPFermat(n, x, mod) * (((ll)numOfWays(sm) * numOfWays(lg)) % mod);\\n        }\\n        \\n        if(N == nums.size()) return ((ans - 1) % mod);\\n        return (ans % mod);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304062,
                "title": "clean-solution-without-dp-or-divide-and-conquer",
                "content": "The general problem here is determining the number of topological orderings on a tree (a binary search tree in this case). Notably, we have to select the numbers to add into the BST in some order that always picks a node that has no incoming edges from any non-picked nodes (so we go from top to bottom, or topological order).\\n\\nTo count this effectively, we can do dp on the tree, but we can understand it more intuitively and simply by a combinatorial method. The overall number of ways we could add in the numbers to the BST is n! ways. Consider the subtrees dictated by the sequence of roots in any topological order. The first subtree will be the entire tree. Out of all n! orderings, only 1/n of them are such that the root node is added first (the other (n-1)/n orderings invalidly add a different node), so we divide by n to correctly count them. For the children, the same argument holds independently, for example, the left child\\'s subtree will have exactly 1/leftSize orderings that are valid. We can make the argument for each child independently because for any child\\'s subtree, the only node additions that matter are ones that belong to that subtree, so we can effectively ignore the addition of all elements outside of the subtree. This argument holds throughout the entire tree as we traverse downward.\\n\\nThus, our final answer is n! divided by the product of all subtree sizes (minus 1 since this problem in particular asks us to count the number of *additional* ways). (To do modulo division, we use Fermat\\'s little theorem which tells us that `a^(p-1) = 1 mod p => a^(p-2) = a^-1 mod p`, where p is a prime, and binary exponentiation)\\n\\nTo determine the sizes of subtrees, we can build the BST as we iterate through the input ordering. As a base case, we know the subtree size of the root will be n automatically. Now, in general, there are 3 possible cases for a node if we consider it\\'s lower and higher element in the BST. Let the values of these respective elements be `below` and `above`.\\n1. If the next lower element and next higher element both exist, then the number of elements in our subtree will be `above - below - 1`.  This is because all elements in the inclusive range `[below + 1, above - 1]` will be added to this node\\'s subtree.\\n2. If the next lower element exists but not the next higher, the number of elements in our subtree will be `n - below`, since elements in `[below + 1, n]` will be added here\\n3. If the next lower element exists but not the next higher, we\\'ll have `above-1`, since elements in `[1, above - 1]` will be added here\\n\\nSo, we can compute these values in `O(log(n))` time for each node as we iterate through the tree, for a total of `O(nlog(n))` time and `O(n)` memory.\\n\\n",
                "solutionTags": [
                    "Combinatorics"
                ],
                "code": "The general problem here is determining the number of topological orderings on a tree (a binary search tree in this case). Notably, we have to select the numbers to add into the BST in some order that always picks a node that has no incoming edges from any non-picked nodes (so we go from top to bottom, or topological order).\\n\\nTo count this effectively, we can do dp on the tree, but we can understand it more intuitively and simply by a combinatorial method. The overall number of ways we could add in the numbers to the BST is n! ways. Consider the subtrees dictated by the sequence of roots in any topological order. The first subtree will be the entire tree. Out of all n! orderings, only 1/n of them are such that the root node is added first (the other (n-1)/n orderings invalidly add a different node), so we divide by n to correctly count them. For the children, the same argument holds independently, for example, the left child\\'s subtree will have exactly 1/leftSize orderings that are valid. We can make the argument for each child independently because for any child\\'s subtree, the only node additions that matter are ones that belong to that subtree, so we can effectively ignore the addition of all elements outside of the subtree. This argument holds throughout the entire tree as we traverse downward.\\n\\nThus, our final answer is n! divided by the product of all subtree sizes (minus 1 since this problem in particular asks us to count the number of *additional* ways). (To do modulo division, we use Fermat\\'s little theorem which tells us that `a^(p-1) = 1 mod p => a^(p-2) = a^-1 mod p`, where p is a prime, and binary exponentiation)\\n\\nTo determine the sizes of subtrees, we can build the BST as we iterate through the input ordering. As a base case, we know the subtree size of the root will be n automatically. Now, in general, there are 3 possible cases for a node if we consider it\\'s lower and higher element in the BST. Let the values of these respective elements be `below` and `above`.\\n1. If the next lower element and next higher element both exist, then the number of elements in our subtree will be `above - below - 1`.  This is because all elements in the inclusive range `[below + 1, above - 1]` will be added to this node\\'s subtree.\\n2. If the next lower element exists but not the next higher, the number of elements in our subtree will be `n - below`, since elements in `[below + 1, n]` will be added here\\n3. If the next lower element exists but not the next higher, we\\'ll have `above-1`, since elements in `[1, above - 1]` will be added here\\n\\nSo, we can compute these values in `O(log(n))` time for each node as we iterate through the tree, for a total of `O(nlog(n))` time and `O(n)` memory.\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 954643,
                "title": "go-o-n-2-dp-solution",
                "content": "```\\ntype TreeNode struct {\\n    Val int\\n    SizeLeft int\\n    SizeRight int\\n    Left *TreeNode\\n    Right *TreeNode\\n}\\n\\nfunc insert(node *TreeNode, val int){\\n    if val < node.Val{\\n        if node.Left == nil{\\n            node.Left = &TreeNode{Val : val}\\n        } else {\\n            insert(node.Left, val)\\n        }\\n        node.SizeLeft++\\n    }else{\\n        if node.Right == nil{\\n            node.Right = &TreeNode{Val : val}\\n        } else {\\n            insert(node.Right, val)\\n        }\\n        node.SizeRight++\\n    }\\n}\\n\\nfunc solve(node *TreeNode, dp *[]int, ncr *[][]int, mod int) int{\\n    if node == nil {\\n        return 1\\n    }\\n    if (*dp)[node.Val] != -1 {\\n        return (*dp)[node.Val]\\n    }\\n    waysLeft := solve(node.Left, dp, ncr, mod)\\n    waysRight := solve(node.Right, dp, ncr, mod)\\n    nodesLeft := node.SizeLeft\\n    nodesRight := node.SizeRight\\n    sol := waysLeft\\n    sol = (sol * waysRight) % mod\\n    sol = (sol * (*ncr)[nodesLeft + nodesRight] [nodesLeft]) % mod\\n    (*dp)[node.Val] = sol\\n    return sol\\n}\\n\\nfunc numOfWays(nums []int) int {\\n    if len(nums) == 0 {\\n        return 0\\n    }\\n    const mod = int(1e9 + 7)\\n    root := &TreeNode{Val : nums[0]}\\n    for i := 1; i < len(nums); i++ {\\n        insert(root, nums[i])\\n    }\\n    dp := make([]int, len(nums) + 1)\\n    for i := range dp{\\n        dp[i] = -1\\n    }\\n    ncr := make([][]int, 1005)\\n    for i := 0; i <= 1000; i++ {\\n        ncr[i] = make([]int, i + 1)\\n        ncr[i][0] = 1\\n        ncr[i][i] = 1\\n        for j := 1; j < i; j++ {\\n            ncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1]) % mod\\n        }\\n    }\\n    return (solve(root, &dp, &ncr, mod) - 1 + mod) % mod;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype TreeNode struct {\\n    Val int\\n    SizeLeft int\\n    SizeRight int\\n    Left *TreeNode\\n    Right *TreeNode\\n}\\n\\nfunc insert(node *TreeNode, val int){\\n    if val < node.Val{\\n        if node.Left == nil{\\n            node.Left = &TreeNode{Val : val}\\n        } else {\\n            insert(node.Left, val)\\n        }\\n        node.SizeLeft++\\n    }else{\\n        if node.Right == nil{\\n            node.Right = &TreeNode{Val : val}\\n        } else {\\n            insert(node.Right, val)\\n        }\\n        node.SizeRight++\\n    }\\n}\\n\\nfunc solve(node *TreeNode, dp *[]int, ncr *[][]int, mod int) int{\\n    if node == nil {\\n        return 1\\n    }\\n    if (*dp)[node.Val] != -1 {\\n        return (*dp)[node.Val]\\n    }\\n    waysLeft := solve(node.Left, dp, ncr, mod)\\n    waysRight := solve(node.Right, dp, ncr, mod)\\n    nodesLeft := node.SizeLeft\\n    nodesRight := node.SizeRight\\n    sol := waysLeft\\n    sol = (sol * waysRight) % mod\\n    sol = (sol * (*ncr)[nodesLeft + nodesRight] [nodesLeft]) % mod\\n    (*dp)[node.Val] = sol\\n    return sol\\n}\\n\\nfunc numOfWays(nums []int) int {\\n    if len(nums) == 0 {\\n        return 0\\n    }\\n    const mod = int(1e9 + 7)\\n    root := &TreeNode{Val : nums[0]}\\n    for i := 1; i < len(nums); i++ {\\n        insert(root, nums[i])\\n    }\\n    dp := make([]int, len(nums) + 1)\\n    for i := range dp{\\n        dp[i] = -1\\n    }\\n    ncr := make([][]int, 1005)\\n    for i := 0; i <= 1000; i++ {\\n        ncr[i] = make([]int, i + 1)\\n        ncr[i][0] = 1\\n        ncr[i][i] = 1\\n        for j := 1; j < i; j++ {\\n            ncr[i][j] = (ncr[i - 1][j] + ncr[i - 1][j - 1]) % mod\\n        }\\n    }\\n    return (solve(root, &dp, &ncr, mod) - 1 + mod) % mod;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935585,
                "title": "easy-and-commented-c-solution",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    ll MOD=1e9L+7;\\n    ll dp[1001][1001]; // dp[i][j] = iCj (i choose j)\\n    \\n    ll util(vector<int>& v){\\n        int n=v.size();\\n        if(n==0) return 1; // base case when binary search tree is empty\\n        \\n        int root=v[0]; // root of the binary search tree\\n        \\n        vector<int> left, right;\\n        \\n        for(int i=1; i<n; i++){\\n            if(v[i]>root){\\n                right.push_back(v[i]); // right children of root\\n            }\\n            else if(v[i]<root){\\n                left.push_back(v[i]); // left children of root\\n            }\\n        }\\n        \\n        ll left_ans=util(left); // number of ways to form left subtree\\n        ll right_ans=util(right); // number of ways to form right subtree\\n        \\n        ll ans=(ll)left_ans*right_ans%MOD; // merging the answer of left and right (standard divide conquer strategy)\\n        \\n        ans=(ll)ans*dp[n-1][(int)left.size()]%MOD; // also among total n-1 insertions in this tree there are (n-1)C(left.size()) ways to interleave the left and right insertions\\n        \\n        return ans;\\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        dp[0][0]=1;\\n        \\n        for(ll i=1; i<=nums.size(); i++){\\n            dp[i][0]=1;\\n            dp[i][i]=1;\\n            for(ll j=1; j<i; j++){\\n                dp[i][j]=(dp[i-1][j-1]+dp[i-1][j])%MOD;\\n            }\\n        }\\n        \\n        ll ans=util(nums);\\n        \\n        ans=(ans+MOD-1)%MOD; // need to subtract the already given ordering\\n        \\n        return ans; // :)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n    ll MOD=1e9L+7;\\n    ll dp[1001][1001]; // dp[i][j] = iCj (i choose j)\\n    \\n    ll util(vector<int>& v){\\n        int n=v.size();\\n        if(n==0) return 1; // base case when binary search tree is empty\\n        \\n        int root=v[0]; // root of the binary search tree\\n        \\n        vector<int> left, right;\\n        \\n        for(int i=1; i<n; i++){\\n            if(v[i]>root){\\n                right.push_back(v[i]); // right children of root\\n            }\\n            else if(v[i]<root){\\n                left.push_back(v[i]); // left children of root\\n            }\\n        }\\n        \\n        ll left_ans=util(left); // number of ways to form left subtree\\n        ll right_ans=util(right); // number of ways to form right subtree\\n        \\n        ll ans=(ll)left_ans*right_ans%MOD; // merging the answer of left and right (standard divide conquer strategy)\\n        \\n        ans=(ll)ans*dp[n-1][(int)left.size()]%MOD; // also among total n-1 insertions in this tree there are (n-1)C(left.size()) ways to interleave the left and right insertions\\n        \\n        return ans;\\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        dp[0][0]=1;\\n        \\n        for(ll i=1; i<=nums.size(); i++){\\n            dp[i][0]=1;\\n            dp[i][i]=1;\\n            for(ll j=1; j<i; j++){\\n                dp[i][j]=(dp[i-1][j-1]+dp[i-1][j])%MOD;\\n            }\\n        }\\n        \\n        ll ans=util(nums);\\n        \\n        ans=(ans+MOD-1)%MOD; // need to subtract the already given ordering\\n        \\n        return ans; // :)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881155,
                "title": "python-solution-with-divide-concur-and-recursion",
                "content": "Just complete on Daciuk\\'s post \\n\\nhttps://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/discuss/819326/Python-in-6-short-lines-with-easy-explanation\\n\\n\\'\\'\\'\\'\\n\\n\\t\\tclass Solution(object):\\n\\t\\t\\tdef numOfWays(self, nums):\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t\\t:rtype: int\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tmemo = dict()\\n\\t\\t\\t\\tMOD = 10**9+7\\n\\t\\t\\t\\tdef comb(m, n):\\n\\t\\t\\t\\t\\tif m == 0 or n == 0:\\n\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\tif (m, n) not in memo:\\n\\t\\t\\t\\t\\t\\tmemo[(m, n)] = comb(m-1, n) + comb(m, n-1)\\n\\t\\t\\t\\t\\treturn memo[(m, n)] \\n\\n\\t\\t\\t\\tdef f(nums):\\n\\t\\t\\t\\t\\tif len(nums) <= 2:\\n\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\troot = nums[0]\\n\\t\\t\\t\\t\\tleft = []\\n\\t\\t\\t\\t\\tright = []\\n\\t\\t\\t\\t\\tfor n in nums[1:]:\\n\\t\\t\\t\\t\\t\\tif n < root:\\n\\t\\t\\t\\t\\t\\t\\tleft.append(n)\\n\\t\\t\\t\\t\\t\\tif n > root:\\n\\t\\t\\t\\t\\t\\t\\tright.append(n)\\n\\t\\t\\t\\t\\treturn comb(len(left), len(right)) * f(left) * f(right)\\n\\n\\t\\t\\t\\treturn (f(nums)-1)%MOD\\n\\n\\n\\'\\'\\'\\'",
                "solutionTags": [],
                "code": "Just complete on Daciuk\\'s post \\n\\nhttps://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/discuss/819326/Python-in-6-short-lines-with-easy-explanation\\n\\n\\'\\'\\'\\'\\n\\n\\t\\tclass Solution(object):\\n\\t\\t\\tdef numOfWays(self, nums):\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t\\t:rtype: int\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tmemo = dict()\\n\\t\\t\\t\\tMOD = 10**9+7\\n\\t\\t\\t\\tdef comb(m, n):\\n\\t\\t\\t\\t\\tif m == 0 or n == 0:\\n\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\tif (m, n) not in memo:\\n\\t\\t\\t\\t\\t\\tmemo[(m, n)] = comb(m-1, n) + comb(m, n-1)\\n\\t\\t\\t\\t\\treturn memo[(m, n)] \\n\\n\\t\\t\\t\\tdef f(nums):\\n\\t\\t\\t\\t\\tif len(nums) <= 2:\\n\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\troot = nums[0]\\n\\t\\t\\t\\t\\tleft = []\\n\\t\\t\\t\\t\\tright = []\\n\\t\\t\\t\\t\\tfor n in nums[1:]:\\n\\t\\t\\t\\t\\t\\tif n < root:\\n\\t\\t\\t\\t\\t\\t\\tleft.append(n)\\n\\t\\t\\t\\t\\t\\tif n > root:\\n\\t\\t\\t\\t\\t\\t\\tright.append(n)\\n\\t\\t\\t\\t\\treturn comb(len(left), len(right)) * f(left) * f(right)\\n\\n\\t\\t\\t\\treturn (f(nums)-1)%MOD\\n\\n\\n\\'\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 834208,
                "title": "no-pascal-s-triangle-or-yang-or-combinatoral-formula-simple-dp-accepted-and-faster-than-60",
                "content": "1) For the given list, 1st number is the root. Make a list of smaller and bigger numbers after this. And do the following recursively for each of them.\\n2) We need to merge bigger and smaller list together in a way that relative ordering of the number is maintained.\\n```\\n\\'\\'\\'\\nAssume dp[i][j] as the number of ways to put two lists of length i and j together while preserving relative order. Then you can either pick 1 element of i or 1 element of j. Therefore: \\n\\'\\'\\'\\ndp[i][j] = dp[i-1][j] + dp[i][j-1]\\ndp[0][x] = 1\\ndp[x][0] = 1\\n```\\n\\n\\n```\\nclass Solution:\\n    \\n    def finddp(self, m, n):\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        for i in range(m+1):\\n            dp[i][0] = 1\\n        \\n        for j in range(n+1):\\n            dp[0][j] = 1\\n        \\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp\\n                \\n        \\n        \\n    def numOfW(self, nums: List[int], dp) -> int:\\n        if len(nums) == 0:\\n            return 1\\n        bigger = []\\n        smaller = []\\n        for n in nums[1:]:\\n            if n > nums[0]:\\n                bigger.append(n)\\n            elif n < nums[0]:\\n                smaller.append(n)\\n                \\n        ans = dp[len(bigger)][len(smaller)]\\n        x = 1\\n        if len(bigger):\\n            x = self.numOfW(bigger, dp)\\n        \\n        if len(smaller):\\n            x *= self.numOfW(smaller, dp)\\n            \\n        ans = ans * x\\n        return ans\\n    \\n    def numOfWays(self, nums: List[int]) -> int:\\n        x = self.finddp(len(nums), len(nums))\\n        return self.numOfW(nums, x) % (10**9 + 7) - 1\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nAssume dp[i][j] as the number of ways to put two lists of length i and j together while preserving relative order. Then you can either pick 1 element of i or 1 element of j. Therefore: \\n\\'\\'\\'\\ndp[i][j] = dp[i-1][j] + dp[i][j-1]\\ndp[0][x] = 1\\ndp[x][0] = 1\\n```\n```\\nclass Solution:\\n    \\n    def finddp(self, m, n):\\n        dp = [[0 for j in range(n+1)] for i in range(m+1)]\\n        for i in range(m+1):\\n            dp[i][0] = 1\\n        \\n        for j in range(n+1):\\n            dp[0][j] = 1\\n        \\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\\n        return dp\\n                \\n        \\n        \\n    def numOfW(self, nums: List[int], dp) -> int:\\n        if len(nums) == 0:\\n            return 1\\n        bigger = []\\n        smaller = []\\n        for n in nums[1:]:\\n            if n > nums[0]:\\n                bigger.append(n)\\n            elif n < nums[0]:\\n                smaller.append(n)\\n                \\n        ans = dp[len(bigger)][len(smaller)]\\n        x = 1\\n        if len(bigger):\\n            x = self.numOfW(bigger, dp)\\n        \\n        if len(smaller):\\n            x *= self.numOfW(smaller, dp)\\n            \\n        ans = ans * x\\n        return ans\\n    \\n    def numOfWays(self, nums: List[int]) -> int:\\n        x = self.finddp(len(nums), len(nums))\\n        return self.numOfW(nums, x) % (10**9 + 7) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825638,
                "title": "javascript-bigint",
                "content": "```js\\nfunction numOfWays(nums) {\\n  return dfs(nums) - BigInt(1);\\n  \\n  function dfs(arr) {\\n    if (arr.length <= 2) return BigInt(1);\\n    \\n    const left = arr.filter(n => n < arr[0]);\\n    const right = arr.filter(n => n > arr[0]);\\n    let res = BigInt(1);\\n    for (let i = left.length + 1; i <= left.length + right.length; i++) {\\n      res *= BigInt(i);\\n      res /= BigInt(i - left.length);\\n    }\\n    return res * dfs(left) * dfs(right) % BigInt(1000000007);\\n  }  \\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction numOfWays(nums) {\\n  return dfs(nums) - BigInt(1);\\n  \\n  function dfs(arr) {\\n    if (arr.length <= 2) return BigInt(1);\\n    \\n    const left = arr.filter(n => n < arr[0]);\\n    const right = arr.filter(n => n > arr[0]);\\n    let res = BigInt(1);\\n    for (let i = left.length + 1; i <= left.length + right.length; i++) {\\n      res *= BigInt(i);\\n      res /= BigInt(i - left.length);\\n    }\\n    return res * dfs(left) * dfs(right) % BigInt(1000000007);\\n  }  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820590,
                "title": "c-recursive-solution",
                "content": "```\\n// any sequence of size (x+y) can give the same BST if the mutual ordering of the permutation from set A and permutation of set B is maintained. There are choose(x + y, y) ways to do that.\\n\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    \\n   vector<vector<int>> comb; \\n    \\n    void combs(int n){\\n        \\n        for(int i=2;i<=n;i++){\\n            for(int j=1;j<i;j++){\\n                comb[i][j] = (comb[i-1][j]+comb[i-1][j-1])%mod;\\n            }\\n        }\\n        return;\\n    }\\n    \\n    \\n    int helper(vector<int>& nums){\\n               \\n        int n = nums.size();\\n        if(n<=2) return 1;\\n        int l = 0, r = 0;\\n        vector<int> left, right;\\n        int root = nums[0];\\n        \\n        for(int x:nums){\\n            if(x<root){ left.push_back(x); l++;}\\n            if(x>root){ right.push_back(x); r++;}\\n        }\\n        long long res = 1;\\n        res = (res*(comb[l+r][r]%mod))%mod;\\n        res = (res*(helper(left)%mod))%mod;\\n        res = (res*(helper(right)%mod))%mod;\\n        return res%mod;\\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        comb.resize(n+1, vector<int>(n+1, 1));\\n        combs(n);\\n        \\n        return (helper(nums)-1)%mod;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// any sequence of size (x+y) can give the same BST if the mutual ordering of the permutation from set A and permutation of set B is maintained. There are choose(x + y, y) ways to do that.\\n\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    \\n   vector<vector<int>> comb; \\n    \\n    void combs(int n){\\n        \\n        for(int i=2;i<=n;i++){\\n            for(int j=1;j<i;j++){\\n                comb[i][j] = (comb[i-1][j]+comb[i-1][j-1])%mod;\\n            }\\n        }\\n        return;\\n    }\\n    \\n    \\n    int helper(vector<int>& nums){\\n               \\n        int n = nums.size();\\n        if(n<=2) return 1;\\n        int l = 0, r = 0;\\n        vector<int> left, right;\\n        int root = nums[0];\\n        \\n        for(int x:nums){\\n            if(x<root){ left.push_back(x); l++;}\\n            if(x>root){ right.push_back(x); r++;}\\n        }\\n        long long res = 1;\\n        res = (res*(comb[l+r][r]%mod))%mod;\\n        res = (res*(helper(left)%mod))%mod;\\n        res = (res*(helper(right)%mod))%mod;\\n        return res%mod;\\n    }\\n    \\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        comb.resize(n+1, vector<int>(n+1, 1));\\n        combs(n);\\n        \\n        return (helper(nums)-1)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820386,
                "title": "python3-easy-concise-7-line-dfs-without-comb-o-n-2",
                "content": "As an alternative to the approach using the function ```comb``` in each iteration,\\nwe actually only need to consider **the lengths of all the subtree arrays** instead.\\n\\n**Quick proof:**\\nFor each subtree array (e.g., ```num```),\\nsince the first element (i.e., the root node of the subtree) can only be placed at the first place,\\nonly ```1 / len(num)``` of the all permutations satisfy the requirement.\\n\\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        \\n        def dfs(num):\\n            if len(num) <= 1: return 1\\n            left = [n for n in num[1:] if n < num[0]]\\n            right = [n for n in num[1:] if n > num[0]]\\n            return len(num) * dfs(left) * dfs(right)\\n            \\n        return (math.factorial(len(nums)) // dfs(nums) - 1) % mod\\n```\\n\\n**Complexity Analysis:**\\nTime: ```O(N^2)```\\nSpace: ```O(N)```",
                "solutionTags": [],
                "code": "```comb```\n```num```\n```1 / len(num)```\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        \\n        def dfs(num):\\n            if len(num) <= 1: return 1\\n            left = [n for n in num[1:] if n < num[0]]\\n            right = [n for n in num[1:] if n > num[0]]\\n            return len(num) * dfs(left) * dfs(right)\\n            \\n        return (math.factorial(len(nums)) // dfs(nums) - 1) % mod\\n```\n```O(N^2)```\n```O(N)```",
                "codeTag": "Java"
            },
            {
                "id": 820279,
                "title": "accepted-c-solution-with-dfs",
                "content": "```\\n             public class Solution\\n        {\\n            private class Node\\n            {\\n                public int Val;\\n                public Node Left;\\n                public Node Right;\\n                public int SubTreeSize;\\n            }\\n\\n\\n            private const int MODULO = 1_000_000_007;\\n\\n            private void FillSubtreeSize(Node node)\\n            {\\n                if (node == null)\\n                {\\n                    return;\\n                }\\n\\n                node.SubTreeSize++;\\n                FillSubtreeSize(node.Left);\\n                FillSubtreeSize(node.Right);\\n                node.SubTreeSize += (node.Left?.SubTreeSize).GetValueOrDefault(0);\\n                node.SubTreeSize += (node.Right?.SubTreeSize).GetValueOrDefault(0);\\n            }\\n\\n            private BigInteger Factorial(long n, BigInteger?[] factorialCache)\\n            {\\n                if (n == 0)\\n                {\\n                    return 1;\\n                }\\n\\n                if (factorialCache[n].HasValue)\\n                {\\n                    return factorialCache[n].Value;\\n                }\\n\\n                var next = Factorial(n - 1, factorialCache);\\n                var res = next * n;\\n                factorialCache[n] = res;\\n                return res;\\n            }\\n\\n            private long CnK(long n, long k, BigInteger?[] factorialCache)\\n            {\\n                checked\\n                {\\n                    var cnk = Factorial(n, factorialCache) /\\n                              (Factorial(k, factorialCache) * Factorial(n - k, factorialCache));\\n                    cnk %= MODULO;\\n                    return (long) cnk;\\n                }\\n            }\\n\\n            private long Helper(Node node, BigInteger?[] factorialCache)\\n            {\\n                if (node.Left == null && node.Right == null)\\n                {\\n                    return 1;\\n                }\\n\\n                if (node.Left == null && node.Right != null)\\n                {\\n                    return Helper(node.Right, factorialCache);\\n                }\\n\\n                if (node.Left != null && node.Right == null)\\n                {\\n                    return Helper(node.Left, factorialCache);\\n                }\\n\\n                var l = Helper(node.Left, factorialCache);\\n                var r = Helper(node.Right, factorialCache);\\n\\n                long intersections = l * r;\\n                intersections %= MODULO;\\n                intersections *= CnK(node.SubTreeSize - 1, node.Left.SubTreeSize,\\n                    factorialCache);\\n                intersections %= MODULO;\\n                return intersections;\\n            }\\n\\n            public int NumOfWays(int[] nums)\\n            {\\n                Node root = new Node();\\n                root.Val = nums[0];\\n\\n                for (int i = 1; i < nums.Length; i++)\\n                {\\n                    var val = nums[i];\\n                    Node node = root;\\n\\n                    while (true)\\n                    {\\n                        if (val < node.Val)\\n                        {\\n                            if (node.Left == null)\\n                            {\\n                                node.Left = new Node();\\n                                node.Left.Val = val;\\n                                break;\\n                            }\\n                            else\\n                            {\\n                                node = node.Left;\\n                            }\\n\\n                            continue;\\n                        }\\n\\n\\n                        if (node.Right == null)\\n                        {\\n                            node.Right = new Node();\\n                            node.Right.Val = val;\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            node = node.Right;\\n                        }\\n                    }\\n                }\\n\\n                FillSubtreeSize(root);\\n                var res = Helper(root, new BigInteger?[nums.Length + 1]);\\n                res--;\\n                res += MODULO;\\n                res %= MODULO;\\n                return (int)res;\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n             public class Solution\\n        {\\n            private class Node\\n            {\\n                public int Val;\\n                public Node Left;\\n                public Node Right;\\n                public int SubTreeSize;\\n            }\\n\\n\\n            private const int MODULO = 1_000_000_007;\\n\\n            private void FillSubtreeSize(Node node)\\n            {\\n                if (node == null)\\n                {\\n                    return;\\n                }\\n\\n                node.SubTreeSize++;\\n                FillSubtreeSize(node.Left);\\n                FillSubtreeSize(node.Right);\\n                node.SubTreeSize += (node.Left?.SubTreeSize).GetValueOrDefault(0);\\n                node.SubTreeSize += (node.Right?.SubTreeSize).GetValueOrDefault(0);\\n            }\\n\\n            private BigInteger Factorial(long n, BigInteger?[] factorialCache)\\n            {\\n                if (n == 0)\\n                {\\n                    return 1;\\n                }\\n\\n                if (factorialCache[n].HasValue)\\n                {\\n                    return factorialCache[n].Value;\\n                }\\n\\n                var next = Factorial(n - 1, factorialCache);\\n                var res = next * n;\\n                factorialCache[n] = res;\\n                return res;\\n            }\\n\\n            private long CnK(long n, long k, BigInteger?[] factorialCache)\\n            {\\n                checked\\n                {\\n                    var cnk = Factorial(n, factorialCache) /\\n                              (Factorial(k, factorialCache) * Factorial(n - k, factorialCache));\\n                    cnk %= MODULO;\\n                    return (long) cnk;\\n                }\\n            }\\n\\n            private long Helper(Node node, BigInteger?[] factorialCache)\\n            {\\n                if (node.Left == null && node.Right == null)\\n                {\\n                    return 1;\\n                }\\n\\n                if (node.Left == null && node.Right != null)\\n                {\\n                    return Helper(node.Right, factorialCache);\\n                }\\n\\n                if (node.Left != null && node.Right == null)\\n                {\\n                    return Helper(node.Left, factorialCache);\\n                }\\n\\n                var l = Helper(node.Left, factorialCache);\\n                var r = Helper(node.Right, factorialCache);\\n\\n                long intersections = l * r;\\n                intersections %= MODULO;\\n                intersections *= CnK(node.SubTreeSize - 1, node.Left.SubTreeSize,\\n                    factorialCache);\\n                intersections %= MODULO;\\n                return intersections;\\n            }\\n\\n            public int NumOfWays(int[] nums)\\n            {\\n                Node root = new Node();\\n                root.Val = nums[0];\\n\\n                for (int i = 1; i < nums.Length; i++)\\n                {\\n                    var val = nums[i];\\n                    Node node = root;\\n\\n                    while (true)\\n                    {\\n                        if (val < node.Val)\\n                        {\\n                            if (node.Left == null)\\n                            {\\n                                node.Left = new Node();\\n                                node.Left.Val = val;\\n                                break;\\n                            }\\n                            else\\n                            {\\n                                node = node.Left;\\n                            }\\n\\n                            continue;\\n                        }\\n\\n\\n                        if (node.Right == null)\\n                        {\\n                            node.Right = new Node();\\n                            node.Right.Val = val;\\n                            break;\\n                        }\\n                        else\\n                        {\\n                            node = node.Right;\\n                        }\\n                    }\\n                }\\n\\n                FillSubtreeSize(root);\\n                var res = Helper(root, new BigInteger?[nums.Length + 1]);\\n                res--;\\n                res += MODULO;\\n                res %= MODULO;\\n                return (int)res;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819683,
                "title": "python-simple-code-beats-100-in-runtime-with-explanations",
                "content": "Note: \\nThe difficult part is to calculate 1000!\\nThis solution is not the best one, but is very easy to come up with.\\nIt is not good because number gets very large as the number of nodes gets bigger.\\nIdeally, we should use modular calculations.\\n\\nUsing pascal\\'s triangle\\uFF08\\u6768\\u8F89\\u4E09\\u89D2\\uFF09to calculate all combinations is a better solution.\\nBut my version is very simple, so I shared it.\\nIf people are interested, go check other solutions for building a tree / using pascal\\'s triangle as well.\\n\\n\\t### Precalculation of 0! to 1000! so that we don\\'t need to calculate them each time\\n\\tfacall = [1]\\n\\tp = 10**9 + 7\\n\\tresult = 1\\n\\tfor i in range(1, 1001):\\n\\t\\tresult = (result * i)\\n\\t\\tfacall.append(result)\\n\\n\\tclass Solution:\\n\\t\\tdef numOfWays(self, nums: List[int]) -> int:\\n\\t\\t\\tmod = 10**9 + 7\\n\\n\\t\\t\\tdef helper(nums):\\n\\t\\t\\t\\t# base case of no node or 1 node\\n\\t\\t\\t\\tif len(nums) <= 1: return 1\\n\\n\\t\\t\\t\\troot = nums[0]\\n\\t\\t\\t\\t# find how many numbers are in the left and right subtree\\n\\t\\t\\t\\tnumsleft = []\\n\\t\\t\\t\\tnumsright = []\\n\\t\\t\\t\\tfor n in nums[1:]:\\n\\t\\t\\t\\t\\tif n < root:\\n\\t\\t\\t\\t\\t\\tnumsleft.append(n)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tnumsright.append(n)\\n\\n\\t\\t\\t\\tleft = helper(numsleft)\\n\\t\\t\\t\\tright = helper(numsright)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# for each order of numsleft and numsright\\n\\t\\t\\t\\t# each time, we can randomly choose one node from numsleft or nums right\\n\\t\\t\\t\\t# so it is choose len(numsleft) from (len(numsleft) + len(numsright))\\n\\t\\t\\t\\t# there are left * right combinations\\n\\t\\t\\t\\treturn (left * right * facall[len(nums)-1] // facall[len(numsleft)] // facall[len(numsright)])%mod\\n\\t\\t\\t\\n\\t\\t\\t# subtract 1 here because the current order should not be counted.\\n\\t\\t\\treturn (helper(nums)-1)%mod",
                "solutionTags": [],
                "code": "Note: \\nThe difficult part is to calculate 1000!\\nThis solution is not the best one, but is very easy to come up with.\\nIt is not good because number gets very large as the number of nodes gets bigger.\\nIdeally, we should use modular calculations.\\n\\nUsing pascal\\'s triangle\\uFF08\\u6768\\u8F89\\u4E09\\u89D2\\uFF09to calculate all combinations is a better solution.\\nBut my version is very simple, so I shared it.\\nIf people are interested, go check other solutions for building a tree / using pascal\\'s triangle as well.\\n\\n\\t### Precalculation of 0! to 1000! so that we don\\'t need to calculate them each time\\n\\tfacall = [1]\\n\\tp = 10**9 + 7\\n\\tresult = 1\\n\\tfor i in range(1, 1001):\\n\\t\\tresult = (result * i)\\n\\t\\tfacall.append(result)\\n\\n\\tclass Solution:\\n\\t\\tdef numOfWays(self, nums: List[int]) -> int:\\n\\t\\t\\tmod = 10**9 + 7\\n\\n\\t\\t\\tdef helper(nums):\\n\\t\\t\\t\\t# base case of no node or 1 node\\n\\t\\t\\t\\tif len(nums) <= 1: return 1\\n\\n\\t\\t\\t\\troot = nums[0]\\n\\t\\t\\t\\t# find how many numbers are in the left and right subtree\\n\\t\\t\\t\\tnumsleft = []\\n\\t\\t\\t\\tnumsright = []\\n\\t\\t\\t\\tfor n in nums[1:]:\\n\\t\\t\\t\\t\\tif n < root:\\n\\t\\t\\t\\t\\t\\tnumsleft.append(n)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tnumsright.append(n)\\n\\n\\t\\t\\t\\tleft = helper(numsleft)\\n\\t\\t\\t\\tright = helper(numsright)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# for each order of numsleft and numsright\\n\\t\\t\\t\\t# each time, we can randomly choose one node from numsleft or nums right\\n\\t\\t\\t\\t# so it is choose len(numsleft) from (len(numsleft) + len(numsright))\\n\\t\\t\\t\\t# there are left * right combinations\\n\\t\\t\\t\\treturn (left * right * facall[len(nums)-1] // facall[len(numsleft)] // facall[len(numsright)])%mod\\n\\t\\t\\t\\n\\t\\t\\t# subtract 1 here because the current order should not be counted.\\n\\t\\t\\treturn (helper(nums)-1)%mod",
                "codeTag": "Java"
            },
            {
                "id": 819463,
                "title": "java-accepted-with-traversal",
                "content": "Overflow may happen when int * int * int even when using long. This makes sense since long.MAX_VALUE = int.MAX_VALUE * int.MAX_VALUE.\\nSo split int * int * int into int * int MOD and then * int MOD.\\nPassed the tests.\\n\\n```\\nclass Solution {\\n    private static int BASE = 1000000007;\\n    private Map<String, Integer> cache = new HashMap<>();\\n    \\n    public int numOfWays(int[] nums) {\\n        TreeNode root = new TreeNode(nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            root.add(nums[i]);\\n        }\\n        \\n        return dfs(root)[1] - 1;\\n    }\\n    \\n    // first element is element count till this node, second element is # of combinations till this node\\n    private int[] dfs(TreeNode node) {\\n        if (node.left == null && node.right == null) {\\n            return new int[] {1, 1};\\n        }\\n        \\n        if (node.left != null && node.right != null) {\\n            int[] left = dfs(node.left);\\n            int[] right= dfs(node.right);\\n            long mul = ((long)left[1] * right[1]) % BASE;\\n            \\n            long res = mul * comb(left[0], right[0]);\\n            return new int[] { left[0] +right[0] + 1,  (int)(res % BASE)};\\n        }\\n        \\n        TreeNode childNode = node.left != null ? node.left : node.right;\\n        int[] child = dfs(childNode);\\n        return new int[] {child[0] +1, child[1]};\\n    }\\n    \\n    private long comb(int len1, int len2) {\\n        if (len1 == 0 || len2 == 0) {\\n            return 1;\\n        }\\n        String key = len1 + \",\" + len2;\\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        int res = (int)((comb(len1 - 1, len2) + comb(len1, len2 - 1)) % BASE);\\n        cache.put(key, res);\\n        return res;\\n    }\\n    \\n    class TreeNode {\\n        int val;\\n        TreeNode left;\\n        TreeNode right;\\n        \\n        TreeNode(int val) {\\n            this.val = val;\\n        }\\n        \\n        void add(int val) {\\n            if (val > this.val) {\\n                if (this.right == null) {\\n                    this.right = new TreeNode(val);\\n                } else {\\n                    this.right.add(val);\\n                }\\n            } else {\\n                if (this.left == null) {\\n                    this.left = new TreeNode(val);\\n                } else {\\n                    this.left.add(val);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static int BASE = 1000000007;\\n    private Map<String, Integer> cache = new HashMap<>();\\n    \\n    public int numOfWays(int[] nums) {\\n        TreeNode root = new TreeNode(nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            root.add(nums[i]);\\n        }\\n        \\n        return dfs(root)[1] - 1;\\n    }\\n    \\n    // first element is element count till this node, second element is # of combinations till this node\\n    private int[] dfs(TreeNode node) {\\n        if (node.left == null && node.right == null) {\\n            return new int[] {1, 1};\\n        }\\n        \\n        if (node.left != null && node.right != null) {\\n            int[] left = dfs(node.left);\\n            int[] right= dfs(node.right);\\n            long mul = ((long)left[1] * right[1]) % BASE;\\n            \\n            long res = mul * comb(left[0], right[0]);\\n            return new int[] { left[0] +right[0] + 1,  (int)(res % BASE)};\\n        }\\n        \\n        TreeNode childNode = node.left != null ? node.left : node.right;\\n        int[] child = dfs(childNode);\\n        return new int[] {child[0] +1, child[1]};\\n    }\\n    \\n    private long comb(int len1, int len2) {\\n        if (len1 == 0 || len2 == 0) {\\n            return 1;\\n        }\\n        String key = len1 + \",\" + len2;\\n        if (cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        int res = (int)((comb(len1 - 1, len2) + comb(len1, len2 - 1)) % BASE);\\n        cache.put(key, res);\\n        return res;\\n    }\\n    \\n    class TreeNode {\\n        int val;\\n        TreeNode left;\\n        TreeNode right;\\n        \\n        TreeNode(int val) {\\n            this.val = val;\\n        }\\n        \\n        void add(int val) {\\n            if (val > this.val) {\\n                if (this.right == null) {\\n                    this.right = new TreeNode(val);\\n                } else {\\n                    this.right.add(val);\\n                }\\n            } else {\\n                if (this.left == null) {\\n                    this.left = new TreeNode(val);\\n                } else {\\n                    this.left.add(val);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819452,
                "title": "java-solution-combination-using-pascal-triangle",
                "content": "Can be optimized. But the idea for calculating combination mod is to use pascal triangle\\n\\n```\\nclass Solution {\\n    int mod = 1000000007;\\n\\n    // nCr = (n-1)C(r-1) + (n-1)Cr;\\n    private long combination(int n, int r) {\\n        if (n == 0) return 1;\\n\\n        long[][] pascal = new long[n+1][r+1];\\n        \\n        pascal[0][0] = 1;\\n        for (int i=1; i<=n; i++) {\\n            pascal[i][0] = 1;\\n            for (int j=1; j<=r; j++) {\\n                pascal[i][j] = (pascal[i-1][j-1] + pascal[i-1][j]) % mod;\\n            }\\n        }\\n        \\n        return pascal[n][r];\\n    }\\n\\n    public int numOfWays(int[] nums) {\\n        List<Integer> l = new ArrayList<>();\\n        for (int i: nums) l.add(i);\\n\\n        long ans = (mod + totalWays(l) - 1) % mod;\\n\\n        return (int) ans;\\n    }\\n\\n    private long totalWays(List<Integer> t) {\\n        if (t.size() == 0) return 1;\\n\\n        List<Integer> l = new ArrayList<>();\\n        List<Integer> r = new ArrayList<>();\\n\\n        int head = t.get(0);\\n\\n        for (int i=1; i<t.size(); i++) {\\n            if (t.get(i) > head) {\\n                r.add(t.get(i));\\n            } else {\\n                l.add(t.get(i));\\n            }\\n        }\\n \\n        long cnt = (totalWays(l) * totalWays(r)) % mod;\\n        long comb = combination(t.size()-1, l.size());\\n\\n        return ((comb*cnt)%mod);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n\\n    // nCr = (n-1)C(r-1) + (n-1)Cr;\\n    private long combination(int n, int r) {\\n        if (n == 0) return 1;\\n\\n        long[][] pascal = new long[n+1][r+1];\\n        \\n        pascal[0][0] = 1;\\n        for (int i=1; i<=n; i++) {\\n            pascal[i][0] = 1;\\n            for (int j=1; j<=r; j++) {\\n                pascal[i][j] = (pascal[i-1][j-1] + pascal[i-1][j]) % mod;\\n            }\\n        }\\n        \\n        return pascal[n][r];\\n    }\\n\\n    public int numOfWays(int[] nums) {\\n        List<Integer> l = new ArrayList<>();\\n        for (int i: nums) l.add(i);\\n\\n        long ans = (mod + totalWays(l) - 1) % mod;\\n\\n        return (int) ans;\\n    }\\n\\n    private long totalWays(List<Integer> t) {\\n        if (t.size() == 0) return 1;\\n\\n        List<Integer> l = new ArrayList<>();\\n        List<Integer> r = new ArrayList<>();\\n\\n        int head = t.get(0);\\n\\n        for (int i=1; i<t.size(); i++) {\\n            if (t.get(i) > head) {\\n                r.add(t.get(i));\\n            } else {\\n                l.add(t.get(i));\\n            }\\n        }\\n \\n        long cnt = (totalWays(l) * totalWays(r)) % mod;\\n        long comb = combination(t.size()-1, l.size());\\n\\n        return ((comb*cnt)%mod);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819450,
                "title": "python-o-n-log-n-solution",
                "content": "Let us analyze the problem, use [3,1,2,5,4,6] as example\\nThe total number of ways without any restriction is 6!=720, you can see them as whole group 1-6.\\n\\nIf you choose the 3 as root of the BST,   the number of ways will be divided by 6, that is 120. 120 ways to construct BST with the root 3.  And rest number will be divided by two groups,  1-2 will go to left  and 4-6 will go to right.\\nThen the next number 1 comes to the left child of 3,  since if 2 comes before 1,  the tree will be different.  So the 120 ways will be divided by 2, that is 60. The rest number still be 2 groups,   2 and 4-6.  \\nThen the next number 2, no matter when it comes, it will always go to 1\\'s right child, and no other number will go to.  So the number of ways is unchanged.\\n\\nThen the next number 4 go to right child of 3 and will make the group 4-6 become 4,6 and total number of ways will be divided by 3. 60/3=20\\nAnd last two numbers 4,6, no matter which come first,  4 will always go to 5\\'s left child and 6 will always go to right child.\\nWe can see,  20 ways to construct tree same as [3,1,2,4,5,6],  expect for itself,  the answer is 19.\\n\\nSo we set total way to be n! initially.  And we will use intervals [[m1,n1],[m2,n2],[m3,n3]......]  to represent the groups of rest numbers,  when a numbe k falls within  [m,n],   the totalways will be divided by n-m+1,  and [m,n] will be cut into [m,k-1],[k+1,n]\\nHere is the code.\\n\\nSince the n! is O(n) time complexity, and searching a number one time from intervals is O(log n),  the time complexity is O(n log n)\\n\\nYou can calculate the number of permutations totally, and minus 1.  That\\'s it. You can use binary search to find how much you should divide more quickly.\\n\\nnotice:  fastfrac is the method to quickly calculate the a//b,   since n! is very large,  we cannot directly divide a by b when a and b are mod by M.  The fastfrac words using Euler-theorem. You can refer this for more information https://en.wikipedia.org/wiki/Euler%27s_theorem\\n\\n\\n```\\nM = 10**9+7\\nfact = [1]\\nfor i in range(1,1001):\\n    fact.append((fact[-1]*i)%M)\\n    \\nclass Solution(object):\\n    def numOfWays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def fastfrac(a,b,M):\\n            numb = pow(b,M-2,M)\\n            return ((a%M)*(numb%M))%M\\n        n = len(nums)\\n        ans = fact[n]\\n        block = [[1,n]]   \\n        for num in nums:\\n            loc = bisect.bisect(block,[num,n+1])-1\\n            front = block[loc][0]\\n            rear = block[loc][1]\\n            length = rear - front + 1 \\n            ans = fastfrac(ans,length,M)\\n            if num==front and front!=rear: block[loc][0] += 1 \\n            elif num==rear and front!=rear: block[loc][1] -= 1 \\n            elif front==rear: block.pop(loc)\\n            else:\\n                block[loc][0] = num + 1 \\n                block.insert(loc,[front,num-1])   \\n        return (ans-1)%M\\n```",
                "solutionTags": [],
                "code": "```\\nM = 10**9+7\\nfact = [1]\\nfor i in range(1,1001):\\n    fact.append((fact[-1]*i)%M)\\n    \\nclass Solution(object):\\n    def numOfWays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def fastfrac(a,b,M):\\n            numb = pow(b,M-2,M)\\n            return ((a%M)*(numb%M))%M\\n        n = len(nums)\\n        ans = fact[n]\\n        block = [[1,n]]   \\n        for num in nums:\\n            loc = bisect.bisect(block,[num,n+1])-1\\n            front = block[loc][0]\\n            rear = block[loc][1]\\n            length = rear - front + 1 \\n            ans = fastfrac(ans,length,M)\\n            if num==front and front!=rear: block[loc][0] += 1 \\n            elif num==rear and front!=rear: block[loc][1] -= 1 \\n            elif front==rear: block.pop(loc)\\n            else:\\n                block[loc][0] = num + 1 \\n                block.insert(loc,[front,num-1])   \\n        return (ans-1)%M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819381,
                "title": "python-short-and-simple",
                "content": "**Simple recursion**\\nNumber of ways of re-arranging current array = (number of ways of rearranging **m** values of left subtree) * (number of ways of rearranging **n** values of right subtree) * (number of ways of inter-leaving two arrays of sizes m and n having unique integers such that order is preserved i.e. **xCy where x = m+n and y = n**).\\n\\nAt the end, we subtract 1 from the number of all combinations to account for input sequence which itself gives the same tree and should not be counted.\\n\\nRefer to \"Number of ways to interleave two ordered sequences\": https://math.stackexchange.com/a/666295\\n\\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def countWays(nums):\\n            if not nums:\\n                return 1\\n            nums1 = [num for num in nums if num < nums[0]]\\n            nums2 = [num for num in nums if num > nums[0]]\\n            return countWays(nums1) * countWays(nums2) * math.comb(len(nums1) + len(nums2), len(nums2))\\n        \\n        return (countWays(nums)-1) % (10**9+7)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        def countWays(nums):\\n            if not nums:\\n                return 1\\n            nums1 = [num for num in nums if num < nums[0]]\\n            nums2 = [num for num in nums if num > nums[0]]\\n            return countWays(nums1) * countWays(nums2) * math.comb(len(nums1) + len(nums2), len(nums2))\\n        \\n        return (countWays(nums)-1) % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020246,
                "title": "python3-solution-recursive-beating-81-and-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a given node, check the sizes of its left subtree and right subtree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursive. Using deque to save memory usage on purpose (this step can be optional).\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWhich is the possible max depth of recursive stack. Also the total memory usage for deque is O(N)\\n# Code\\n```\\nfrom collections import deque\\nfrom math import comb\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        modulo = 10 ** 9 + 7\\n        def helper(array: deque):\\n            if not array:\\n                return 1\\n            elif len(array) == 1:\\n                return 1\\n            left = deque()\\n            right = deque()\\n            piv = array.popleft()\\n            while array:\\n                if piv > array[0]:\\n                    left.append(array.popleft())\\n                else:\\n                    right.append(array.popleft())\\n            L = len(left)\\n            R = len(right)\\n            resL = helper(left)\\n            resR = helper(right)\\n            ret = comb(L+R, L) *  resL * resR\\n            return ret % modulo\\n\\n        return helper(deque(nums)) - 1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nfrom math import comb\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        modulo = 10 ** 9 + 7\\n        def helper(array: deque):\\n            if not array:\\n                return 1\\n            elif len(array) == 1:\\n                return 1\\n            left = deque()\\n            right = deque()\\n            piv = array.popleft()\\n            while array:\\n                if piv > array[0]:\\n                    left.append(array.popleft())\\n                else:\\n                    right.append(array.popleft())\\n            L = len(left)\\n            R = len(right)\\n            resL = helper(left)\\n            resR = helper(right)\\n            ret = comb(L+R, L) *  resL * resR\\n            return ret % modulo\\n\\n        return helper(deque(nums)) - 1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979439,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        long long mod=1e9+7;\\n        vector<vector<long long>>table;\\n\\n        long long dfs(vector<int>&nums)\\n        {\\n            long long n=nums.size();\\n            if (n<=2) return 1;\\n            vector<int>left,right;\\n            for (long long i=1;i<nums.size();i++)\\n            {\\n                if (nums[i]>nums[0]) left.push_back(nums[i]);\\n                else right.push_back(nums[i]);\\n            }\\n            long long lans=dfs(left);\\n            long long rans=dfs(right);\\n            long long llen=left.size();\\n            return ((((table[n-1][llen]*lans)%mod)*rans)%mod);\\n        }\\n\\n    int numOfWays(vector<int>& nums) \\n    {\\n        long long n=nums.size();\\n        table.resize(n+1);\\n        for (long long i=0;i<=n;i++)\\n        {\\n            table[i].resize(i+1,1);\\n            for (long long j=1;j<i;j++)\\n            {\\n                table[i][j]=(table[i-1][j-1]+table[i-1][j])%mod;\\n            }\\n        }\\n        return dfs(nums)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        long long mod=1e9+7;\\n        vector<vector<long long>>table;\\n\\n        long long dfs(vector<int>&nums)\\n        {\\n            long long n=nums.size();\\n            if (n<=2) return 1;\\n            vector<int>left,right;\\n            for (long long i=1;i<nums.size();i++)\\n            {\\n                if (nums[i]>nums[0]) left.push_back(nums[i]);\\n                else right.push_back(nums[i]);\\n            }\\n            long long lans=dfs(left);\\n            long long rans=dfs(right);\\n            long long llen=left.size();\\n            return ((((table[n-1][llen]*lans)%mod)*rans)%mod);\\n        }\\n\\n    int numOfWays(vector<int>& nums) \\n    {\\n        long long n=nums.size();\\n        table.resize(n+1);\\n        for (long long i=0;i<=n;i++)\\n        {\\n            table[i].resize(i+1,1);\\n            for (long long j=1;j<i;j++)\\n            {\\n                table[i][j]=(table[i-1][j-1]+table[i-1][j])%mod;\\n            }\\n        }\\n        return dfs(nums)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785934,
                "title": "o-n-2-time-and-space-solution-using-inverse-mod",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> fact, invf;\\n    int p = 1e9 + 7;\\npublic:\\n    int mul(int x, int y, int p) {\\n        long long ans = x;\\n        ans *= y;\\n        ans %= p;\\n        return (int) ans;\\n    }\\n\\n    int pow(int x, int y, int p) {\\n        int ans = 1, t = x;\\n        while (y > 0) {\\n            if (y & 1) ans = mul(ans, t, p);\\n            y >>= 1;\\n            t = mul(t, t, p);\\n        }\\n        return ans;\\n    }\\n\\n    int inv(int x, int p) {\\n        return pow(x, p - 2, p);\\n    }\\n\\n    int C(int n, int r, int p) {\\n        return mul(fact[n], mul(invf[r], invf[n - r], p), p);\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        fact = vector<int>(1002), invf = vector<int>(1002);\\n        for (int i = 0; i < fact.size(); i++) {\\n            if (i < 2) fact[i] = 1;\\n            else fact[i] = mul(i, fact[i - 1], p);\\n            invf[i] = inv(fact[i], p);\\n        }\\n        return calc(nums) - 1;\\n    }\\n\\n    int calc(vector<int> nums) {\\n        int root = nums[0];\\n        vector<int> l, r;\\n        for (int num: nums) {\\n            if (num < root) l.push_back(num);\\n            else if (num > root) r.push_back(num);\\n        }\\n        int ans = C(l.size() + r.size(), l.size(), p);\\n        if (l.size() != 0) ans = mul(ans, calc(l), p);\\n        if (r.size() != 0) ans = mul(ans, calc(r), p);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> fact, invf;\\n    int p = 1e9 + 7;\\npublic:\\n    int mul(int x, int y, int p) {\\n        long long ans = x;\\n        ans *= y;\\n        ans %= p;\\n        return (int) ans;\\n    }\\n\\n    int pow(int x, int y, int p) {\\n        int ans = 1, t = x;\\n        while (y > 0) {\\n            if (y & 1) ans = mul(ans, t, p);\\n            y >>= 1;\\n            t = mul(t, t, p);\\n        }\\n        return ans;\\n    }\\n\\n    int inv(int x, int p) {\\n        return pow(x, p - 2, p);\\n    }\\n\\n    int C(int n, int r, int p) {\\n        return mul(fact[n], mul(invf[r], invf[n - r], p), p);\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        fact = vector<int>(1002), invf = vector<int>(1002);\\n        for (int i = 0; i < fact.size(); i++) {\\n            if (i < 2) fact[i] = 1;\\n            else fact[i] = mul(i, fact[i - 1], p);\\n            invf[i] = inv(fact[i], p);\\n        }\\n        return calc(nums) - 1;\\n    }\\n\\n    int calc(vector<int> nums) {\\n        int root = nums[0];\\n        vector<int> l, r;\\n        for (int num: nums) {\\n            if (num < root) l.push_back(num);\\n            else if (num > root) r.push_back(num);\\n        }\\n        int ans = C(l.size() + r.size(), l.size(), p);\\n        if (l.size() != 0) ans = mul(ans, calc(l), p);\\n        if (r.size() != 0) ans = mul(ans, calc(r), p);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772711,
                "title": "beats-97-time-99-space-no-dp-no-dfs-no-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s iterate over the given nums array. We are at a position i. Now all the elements that would be inserted in the left subtree of this position i are all the elements that are smaller than it and have not yet come in the array, and all the elements that would be inserted in the right subtree of position i are all the elements that are greater than it and have not yet come in the array.\\nHow does this translate into permutations? All the permutations that have the same relative ordering of left and right subtree elements would yield the same BST. For each position i, we can determine the number of elements that would be to its left and the number of elements that would be to its right by the logic in the first para. Let these be l and r respectively. Let\\'s say you put all the l elements. Now any r element can be inserted into the (l+1) gaps across the l elements as shown - \\n        | 2 | 5 | 7 |\\nHere l = 3, and r elements can be put into (l+1) = 4 positions (denoted by | gaps. Small L (l) and \\'|\\' symbol are confusing in leetcode font). So the entire problem can be boiled down to - \\nx(1) + x(2) + .... + x(l+1) = r;    (i in x(i) is subscript)\\nwhere each x(i) can be from 0 to r.\\nThis is the textbook case of multinomial theorem, and the solution to this problem is C(l+r,r) or C(l+r,l). This expression can also be arrived at by Catalan numbers. Understand it however you wish, but do understand why this expression comes here.\\n\\nWhat we can do for this is to iterate over nums, find out the greatest number lower than nums[i] (= x) and the smallest number greater than nums[i] (= y) that lie in nums[0...i-1]. The numbers in the subtree whose root would be nums[i] are all lying in this range [x,y] except the number nums[i] itself. Hence, l would be (nums[i] - x - 1) and r would be (y - nums[i] - 1).\\nSo at each step we multiply C(l + r, l) = C(y - x - 2, nums[i] - x - 1) with the answer so far.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe nCr function should have a mod functionality. The function I have used here is my go-to function, but it might be too long for you. I believe this is the most optimal way to compute nCr mod N but rest assured, any of the zillion methods mentioned in the solutions (Pascal\\'s triangle etc.) would be almost as fast for this case.\\n\\nTo store greatest number lower than nums[i] and the smallest number greater than nums[i] we have to insert all elements in a set and use lower bound. x and y in the code have the same function they do in the intuition section.\\n# Complexity\\n- Time complexity: Should be O(n*(n + log(n))), but can\\'t be sure coz of nCr\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    const int N = 1e9 + 7;\\n    long long moduloMultiplication(long long val1, long long val2, long long mod){\\n        long long ans = 0;\\n        val1 %= mod;\\n        while (val2) {\\n            if (val2 & 1)\\n                ans = (ans + val1) % mod;\\n            val1 = (2 * val1) % mod;\\n            val2 = val2/2;\\n        }\\n        return ans;\\n    }\\n    long long modInverse(long long val2, long long mod){\\n        long long xx, yy; \\n        long long g = gcdExtended(val2, mod, &xx, &yy);\\n        if (g != 1)return -1;\\n        return (xx % mod + mod) % mod;\\n    }\\n    long long gcdExtended(long long val1, long long val2,long long* xx,long long* yy){\\n        if (val1 == 0) {\\n            *xx = 0, *yy = 1;\\n            return val2;\\n        }\\n        long long x1, y1;\\n        long long gcd = gcdExtended(val2 % val1, val1, &x1, &y1);\\n        *xx = y1 - (val2 / val1) * x1;\\n        *yy = x1;\\n        return gcd;\\n    }\\n    long long modDivide(long long val1, long long val2,long long mod){\\n        val1 = val1 % mod;\\n        long long inv = modInverse(val2, mod);\\n        if (inv == -1)\\n            return 0;\\n        else\\n            return (inv * val1) % mod;\\n    }\\n    int nCr(int n, int r, int x){\\n        if (r > n)\\n            return 0;\\n        if (r > n - r)\\n            r = n - r;\\n        long long ans = 1;\\n        for (int i = 1; i <= r; i++) {\\n            ans = moduloMultiplication(ans, (n + 1 - i), x);\\n            ans = modDivide(ans, i, x);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 1;\\n        set <int> s;\\n        s.insert(0); s.insert(n+1);\\n        for (int i = 0; i < n; i++){\\n            auto it = s.lower_bound(nums[i]);\\n            int y = *(it--), x = *it;\\n            //cout << i << \" \" << y-x-2 << \" \" << nums[i] - x - 1 << \" \" << nCr(y-x-2,nums[i]-x-1,N) << endl;\\n            ans = (ans * nCr(y-x-2, nums[i]-x-1, N))%N;\\n            s.insert(nums[i]);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    const int N = 1e9 + 7;\\n    long long moduloMultiplication(long long val1, long long val2, long long mod){\\n        long long ans = 0;\\n        val1 %= mod;\\n        while (val2) {\\n            if (val2 & 1)\\n                ans = (ans + val1) % mod;\\n            val1 = (2 * val1) % mod;\\n            val2 = val2/2;\\n        }\\n        return ans;\\n    }\\n    long long modInverse(long long val2, long long mod){\\n        long long xx, yy; \\n        long long g = gcdExtended(val2, mod, &xx, &yy);\\n        if (g != 1)return -1;\\n        return (xx % mod + mod) % mod;\\n    }\\n    long long gcdExtended(long long val1, long long val2,long long* xx,long long* yy){\\n        if (val1 == 0) {\\n            *xx = 0, *yy = 1;\\n            return val2;\\n        }\\n        long long x1, y1;\\n        long long gcd = gcdExtended(val2 % val1, val1, &x1, &y1);\\n        *xx = y1 - (val2 / val1) * x1;\\n        *yy = x1;\\n        return gcd;\\n    }\\n    long long modDivide(long long val1, long long val2,long long mod){\\n        val1 = val1 % mod;\\n        long long inv = modInverse(val2, mod);\\n        if (inv == -1)\\n            return 0;\\n        else\\n            return (inv * val1) % mod;\\n    }\\n    int nCr(int n, int r, int x){\\n        if (r > n)\\n            return 0;\\n        if (r > n - r)\\n            r = n - r;\\n        long long ans = 1;\\n        for (int i = 1; i <= r; i++) {\\n            ans = moduloMultiplication(ans, (n + 1 - i), x);\\n            ans = modDivide(ans, i, x);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 1;\\n        set <int> s;\\n        s.insert(0); s.insert(n+1);\\n        for (int i = 0; i < n; i++){\\n            auto it = s.lower_bound(nums[i]);\\n            int y = *(it--), x = *it;\\n            //cout << i << \" \" << y-x-2 << \" \" << nums[i] - x - 1 << \" \" << nCr(y-x-2,nums[i]-x-1,N) << endl;\\n            ans = (ans * nCr(y-x-2, nums[i]-x-1, N))%N;\\n            s.insert(nums[i]);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3742884,
                "title": "numofways",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int numOfWays(vector<int>& nums) {\\n    comb = generate(nums.size() + 1);\\n    return ways(nums) - 1;\\n  }\\n\\n private:\\n  static constexpr int kMod = 1\\'000\\'000\\'007;\\n  // comb[n][k] := C(n, k)\\n  vector<vector<int>> comb;\\n\\n  int ways(const vector<int>& nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    vector<int> left;\\n    vector<int> right;\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums[i] < nums[0])\\n        left.push_back(nums[i]);\\n      else\\n        right.push_back(nums[i]);\\n\\n    long ans = comb[nums.size() - 1][left.size()];\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  vector<vector<int>> generate(int numRows) {\\n    vector<vector<int>> comb;\\n\\n    for (int i = 0; i < numRows; ++i)\\n      comb.push_back(vector<int>(i + 1, 1));\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb[i].size() - 1; ++j)\\n        comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % kMod;\\n\\n    return comb;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int numOfWays(vector<int>& nums) {\\n    comb = generate(nums.size() + 1);\\n    return ways(nums) - 1;\\n  }\\n\\n private:\\n  static constexpr int kMod = 1\\'000\\'000\\'007;\\n  // comb[n][k] := C(n, k)\\n  vector<vector<int>> comb;\\n\\n  int ways(const vector<int>& nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    vector<int> left;\\n    vector<int> right;\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums[i] < nums[0])\\n        left.push_back(nums[i]);\\n      else\\n        right.push_back(nums[i]);\\n\\n    long ans = comb[nums.size() - 1][left.size()];\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  vector<vector<int>> generate(int numRows) {\\n    vector<vector<int>> comb;\\n\\n    for (int i = 0; i < numRows; ++i)\\n      comb.push_back(vector<int>(i + 1, 1));\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb[i].size() - 1; ++j)\\n        comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % kMod;\\n\\n    return comb;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725165,
                "title": "rust-easy-solution-no-binary-trees",
                "content": "# Approach\\n\\nDivide and conquer. The count of different inputs that result in the same BST must be related to that of its left subtree and that of its right subtree.\\n\\nSince subtrees are uninfluenced by their sibling\\'s construction, we can construct the same subtree by stripping away all elements from the input that goes to its sibling.\\n\\nFor a given input `vec`, the tree root is `vec[0]`. All values smaller than `vec[0]` goes to the left subtree, vice versa.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m^2 + n^2)$$ when the input array is monotonically increasing/decreasing.\\n\\n- Space complexity:\\n$$O(m^2 + n)$$\\n\\n# Code\\n```\\nconst MOD: usize = 1_000_000_007;\\n\\n// Pick `r` items from a total of `n`!\\npub struct nCr {\\n    n_max: usize,\\n    memo: Vec<Vec<usize>>,\\n}\\n\\nimpl nCr {\\n    pub fn new(n_max: usize) -> Self {\\n        let mut memo = vec![vec![0; n_max + 1]; n_max + 1];\\n        for n in 0..n_max { memo[n][0] = 1; }\\n\\n        for n in 1..n_max {\\n            for r in 1..=n {\\n                let mut ret = 0usize;\\n                ret += memo[n - 1][r - 1];\\n                ret += memo[n - 1][r];\\n                memo[n][r] = ret % MOD;\\n            }\\n        }\\n\\n        Self { n_max, memo }\\n    }\\n\\n    // Precomputed, O(1)\\n    pub fn solve(&self, n: usize, r: usize) -> usize {\\n        if n > self.n_max { return 0; }\\n        if r > self.n_max { return 0; }\\n\\n        self.memo[n][r]\\n    }\\n}\\n\\npub fn solve(vec: Vec<i32>, dp: &nCr) -> usize {\\n    if vec.is_empty() { return 1; }\\n\\n    // Get the input vec of two subtrees\\n    let root = vec[0];\\n    let (vec_l, vec_r): (Vec<_>, Vec<_>)\\n        = vec.into_iter().skip(1).partition(|&e| e < root);\\n\\n    let mut ret = dp.solve(\\n        vec_l.len() + vec_r.len(),\\n        vec_l.len().min(vec_r.len())\\n    );\\n\\n    // Recursively get counts for both subtrees\\n    ret *= solve(vec_l, dp);\\n    ret %= MOD;\\n    ret *= solve(vec_r, dp);\\n    ret %= MOD;\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn num_of_ways(vec: Vec<i32>) -> i32 {\\n        let dp = nCr::new(vec.len());\\n        (solve(vec, &dp) - 1) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Divide and Conquer",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nconst MOD: usize = 1_000_000_007;\\n\\n// Pick `r` items from a total of `n`!\\npub struct nCr {\\n    n_max: usize,\\n    memo: Vec<Vec<usize>>,\\n}\\n\\nimpl nCr {\\n    pub fn new(n_max: usize) -> Self {\\n        let mut memo = vec![vec![0; n_max + 1]; n_max + 1];\\n        for n in 0..n_max { memo[n][0] = 1; }\\n\\n        for n in 1..n_max {\\n            for r in 1..=n {\\n                let mut ret = 0usize;\\n                ret += memo[n - 1][r - 1];\\n                ret += memo[n - 1][r];\\n                memo[n][r] = ret % MOD;\\n            }\\n        }\\n\\n        Self { n_max, memo }\\n    }\\n\\n    // Precomputed, O(1)\\n    pub fn solve(&self, n: usize, r: usize) -> usize {\\n        if n > self.n_max { return 0; }\\n        if r > self.n_max { return 0; }\\n\\n        self.memo[n][r]\\n    }\\n}\\n\\npub fn solve(vec: Vec<i32>, dp: &nCr) -> usize {\\n    if vec.is_empty() { return 1; }\\n\\n    // Get the input vec of two subtrees\\n    let root = vec[0];\\n    let (vec_l, vec_r): (Vec<_>, Vec<_>)\\n        = vec.into_iter().skip(1).partition(|&e| e < root);\\n\\n    let mut ret = dp.solve(\\n        vec_l.len() + vec_r.len(),\\n        vec_l.len().min(vec_r.len())\\n    );\\n\\n    // Recursively get counts for both subtrees\\n    ret *= solve(vec_l, dp);\\n    ret %= MOD;\\n    ret *= solve(vec_r, dp);\\n    ret %= MOD;\\n\\n    ret\\n}\\n\\nimpl Solution {\\n    pub fn num_of_ways(vec: Vec<i32>) -> i32 {\\n        let dp = nCr::new(vec.len());\\n        (solve(vec, &dp) - 1) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3715400,
                "title": "python-time-o-n-2-98-89-space-o-n-99-20",
                "content": "# Intuition\\nDisclaimer: I failed solving this on my own. This solution was made after reading the intuition for the following solution: https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/solutions/839559/o-n-simple-fast/ My implementation is slightly different, though.\\n\\nInstead of adding nodes, we delete from the back of the given array. Each time we delete, we find the size of the current subtree deleted (which may include previously deleted subtrees as its children) and multiply it to an `product` variable. We obtain our final answer with `(len(nums)! // product) - 1`. \\n\\n`len(nums)!` is obviously the max number of ways to permutate the given array. But since the root of a subtree is always fixed, we should only count the number of permutations with that specific root being the first element. This is equivalent to dividing the factorial of the subtree size by the size of the subtree. We need to do this division for all subtrees in the given tree. And that is what the `product` variable is for - the divisor.\\n\\n\\n# Approach\\nIterating from the back of the array, We get a node\\'s children subtrees by querying the node\\'s value `+1` and `-1` to see if they have already been visited and hence existing as a key in a dict. Fusing the children\\'s subtrees with the current node\\'s value creates the list of the current subtree with the current node as the subtree root. We then store this list in the dict and have every node be pointing to it within that dict to show that they are part of this visited subtree. Pointing instead of copying is the saving grace for both time and space. \\n\\n# Complexity\\n- Time complexity: O(n^2). 2 For-loops through all nodes\\n\\n- Space complexity: O(2n) due to having to recreate the list within the dict at most 2 times = O(n) \\n\\n# Code\\n```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n      n = len(nums)\\n      mod = 10**9 + 7\\n      product = 1\\n      deleted = defaultdict(list)\\n\\n      for i in range(n-1, -1, -1): # removing nodes from the back of nums\\n        curr = nums[i] # to delete\\n        # represent nodes in current subtree using list\\n\\n        # fuse all nodes of curr substree to 1 list \\n        # and have all pointers pointing to it\\n        fused = deleted[curr + 1] + deleted[curr - 1] + [curr]\\n        for j in fused:\\n          deleted[j] = fused\\n        \\n        product *= len(deleted[curr])\\n      \\n      for i in range(2, n): # for len(nums)!\\n        n *= i\\n      \\n      ans = n // product - 1 # -1 for removing current permutation\\n      return ans % mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n      n = len(nums)\\n      mod = 10**9 + 7\\n      product = 1\\n      deleted = defaultdict(list)\\n\\n      for i in range(n-1, -1, -1): # removing nodes from the back of nums\\n        curr = nums[i] # to delete\\n        # represent nodes in current subtree using list\\n\\n        # fuse all nodes of curr substree to 1 list \\n        # and have all pointers pointing to it\\n        fused = deleted[curr + 1] + deleted[curr - 1] + [curr]\\n        for j in fused:\\n          deleted[j] = fused\\n        \\n        product *= len(deleted[curr])\\n      \\n      for i in range(2, n): # for len(nums)!\\n        n *= i\\n      \\n      ans = n // product - 1 # -1 for removing current permutation\\n      return ans % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714672,
                "title": "simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    const int mod = 1e9+7;\\n    #define ll long long\\n    ll power(ll a,ll b){\\n        if(b<=0){\\n            return 1;\\n        }\\n        a = a%mod;\\n        ll ans=1;\\n        while(b){\\n            if(b%2==1){\\n                ans = ans*1LL*a;\\n                ans = ans%mod;\\n            }\\n            a = (a*1LL*a)%mod;\\n            b = (b>>1);\\n        }\\n        return ans%mod;\\n    }\\n\\n    ll fact[1001];\\n    void pre(){\\n        fact[0]=1;\\n        for(int i=1;i<1001;i++){\\n            fact[i] = (fact[i-1]*1LL*i)%mod;\\n        }\\n    }\\n\\n    ll ncr(ll n, ll r){\\n        if(r>=n){\\n            return 1;\\n        }\\n        ll nu = fact[n]%mod;\\n        ll de = power((fact[r]*1LL*fact[n-r])%mod,mod-2)%mod;\\n        nu  = (nu*1LL*de)%mod;\\n        return nu;\\n    }\\n\\n    int cal(vector<int> &v,ll &ans){\\n        if(v.size()<=0){\\n            return 0;\\n        }\\n        int node = v[0];\\n        vector<int> left,right;\\n        for(int j=1;j<v.size();j++){\\n            if(v[j]>node){\\n                right.push_back(v[j]);\\n            }\\n            else{\\n                left.push_back(v[j]);\\n            }\\n        }\\n        int l = cal(left,ans);\\n        int r = cal(right,ans);\\n        ans = (ans*1LL*(ncr(l+r,l)))%mod;\\n        // cout<<ans<<\\n        return l+r+1;\\n    }\\n\\n\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        pre();\\n        ll ans=1;\\n        // int i=0;\\n        cal(nums,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Divide and Conquer",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    const int mod = 1e9+7;\\n    #define ll long long\\n    ll power(ll a,ll b){\\n        if(b<=0){\\n            return 1;\\n        }\\n        a = a%mod;\\n        ll ans=1;\\n        while(b){\\n            if(b%2==1){\\n                ans = ans*1LL*a;\\n                ans = ans%mod;\\n            }\\n            a = (a*1LL*a)%mod;\\n            b = (b>>1);\\n        }\\n        return ans%mod;\\n    }\\n\\n    ll fact[1001];\\n    void pre(){\\n        fact[0]=1;\\n        for(int i=1;i<1001;i++){\\n            fact[i] = (fact[i-1]*1LL*i)%mod;\\n        }\\n    }\\n\\n    ll ncr(ll n, ll r){\\n        if(r>=n){\\n            return 1;\\n        }\\n        ll nu = fact[n]%mod;\\n        ll de = power((fact[r]*1LL*fact[n-r])%mod,mod-2)%mod;\\n        nu  = (nu*1LL*de)%mod;\\n        return nu;\\n    }\\n\\n    int cal(vector<int> &v,ll &ans){\\n        if(v.size()<=0){\\n            return 0;\\n        }\\n        int node = v[0];\\n        vector<int> left,right;\\n        for(int j=1;j<v.size();j++){\\n            if(v[j]>node){\\n                right.push_back(v[j]);\\n            }\\n            else{\\n                left.push_back(v[j]);\\n            }\\n        }\\n        int l = cal(left,ans);\\n        int r = cal(right,ans);\\n        ans = (ans*1LL*(ncr(l+r,l)))%mod;\\n        // cout<<ans<<\\n        return l+r+1;\\n    }\\n\\n\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        pre();\\n        ll ans=1;\\n        // int i=0;\\n        cal(nums,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3697644,
                "title": "c-soln-using-binomial-coefficients",
                "content": "# Complexity\\n- Time complexity: $$O(m^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    // using pascal triangle to store the binomial coefficent\\n    // m-1\\n    //    C\\n    //     left.size() \\n    vector<vector<long long>> pascal;\\n    long long mod = 1e9 + 7;\\n    long long dfs(vector<int> &nums) {\\n        int m = nums.size();\\n        if (m<3) return 1; // base case for bst with 0, 1 or 2 nodes\\n        vector<int> left, right;\\n        for (int i=1; i<m; i++) {\\n            // constructing right and left subtrees for bst with root as nums[0]\\n            if (nums[i] < nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        long long waysinleft = dfs(left)%mod;\\n        long long waysinright = dfs(right)%mod;\\n        // m-1 C left.size() to get binomial coefficient\\n        return (((waysinleft*waysinright)%mod)*pascal[m-1][left.size()])%mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int m = nums.size();\\n        pascal.resize(m+1);\\n        // constructing the pascals triangle since we will be using its binomial coeff.\\n        for (int i=0; i<=m; i++) {\\n            //both of the following statements do the same operation !\\n            //pascal[i] = vector<long long> (i+1, 1); \\n            pascal[i].resize(i+1, 1);\\n            for (int j=1; j<i; j++) {\\n                pascal[i][j] = (pascal[i-1][j-1] + pascal[i-1][j])%mod;\\n            }\\n        }\\n        return (dfs(nums) - 1)%mod; // no idea why we subract 1 :(\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Combinatorics",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // using pascal triangle to store the binomial coefficent\\n    // m-1\\n    //    C\\n    //     left.size() \\n    vector<vector<long long>> pascal;\\n    long long mod = 1e9 + 7;\\n    long long dfs(vector<int> &nums) {\\n        int m = nums.size();\\n        if (m<3) return 1; // base case for bst with 0, 1 or 2 nodes\\n        vector<int> left, right;\\n        for (int i=1; i<m; i++) {\\n            // constructing right and left subtrees for bst with root as nums[0]\\n            if (nums[i] < nums[0]) left.push_back(nums[i]);\\n            else right.push_back(nums[i]);\\n        }\\n        long long waysinleft = dfs(left)%mod;\\n        long long waysinright = dfs(right)%mod;\\n        // m-1 C left.size() to get binomial coefficient\\n        return (((waysinleft*waysinright)%mod)*pascal[m-1][left.size()])%mod;\\n    }\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int m = nums.size();\\n        pascal.resize(m+1);\\n        // constructing the pascals triangle since we will be using its binomial coeff.\\n        for (int i=0; i<=m; i++) {\\n            //both of the following statements do the same operation !\\n            //pascal[i] = vector<long long> (i+1, 1); \\n            pascal[i].resize(i+1, 1);\\n            for (int j=1; j<i; j++) {\\n                pascal[i][j] = (pascal[i-1][j-1] + pascal[i-1][j])%mod;\\n            }\\n        }\\n        return (dfs(nums) - 1)%mod; // no idea why we subract 1 :(\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695491,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def __init__(self):\\n        self.mod = 10 ** 9 + 7\\n\\n    def fact(self, n):\\n        if n == 1 or n == 0:\\n            return 1\\n        return n*self.fact(n-1)\\n\\n    def func(self, nums):\\n\\n        #func(nums) returns the number of order to get the same tree as we insert elements in the order of nums, so func(nums)-1 == numOfWays(nums)\\n        \\n        #base case\\n        if len(nums) == 0 or len(nums) == 1:\\n            return 1 \\n        \\n        leftTreeNodes = []\\n        rightTreeNodes = []\\n        for num in nums[1:]:\\n            if num < nums[0]:\\n                leftTreeNodes.append(num)\\n            else:\\n                rightTreeNodes.append(num)\\n        #the left subtree will be constructed by inserting element in the order of leftTreeNodes\\n        # we can know how many ways to get the same left tree by change the order\\n        # for the left, the num of ways should be func(leftTreeNodes)\\n        res = self.func(leftTreeNodes)*self.func(rightTreeNodes)\\n        #in the meanwhile ,the relative order of the node in the left and the node in the right doesn\\'t matter at all, so after the order of the left tree and the right tree is decided, the left nodes and rights node can change their relative order\\n        res *= comb(len(nums)-1, len(leftTreeNodes))\\n        # if I calculate the fact by my self, the number could be too large and induce error\\n        # res *= self.fact(len(nums)-1)/self.fact(len(leftTreeNodes))/self.fact(len(rightTreeNodes)) \\n\\n        return int(res) % self.mod\\n\\n    def numOfWays(self, nums: List[int]) -> int:\\n        mod = 10 ** 9 + 7 \\n        return (self.func(nums)-1) % self.mod\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def __init__(self):\\n        self.mod = 10 ** 9 + 7\\n\\n    def fact(self, n):\\n        if n == 1 or n == 0:\\n            return 1\\n        return n*self.fact(n-1)\\n\\n    def func(self, nums):\\n\\n        #func(nums) returns the number of order to get the same tree as we insert elements in the order of nums, so func(nums)-1 == numOfWays(nums)\\n        \\n        #base case\\n        if len(nums) == 0 or len(nums) == 1:\\n            return 1 \\n        \\n        leftTreeNodes = []\\n        rightTreeNodes = []\\n        for num in nums[1:]:\\n            if num < nums[0]:\\n                leftTreeNodes.append(num)\\n            else:\\n                rightTreeNodes.append(num)\\n        #the left subtree will be constructed by inserting element in the order of leftTreeNodes\\n        # we can know how many ways to get the same left tree by change the order\\n        # for the left, the num of ways should be func(leftTreeNodes)\\n        res = self.func(leftTreeNodes)*self.func(rightTreeNodes)\\n        #in the meanwhile ,the relative order of the node in the left and the node in the right doesn\\'t matter at all, so after the order of the left tree and the right tree is decided, the left nodes and rights node can change their relative order\\n        res *= comb(len(nums)-1, len(leftTreeNodes))\\n        # if I calculate the fact by my self, the number could be too large and induce error\\n        # res *= self.fact(len(nums)-1)/self.fact(len(leftTreeNodes))/self.fact(len(rightTreeNodes)) \\n\\n        return int(res) % self.mod\\n\\n    def numOfWays(self, nums: List[int]) -> int:\\n        mod = 10 ** 9 + 7 \\n        return (self.func(nums)-1) % self.mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679295,
                "title": "java-preorder-dfs-beats-84-solutions-beautiful-easy-to-understand-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    long mod = (long) 1e9 + 7;\\n    long nCr[][];\\n\\n    public void computeCombinations(int m) {\\n        // Pascal Triangle table\\n        nCr = new long[m][m];\\n\\n        for (int i = 0; i < m; i++){\\n            nCr[i][0] = 1;\\n            nCr[0][i] = 1;\\n            nCr[i][i] = 1;\\n        }\\n\\n        for (int n = 2; n < m; n++) {\\n            for (int r = 1; r < n; r++) {\\n                nCr[n][r] = (nCr[n - 1][r] + nCr[n - 1][r - 1]) % mod;\\n            }\\n        }\\n    }\\n\\n    public long numOfWaysUtil(ArrayList<Integer> nodes) {\\n        int n = nodes.size();\\n        if (n == 0 || n == 1 || n == 2)\\n        return 1;\\n\\n        int root = nodes.get(0);\\n\\n        ArrayList<Integer> leftST = new ArrayList<>();\\n        ArrayList<Integer> rightST = new ArrayList<>();\\n\\n        for (int i = 1; i < n; i++) {\\n            int node = nodes.get(i);\\n            if (node > root){\\n                rightST.add(node);\\n            }\\n            else {\\n                leftST.add(node);\\n            }\\n        }\\n\\n        long numOfLeftSTRelativeCombinations = numOfWaysUtil(leftST);\\n        long numOfRightSTRelativeCombinations = numOfWaysUtil(rightST);\\n\\n        long numOfLeftRightSTRelativeCombinations =\\n        (long) (numOfLeftSTRelativeCombinations * numOfRightSTRelativeCombinations) % mod;\\n\\n\\n        int numOfNodesInLeftST = leftST.size();\\n        int numOfNodesInRightST = rightST.size();\\n\\n        int totPlacesToBeChosen = n - 1;\\n\\n        return (int) (((long)\\n        nCr[totPlacesToBeChosen][numOfNodesInLeftST] * numOfLeftRightSTRelativeCombinations) % mod);\\n    }\\n\\n    public int numOfWays(int[] nums) { \\n        int n = nums.length;\\n        computeCombinations(n);\\n\\n        ArrayList<Integer> numsVarList = new ArrayList<>(n);\\n        for(int i = 0; i < n; i++)\\n        numsVarList.add(nums[i]);\\n\\n        return (int) numOfWaysUtil(numsVarList) - 1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    long mod = (long) 1e9 + 7;\\n    long nCr[][];\\n\\n    public void computeCombinations(int m) {\\n        // Pascal Triangle table\\n        nCr = new long[m][m];\\n\\n        for (int i = 0; i < m; i++){\\n            nCr[i][0] = 1;\\n            nCr[0][i] = 1;\\n            nCr[i][i] = 1;\\n        }\\n\\n        for (int n = 2; n < m; n++) {\\n            for (int r = 1; r < n; r++) {\\n                nCr[n][r] = (nCr[n - 1][r] + nCr[n - 1][r - 1]) % mod;\\n            }\\n        }\\n    }\\n\\n    public long numOfWaysUtil(ArrayList<Integer> nodes) {\\n        int n = nodes.size();\\n        if (n == 0 || n == 1 || n == 2)\\n        return 1;\\n\\n        int root = nodes.get(0);\\n\\n        ArrayList<Integer> leftST = new ArrayList<>();\\n        ArrayList<Integer> rightST = new ArrayList<>();\\n\\n        for (int i = 1; i < n; i++) {\\n            int node = nodes.get(i);\\n            if (node > root){\\n                rightST.add(node);\\n            }\\n            else {\\n                leftST.add(node);\\n            }\\n        }\\n\\n        long numOfLeftSTRelativeCombinations = numOfWaysUtil(leftST);\\n        long numOfRightSTRelativeCombinations = numOfWaysUtil(rightST);\\n\\n        long numOfLeftRightSTRelativeCombinations =\\n        (long) (numOfLeftSTRelativeCombinations * numOfRightSTRelativeCombinations) % mod;\\n\\n\\n        int numOfNodesInLeftST = leftST.size();\\n        int numOfNodesInRightST = rightST.size();\\n\\n        int totPlacesToBeChosen = n - 1;\\n\\n        return (int) (((long)\\n        nCr[totPlacesToBeChosen][numOfNodesInLeftST] * numOfLeftRightSTRelativeCombinations) % mod);\\n    }\\n\\n    public int numOfWays(int[] nums) { \\n        int n = nums.length;\\n        computeCombinations(n);\\n\\n        ArrayList<Integer> numsVarList = new ArrayList<>(n);\\n        for(int i = 0; i < n; i++)\\n        numsVarList.add(nums[i]);\\n\\n        return (int) numOfWaysUtil(numsVarList) - 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674950,
                "title": "fast-solution-11ms-pascal-s-triangle-combinations-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHi. Intuition is to construct array with numbers which are less than root number, and array with numbers that are greater. Then we recusively pass this two arrays to function which calculates number of ways for each array. In recusive method we just find the number of permutations using Pascal\\'s triangle\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Construct 2 arrays with numbers in one array greater than array, in another array less.\\n\\n2) Find Combinations using pascal\\'s triangle multiple by return of same method but with array with smaller numbers, and again multiple by return of same method with array which have numbers greater than root value\\n3) At each step MOD by 1000000007, so that result avoids overflow.\\n4) Return value decremented by 1;\\n\\nHere is my video solution. \\nhttps://youtu.be/FMfLFWdNStY\\n\\nThank you. PLease upvote.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) \\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) stack of recursive calls\\n\\n# Code\\n```\\nclass Solution {\\n    static int[][] combinations = fillCombinations();\\n    static final int MOD = 1000000007;\\n\\n    public int numOfWays(int[] nums) {\\n        int answer = ways(nums)%MOD;\\n        answer--;\\n        return answer;\\n    }\\n\\n    public int ways(int[] nums) {\\n        int size = nums.length;\\n        if(size==0) {\\n            return 1;\\n        }\\n        int count = 0;\\n        int target = nums[0];\\n        for(int i=0; i<size; i++) {\\n            if(nums[i]<target) {\\n                count++;\\n            }\\n        }\\n        int[] less = new int[count];\\n        count = 0;\\n        for(int i=0; i<size; i++) {\\n            if(nums[i]<target) {\\n                less[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        count = 0;\\n        for(int i=0; i<size; i++) {\\n            if(nums[i]>target) {\\n                count++;\\n            }\\n        }\\n        int[] greater = new int[count];\\n        count = 0;\\n        for(int i=0; i<size; i++) {\\n            if(nums[i]>target) {\\n                greater[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        long m1 = (long)combinations[size-1][less.length] * (long)ways(less);\\n        m1 = m1 %((long)MOD);\\n        long m2 = m1 * (long)ways(greater);\\n        m2 = m2 % (long)MOD;\\n        int result = (int)m2 % MOD;\\n        return result;\\n    }\\n\\n    public static int[][] fillCombinations() {\\n        int N = 1001;\\n        int [][] arr = new int[N][N];\\n        arr[0][0] = 1;\\n        for(int i=1; i<N; i++) {\\n            for(int j=0; j<=i; j++) {\\n                int prev1 = 0;\\n                if(i-1>=0 && j-1>=0) {\\n                    prev1 = arr[i-1][j-1] % MOD;\\n                }\\n                int prev2 = 0;\\n                if(i-1>=0) {\\n                    prev2 = arr[i-1][j] % MOD;\\n                } \\n                arr[i][j] = (prev1 + prev2) % MOD;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Divide and Conquer",
                    "Recursion",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n    static int[][] combinations = fillCombinations();\\n    static final int MOD = 1000000007;\\n\\n    public int numOfWays(int[] nums) {\\n        int answer = ways(nums)%MOD;\\n        answer--;\\n        return answer;\\n    }\\n\\n    public int ways(int[] nums) {\\n        int size = nums.length;\\n        if(size==0) {\\n            return 1;\\n        }\\n        int count = 0;\\n        int target = nums[0];\\n        for(int i=0; i<size; i++) {\\n            if(nums[i]<target) {\\n                count++;\\n            }\\n        }\\n        int[] less = new int[count];\\n        count = 0;\\n        for(int i=0; i<size; i++) {\\n            if(nums[i]<target) {\\n                less[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        count = 0;\\n        for(int i=0; i<size; i++) {\\n            if(nums[i]>target) {\\n                count++;\\n            }\\n        }\\n        int[] greater = new int[count];\\n        count = 0;\\n        for(int i=0; i<size; i++) {\\n            if(nums[i]>target) {\\n                greater[count] = nums[i];\\n                count++;\\n            }\\n        }\\n        long m1 = (long)combinations[size-1][less.length] * (long)ways(less);\\n        m1 = m1 %((long)MOD);\\n        long m2 = m1 * (long)ways(greater);\\n        m2 = m2 % (long)MOD;\\n        int result = (int)m2 % MOD;\\n        return result;\\n    }\\n\\n    public static int[][] fillCombinations() {\\n        int N = 1001;\\n        int [][] arr = new int[N][N];\\n        arr[0][0] = 1;\\n        for(int i=1; i<N; i++) {\\n            for(int j=0; j<=i; j++) {\\n                int prev1 = 0;\\n                if(i-1>=0 && j-1>=0) {\\n                    prev1 = arr[i-1][j-1] % MOD;\\n                }\\n                int prev2 = 0;\\n                if(i-1>=0) {\\n                    prev2 = arr[i-1][j] % MOD;\\n                } \\n                arr[i][j] = (prev1 + prev2) % MOD;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671754,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\nvector<vector<long long>>tab; \\nlong long dfs(vector<int>&nums,long long mod) \\n{\\n    int n=nums.size(); \\n    if(n<=2) return 1; \\n    vector<int>left,right; \\n    for(int i=1;i<n;++i) \\n    {\\n        if(nums[i]<nums[0]) \\n        left.push_back(nums[i]); \\n        else \\n        right.push_back(nums[i]);\\n    } \\n    long long left_res=dfs(left,mod)%mod;  \\n    long long right_res=dfs(right,mod)%mod;  \\n    int left_len=left.size(),right_len=right.size(); \\n    return (((tab[n-1][left_len]*left_res)%mod)*right_res)%mod;  \\n\\n\\n}\\n    int numOfWays(vector<int>& nums) {\\n        long long mod=1e9+7; \\n        int n=nums.size(); \\n        tab.resize(n+1); \\n        for(int i=0;i<n+1;++i) \\n        {\\n            tab[i]=vector<long long>(i+1,1); \\n            for(int j=1;j<i;++j) \\n            {\\n                tab[i][j]=(tab[i-1][j-1]+tab[i-1][j])%mod;\\n            }\\n        } \\n        long long ans=dfs(nums,mod); \\n        return (ans%mod -1)%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\nvector<vector<long long>>tab; \\nlong long dfs(vector<int>&nums,long long mod) \\n{\\n    int n=nums.size(); \\n    if(n<=2) return 1; \\n    vector<int>left,right; \\n    for(int i=1;i<n;++i) \\n    {\\n        if(nums[i]<nums[0]) \\n        left.push_back(nums[i]); \\n        else \\n        right.push_back(nums[i]);\\n    } \\n    long long left_res=dfs(left,mod)%mod;  \\n    long long right_res=dfs(right,mod)%mod;  \\n    int left_len=left.size(),right_len=right.size(); \\n    return (((tab[n-1][left_len]*left_res)%mod)*right_res)%mod;  \\n\\n\\n}\\n    int numOfWays(vector<int>& nums) {\\n        long long mod=1e9+7; \\n        int n=nums.size(); \\n        tab.resize(n+1); \\n        for(int i=0;i<n+1;++i) \\n        {\\n            tab[i]=vector<long long>(i+1,1); \\n            for(int j=1;j<i;++j) \\n            {\\n                tab[i][j]=(tab[i-1][j-1]+tab[i-1][j])%mod;\\n            }\\n        } \\n        long long ans=dfs(nums,mod); \\n        return (ans%mod -1)%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664864,
                "title": "beats-95-in-both-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint mod = 1000000007;\\n\\nconst int MOD = 1e9 + 7;\\n\\nint inverse(int a, int m)\\n{\\n    int m0 = m, t, q;\\n    int x0 = 0, x1 = 1;\\n    if (m == 1)\\n        return 0;\\n    while (a > 1) {\\n        q = a / m;\\n        t = m;\\n        m = a % m, a = t;\\n        t = x0;\\n        x0 = x1 - q * x0;\\n        x1 = t;\\n    }\\n    if (x1 < 0)\\n        x1 += m0;\\n    return x1;\\n}\\n\\nint binomialCoeff(int n, int k)\\n{\\n    long long res = 1;\\n    if (k > n - k)\\n        k = n - k;\\n    for (int i = 0; i < k; ++i)\\n    {\\n        res = (res * (n - i)) % MOD;\\n        res = (res * inverse(i + 1, MOD)) % MOD;\\n    }\\n    return (int)res;\\n}\\n\\n\\n\\nint mul(int a, int b, int c)\\n{\\n    long long res = (long long)a * b % MOD;\\n    res = res * c % MOD;\\n    return (int)res;\\n}\\n\\nint calculate(int m , int n){\\n\\n    int a = max(m,n);\\n    int b = min(m,n);\\n\\n    int num = 1;\\n    int den = 1;\\n\\n    for(int i = 1 ; i <= b ; i++) {\\n\\n        num *= a+i;\\n        den *= i;\\n    }\\n\\n    return num/den ;\\n}\\n\\nint solve(vector<int>& nums , int n){\\n\\n    // base case\\n\\n    if( n <= 2) return 1;\\n\\n    vector<int>small;\\n    vector<int>large;\\n\\n    int root = nums[0];\\n\\n    for(int i = 1 ; i < n ; i++){\\n\\n        if( nums[i] < root) small.push_back(nums[i]);\\n\\n        else large.push_back(nums[i]);\\n    }\\n\\n    int left_per = solve(small , small.size());\\n    int right_per = solve(large , large.size());\\n\\n    int m_n = small.size()+large.size();\\n    int m = large.size();\\n\\n\\n    return mul(binomialCoeff(m_n , m) ,left_per,right_per);\\n\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n\\n        return solve(nums , nums.size())-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint mod = 1000000007;\\n\\nconst int MOD = 1e9 + 7;\\n\\nint inverse(int a, int m)\\n{\\n    int m0 = m, t, q;\\n    int x0 = 0, x1 = 1;\\n    if (m == 1)\\n        return 0;\\n    while (a > 1) {\\n        q = a / m;\\n        t = m;\\n        m = a % m, a = t;\\n        t = x0;\\n        x0 = x1 - q * x0;\\n        x1 = t;\\n    }\\n    if (x1 < 0)\\n        x1 += m0;\\n    return x1;\\n}\\n\\nint binomialCoeff(int n, int k)\\n{\\n    long long res = 1;\\n    if (k > n - k)\\n        k = n - k;\\n    for (int i = 0; i < k; ++i)\\n    {\\n        res = (res * (n - i)) % MOD;\\n        res = (res * inverse(i + 1, MOD)) % MOD;\\n    }\\n    return (int)res;\\n}\\n\\n\\n\\nint mul(int a, int b, int c)\\n{\\n    long long res = (long long)a * b % MOD;\\n    res = res * c % MOD;\\n    return (int)res;\\n}\\n\\nint calculate(int m , int n){\\n\\n    int a = max(m,n);\\n    int b = min(m,n);\\n\\n    int num = 1;\\n    int den = 1;\\n\\n    for(int i = 1 ; i <= b ; i++) {\\n\\n        num *= a+i;\\n        den *= i;\\n    }\\n\\n    return num/den ;\\n}\\n\\nint solve(vector<int>& nums , int n){\\n\\n    // base case\\n\\n    if( n <= 2) return 1;\\n\\n    vector<int>small;\\n    vector<int>large;\\n\\n    int root = nums[0];\\n\\n    for(int i = 1 ; i < n ; i++){\\n\\n        if( nums[i] < root) small.push_back(nums[i]);\\n\\n        else large.push_back(nums[i]);\\n    }\\n\\n    int left_per = solve(small , small.size());\\n    int right_per = solve(large , large.size());\\n\\n    int m_n = small.size()+large.size();\\n    int m = large.size();\\n\\n\\n    return mul(binomialCoeff(m_n , m) ,left_per,right_per);\\n\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n\\n        return solve(nums , nums.size())-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664173,
                "title": "beats-95-in-both-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint mod = 1000000007;\\n\\nconst int MOD = 1e9 + 7;\\n\\nint inverse(int a, int m)\\n{\\n    int m0 = m, t, q;\\n    int x0 = 0, x1 = 1;\\n    if (m == 1)\\n        return 0;\\n    while (a > 1) {\\n        q = a / m;\\n        t = m;\\n        m = a % m, a = t;\\n        t = x0;\\n        x0 = x1 - q * x0;\\n        x1 = t;\\n    }\\n    if (x1 < 0)\\n        x1 += m0;\\n    return x1;\\n}\\n\\nint binomialCoeff(int n, int k)\\n{\\n    long long res = 1;\\n    if (k > n - k)\\n        k = n - k;\\n    for (int i = 0; i < k; ++i)\\n    {\\n        res = (res * (n - i)) % MOD;\\n        res = (res * inverse(i + 1, MOD)) % MOD;\\n    }\\n    return (int)res;\\n}\\n\\n\\n\\nint mul(int a, int b, int c)\\n{\\n    long long res = (long long)a * b % MOD;\\n    res = res * c % MOD;\\n    return (int)res;\\n}\\n\\nint calculate(int m , int n){\\n\\n    int a = max(m,n);\\n    int b = min(m,n);\\n\\n    int num = 1;\\n    int den = 1;\\n\\n    for(int i = 1 ; i <= b ; i++) {\\n\\n        num *= a+i;\\n        den *= i;\\n    }\\n\\n    return num/den ;\\n}\\n\\nint solve(vector<int>& nums , int n){\\n\\n    // base case\\n\\n    if( n <= 2) return 1;\\n\\n    vector<int>small;\\n    vector<int>large;\\n\\n    int root = nums[0];\\n\\n    for(int i = 1 ; i < n ; i++){\\n\\n        if( nums[i] < root) small.push_back(nums[i]);\\n\\n        else large.push_back(nums[i]);\\n    }\\n\\n    int left_per = solve(small , small.size());\\n    int right_per = solve(large , large.size());\\n\\n    int m_n = small.size()+large.size();\\n    int m = large.size();\\n\\n\\n    return mul(binomialCoeff(m_n , m) ,left_per,right_per);\\n\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n\\n        return solve(nums , nums.size())-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint mod = 1000000007;\\n\\nconst int MOD = 1e9 + 7;\\n\\nint inverse(int a, int m)\\n{\\n    int m0 = m, t, q;\\n    int x0 = 0, x1 = 1;\\n    if (m == 1)\\n        return 0;\\n    while (a > 1) {\\n        q = a / m;\\n        t = m;\\n        m = a % m, a = t;\\n        t = x0;\\n        x0 = x1 - q * x0;\\n        x1 = t;\\n    }\\n    if (x1 < 0)\\n        x1 += m0;\\n    return x1;\\n}\\n\\nint binomialCoeff(int n, int k)\\n{\\n    long long res = 1;\\n    if (k > n - k)\\n        k = n - k;\\n    for (int i = 0; i < k; ++i)\\n    {\\n        res = (res * (n - i)) % MOD;\\n        res = (res * inverse(i + 1, MOD)) % MOD;\\n    }\\n    return (int)res;\\n}\\n\\n\\n\\nint mul(int a, int b, int c)\\n{\\n    long long res = (long long)a * b % MOD;\\n    res = res * c % MOD;\\n    return (int)res;\\n}\\n\\nint calculate(int m , int n){\\n\\n    int a = max(m,n);\\n    int b = min(m,n);\\n\\n    int num = 1;\\n    int den = 1;\\n\\n    for(int i = 1 ; i <= b ; i++) {\\n\\n        num *= a+i;\\n        den *= i;\\n    }\\n\\n    return num/den ;\\n}\\n\\nint solve(vector<int>& nums , int n){\\n\\n    // base case\\n\\n    if( n <= 2) return 1;\\n\\n    vector<int>small;\\n    vector<int>large;\\n\\n    int root = nums[0];\\n\\n    for(int i = 1 ; i < n ; i++){\\n\\n        if( nums[i] < root) small.push_back(nums[i]);\\n\\n        else large.push_back(nums[i]);\\n    }\\n\\n    int left_per = solve(small , small.size());\\n    int right_per = solve(large , large.size());\\n\\n    int m_n = small.size()+large.size();\\n    int m = large.size();\\n\\n\\n    return mul(binomialCoeff(m_n , m) ,left_per,right_per);\\n\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n\\n        return solve(nums , nums.size())-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660059,
                "title": "elixir-recursive-solution",
                "content": "# Intuition\\n- The first number in `nums` always is the root.\\n- For all permutations of the descendants of `root`, if the order of the numbers less than the root keeps the same as they are in `nums`, and so is the order of the numbers greater than the root, then the BST keeps the same.\\n- The number of permutations that keeps the orders of both lesser and greater numbers is just $$\\\\begin{pmatrix} n \\\\\\\\ m \\\\end{pmatrix}$$ where $$n$$ is the total number of descendants and $$m$$ is the number of the descendants less than the root.\\n- Recursively find the number of permutations in the left and right subtrees, and multiply them together.\\n\\n# Time Complexity\\n$$O(n^2)$$\\n\\n# Space Complexity\\n$$O(n^2)$$\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec num_of_ways(nums :: [integer]) :: integer\\n  def num_of_ways(nums) do\\n    calc(nums) - 1\\n  end\\n\\n  @modulus 1_000_000_007\\n\\n  defp calc([]), do: 1\\n\\n  defp calc([h | t]) do\\n    {lesser, greater} = Enum.split_with(t, & &1 < h)\\n\\n    combinations(length(t), length(lesser))\\n    |> rem(@modulus)\\n    |> Kernel.*(calc(lesser))\\n    |> rem(@modulus)\\n    |> Kernel.*(calc(greater))\\n    |> rem(@modulus)\\n  end\\n\\n  defp combinations(_n, 0), do: 1\\n\\n  defp combinations(n, n), do: 1\\n\\n  defp combinations(n, m) do\\n    div(Enum.product(m+1..n), Enum.product(1..n-m))\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec num_of_ways(nums :: [integer]) :: integer\\n  def num_of_ways(nums) do\\n    calc(nums) - 1\\n  end\\n\\n  @modulus 1_000_000_007\\n\\n  defp calc([]), do: 1\\n\\n  defp calc([h | t]) do\\n    {lesser, greater} = Enum.split_with(t, & &1 < h)\\n\\n    combinations(length(t), length(lesser))\\n    |> rem(@modulus)\\n    |> Kernel.*(calc(lesser))\\n    |> rem(@modulus)\\n    |> Kernel.*(calc(greater))\\n    |> rem(@modulus)\\n  end\\n\\n  defp combinations(_n, 0), do: 1\\n\\n  defp combinations(n, n), do: 1\\n\\n  defp combinations(n, m) do\\n    div(Enum.product(m+1..n), Enum.product(1..n-m))\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3657339,
                "title": "counting-ways-to-reorder-an-array-for-identical-binary-search-trees",
                "content": "# Intuition\\nTo solve this problem, we can use a recursive approach. We start with the given array `nums` and recursively count the number of ways to reorder the array such that the resulting binary search tree (BST) is identical to the original BST formed from `nums`.\\n\\n\\n# Approach\\n1. The `numOfWays` function is the entry point for the code. It initializes necessary variables and calls the `countWays` function to calculate the number of ways to reorder the array.\\n2. The `countWays` function takes a list of integers (`nums`) as input and performs the recursive calculation.\\n3. In each recursive call of `countWays`, we choose the first element of `nums` as the root of the BST and separate the remaining elements into left and right subtrees.\\n4. We calculate the number of ways to reorder the left and right subtrees separately and multiply them together.\\n5. To calculate the number of combinations for arranging the elements in the subtrees, we use the `choose` function.\\n6. The `choose` function uses dynamic programming to calculate the binomial coefficients and handles large numbers using modular arithmetic.\\n7. Finally, the result is returned as the number of ways to reorder the array, subtracting 1 to exclude the original ordering.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(n^2), where n is the length of the input array `nums`. This is because for each element in the array, we recursively calculate the number of ways to reorder the remaining elements.\\n\\n- Space complexity:\\nThe space complexity is O(n) since we use additional space for the recursive function calls and the `choose` function.\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int numOfWays(int[] nums) {\\n        int n = nums.length;\\n        List<Integer> numList = new ArrayList<>();\\n        for (int num : nums) {\\n            numList.add(num);\\n        }\\n        return (int) (countWays(numList) - 1); // Subtract 1 for the original ordering\\n    }\\n\\n    private long countWays(List<Integer> nums) {\\n        if (nums.size() <= 2) {\\n            return 1;\\n        }\\n\\n        int root = nums.get(0);\\n        List<Integer> leftSubtree = new ArrayList<>();\\n        List<Integer> rightSubtree = new ArrayList<>();\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums.get(i) < root) {\\n                leftSubtree.add(nums.get(i));\\n            } else {\\n                rightSubtree.add(nums.get(i));\\n            }\\n        }\\n\\n        long leftWays = countWays(leftSubtree);\\n        long rightWays = countWays(rightSubtree);\\n\\n        long result = (choose(nums.size() - 1, leftSubtree.size()) % MOD * leftWays % MOD * rightWays % MOD) % MOD;\\n\\n        return result;\\n    }\\n\\n    private long choose(int n, int k) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n\\n        long[][] dp = new long[n + 1][n + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 1;\\n            dp[i][i] = 1;\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j < i; j++) {\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    private static final int MOD = (int) 1e9 + 7;\\n\\n    public int numOfWays(int[] nums) {\\n        int n = nums.length;\\n        List<Integer> numList = new ArrayList<>();\\n        for (int num : nums) {\\n            numList.add(num);\\n        }\\n        return (int) (countWays(numList) - 1); // Subtract 1 for the original ordering\\n    }\\n\\n    private long countWays(List<Integer> nums) {\\n        if (nums.size() <= 2) {\\n            return 1;\\n        }\\n\\n        int root = nums.get(0);\\n        List<Integer> leftSubtree = new ArrayList<>();\\n        List<Integer> rightSubtree = new ArrayList<>();\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums.get(i) < root) {\\n                leftSubtree.add(nums.get(i));\\n            } else {\\n                rightSubtree.add(nums.get(i));\\n            }\\n        }\\n\\n        long leftWays = countWays(leftSubtree);\\n        long rightWays = countWays(rightSubtree);\\n\\n        long result = (choose(nums.size() - 1, leftSubtree.size()) % MOD * leftWays % MOD * rightWays % MOD) % MOD;\\n\\n        return result;\\n    }\\n\\n    private long choose(int n, int k) {\\n        if (k == 0 || k == n) {\\n            return 1;\\n        }\\n\\n        long[][] dp = new long[n + 1][n + 1];\\n\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 1;\\n            dp[i][i] = 1;\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j < i; j++) {\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656630,
                "title": "easy-solution-of-divide-and-conquer-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDivide and conquer approach and then DP to store Binomial Coefficient.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is simple i.e. the first element of nums will be root and then order of smaller and greater elements than root will be order.Similarly we will divide the tree in smaller and greater array and apply the same approach for left and right subtree.\\nAnd 1 is subtracted from the final answer to remove the count of original array given in the problem.\\nHope it Helps. **PLEASE UPVOTE**\\n\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//PLEASE_UPVOTE\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(int n,int k){\\n        //this function is store the binomial coefficient\\n        vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, 0));\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            dp[i][0] = 1;\\n            for (int j = 1; j <= min(i, k); j++) {\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j])%mod;\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n    long long solve(vector<int>&nums){\\n        if(nums.size()<=1)return 1;\\n        int n=nums.size();\\n        vector<int>smaller,greater;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[0])greater.push_back(nums[i]);\\n            else smaller.push_back(nums[i]);\\n        }\\n        int m=smaller.size();\\n        long long ans=func(n-1,m);\\n        //n-1 is passed in the ans as total size will be 1 minus from root i.e. nums[0].\\n        //smaller is meant for left subtree\\n        //greater is meant for right subtree\\n        return ans%mod*solve(smaller)%mod*solve(greater)%mod;\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        return (solve(nums)-1)%mod;//-1 to remove the count of original array.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n//PLEASE_UPVOTE\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int func(int n,int k){\\n        //this function is store the binomial coefficient\\n        vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, 0));\\n        dp[0][0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            dp[i][0] = 1;\\n            for (int j = 1; j <= min(i, k); j++) {\\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j])%mod;\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n    long long solve(vector<int>&nums){\\n        if(nums.size()<=1)return 1;\\n        int n=nums.size();\\n        vector<int>smaller,greater;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[0])greater.push_back(nums[i]);\\n            else smaller.push_back(nums[i]);\\n        }\\n        int m=smaller.size();\\n        long long ans=func(n-1,m);\\n        //n-1 is passed in the ans as total size will be 1 minus from root i.e. nums[0].\\n        //smaller is meant for left subtree\\n        //greater is meant for right subtree\\n        return ans%mod*solve(smaller)%mod*solve(greater)%mod;\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        return (solve(nums)-1)%mod;//-1 to remove the count of original array.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653224,
                "title": "java-recursion-time-60ms-94-space-55mb-79",
                "content": "# Approach\\nSince it is a binary tree, every node can be bisected into a left and right subtree depending on it they are smaller or larger respectively. Thus, we can permute the ordering across different subtrees; only ensuring that the ordering within the same subtree is preserved to yield the same binary tree.\\n\\nThus, we can recurse through each level of the binary tree, identifying the left and right subtree and calculating the number of permutations across the two different subtrees.\\n * This would have a time complexity of O(n * m) and space complexity of O(n * m) where n and m are the dimensions of the grid.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) *, where n is the size of the array*\\n\\n- Space complexity:\\nO(n^2) *, where n is the size of the array*\\n\\n# Code\\n```\\nclass Solution {\\n\\tprivate int modval = 1000000007;\\n\\tint[][] triangle; // Pascal\\'s triangle\\n\\n\\t/**\\n\\t * Generates Pascal\\'s triangle up to certain depth\\n\\t * @param depth depth of the Pascals\\' triangle\\n\\t */\\n\\tprivate void PascalTriangle (int depth) {\\n\\t\\ttriangle = new int[depth][depth];\\n\\n\\t\\t// first & second layer\\n\\t\\ttriangle[0][0] = 1;\\n\\t\\tif (depth > 1) {\\n\\t\\t\\ttriangle[1][0] = 1;\\n\\t\\t\\ttriangle[1][1] = 1;\\n\\t\\t}\\n\\n\\t\\t// subsequent layers\\n\\t\\tfor (int i = 2; i < depth; i++) {\\n\\t\\t\\ttriangle[i][0] = 1;\\n\\t\\t\\ttriangle[i][i] = 1;\\n\\t\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\t\\ttriangle[i][j] = (triangle[i - 1][j - 1] + triangle [i - 1][j])\\n\\t\\t\\t\\t\\t\\t% modval;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Recursively calculates the number of permutations b/w each left and right\\n\\t * subtrees, to still yield the same binary tree\\n\\t * @param arr array of integers to insert into binary tree, sequentially\\n\\t * @return number of ways to permute arr to yield the same binary tree\\n\\t */\\n\\tprivate int recurse(ArrayList<Integer> arr) {\\n\\t\\t// base case, only 1 node\\n\\t\\tif (arr.size() <= 1) return 1;\\n\\n\\t\\t// sort into left/right subtree\\n\\t\\tArrayList<Integer> left = new ArrayList<Integer>();\\n\\t\\tArrayList<Integer> right = new ArrayList<Integer>();\\n\\t\\tfor (int i = 1; i < arr.size(); i++) {\\n\\t\\t\\tif (arr.get(i) > arr.get(0)) right.add(arr.get(i));\\n\\t\\t\\telse left.add(arr.get(i));\\n\\t\\t}\\n\\n\\t\\t// recurse other levels\\n\\t\\tlong nways = triangle[left.size() + right.size()][left.size()];\\n\\t\\tif (left.size() != 0) nways = (nways * recurse(left)) % modval;\\n\\t\\tif (right.size() != 0) nways = (nways * recurse(right)) % modval;\\n\\n\\t\\t// calculate permutations\\n\\t\\treturn (int) nways;\\n\\t}\\n\\n\\t/**\\n\\t * Calculates the number of ways to permute nums while still yielding the\\n\\t * same binary tree when elements are inserted sequentially.\\n\\t * @param nums numbers to insert into the binary tree, sequentially\\n\\t * @return numbers of ways to permute nums to yield the same binary tree\\n\\t */\\n\\tpublic int numOfWays(int[] nums) {\\n\\t\\tPascalTriangle(nums.length); // calculate binomial coefficient\\n\\t\\t\\n\\t\\t// cast nums to ArrayList for helper function\\n\\t\\tArrayList<Integer> arr = new ArrayList<Integer>(nums.length);\\n\\t\\tfor (int num : nums) arr.add(num);\\n\\n\\t\\treturn recurse(arr) - 1;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tprivate int modval = 1000000007;\\n\\tint[][] triangle; // Pascal\\'s triangle\\n\\n\\t/**\\n\\t * Generates Pascal\\'s triangle up to certain depth\\n\\t * @param depth depth of the Pascals\\' triangle\\n\\t */\\n\\tprivate void PascalTriangle (int depth) {\\n\\t\\ttriangle = new int[depth][depth];\\n\\n\\t\\t// first & second layer\\n\\t\\ttriangle[0][0] = 1;\\n\\t\\tif (depth > 1) {\\n\\t\\t\\ttriangle[1][0] = 1;\\n\\t\\t\\ttriangle[1][1] = 1;\\n\\t\\t}\\n\\n\\t\\t// subsequent layers\\n\\t\\tfor (int i = 2; i < depth; i++) {\\n\\t\\t\\ttriangle[i][0] = 1;\\n\\t\\t\\ttriangle[i][i] = 1;\\n\\t\\t\\tfor (int j = 1; j < i; j++) {\\n\\t\\t\\t\\ttriangle[i][j] = (triangle[i - 1][j - 1] + triangle [i - 1][j])\\n\\t\\t\\t\\t\\t\\t% modval;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Recursively calculates the number of permutations b/w each left and right\\n\\t * subtrees, to still yield the same binary tree\\n\\t * @param arr array of integers to insert into binary tree, sequentially\\n\\t * @return number of ways to permute arr to yield the same binary tree\\n\\t */\\n\\tprivate int recurse(ArrayList<Integer> arr) {\\n\\t\\t// base case, only 1 node\\n\\t\\tif (arr.size() <= 1) return 1;\\n\\n\\t\\t// sort into left/right subtree\\n\\t\\tArrayList<Integer> left = new ArrayList<Integer>();\\n\\t\\tArrayList<Integer> right = new ArrayList<Integer>();\\n\\t\\tfor (int i = 1; i < arr.size(); i++) {\\n\\t\\t\\tif (arr.get(i) > arr.get(0)) right.add(arr.get(i));\\n\\t\\t\\telse left.add(arr.get(i));\\n\\t\\t}\\n\\n\\t\\t// recurse other levels\\n\\t\\tlong nways = triangle[left.size() + right.size()][left.size()];\\n\\t\\tif (left.size() != 0) nways = (nways * recurse(left)) % modval;\\n\\t\\tif (right.size() != 0) nways = (nways * recurse(right)) % modval;\\n\\n\\t\\t// calculate permutations\\n\\t\\treturn (int) nways;\\n\\t}\\n\\n\\t/**\\n\\t * Calculates the number of ways to permute nums while still yielding the\\n\\t * same binary tree when elements are inserted sequentially.\\n\\t * @param nums numbers to insert into the binary tree, sequentially\\n\\t * @return numbers of ways to permute nums to yield the same binary tree\\n\\t */\\n\\tpublic int numOfWays(int[] nums) {\\n\\t\\tPascalTriangle(nums.length); // calculate binomial coefficient\\n\\t\\t\\n\\t\\t// cast nums to ArrayList for helper function\\n\\t\\tArrayList<Integer> arr = new ArrayList<Integer>(nums.length);\\n\\t\\tfor (int num : nums) arr.add(num);\\n\\n\\t\\treturn recurse(arr) - 1;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653184,
                "title": "best-c-code-dfs-postorder",
                "content": "# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<vector<long>> nCr;\\n\\n    long DFS(vector<int>& nums){\\n        int n = nums.size();\\n        if(n <= 2)\\n            return 1;\\n        long left_ans = 0,right_ans = 0;\\n        vector<int> left,right;\\n        for(int i=1;i<n;i++){\\n            if(nums[i] < nums[0])\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }\\n        left_ans = DFS(left);\\n        right_ans = DFS(right);\\n        int len = left.size();\\n        return (((nCr[n-1][len] * left_ans) % mod) * right_ans) % mod;\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        nCr.resize(n+1);\\n        for(int i=0;i<n+1;i++){\\n            nCr[i].resize(i+1,1);   //Pascals Triangle to calculate nCr\\n            for(int j=1;j<i;j++)\\n                nCr[i][j] = (nCr[i-1][j-1] + nCr[i-1][j]) % mod;\\n        }\\n        return (DFS(nums) - 1) % mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    vector<vector<long>> nCr;\\n\\n    long DFS(vector<int>& nums){\\n        int n = nums.size();\\n        if(n <= 2)\\n            return 1;\\n        long left_ans = 0,right_ans = 0;\\n        vector<int> left,right;\\n        for(int i=1;i<n;i++){\\n            if(nums[i] < nums[0])\\n                left.push_back(nums[i]);\\n            else\\n                right.push_back(nums[i]);\\n        }\\n        left_ans = DFS(left);\\n        right_ans = DFS(right);\\n        int len = left.size();\\n        return (((nCr[n-1][len] * left_ans) % mod) * right_ans) % mod;\\n    }\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size();\\n        nCr.resize(n+1);\\n        for(int i=0;i<n+1;i++){\\n            nCr[i].resize(i+1,1);   //Pascals Triangle to calculate nCr\\n            for(int j=1;j<i;j++)\\n                nCr[i][j] = (nCr[i-1][j-1] + nCr[i-1][j]) % mod;\\n        }\\n        return (DFS(nums) - 1) % mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652655,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    private static final int MOD = 1000000007;\\n    private long[][] PT;\\n    public int numOfWays(int[] nums) {\\n        int n = nums.length;\\n\\n        PT = new long[n+1][n+1];\\n        for(int i = 0; i <= n; i++) {\\n            PT[i][0] = PT[i][i] = 1;\\n        }\\n\\n        for(int i = 2; i <= n; i++) {\\n            for(int j = 1; j < i; j++) {\\n                PT[i][j] = (PT[i-1][j] + PT[i-1][j-1])%MOD;\\n            }\\n        }\\n\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for(int val : nums) {\\n            arr.add(val);\\n        }\\n        return ((int)(solve(arr)-1))%MOD;\\n    }\\n\\n    private long solve(ArrayList<Integer> nums) {\\n        int n = nums.size();\\n        if(n < 3) {\\n            return 1;\\n        }\\n\\n        ArrayList<Integer> left = new ArrayList<>();\\n        ArrayList<Integer> right = new ArrayList<>();\\n        int root = nums.get(0);\\n\\n        for(int i = 1; i < n; i++) {\\n            int node = nums.get(i);\\n            if(node < root) {\\n                left.add(node);\\n            } else {\\n                right.add(node);\\n            }\\n        }\\n\\n        long x = solve(left)%MOD;\\n        long y = solve(right)%MOD;\\n\\n        long z = PT[n-1][left.size()];\\n        return (((x*y)%MOD)*z)%MOD;\\n    }\\n    \\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static final int MOD = 1000000007;\\n    private long[][] PT;\\n    public int numOfWays(int[] nums) {\\n        int n = nums.length;\\n\\n        PT = new long[n+1][n+1];\\n        for(int i = 0; i <= n; i++) {\\n            PT[i][0] = PT[i][i] = 1;\\n        }\\n\\n        for(int i = 2; i <= n; i++) {\\n            for(int j = 1; j < i; j++) {\\n                PT[i][j] = (PT[i-1][j] + PT[i-1][j-1])%MOD;\\n            }\\n        }\\n\\n        ArrayList<Integer> arr = new ArrayList<>();\\n        for(int val : nums) {\\n            arr.add(val);\\n        }\\n        return ((int)(solve(arr)-1))%MOD;\\n    }\\n\\n    private long solve(ArrayList<Integer> nums) {\\n        int n = nums.size();\\n        if(n < 3) {\\n            return 1;\\n        }\\n\\n        ArrayList<Integer> left = new ArrayList<>();\\n        ArrayList<Integer> right = new ArrayList<>();\\n        int root = nums.get(0);\\n\\n        for(int i = 1; i < n; i++) {\\n            int node = nums.get(i);\\n            if(node < root) {\\n                left.add(node);\\n            } else {\\n                right.add(node);\\n            }\\n        }\\n\\n        long x = solve(left)%MOD;\\n        long y = solve(right)%MOD;\\n\\n        long z = PT[n-1][left.size()];\\n        return (((x*y)%MOD)*z)%MOD;\\n    }\\n    \\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652614,
                "title": "c-python-dynamic-programming-solution-with-explanation",
                "content": "```\\nWhen we know value of root, the structure of BST is fixed.\\nsuppose nums = [3,4,5,1,2]\\nroot is 3 -> [3,x,x,x,x], and there are 4 numbers after root, and we know 2 number in the left subtree and 2 number in the right subtree.\\nSo, remark x with L or R, which means there are some numbers in left and right subtree, there are C(4,2) way to rearrange combination of L and R.\\n3 L L R R\\n3 L R L R\\n3 L R R L\\n3 R R L L\\n...\\n\\nTo fill the numbers into L and R, we just fill the permutation of left and right subtree,\\nso, dp(root) is number of way to build the same BST, \\ndp(root) = C(size of root -1, size of left subtree) * dp(left subtree) * dp(right subtree)\\ndp(empty) = 1\\n```\\nWe can precalculate combination with O(n^2), and then build BST using O(nlogn), then dp on tree using O(n), so total tc is O(n^2),\\nsc is O(n^2).\\n\\n### c++\\n```cpp\\nclass Node {\\npublic:\\n    int val, sub, size; // node value, dp value, tree size\\n    Node *left, *right;\\n    Node(int val): val(val), left(nullptr), right(nullptr), size(1), sub(0) {};\\n};\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size(), mod = 1000000007;\\n        vector<vector<int>> comb (n+1, vector<int>(n+1, 1));\\n        for (int i = 2; i <= n; i+=1) {\\n            for (int j = 1; j < i; j+=1) {\\n                comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\\n                if (comb[i][j] >= mod) comb[i][j] -= mod; // C(n, k) = C(n-1, k-1) + C(n-1, k)\\n            }\\n        }\\n\\n        Node* root = new Node(nums[0]);\\n\\n        auto insertNode = [&] (Node* node) -> void { // build tree\\n            Node* cur = root;\\n            while (true) {\\n                cur -> size += 1;\\n                if (node -> val > cur -> val) {\\n                    if (! cur -> right) {\\n                        cur -> right = node;\\n                        return;\\n                    }\\n                    cur = cur -> right;\\n                } else {\\n                    if (! cur -> left) {\\n                        cur -> left = node;\\n                        return;\\n                    }\\n                    cur = cur -> left;\\n                }\\n            }\\n        };\\n        \\n        for (int i = 1; i < n; i+=1) {\\n            Node* node = new Node(nums[i]);\\n            insertNode(node); // build tree\\n        }\\n        \\n        function<void(Node*)> dfs = [&] (Node* cur) {\\n            if (! cur) return;\\n            dfs(cur -> left);\\n            dfs(cur -> right);\\n            int left_size = cur -> left ? cur -> left -> size: 0, right_size = cur -> right ? cur -> right -> size: 0;\\n            int left_sub = cur -> left ? cur -> left -> sub: 1, right_sub = cur -> right ? cur -> right -> sub: 1;\\n            cur -> sub = (long long) comb[left_size + right_size][left_size] * left_sub % mod * right_sub % mod; // calculate dp value\\n        };\\n        \\n        dfs(root);\\n        return root -> sub - 1;\\n    }\\n};\\n```\\n### python\\n```python\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = self.right = None\\n        self.size = 1 # tree size\\n        self.sub = 0 # dp value\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        mod = 10 ** 9 + 7\\n        comb = [[1] * (n + 1) for _ in range(n + 1)]\\n        for i in range(2, n+1):\\n            for j in range(1, i):\\n                comb[i][j] = comb[i-1][j-1] + comb[i-1][j] # C(n, k) = C(n-1, k-1) + C(n-1, k)\\n                if comb[i][j] >= mod: comb[i][j] -= mod\\n\\n        root = Node(nums[0])\\n        def insertNode(node): # build tree\\n            cur = root\\n            while True:\\n                cur.size += 1\\n                if node.val > cur.val:\\n                    if not cur.right:\\n                        cur.right = node\\n                        return\\n                    cur = cur.right\\n                else:\\n                    if not cur.left: \\n                        cur.left = node\\n                        return\\n                    cur = cur.left\\n        \\n        for i in range(1, n):\\n            node = Node(nums[i])\\n            insertNode(node) # build tree\\n        \\n        def dfs(node):\\n            if not node: return\\n            dfs(node.left)\\n            dfs(node.right)\\n            left_size = node.left.size if node.left else 0\\n            right_size = node.right.size if node.right else 0\\n            left_sub = node.left.sub if node.left else 1\\n            right_sub = node.right.sub if node.right else 1\\n            node.sub = comb[left_size + right_size][left_size] * left_sub * right_sub % mod # calculate dp value\\n        dfs(root)\\n        return root.sub - 1\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Binary Search Tree",
                    "Combinatorics"
                ],
                "code": "```\\nWhen we know value of root, the structure of BST is fixed.\\nsuppose nums = [3,4,5,1,2]\\nroot is 3 -> [3,x,x,x,x], and there are 4 numbers after root, and we know 2 number in the left subtree and 2 number in the right subtree.\\nSo, remark x with L or R, which means there are some numbers in left and right subtree, there are C(4,2) way to rearrange combination of L and R.\\n3 L L R R\\n3 L R L R\\n3 L R R L\\n3 R R L L\\n...\\n\\nTo fill the numbers into L and R, we just fill the permutation of left and right subtree,\\nso, dp(root) is number of way to build the same BST, \\ndp(root) = C(size of root -1, size of left subtree) * dp(left subtree) * dp(right subtree)\\ndp(empty) = 1\\n```\n```cpp\\nclass Node {\\npublic:\\n    int val, sub, size; // node value, dp value, tree size\\n    Node *left, *right;\\n    Node(int val): val(val), left(nullptr), right(nullptr), size(1), sub(0) {};\\n};\\nclass Solution {\\npublic:\\n    int numOfWays(vector<int>& nums) {\\n        int n = nums.size(), mod = 1000000007;\\n        vector<vector<int>> comb (n+1, vector<int>(n+1, 1));\\n        for (int i = 2; i <= n; i+=1) {\\n            for (int j = 1; j < i; j+=1) {\\n                comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\\n                if (comb[i][j] >= mod) comb[i][j] -= mod; // C(n, k) = C(n-1, k-1) + C(n-1, k)\\n            }\\n        }\\n\\n        Node* root = new Node(nums[0]);\\n\\n        auto insertNode = [&] (Node* node) -> void { // build tree\\n            Node* cur = root;\\n            while (true) {\\n                cur -> size += 1;\\n                if (node -> val > cur -> val) {\\n                    if (! cur -> right) {\\n                        cur -> right = node;\\n                        return;\\n                    }\\n                    cur = cur -> right;\\n                } else {\\n                    if (! cur -> left) {\\n                        cur -> left = node;\\n                        return;\\n                    }\\n                    cur = cur -> left;\\n                }\\n            }\\n        };\\n        \\n        for (int i = 1; i < n; i+=1) {\\n            Node* node = new Node(nums[i]);\\n            insertNode(node); // build tree\\n        }\\n        \\n        function<void(Node*)> dfs = [&] (Node* cur) {\\n            if (! cur) return;\\n            dfs(cur -> left);\\n            dfs(cur -> right);\\n            int left_size = cur -> left ? cur -> left -> size: 0, right_size = cur -> right ? cur -> right -> size: 0;\\n            int left_sub = cur -> left ? cur -> left -> sub: 1, right_sub = cur -> right ? cur -> right -> sub: 1;\\n            cur -> sub = (long long) comb[left_size + right_size][left_size] * left_sub % mod * right_sub % mod; // calculate dp value\\n        };\\n        \\n        dfs(root);\\n        return root -> sub - 1;\\n    }\\n};\\n```\n```python\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = self.right = None\\n        self.size = 1 # tree size\\n        self.sub = 0 # dp value\\n\\nclass Solution:\\n    def numOfWays(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        mod = 10 ** 9 + 7\\n        comb = [[1] * (n + 1) for _ in range(n + 1)]\\n        for i in range(2, n+1):\\n            for j in range(1, i):\\n                comb[i][j] = comb[i-1][j-1] + comb[i-1][j] # C(n, k) = C(n-1, k-1) + C(n-1, k)\\n                if comb[i][j] >= mod: comb[i][j] -= mod\\n\\n        root = Node(nums[0])\\n        def insertNode(node): # build tree\\n            cur = root\\n            while True:\\n                cur.size += 1\\n                if node.val > cur.val:\\n                    if not cur.right:\\n                        cur.right = node\\n                        return\\n                    cur = cur.right\\n                else:\\n                    if not cur.left: \\n                        cur.left = node\\n                        return\\n                    cur = cur.left\\n        \\n        for i in range(1, n):\\n            node = Node(nums[i])\\n            insertNode(node) # build tree\\n        \\n        def dfs(node):\\n            if not node: return\\n            dfs(node.left)\\n            dfs(node.right)\\n            left_size = node.left.size if node.left else 0\\n            right_size = node.right.size if node.right else 0\\n            left_sub = node.left.sub if node.left else 1\\n            right_sub = node.right.sub if node.right else 1\\n            node.sub = comb[left_size + right_size][left_size] * left_sub * right_sub % mod # calculate dp value\\n        dfs(root)\\n        return root.sub - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652006,
                "title": "dfs-solution-using-efficient-combination-in-rust",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou can count the number of ways recursively if you know the binary-tree form for the original array.\\nIt consists of three combinations;\\n* the combination to pick up the space of children in the left subtree\\n* the combination to arrange the children in left subtree\\n* the combination to arrange the children in right subtree\\n\\nThe follows describe it.\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n    - $$nCr: O(NR)$$\\n    - Tree Travasal: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nconst M: i64 = 1_000_000_007;\\n\\n#[derive(Debug)]\\nstruct TreeNode {\\n    n: i32,\\n    val: i32,\\n    left: Option<Rc<RefCell<TreeNode>>>,\\n    right: Option<Rc<RefCell<TreeNode>>>,\\n}\\n\\nimpl TreeNode {\\n    pub fn new(val: i32) -> Self {\\n        TreeNode { val, n: 1, left: None, right: None }\\n    }\\n\\n    pub fn insert(&mut self, val: i32) {\\n        self.n += 1;\\n        if val < self.val {\\n            if let Some(rc) = self.left.clone() {\\n                rc.borrow_mut().insert(val);\\n            } else {\\n                self.left = Some(Rc::new(RefCell::new(TreeNode::new(val))));\\n            }\\n        } else {\\n            if let Some(rc) = self.right.clone() {\\n                rc.borrow_mut().insert(val);\\n            } else {\\n                self.right = Some(Rc::new(RefCell::new(TreeNode::new(val))));\\n            }\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    fn comb(n: i32, r: i32) -> i64 {\\n        let r = r.min(n - r) as usize;\\n        let n = n as usize;\\n        let mut cache = vec![0_i64; n + 1];\\n        cache[0] = 1;\\n        for i in 1..=n {\\n            cache[0] = 1;\\n            cache[i] = 1;\\n            let mut prev = cache[0];\\n            for j in 1..=r.min(i - 1) {\\n                let cur = cache[j];\\n                cache[j] = (cur + prev) % M;\\n                prev = cur;\\n            }\\n        }\\n        cache[r]\\n    }\\n\\n    fn _num_of_ways(bst: Option<Rc<RefCell<TreeNode>>>) -> i64 {\\n        let mut ans = 1_i64;\\n        if let Some(rc) = bst {\\n            let node = rc.borrow();\\n            if let Some(rc_left) = node.left.clone() {\\n                let left = rc_left.borrow();\\n                ans = Self::comb(node.n - 1, left.n);\\n                ans = (ans * Self::_num_of_ways(node.left.clone())) % M;\\n                ans = (ans * Self::_num_of_ways(node.right.clone())) % M;\\n            } else {\\n                ans = Self::_num_of_ways(node.right.clone());\\n            }\\n        }\\n        ans\\n    }\\n\\n    pub fn num_of_ways(nums: Vec<i32>) -> i32 {\\n        let mut bst = TreeNode::new(nums[0]);\\n        for num in &nums[1..] {\\n            bst.insert(*num);\\n        }\\n\\n        (Self::_num_of_ways(Some(Rc::new(RefCell::new(bst)))) - 1) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nuse std::cell::RefCell;\\nuse std::rc::Rc;\\n\\nconst M: i64 = 1_000_000_007;\\n\\n#[derive(Debug)]\\nstruct TreeNode {\\n    n: i32,\\n    val: i32,\\n    left: Option<Rc<RefCell<TreeNode>>>,\\n    right: Option<Rc<RefCell<TreeNode>>>,\\n}\\n\\nimpl TreeNode {\\n    pub fn new(val: i32) -> Self {\\n        TreeNode { val, n: 1, left: None, right: None }\\n    }\\n\\n    pub fn insert(&mut self, val: i32) {\\n        self.n += 1;\\n        if val < self.val {\\n            if let Some(rc) = self.left.clone() {\\n                rc.borrow_mut().insert(val);\\n            } else {\\n                self.left = Some(Rc::new(RefCell::new(TreeNode::new(val))));\\n            }\\n        } else {\\n            if let Some(rc) = self.right.clone() {\\n                rc.borrow_mut().insert(val);\\n            } else {\\n                self.right = Some(Rc::new(RefCell::new(TreeNode::new(val))));\\n            }\\n        }\\n    }\\n}\\n\\nimpl Solution {\\n    fn comb(n: i32, r: i32) -> i64 {\\n        let r = r.min(n - r) as usize;\\n        let n = n as usize;\\n        let mut cache = vec![0_i64; n + 1];\\n        cache[0] = 1;\\n        for i in 1..=n {\\n            cache[0] = 1;\\n            cache[i] = 1;\\n            let mut prev = cache[0];\\n            for j in 1..=r.min(i - 1) {\\n                let cur = cache[j];\\n                cache[j] = (cur + prev) % M;\\n                prev = cur;\\n            }\\n        }\\n        cache[r]\\n    }\\n\\n    fn _num_of_ways(bst: Option<Rc<RefCell<TreeNode>>>) -> i64 {\\n        let mut ans = 1_i64;\\n        if let Some(rc) = bst {\\n            let node = rc.borrow();\\n            if let Some(rc_left) = node.left.clone() {\\n                let left = rc_left.borrow();\\n                ans = Self::comb(node.n - 1, left.n);\\n                ans = (ans * Self::_num_of_ways(node.left.clone())) % M;\\n                ans = (ans * Self::_num_of_ways(node.right.clone())) % M;\\n            } else {\\n                ans = Self::_num_of_ways(node.right.clone());\\n            }\\n        }\\n        ans\\n    }\\n\\n    pub fn num_of_ways(nums: Vec<i32>) -> i32 {\\n        let mut bst = TreeNode::new(nums[0]);\\n        for num in &nums[1..] {\\n            bst.insert(*num);\\n        }\\n\\n        (Self::_num_of_ways(Some(Rc::new(RefCell::new(bst)))) - 1) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650001,
                "title": "c-3ms-solution-using-std-partition",
                "content": "The title is a little click-baiting. No, I don\\'t consistently get 3ms due to LeetCode variations. But I did get a 3ms here, https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/submissions/972405254/.\\n\\nIf $$left$$ denotes the left subtree of size $$l$$ and $$right$$ denotes the right subtree of size $$r$$, then the recursive formula is \\n$$L(T) = \\\\frac{(l + r)!}{l! \\\\ r!} * L(left) * L(right)$$.\\n\\nI\\'m using the library function std::stable_partition to determine the elements in the two sub-branches. stable_partition does allocate memory behind the scene, but frees it up again. This makes the overall memory footprint smaller than many hand-rolled recursive solutions. And, the hot data stays in-place.\\n\\nIf the data in a sub-branch is sorted (ascending or descending), then there is only one way of forming the subtree. I detect this case to limit the recursion.\\n\\n```\\nclass Solution\\n{\\n    int const m = 1\\'000\\'000\\'007;\\n\\n\\tint inverse(int k)\\n\\t{\\n        // Calculate the multiplicative inverse to k modulo m\\n\\t\\tif (k == 1) { return 1; }\\n\\n\\t\\tauto q = m / k;\\n\\t\\tauto r = m - q * k;\\n\\n\\t\\treturn static_cast<int>(1LL * q * (m - inverse(r)) % m);\\n\\t}\\n\\n\\tint combinations(int l, int r)\\n\\t{\\n\\t\\tif (l == 0 || r == 0) { return 1; }\\n\\n\\t\\tauto n = l + r;\\n\\t\\tauto k = std::min(l, r);\\n\\n\\t\\tauto numerator = 1;\\n\\t\\tfor (auto f = n; f > n - k; --f) { numerator = static_cast<int>(1LL * numerator * f % m); }\\n\\n\\t\\tauto denominator = 1;\\n\\t\\tfor (auto d = 1; d <= k; ++d) { denominator = static_cast<int>(1LL * denominator * d % m); }\\n\\t\\t\\n\\t\\treturn static_cast<int>(1LL * numerator * inverse(denominator) % m);\\n\\t}\\n\\n    using Iterator = std::vector<int>::iterator;\\n\\n\\tint numOfWays(Iterator first, Iterator last)\\n\\t{\\n        // Short circuiting if possible\\n\\t\\tif (std::is_sorted(first, last, std::less<>())) { return 1; }\\n\\t\\tif (std::is_sorted(first, last, std::greater<>())) { return 1; }\\n\\n        // Determine the elements in the two sub-branches\\n\\t\\tauto iter = std::stable_partition(std::next(first), last,\\n            [x = *first](auto y) { return y < x; });\\n\\n\\t\\t// Recursively handling the left subtree\\n\\t\\tauto left = numOfWays(std::next(first), iter);\\n\\t\\tauto l = static_cast<int>(std::distance(std::next(first), iter));\\n\\n\\t\\t// Recursively handling the right subtree\\n\\t\\tauto right = numOfWays(iter, last);\\n\\t\\tauto r = static_cast<int>(std::distance(iter, last));\\n\\n\\t\\t// Using the recursive formula directly\\n\\t\\treturn static_cast<int>(1LL * combinations(l, r) * left % m * right % m);\\n\\t}\\npublic:\\n\\tint numOfWays(std::vector<int>& nums)\\n\\t{\\n\\t\\treturn -1 + numOfWays(std::begin(nums), std::end(nums));\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    int const m = 1\\'000\\'000\\'007;\\n\\n\\tint inverse(int k)\\n\\t{\\n        // Calculate the multiplicative inverse to k modulo m\\n\\t\\tif (k == 1) { return 1; }\\n\\n\\t\\tauto q = m / k;\\n\\t\\tauto r = m - q * k;\\n\\n\\t\\treturn static_cast<int>(1LL * q * (m - inverse(r)) % m);\\n\\t}\\n\\n\\tint combinations(int l, int r)\\n\\t{\\n\\t\\tif (l == 0 || r == 0) { return 1; }\\n\\n\\t\\tauto n = l + r;\\n\\t\\tauto k = std::min(l, r);\\n\\n\\t\\tauto numerator = 1;\\n\\t\\tfor (auto f = n; f > n - k; --f) { numerator = static_cast<int>(1LL * numerator * f % m); }\\n\\n\\t\\tauto denominator = 1;\\n\\t\\tfor (auto d = 1; d <= k; ++d) { denominator = static_cast<int>(1LL * denominator * d % m); }\\n\\t\\t\\n\\t\\treturn static_cast<int>(1LL * numerator * inverse(denominator) % m);\\n\\t}\\n\\n    using Iterator = std::vector<int>::iterator;\\n\\n\\tint numOfWays(Iterator first, Iterator last)\\n\\t{\\n        // Short circuiting if possible\\n\\t\\tif (std::is_sorted(first, last, std::less<>())) { return 1; }\\n\\t\\tif (std::is_sorted(first, last, std::greater<>())) { return 1; }\\n\\n        // Determine the elements in the two sub-branches\\n\\t\\tauto iter = std::stable_partition(std::next(first), last,\\n            [x = *first](auto y) { return y < x; });\\n\\n\\t\\t// Recursively handling the left subtree\\n\\t\\tauto left = numOfWays(std::next(first), iter);\\n\\t\\tauto l = static_cast<int>(std::distance(std::next(first), iter));\\n\\n\\t\\t// Recursively handling the right subtree\\n\\t\\tauto right = numOfWays(iter, last);\\n\\t\\tauto r = static_cast<int>(std::distance(iter, last));\\n\\n\\t\\t// Using the recursive formula directly\\n\\t\\treturn static_cast<int>(1LL * combinations(l, r) * left % m * right % m);\\n\\t}\\npublic:\\n\\tint numOfWays(std::vector<int>& nums)\\n\\t{\\n\\t\\treturn -1 + numOfWays(std::begin(nums), std::end(nums));\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649820,
                "title": "clean-c-code",
                "content": "Easy C++ clean code, with logic:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    /*\\n        Logic:\\n        [3,4,5,1,2]\\n        \\n        intuition: - 3 is root\\n                   - 1 then 2 \\n                   - 4 then 5\\n        => array will look like  3 .. 1 4 .. 4 5\\n        \\n        Now the logic to find these numbers is simple\\n        3 _ _ _ _ \\n        We want to find the no of ways 1,2,4,5 can fit these 4 dash, with 1 then 2, and 4 then 5\\n        \\n        simple find the no of ways to fill 1 and 2, then fill the remaining 4 and 5 in the remain\\n        \\n        thus no of ways will be 4C2 in this case\\n        \\n        Now the left tree can have multiple ways to be constructed, same for right tree\\n        \\n        thus result at one root is, left * right * nCk\\n    */\\n    \\n    const int MOD = 1e9 + 7;\\n    #define ll long long\\n    \\n    int binpower(ll base, ll p) {\\n        ll res = 1;\\n        while(p > 0) {\\n            if(p & 1) {\\n                res = mul(res, base);\\n            }\\n            p >>= 1;\\n            base = mul(base, base);\\n        }\\n        return res;\\n    }\\n    \\n    int modInv(ll oper) {\\n        return binpower(oper, MOD-2);\\n    }\\n    \\n    int mod(ll val) {\\n        return ((val % MOD) + MOD) % MOD;\\n    }\\n    \\n    int mul(ll oper1, ll oper2) {\\n        oper1 = mod(oper1);\\n        oper2 = mod(oper2);\\n        ll res = oper1 * oper2;\\n        res = mod(res);\\n        return res;\\n    }\\n    \\n    int div(ll oper1, ll oper2) {\\n        oper1 = mod(oper1);\\n        oper2 = mod(oper2);\\n        ll res = oper1 * modInv(oper2);\\n        res = mod(res);\\n        return res;\\n    }\\n    \\n    vector<int> fac;\\n    \\n    void init(int n) {\\n        fac = vector<int>(n+1);\\n        fac[0] = 1;\\n        for(int i = 1; i <= n; i++) {\\n            fac[i] = mul(fac[i-1], i);\\n        }\\n    }\\n    \\n    int nCr(int n, int r) {\\n        int num = fac[n];\\n        int den = mul(fac[r], fac[n-r]);\\n        int res = div(num, den);\\n        return res;\\n    }\\n    \\n    int numOfWaysUtil(vector<int> nums) {\\n        int n = nums.size();\\n        if(n == 0) return 1;\\n        \\n        int root = nums[0];\\n        vector<int> smaller, greater;\\n        for(auto it: nums) {\\n            if(it < root) smaller.push_back(it);\\n            if(it > root) greater.push_back(it);\\n        }\\n        \\n        int left = numOfWaysUtil(smaller);\\n        int right = numOfWaysUtil(greater);\\n        \\n        int sz = smaller.size();\\n        int res = mul(mul(left, right), nCr(n-1, sz));\\n        return res;\\n    }\\n    \\n    int numOfWays(vector<int> nums) {\\n        int n = nums.size();\\n        init(n);\\n        int res = numOfWaysUtil(nums) - 1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    /*\\n        Logic:\\n        [3,4,5,1,2]\\n        \\n        intuition: - 3 is root\\n                   - 1 then 2 \\n                   - 4 then 5\\n        => array will look like  3 .. 1 4 .. 4 5\\n        \\n        Now the logic to find these numbers is simple\\n        3 _ _ _ _ \\n        We want to find the no of ways 1,2,4,5 can fit these 4 dash, with 1 then 2, and 4 then 5\\n        \\n        simple find the no of ways to fill 1 and 2, then fill the remaining 4 and 5 in the remain\\n        \\n        thus no of ways will be 4C2 in this case\\n        \\n        Now the left tree can have multiple ways to be constructed, same for right tree\\n        \\n        thus result at one root is, left * right * nCk\\n    */\\n    \\n    const int MOD = 1e9 + 7;\\n    #define ll long long\\n    \\n    int binpower(ll base, ll p) {\\n        ll res = 1;\\n        while(p > 0) {\\n            if(p & 1) {\\n                res = mul(res, base);\\n            }\\n            p >>= 1;\\n            base = mul(base, base);\\n        }\\n        return res;\\n    }\\n    \\n    int modInv(ll oper) {\\n        return binpower(oper, MOD-2);\\n    }\\n    \\n    int mod(ll val) {\\n        return ((val % MOD) + MOD) % MOD;\\n    }\\n    \\n    int mul(ll oper1, ll oper2) {\\n        oper1 = mod(oper1);\\n        oper2 = mod(oper2);\\n        ll res = oper1 * oper2;\\n        res = mod(res);\\n        return res;\\n    }\\n    \\n    int div(ll oper1, ll oper2) {\\n        oper1 = mod(oper1);\\n        oper2 = mod(oper2);\\n        ll res = oper1 * modInv(oper2);\\n        res = mod(res);\\n        return res;\\n    }\\n    \\n    vector<int> fac;\\n    \\n    void init(int n) {\\n        fac = vector<int>(n+1);\\n        fac[0] = 1;\\n        for(int i = 1; i <= n; i++) {\\n            fac[i] = mul(fac[i-1], i);\\n        }\\n    }\\n    \\n    int nCr(int n, int r) {\\n        int num = fac[n];\\n        int den = mul(fac[r], fac[n-r]);\\n        int res = div(num, den);\\n        return res;\\n    }\\n    \\n    int numOfWaysUtil(vector<int> nums) {\\n        int n = nums.size();\\n        if(n == 0) return 1;\\n        \\n        int root = nums[0];\\n        vector<int> smaller, greater;\\n        for(auto it: nums) {\\n            if(it < root) smaller.push_back(it);\\n            if(it > root) greater.push_back(it);\\n        }\\n        \\n        int left = numOfWaysUtil(smaller);\\n        int right = numOfWaysUtil(greater);\\n        \\n        int sz = smaller.size();\\n        int res = mul(mul(left, right), nCr(n-1, sz));\\n        return res;\\n    }\\n    \\n    int numOfWays(vector<int> nums) {\\n        int n = nums.size();\\n        init(n);\\n        int res = numOfWaysUtil(nums) - 1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649180,
                "title": "with-drawing-number-of-ways-to-permute-the-left-and-right-subtree-build-and-traverse-bst",
                "content": "# Intuition\\n- First, build the binary search tree.\\n- Second, traverse the tree to get the left and right subtree size.\\n- For each node, the number of ways to permute its left and right subtree is \\n    -  `nCr(left_size + right_size, left_size)`\\n    - For example, if the current node has 2 nodes under its left subtree and 2 under right subtree, the number of ways to permute the left and right subtrees is `nCr(4, 2)`. (See ex1 in the picture below).\\n\\n![IMG_BA32F2E4C88B-1.jpeg](https://assets.leetcode.com/users/images/2ff99edb-753b-4090-ae59-b5a81434137f_1687019195.5505059.jpeg)\\n\\n\\n- Regarding the final result, we just multiple all node\\'s number of combinations together. (See ex2 in the picture above). Ex2 has 3 non-leaf nodes, so the result is `10 * 2 * 1`.\\n- The last trick in calculating combination `nCr(n,k)` is to use a pascal\\'s triangle. After building the pascal table, we can look up `nCr` every time.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* root = NULL;\\n    vector<vector<long long>> pascal_table;\\n    long long res = 1;\\n    long long mod = 1e9 + 7;\\n\\n    vector<vector<long long>> pascal(int max_n){\\n        vector<vector<long long>> table(max_n, vector<long long>(max_n, 1));\\n        for(int i = 1; i < max_n; i++){\\n            for(int j = 1; j < i; j++){\\n                table[i][j] = (table[i-1][j-1] + table[i-1][j]) % mod;\\n            }\\n        }\\n        return table;\\n    }\\n\\n    long long nCr(int n, int k){\\n        long long rc = pascal_table[n][k];\\n        return rc;\\n    }\\n\\n    TreeNode* build_tree(TreeNode* cur, int val){\\n        if(cur == NULL){\\n            return new TreeNode(val);\\n        }\\n        if(val > cur->val){\\n            cur->right = build_tree(cur->right, val);\\n        }\\n        else if(val < cur->val){\\n            cur->left = build_tree(cur->left, val);\\n        }\\n        return cur;\\n    }\\n\\n    int num_child(TreeNode* cur){\\n        if(cur == NULL){\\n            return 0;\\n        }\\n        int left_len = num_child(cur->left);\\n        int right_len = num_child(cur->right);\\n        long long cur_perm = nCr(left_len + right_len, left_len) % mod;\\n        res = (res * cur_perm) % mod;\\n        return left_len + right_len + 1;\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        for(int x : nums){\\n            root = build_tree(root, x);\\n        }\\n\\n        pascal_table = pascal(nums.size());\\n\\n        num_child(root);\\n        return res - 1;   \\n    }\\n};\\n```\\n\\nInspiration drawn from: [[C++]--Just using recursion, very Clean and Easy to understand--O(n^2)](https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/solutions/819369/c-just-using-recursion-very-clean-and-easy-to-understand-o-n-2/).\\n\\nHope it helps!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* root = NULL;\\n    vector<vector<long long>> pascal_table;\\n    long long res = 1;\\n    long long mod = 1e9 + 7;\\n\\n    vector<vector<long long>> pascal(int max_n){\\n        vector<vector<long long>> table(max_n, vector<long long>(max_n, 1));\\n        for(int i = 1; i < max_n; i++){\\n            for(int j = 1; j < i; j++){\\n                table[i][j] = (table[i-1][j-1] + table[i-1][j]) % mod;\\n            }\\n        }\\n        return table;\\n    }\\n\\n    long long nCr(int n, int k){\\n        long long rc = pascal_table[n][k];\\n        return rc;\\n    }\\n\\n    TreeNode* build_tree(TreeNode* cur, int val){\\n        if(cur == NULL){\\n            return new TreeNode(val);\\n        }\\n        if(val > cur->val){\\n            cur->right = build_tree(cur->right, val);\\n        }\\n        else if(val < cur->val){\\n            cur->left = build_tree(cur->left, val);\\n        }\\n        return cur;\\n    }\\n\\n    int num_child(TreeNode* cur){\\n        if(cur == NULL){\\n            return 0;\\n        }\\n        int left_len = num_child(cur->left);\\n        int right_len = num_child(cur->right);\\n        long long cur_perm = nCr(left_len + right_len, left_len) % mod;\\n        res = (res * cur_perm) % mod;\\n        return left_len + right_len + 1;\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        for(int x : nums){\\n            root = build_tree(root, x);\\n        }\\n\\n        pascal_table = pascal(nums.size());\\n\\n        num_child(root);\\n        return res - 1;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648868,
                "title": "finding-all-topological-sortings-using-dfs",
                "content": "# Intuition\\n- First, build the BST tree.\\n- Second, traverse the tree to build an adjacency list of the graph. \\n- Third, use DFS to traverse the graph:\\n    - start from a node with no incoming edges (in this case, the root node). \\n    - append this node to onPath array. \\n    - minus the in-degrees of all children of this node by 1. \\n    - perform dfs on the next 0-in-degree node.\\n- Finally, res array will contain all topological orderings.\\n\\n# Code\\n```\\n// struct TreeNode {\\n//     TreeNode* left;\\n//     TreeNode* right;\\n//     int val;\\n//     TreeNode(int x) {val = x; left = NULL; right = NULL;}\\n// };\\n\\nclass Solution {\\npublic:\\n    vector<int> onPath;\\n    TreeNode* root = NULL;\\n    unordered_map<int, vector<int>> adj;\\n    unordered_map<int, int> indeg;\\n    vector<int> mynums;\\n    vector<vector<int>> res;\\n    vector<int> visited;\\n\\n    TreeNode* buildTree(TreeNode* cur, int val){\\n        if(cur == NULL){\\n            return new TreeNode(val);\\n        }\\n        else if(val < cur->val){\\n            cur->left = buildTree(cur->left, val);\\n        }\\n        else if(val > cur->val){\\n            cur->right = buildTree(cur->right, val);\\n        }\\n\\n        return cur;\\n    }\\n\\n    void traverse(TreeNode* cur){\\n        if(cur == NULL){\\n            return;\\n        }\\n\\n        traverse(cur->left);\\n        traverse(cur->right);\\n        if(cur->left)\\n            adj[cur->val].push_back(cur->left->val);\\n        if(cur->right)\\n            adj[cur->val].push_back(cur->right->val);\\n    }\\n\\n    void dfs(){\\n        for(int v : mynums){\\n            if(indeg[v] == 0 and !visited[v]){\\n                for(int x : adj[v]){indeg[x] --;}\\n                onPath.push_back(v);\\n                visited[v] = 1;\\n                dfs();\\n                onPath.pop_back();\\n                visited[v] = 0;\\n                for(int x : adj[v]) indeg[x] ++;\\n            }\\n        }\\n\\n        if(onPath.size() == mynums.size()){\\n            res.push_back(onPath);\\n        }\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        /* Build tree*/\\n        for(int x : nums){\\n            if(root == NULL){\\n                root = buildTree(root, x);\\n            }else{\\n                TreeNode* rc = buildTree(root, x);\\n            }\\n\\n            indeg[x] = 1;\\n        }\\n\\n        /* Initialize the graph */\\n        int max_ele = *max_element(nums.begin(), nums.end());\\n        visited.assign(max_ele + 1, 0);\\n        indeg[nums[0]] = 0;\\n        mynums = nums;\\n        traverse(root);\\n\\n        /* DFS */\\n        dfs();\\n\\n        /* res contains all topological orderings */\\n        return res.size() - 1;        \\n    }\\n};\\n```\\n\\nNote that this solution will result in TLE. We can record only the count of orders instead of the actual ordering to reduce the time consumption.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// struct TreeNode {\\n//     TreeNode* left;\\n//     TreeNode* right;\\n//     int val;\\n//     TreeNode(int x) {val = x; left = NULL; right = NULL;}\\n// };\\n\\nclass Solution {\\npublic:\\n    vector<int> onPath;\\n    TreeNode* root = NULL;\\n    unordered_map<int, vector<int>> adj;\\n    unordered_map<int, int> indeg;\\n    vector<int> mynums;\\n    vector<vector<int>> res;\\n    vector<int> visited;\\n\\n    TreeNode* buildTree(TreeNode* cur, int val){\\n        if(cur == NULL){\\n            return new TreeNode(val);\\n        }\\n        else if(val < cur->val){\\n            cur->left = buildTree(cur->left, val);\\n        }\\n        else if(val > cur->val){\\n            cur->right = buildTree(cur->right, val);\\n        }\\n\\n        return cur;\\n    }\\n\\n    void traverse(TreeNode* cur){\\n        if(cur == NULL){\\n            return;\\n        }\\n\\n        traverse(cur->left);\\n        traverse(cur->right);\\n        if(cur->left)\\n            adj[cur->val].push_back(cur->left->val);\\n        if(cur->right)\\n            adj[cur->val].push_back(cur->right->val);\\n    }\\n\\n    void dfs(){\\n        for(int v : mynums){\\n            if(indeg[v] == 0 and !visited[v]){\\n                for(int x : adj[v]){indeg[x] --;}\\n                onPath.push_back(v);\\n                visited[v] = 1;\\n                dfs();\\n                onPath.pop_back();\\n                visited[v] = 0;\\n                for(int x : adj[v]) indeg[x] ++;\\n            }\\n        }\\n\\n        if(onPath.size() == mynums.size()){\\n            res.push_back(onPath);\\n        }\\n    }\\n\\n    int numOfWays(vector<int>& nums) {\\n        /* Build tree*/\\n        for(int x : nums){\\n            if(root == NULL){\\n                root = buildTree(root, x);\\n            }else{\\n                TreeNode* rc = buildTree(root, x);\\n            }\\n\\n            indeg[x] = 1;\\n        }\\n\\n        /* Initialize the graph */\\n        int max_ele = *max_element(nums.begin(), nums.end());\\n        visited.assign(max_ele + 1, 0);\\n        indeg[nums[0]] = 0;\\n        mynums = nums;\\n        traverse(root);\\n\\n        /* DFS */\\n        dfs();\\n\\n        /* res contains all topological orderings */\\n        return res.size() - 1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648828,
                "title": "c-100-100-o-n-dfs",
                "content": "# Intuition\\nConstruct the tree, then calculate the result.\\n\\n# Approach\\nAt first construct the tree with the number of child-nodes (field `Count` in `NumOfWaysTree` class):\\n```\\nvar root = ConstructTree(nums);\\n...\\nprivate class NumOfWaysTree\\n{\\n    public int Val;\\n    public int Count;\\n    public NumOfWaysTree Left;\\n    public NumOfWaysTree Right;\\n    public NumOfWaysTree(int value = 0)\\n    {\\n        Val = value;\\n        Count = 1;\\n    }\\n}\\n```\\nThen call the method\\n```\\nprivate BigInteger NumOfWays(NumOfWaysTree root)\\n```\\nrecursively.\\nIn this method first of all calctulate the number of combinations:\\n```\\nBigInteger combinL = 1;\\nBigInteger fact = 1;\\nif (root.Left != null)\\n{\\n    var limit = Math.Min(root.Left.Count, root.Count - 1 - root.Left.Count);\\n    for (int i = 0; i < limit; i++)\\n    {\\n        combinL *= (root.Count - 1 - i);\\n        fact *= (i + 1);\\n    }\\n}\\ncombinL /= fact;\\n```\\nand then multiply the result by the values for the left and right subnodes:\\n```\\nvar rs = combinL % 1_000_000_007;\\nif (root.Left != null)\\n{\\n    rs *= NumOfWays(root.Left);\\n    rs %= 1_000_000_007;\\n}\\nif (root.Right != null)\\n{\\n    rs *= NumOfWays(root.Right);\\n    rs %= 1_000_000_007;\\n}\\nreturn rs;\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(len(nums))$$\\n\\n- Space complexity:\\n$$O(len(nums))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumOfWays(int[] nums) {\\n        var root = ConstructTree(nums);\\n        var rs = NumOfWays(root) - 1;\\n        return (int)rs;\\n    }\\n    private BigInteger NumOfWays(NumOfWaysTree root)\\n    {\\n        BigInteger combinL = 1;\\n        BigInteger fact = 1;\\n        if (root.Left != null)\\n        {\\n            var limit = Math.Min(root.Left.Count, root.Count - 1 - root.Left.Count);\\n            for (int i = 0; i < limit; i++)\\n            {\\n                combinL *= (root.Count - 1 - i);\\n                fact *= (i + 1);\\n            }\\n        }\\n        combinL /= fact;\\n        var rs = combinL % 1_000_000_007;\\n        if (root.Left != null)\\n        {\\n            rs *= NumOfWays(root.Left);\\n            rs %= 1_000_000_007;\\n        }\\n        if (root.Right != null)\\n        {\\n            rs *= NumOfWays(root.Right);\\n            rs %= 1_000_000_007;\\n        }\\n        return rs;\\n    }\\n    private NumOfWaysTree ConstructTree(int[] nums)\\n    {\\n        var rs = new NumOfWaysTree(nums[0]);\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            AddNode(nums[i], rs);\\n        }\\n        AddNodeCount(rs);\\n        return rs;\\n    }\\n    private void AddNodeCount(NumOfWaysTree root)\\n    {\\n        root.Count = 1;\\n        if (root.Left != null)\\n        {\\n            AddNodeCount(root.Left);\\n            root.Count += root.Left.Count;\\n        }\\n        if (root.Right != null)\\n        {\\n            AddNodeCount(root.Right);\\n            root.Count += root.Right.Count;\\n        }\\n    }\\n    private void AddNode(int val, NumOfWaysTree root)\\n    {\\n        if (val < root.Val)\\n        {\\n            if (root.Left == null)\\n            {\\n                root.Left = new NumOfWaysTree(val);\\n            }\\n            else\\n            {\\n                AddNode(val, root.Left);\\n            }\\n        }\\n        else\\n        {\\n            if (root.Right == null)\\n            {\\n                root.Right = new NumOfWaysTree(val);\\n            }\\n            else\\n            {\\n                AddNode(val, root.Right);\\n            }\\n        }\\n    }\\n    private class NumOfWaysTree\\n    {\\n        public int Val;\\n        public int Count;\\n        public NumOfWaysTree Left;\\n        public NumOfWaysTree Right;\\n        public NumOfWaysTree(int value = 0)\\n        {\\n            Val = value;\\n            Count = 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Divide and Conquer",
                    "Depth-First Search"
                ],
                "code": "```\\nvar root = ConstructTree(nums);\\n...\\nprivate class NumOfWaysTree\\n{\\n    public int Val;\\n    public int Count;\\n    public NumOfWaysTree Left;\\n    public NumOfWaysTree Right;\\n    public NumOfWaysTree(int value = 0)\\n    {\\n        Val = value;\\n        Count = 1;\\n    }\\n}\\n```\n```\\nprivate BigInteger NumOfWays(NumOfWaysTree root)\\n```\n```\\nBigInteger combinL = 1;\\nBigInteger fact = 1;\\nif (root.Left != null)\\n{\\n    var limit = Math.Min(root.Left.Count, root.Count - 1 - root.Left.Count);\\n    for (int i = 0; i < limit; i++)\\n    {\\n        combinL *= (root.Count - 1 - i);\\n        fact *= (i + 1);\\n    }\\n}\\ncombinL /= fact;\\n```\n```\\nvar rs = combinL % 1_000_000_007;\\nif (root.Left != null)\\n{\\n    rs *= NumOfWays(root.Left);\\n    rs %= 1_000_000_007;\\n}\\nif (root.Right != null)\\n{\\n    rs *= NumOfWays(root.Right);\\n    rs %= 1_000_000_007;\\n}\\nreturn rs;\\n```\n```\\npublic class Solution {\\n    public int NumOfWays(int[] nums) {\\n        var root = ConstructTree(nums);\\n        var rs = NumOfWays(root) - 1;\\n        return (int)rs;\\n    }\\n    private BigInteger NumOfWays(NumOfWaysTree root)\\n    {\\n        BigInteger combinL = 1;\\n        BigInteger fact = 1;\\n        if (root.Left != null)\\n        {\\n            var limit = Math.Min(root.Left.Count, root.Count - 1 - root.Left.Count);\\n            for (int i = 0; i < limit; i++)\\n            {\\n                combinL *= (root.Count - 1 - i);\\n                fact *= (i + 1);\\n            }\\n        }\\n        combinL /= fact;\\n        var rs = combinL % 1_000_000_007;\\n        if (root.Left != null)\\n        {\\n            rs *= NumOfWays(root.Left);\\n            rs %= 1_000_000_007;\\n        }\\n        if (root.Right != null)\\n        {\\n            rs *= NumOfWays(root.Right);\\n            rs %= 1_000_000_007;\\n        }\\n        return rs;\\n    }\\n    private NumOfWaysTree ConstructTree(int[] nums)\\n    {\\n        var rs = new NumOfWaysTree(nums[0]);\\n        for (int i = 1; i < nums.Length; i++)\\n        {\\n            AddNode(nums[i], rs);\\n        }\\n        AddNodeCount(rs);\\n        return rs;\\n    }\\n    private void AddNodeCount(NumOfWaysTree root)\\n    {\\n        root.Count = 1;\\n        if (root.Left != null)\\n        {\\n            AddNodeCount(root.Left);\\n            root.Count += root.Left.Count;\\n        }\\n        if (root.Right != null)\\n        {\\n            AddNodeCount(root.Right);\\n            root.Count += root.Right.Count;\\n        }\\n    }\\n    private void AddNode(int val, NumOfWaysTree root)\\n    {\\n        if (val < root.Val)\\n        {\\n            if (root.Left == null)\\n            {\\n                root.Left = new NumOfWaysTree(val);\\n            }\\n            else\\n            {\\n                AddNode(val, root.Left);\\n            }\\n        }\\n        else\\n        {\\n            if (root.Right == null)\\n            {\\n                root.Right = new NumOfWaysTree(val);\\n            }\\n            else\\n            {\\n                AddNode(val, root.Right);\\n            }\\n        }\\n    }\\n    private class NumOfWaysTree\\n    {\\n        public int Val;\\n        public int Count;\\n        public NumOfWaysTree Left;\\n        public NumOfWaysTree Right;\\n        public NumOfWaysTree(int value = 0)\\n        {\\n            Val = value;\\n            Count = 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648559,
                "title": "1569-number-of-ways-to-reorder-array-to-get-same-bst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nMOD = 10**9 + 7\\n\\nclass Solution(object):\\n    def numOfWays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def count_ways(nums):\\n            if len(nums) <= 2:\\n                return 1\\n\\n            root = nums[0]\\n            left_nums = [num for num in nums[1:] if num < root]\\n            right_nums = [num for num in nums[1:] if num > root]\\n\\n            left_ways = count_ways(left_nums)\\n            right_ways = count_ways(right_nums)\\n\\n            num_ways = (\\n                self.combination(len(nums) - 1, len(left_nums)) * \\n                left_ways * right_ways\\n            )\\n\\n            return num_ways\\n\\n        return (count_ways(nums) - 1) % MOD\\n\\n    def combination(self, n, k):\\n        if k > n - k:\\n            k = n - k\\n\\n        res = 1\\n        for i in range(k):\\n            res = (res * (n - i)) // (i + 1)\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nMOD = 10**9 + 7\\n\\nclass Solution(object):\\n    def numOfWays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def count_ways(nums):\\n            if len(nums) <= 2:\\n                return 1\\n\\n            root = nums[0]\\n            left_nums = [num for num in nums[1:] if num < root]\\n            right_nums = [num for num in nums[1:] if num > root]\\n\\n            left_ways = count_ways(left_nums)\\n            right_ways = count_ways(right_nums)\\n\\n            num_ways = (\\n                self.combination(len(nums) - 1, len(left_nums)) * \\n                left_ways * right_ways\\n            )\\n\\n            return num_ways\\n\\n        return (count_ways(nums) - 1) % MOD\\n\\n    def combination(self, n, k):\\n        if k > n - k:\\n            k = n - k\\n\\n        res = 1\\n        for i in range(k):\\n            res = (res * (n - i)) // (i + 1)\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1931123,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931107,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931348,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931145,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931242,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931167,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1566638,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931163,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931177,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931396,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931123,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931107,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931348,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931145,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931242,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931167,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1566638,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931163,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931177,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931396,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "\\'we dont really want to hire you\\' "
                    },
                    {
                        "username": "ursachu",
                        "content": "My streak!!, No my streak!!!!"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@dkochetov](/dkochetov) So we are looking at the the left and right tree in the first level and not the subsequent subtrees"
                    },
                    {
                        "username": "dkochetov",
                        "content": "[@ursachu](/ursachu) Notice that those BSTs are not balanced. From the 1st example:\nBuilding BST with [2,1,3]:\n```\n  (2)    (2)      (2)\n         /        / \\\n       (1)      (1)  (3)  \n```\nBuilding BST with [2,3,1]:\n```\n  (2)    (2)       (2)\n           \\       / \\\n           (3)   (1)  (3)  \n```\nBuilding BST with [3,2,1]:\n```\n  (3)    (3)       (3)\n         /         / \n       (2)       (2) \n                 /\n               (1)\n```\nBuilding BST with [1,3,2]:\n```\n  (1)    (1)       (1)\n           \\          \\\n           (3)         (3)  \n                       /\n                     (2)\n```\nAnd similar for [3,1,2] and [1,2,3].\n\nWe can shuffle the initial [2,1,3] only one way ([2,3,1]), so the BST would look the same."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "my 107 day streak :\\'(\\n"
                    },
                    {
                        "username": "ursachu",
                        "content": "[@yinboshi13](/yinboshi13) I cant even figure out how there can be more than one BST. Time to go for the editorial"
                    },
                    {
                        "username": "user8876Ek",
                        "content": "Just get the idea of how logic can be...., theres more time bro, lets not give up the streak!"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "it\\'s only been 3 hrs..."
                    },
                    {
                        "username": "amshanaks313",
                        "content": "I don\\'t want to hear anyone say - \"This should\\'ve been tagged easy/medium\""
                    },
                    {
                        "username": "mshoosterman",
                        "content": "meh, if your language has a decent nCr function built in, then yeah definitely this is a medium. "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "[@Dzuchun](/Dzuchun) You can\\'t always rely on hints as a crutch lol.  It\\'s not particularly hard once you find the trick, but finding that trick takes a lot of effort.\\n\\nNot to mention you haven\\'t passed the tests..."
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Provided hints given, that\\'s in fact medium.\\nYou can instantly come up with intended algorithm after reading these.\\n\\nStill can\\'t pass the tests, tho..."
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "I am finding such comment, please don\\'t FIR...!"
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Leetcode : relaxing time is over"
                    },
                    {
                        "username": "ducthinh121994",
                        "content": "nah, relaxing time just started"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "[@Aadil42](/Aadil42) Let\\'s do it boys"
                    },
                    {
                        "username": "Aadil42",
                        "content": "I told you."
                    },
                    {
                        "username": "memercrypto0",
                        "content": "Out of my league, same as of my crush"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "You are not alone. "
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "can relate T.T"
                    },
                    {
                        "username": "caoxz0815",
                        "content": "GG im leaving this industry \\uD83D\\uDE2D"
                    },
                    {
                        "username": "laruru",
                        "content": "What does it mean by inserting `nums` in order?\\nCan anyone explain using the first example `[2,1,3]`, why `[2,3,1]` gives us the same BST?"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "In order to understand that start inserting elements into a BST one after the other and you will understand it better "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@deCodeIt](/deCodeIt) Noice Explanation mate ! "
                    },
                    {
                        "username": "deCodeIt",
                        "content": "The array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "orbuluh",
                        "content": "BST: For every node, \"all\" the values in its left subtree are less than the node\\'s value, and \"all\"\" the values in its right subtree are greater than the node\\'s value.\\n\\nHence, given array nums, to form a BST by \"inserting the elements of nums in order into an initially empty BST\", wll be a process like...\\n\\n[3 4 5 1 2] -> first node is 3, root is 3\\n-> next node: 4, can only be right of 3\\n-> next node: 5, can only be right of 4\\n-> next node: 1, can only be left of 3\\n-> next node: 2, can only be right of 1\\n\\n=> hence, it looks like      \\n```\\n                              3\\n                         1        4\\n                           2        5\\n```"
                    },
                    {
                        "username": "c4tdog",
                        "content": "it means, you grab every number and insert it to a tree, <b>created so far</b>. Take a look at second example: why 3,2,1,4,5 is not a correct answer? B/c if you take 2 before 1, the left child of 3 (root) will be 2, whereas 1 is needed."
                    },
                    {
                        "username": "NekoShadow",
                        "content": "It is because they both use 2 as root, 1 as left child and 3 as right child. In contrast, [3,2,1] generates a different BST because it uses 3 as root, 2 as left child, and 1 as left child\\'s left child. \\n\\nThis problem is asking the number of ways to order nums so that the resulting array can generates the same BST as the original array."
                    },
                    {
                        "username": "avinashkumar123",
                        "content": "same doubt\\n"
                    },
                    {
                        "username": "SightVanish",
                        "content": "My weak brain cannot handle this"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Real"
                    },
                    {
                        "username": "mufia001",
                        "content": "Hint: You won't be able to solve this without the knowledge of pascal triangle and binomial coefficient. I suggest reading the Editorial 3 times (without coding part) before implementing the solution"
                    },
                    {
                        "username": "ktnaneri",
                        "content": "What language are you all speaking here? "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Managed to did it without yet looking into Editorial \\uD83D\\uDCAA\\nI\\'ve come to binomial coefficients, but calculated them without triangle"
                    },
                    {
                        "username": "beardedone",
                        "content": "Since 1e9+7 is prime, you can use Fermat\\'s Little Theorem to calculate modular multiplicative inverse.... This one was brutal."
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "even then i couldn\\'t know that it needed Binomial coeff math."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "from math import comb"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "> You won\\'t be able to solve this without the knowledge of pascal triangle and binomial coefficient\\n\\nSounds like a challenge"
                    },
                    {
                        "username": "mistyotter",
                        "content": "\"We hired that Asian boy who won the ICPC, and now we need to delicately dismiss all the other candidates\""
                    }
                ]
            },
            {
                "id": 1931132,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "..And now I understand that I don't understand how the hell this array is mapped into a tree"
                    },
                    {
                        "username": "mossej",
                        "content": "First element of nums is the root. All remaining nums < root go to the left, nums > root goes to the right. "
                    },
                    {
                        "username": "khanhtc",
                        "content": "it\\'s not how the array is mapped to the BST, it\\'s how to construct a BST with nodes value given from an array in the array order."
                    },
                    {
                        "username": "GOBurrito",
                        "content": "it iterates through the array and each number is placed in the most fitting spot for it on the current tree"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a math problem! It needs to compute lots of combination numbers!!!\nUse recursion, if the subproblem for left subtree and right subtree are solved, with the number l and r, Use the following formula:\n$$\nTotalNumber=l\t*  r\t* C^{N-1}_{Len(left\\_subtree)}-1\n$$\n # Why multiplication? \nThe fundamental principle of counting/rule of product or multiplication principle  says:\n>  if there are a ways of doing something and b ways of doing another thing, then there are a · b ways of performing both actions.\n\nThis test case makes using direct method computing  $C^{N-1}_{Len(left\\_subtree)}$ impossible in C++, even using unsigned long long!\n```\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\n```"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Uh oh, easy strike ends guys."
                    },
                    {
                        "username": "hridoy100",
                        "content": "## Leetcode C++ and Java compilers are giving runtime error!\nAfter submitting got these errors:\n\n```Java []\n[0.015s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\n```\n```C++ []\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n```\nThe reason is that global/static variables affect the program state from one test case to another. The system executes all testcases using the same program instance. This is their development issue. For python3 this issue doesn't pops up."
                    },
                    {
                        "username": "user3954sk",
                        "content": "This can be solved using the \"programming way\" - DP and recursion - or by starting with all possible combinations of 1..n and working out what fraction of them are actually valid.\\nFor the latter, ask yourself: (answers below)\\n1. What is the total number of permutations of 1..n? \\n2. Given that the first number in the source is \"a\", any combination that doesn\\'t have \"a\" as the start is invalid.  What fraction of all starting combinations are therefore valid?  \\n\\nNow we have 2 trees - we have a left hand tree with numbers 1..a-1, and a right hand tree a+1..n\\nThese two trees are completely intermingled.\\n3. Let\\'s look at the second number in the source \"b\".  Assuming it is in the range 1..a-1, we can say that of all the remaining valid combinations, only ones that have the first number in that range equal to \"b\" will be valid.  So the number of valid permutations must be reduced to 1/y where y = ?\\n\\nContinue with all the remaining numbers in the array.  The range that they are part of gets smaller until it is the only number in the range (in which case the fraction is 1/1.\\nFor each fraction from questions 2,3, and all the remaining numbers, multiple the divisors together (we want to do the actual division only once) and don\\'t forget to do the mod operation.\\nNow do modular divide (see below) of the total (from question 1) by the divisor(answer 2 * answer 3 * ....)\\nFinally subtract 1 (the original combination)\\n\\nIn this way you only need to keep track of all numbers previously seen in a way that enables you to ask \"how big is the range of possible numbers that the new number is in?\"\\n\\nModular divide\\n===========\\nFermat\\'s Little Theorem for modular division, (the restriction on this is always valid for prime numbers such as 10^9+7)\\n1/a mod b -> a^(b-2) mod b\\n\\nDo this a c * a + d * a^2 + e * a^4 + f * a^8 ... Where c,d,e,f,... corresponds to the bit representation of b\\n\\nAnswers:\\n=======\\n1. n!\\n2. Since we have n possible numbers, only 1/n of them are going to be valid\\n3. Since the first number is in range 1..a-1, the number that have b first will be 1/(a-1)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You can\\'t do it with DP - how will you cache the results? The key would be a set."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Holy moly , the Related Topics Tab is as long as a question."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "First, let's consider the properties of a binary search tree (BST). In a BST, all elements in the left subtree of a node are smaller than the node, and all elements in the right subtree are greater than the node. Therefore, the first number in the reordered array will always be the root of the BST.\n\nNow, let's consider the numbers smaller than the root and the numbers larger than the root separately.\n\nFor the numbers smaller than the root, they will form the left subtree. We can recursively calculate the number of different ways to reorder these numbers to form the left subtree.\n\nSimilarly, for the numbers larger than the root, they will form the right subtree. We can recursively calculate the number of different ways to reorder these numbers to form the right subtree.\n\nTo merge the results, we need to consider the number of ways to order x elements in x+y positions. Here, x represents the number of elements in the left subtree, and y represents the number of elements in the right subtree.\n\nTherefore, the total number of different ways to reorder nums such that the BST formed is identical to the original BST formed from nums is:\n\nways = `number of ways to reorder left subtree` * `number of ways to reorder right subtree` * `number of ways to order x elements in x+y positions`"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Oh my god!! Okay, Its happening! Everybody stay calm! Everybody stay CALM!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "et tu, leetcode ?"
                    },
                    {
                        "username": "dEAthWednesday",
                        "content": "fav comment right here"
                    }
                ]
            },
            {
                "id": 1931220,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "..And now I understand that I don't understand how the hell this array is mapped into a tree"
                    },
                    {
                        "username": "mossej",
                        "content": "First element of nums is the root. All remaining nums < root go to the left, nums > root goes to the right. "
                    },
                    {
                        "username": "khanhtc",
                        "content": "it\\'s not how the array is mapped to the BST, it\\'s how to construct a BST with nodes value given from an array in the array order."
                    },
                    {
                        "username": "GOBurrito",
                        "content": "it iterates through the array and each number is placed in the most fitting spot for it on the current tree"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a math problem! It needs to compute lots of combination numbers!!!\nUse recursion, if the subproblem for left subtree and right subtree are solved, with the number l and r, Use the following formula:\n$$\nTotalNumber=l\t*  r\t* C^{N-1}_{Len(left\\_subtree)}-1\n$$\n # Why multiplication? \nThe fundamental principle of counting/rule of product or multiplication principle  says:\n>  if there are a ways of doing something and b ways of doing another thing, then there are a · b ways of performing both actions.\n\nThis test case makes using direct method computing  $C^{N-1}_{Len(left\\_subtree)}$ impossible in C++, even using unsigned long long!\n```\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\n```"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Uh oh, easy strike ends guys."
                    },
                    {
                        "username": "hridoy100",
                        "content": "## Leetcode C++ and Java compilers are giving runtime error!\nAfter submitting got these errors:\n\n```Java []\n[0.015s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\n```\n```C++ []\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n```\nThe reason is that global/static variables affect the program state from one test case to another. The system executes all testcases using the same program instance. This is their development issue. For python3 this issue doesn't pops up."
                    },
                    {
                        "username": "user3954sk",
                        "content": "This can be solved using the \"programming way\" - DP and recursion - or by starting with all possible combinations of 1..n and working out what fraction of them are actually valid.\\nFor the latter, ask yourself: (answers below)\\n1. What is the total number of permutations of 1..n? \\n2. Given that the first number in the source is \"a\", any combination that doesn\\'t have \"a\" as the start is invalid.  What fraction of all starting combinations are therefore valid?  \\n\\nNow we have 2 trees - we have a left hand tree with numbers 1..a-1, and a right hand tree a+1..n\\nThese two trees are completely intermingled.\\n3. Let\\'s look at the second number in the source \"b\".  Assuming it is in the range 1..a-1, we can say that of all the remaining valid combinations, only ones that have the first number in that range equal to \"b\" will be valid.  So the number of valid permutations must be reduced to 1/y where y = ?\\n\\nContinue with all the remaining numbers in the array.  The range that they are part of gets smaller until it is the only number in the range (in which case the fraction is 1/1.\\nFor each fraction from questions 2,3, and all the remaining numbers, multiple the divisors together (we want to do the actual division only once) and don\\'t forget to do the mod operation.\\nNow do modular divide (see below) of the total (from question 1) by the divisor(answer 2 * answer 3 * ....)\\nFinally subtract 1 (the original combination)\\n\\nIn this way you only need to keep track of all numbers previously seen in a way that enables you to ask \"how big is the range of possible numbers that the new number is in?\"\\n\\nModular divide\\n===========\\nFermat\\'s Little Theorem for modular division, (the restriction on this is always valid for prime numbers such as 10^9+7)\\n1/a mod b -> a^(b-2) mod b\\n\\nDo this a c * a + d * a^2 + e * a^4 + f * a^8 ... Where c,d,e,f,... corresponds to the bit representation of b\\n\\nAnswers:\\n=======\\n1. n!\\n2. Since we have n possible numbers, only 1/n of them are going to be valid\\n3. Since the first number is in range 1..a-1, the number that have b first will be 1/(a-1)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You can\\'t do it with DP - how will you cache the results? The key would be a set."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Holy moly , the Related Topics Tab is as long as a question."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "First, let's consider the properties of a binary search tree (BST). In a BST, all elements in the left subtree of a node are smaller than the node, and all elements in the right subtree are greater than the node. Therefore, the first number in the reordered array will always be the root of the BST.\n\nNow, let's consider the numbers smaller than the root and the numbers larger than the root separately.\n\nFor the numbers smaller than the root, they will form the left subtree. We can recursively calculate the number of different ways to reorder these numbers to form the left subtree.\n\nSimilarly, for the numbers larger than the root, they will form the right subtree. We can recursively calculate the number of different ways to reorder these numbers to form the right subtree.\n\nTo merge the results, we need to consider the number of ways to order x elements in x+y positions. Here, x represents the number of elements in the left subtree, and y represents the number of elements in the right subtree.\n\nTherefore, the total number of different ways to reorder nums such that the BST formed is identical to the original BST formed from nums is:\n\nways = `number of ways to reorder left subtree` * `number of ways to reorder right subtree` * `number of ways to order x elements in x+y positions`"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Oh my god!! Okay, Its happening! Everybody stay calm! Everybody stay CALM!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "et tu, leetcode ?"
                    },
                    {
                        "username": "dEAthWednesday",
                        "content": "fav comment right here"
                    }
                ]
            },
            {
                "id": 1931117,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "..And now I understand that I don't understand how the hell this array is mapped into a tree"
                    },
                    {
                        "username": "mossej",
                        "content": "First element of nums is the root. All remaining nums < root go to the left, nums > root goes to the right. "
                    },
                    {
                        "username": "khanhtc",
                        "content": "it\\'s not how the array is mapped to the BST, it\\'s how to construct a BST with nodes value given from an array in the array order."
                    },
                    {
                        "username": "GOBurrito",
                        "content": "it iterates through the array and each number is placed in the most fitting spot for it on the current tree"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a math problem! It needs to compute lots of combination numbers!!!\nUse recursion, if the subproblem for left subtree and right subtree are solved, with the number l and r, Use the following formula:\n$$\nTotalNumber=l\t*  r\t* C^{N-1}_{Len(left\\_subtree)}-1\n$$\n # Why multiplication? \nThe fundamental principle of counting/rule of product or multiplication principle  says:\n>  if there are a ways of doing something and b ways of doing another thing, then there are a · b ways of performing both actions.\n\nThis test case makes using direct method computing  $C^{N-1}_{Len(left\\_subtree)}$ impossible in C++, even using unsigned long long!\n```\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\n```"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Uh oh, easy strike ends guys."
                    },
                    {
                        "username": "hridoy100",
                        "content": "## Leetcode C++ and Java compilers are giving runtime error!\nAfter submitting got these errors:\n\n```Java []\n[0.015s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\n```\n```C++ []\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n```\nThe reason is that global/static variables affect the program state from one test case to another. The system executes all testcases using the same program instance. This is their development issue. For python3 this issue doesn't pops up."
                    },
                    {
                        "username": "user3954sk",
                        "content": "This can be solved using the \"programming way\" - DP and recursion - or by starting with all possible combinations of 1..n and working out what fraction of them are actually valid.\\nFor the latter, ask yourself: (answers below)\\n1. What is the total number of permutations of 1..n? \\n2. Given that the first number in the source is \"a\", any combination that doesn\\'t have \"a\" as the start is invalid.  What fraction of all starting combinations are therefore valid?  \\n\\nNow we have 2 trees - we have a left hand tree with numbers 1..a-1, and a right hand tree a+1..n\\nThese two trees are completely intermingled.\\n3. Let\\'s look at the second number in the source \"b\".  Assuming it is in the range 1..a-1, we can say that of all the remaining valid combinations, only ones that have the first number in that range equal to \"b\" will be valid.  So the number of valid permutations must be reduced to 1/y where y = ?\\n\\nContinue with all the remaining numbers in the array.  The range that they are part of gets smaller until it is the only number in the range (in which case the fraction is 1/1.\\nFor each fraction from questions 2,3, and all the remaining numbers, multiple the divisors together (we want to do the actual division only once) and don\\'t forget to do the mod operation.\\nNow do modular divide (see below) of the total (from question 1) by the divisor(answer 2 * answer 3 * ....)\\nFinally subtract 1 (the original combination)\\n\\nIn this way you only need to keep track of all numbers previously seen in a way that enables you to ask \"how big is the range of possible numbers that the new number is in?\"\\n\\nModular divide\\n===========\\nFermat\\'s Little Theorem for modular division, (the restriction on this is always valid for prime numbers such as 10^9+7)\\n1/a mod b -> a^(b-2) mod b\\n\\nDo this a c * a + d * a^2 + e * a^4 + f * a^8 ... Where c,d,e,f,... corresponds to the bit representation of b\\n\\nAnswers:\\n=======\\n1. n!\\n2. Since we have n possible numbers, only 1/n of them are going to be valid\\n3. Since the first number is in range 1..a-1, the number that have b first will be 1/(a-1)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You can\\'t do it with DP - how will you cache the results? The key would be a set."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Holy moly , the Related Topics Tab is as long as a question."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "First, let's consider the properties of a binary search tree (BST). In a BST, all elements in the left subtree of a node are smaller than the node, and all elements in the right subtree are greater than the node. Therefore, the first number in the reordered array will always be the root of the BST.\n\nNow, let's consider the numbers smaller than the root and the numbers larger than the root separately.\n\nFor the numbers smaller than the root, they will form the left subtree. We can recursively calculate the number of different ways to reorder these numbers to form the left subtree.\n\nSimilarly, for the numbers larger than the root, they will form the right subtree. We can recursively calculate the number of different ways to reorder these numbers to form the right subtree.\n\nTo merge the results, we need to consider the number of ways to order x elements in x+y positions. Here, x represents the number of elements in the left subtree, and y represents the number of elements in the right subtree.\n\nTherefore, the total number of different ways to reorder nums such that the BST formed is identical to the original BST formed from nums is:\n\nways = `number of ways to reorder left subtree` * `number of ways to reorder right subtree` * `number of ways to order x elements in x+y positions`"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Oh my god!! Okay, Its happening! Everybody stay calm! Everybody stay CALM!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "et tu, leetcode ?"
                    },
                    {
                        "username": "dEAthWednesday",
                        "content": "fav comment right here"
                    }
                ]
            },
            {
                "id": 1932384,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "..And now I understand that I don't understand how the hell this array is mapped into a tree"
                    },
                    {
                        "username": "mossej",
                        "content": "First element of nums is the root. All remaining nums < root go to the left, nums > root goes to the right. "
                    },
                    {
                        "username": "khanhtc",
                        "content": "it\\'s not how the array is mapped to the BST, it\\'s how to construct a BST with nodes value given from an array in the array order."
                    },
                    {
                        "username": "GOBurrito",
                        "content": "it iterates through the array and each number is placed in the most fitting spot for it on the current tree"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a math problem! It needs to compute lots of combination numbers!!!\nUse recursion, if the subproblem for left subtree and right subtree are solved, with the number l and r, Use the following formula:\n$$\nTotalNumber=l\t*  r\t* C^{N-1}_{Len(left\\_subtree)}-1\n$$\n # Why multiplication? \nThe fundamental principle of counting/rule of product or multiplication principle  says:\n>  if there are a ways of doing something and b ways of doing another thing, then there are a · b ways of performing both actions.\n\nThis test case makes using direct method computing  $C^{N-1}_{Len(left\\_subtree)}$ impossible in C++, even using unsigned long long!\n```\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\n```"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Uh oh, easy strike ends guys."
                    },
                    {
                        "username": "hridoy100",
                        "content": "## Leetcode C++ and Java compilers are giving runtime error!\nAfter submitting got these errors:\n\n```Java []\n[0.015s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\n```\n```C++ []\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n```\nThe reason is that global/static variables affect the program state from one test case to another. The system executes all testcases using the same program instance. This is their development issue. For python3 this issue doesn't pops up."
                    },
                    {
                        "username": "user3954sk",
                        "content": "This can be solved using the \"programming way\" - DP and recursion - or by starting with all possible combinations of 1..n and working out what fraction of them are actually valid.\\nFor the latter, ask yourself: (answers below)\\n1. What is the total number of permutations of 1..n? \\n2. Given that the first number in the source is \"a\", any combination that doesn\\'t have \"a\" as the start is invalid.  What fraction of all starting combinations are therefore valid?  \\n\\nNow we have 2 trees - we have a left hand tree with numbers 1..a-1, and a right hand tree a+1..n\\nThese two trees are completely intermingled.\\n3. Let\\'s look at the second number in the source \"b\".  Assuming it is in the range 1..a-1, we can say that of all the remaining valid combinations, only ones that have the first number in that range equal to \"b\" will be valid.  So the number of valid permutations must be reduced to 1/y where y = ?\\n\\nContinue with all the remaining numbers in the array.  The range that they are part of gets smaller until it is the only number in the range (in which case the fraction is 1/1.\\nFor each fraction from questions 2,3, and all the remaining numbers, multiple the divisors together (we want to do the actual division only once) and don\\'t forget to do the mod operation.\\nNow do modular divide (see below) of the total (from question 1) by the divisor(answer 2 * answer 3 * ....)\\nFinally subtract 1 (the original combination)\\n\\nIn this way you only need to keep track of all numbers previously seen in a way that enables you to ask \"how big is the range of possible numbers that the new number is in?\"\\n\\nModular divide\\n===========\\nFermat\\'s Little Theorem for modular division, (the restriction on this is always valid for prime numbers such as 10^9+7)\\n1/a mod b -> a^(b-2) mod b\\n\\nDo this a c * a + d * a^2 + e * a^4 + f * a^8 ... Where c,d,e,f,... corresponds to the bit representation of b\\n\\nAnswers:\\n=======\\n1. n!\\n2. Since we have n possible numbers, only 1/n of them are going to be valid\\n3. Since the first number is in range 1..a-1, the number that have b first will be 1/(a-1)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You can\\'t do it with DP - how will you cache the results? The key would be a set."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Holy moly , the Related Topics Tab is as long as a question."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "First, let's consider the properties of a binary search tree (BST). In a BST, all elements in the left subtree of a node are smaller than the node, and all elements in the right subtree are greater than the node. Therefore, the first number in the reordered array will always be the root of the BST.\n\nNow, let's consider the numbers smaller than the root and the numbers larger than the root separately.\n\nFor the numbers smaller than the root, they will form the left subtree. We can recursively calculate the number of different ways to reorder these numbers to form the left subtree.\n\nSimilarly, for the numbers larger than the root, they will form the right subtree. We can recursively calculate the number of different ways to reorder these numbers to form the right subtree.\n\nTo merge the results, we need to consider the number of ways to order x elements in x+y positions. Here, x represents the number of elements in the left subtree, and y represents the number of elements in the right subtree.\n\nTherefore, the total number of different ways to reorder nums such that the BST formed is identical to the original BST formed from nums is:\n\nways = `number of ways to reorder left subtree` * `number of ways to reorder right subtree` * `number of ways to order x elements in x+y positions`"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Oh my god!! Okay, Its happening! Everybody stay calm! Everybody stay CALM!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "et tu, leetcode ?"
                    },
                    {
                        "username": "dEAthWednesday",
                        "content": "fav comment right here"
                    }
                ]
            },
            {
                "id": 1931498,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "..And now I understand that I don't understand how the hell this array is mapped into a tree"
                    },
                    {
                        "username": "mossej",
                        "content": "First element of nums is the root. All remaining nums < root go to the left, nums > root goes to the right. "
                    },
                    {
                        "username": "khanhtc",
                        "content": "it\\'s not how the array is mapped to the BST, it\\'s how to construct a BST with nodes value given from an array in the array order."
                    },
                    {
                        "username": "GOBurrito",
                        "content": "it iterates through the array and each number is placed in the most fitting spot for it on the current tree"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a math problem! It needs to compute lots of combination numbers!!!\nUse recursion, if the subproblem for left subtree and right subtree are solved, with the number l and r, Use the following formula:\n$$\nTotalNumber=l\t*  r\t* C^{N-1}_{Len(left\\_subtree)}-1\n$$\n # Why multiplication? \nThe fundamental principle of counting/rule of product or multiplication principle  says:\n>  if there are a ways of doing something and b ways of doing another thing, then there are a · b ways of performing both actions.\n\nThis test case makes using direct method computing  $C^{N-1}_{Len(left\\_subtree)}$ impossible in C++, even using unsigned long long!\n```\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\n```"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Uh oh, easy strike ends guys."
                    },
                    {
                        "username": "hridoy100",
                        "content": "## Leetcode C++ and Java compilers are giving runtime error!\nAfter submitting got these errors:\n\n```Java []\n[0.015s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\n```\n```C++ []\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n```\nThe reason is that global/static variables affect the program state from one test case to another. The system executes all testcases using the same program instance. This is their development issue. For python3 this issue doesn't pops up."
                    },
                    {
                        "username": "user3954sk",
                        "content": "This can be solved using the \"programming way\" - DP and recursion - or by starting with all possible combinations of 1..n and working out what fraction of them are actually valid.\\nFor the latter, ask yourself: (answers below)\\n1. What is the total number of permutations of 1..n? \\n2. Given that the first number in the source is \"a\", any combination that doesn\\'t have \"a\" as the start is invalid.  What fraction of all starting combinations are therefore valid?  \\n\\nNow we have 2 trees - we have a left hand tree with numbers 1..a-1, and a right hand tree a+1..n\\nThese two trees are completely intermingled.\\n3. Let\\'s look at the second number in the source \"b\".  Assuming it is in the range 1..a-1, we can say that of all the remaining valid combinations, only ones that have the first number in that range equal to \"b\" will be valid.  So the number of valid permutations must be reduced to 1/y where y = ?\\n\\nContinue with all the remaining numbers in the array.  The range that they are part of gets smaller until it is the only number in the range (in which case the fraction is 1/1.\\nFor each fraction from questions 2,3, and all the remaining numbers, multiple the divisors together (we want to do the actual division only once) and don\\'t forget to do the mod operation.\\nNow do modular divide (see below) of the total (from question 1) by the divisor(answer 2 * answer 3 * ....)\\nFinally subtract 1 (the original combination)\\n\\nIn this way you only need to keep track of all numbers previously seen in a way that enables you to ask \"how big is the range of possible numbers that the new number is in?\"\\n\\nModular divide\\n===========\\nFermat\\'s Little Theorem for modular division, (the restriction on this is always valid for prime numbers such as 10^9+7)\\n1/a mod b -> a^(b-2) mod b\\n\\nDo this a c * a + d * a^2 + e * a^4 + f * a^8 ... Where c,d,e,f,... corresponds to the bit representation of b\\n\\nAnswers:\\n=======\\n1. n!\\n2. Since we have n possible numbers, only 1/n of them are going to be valid\\n3. Since the first number is in range 1..a-1, the number that have b first will be 1/(a-1)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You can\\'t do it with DP - how will you cache the results? The key would be a set."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Holy moly , the Related Topics Tab is as long as a question."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "First, let's consider the properties of a binary search tree (BST). In a BST, all elements in the left subtree of a node are smaller than the node, and all elements in the right subtree are greater than the node. Therefore, the first number in the reordered array will always be the root of the BST.\n\nNow, let's consider the numbers smaller than the root and the numbers larger than the root separately.\n\nFor the numbers smaller than the root, they will form the left subtree. We can recursively calculate the number of different ways to reorder these numbers to form the left subtree.\n\nSimilarly, for the numbers larger than the root, they will form the right subtree. We can recursively calculate the number of different ways to reorder these numbers to form the right subtree.\n\nTo merge the results, we need to consider the number of ways to order x elements in x+y positions. Here, x represents the number of elements in the left subtree, and y represents the number of elements in the right subtree.\n\nTherefore, the total number of different ways to reorder nums such that the BST formed is identical to the original BST formed from nums is:\n\nways = `number of ways to reorder left subtree` * `number of ways to reorder right subtree` * `number of ways to order x elements in x+y positions`"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Oh my god!! Okay, Its happening! Everybody stay calm! Everybody stay CALM!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "et tu, leetcode ?"
                    },
                    {
                        "username": "dEAthWednesday",
                        "content": "fav comment right here"
                    }
                ]
            },
            {
                "id": 1931801,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "..And now I understand that I don't understand how the hell this array is mapped into a tree"
                    },
                    {
                        "username": "mossej",
                        "content": "First element of nums is the root. All remaining nums < root go to the left, nums > root goes to the right. "
                    },
                    {
                        "username": "khanhtc",
                        "content": "it\\'s not how the array is mapped to the BST, it\\'s how to construct a BST with nodes value given from an array in the array order."
                    },
                    {
                        "username": "GOBurrito",
                        "content": "it iterates through the array and each number is placed in the most fitting spot for it on the current tree"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a math problem! It needs to compute lots of combination numbers!!!\nUse recursion, if the subproblem for left subtree and right subtree are solved, with the number l and r, Use the following formula:\n$$\nTotalNumber=l\t*  r\t* C^{N-1}_{Len(left\\_subtree)}-1\n$$\n # Why multiplication? \nThe fundamental principle of counting/rule of product or multiplication principle  says:\n>  if there are a ways of doing something and b ways of doing another thing, then there are a · b ways of performing both actions.\n\nThis test case makes using direct method computing  $C^{N-1}_{Len(left\\_subtree)}$ impossible in C++, even using unsigned long long!\n```\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\n```"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Uh oh, easy strike ends guys."
                    },
                    {
                        "username": "hridoy100",
                        "content": "## Leetcode C++ and Java compilers are giving runtime error!\nAfter submitting got these errors:\n\n```Java []\n[0.015s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\n```\n```C++ []\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n```\nThe reason is that global/static variables affect the program state from one test case to another. The system executes all testcases using the same program instance. This is their development issue. For python3 this issue doesn't pops up."
                    },
                    {
                        "username": "user3954sk",
                        "content": "This can be solved using the \"programming way\" - DP and recursion - or by starting with all possible combinations of 1..n and working out what fraction of them are actually valid.\\nFor the latter, ask yourself: (answers below)\\n1. What is the total number of permutations of 1..n? \\n2. Given that the first number in the source is \"a\", any combination that doesn\\'t have \"a\" as the start is invalid.  What fraction of all starting combinations are therefore valid?  \\n\\nNow we have 2 trees - we have a left hand tree with numbers 1..a-1, and a right hand tree a+1..n\\nThese two trees are completely intermingled.\\n3. Let\\'s look at the second number in the source \"b\".  Assuming it is in the range 1..a-1, we can say that of all the remaining valid combinations, only ones that have the first number in that range equal to \"b\" will be valid.  So the number of valid permutations must be reduced to 1/y where y = ?\\n\\nContinue with all the remaining numbers in the array.  The range that they are part of gets smaller until it is the only number in the range (in which case the fraction is 1/1.\\nFor each fraction from questions 2,3, and all the remaining numbers, multiple the divisors together (we want to do the actual division only once) and don\\'t forget to do the mod operation.\\nNow do modular divide (see below) of the total (from question 1) by the divisor(answer 2 * answer 3 * ....)\\nFinally subtract 1 (the original combination)\\n\\nIn this way you only need to keep track of all numbers previously seen in a way that enables you to ask \"how big is the range of possible numbers that the new number is in?\"\\n\\nModular divide\\n===========\\nFermat\\'s Little Theorem for modular division, (the restriction on this is always valid for prime numbers such as 10^9+7)\\n1/a mod b -> a^(b-2) mod b\\n\\nDo this a c * a + d * a^2 + e * a^4 + f * a^8 ... Where c,d,e,f,... corresponds to the bit representation of b\\n\\nAnswers:\\n=======\\n1. n!\\n2. Since we have n possible numbers, only 1/n of them are going to be valid\\n3. Since the first number is in range 1..a-1, the number that have b first will be 1/(a-1)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You can\\'t do it with DP - how will you cache the results? The key would be a set."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Holy moly , the Related Topics Tab is as long as a question."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "First, let's consider the properties of a binary search tree (BST). In a BST, all elements in the left subtree of a node are smaller than the node, and all elements in the right subtree are greater than the node. Therefore, the first number in the reordered array will always be the root of the BST.\n\nNow, let's consider the numbers smaller than the root and the numbers larger than the root separately.\n\nFor the numbers smaller than the root, they will form the left subtree. We can recursively calculate the number of different ways to reorder these numbers to form the left subtree.\n\nSimilarly, for the numbers larger than the root, they will form the right subtree. We can recursively calculate the number of different ways to reorder these numbers to form the right subtree.\n\nTo merge the results, we need to consider the number of ways to order x elements in x+y positions. Here, x represents the number of elements in the left subtree, and y represents the number of elements in the right subtree.\n\nTherefore, the total number of different ways to reorder nums such that the BST formed is identical to the original BST formed from nums is:\n\nways = `number of ways to reorder left subtree` * `number of ways to reorder right subtree` * `number of ways to order x elements in x+y positions`"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Oh my god!! Okay, Its happening! Everybody stay calm! Everybody stay CALM!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "et tu, leetcode ?"
                    },
                    {
                        "username": "dEAthWednesday",
                        "content": "fav comment right here"
                    }
                ]
            },
            {
                "id": 1931922,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "..And now I understand that I don't understand how the hell this array is mapped into a tree"
                    },
                    {
                        "username": "mossej",
                        "content": "First element of nums is the root. All remaining nums < root go to the left, nums > root goes to the right. "
                    },
                    {
                        "username": "khanhtc",
                        "content": "it\\'s not how the array is mapped to the BST, it\\'s how to construct a BST with nodes value given from an array in the array order."
                    },
                    {
                        "username": "GOBurrito",
                        "content": "it iterates through the array and each number is placed in the most fitting spot for it on the current tree"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a math problem! It needs to compute lots of combination numbers!!!\nUse recursion, if the subproblem for left subtree and right subtree are solved, with the number l and r, Use the following formula:\n$$\nTotalNumber=l\t*  r\t* C^{N-1}_{Len(left\\_subtree)}-1\n$$\n # Why multiplication? \nThe fundamental principle of counting/rule of product or multiplication principle  says:\n>  if there are a ways of doing something and b ways of doing another thing, then there are a · b ways of performing both actions.\n\nThis test case makes using direct method computing  $C^{N-1}_{Len(left\\_subtree)}$ impossible in C++, even using unsigned long long!\n```\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\n```"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Uh oh, easy strike ends guys."
                    },
                    {
                        "username": "hridoy100",
                        "content": "## Leetcode C++ and Java compilers are giving runtime error!\nAfter submitting got these errors:\n\n```Java []\n[0.015s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\n```\n```C++ []\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n```\nThe reason is that global/static variables affect the program state from one test case to another. The system executes all testcases using the same program instance. This is their development issue. For python3 this issue doesn't pops up."
                    },
                    {
                        "username": "user3954sk",
                        "content": "This can be solved using the \"programming way\" - DP and recursion - or by starting with all possible combinations of 1..n and working out what fraction of them are actually valid.\\nFor the latter, ask yourself: (answers below)\\n1. What is the total number of permutations of 1..n? \\n2. Given that the first number in the source is \"a\", any combination that doesn\\'t have \"a\" as the start is invalid.  What fraction of all starting combinations are therefore valid?  \\n\\nNow we have 2 trees - we have a left hand tree with numbers 1..a-1, and a right hand tree a+1..n\\nThese two trees are completely intermingled.\\n3. Let\\'s look at the second number in the source \"b\".  Assuming it is in the range 1..a-1, we can say that of all the remaining valid combinations, only ones that have the first number in that range equal to \"b\" will be valid.  So the number of valid permutations must be reduced to 1/y where y = ?\\n\\nContinue with all the remaining numbers in the array.  The range that they are part of gets smaller until it is the only number in the range (in which case the fraction is 1/1.\\nFor each fraction from questions 2,3, and all the remaining numbers, multiple the divisors together (we want to do the actual division only once) and don\\'t forget to do the mod operation.\\nNow do modular divide (see below) of the total (from question 1) by the divisor(answer 2 * answer 3 * ....)\\nFinally subtract 1 (the original combination)\\n\\nIn this way you only need to keep track of all numbers previously seen in a way that enables you to ask \"how big is the range of possible numbers that the new number is in?\"\\n\\nModular divide\\n===========\\nFermat\\'s Little Theorem for modular division, (the restriction on this is always valid for prime numbers such as 10^9+7)\\n1/a mod b -> a^(b-2) mod b\\n\\nDo this a c * a + d * a^2 + e * a^4 + f * a^8 ... Where c,d,e,f,... corresponds to the bit representation of b\\n\\nAnswers:\\n=======\\n1. n!\\n2. Since we have n possible numbers, only 1/n of them are going to be valid\\n3. Since the first number is in range 1..a-1, the number that have b first will be 1/(a-1)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You can\\'t do it with DP - how will you cache the results? The key would be a set."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Holy moly , the Related Topics Tab is as long as a question."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "First, let's consider the properties of a binary search tree (BST). In a BST, all elements in the left subtree of a node are smaller than the node, and all elements in the right subtree are greater than the node. Therefore, the first number in the reordered array will always be the root of the BST.\n\nNow, let's consider the numbers smaller than the root and the numbers larger than the root separately.\n\nFor the numbers smaller than the root, they will form the left subtree. We can recursively calculate the number of different ways to reorder these numbers to form the left subtree.\n\nSimilarly, for the numbers larger than the root, they will form the right subtree. We can recursively calculate the number of different ways to reorder these numbers to form the right subtree.\n\nTo merge the results, we need to consider the number of ways to order x elements in x+y positions. Here, x represents the number of elements in the left subtree, and y represents the number of elements in the right subtree.\n\nTherefore, the total number of different ways to reorder nums such that the BST formed is identical to the original BST formed from nums is:\n\nways = `number of ways to reorder left subtree` * `number of ways to reorder right subtree` * `number of ways to order x elements in x+y positions`"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Oh my god!! Okay, Its happening! Everybody stay calm! Everybody stay CALM!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "et tu, leetcode ?"
                    },
                    {
                        "username": "dEAthWednesday",
                        "content": "fav comment right here"
                    }
                ]
            },
            {
                "id": 1931890,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "..And now I understand that I don't understand how the hell this array is mapped into a tree"
                    },
                    {
                        "username": "mossej",
                        "content": "First element of nums is the root. All remaining nums < root go to the left, nums > root goes to the right. "
                    },
                    {
                        "username": "khanhtc",
                        "content": "it\\'s not how the array is mapped to the BST, it\\'s how to construct a BST with nodes value given from an array in the array order."
                    },
                    {
                        "username": "GOBurrito",
                        "content": "it iterates through the array and each number is placed in the most fitting spot for it on the current tree"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a math problem! It needs to compute lots of combination numbers!!!\nUse recursion, if the subproblem for left subtree and right subtree are solved, with the number l and r, Use the following formula:\n$$\nTotalNumber=l\t*  r\t* C^{N-1}_{Len(left\\_subtree)}-1\n$$\n # Why multiplication? \nThe fundamental principle of counting/rule of product or multiplication principle  says:\n>  if there are a ways of doing something and b ways of doing another thing, then there are a · b ways of performing both actions.\n\nThis test case makes using direct method computing  $C^{N-1}_{Len(left\\_subtree)}$ impossible in C++, even using unsigned long long!\n```\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\n```"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Uh oh, easy strike ends guys."
                    },
                    {
                        "username": "hridoy100",
                        "content": "## Leetcode C++ and Java compilers are giving runtime error!\nAfter submitting got these errors:\n\n```Java []\n[0.015s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\n```\n```C++ []\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n```\nThe reason is that global/static variables affect the program state from one test case to another. The system executes all testcases using the same program instance. This is their development issue. For python3 this issue doesn't pops up."
                    },
                    {
                        "username": "user3954sk",
                        "content": "This can be solved using the \"programming way\" - DP and recursion - or by starting with all possible combinations of 1..n and working out what fraction of them are actually valid.\\nFor the latter, ask yourself: (answers below)\\n1. What is the total number of permutations of 1..n? \\n2. Given that the first number in the source is \"a\", any combination that doesn\\'t have \"a\" as the start is invalid.  What fraction of all starting combinations are therefore valid?  \\n\\nNow we have 2 trees - we have a left hand tree with numbers 1..a-1, and a right hand tree a+1..n\\nThese two trees are completely intermingled.\\n3. Let\\'s look at the second number in the source \"b\".  Assuming it is in the range 1..a-1, we can say that of all the remaining valid combinations, only ones that have the first number in that range equal to \"b\" will be valid.  So the number of valid permutations must be reduced to 1/y where y = ?\\n\\nContinue with all the remaining numbers in the array.  The range that they are part of gets smaller until it is the only number in the range (in which case the fraction is 1/1.\\nFor each fraction from questions 2,3, and all the remaining numbers, multiple the divisors together (we want to do the actual division only once) and don\\'t forget to do the mod operation.\\nNow do modular divide (see below) of the total (from question 1) by the divisor(answer 2 * answer 3 * ....)\\nFinally subtract 1 (the original combination)\\n\\nIn this way you only need to keep track of all numbers previously seen in a way that enables you to ask \"how big is the range of possible numbers that the new number is in?\"\\n\\nModular divide\\n===========\\nFermat\\'s Little Theorem for modular division, (the restriction on this is always valid for prime numbers such as 10^9+7)\\n1/a mod b -> a^(b-2) mod b\\n\\nDo this a c * a + d * a^2 + e * a^4 + f * a^8 ... Where c,d,e,f,... corresponds to the bit representation of b\\n\\nAnswers:\\n=======\\n1. n!\\n2. Since we have n possible numbers, only 1/n of them are going to be valid\\n3. Since the first number is in range 1..a-1, the number that have b first will be 1/(a-1)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You can\\'t do it with DP - how will you cache the results? The key would be a set."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Holy moly , the Related Topics Tab is as long as a question."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "First, let's consider the properties of a binary search tree (BST). In a BST, all elements in the left subtree of a node are smaller than the node, and all elements in the right subtree are greater than the node. Therefore, the first number in the reordered array will always be the root of the BST.\n\nNow, let's consider the numbers smaller than the root and the numbers larger than the root separately.\n\nFor the numbers smaller than the root, they will form the left subtree. We can recursively calculate the number of different ways to reorder these numbers to form the left subtree.\n\nSimilarly, for the numbers larger than the root, they will form the right subtree. We can recursively calculate the number of different ways to reorder these numbers to form the right subtree.\n\nTo merge the results, we need to consider the number of ways to order x elements in x+y positions. Here, x represents the number of elements in the left subtree, and y represents the number of elements in the right subtree.\n\nTherefore, the total number of different ways to reorder nums such that the BST formed is identical to the original BST formed from nums is:\n\nways = `number of ways to reorder left subtree` * `number of ways to reorder right subtree` * `number of ways to order x elements in x+y positions`"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Oh my god!! Okay, Its happening! Everybody stay calm! Everybody stay CALM!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "et tu, leetcode ?"
                    },
                    {
                        "username": "dEAthWednesday",
                        "content": "fav comment right here"
                    }
                ]
            },
            {
                "id": 1931588,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "..And now I understand that I don't understand how the hell this array is mapped into a tree"
                    },
                    {
                        "username": "mossej",
                        "content": "First element of nums is the root. All remaining nums < root go to the left, nums > root goes to the right. "
                    },
                    {
                        "username": "khanhtc",
                        "content": "it\\'s not how the array is mapped to the BST, it\\'s how to construct a BST with nodes value given from an array in the array order."
                    },
                    {
                        "username": "GOBurrito",
                        "content": "it iterates through the array and each number is placed in the most fitting spot for it on the current tree"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a math problem! It needs to compute lots of combination numbers!!!\nUse recursion, if the subproblem for left subtree and right subtree are solved, with the number l and r, Use the following formula:\n$$\nTotalNumber=l\t*  r\t* C^{N-1}_{Len(left\\_subtree)}-1\n$$\n # Why multiplication? \nThe fundamental principle of counting/rule of product or multiplication principle  says:\n>  if there are a ways of doing something and b ways of doing another thing, then there are a · b ways of performing both actions.\n\nThis test case makes using direct method computing  $C^{N-1}_{Len(left\\_subtree)}$ impossible in C++, even using unsigned long long!\n```\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\n```"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Uh oh, easy strike ends guys."
                    },
                    {
                        "username": "hridoy100",
                        "content": "## Leetcode C++ and Java compilers are giving runtime error!\nAfter submitting got these errors:\n\n```Java []\n[0.015s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\n```\n```C++ []\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n```\nThe reason is that global/static variables affect the program state from one test case to another. The system executes all testcases using the same program instance. This is their development issue. For python3 this issue doesn't pops up."
                    },
                    {
                        "username": "user3954sk",
                        "content": "This can be solved using the \"programming way\" - DP and recursion - or by starting with all possible combinations of 1..n and working out what fraction of them are actually valid.\\nFor the latter, ask yourself: (answers below)\\n1. What is the total number of permutations of 1..n? \\n2. Given that the first number in the source is \"a\", any combination that doesn\\'t have \"a\" as the start is invalid.  What fraction of all starting combinations are therefore valid?  \\n\\nNow we have 2 trees - we have a left hand tree with numbers 1..a-1, and a right hand tree a+1..n\\nThese two trees are completely intermingled.\\n3. Let\\'s look at the second number in the source \"b\".  Assuming it is in the range 1..a-1, we can say that of all the remaining valid combinations, only ones that have the first number in that range equal to \"b\" will be valid.  So the number of valid permutations must be reduced to 1/y where y = ?\\n\\nContinue with all the remaining numbers in the array.  The range that they are part of gets smaller until it is the only number in the range (in which case the fraction is 1/1.\\nFor each fraction from questions 2,3, and all the remaining numbers, multiple the divisors together (we want to do the actual division only once) and don\\'t forget to do the mod operation.\\nNow do modular divide (see below) of the total (from question 1) by the divisor(answer 2 * answer 3 * ....)\\nFinally subtract 1 (the original combination)\\n\\nIn this way you only need to keep track of all numbers previously seen in a way that enables you to ask \"how big is the range of possible numbers that the new number is in?\"\\n\\nModular divide\\n===========\\nFermat\\'s Little Theorem for modular division, (the restriction on this is always valid for prime numbers such as 10^9+7)\\n1/a mod b -> a^(b-2) mod b\\n\\nDo this a c * a + d * a^2 + e * a^4 + f * a^8 ... Where c,d,e,f,... corresponds to the bit representation of b\\n\\nAnswers:\\n=======\\n1. n!\\n2. Since we have n possible numbers, only 1/n of them are going to be valid\\n3. Since the first number is in range 1..a-1, the number that have b first will be 1/(a-1)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You can\\'t do it with DP - how will you cache the results? The key would be a set."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Holy moly , the Related Topics Tab is as long as a question."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "First, let's consider the properties of a binary search tree (BST). In a BST, all elements in the left subtree of a node are smaller than the node, and all elements in the right subtree are greater than the node. Therefore, the first number in the reordered array will always be the root of the BST.\n\nNow, let's consider the numbers smaller than the root and the numbers larger than the root separately.\n\nFor the numbers smaller than the root, they will form the left subtree. We can recursively calculate the number of different ways to reorder these numbers to form the left subtree.\n\nSimilarly, for the numbers larger than the root, they will form the right subtree. We can recursively calculate the number of different ways to reorder these numbers to form the right subtree.\n\nTo merge the results, we need to consider the number of ways to order x elements in x+y positions. Here, x represents the number of elements in the left subtree, and y represents the number of elements in the right subtree.\n\nTherefore, the total number of different ways to reorder nums such that the BST formed is identical to the original BST formed from nums is:\n\nways = `number of ways to reorder left subtree` * `number of ways to reorder right subtree` * `number of ways to order x elements in x+y positions`"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Oh my god!! Okay, Its happening! Everybody stay calm! Everybody stay CALM!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "et tu, leetcode ?"
                    },
                    {
                        "username": "dEAthWednesday",
                        "content": "fav comment right here"
                    }
                ]
            },
            {
                "id": 1931547,
                "content": [
                    {
                        "username": "VladimirTheLeet",
                        "content": "..And now I understand that I don't understand how the hell this array is mapped into a tree"
                    },
                    {
                        "username": "mossej",
                        "content": "First element of nums is the root. All remaining nums < root go to the left, nums > root goes to the right. "
                    },
                    {
                        "username": "khanhtc",
                        "content": "it\\'s not how the array is mapped to the BST, it\\'s how to construct a BST with nodes value given from an array in the array order."
                    },
                    {
                        "username": "GOBurrito",
                        "content": "it iterates through the array and each number is placed in the most fitting spot for it on the current tree"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This is a math problem! It needs to compute lots of combination numbers!!!\nUse recursion, if the subproblem for left subtree and right subtree are solved, with the number l and r, Use the following formula:\n$$\nTotalNumber=l\t*  r\t* C^{N-1}_{Len(left\\_subtree)}-1\n$$\n # Why multiplication? \nThe fundamental principle of counting/rule of product or multiplication principle  says:\n>  if there are a ways of doing something and b ways of doing another thing, then there are a · b ways of performing both actions.\n\nThis test case makes using direct method computing  $C^{N-1}_{Len(left\\_subtree)}$ impossible in C++, even using unsigned long long!\n```\n[74,24,70,11,6,4,59,9,36,82,80,30,46,31,22,34,8,69,32,57,18,21,37,83,55,38,41,72,48,65,27,60,73,58,68,50,16,77,75,20,81,3,61,13,10,29,62,49,12,66,39,45,28,40,42,52,78,56,44,17,14,67,35,26,19,5,63,51,43,23,79,2,54,47,76,53,7,25,64,33,1,15,71]\n```"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Uh oh, easy strike ends guys."
                    },
                    {
                        "username": "hridoy100",
                        "content": "## Leetcode C++ and Java compilers are giving runtime error!\nAfter submitting got these errors:\n\n```Java []\n[0.015s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\nError occurred during initialization of VM\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\n```\n```C++ []\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v\n```\nThe reason is that global/static variables affect the program state from one test case to another. The system executes all testcases using the same program instance. This is their development issue. For python3 this issue doesn't pops up."
                    },
                    {
                        "username": "user3954sk",
                        "content": "This can be solved using the \"programming way\" - DP and recursion - or by starting with all possible combinations of 1..n and working out what fraction of them are actually valid.\\nFor the latter, ask yourself: (answers below)\\n1. What is the total number of permutations of 1..n? \\n2. Given that the first number in the source is \"a\", any combination that doesn\\'t have \"a\" as the start is invalid.  What fraction of all starting combinations are therefore valid?  \\n\\nNow we have 2 trees - we have a left hand tree with numbers 1..a-1, and a right hand tree a+1..n\\nThese two trees are completely intermingled.\\n3. Let\\'s look at the second number in the source \"b\".  Assuming it is in the range 1..a-1, we can say that of all the remaining valid combinations, only ones that have the first number in that range equal to \"b\" will be valid.  So the number of valid permutations must be reduced to 1/y where y = ?\\n\\nContinue with all the remaining numbers in the array.  The range that they are part of gets smaller until it is the only number in the range (in which case the fraction is 1/1.\\nFor each fraction from questions 2,3, and all the remaining numbers, multiple the divisors together (we want to do the actual division only once) and don\\'t forget to do the mod operation.\\nNow do modular divide (see below) of the total (from question 1) by the divisor(answer 2 * answer 3 * ....)\\nFinally subtract 1 (the original combination)\\n\\nIn this way you only need to keep track of all numbers previously seen in a way that enables you to ask \"how big is the range of possible numbers that the new number is in?\"\\n\\nModular divide\\n===========\\nFermat\\'s Little Theorem for modular division, (the restriction on this is always valid for prime numbers such as 10^9+7)\\n1/a mod b -> a^(b-2) mod b\\n\\nDo this a c * a + d * a^2 + e * a^4 + f * a^8 ... Where c,d,e,f,... corresponds to the bit representation of b\\n\\nAnswers:\\n=======\\n1. n!\\n2. Since we have n possible numbers, only 1/n of them are going to be valid\\n3. Since the first number is in range 1..a-1, the number that have b first will be 1/(a-1)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "You can\\'t do it with DP - how will you cache the results? The key would be a set."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Holy moly , the Related Topics Tab is as long as a question."
                    },
                    {
                        "username": "purvi_jha",
                        "content": "my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! my eyes ...!!!! "
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "First, let's consider the properties of a binary search tree (BST). In a BST, all elements in the left subtree of a node are smaller than the node, and all elements in the right subtree are greater than the node. Therefore, the first number in the reordered array will always be the root of the BST.\n\nNow, let's consider the numbers smaller than the root and the numbers larger than the root separately.\n\nFor the numbers smaller than the root, they will form the left subtree. We can recursively calculate the number of different ways to reorder these numbers to form the left subtree.\n\nSimilarly, for the numbers larger than the root, they will form the right subtree. We can recursively calculate the number of different ways to reorder these numbers to form the right subtree.\n\nTo merge the results, we need to consider the number of ways to order x elements in x+y positions. Here, x represents the number of elements in the left subtree, and y represents the number of elements in the right subtree.\n\nTherefore, the total number of different ways to reorder nums such that the BST formed is identical to the original BST formed from nums is:\n\nways = `number of ways to reorder left subtree` * `number of ways to reorder right subtree` * `number of ways to order x elements in x+y positions`"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "Oh my god!! Okay, Its happening! Everybody stay calm! Everybody stay CALM!!!"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "et tu, leetcode ?"
                    },
                    {
                        "username": "dEAthWednesday",
                        "content": "fav comment right here"
                    }
                ]
            },
            {
                "id": 1931283,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Phew! My streak is still intact. The editorial gave a very good explanation of the algorithm involved.\\n\\nNote that many of the coefficients of Pascal\\'s Triangle won\\'t even fit into a long long integer (64 bits) so be prepared for a lot of modulo arithmetic."
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "Thanks for giving me the confidence to solve this. <3"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "\"I like challenges\"\\n\"Okay, we will give you a challenge\"\\n...\\nThe challenge:"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "Just joking, this problem is actually solvable. Put more time to observe, like asking why:\\na) [3,4,1,2,5] is not same with [4,3,1,2,5], \\nb) [1,2,3,4,5] is same with [1,3,2,4,5]\\nc) how to determine what element is located on left or right\\netc.\\n\\nMy tips: don\\'t read editorial, just believe in yourself, you can do it guys!\\nI know this clearly a hard problem. But the harder the problem, the more we could learn. Good luck \\uD83D\\uDE09"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Hard we all were looking for! This month's first Hard 😀"
                    },
                    {
                        "username": "huleshjangde",
                        "content": "what is this ==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "In my case I was returning `solve(nums) % mod -1` directly from numOfWays function. \\nI changed it to this - \\n`int ans = solve(nums) % mod -1;\\nreturn ans;`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "If you are storing factorial in an array of long long data type do like below - \\n```\\nfor(int i=1; i<=1003; i++){\\n            fact[i] = (fact[i-1] * (long long)i *1)%mod;\\n        }\\n```"
                    },
                    {
                        "username": "user2049D",
                        "content": "Proud to have found this one.\\nI understood that I\\'d have to \"divide and conquer\". But it was not so easy to figure how.\\nI used the 3 given examples to confirm what I saw on paper: I\\'d have to use combinations.\\n\\nSince, I understood that I had to split the array `nums` in values under and over `root` and count the combinations with these 2 arrays cases recursively.\\nI verified that, with a max of 1000 for `n`, my solution would be acceptable."
                    },
                    {
                        "username": "johnnychang",
                        "content": "This is a great hard question testing several things:\\n1. attribute of BST\\n2. math\\n3. coding up recursion and binomial coefficient"
                    },
                    {
                        "username": "bishal_722",
                        "content": "Leetcode : Summer\\'s enjoyment over, back to reality!!"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Login to leetcode.\\nOK, check out the daily challenge!\\nClose all tabs."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem requires knowledge of combinatorics (n choose k) and modular inverse.\nDefinitely a tough one."
                    },
                    {
                        "username": "sohammistri",
                        "content": "Some combinatorics knowledge is useful. And a hell lot of helper functions of modular arithmetic. Thank god I had saved a CP template with all this."
                    }
                ]
            },
            {
                "id": 1931258,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Phew! My streak is still intact. The editorial gave a very good explanation of the algorithm involved.\\n\\nNote that many of the coefficients of Pascal\\'s Triangle won\\'t even fit into a long long integer (64 bits) so be prepared for a lot of modulo arithmetic."
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "Thanks for giving me the confidence to solve this. <3"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "\"I like challenges\"\\n\"Okay, we will give you a challenge\"\\n...\\nThe challenge:"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "Just joking, this problem is actually solvable. Put more time to observe, like asking why:\\na) [3,4,1,2,5] is not same with [4,3,1,2,5], \\nb) [1,2,3,4,5] is same with [1,3,2,4,5]\\nc) how to determine what element is located on left or right\\netc.\\n\\nMy tips: don\\'t read editorial, just believe in yourself, you can do it guys!\\nI know this clearly a hard problem. But the harder the problem, the more we could learn. Good luck \\uD83D\\uDE09"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Hard we all were looking for! This month's first Hard 😀"
                    },
                    {
                        "username": "huleshjangde",
                        "content": "what is this ==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "In my case I was returning `solve(nums) % mod -1` directly from numOfWays function. \\nI changed it to this - \\n`int ans = solve(nums) % mod -1;\\nreturn ans;`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "If you are storing factorial in an array of long long data type do like below - \\n```\\nfor(int i=1; i<=1003; i++){\\n            fact[i] = (fact[i-1] * (long long)i *1)%mod;\\n        }\\n```"
                    },
                    {
                        "username": "user2049D",
                        "content": "Proud to have found this one.\\nI understood that I\\'d have to \"divide and conquer\". But it was not so easy to figure how.\\nI used the 3 given examples to confirm what I saw on paper: I\\'d have to use combinations.\\n\\nSince, I understood that I had to split the array `nums` in values under and over `root` and count the combinations with these 2 arrays cases recursively.\\nI verified that, with a max of 1000 for `n`, my solution would be acceptable."
                    },
                    {
                        "username": "johnnychang",
                        "content": "This is a great hard question testing several things:\\n1. attribute of BST\\n2. math\\n3. coding up recursion and binomial coefficient"
                    },
                    {
                        "username": "bishal_722",
                        "content": "Leetcode : Summer\\'s enjoyment over, back to reality!!"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Login to leetcode.\\nOK, check out the daily challenge!\\nClose all tabs."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem requires knowledge of combinatorics (n choose k) and modular inverse.\nDefinitely a tough one."
                    },
                    {
                        "username": "sohammistri",
                        "content": "Some combinatorics knowledge is useful. And a hell lot of helper functions of modular arithmetic. Thank god I had saved a CP template with all this."
                    }
                ]
            },
            {
                "id": 1931101,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Phew! My streak is still intact. The editorial gave a very good explanation of the algorithm involved.\\n\\nNote that many of the coefficients of Pascal\\'s Triangle won\\'t even fit into a long long integer (64 bits) so be prepared for a lot of modulo arithmetic."
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "Thanks for giving me the confidence to solve this. <3"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "\"I like challenges\"\\n\"Okay, we will give you a challenge\"\\n...\\nThe challenge:"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "Just joking, this problem is actually solvable. Put more time to observe, like asking why:\\na) [3,4,1,2,5] is not same with [4,3,1,2,5], \\nb) [1,2,3,4,5] is same with [1,3,2,4,5]\\nc) how to determine what element is located on left or right\\netc.\\n\\nMy tips: don\\'t read editorial, just believe in yourself, you can do it guys!\\nI know this clearly a hard problem. But the harder the problem, the more we could learn. Good luck \\uD83D\\uDE09"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Hard we all were looking for! This month's first Hard 😀"
                    },
                    {
                        "username": "huleshjangde",
                        "content": "what is this ==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "In my case I was returning `solve(nums) % mod -1` directly from numOfWays function. \\nI changed it to this - \\n`int ans = solve(nums) % mod -1;\\nreturn ans;`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "If you are storing factorial in an array of long long data type do like below - \\n```\\nfor(int i=1; i<=1003; i++){\\n            fact[i] = (fact[i-1] * (long long)i *1)%mod;\\n        }\\n```"
                    },
                    {
                        "username": "user2049D",
                        "content": "Proud to have found this one.\\nI understood that I\\'d have to \"divide and conquer\". But it was not so easy to figure how.\\nI used the 3 given examples to confirm what I saw on paper: I\\'d have to use combinations.\\n\\nSince, I understood that I had to split the array `nums` in values under and over `root` and count the combinations with these 2 arrays cases recursively.\\nI verified that, with a max of 1000 for `n`, my solution would be acceptable."
                    },
                    {
                        "username": "johnnychang",
                        "content": "This is a great hard question testing several things:\\n1. attribute of BST\\n2. math\\n3. coding up recursion and binomial coefficient"
                    },
                    {
                        "username": "bishal_722",
                        "content": "Leetcode : Summer\\'s enjoyment over, back to reality!!"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Login to leetcode.\\nOK, check out the daily challenge!\\nClose all tabs."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem requires knowledge of combinatorics (n choose k) and modular inverse.\nDefinitely a tough one."
                    },
                    {
                        "username": "sohammistri",
                        "content": "Some combinatorics knowledge is useful. And a hell lot of helper functions of modular arithmetic. Thank god I had saved a CP template with all this."
                    }
                ]
            },
            {
                "id": 1932288,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Phew! My streak is still intact. The editorial gave a very good explanation of the algorithm involved.\\n\\nNote that many of the coefficients of Pascal\\'s Triangle won\\'t even fit into a long long integer (64 bits) so be prepared for a lot of modulo arithmetic."
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "Thanks for giving me the confidence to solve this. <3"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "\"I like challenges\"\\n\"Okay, we will give you a challenge\"\\n...\\nThe challenge:"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "Just joking, this problem is actually solvable. Put more time to observe, like asking why:\\na) [3,4,1,2,5] is not same with [4,3,1,2,5], \\nb) [1,2,3,4,5] is same with [1,3,2,4,5]\\nc) how to determine what element is located on left or right\\netc.\\n\\nMy tips: don\\'t read editorial, just believe in yourself, you can do it guys!\\nI know this clearly a hard problem. But the harder the problem, the more we could learn. Good luck \\uD83D\\uDE09"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Hard we all were looking for! This month's first Hard 😀"
                    },
                    {
                        "username": "huleshjangde",
                        "content": "what is this ==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "In my case I was returning `solve(nums) % mod -1` directly from numOfWays function. \\nI changed it to this - \\n`int ans = solve(nums) % mod -1;\\nreturn ans;`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "If you are storing factorial in an array of long long data type do like below - \\n```\\nfor(int i=1; i<=1003; i++){\\n            fact[i] = (fact[i-1] * (long long)i *1)%mod;\\n        }\\n```"
                    },
                    {
                        "username": "user2049D",
                        "content": "Proud to have found this one.\\nI understood that I\\'d have to \"divide and conquer\". But it was not so easy to figure how.\\nI used the 3 given examples to confirm what I saw on paper: I\\'d have to use combinations.\\n\\nSince, I understood that I had to split the array `nums` in values under and over `root` and count the combinations with these 2 arrays cases recursively.\\nI verified that, with a max of 1000 for `n`, my solution would be acceptable."
                    },
                    {
                        "username": "johnnychang",
                        "content": "This is a great hard question testing several things:\\n1. attribute of BST\\n2. math\\n3. coding up recursion and binomial coefficient"
                    },
                    {
                        "username": "bishal_722",
                        "content": "Leetcode : Summer\\'s enjoyment over, back to reality!!"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Login to leetcode.\\nOK, check out the daily challenge!\\nClose all tabs."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem requires knowledge of combinatorics (n choose k) and modular inverse.\nDefinitely a tough one."
                    },
                    {
                        "username": "sohammistri",
                        "content": "Some combinatorics knowledge is useful. And a hell lot of helper functions of modular arithmetic. Thank god I had saved a CP template with all this."
                    }
                ]
            },
            {
                "id": 1932207,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Phew! My streak is still intact. The editorial gave a very good explanation of the algorithm involved.\\n\\nNote that many of the coefficients of Pascal\\'s Triangle won\\'t even fit into a long long integer (64 bits) so be prepared for a lot of modulo arithmetic."
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "Thanks for giving me the confidence to solve this. <3"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "\"I like challenges\"\\n\"Okay, we will give you a challenge\"\\n...\\nThe challenge:"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "Just joking, this problem is actually solvable. Put more time to observe, like asking why:\\na) [3,4,1,2,5] is not same with [4,3,1,2,5], \\nb) [1,2,3,4,5] is same with [1,3,2,4,5]\\nc) how to determine what element is located on left or right\\netc.\\n\\nMy tips: don\\'t read editorial, just believe in yourself, you can do it guys!\\nI know this clearly a hard problem. But the harder the problem, the more we could learn. Good luck \\uD83D\\uDE09"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Hard we all were looking for! This month's first Hard 😀"
                    },
                    {
                        "username": "huleshjangde",
                        "content": "what is this ==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "In my case I was returning `solve(nums) % mod -1` directly from numOfWays function. \\nI changed it to this - \\n`int ans = solve(nums) % mod -1;\\nreturn ans;`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "If you are storing factorial in an array of long long data type do like below - \\n```\\nfor(int i=1; i<=1003; i++){\\n            fact[i] = (fact[i-1] * (long long)i *1)%mod;\\n        }\\n```"
                    },
                    {
                        "username": "user2049D",
                        "content": "Proud to have found this one.\\nI understood that I\\'d have to \"divide and conquer\". But it was not so easy to figure how.\\nI used the 3 given examples to confirm what I saw on paper: I\\'d have to use combinations.\\n\\nSince, I understood that I had to split the array `nums` in values under and over `root` and count the combinations with these 2 arrays cases recursively.\\nI verified that, with a max of 1000 for `n`, my solution would be acceptable."
                    },
                    {
                        "username": "johnnychang",
                        "content": "This is a great hard question testing several things:\\n1. attribute of BST\\n2. math\\n3. coding up recursion and binomial coefficient"
                    },
                    {
                        "username": "bishal_722",
                        "content": "Leetcode : Summer\\'s enjoyment over, back to reality!!"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Login to leetcode.\\nOK, check out the daily challenge!\\nClose all tabs."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem requires knowledge of combinatorics (n choose k) and modular inverse.\nDefinitely a tough one."
                    },
                    {
                        "username": "sohammistri",
                        "content": "Some combinatorics knowledge is useful. And a hell lot of helper functions of modular arithmetic. Thank god I had saved a CP template with all this."
                    }
                ]
            },
            {
                "id": 1932056,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Phew! My streak is still intact. The editorial gave a very good explanation of the algorithm involved.\\n\\nNote that many of the coefficients of Pascal\\'s Triangle won\\'t even fit into a long long integer (64 bits) so be prepared for a lot of modulo arithmetic."
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "Thanks for giving me the confidence to solve this. <3"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "\"I like challenges\"\\n\"Okay, we will give you a challenge\"\\n...\\nThe challenge:"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "Just joking, this problem is actually solvable. Put more time to observe, like asking why:\\na) [3,4,1,2,5] is not same with [4,3,1,2,5], \\nb) [1,2,3,4,5] is same with [1,3,2,4,5]\\nc) how to determine what element is located on left or right\\netc.\\n\\nMy tips: don\\'t read editorial, just believe in yourself, you can do it guys!\\nI know this clearly a hard problem. But the harder the problem, the more we could learn. Good luck \\uD83D\\uDE09"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Hard we all were looking for! This month's first Hard 😀"
                    },
                    {
                        "username": "huleshjangde",
                        "content": "what is this ==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "In my case I was returning `solve(nums) % mod -1` directly from numOfWays function. \\nI changed it to this - \\n`int ans = solve(nums) % mod -1;\\nreturn ans;`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "If you are storing factorial in an array of long long data type do like below - \\n```\\nfor(int i=1; i<=1003; i++){\\n            fact[i] = (fact[i-1] * (long long)i *1)%mod;\\n        }\\n```"
                    },
                    {
                        "username": "user2049D",
                        "content": "Proud to have found this one.\\nI understood that I\\'d have to \"divide and conquer\". But it was not so easy to figure how.\\nI used the 3 given examples to confirm what I saw on paper: I\\'d have to use combinations.\\n\\nSince, I understood that I had to split the array `nums` in values under and over `root` and count the combinations with these 2 arrays cases recursively.\\nI verified that, with a max of 1000 for `n`, my solution would be acceptable."
                    },
                    {
                        "username": "johnnychang",
                        "content": "This is a great hard question testing several things:\\n1. attribute of BST\\n2. math\\n3. coding up recursion and binomial coefficient"
                    },
                    {
                        "username": "bishal_722",
                        "content": "Leetcode : Summer\\'s enjoyment over, back to reality!!"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Login to leetcode.\\nOK, check out the daily challenge!\\nClose all tabs."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem requires knowledge of combinatorics (n choose k) and modular inverse.\nDefinitely a tough one."
                    },
                    {
                        "username": "sohammistri",
                        "content": "Some combinatorics knowledge is useful. And a hell lot of helper functions of modular arithmetic. Thank god I had saved a CP template with all this."
                    }
                ]
            },
            {
                "id": 1931933,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Phew! My streak is still intact. The editorial gave a very good explanation of the algorithm involved.\\n\\nNote that many of the coefficients of Pascal\\'s Triangle won\\'t even fit into a long long integer (64 bits) so be prepared for a lot of modulo arithmetic."
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "Thanks for giving me the confidence to solve this. <3"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "\"I like challenges\"\\n\"Okay, we will give you a challenge\"\\n...\\nThe challenge:"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "Just joking, this problem is actually solvable. Put more time to observe, like asking why:\\na) [3,4,1,2,5] is not same with [4,3,1,2,5], \\nb) [1,2,3,4,5] is same with [1,3,2,4,5]\\nc) how to determine what element is located on left or right\\netc.\\n\\nMy tips: don\\'t read editorial, just believe in yourself, you can do it guys!\\nI know this clearly a hard problem. But the harder the problem, the more we could learn. Good luck \\uD83D\\uDE09"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Hard we all were looking for! This month's first Hard 😀"
                    },
                    {
                        "username": "huleshjangde",
                        "content": "what is this ==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "In my case I was returning `solve(nums) % mod -1` directly from numOfWays function. \\nI changed it to this - \\n`int ans = solve(nums) % mod -1;\\nreturn ans;`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "If you are storing factorial in an array of long long data type do like below - \\n```\\nfor(int i=1; i<=1003; i++){\\n            fact[i] = (fact[i-1] * (long long)i *1)%mod;\\n        }\\n```"
                    },
                    {
                        "username": "user2049D",
                        "content": "Proud to have found this one.\\nI understood that I\\'d have to \"divide and conquer\". But it was not so easy to figure how.\\nI used the 3 given examples to confirm what I saw on paper: I\\'d have to use combinations.\\n\\nSince, I understood that I had to split the array `nums` in values under and over `root` and count the combinations with these 2 arrays cases recursively.\\nI verified that, with a max of 1000 for `n`, my solution would be acceptable."
                    },
                    {
                        "username": "johnnychang",
                        "content": "This is a great hard question testing several things:\\n1. attribute of BST\\n2. math\\n3. coding up recursion and binomial coefficient"
                    },
                    {
                        "username": "bishal_722",
                        "content": "Leetcode : Summer\\'s enjoyment over, back to reality!!"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Login to leetcode.\\nOK, check out the daily challenge!\\nClose all tabs."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem requires knowledge of combinatorics (n choose k) and modular inverse.\nDefinitely a tough one."
                    },
                    {
                        "username": "sohammistri",
                        "content": "Some combinatorics knowledge is useful. And a hell lot of helper functions of modular arithmetic. Thank god I had saved a CP template with all this."
                    }
                ]
            },
            {
                "id": 1931851,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Phew! My streak is still intact. The editorial gave a very good explanation of the algorithm involved.\\n\\nNote that many of the coefficients of Pascal\\'s Triangle won\\'t even fit into a long long integer (64 bits) so be prepared for a lot of modulo arithmetic."
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "Thanks for giving me the confidence to solve this. <3"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "\"I like challenges\"\\n\"Okay, we will give you a challenge\"\\n...\\nThe challenge:"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "Just joking, this problem is actually solvable. Put more time to observe, like asking why:\\na) [3,4,1,2,5] is not same with [4,3,1,2,5], \\nb) [1,2,3,4,5] is same with [1,3,2,4,5]\\nc) how to determine what element is located on left or right\\netc.\\n\\nMy tips: don\\'t read editorial, just believe in yourself, you can do it guys!\\nI know this clearly a hard problem. But the harder the problem, the more we could learn. Good luck \\uD83D\\uDE09"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Hard we all were looking for! This month's first Hard 😀"
                    },
                    {
                        "username": "huleshjangde",
                        "content": "what is this ==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "In my case I was returning `solve(nums) % mod -1` directly from numOfWays function. \\nI changed it to this - \\n`int ans = solve(nums) % mod -1;\\nreturn ans;`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "If you are storing factorial in an array of long long data type do like below - \\n```\\nfor(int i=1; i<=1003; i++){\\n            fact[i] = (fact[i-1] * (long long)i *1)%mod;\\n        }\\n```"
                    },
                    {
                        "username": "user2049D",
                        "content": "Proud to have found this one.\\nI understood that I\\'d have to \"divide and conquer\". But it was not so easy to figure how.\\nI used the 3 given examples to confirm what I saw on paper: I\\'d have to use combinations.\\n\\nSince, I understood that I had to split the array `nums` in values under and over `root` and count the combinations with these 2 arrays cases recursively.\\nI verified that, with a max of 1000 for `n`, my solution would be acceptable."
                    },
                    {
                        "username": "johnnychang",
                        "content": "This is a great hard question testing several things:\\n1. attribute of BST\\n2. math\\n3. coding up recursion and binomial coefficient"
                    },
                    {
                        "username": "bishal_722",
                        "content": "Leetcode : Summer\\'s enjoyment over, back to reality!!"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Login to leetcode.\\nOK, check out the daily challenge!\\nClose all tabs."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem requires knowledge of combinatorics (n choose k) and modular inverse.\nDefinitely a tough one."
                    },
                    {
                        "username": "sohammistri",
                        "content": "Some combinatorics knowledge is useful. And a hell lot of helper functions of modular arithmetic. Thank god I had saved a CP template with all this."
                    }
                ]
            },
            {
                "id": 1931802,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Phew! My streak is still intact. The editorial gave a very good explanation of the algorithm involved.\\n\\nNote that many of the coefficients of Pascal\\'s Triangle won\\'t even fit into a long long integer (64 bits) so be prepared for a lot of modulo arithmetic."
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "Thanks for giving me the confidence to solve this. <3"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "\"I like challenges\"\\n\"Okay, we will give you a challenge\"\\n...\\nThe challenge:"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "Just joking, this problem is actually solvable. Put more time to observe, like asking why:\\na) [3,4,1,2,5] is not same with [4,3,1,2,5], \\nb) [1,2,3,4,5] is same with [1,3,2,4,5]\\nc) how to determine what element is located on left or right\\netc.\\n\\nMy tips: don\\'t read editorial, just believe in yourself, you can do it guys!\\nI know this clearly a hard problem. But the harder the problem, the more we could learn. Good luck \\uD83D\\uDE09"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Hard we all were looking for! This month's first Hard 😀"
                    },
                    {
                        "username": "huleshjangde",
                        "content": "what is this ==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "In my case I was returning `solve(nums) % mod -1` directly from numOfWays function. \\nI changed it to this - \\n`int ans = solve(nums) % mod -1;\\nreturn ans;`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "If you are storing factorial in an array of long long data type do like below - \\n```\\nfor(int i=1; i<=1003; i++){\\n            fact[i] = (fact[i-1] * (long long)i *1)%mod;\\n        }\\n```"
                    },
                    {
                        "username": "user2049D",
                        "content": "Proud to have found this one.\\nI understood that I\\'d have to \"divide and conquer\". But it was not so easy to figure how.\\nI used the 3 given examples to confirm what I saw on paper: I\\'d have to use combinations.\\n\\nSince, I understood that I had to split the array `nums` in values under and over `root` and count the combinations with these 2 arrays cases recursively.\\nI verified that, with a max of 1000 for `n`, my solution would be acceptable."
                    },
                    {
                        "username": "johnnychang",
                        "content": "This is a great hard question testing several things:\\n1. attribute of BST\\n2. math\\n3. coding up recursion and binomial coefficient"
                    },
                    {
                        "username": "bishal_722",
                        "content": "Leetcode : Summer\\'s enjoyment over, back to reality!!"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Login to leetcode.\\nOK, check out the daily challenge!\\nClose all tabs."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem requires knowledge of combinatorics (n choose k) and modular inverse.\nDefinitely a tough one."
                    },
                    {
                        "username": "sohammistri",
                        "content": "Some combinatorics knowledge is useful. And a hell lot of helper functions of modular arithmetic. Thank god I had saved a CP template with all this."
                    }
                ]
            },
            {
                "id": 1931587,
                "content": [
                    {
                        "username": "psionl0",
                        "content": "Phew! My streak is still intact. The editorial gave a very good explanation of the algorithm involved.\\n\\nNote that many of the coefficients of Pascal\\'s Triangle won\\'t even fit into a long long integer (64 bits) so be prepared for a lot of modulo arithmetic."
                    },
                    {
                        "username": "SaketNarayane",
                        "content": "Thanks for giving me the confidence to solve this. <3"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "\"I like challenges\"\\n\"Okay, we will give you a challenge\"\\n...\\nThe challenge:"
                    },
                    {
                        "username": "alamsyahn_",
                        "content": "Just joking, this problem is actually solvable. Put more time to observe, like asking why:\\na) [3,4,1,2,5] is not same with [4,3,1,2,5], \\nb) [1,2,3,4,5] is same with [1,3,2,4,5]\\nc) how to determine what element is located on left or right\\netc.\\n\\nMy tips: don\\'t read editorial, just believe in yourself, you can do it guys!\\nI know this clearly a hard problem. But the harder the problem, the more we could learn. Good luck \\uD83D\\uDE09"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Finally a Hard we all were looking for! This month's first Hard 😀"
                    },
                    {
                        "username": "huleshjangde",
                        "content": "what is this ==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "In my case I was returning `solve(nums) % mod -1` directly from numOfWays function. \\nI changed it to this - \\n`int ans = solve(nums) % mod -1;\\nreturn ans;`"
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "If you are storing factorial in an array of long long data type do like below - \\n```\\nfor(int i=1; i<=1003; i++){\\n            fact[i] = (fact[i-1] * (long long)i *1)%mod;\\n        }\\n```"
                    },
                    {
                        "username": "user2049D",
                        "content": "Proud to have found this one.\\nI understood that I\\'d have to \"divide and conquer\". But it was not so easy to figure how.\\nI used the 3 given examples to confirm what I saw on paper: I\\'d have to use combinations.\\n\\nSince, I understood that I had to split the array `nums` in values under and over `root` and count the combinations with these 2 arrays cases recursively.\\nI verified that, with a max of 1000 for `n`, my solution would be acceptable."
                    },
                    {
                        "username": "johnnychang",
                        "content": "This is a great hard question testing several things:\\n1. attribute of BST\\n2. math\\n3. coding up recursion and binomial coefficient"
                    },
                    {
                        "username": "bishal_722",
                        "content": "Leetcode : Summer\\'s enjoyment over, back to reality!!"
                    },
                    {
                        "username": "MrDLt000",
                        "content": "Login to leetcode.\\nOK, check out the daily challenge!\\nClose all tabs."
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "This problem requires knowledge of combinatorics (n choose k) and modular inverse.\nDefinitely a tough one."
                    },
                    {
                        "username": "sohammistri",
                        "content": "Some combinatorics knowledge is useful. And a hell lot of helper functions of modular arithmetic. Thank god I had saved a CP template with all this."
                    }
                ]
            },
            {
                "id": 1931502,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**I lost 350 days streak, june month batch and year batch, where only june month was left\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D**"
                    },
                    {
                        "username": "wwhysohard",
                        "content": "Can\\'t the time travel ticket help you restore your streak?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "dude im legitimately sorry for you \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "time to break the streak :("
                    },
                    {
                        "username": "eduard92",
                        "content": "my monitor broke and I connected on pc with tw just to find this... copy paste it is this time. I am gonna read the editorial tho"
                    },
                    {
                        "username": "bac2qh",
                        "content": "This is the hardest shxt I have seen for a very long while. Legit has no legit idea after 3 hours "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "us moment !\\n"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "Can someone please tell me how the hell the array maps onto the BST? Literally in every single other question involving BST (or binary tree for that matter) it goes [Root, left, right, left\\'s left, left\\'s right, right\\'s left, right\\'s right] and so on.. so how the hell does [2,1,3] make the same tree as [2,3,1]? "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n\\'\\'\\'def insertNode(self,node,data):\\n    if node is None:\\n        return self.createNode(data)\\n    if data < node.data :\\n        node.left = self.insertNode(node.left,data)\\n    else :\\n        node.right = self.insertNode(node.right,data)\\n    return node\\'\\'\\'"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "[@GOBurrito](/GOBurrito) Oh I see... so literally the only thing that's fixed is the root? If so, that actually makes so much more sense. I just got extremely confused because like I said, all other questions involving trees (AND FOR THAT MATTER, LEETCODE INTERNAL ILLUSTRATION OF TREES) follows the whole root, left, right pattern....\n\nEdit: The problem is literally just \"in how many ways can we arrange the rest of the numbers given that the first number is fixed and also the order of the rest of the numbers are the same\" with a twist that the two lists are formed via the BST rule "
                    },
                    {
                        "username": "GOBurrito",
                        "content": "The array doesn\\'t describe a tree, it is just a sequence of numbers which then gets converted into a tree.\\nSo each successive number in the array will be placed in whatever open space on the tree is most appropriate for it.\\n\\n[2,1,3] starts with 2, then 1 < 2 so it goes on the left, then 3 > 2 so it goes on the right\\n[2,3,1] starts with 2, then 3 > 2 so it goes on the right, then 1 < 2 so it goes on the left.\\nSame result"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "https://www.youtube.com/embed/FvdPo8PBQtc?start=67"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I don\\'t understand why [2, 1, 3] and [2, 3, 1] yields the same BST, does [2, 3, 1] means the root is 2, and left node is 3, right node is 1? If anyone can explain, thanks a lot."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@psionl0](/psionl0) thank u, i understand"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@deCodeIt](/deCodeIt) thank u, i understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "[2,1,3] and [2,3,1] both mean the same thing: root = 2, 1 < 2 so root.left=1\\nand 3 > 2 so root.right = 3. In a larger tree, the root will still be the left most element but there will be several numbers less than the root and several numbers greater than the root. These will form the basis of a recursion."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "For your question, \"NO\" the array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Yes you are correct. Build the BST using the property of it - smaller number goes to left and greater number goes to right."
                    },
                    {
                        "username": "czjnbb",
                        "content": "You have to build a BST."
                    },
                    {
                        "username": "czjnbb",
                        "content": "For me, using combination is easier for this kind of questions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ruturajpanditrao777](/ruturajpanditrao777) You already know the root (1st element), so you just need to maintain the order of the values smaller (arr1, len1) than the root and the values larger (arr2, len2) than the root. You need to pick len1/len2 spots from (len1 + len2) spots.\\n\\nDo this iteratively for arr1, arr2, etc..."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Yes i'm thinking about combinations. How did you approach the problem ? The relative order of elements less than root & greater than root should be same right? Like 3 1 4 5 2, 1 should always occur before 2 and also 4 should occur before 5 anywhere in array. How to solve this?\n"
                    },
                    {
                        "username": "aminbagheri",
                        "content": "This should be a medium, lol. Just some basic math "
                    },
                    {
                        "username": "synbat_d",
                        "content": "Hi, I solved this question on youtube. This is my first video on Youtube. Thank you. \\nhttps://youtu.be/FMfLFWdNStY"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "time limit exceeded for testcase 50"
                    }
                ]
            },
            {
                "id": 1931495,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**I lost 350 days streak, june month batch and year batch, where only june month was left\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D**"
                    },
                    {
                        "username": "wwhysohard",
                        "content": "Can\\'t the time travel ticket help you restore your streak?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "dude im legitimately sorry for you \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "time to break the streak :("
                    },
                    {
                        "username": "eduard92",
                        "content": "my monitor broke and I connected on pc with tw just to find this... copy paste it is this time. I am gonna read the editorial tho"
                    },
                    {
                        "username": "bac2qh",
                        "content": "This is the hardest shxt I have seen for a very long while. Legit has no legit idea after 3 hours "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "us moment !\\n"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "Can someone please tell me how the hell the array maps onto the BST? Literally in every single other question involving BST (or binary tree for that matter) it goes [Root, left, right, left\\'s left, left\\'s right, right\\'s left, right\\'s right] and so on.. so how the hell does [2,1,3] make the same tree as [2,3,1]? "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n\\'\\'\\'def insertNode(self,node,data):\\n    if node is None:\\n        return self.createNode(data)\\n    if data < node.data :\\n        node.left = self.insertNode(node.left,data)\\n    else :\\n        node.right = self.insertNode(node.right,data)\\n    return node\\'\\'\\'"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "[@GOBurrito](/GOBurrito) Oh I see... so literally the only thing that's fixed is the root? If so, that actually makes so much more sense. I just got extremely confused because like I said, all other questions involving trees (AND FOR THAT MATTER, LEETCODE INTERNAL ILLUSTRATION OF TREES) follows the whole root, left, right pattern....\n\nEdit: The problem is literally just \"in how many ways can we arrange the rest of the numbers given that the first number is fixed and also the order of the rest of the numbers are the same\" with a twist that the two lists are formed via the BST rule "
                    },
                    {
                        "username": "GOBurrito",
                        "content": "The array doesn\\'t describe a tree, it is just a sequence of numbers which then gets converted into a tree.\\nSo each successive number in the array will be placed in whatever open space on the tree is most appropriate for it.\\n\\n[2,1,3] starts with 2, then 1 < 2 so it goes on the left, then 3 > 2 so it goes on the right\\n[2,3,1] starts with 2, then 3 > 2 so it goes on the right, then 1 < 2 so it goes on the left.\\nSame result"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "https://www.youtube.com/embed/FvdPo8PBQtc?start=67"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I don\\'t understand why [2, 1, 3] and [2, 3, 1] yields the same BST, does [2, 3, 1] means the root is 2, and left node is 3, right node is 1? If anyone can explain, thanks a lot."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@psionl0](/psionl0) thank u, i understand"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@deCodeIt](/deCodeIt) thank u, i understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "[2,1,3] and [2,3,1] both mean the same thing: root = 2, 1 < 2 so root.left=1\\nand 3 > 2 so root.right = 3. In a larger tree, the root will still be the left most element but there will be several numbers less than the root and several numbers greater than the root. These will form the basis of a recursion."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "For your question, \"NO\" the array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Yes you are correct. Build the BST using the property of it - smaller number goes to left and greater number goes to right."
                    },
                    {
                        "username": "czjnbb",
                        "content": "You have to build a BST."
                    },
                    {
                        "username": "czjnbb",
                        "content": "For me, using combination is easier for this kind of questions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ruturajpanditrao777](/ruturajpanditrao777) You already know the root (1st element), so you just need to maintain the order of the values smaller (arr1, len1) than the root and the values larger (arr2, len2) than the root. You need to pick len1/len2 spots from (len1 + len2) spots.\\n\\nDo this iteratively for arr1, arr2, etc..."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Yes i'm thinking about combinations. How did you approach the problem ? The relative order of elements less than root & greater than root should be same right? Like 3 1 4 5 2, 1 should always occur before 2 and also 4 should occur before 5 anywhere in array. How to solve this?\n"
                    },
                    {
                        "username": "aminbagheri",
                        "content": "This should be a medium, lol. Just some basic math "
                    },
                    {
                        "username": "synbat_d",
                        "content": "Hi, I solved this question on youtube. This is my first video on Youtube. Thank you. \\nhttps://youtu.be/FMfLFWdNStY"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "time limit exceeded for testcase 50"
                    }
                ]
            },
            {
                "id": 1931479,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**I lost 350 days streak, june month batch and year batch, where only june month was left\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D**"
                    },
                    {
                        "username": "wwhysohard",
                        "content": "Can\\'t the time travel ticket help you restore your streak?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "dude im legitimately sorry for you \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "time to break the streak :("
                    },
                    {
                        "username": "eduard92",
                        "content": "my monitor broke and I connected on pc with tw just to find this... copy paste it is this time. I am gonna read the editorial tho"
                    },
                    {
                        "username": "bac2qh",
                        "content": "This is the hardest shxt I have seen for a very long while. Legit has no legit idea after 3 hours "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "us moment !\\n"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "Can someone please tell me how the hell the array maps onto the BST? Literally in every single other question involving BST (or binary tree for that matter) it goes [Root, left, right, left\\'s left, left\\'s right, right\\'s left, right\\'s right] and so on.. so how the hell does [2,1,3] make the same tree as [2,3,1]? "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n\\'\\'\\'def insertNode(self,node,data):\\n    if node is None:\\n        return self.createNode(data)\\n    if data < node.data :\\n        node.left = self.insertNode(node.left,data)\\n    else :\\n        node.right = self.insertNode(node.right,data)\\n    return node\\'\\'\\'"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "[@GOBurrito](/GOBurrito) Oh I see... so literally the only thing that's fixed is the root? If so, that actually makes so much more sense. I just got extremely confused because like I said, all other questions involving trees (AND FOR THAT MATTER, LEETCODE INTERNAL ILLUSTRATION OF TREES) follows the whole root, left, right pattern....\n\nEdit: The problem is literally just \"in how many ways can we arrange the rest of the numbers given that the first number is fixed and also the order of the rest of the numbers are the same\" with a twist that the two lists are formed via the BST rule "
                    },
                    {
                        "username": "GOBurrito",
                        "content": "The array doesn\\'t describe a tree, it is just a sequence of numbers which then gets converted into a tree.\\nSo each successive number in the array will be placed in whatever open space on the tree is most appropriate for it.\\n\\n[2,1,3] starts with 2, then 1 < 2 so it goes on the left, then 3 > 2 so it goes on the right\\n[2,3,1] starts with 2, then 3 > 2 so it goes on the right, then 1 < 2 so it goes on the left.\\nSame result"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "https://www.youtube.com/embed/FvdPo8PBQtc?start=67"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I don\\'t understand why [2, 1, 3] and [2, 3, 1] yields the same BST, does [2, 3, 1] means the root is 2, and left node is 3, right node is 1? If anyone can explain, thanks a lot."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@psionl0](/psionl0) thank u, i understand"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@deCodeIt](/deCodeIt) thank u, i understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "[2,1,3] and [2,3,1] both mean the same thing: root = 2, 1 < 2 so root.left=1\\nand 3 > 2 so root.right = 3. In a larger tree, the root will still be the left most element but there will be several numbers less than the root and several numbers greater than the root. These will form the basis of a recursion."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "For your question, \"NO\" the array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Yes you are correct. Build the BST using the property of it - smaller number goes to left and greater number goes to right."
                    },
                    {
                        "username": "czjnbb",
                        "content": "You have to build a BST."
                    },
                    {
                        "username": "czjnbb",
                        "content": "For me, using combination is easier for this kind of questions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ruturajpanditrao777](/ruturajpanditrao777) You already know the root (1st element), so you just need to maintain the order of the values smaller (arr1, len1) than the root and the values larger (arr2, len2) than the root. You need to pick len1/len2 spots from (len1 + len2) spots.\\n\\nDo this iteratively for arr1, arr2, etc..."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Yes i'm thinking about combinations. How did you approach the problem ? The relative order of elements less than root & greater than root should be same right? Like 3 1 4 5 2, 1 should always occur before 2 and also 4 should occur before 5 anywhere in array. How to solve this?\n"
                    },
                    {
                        "username": "aminbagheri",
                        "content": "This should be a medium, lol. Just some basic math "
                    },
                    {
                        "username": "synbat_d",
                        "content": "Hi, I solved this question on youtube. This is my first video on Youtube. Thank you. \\nhttps://youtu.be/FMfLFWdNStY"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "time limit exceeded for testcase 50"
                    }
                ]
            },
            {
                "id": 1931423,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**I lost 350 days streak, june month batch and year batch, where only june month was left\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D**"
                    },
                    {
                        "username": "wwhysohard",
                        "content": "Can\\'t the time travel ticket help you restore your streak?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "dude im legitimately sorry for you \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "time to break the streak :("
                    },
                    {
                        "username": "eduard92",
                        "content": "my monitor broke and I connected on pc with tw just to find this... copy paste it is this time. I am gonna read the editorial tho"
                    },
                    {
                        "username": "bac2qh",
                        "content": "This is the hardest shxt I have seen for a very long while. Legit has no legit idea after 3 hours "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "us moment !\\n"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "Can someone please tell me how the hell the array maps onto the BST? Literally in every single other question involving BST (or binary tree for that matter) it goes [Root, left, right, left\\'s left, left\\'s right, right\\'s left, right\\'s right] and so on.. so how the hell does [2,1,3] make the same tree as [2,3,1]? "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n\\'\\'\\'def insertNode(self,node,data):\\n    if node is None:\\n        return self.createNode(data)\\n    if data < node.data :\\n        node.left = self.insertNode(node.left,data)\\n    else :\\n        node.right = self.insertNode(node.right,data)\\n    return node\\'\\'\\'"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "[@GOBurrito](/GOBurrito) Oh I see... so literally the only thing that's fixed is the root? If so, that actually makes so much more sense. I just got extremely confused because like I said, all other questions involving trees (AND FOR THAT MATTER, LEETCODE INTERNAL ILLUSTRATION OF TREES) follows the whole root, left, right pattern....\n\nEdit: The problem is literally just \"in how many ways can we arrange the rest of the numbers given that the first number is fixed and also the order of the rest of the numbers are the same\" with a twist that the two lists are formed via the BST rule "
                    },
                    {
                        "username": "GOBurrito",
                        "content": "The array doesn\\'t describe a tree, it is just a sequence of numbers which then gets converted into a tree.\\nSo each successive number in the array will be placed in whatever open space on the tree is most appropriate for it.\\n\\n[2,1,3] starts with 2, then 1 < 2 so it goes on the left, then 3 > 2 so it goes on the right\\n[2,3,1] starts with 2, then 3 > 2 so it goes on the right, then 1 < 2 so it goes on the left.\\nSame result"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "https://www.youtube.com/embed/FvdPo8PBQtc?start=67"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I don\\'t understand why [2, 1, 3] and [2, 3, 1] yields the same BST, does [2, 3, 1] means the root is 2, and left node is 3, right node is 1? If anyone can explain, thanks a lot."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@psionl0](/psionl0) thank u, i understand"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@deCodeIt](/deCodeIt) thank u, i understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "[2,1,3] and [2,3,1] both mean the same thing: root = 2, 1 < 2 so root.left=1\\nand 3 > 2 so root.right = 3. In a larger tree, the root will still be the left most element but there will be several numbers less than the root and several numbers greater than the root. These will form the basis of a recursion."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "For your question, \"NO\" the array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Yes you are correct. Build the BST using the property of it - smaller number goes to left and greater number goes to right."
                    },
                    {
                        "username": "czjnbb",
                        "content": "You have to build a BST."
                    },
                    {
                        "username": "czjnbb",
                        "content": "For me, using combination is easier for this kind of questions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ruturajpanditrao777](/ruturajpanditrao777) You already know the root (1st element), so you just need to maintain the order of the values smaller (arr1, len1) than the root and the values larger (arr2, len2) than the root. You need to pick len1/len2 spots from (len1 + len2) spots.\\n\\nDo this iteratively for arr1, arr2, etc..."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Yes i'm thinking about combinations. How did you approach the problem ? The relative order of elements less than root & greater than root should be same right? Like 3 1 4 5 2, 1 should always occur before 2 and also 4 should occur before 5 anywhere in array. How to solve this?\n"
                    },
                    {
                        "username": "aminbagheri",
                        "content": "This should be a medium, lol. Just some basic math "
                    },
                    {
                        "username": "synbat_d",
                        "content": "Hi, I solved this question on youtube. This is my first video on Youtube. Thank you. \\nhttps://youtu.be/FMfLFWdNStY"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "time limit exceeded for testcase 50"
                    }
                ]
            },
            {
                "id": 1931249,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**I lost 350 days streak, june month batch and year batch, where only june month was left\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D**"
                    },
                    {
                        "username": "wwhysohard",
                        "content": "Can\\'t the time travel ticket help you restore your streak?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "dude im legitimately sorry for you \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "time to break the streak :("
                    },
                    {
                        "username": "eduard92",
                        "content": "my monitor broke and I connected on pc with tw just to find this... copy paste it is this time. I am gonna read the editorial tho"
                    },
                    {
                        "username": "bac2qh",
                        "content": "This is the hardest shxt I have seen for a very long while. Legit has no legit idea after 3 hours "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "us moment !\\n"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "Can someone please tell me how the hell the array maps onto the BST? Literally in every single other question involving BST (or binary tree for that matter) it goes [Root, left, right, left\\'s left, left\\'s right, right\\'s left, right\\'s right] and so on.. so how the hell does [2,1,3] make the same tree as [2,3,1]? "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n\\'\\'\\'def insertNode(self,node,data):\\n    if node is None:\\n        return self.createNode(data)\\n    if data < node.data :\\n        node.left = self.insertNode(node.left,data)\\n    else :\\n        node.right = self.insertNode(node.right,data)\\n    return node\\'\\'\\'"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "[@GOBurrito](/GOBurrito) Oh I see... so literally the only thing that's fixed is the root? If so, that actually makes so much more sense. I just got extremely confused because like I said, all other questions involving trees (AND FOR THAT MATTER, LEETCODE INTERNAL ILLUSTRATION OF TREES) follows the whole root, left, right pattern....\n\nEdit: The problem is literally just \"in how many ways can we arrange the rest of the numbers given that the first number is fixed and also the order of the rest of the numbers are the same\" with a twist that the two lists are formed via the BST rule "
                    },
                    {
                        "username": "GOBurrito",
                        "content": "The array doesn\\'t describe a tree, it is just a sequence of numbers which then gets converted into a tree.\\nSo each successive number in the array will be placed in whatever open space on the tree is most appropriate for it.\\n\\n[2,1,3] starts with 2, then 1 < 2 so it goes on the left, then 3 > 2 so it goes on the right\\n[2,3,1] starts with 2, then 3 > 2 so it goes on the right, then 1 < 2 so it goes on the left.\\nSame result"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "https://www.youtube.com/embed/FvdPo8PBQtc?start=67"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I don\\'t understand why [2, 1, 3] and [2, 3, 1] yields the same BST, does [2, 3, 1] means the root is 2, and left node is 3, right node is 1? If anyone can explain, thanks a lot."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@psionl0](/psionl0) thank u, i understand"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@deCodeIt](/deCodeIt) thank u, i understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "[2,1,3] and [2,3,1] both mean the same thing: root = 2, 1 < 2 so root.left=1\\nand 3 > 2 so root.right = 3. In a larger tree, the root will still be the left most element but there will be several numbers less than the root and several numbers greater than the root. These will form the basis of a recursion."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "For your question, \"NO\" the array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Yes you are correct. Build the BST using the property of it - smaller number goes to left and greater number goes to right."
                    },
                    {
                        "username": "czjnbb",
                        "content": "You have to build a BST."
                    },
                    {
                        "username": "czjnbb",
                        "content": "For me, using combination is easier for this kind of questions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ruturajpanditrao777](/ruturajpanditrao777) You already know the root (1st element), so you just need to maintain the order of the values smaller (arr1, len1) than the root and the values larger (arr2, len2) than the root. You need to pick len1/len2 spots from (len1 + len2) spots.\\n\\nDo this iteratively for arr1, arr2, etc..."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Yes i'm thinking about combinations. How did you approach the problem ? The relative order of elements less than root & greater than root should be same right? Like 3 1 4 5 2, 1 should always occur before 2 and also 4 should occur before 5 anywhere in array. How to solve this?\n"
                    },
                    {
                        "username": "aminbagheri",
                        "content": "This should be a medium, lol. Just some basic math "
                    },
                    {
                        "username": "synbat_d",
                        "content": "Hi, I solved this question on youtube. This is my first video on Youtube. Thank you. \\nhttps://youtu.be/FMfLFWdNStY"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "time limit exceeded for testcase 50"
                    }
                ]
            },
            {
                "id": 1931194,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**I lost 350 days streak, june month batch and year batch, where only june month was left\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D**"
                    },
                    {
                        "username": "wwhysohard",
                        "content": "Can\\'t the time travel ticket help you restore your streak?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "dude im legitimately sorry for you \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "time to break the streak :("
                    },
                    {
                        "username": "eduard92",
                        "content": "my monitor broke and I connected on pc with tw just to find this... copy paste it is this time. I am gonna read the editorial tho"
                    },
                    {
                        "username": "bac2qh",
                        "content": "This is the hardest shxt I have seen for a very long while. Legit has no legit idea after 3 hours "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "us moment !\\n"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "Can someone please tell me how the hell the array maps onto the BST? Literally in every single other question involving BST (or binary tree for that matter) it goes [Root, left, right, left\\'s left, left\\'s right, right\\'s left, right\\'s right] and so on.. so how the hell does [2,1,3] make the same tree as [2,3,1]? "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n\\'\\'\\'def insertNode(self,node,data):\\n    if node is None:\\n        return self.createNode(data)\\n    if data < node.data :\\n        node.left = self.insertNode(node.left,data)\\n    else :\\n        node.right = self.insertNode(node.right,data)\\n    return node\\'\\'\\'"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "[@GOBurrito](/GOBurrito) Oh I see... so literally the only thing that's fixed is the root? If so, that actually makes so much more sense. I just got extremely confused because like I said, all other questions involving trees (AND FOR THAT MATTER, LEETCODE INTERNAL ILLUSTRATION OF TREES) follows the whole root, left, right pattern....\n\nEdit: The problem is literally just \"in how many ways can we arrange the rest of the numbers given that the first number is fixed and also the order of the rest of the numbers are the same\" with a twist that the two lists are formed via the BST rule "
                    },
                    {
                        "username": "GOBurrito",
                        "content": "The array doesn\\'t describe a tree, it is just a sequence of numbers which then gets converted into a tree.\\nSo each successive number in the array will be placed in whatever open space on the tree is most appropriate for it.\\n\\n[2,1,3] starts with 2, then 1 < 2 so it goes on the left, then 3 > 2 so it goes on the right\\n[2,3,1] starts with 2, then 3 > 2 so it goes on the right, then 1 < 2 so it goes on the left.\\nSame result"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "https://www.youtube.com/embed/FvdPo8PBQtc?start=67"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I don\\'t understand why [2, 1, 3] and [2, 3, 1] yields the same BST, does [2, 3, 1] means the root is 2, and left node is 3, right node is 1? If anyone can explain, thanks a lot."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@psionl0](/psionl0) thank u, i understand"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@deCodeIt](/deCodeIt) thank u, i understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "[2,1,3] and [2,3,1] both mean the same thing: root = 2, 1 < 2 so root.left=1\\nand 3 > 2 so root.right = 3. In a larger tree, the root will still be the left most element but there will be several numbers less than the root and several numbers greater than the root. These will form the basis of a recursion."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "For your question, \"NO\" the array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Yes you are correct. Build the BST using the property of it - smaller number goes to left and greater number goes to right."
                    },
                    {
                        "username": "czjnbb",
                        "content": "You have to build a BST."
                    },
                    {
                        "username": "czjnbb",
                        "content": "For me, using combination is easier for this kind of questions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ruturajpanditrao777](/ruturajpanditrao777) You already know the root (1st element), so you just need to maintain the order of the values smaller (arr1, len1) than the root and the values larger (arr2, len2) than the root. You need to pick len1/len2 spots from (len1 + len2) spots.\\n\\nDo this iteratively for arr1, arr2, etc..."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Yes i'm thinking about combinations. How did you approach the problem ? The relative order of elements less than root & greater than root should be same right? Like 3 1 4 5 2, 1 should always occur before 2 and also 4 should occur before 5 anywhere in array. How to solve this?\n"
                    },
                    {
                        "username": "aminbagheri",
                        "content": "This should be a medium, lol. Just some basic math "
                    },
                    {
                        "username": "synbat_d",
                        "content": "Hi, I solved this question on youtube. This is my first video on Youtube. Thank you. \\nhttps://youtu.be/FMfLFWdNStY"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "time limit exceeded for testcase 50"
                    }
                ]
            },
            {
                "id": 1931187,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**I lost 350 days streak, june month batch and year batch, where only june month was left\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D**"
                    },
                    {
                        "username": "wwhysohard",
                        "content": "Can\\'t the time travel ticket help you restore your streak?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "dude im legitimately sorry for you \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "time to break the streak :("
                    },
                    {
                        "username": "eduard92",
                        "content": "my monitor broke and I connected on pc with tw just to find this... copy paste it is this time. I am gonna read the editorial tho"
                    },
                    {
                        "username": "bac2qh",
                        "content": "This is the hardest shxt I have seen for a very long while. Legit has no legit idea after 3 hours "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "us moment !\\n"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "Can someone please tell me how the hell the array maps onto the BST? Literally in every single other question involving BST (or binary tree for that matter) it goes [Root, left, right, left\\'s left, left\\'s right, right\\'s left, right\\'s right] and so on.. so how the hell does [2,1,3] make the same tree as [2,3,1]? "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n\\'\\'\\'def insertNode(self,node,data):\\n    if node is None:\\n        return self.createNode(data)\\n    if data < node.data :\\n        node.left = self.insertNode(node.left,data)\\n    else :\\n        node.right = self.insertNode(node.right,data)\\n    return node\\'\\'\\'"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "[@GOBurrito](/GOBurrito) Oh I see... so literally the only thing that's fixed is the root? If so, that actually makes so much more sense. I just got extremely confused because like I said, all other questions involving trees (AND FOR THAT MATTER, LEETCODE INTERNAL ILLUSTRATION OF TREES) follows the whole root, left, right pattern....\n\nEdit: The problem is literally just \"in how many ways can we arrange the rest of the numbers given that the first number is fixed and also the order of the rest of the numbers are the same\" with a twist that the two lists are formed via the BST rule "
                    },
                    {
                        "username": "GOBurrito",
                        "content": "The array doesn\\'t describe a tree, it is just a sequence of numbers which then gets converted into a tree.\\nSo each successive number in the array will be placed in whatever open space on the tree is most appropriate for it.\\n\\n[2,1,3] starts with 2, then 1 < 2 so it goes on the left, then 3 > 2 so it goes on the right\\n[2,3,1] starts with 2, then 3 > 2 so it goes on the right, then 1 < 2 so it goes on the left.\\nSame result"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "https://www.youtube.com/embed/FvdPo8PBQtc?start=67"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I don\\'t understand why [2, 1, 3] and [2, 3, 1] yields the same BST, does [2, 3, 1] means the root is 2, and left node is 3, right node is 1? If anyone can explain, thanks a lot."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@psionl0](/psionl0) thank u, i understand"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@deCodeIt](/deCodeIt) thank u, i understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "[2,1,3] and [2,3,1] both mean the same thing: root = 2, 1 < 2 so root.left=1\\nand 3 > 2 so root.right = 3. In a larger tree, the root will still be the left most element but there will be several numbers less than the root and several numbers greater than the root. These will form the basis of a recursion."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "For your question, \"NO\" the array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Yes you are correct. Build the BST using the property of it - smaller number goes to left and greater number goes to right."
                    },
                    {
                        "username": "czjnbb",
                        "content": "You have to build a BST."
                    },
                    {
                        "username": "czjnbb",
                        "content": "For me, using combination is easier for this kind of questions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ruturajpanditrao777](/ruturajpanditrao777) You already know the root (1st element), so you just need to maintain the order of the values smaller (arr1, len1) than the root and the values larger (arr2, len2) than the root. You need to pick len1/len2 spots from (len1 + len2) spots.\\n\\nDo this iteratively for arr1, arr2, etc..."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Yes i'm thinking about combinations. How did you approach the problem ? The relative order of elements less than root & greater than root should be same right? Like 3 1 4 5 2, 1 should always occur before 2 and also 4 should occur before 5 anywhere in array. How to solve this?\n"
                    },
                    {
                        "username": "aminbagheri",
                        "content": "This should be a medium, lol. Just some basic math "
                    },
                    {
                        "username": "synbat_d",
                        "content": "Hi, I solved this question on youtube. This is my first video on Youtube. Thank you. \\nhttps://youtu.be/FMfLFWdNStY"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "time limit exceeded for testcase 50"
                    }
                ]
            },
            {
                "id": 2053601,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**I lost 350 days streak, june month batch and year batch, where only june month was left\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D**"
                    },
                    {
                        "username": "wwhysohard",
                        "content": "Can\\'t the time travel ticket help you restore your streak?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "dude im legitimately sorry for you \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "time to break the streak :("
                    },
                    {
                        "username": "eduard92",
                        "content": "my monitor broke and I connected on pc with tw just to find this... copy paste it is this time. I am gonna read the editorial tho"
                    },
                    {
                        "username": "bac2qh",
                        "content": "This is the hardest shxt I have seen for a very long while. Legit has no legit idea after 3 hours "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "us moment !\\n"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "Can someone please tell me how the hell the array maps onto the BST? Literally in every single other question involving BST (or binary tree for that matter) it goes [Root, left, right, left\\'s left, left\\'s right, right\\'s left, right\\'s right] and so on.. so how the hell does [2,1,3] make the same tree as [2,3,1]? "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n\\'\\'\\'def insertNode(self,node,data):\\n    if node is None:\\n        return self.createNode(data)\\n    if data < node.data :\\n        node.left = self.insertNode(node.left,data)\\n    else :\\n        node.right = self.insertNode(node.right,data)\\n    return node\\'\\'\\'"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "[@GOBurrito](/GOBurrito) Oh I see... so literally the only thing that's fixed is the root? If so, that actually makes so much more sense. I just got extremely confused because like I said, all other questions involving trees (AND FOR THAT MATTER, LEETCODE INTERNAL ILLUSTRATION OF TREES) follows the whole root, left, right pattern....\n\nEdit: The problem is literally just \"in how many ways can we arrange the rest of the numbers given that the first number is fixed and also the order of the rest of the numbers are the same\" with a twist that the two lists are formed via the BST rule "
                    },
                    {
                        "username": "GOBurrito",
                        "content": "The array doesn\\'t describe a tree, it is just a sequence of numbers which then gets converted into a tree.\\nSo each successive number in the array will be placed in whatever open space on the tree is most appropriate for it.\\n\\n[2,1,3] starts with 2, then 1 < 2 so it goes on the left, then 3 > 2 so it goes on the right\\n[2,3,1] starts with 2, then 3 > 2 so it goes on the right, then 1 < 2 so it goes on the left.\\nSame result"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "https://www.youtube.com/embed/FvdPo8PBQtc?start=67"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I don\\'t understand why [2, 1, 3] and [2, 3, 1] yields the same BST, does [2, 3, 1] means the root is 2, and left node is 3, right node is 1? If anyone can explain, thanks a lot."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@psionl0](/psionl0) thank u, i understand"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@deCodeIt](/deCodeIt) thank u, i understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "[2,1,3] and [2,3,1] both mean the same thing: root = 2, 1 < 2 so root.left=1\\nand 3 > 2 so root.right = 3. In a larger tree, the root will still be the left most element but there will be several numbers less than the root and several numbers greater than the root. These will form the basis of a recursion."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "For your question, \"NO\" the array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Yes you are correct. Build the BST using the property of it - smaller number goes to left and greater number goes to right."
                    },
                    {
                        "username": "czjnbb",
                        "content": "You have to build a BST."
                    },
                    {
                        "username": "czjnbb",
                        "content": "For me, using combination is easier for this kind of questions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ruturajpanditrao777](/ruturajpanditrao777) You already know the root (1st element), so you just need to maintain the order of the values smaller (arr1, len1) than the root and the values larger (arr2, len2) than the root. You need to pick len1/len2 spots from (len1 + len2) spots.\\n\\nDo this iteratively for arr1, arr2, etc..."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Yes i'm thinking about combinations. How did you approach the problem ? The relative order of elements less than root & greater than root should be same right? Like 3 1 4 5 2, 1 should always occur before 2 and also 4 should occur before 5 anywhere in array. How to solve this?\n"
                    },
                    {
                        "username": "aminbagheri",
                        "content": "This should be a medium, lol. Just some basic math "
                    },
                    {
                        "username": "synbat_d",
                        "content": "Hi, I solved this question on youtube. This is my first video on Youtube. Thank you. \\nhttps://youtu.be/FMfLFWdNStY"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "time limit exceeded for testcase 50"
                    }
                ]
            },
            {
                "id": 1941367,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**I lost 350 days streak, june month batch and year batch, where only june month was left\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D**"
                    },
                    {
                        "username": "wwhysohard",
                        "content": "Can\\'t the time travel ticket help you restore your streak?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "dude im legitimately sorry for you \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "time to break the streak :("
                    },
                    {
                        "username": "eduard92",
                        "content": "my monitor broke and I connected on pc with tw just to find this... copy paste it is this time. I am gonna read the editorial tho"
                    },
                    {
                        "username": "bac2qh",
                        "content": "This is the hardest shxt I have seen for a very long while. Legit has no legit idea after 3 hours "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "us moment !\\n"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "Can someone please tell me how the hell the array maps onto the BST? Literally in every single other question involving BST (or binary tree for that matter) it goes [Root, left, right, left\\'s left, left\\'s right, right\\'s left, right\\'s right] and so on.. so how the hell does [2,1,3] make the same tree as [2,3,1]? "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n\\'\\'\\'def insertNode(self,node,data):\\n    if node is None:\\n        return self.createNode(data)\\n    if data < node.data :\\n        node.left = self.insertNode(node.left,data)\\n    else :\\n        node.right = self.insertNode(node.right,data)\\n    return node\\'\\'\\'"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "[@GOBurrito](/GOBurrito) Oh I see... so literally the only thing that's fixed is the root? If so, that actually makes so much more sense. I just got extremely confused because like I said, all other questions involving trees (AND FOR THAT MATTER, LEETCODE INTERNAL ILLUSTRATION OF TREES) follows the whole root, left, right pattern....\n\nEdit: The problem is literally just \"in how many ways can we arrange the rest of the numbers given that the first number is fixed and also the order of the rest of the numbers are the same\" with a twist that the two lists are formed via the BST rule "
                    },
                    {
                        "username": "GOBurrito",
                        "content": "The array doesn\\'t describe a tree, it is just a sequence of numbers which then gets converted into a tree.\\nSo each successive number in the array will be placed in whatever open space on the tree is most appropriate for it.\\n\\n[2,1,3] starts with 2, then 1 < 2 so it goes on the left, then 3 > 2 so it goes on the right\\n[2,3,1] starts with 2, then 3 > 2 so it goes on the right, then 1 < 2 so it goes on the left.\\nSame result"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "https://www.youtube.com/embed/FvdPo8PBQtc?start=67"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I don\\'t understand why [2, 1, 3] and [2, 3, 1] yields the same BST, does [2, 3, 1] means the root is 2, and left node is 3, right node is 1? If anyone can explain, thanks a lot."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@psionl0](/psionl0) thank u, i understand"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@deCodeIt](/deCodeIt) thank u, i understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "[2,1,3] and [2,3,1] both mean the same thing: root = 2, 1 < 2 so root.left=1\\nand 3 > 2 so root.right = 3. In a larger tree, the root will still be the left most element but there will be several numbers less than the root and several numbers greater than the root. These will form the basis of a recursion."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "For your question, \"NO\" the array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Yes you are correct. Build the BST using the property of it - smaller number goes to left and greater number goes to right."
                    },
                    {
                        "username": "czjnbb",
                        "content": "You have to build a BST."
                    },
                    {
                        "username": "czjnbb",
                        "content": "For me, using combination is easier for this kind of questions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ruturajpanditrao777](/ruturajpanditrao777) You already know the root (1st element), so you just need to maintain the order of the values smaller (arr1, len1) than the root and the values larger (arr2, len2) than the root. You need to pick len1/len2 spots from (len1 + len2) spots.\\n\\nDo this iteratively for arr1, arr2, etc..."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Yes i'm thinking about combinations. How did you approach the problem ? The relative order of elements less than root & greater than root should be same right? Like 3 1 4 5 2, 1 should always occur before 2 and also 4 should occur before 5 anywhere in array. How to solve this?\n"
                    },
                    {
                        "username": "aminbagheri",
                        "content": "This should be a medium, lol. Just some basic math "
                    },
                    {
                        "username": "synbat_d",
                        "content": "Hi, I solved this question on youtube. This is my first video on Youtube. Thank you. \\nhttps://youtu.be/FMfLFWdNStY"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "time limit exceeded for testcase 50"
                    }
                ]
            },
            {
                "id": 1933198,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**I lost 350 days streak, june month batch and year batch, where only june month was left\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D**"
                    },
                    {
                        "username": "wwhysohard",
                        "content": "Can\\'t the time travel ticket help you restore your streak?"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "dude im legitimately sorry for you \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "time to break the streak :("
                    },
                    {
                        "username": "eduard92",
                        "content": "my monitor broke and I connected on pc with tw just to find this... copy paste it is this time. I am gonna read the editorial tho"
                    },
                    {
                        "username": "bac2qh",
                        "content": "This is the hardest shxt I have seen for a very long while. Legit has no legit idea after 3 hours "
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "us moment !\\n"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "Can someone please tell me how the hell the array maps onto the BST? Literally in every single other question involving BST (or binary tree for that matter) it goes [Root, left, right, left\\'s left, left\\'s right, right\\'s left, right\\'s right] and so on.. so how the hell does [2,1,3] make the same tree as [2,3,1]? "
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n\\'\\'\\'def insertNode(self,node,data):\\n    if node is None:\\n        return self.createNode(data)\\n    if data < node.data :\\n        node.left = self.insertNode(node.left,data)\\n    else :\\n        node.right = self.insertNode(node.right,data)\\n    return node\\'\\'\\'"
                    },
                    {
                        "username": "bottlewater072",
                        "content": "[@GOBurrito](/GOBurrito) Oh I see... so literally the only thing that's fixed is the root? If so, that actually makes so much more sense. I just got extremely confused because like I said, all other questions involving trees (AND FOR THAT MATTER, LEETCODE INTERNAL ILLUSTRATION OF TREES) follows the whole root, left, right pattern....\n\nEdit: The problem is literally just \"in how many ways can we arrange the rest of the numbers given that the first number is fixed and also the order of the rest of the numbers are the same\" with a twist that the two lists are formed via the BST rule "
                    },
                    {
                        "username": "GOBurrito",
                        "content": "The array doesn\\'t describe a tree, it is just a sequence of numbers which then gets converted into a tree.\\nSo each successive number in the array will be placed in whatever open space on the tree is most appropriate for it.\\n\\n[2,1,3] starts with 2, then 1 < 2 so it goes on the left, then 3 > 2 so it goes on the right\\n[2,3,1] starts with 2, then 3 > 2 so it goes on the right, then 1 < 2 so it goes on the left.\\nSame result"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "https://www.youtube.com/embed/FvdPo8PBQtc?start=67"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "I don\\'t understand why [2, 1, 3] and [2, 3, 1] yields the same BST, does [2, 3, 1] means the root is 2, and left node is 3, right node is 1? If anyone can explain, thanks a lot."
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@psionl0](/psionl0) thank u, i understand"
                    },
                    {
                        "username": "wangshuoyuan2",
                        "content": "[@deCodeIt](/deCodeIt) thank u, i understand"
                    },
                    {
                        "username": "psionl0",
                        "content": "[2,1,3] and [2,3,1] both mean the same thing: root = 2, 1 < 2 so root.left=1\\nand 3 > 2 so root.right = 3. In a larger tree, the root will still be the left most element but there will be several numbers less than the root and several numbers greater than the root. These will form the basis of a recursion."
                    },
                    {
                        "username": "deCodeIt",
                        "content": "For your question, \"NO\" the array [ 2, 3, 1 ] does not mean [ root, root\\'s left, root\\'s right ]. It\\'s just the order in which elements will be given to you so that you can create a BST out of it. Basically whatever comes first will be the root and afterwards whatever comes will either go left or right depending upon if it\\'s smaller than root value or larger than the root value. This process happens recursively for every child Node unless you hit a null. This is brief of how you create a BST.\\n\\nFor example:\\n\\ni. [ 2, 3, 1 ]\\nii. [ 2 ] => becomes root as the first element.\\niii. [ 3 ] => Check whether 3 is smaller or larger than root val ( i.e. 2 ) => As 3 > 2 => 3 goes to right.\\niV. [ 1 ] => Check whether 1 is smaller or larger than root val ( i.e. 2 ) => As 1 < 2 => 1 goes to the left.\\n\\nNote: The given array is NOT a tree representation at all, it\\'s just the order of elements you\\'ll be provided to create a BST"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Yes you are correct. Build the BST using the property of it - smaller number goes to left and greater number goes to right."
                    },
                    {
                        "username": "czjnbb",
                        "content": "You have to build a BST."
                    },
                    {
                        "username": "czjnbb",
                        "content": "For me, using combination is easier for this kind of questions."
                    },
                    {
                        "username": "czjnbb",
                        "content": "[@ruturajpanditrao777](/ruturajpanditrao777) You already know the root (1st element), so you just need to maintain the order of the values smaller (arr1, len1) than the root and the values larger (arr2, len2) than the root. You need to pick len1/len2 spots from (len1 + len2) spots.\\n\\nDo this iteratively for arr1, arr2, etc..."
                    },
                    {
                        "username": "ruturajpanditrao777",
                        "content": "Yes i'm thinking about combinations. How did you approach the problem ? The relative order of elements less than root & greater than root should be same right? Like 3 1 4 5 2, 1 should always occur before 2 and also 4 should occur before 5 anywhere in array. How to solve this?\n"
                    },
                    {
                        "username": "aminbagheri",
                        "content": "This should be a medium, lol. Just some basic math "
                    },
                    {
                        "username": "synbat_d",
                        "content": "Hi, I solved this question on youtube. This is my first video on Youtube. Thank you. \\nhttps://youtu.be/FMfLFWdNStY"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "time limit exceeded for testcase 50"
                    }
                ]
            },
            {
                "id": 1933154,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Folks, get ready for a great weekend :\\'("
                    },
                    {
                        "username": "SanchitGhai",
                        "content": "dukh \\u256F\\uFE3F\\u2570"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "I don\\'t understand why I am getting runtime error in leetcode and not in onlinegdb "
                    },
                    {
                        "username": "feindreh",
                        "content": "i just hate all mod questions.... :D \\ncouldnt get the right answer on the 30 something test case went with BigInt and got it ...."
                    },
                    {
                        "username": "Tigarana",
                        "content": "I feel ya"
                    },
                    {
                        "username": "user2351Hg",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "I was able to solve the question after going through both the hints :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can this be solved using topologic sort?"
                    },
                    {
                        "username": "galimov-sa",
                        "content": "I\\'m very very sick today but I\\'ll try to solve this problem"
                    },
                    {
                        "username": "priyayadav1302",
                        "content": "I\\'m a new coder tried to maintain a streak . They didn\\'t even let me complete a weak."
                    },
                    {
                        "username": "agrima18",
                        "content": "Pheww, did it! Made a streak of 100 !!!"
                    },
                    {
                        "username": "SxreaM",
                        "content": "What a stupid error!\\nfor c++ users, add space after every line and don\\'t declare nCr array globally. Worked for me"
                    }
                ]
            },
            {
                "id": 1932536,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Folks, get ready for a great weekend :\\'("
                    },
                    {
                        "username": "SanchitGhai",
                        "content": "dukh \\u256F\\uFE3F\\u2570"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "I don\\'t understand why I am getting runtime error in leetcode and not in onlinegdb "
                    },
                    {
                        "username": "feindreh",
                        "content": "i just hate all mod questions.... :D \\ncouldnt get the right answer on the 30 something test case went with BigInt and got it ...."
                    },
                    {
                        "username": "Tigarana",
                        "content": "I feel ya"
                    },
                    {
                        "username": "user2351Hg",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "I was able to solve the question after going through both the hints :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can this be solved using topologic sort?"
                    },
                    {
                        "username": "galimov-sa",
                        "content": "I\\'m very very sick today but I\\'ll try to solve this problem"
                    },
                    {
                        "username": "priyayadav1302",
                        "content": "I\\'m a new coder tried to maintain a streak . They didn\\'t even let me complete a weak."
                    },
                    {
                        "username": "agrima18",
                        "content": "Pheww, did it! Made a streak of 100 !!!"
                    },
                    {
                        "username": "SxreaM",
                        "content": "What a stupid error!\\nfor c++ users, add space after every line and don\\'t declare nCr array globally. Worked for me"
                    }
                ]
            },
            {
                "id": 1932528,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Folks, get ready for a great weekend :\\'("
                    },
                    {
                        "username": "SanchitGhai",
                        "content": "dukh \\u256F\\uFE3F\\u2570"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "I don\\'t understand why I am getting runtime error in leetcode and not in onlinegdb "
                    },
                    {
                        "username": "feindreh",
                        "content": "i just hate all mod questions.... :D \\ncouldnt get the right answer on the 30 something test case went with BigInt and got it ...."
                    },
                    {
                        "username": "Tigarana",
                        "content": "I feel ya"
                    },
                    {
                        "username": "user2351Hg",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "I was able to solve the question after going through both the hints :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can this be solved using topologic sort?"
                    },
                    {
                        "username": "galimov-sa",
                        "content": "I\\'m very very sick today but I\\'ll try to solve this problem"
                    },
                    {
                        "username": "priyayadav1302",
                        "content": "I\\'m a new coder tried to maintain a streak . They didn\\'t even let me complete a weak."
                    },
                    {
                        "username": "agrima18",
                        "content": "Pheww, did it! Made a streak of 100 !!!"
                    },
                    {
                        "username": "SxreaM",
                        "content": "What a stupid error!\\nfor c++ users, add space after every line and don\\'t declare nCr array globally. Worked for me"
                    }
                ]
            },
            {
                "id": 1932498,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Folks, get ready for a great weekend :\\'("
                    },
                    {
                        "username": "SanchitGhai",
                        "content": "dukh \\u256F\\uFE3F\\u2570"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "I don\\'t understand why I am getting runtime error in leetcode and not in onlinegdb "
                    },
                    {
                        "username": "feindreh",
                        "content": "i just hate all mod questions.... :D \\ncouldnt get the right answer on the 30 something test case went with BigInt and got it ...."
                    },
                    {
                        "username": "Tigarana",
                        "content": "I feel ya"
                    },
                    {
                        "username": "user2351Hg",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "I was able to solve the question after going through both the hints :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can this be solved using topologic sort?"
                    },
                    {
                        "username": "galimov-sa",
                        "content": "I\\'m very very sick today but I\\'ll try to solve this problem"
                    },
                    {
                        "username": "priyayadav1302",
                        "content": "I\\'m a new coder tried to maintain a streak . They didn\\'t even let me complete a weak."
                    },
                    {
                        "username": "agrima18",
                        "content": "Pheww, did it! Made a streak of 100 !!!"
                    },
                    {
                        "username": "SxreaM",
                        "content": "What a stupid error!\\nfor c++ users, add space after every line and don\\'t declare nCr array globally. Worked for me"
                    }
                ]
            },
            {
                "id": 1932469,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Folks, get ready for a great weekend :\\'("
                    },
                    {
                        "username": "SanchitGhai",
                        "content": "dukh \\u256F\\uFE3F\\u2570"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "I don\\'t understand why I am getting runtime error in leetcode and not in onlinegdb "
                    },
                    {
                        "username": "feindreh",
                        "content": "i just hate all mod questions.... :D \\ncouldnt get the right answer on the 30 something test case went with BigInt and got it ...."
                    },
                    {
                        "username": "Tigarana",
                        "content": "I feel ya"
                    },
                    {
                        "username": "user2351Hg",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "I was able to solve the question after going through both the hints :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can this be solved using topologic sort?"
                    },
                    {
                        "username": "galimov-sa",
                        "content": "I\\'m very very sick today but I\\'ll try to solve this problem"
                    },
                    {
                        "username": "priyayadav1302",
                        "content": "I\\'m a new coder tried to maintain a streak . They didn\\'t even let me complete a weak."
                    },
                    {
                        "username": "agrima18",
                        "content": "Pheww, did it! Made a streak of 100 !!!"
                    },
                    {
                        "username": "SxreaM",
                        "content": "What a stupid error!\\nfor c++ users, add space after every line and don\\'t declare nCr array globally. Worked for me"
                    }
                ]
            },
            {
                "id": 1932458,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Folks, get ready for a great weekend :\\'("
                    },
                    {
                        "username": "SanchitGhai",
                        "content": "dukh \\u256F\\uFE3F\\u2570"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "I don\\'t understand why I am getting runtime error in leetcode and not in onlinegdb "
                    },
                    {
                        "username": "feindreh",
                        "content": "i just hate all mod questions.... :D \\ncouldnt get the right answer on the 30 something test case went with BigInt and got it ...."
                    },
                    {
                        "username": "Tigarana",
                        "content": "I feel ya"
                    },
                    {
                        "username": "user2351Hg",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "I was able to solve the question after going through both the hints :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can this be solved using topologic sort?"
                    },
                    {
                        "username": "galimov-sa",
                        "content": "I\\'m very very sick today but I\\'ll try to solve this problem"
                    },
                    {
                        "username": "priyayadav1302",
                        "content": "I\\'m a new coder tried to maintain a streak . They didn\\'t even let me complete a weak."
                    },
                    {
                        "username": "agrima18",
                        "content": "Pheww, did it! Made a streak of 100 !!!"
                    },
                    {
                        "username": "SxreaM",
                        "content": "What a stupid error!\\nfor c++ users, add space after every line and don\\'t declare nCr array globally. Worked for me"
                    }
                ]
            },
            {
                "id": 1932416,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Folks, get ready for a great weekend :\\'("
                    },
                    {
                        "username": "SanchitGhai",
                        "content": "dukh \\u256F\\uFE3F\\u2570"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "I don\\'t understand why I am getting runtime error in leetcode and not in onlinegdb "
                    },
                    {
                        "username": "feindreh",
                        "content": "i just hate all mod questions.... :D \\ncouldnt get the right answer on the 30 something test case went with BigInt and got it ...."
                    },
                    {
                        "username": "Tigarana",
                        "content": "I feel ya"
                    },
                    {
                        "username": "user2351Hg",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "I was able to solve the question after going through both the hints :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can this be solved using topologic sort?"
                    },
                    {
                        "username": "galimov-sa",
                        "content": "I\\'m very very sick today but I\\'ll try to solve this problem"
                    },
                    {
                        "username": "priyayadav1302",
                        "content": "I\\'m a new coder tried to maintain a streak . They didn\\'t even let me complete a weak."
                    },
                    {
                        "username": "agrima18",
                        "content": "Pheww, did it! Made a streak of 100 !!!"
                    },
                    {
                        "username": "SxreaM",
                        "content": "What a stupid error!\\nfor c++ users, add space after every line and don\\'t declare nCr array globally. Worked for me"
                    }
                ]
            },
            {
                "id": 1932381,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Folks, get ready for a great weekend :\\'("
                    },
                    {
                        "username": "SanchitGhai",
                        "content": "dukh \\u256F\\uFE3F\\u2570"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "I don\\'t understand why I am getting runtime error in leetcode and not in onlinegdb "
                    },
                    {
                        "username": "feindreh",
                        "content": "i just hate all mod questions.... :D \\ncouldnt get the right answer on the 30 something test case went with BigInt and got it ...."
                    },
                    {
                        "username": "Tigarana",
                        "content": "I feel ya"
                    },
                    {
                        "username": "user2351Hg",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "I was able to solve the question after going through both the hints :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can this be solved using topologic sort?"
                    },
                    {
                        "username": "galimov-sa",
                        "content": "I\\'m very very sick today but I\\'ll try to solve this problem"
                    },
                    {
                        "username": "priyayadav1302",
                        "content": "I\\'m a new coder tried to maintain a streak . They didn\\'t even let me complete a weak."
                    },
                    {
                        "username": "agrima18",
                        "content": "Pheww, did it! Made a streak of 100 !!!"
                    },
                    {
                        "username": "SxreaM",
                        "content": "What a stupid error!\\nfor c++ users, add space after every line and don\\'t declare nCr array globally. Worked for me"
                    }
                ]
            },
            {
                "id": 1932368,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Folks, get ready for a great weekend :\\'("
                    },
                    {
                        "username": "SanchitGhai",
                        "content": "dukh \\u256F\\uFE3F\\u2570"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "I don\\'t understand why I am getting runtime error in leetcode and not in onlinegdb "
                    },
                    {
                        "username": "feindreh",
                        "content": "i just hate all mod questions.... :D \\ncouldnt get the right answer on the 30 something test case went with BigInt and got it ...."
                    },
                    {
                        "username": "Tigarana",
                        "content": "I feel ya"
                    },
                    {
                        "username": "user2351Hg",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "I was able to solve the question after going through both the hints :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can this be solved using topologic sort?"
                    },
                    {
                        "username": "galimov-sa",
                        "content": "I\\'m very very sick today but I\\'ll try to solve this problem"
                    },
                    {
                        "username": "priyayadav1302",
                        "content": "I\\'m a new coder tried to maintain a streak . They didn\\'t even let me complete a weak."
                    },
                    {
                        "username": "agrima18",
                        "content": "Pheww, did it! Made a streak of 100 !!!"
                    },
                    {
                        "username": "SxreaM",
                        "content": "What a stupid error!\\nfor c++ users, add space after every line and don\\'t declare nCr array globally. Worked for me"
                    }
                ]
            },
            {
                "id": 1932346,
                "content": [
                    {
                        "username": "palak-agg",
                        "content": "Folks, get ready for a great weekend :\\'("
                    },
                    {
                        "username": "SanchitGhai",
                        "content": "dukh \\u256F\\uFE3F\\u2570"
                    },
                    {
                        "username": "Dominator3727",
                        "content": "I don\\'t understand why I am getting runtime error in leetcode and not in onlinegdb "
                    },
                    {
                        "username": "feindreh",
                        "content": "i just hate all mod questions.... :D \\ncouldnt get the right answer on the 30 something test case went with BigInt and got it ...."
                    },
                    {
                        "username": "Tigarana",
                        "content": "I feel ya"
                    },
                    {
                        "username": "user2351Hg",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "TryToBeTheBest",
                        "content": "I was able to solve the question after going through both the hints :)"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "can this be solved using topologic sort?"
                    },
                    {
                        "username": "galimov-sa",
                        "content": "I\\'m very very sick today but I\\'ll try to solve this problem"
                    },
                    {
                        "username": "priyayadav1302",
                        "content": "I\\'m a new coder tried to maintain a streak . They didn\\'t even let me complete a weak."
                    },
                    {
                        "username": "agrima18",
                        "content": "Pheww, did it! Made a streak of 100 !!!"
                    },
                    {
                        "username": "SxreaM",
                        "content": "What a stupid error!\\nfor c++ users, add space after every line and don\\'t declare nCr array globally. Worked for me"
                    }
                ]
            },
            {
                "id": 1932298,
                "content": [
                    {
                        "username": "Tigarana",
                        "content": "I\\'m having a lot of issues with the accuracy of my answer. When getting towards the later test cases, I start seeing accuracy errors, anyone who can help me with how to deal with it?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@yinboshi13](/yinboshi13) It shouldn't, but it was masked with the modulo (programming in python). \nUsing floor division fixed the issue. Thx"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "accuracy? are you using float?"
                    },
                    {
                        "username": "vnk01",
                        "content": "Finally, a problem worthy of our time after those humdrum questions over the past few days! The math path is rather intuitive. Not sure why the Editorial section make a big fuss out of it. I can\\'t get around the modding thing and need to use BigInteger again..."
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Best Problem to break your streak"
                    },
                    {
                        "username": "enkr1",
                        "content": "help, can someone explain why is `[3,1,2,5,4,6]` is expected to return 19? "
                    },
                    {
                        "username": "hrithik_248",
                        "content": "3 5 6 4 1 2 \\n3 5 6 1 2 4 \\n3 5 6 1 4 2 \\n3 5 4 6 1 2 \\n3 5 4 1 2 6 \\n3 5 4 1 6 2 \\n3 5 1 2 6 4 \\n3 5 1 2 4 6 \\n3 5 1 6 2 4 \\n3 5 1 6 4 2 \\n3 5 1 4 2 6 \\n3 5 1 4 6 2 \\n3 1 2 5 6 4 \\n3 1 5 6 4 2 \\n3 1 5 6 2 4 \\n3 1 5 4 6 2 \\n3 1 5 4 2 6 \\n3 1 5 2 6 4 \\n3 1 5 2 4 6 \\nthese are the possible permutation for this question. try to draw the tree you\\'ll understand. hope it helps."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\ndoes everone getting this runtime error after submittng ?"
                    },
                    {
                        "username": "vnk01",
                        "content": "I use Java and BigInteger (because I can\\'t get around those annoying mod constraint) and got the same issue and I tried to fix it like 20+ mins straight. Apparently, it seems like just adding this.xxx to your class variable when you refer to it inside a method fix it (for whatever reason \\uD83E\\uDD14)"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints were really helpful here.\\nTry to solve test case [3, 1, 2, 5, 4, 6] on paper with drawing.  Take one root at a time, consider left and right subtrees, and find arrangements of their nodes such that it relative order of a subtree\\'s nodes stays same."
                    },
                    {
                        "username": "rene_2412",
                        "content": "its over"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "Can anyone tell me a good playlist for dp on trees\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "People who work on farms are called farmers.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "yuriitaranets",
                        "content": "Hope you\\'ll enjoy \"Friday Challenge\""
                    }
                ]
            },
            {
                "id": 1932282,
                "content": [
                    {
                        "username": "Tigarana",
                        "content": "I\\'m having a lot of issues with the accuracy of my answer. When getting towards the later test cases, I start seeing accuracy errors, anyone who can help me with how to deal with it?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@yinboshi13](/yinboshi13) It shouldn't, but it was masked with the modulo (programming in python). \nUsing floor division fixed the issue. Thx"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "accuracy? are you using float?"
                    },
                    {
                        "username": "vnk01",
                        "content": "Finally, a problem worthy of our time after those humdrum questions over the past few days! The math path is rather intuitive. Not sure why the Editorial section make a big fuss out of it. I can\\'t get around the modding thing and need to use BigInteger again..."
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Best Problem to break your streak"
                    },
                    {
                        "username": "enkr1",
                        "content": "help, can someone explain why is `[3,1,2,5,4,6]` is expected to return 19? "
                    },
                    {
                        "username": "hrithik_248",
                        "content": "3 5 6 4 1 2 \\n3 5 6 1 2 4 \\n3 5 6 1 4 2 \\n3 5 4 6 1 2 \\n3 5 4 1 2 6 \\n3 5 4 1 6 2 \\n3 5 1 2 6 4 \\n3 5 1 2 4 6 \\n3 5 1 6 2 4 \\n3 5 1 6 4 2 \\n3 5 1 4 2 6 \\n3 5 1 4 6 2 \\n3 1 2 5 6 4 \\n3 1 5 6 4 2 \\n3 1 5 6 2 4 \\n3 1 5 4 6 2 \\n3 1 5 4 2 6 \\n3 1 5 2 6 4 \\n3 1 5 2 4 6 \\nthese are the possible permutation for this question. try to draw the tree you\\'ll understand. hope it helps."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\ndoes everone getting this runtime error after submittng ?"
                    },
                    {
                        "username": "vnk01",
                        "content": "I use Java and BigInteger (because I can\\'t get around those annoying mod constraint) and got the same issue and I tried to fix it like 20+ mins straight. Apparently, it seems like just adding this.xxx to your class variable when you refer to it inside a method fix it (for whatever reason \\uD83E\\uDD14)"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints were really helpful here.\\nTry to solve test case [3, 1, 2, 5, 4, 6] on paper with drawing.  Take one root at a time, consider left and right subtrees, and find arrangements of their nodes such that it relative order of a subtree\\'s nodes stays same."
                    },
                    {
                        "username": "rene_2412",
                        "content": "its over"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "Can anyone tell me a good playlist for dp on trees\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "People who work on farms are called farmers.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "yuriitaranets",
                        "content": "Hope you\\'ll enjoy \"Friday Challenge\""
                    }
                ]
            },
            {
                "id": 1932208,
                "content": [
                    {
                        "username": "Tigarana",
                        "content": "I\\'m having a lot of issues with the accuracy of my answer. When getting towards the later test cases, I start seeing accuracy errors, anyone who can help me with how to deal with it?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@yinboshi13](/yinboshi13) It shouldn't, but it was masked with the modulo (programming in python). \nUsing floor division fixed the issue. Thx"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "accuracy? are you using float?"
                    },
                    {
                        "username": "vnk01",
                        "content": "Finally, a problem worthy of our time after those humdrum questions over the past few days! The math path is rather intuitive. Not sure why the Editorial section make a big fuss out of it. I can\\'t get around the modding thing and need to use BigInteger again..."
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Best Problem to break your streak"
                    },
                    {
                        "username": "enkr1",
                        "content": "help, can someone explain why is `[3,1,2,5,4,6]` is expected to return 19? "
                    },
                    {
                        "username": "hrithik_248",
                        "content": "3 5 6 4 1 2 \\n3 5 6 1 2 4 \\n3 5 6 1 4 2 \\n3 5 4 6 1 2 \\n3 5 4 1 2 6 \\n3 5 4 1 6 2 \\n3 5 1 2 6 4 \\n3 5 1 2 4 6 \\n3 5 1 6 2 4 \\n3 5 1 6 4 2 \\n3 5 1 4 2 6 \\n3 5 1 4 6 2 \\n3 1 2 5 6 4 \\n3 1 5 6 4 2 \\n3 1 5 6 2 4 \\n3 1 5 4 6 2 \\n3 1 5 4 2 6 \\n3 1 5 2 6 4 \\n3 1 5 2 4 6 \\nthese are the possible permutation for this question. try to draw the tree you\\'ll understand. hope it helps."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\ndoes everone getting this runtime error after submittng ?"
                    },
                    {
                        "username": "vnk01",
                        "content": "I use Java and BigInteger (because I can\\'t get around those annoying mod constraint) and got the same issue and I tried to fix it like 20+ mins straight. Apparently, it seems like just adding this.xxx to your class variable when you refer to it inside a method fix it (for whatever reason \\uD83E\\uDD14)"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints were really helpful here.\\nTry to solve test case [3, 1, 2, 5, 4, 6] on paper with drawing.  Take one root at a time, consider left and right subtrees, and find arrangements of their nodes such that it relative order of a subtree\\'s nodes stays same."
                    },
                    {
                        "username": "rene_2412",
                        "content": "its over"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "Can anyone tell me a good playlist for dp on trees\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "People who work on farms are called farmers.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "yuriitaranets",
                        "content": "Hope you\\'ll enjoy \"Friday Challenge\""
                    }
                ]
            },
            {
                "id": 1932188,
                "content": [
                    {
                        "username": "Tigarana",
                        "content": "I\\'m having a lot of issues with the accuracy of my answer. When getting towards the later test cases, I start seeing accuracy errors, anyone who can help me with how to deal with it?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@yinboshi13](/yinboshi13) It shouldn't, but it was masked with the modulo (programming in python). \nUsing floor division fixed the issue. Thx"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "accuracy? are you using float?"
                    },
                    {
                        "username": "vnk01",
                        "content": "Finally, a problem worthy of our time after those humdrum questions over the past few days! The math path is rather intuitive. Not sure why the Editorial section make a big fuss out of it. I can\\'t get around the modding thing and need to use BigInteger again..."
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Best Problem to break your streak"
                    },
                    {
                        "username": "enkr1",
                        "content": "help, can someone explain why is `[3,1,2,5,4,6]` is expected to return 19? "
                    },
                    {
                        "username": "hrithik_248",
                        "content": "3 5 6 4 1 2 \\n3 5 6 1 2 4 \\n3 5 6 1 4 2 \\n3 5 4 6 1 2 \\n3 5 4 1 2 6 \\n3 5 4 1 6 2 \\n3 5 1 2 6 4 \\n3 5 1 2 4 6 \\n3 5 1 6 2 4 \\n3 5 1 6 4 2 \\n3 5 1 4 2 6 \\n3 5 1 4 6 2 \\n3 1 2 5 6 4 \\n3 1 5 6 4 2 \\n3 1 5 6 2 4 \\n3 1 5 4 6 2 \\n3 1 5 4 2 6 \\n3 1 5 2 6 4 \\n3 1 5 2 4 6 \\nthese are the possible permutation for this question. try to draw the tree you\\'ll understand. hope it helps."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\ndoes everone getting this runtime error after submittng ?"
                    },
                    {
                        "username": "vnk01",
                        "content": "I use Java and BigInteger (because I can\\'t get around those annoying mod constraint) and got the same issue and I tried to fix it like 20+ mins straight. Apparently, it seems like just adding this.xxx to your class variable when you refer to it inside a method fix it (for whatever reason \\uD83E\\uDD14)"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints were really helpful here.\\nTry to solve test case [3, 1, 2, 5, 4, 6] on paper with drawing.  Take one root at a time, consider left and right subtrees, and find arrangements of their nodes such that it relative order of a subtree\\'s nodes stays same."
                    },
                    {
                        "username": "rene_2412",
                        "content": "its over"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "Can anyone tell me a good playlist for dp on trees\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "People who work on farms are called farmers.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "yuriitaranets",
                        "content": "Hope you\\'ll enjoy \"Friday Challenge\""
                    }
                ]
            },
            {
                "id": 1932176,
                "content": [
                    {
                        "username": "Tigarana",
                        "content": "I\\'m having a lot of issues with the accuracy of my answer. When getting towards the later test cases, I start seeing accuracy errors, anyone who can help me with how to deal with it?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@yinboshi13](/yinboshi13) It shouldn't, but it was masked with the modulo (programming in python). \nUsing floor division fixed the issue. Thx"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "accuracy? are you using float?"
                    },
                    {
                        "username": "vnk01",
                        "content": "Finally, a problem worthy of our time after those humdrum questions over the past few days! The math path is rather intuitive. Not sure why the Editorial section make a big fuss out of it. I can\\'t get around the modding thing and need to use BigInteger again..."
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Best Problem to break your streak"
                    },
                    {
                        "username": "enkr1",
                        "content": "help, can someone explain why is `[3,1,2,5,4,6]` is expected to return 19? "
                    },
                    {
                        "username": "hrithik_248",
                        "content": "3 5 6 4 1 2 \\n3 5 6 1 2 4 \\n3 5 6 1 4 2 \\n3 5 4 6 1 2 \\n3 5 4 1 2 6 \\n3 5 4 1 6 2 \\n3 5 1 2 6 4 \\n3 5 1 2 4 6 \\n3 5 1 6 2 4 \\n3 5 1 6 4 2 \\n3 5 1 4 2 6 \\n3 5 1 4 6 2 \\n3 1 2 5 6 4 \\n3 1 5 6 4 2 \\n3 1 5 6 2 4 \\n3 1 5 4 6 2 \\n3 1 5 4 2 6 \\n3 1 5 2 6 4 \\n3 1 5 2 4 6 \\nthese are the possible permutation for this question. try to draw the tree you\\'ll understand. hope it helps."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\ndoes everone getting this runtime error after submittng ?"
                    },
                    {
                        "username": "vnk01",
                        "content": "I use Java and BigInteger (because I can\\'t get around those annoying mod constraint) and got the same issue and I tried to fix it like 20+ mins straight. Apparently, it seems like just adding this.xxx to your class variable when you refer to it inside a method fix it (for whatever reason \\uD83E\\uDD14)"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints were really helpful here.\\nTry to solve test case [3, 1, 2, 5, 4, 6] on paper with drawing.  Take one root at a time, consider left and right subtrees, and find arrangements of their nodes such that it relative order of a subtree\\'s nodes stays same."
                    },
                    {
                        "username": "rene_2412",
                        "content": "its over"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "Can anyone tell me a good playlist for dp on trees\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "People who work on farms are called farmers.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "yuriitaranets",
                        "content": "Hope you\\'ll enjoy \"Friday Challenge\""
                    }
                ]
            },
            {
                "id": 1932166,
                "content": [
                    {
                        "username": "Tigarana",
                        "content": "I\\'m having a lot of issues with the accuracy of my answer. When getting towards the later test cases, I start seeing accuracy errors, anyone who can help me with how to deal with it?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@yinboshi13](/yinboshi13) It shouldn't, but it was masked with the modulo (programming in python). \nUsing floor division fixed the issue. Thx"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "accuracy? are you using float?"
                    },
                    {
                        "username": "vnk01",
                        "content": "Finally, a problem worthy of our time after those humdrum questions over the past few days! The math path is rather intuitive. Not sure why the Editorial section make a big fuss out of it. I can\\'t get around the modding thing and need to use BigInteger again..."
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Best Problem to break your streak"
                    },
                    {
                        "username": "enkr1",
                        "content": "help, can someone explain why is `[3,1,2,5,4,6]` is expected to return 19? "
                    },
                    {
                        "username": "hrithik_248",
                        "content": "3 5 6 4 1 2 \\n3 5 6 1 2 4 \\n3 5 6 1 4 2 \\n3 5 4 6 1 2 \\n3 5 4 1 2 6 \\n3 5 4 1 6 2 \\n3 5 1 2 6 4 \\n3 5 1 2 4 6 \\n3 5 1 6 2 4 \\n3 5 1 6 4 2 \\n3 5 1 4 2 6 \\n3 5 1 4 6 2 \\n3 1 2 5 6 4 \\n3 1 5 6 4 2 \\n3 1 5 6 2 4 \\n3 1 5 4 6 2 \\n3 1 5 4 2 6 \\n3 1 5 2 6 4 \\n3 1 5 2 4 6 \\nthese are the possible permutation for this question. try to draw the tree you\\'ll understand. hope it helps."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\ndoes everone getting this runtime error after submittng ?"
                    },
                    {
                        "username": "vnk01",
                        "content": "I use Java and BigInteger (because I can\\'t get around those annoying mod constraint) and got the same issue and I tried to fix it like 20+ mins straight. Apparently, it seems like just adding this.xxx to your class variable when you refer to it inside a method fix it (for whatever reason \\uD83E\\uDD14)"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints were really helpful here.\\nTry to solve test case [3, 1, 2, 5, 4, 6] on paper with drawing.  Take one root at a time, consider left and right subtrees, and find arrangements of their nodes such that it relative order of a subtree\\'s nodes stays same."
                    },
                    {
                        "username": "rene_2412",
                        "content": "its over"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "Can anyone tell me a good playlist for dp on trees\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "People who work on farms are called farmers.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "yuriitaranets",
                        "content": "Hope you\\'ll enjoy \"Friday Challenge\""
                    }
                ]
            },
            {
                "id": 1932161,
                "content": [
                    {
                        "username": "Tigarana",
                        "content": "I\\'m having a lot of issues with the accuracy of my answer. When getting towards the later test cases, I start seeing accuracy errors, anyone who can help me with how to deal with it?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@yinboshi13](/yinboshi13) It shouldn't, but it was masked with the modulo (programming in python). \nUsing floor division fixed the issue. Thx"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "accuracy? are you using float?"
                    },
                    {
                        "username": "vnk01",
                        "content": "Finally, a problem worthy of our time after those humdrum questions over the past few days! The math path is rather intuitive. Not sure why the Editorial section make a big fuss out of it. I can\\'t get around the modding thing and need to use BigInteger again..."
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Best Problem to break your streak"
                    },
                    {
                        "username": "enkr1",
                        "content": "help, can someone explain why is `[3,1,2,5,4,6]` is expected to return 19? "
                    },
                    {
                        "username": "hrithik_248",
                        "content": "3 5 6 4 1 2 \\n3 5 6 1 2 4 \\n3 5 6 1 4 2 \\n3 5 4 6 1 2 \\n3 5 4 1 2 6 \\n3 5 4 1 6 2 \\n3 5 1 2 6 4 \\n3 5 1 2 4 6 \\n3 5 1 6 2 4 \\n3 5 1 6 4 2 \\n3 5 1 4 2 6 \\n3 5 1 4 6 2 \\n3 1 2 5 6 4 \\n3 1 5 6 4 2 \\n3 1 5 6 2 4 \\n3 1 5 4 6 2 \\n3 1 5 4 2 6 \\n3 1 5 2 6 4 \\n3 1 5 2 4 6 \\nthese are the possible permutation for this question. try to draw the tree you\\'ll understand. hope it helps."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\ndoes everone getting this runtime error after submittng ?"
                    },
                    {
                        "username": "vnk01",
                        "content": "I use Java and BigInteger (because I can\\'t get around those annoying mod constraint) and got the same issue and I tried to fix it like 20+ mins straight. Apparently, it seems like just adding this.xxx to your class variable when you refer to it inside a method fix it (for whatever reason \\uD83E\\uDD14)"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints were really helpful here.\\nTry to solve test case [3, 1, 2, 5, 4, 6] on paper with drawing.  Take one root at a time, consider left and right subtrees, and find arrangements of their nodes such that it relative order of a subtree\\'s nodes stays same."
                    },
                    {
                        "username": "rene_2412",
                        "content": "its over"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "Can anyone tell me a good playlist for dp on trees\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "People who work on farms are called farmers.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "yuriitaranets",
                        "content": "Hope you\\'ll enjoy \"Friday Challenge\""
                    }
                ]
            },
            {
                "id": 1932157,
                "content": [
                    {
                        "username": "Tigarana",
                        "content": "I\\'m having a lot of issues with the accuracy of my answer. When getting towards the later test cases, I start seeing accuracy errors, anyone who can help me with how to deal with it?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@yinboshi13](/yinboshi13) It shouldn't, but it was masked with the modulo (programming in python). \nUsing floor division fixed the issue. Thx"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "accuracy? are you using float?"
                    },
                    {
                        "username": "vnk01",
                        "content": "Finally, a problem worthy of our time after those humdrum questions over the past few days! The math path is rather intuitive. Not sure why the Editorial section make a big fuss out of it. I can\\'t get around the modding thing and need to use BigInteger again..."
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Best Problem to break your streak"
                    },
                    {
                        "username": "enkr1",
                        "content": "help, can someone explain why is `[3,1,2,5,4,6]` is expected to return 19? "
                    },
                    {
                        "username": "hrithik_248",
                        "content": "3 5 6 4 1 2 \\n3 5 6 1 2 4 \\n3 5 6 1 4 2 \\n3 5 4 6 1 2 \\n3 5 4 1 2 6 \\n3 5 4 1 6 2 \\n3 5 1 2 6 4 \\n3 5 1 2 4 6 \\n3 5 1 6 2 4 \\n3 5 1 6 4 2 \\n3 5 1 4 2 6 \\n3 5 1 4 6 2 \\n3 1 2 5 6 4 \\n3 1 5 6 4 2 \\n3 1 5 6 2 4 \\n3 1 5 4 6 2 \\n3 1 5 4 2 6 \\n3 1 5 2 6 4 \\n3 1 5 2 4 6 \\nthese are the possible permutation for this question. try to draw the tree you\\'ll understand. hope it helps."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\ndoes everone getting this runtime error after submittng ?"
                    },
                    {
                        "username": "vnk01",
                        "content": "I use Java and BigInteger (because I can\\'t get around those annoying mod constraint) and got the same issue and I tried to fix it like 20+ mins straight. Apparently, it seems like just adding this.xxx to your class variable when you refer to it inside a method fix it (for whatever reason \\uD83E\\uDD14)"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints were really helpful here.\\nTry to solve test case [3, 1, 2, 5, 4, 6] on paper with drawing.  Take one root at a time, consider left and right subtrees, and find arrangements of their nodes such that it relative order of a subtree\\'s nodes stays same."
                    },
                    {
                        "username": "rene_2412",
                        "content": "its over"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "Can anyone tell me a good playlist for dp on trees\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "People who work on farms are called farmers.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "yuriitaranets",
                        "content": "Hope you\\'ll enjoy \"Friday Challenge\""
                    }
                ]
            },
            {
                "id": 1932153,
                "content": [
                    {
                        "username": "Tigarana",
                        "content": "I\\'m having a lot of issues with the accuracy of my answer. When getting towards the later test cases, I start seeing accuracy errors, anyone who can help me with how to deal with it?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@yinboshi13](/yinboshi13) It shouldn't, but it was masked with the modulo (programming in python). \nUsing floor division fixed the issue. Thx"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "accuracy? are you using float?"
                    },
                    {
                        "username": "vnk01",
                        "content": "Finally, a problem worthy of our time after those humdrum questions over the past few days! The math path is rather intuitive. Not sure why the Editorial section make a big fuss out of it. I can\\'t get around the modding thing and need to use BigInteger again..."
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Best Problem to break your streak"
                    },
                    {
                        "username": "enkr1",
                        "content": "help, can someone explain why is `[3,1,2,5,4,6]` is expected to return 19? "
                    },
                    {
                        "username": "hrithik_248",
                        "content": "3 5 6 4 1 2 \\n3 5 6 1 2 4 \\n3 5 6 1 4 2 \\n3 5 4 6 1 2 \\n3 5 4 1 2 6 \\n3 5 4 1 6 2 \\n3 5 1 2 6 4 \\n3 5 1 2 4 6 \\n3 5 1 6 2 4 \\n3 5 1 6 4 2 \\n3 5 1 4 2 6 \\n3 5 1 4 6 2 \\n3 1 2 5 6 4 \\n3 1 5 6 4 2 \\n3 1 5 6 2 4 \\n3 1 5 4 6 2 \\n3 1 5 4 2 6 \\n3 1 5 2 6 4 \\n3 1 5 2 4 6 \\nthese are the possible permutation for this question. try to draw the tree you\\'ll understand. hope it helps."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\ndoes everone getting this runtime error after submittng ?"
                    },
                    {
                        "username": "vnk01",
                        "content": "I use Java and BigInteger (because I can\\'t get around those annoying mod constraint) and got the same issue and I tried to fix it like 20+ mins straight. Apparently, it seems like just adding this.xxx to your class variable when you refer to it inside a method fix it (for whatever reason \\uD83E\\uDD14)"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints were really helpful here.\\nTry to solve test case [3, 1, 2, 5, 4, 6] on paper with drawing.  Take one root at a time, consider left and right subtrees, and find arrangements of their nodes such that it relative order of a subtree\\'s nodes stays same."
                    },
                    {
                        "username": "rene_2412",
                        "content": "its over"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "Can anyone tell me a good playlist for dp on trees\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "People who work on farms are called farmers.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "yuriitaranets",
                        "content": "Hope you\\'ll enjoy \"Friday Challenge\""
                    }
                ]
            },
            {
                "id": 1932104,
                "content": [
                    {
                        "username": "Tigarana",
                        "content": "I\\'m having a lot of issues with the accuracy of my answer. When getting towards the later test cases, I start seeing accuracy errors, anyone who can help me with how to deal with it?"
                    },
                    {
                        "username": "Tigarana",
                        "content": "[@yinboshi13](/yinboshi13) It shouldn't, but it was masked with the modulo (programming in python). \nUsing floor division fixed the issue. Thx"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "accuracy? are you using float?"
                    },
                    {
                        "username": "vnk01",
                        "content": "Finally, a problem worthy of our time after those humdrum questions over the past few days! The math path is rather intuitive. Not sure why the Editorial section make a big fuss out of it. I can\\'t get around the modding thing and need to use BigInteger again..."
                    },
                    {
                        "username": "satishvegisetti563",
                        "content": "Best Problem to break your streak"
                    },
                    {
                        "username": "enkr1",
                        "content": "help, can someone explain why is `[3,1,2,5,4,6]` is expected to return 19? "
                    },
                    {
                        "username": "hrithik_248",
                        "content": "3 5 6 4 1 2 \\n3 5 6 1 2 4 \\n3 5 6 1 4 2 \\n3 5 4 6 1 2 \\n3 5 4 1 2 6 \\n3 5 4 1 6 2 \\n3 5 1 2 6 4 \\n3 5 1 2 4 6 \\n3 5 1 6 2 4 \\n3 5 1 6 4 2 \\n3 5 1 4 2 6 \\n3 5 1 4 6 2 \\n3 1 2 5 6 4 \\n3 1 5 6 4 2 \\n3 1 5 6 2 4 \\n3 1 5 4 6 2 \\n3 1 5 4 2 6 \\n3 1 5 2 6 4 \\n3 1 5 2 4 6 \\nthese are the possible permutation for this question. try to draw the tree you\\'ll understand. hope it helps."
                    },
                    {
                        "username": "pankajpnd2001",
                        "content": "[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached\\ndoes everone getting this runtime error after submittng ?"
                    },
                    {
                        "username": "vnk01",
                        "content": "I use Java and BigInteger (because I can\\'t get around those annoying mod constraint) and got the same issue and I tried to fix it like 20+ mins straight. Apparently, it seems like just adding this.xxx to your class variable when you refer to it inside a method fix it (for whatever reason \\uD83E\\uDD14)"
                    },
                    {
                        "username": "cJayesh",
                        "content": "Hints were really helpful here.\\nTry to solve test case [3, 1, 2, 5, 4, 6] on paper with drawing.  Take one root at a time, consider left and right subtrees, and find arrangements of their nodes such that it relative order of a subtree\\'s nodes stays same."
                    },
                    {
                        "username": "rene_2412",
                        "content": "its over"
                    },
                    {
                        "username": "Dhairya_Vardhan_Chauhan",
                        "content": "Can anyone tell me a good playlist for dp on trees\\n"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "People who work on farms are called farmers.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "yuriitaranets",
                        "content": "Hope you\\'ll enjoy \"Friday Challenge\""
                    }
                ]
            },
            {
                "id": 1932103,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "when building pascal\\'s triangle is just a preparation step, you know you\\'re gonna have a bad time."
                    },
                    {
                        "username": "Reethik_27",
                        "content": "Wake up to the  reality nothing ever goes as planned in this accursed world - Madara Uchiha"
                    },
                    {
                        "username": "Aravind_Swaminathan",
                        "content": "working on this for past 17hrs\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can someone help with this error that I am getting after submitting solution for this problem?\\n\\n\"\"==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\"\"\\n\\nThe program is running fine for all the test cases, but showing the above runtime error after submitting the solution."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "This is error is not because of your code instead its the JAVA and C++ compiler issue of leetcode since last night. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "hello fellow c++\\'er - i get addressSanitizer usually when i try to access an unallocated index of a vector or array..  you can \"debug\" the leetcode runtime with cerr messages to pinpoint where ur issue is happening"
                    },
                    {
                        "username": "halfengineer",
                        "content": "First thought that oh catalan number will work still figuring out how\\uD83D\\uDE13\\uD83D\\uDE13"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Oh my god, I literally just saw red squiggly line in the COMMENTS SECTION. I think I should use Rust less :/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "What a great question!"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "If you not understand problem clearly then here is explanation\nLet's suppose we have given array [3,4,5,1,2] and empty tree\nthen we have to place element in tree by order they comes  i.e. \nwe get first element 3 make it root then we have element 4 make it to right child of 3,\nnow element 5 come make it to right child of 4 then element 1 come make it to left child of 3 which is its correct position according to BST rule (i.e. smaller element left side and larger element right side) now 2 come make it to right child of 1.\nNow we have to find how many arrangements of give permutation give same BST.\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\nHint: writes all arrangement of array try to find pattern in this.\n(Sorry for poor English)."
                    },
                    {
                        "username": "Karilli",
                        "content": "I am starting a petition that leatcode has to accept O(n!) solutions on this problem. Let me keep my streak pliiiz."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "How array is mapped into tree. Please anyone clear my doubt in example."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n    \\'\\'\\'def insertNode(self,node,data):\\n        if node is None:\\n            return self.createNode(data)\\n        if data < node.data :\\n            node.left = self.insertNode(node.left,data)\\n        else :\\n            node.right = self.insertNode(node.right,data)\\n        return node\\'\\'\\'\\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "You have to simply insert the values of array one by one by just following the rules of BST . \\nSmaller values will be on left and larger value on right ."
                    }
                ]
            },
            {
                "id": 1932101,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "when building pascal\\'s triangle is just a preparation step, you know you\\'re gonna have a bad time."
                    },
                    {
                        "username": "Reethik_27",
                        "content": "Wake up to the  reality nothing ever goes as planned in this accursed world - Madara Uchiha"
                    },
                    {
                        "username": "Aravind_Swaminathan",
                        "content": "working on this for past 17hrs\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can someone help with this error that I am getting after submitting solution for this problem?\\n\\n\"\"==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\"\"\\n\\nThe program is running fine for all the test cases, but showing the above runtime error after submitting the solution."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "This is error is not because of your code instead its the JAVA and C++ compiler issue of leetcode since last night. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "hello fellow c++\\'er - i get addressSanitizer usually when i try to access an unallocated index of a vector or array..  you can \"debug\" the leetcode runtime with cerr messages to pinpoint where ur issue is happening"
                    },
                    {
                        "username": "halfengineer",
                        "content": "First thought that oh catalan number will work still figuring out how\\uD83D\\uDE13\\uD83D\\uDE13"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Oh my god, I literally just saw red squiggly line in the COMMENTS SECTION. I think I should use Rust less :/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "What a great question!"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "If you not understand problem clearly then here is explanation\nLet's suppose we have given array [3,4,5,1,2] and empty tree\nthen we have to place element in tree by order they comes  i.e. \nwe get first element 3 make it root then we have element 4 make it to right child of 3,\nnow element 5 come make it to right child of 4 then element 1 come make it to left child of 3 which is its correct position according to BST rule (i.e. smaller element left side and larger element right side) now 2 come make it to right child of 1.\nNow we have to find how many arrangements of give permutation give same BST.\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\nHint: writes all arrangement of array try to find pattern in this.\n(Sorry for poor English)."
                    },
                    {
                        "username": "Karilli",
                        "content": "I am starting a petition that leatcode has to accept O(n!) solutions on this problem. Let me keep my streak pliiiz."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "How array is mapped into tree. Please anyone clear my doubt in example."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n    \\'\\'\\'def insertNode(self,node,data):\\n        if node is None:\\n            return self.createNode(data)\\n        if data < node.data :\\n            node.left = self.insertNode(node.left,data)\\n        else :\\n            node.right = self.insertNode(node.right,data)\\n        return node\\'\\'\\'\\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "You have to simply insert the values of array one by one by just following the rules of BST . \\nSmaller values will be on left and larger value on right ."
                    }
                ]
            },
            {
                "id": 1932088,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "when building pascal\\'s triangle is just a preparation step, you know you\\'re gonna have a bad time."
                    },
                    {
                        "username": "Reethik_27",
                        "content": "Wake up to the  reality nothing ever goes as planned in this accursed world - Madara Uchiha"
                    },
                    {
                        "username": "Aravind_Swaminathan",
                        "content": "working on this for past 17hrs\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can someone help with this error that I am getting after submitting solution for this problem?\\n\\n\"\"==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\"\"\\n\\nThe program is running fine for all the test cases, but showing the above runtime error after submitting the solution."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "This is error is not because of your code instead its the JAVA and C++ compiler issue of leetcode since last night. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "hello fellow c++\\'er - i get addressSanitizer usually when i try to access an unallocated index of a vector or array..  you can \"debug\" the leetcode runtime with cerr messages to pinpoint where ur issue is happening"
                    },
                    {
                        "username": "halfengineer",
                        "content": "First thought that oh catalan number will work still figuring out how\\uD83D\\uDE13\\uD83D\\uDE13"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Oh my god, I literally just saw red squiggly line in the COMMENTS SECTION. I think I should use Rust less :/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "What a great question!"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "If you not understand problem clearly then here is explanation\nLet's suppose we have given array [3,4,5,1,2] and empty tree\nthen we have to place element in tree by order they comes  i.e. \nwe get first element 3 make it root then we have element 4 make it to right child of 3,\nnow element 5 come make it to right child of 4 then element 1 come make it to left child of 3 which is its correct position according to BST rule (i.e. smaller element left side and larger element right side) now 2 come make it to right child of 1.\nNow we have to find how many arrangements of give permutation give same BST.\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\nHint: writes all arrangement of array try to find pattern in this.\n(Sorry for poor English)."
                    },
                    {
                        "username": "Karilli",
                        "content": "I am starting a petition that leatcode has to accept O(n!) solutions on this problem. Let me keep my streak pliiiz."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "How array is mapped into tree. Please anyone clear my doubt in example."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n    \\'\\'\\'def insertNode(self,node,data):\\n        if node is None:\\n            return self.createNode(data)\\n        if data < node.data :\\n            node.left = self.insertNode(node.left,data)\\n        else :\\n            node.right = self.insertNode(node.right,data)\\n        return node\\'\\'\\'\\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "You have to simply insert the values of array one by one by just following the rules of BST . \\nSmaller values will be on left and larger value on right ."
                    }
                ]
            },
            {
                "id": 1932062,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "when building pascal\\'s triangle is just a preparation step, you know you\\'re gonna have a bad time."
                    },
                    {
                        "username": "Reethik_27",
                        "content": "Wake up to the  reality nothing ever goes as planned in this accursed world - Madara Uchiha"
                    },
                    {
                        "username": "Aravind_Swaminathan",
                        "content": "working on this for past 17hrs\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can someone help with this error that I am getting after submitting solution for this problem?\\n\\n\"\"==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\"\"\\n\\nThe program is running fine for all the test cases, but showing the above runtime error after submitting the solution."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "This is error is not because of your code instead its the JAVA and C++ compiler issue of leetcode since last night. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "hello fellow c++\\'er - i get addressSanitizer usually when i try to access an unallocated index of a vector or array..  you can \"debug\" the leetcode runtime with cerr messages to pinpoint where ur issue is happening"
                    },
                    {
                        "username": "halfengineer",
                        "content": "First thought that oh catalan number will work still figuring out how\\uD83D\\uDE13\\uD83D\\uDE13"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Oh my god, I literally just saw red squiggly line in the COMMENTS SECTION. I think I should use Rust less :/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "What a great question!"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "If you not understand problem clearly then here is explanation\nLet's suppose we have given array [3,4,5,1,2] and empty tree\nthen we have to place element in tree by order they comes  i.e. \nwe get first element 3 make it root then we have element 4 make it to right child of 3,\nnow element 5 come make it to right child of 4 then element 1 come make it to left child of 3 which is its correct position according to BST rule (i.e. smaller element left side and larger element right side) now 2 come make it to right child of 1.\nNow we have to find how many arrangements of give permutation give same BST.\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\nHint: writes all arrangement of array try to find pattern in this.\n(Sorry for poor English)."
                    },
                    {
                        "username": "Karilli",
                        "content": "I am starting a petition that leatcode has to accept O(n!) solutions on this problem. Let me keep my streak pliiiz."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "How array is mapped into tree. Please anyone clear my doubt in example."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n    \\'\\'\\'def insertNode(self,node,data):\\n        if node is None:\\n            return self.createNode(data)\\n        if data < node.data :\\n            node.left = self.insertNode(node.left,data)\\n        else :\\n            node.right = self.insertNode(node.right,data)\\n        return node\\'\\'\\'\\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "You have to simply insert the values of array one by one by just following the rules of BST . \\nSmaller values will be on left and larger value on right ."
                    }
                ]
            },
            {
                "id": 1932057,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "when building pascal\\'s triangle is just a preparation step, you know you\\'re gonna have a bad time."
                    },
                    {
                        "username": "Reethik_27",
                        "content": "Wake up to the  reality nothing ever goes as planned in this accursed world - Madara Uchiha"
                    },
                    {
                        "username": "Aravind_Swaminathan",
                        "content": "working on this for past 17hrs\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can someone help with this error that I am getting after submitting solution for this problem?\\n\\n\"\"==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\"\"\\n\\nThe program is running fine for all the test cases, but showing the above runtime error after submitting the solution."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "This is error is not because of your code instead its the JAVA and C++ compiler issue of leetcode since last night. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "hello fellow c++\\'er - i get addressSanitizer usually when i try to access an unallocated index of a vector or array..  you can \"debug\" the leetcode runtime with cerr messages to pinpoint where ur issue is happening"
                    },
                    {
                        "username": "halfengineer",
                        "content": "First thought that oh catalan number will work still figuring out how\\uD83D\\uDE13\\uD83D\\uDE13"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Oh my god, I literally just saw red squiggly line in the COMMENTS SECTION. I think I should use Rust less :/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "What a great question!"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "If you not understand problem clearly then here is explanation\nLet's suppose we have given array [3,4,5,1,2] and empty tree\nthen we have to place element in tree by order they comes  i.e. \nwe get first element 3 make it root then we have element 4 make it to right child of 3,\nnow element 5 come make it to right child of 4 then element 1 come make it to left child of 3 which is its correct position according to BST rule (i.e. smaller element left side and larger element right side) now 2 come make it to right child of 1.\nNow we have to find how many arrangements of give permutation give same BST.\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\nHint: writes all arrangement of array try to find pattern in this.\n(Sorry for poor English)."
                    },
                    {
                        "username": "Karilli",
                        "content": "I am starting a petition that leatcode has to accept O(n!) solutions on this problem. Let me keep my streak pliiiz."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "How array is mapped into tree. Please anyone clear my doubt in example."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n    \\'\\'\\'def insertNode(self,node,data):\\n        if node is None:\\n            return self.createNode(data)\\n        if data < node.data :\\n            node.left = self.insertNode(node.left,data)\\n        else :\\n            node.right = self.insertNode(node.right,data)\\n        return node\\'\\'\\'\\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "You have to simply insert the values of array one by one by just following the rules of BST . \\nSmaller values will be on left and larger value on right ."
                    }
                ]
            },
            {
                "id": 1931963,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "when building pascal\\'s triangle is just a preparation step, you know you\\'re gonna have a bad time."
                    },
                    {
                        "username": "Reethik_27",
                        "content": "Wake up to the  reality nothing ever goes as planned in this accursed world - Madara Uchiha"
                    },
                    {
                        "username": "Aravind_Swaminathan",
                        "content": "working on this for past 17hrs\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can someone help with this error that I am getting after submitting solution for this problem?\\n\\n\"\"==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\"\"\\n\\nThe program is running fine for all the test cases, but showing the above runtime error after submitting the solution."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "This is error is not because of your code instead its the JAVA and C++ compiler issue of leetcode since last night. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "hello fellow c++\\'er - i get addressSanitizer usually when i try to access an unallocated index of a vector or array..  you can \"debug\" the leetcode runtime with cerr messages to pinpoint where ur issue is happening"
                    },
                    {
                        "username": "halfengineer",
                        "content": "First thought that oh catalan number will work still figuring out how\\uD83D\\uDE13\\uD83D\\uDE13"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Oh my god, I literally just saw red squiggly line in the COMMENTS SECTION. I think I should use Rust less :/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "What a great question!"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "If you not understand problem clearly then here is explanation\nLet's suppose we have given array [3,4,5,1,2] and empty tree\nthen we have to place element in tree by order they comes  i.e. \nwe get first element 3 make it root then we have element 4 make it to right child of 3,\nnow element 5 come make it to right child of 4 then element 1 come make it to left child of 3 which is its correct position according to BST rule (i.e. smaller element left side and larger element right side) now 2 come make it to right child of 1.\nNow we have to find how many arrangements of give permutation give same BST.\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\nHint: writes all arrangement of array try to find pattern in this.\n(Sorry for poor English)."
                    },
                    {
                        "username": "Karilli",
                        "content": "I am starting a petition that leatcode has to accept O(n!) solutions on this problem. Let me keep my streak pliiiz."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "How array is mapped into tree. Please anyone clear my doubt in example."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n    \\'\\'\\'def insertNode(self,node,data):\\n        if node is None:\\n            return self.createNode(data)\\n        if data < node.data :\\n            node.left = self.insertNode(node.left,data)\\n        else :\\n            node.right = self.insertNode(node.right,data)\\n        return node\\'\\'\\'\\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "You have to simply insert the values of array one by one by just following the rules of BST . \\nSmaller values will be on left and larger value on right ."
                    }
                ]
            },
            {
                "id": 1931834,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "when building pascal\\'s triangle is just a preparation step, you know you\\'re gonna have a bad time."
                    },
                    {
                        "username": "Reethik_27",
                        "content": "Wake up to the  reality nothing ever goes as planned in this accursed world - Madara Uchiha"
                    },
                    {
                        "username": "Aravind_Swaminathan",
                        "content": "working on this for past 17hrs\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can someone help with this error that I am getting after submitting solution for this problem?\\n\\n\"\"==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\"\"\\n\\nThe program is running fine for all the test cases, but showing the above runtime error after submitting the solution."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "This is error is not because of your code instead its the JAVA and C++ compiler issue of leetcode since last night. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "hello fellow c++\\'er - i get addressSanitizer usually when i try to access an unallocated index of a vector or array..  you can \"debug\" the leetcode runtime with cerr messages to pinpoint where ur issue is happening"
                    },
                    {
                        "username": "halfengineer",
                        "content": "First thought that oh catalan number will work still figuring out how\\uD83D\\uDE13\\uD83D\\uDE13"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Oh my god, I literally just saw red squiggly line in the COMMENTS SECTION. I think I should use Rust less :/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "What a great question!"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "If you not understand problem clearly then here is explanation\nLet's suppose we have given array [3,4,5,1,2] and empty tree\nthen we have to place element in tree by order they comes  i.e. \nwe get first element 3 make it root then we have element 4 make it to right child of 3,\nnow element 5 come make it to right child of 4 then element 1 come make it to left child of 3 which is its correct position according to BST rule (i.e. smaller element left side and larger element right side) now 2 come make it to right child of 1.\nNow we have to find how many arrangements of give permutation give same BST.\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\nHint: writes all arrangement of array try to find pattern in this.\n(Sorry for poor English)."
                    },
                    {
                        "username": "Karilli",
                        "content": "I am starting a petition that leatcode has to accept O(n!) solutions on this problem. Let me keep my streak pliiiz."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "How array is mapped into tree. Please anyone clear my doubt in example."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n    \\'\\'\\'def insertNode(self,node,data):\\n        if node is None:\\n            return self.createNode(data)\\n        if data < node.data :\\n            node.left = self.insertNode(node.left,data)\\n        else :\\n            node.right = self.insertNode(node.right,data)\\n        return node\\'\\'\\'\\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "You have to simply insert the values of array one by one by just following the rules of BST . \\nSmaller values will be on left and larger value on right ."
                    }
                ]
            },
            {
                "id": 1931803,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "when building pascal\\'s triangle is just a preparation step, you know you\\'re gonna have a bad time."
                    },
                    {
                        "username": "Reethik_27",
                        "content": "Wake up to the  reality nothing ever goes as planned in this accursed world - Madara Uchiha"
                    },
                    {
                        "username": "Aravind_Swaminathan",
                        "content": "working on this for past 17hrs\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can someone help with this error that I am getting after submitting solution for this problem?\\n\\n\"\"==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\"\"\\n\\nThe program is running fine for all the test cases, but showing the above runtime error after submitting the solution."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "This is error is not because of your code instead its the JAVA and C++ compiler issue of leetcode since last night. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "hello fellow c++\\'er - i get addressSanitizer usually when i try to access an unallocated index of a vector or array..  you can \"debug\" the leetcode runtime with cerr messages to pinpoint where ur issue is happening"
                    },
                    {
                        "username": "halfengineer",
                        "content": "First thought that oh catalan number will work still figuring out how\\uD83D\\uDE13\\uD83D\\uDE13"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Oh my god, I literally just saw red squiggly line in the COMMENTS SECTION. I think I should use Rust less :/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "What a great question!"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "If you not understand problem clearly then here is explanation\nLet's suppose we have given array [3,4,5,1,2] and empty tree\nthen we have to place element in tree by order they comes  i.e. \nwe get first element 3 make it root then we have element 4 make it to right child of 3,\nnow element 5 come make it to right child of 4 then element 1 come make it to left child of 3 which is its correct position according to BST rule (i.e. smaller element left side and larger element right side) now 2 come make it to right child of 1.\nNow we have to find how many arrangements of give permutation give same BST.\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\nHint: writes all arrangement of array try to find pattern in this.\n(Sorry for poor English)."
                    },
                    {
                        "username": "Karilli",
                        "content": "I am starting a petition that leatcode has to accept O(n!) solutions on this problem. Let me keep my streak pliiiz."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "How array is mapped into tree. Please anyone clear my doubt in example."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n    \\'\\'\\'def insertNode(self,node,data):\\n        if node is None:\\n            return self.createNode(data)\\n        if data < node.data :\\n            node.left = self.insertNode(node.left,data)\\n        else :\\n            node.right = self.insertNode(node.right,data)\\n        return node\\'\\'\\'\\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "You have to simply insert the values of array one by one by just following the rules of BST . \\nSmaller values will be on left and larger value on right ."
                    }
                ]
            },
            {
                "id": 1931763,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "when building pascal\\'s triangle is just a preparation step, you know you\\'re gonna have a bad time."
                    },
                    {
                        "username": "Reethik_27",
                        "content": "Wake up to the  reality nothing ever goes as planned in this accursed world - Madara Uchiha"
                    },
                    {
                        "username": "Aravind_Swaminathan",
                        "content": "working on this for past 17hrs\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can someone help with this error that I am getting after submitting solution for this problem?\\n\\n\"\"==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\"\"\\n\\nThe program is running fine for all the test cases, but showing the above runtime error after submitting the solution."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "This is error is not because of your code instead its the JAVA and C++ compiler issue of leetcode since last night. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "hello fellow c++\\'er - i get addressSanitizer usually when i try to access an unallocated index of a vector or array..  you can \"debug\" the leetcode runtime with cerr messages to pinpoint where ur issue is happening"
                    },
                    {
                        "username": "halfengineer",
                        "content": "First thought that oh catalan number will work still figuring out how\\uD83D\\uDE13\\uD83D\\uDE13"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Oh my god, I literally just saw red squiggly line in the COMMENTS SECTION. I think I should use Rust less :/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "What a great question!"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "If you not understand problem clearly then here is explanation\nLet's suppose we have given array [3,4,5,1,2] and empty tree\nthen we have to place element in tree by order they comes  i.e. \nwe get first element 3 make it root then we have element 4 make it to right child of 3,\nnow element 5 come make it to right child of 4 then element 1 come make it to left child of 3 which is its correct position according to BST rule (i.e. smaller element left side and larger element right side) now 2 come make it to right child of 1.\nNow we have to find how many arrangements of give permutation give same BST.\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\nHint: writes all arrangement of array try to find pattern in this.\n(Sorry for poor English)."
                    },
                    {
                        "username": "Karilli",
                        "content": "I am starting a petition that leatcode has to accept O(n!) solutions on this problem. Let me keep my streak pliiiz."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "How array is mapped into tree. Please anyone clear my doubt in example."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n    \\'\\'\\'def insertNode(self,node,data):\\n        if node is None:\\n            return self.createNode(data)\\n        if data < node.data :\\n            node.left = self.insertNode(node.left,data)\\n        else :\\n            node.right = self.insertNode(node.right,data)\\n        return node\\'\\'\\'\\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "You have to simply insert the values of array one by one by just following the rules of BST . \\nSmaller values will be on left and larger value on right ."
                    }
                ]
            },
            {
                "id": 1931639,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "when building pascal\\'s triangle is just a preparation step, you know you\\'re gonna have a bad time."
                    },
                    {
                        "username": "Reethik_27",
                        "content": "Wake up to the  reality nothing ever goes as planned in this accursed world - Madara Uchiha"
                    },
                    {
                        "username": "Aravind_Swaminathan",
                        "content": "working on this for past 17hrs\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "coolspec",
                        "content": "Can someone help with this error that I am getting after submitting solution for this problem?\\n\\n\"\"==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\"\"\\n\\nThe program is running fine for all the test cases, but showing the above runtime error after submitting the solution."
                    },
                    {
                        "username": "prabhash_iitp",
                        "content": "This is error is not because of your code instead its the JAVA and C++ compiler issue of leetcode since last night. "
                    },
                    {
                        "username": "user5400vw",
                        "content": "hello fellow c++\\'er - i get addressSanitizer usually when i try to access an unallocated index of a vector or array..  you can \"debug\" the leetcode runtime with cerr messages to pinpoint where ur issue is happening"
                    },
                    {
                        "username": "halfengineer",
                        "content": "First thought that oh catalan number will work still figuring out how\\uD83D\\uDE13\\uD83D\\uDE13"
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Oh my god, I literally just saw red squiggly line in the COMMENTS SECTION. I think I should use Rust less :/"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "What a great question!"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "If you not understand problem clearly then here is explanation\nLet's suppose we have given array [3,4,5,1,2] and empty tree\nthen we have to place element in tree by order they comes  i.e. \nwe get first element 3 make it root then we have element 4 make it to right child of 3,\nnow element 5 come make it to right child of 4 then element 1 come make it to left child of 3 which is its correct position according to BST rule (i.e. smaller element left side and larger element right side) now 2 come make it to right child of 1.\nNow we have to find how many arrangements of give permutation give same BST.\ni.e. 3 as root, 4 is right child of 3,5 is right child of 4, 1 is left child of 3 and 2 is right child of 1.\nHint: writes all arrangement of array try to find pattern in this.\n(Sorry for poor English)."
                    },
                    {
                        "username": "Karilli",
                        "content": "I am starting a petition that leatcode has to accept O(n!) solutions on this problem. Let me keep my streak pliiiz."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "How array is mapped into tree. Please anyone clear my doubt in example."
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "take your root element. all the elements smaller to root will go on left side , all the bigger ones will go on the right.\\nnow for each node and remaining elements you will have to repeat the process until no elements are left.\\n\\nbelow is the example of insert function:\\n\\n    \\'\\'\\'def insertNode(self,node,data):\\n        if node is None:\\n            return self.createNode(data)\\n        if data < node.data :\\n            node.left = self.insertNode(node.left,data)\\n        else :\\n            node.right = self.insertNode(node.right,data)\\n        return node\\'\\'\\'\\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "You have to simply insert the values of array one by one by just following the rules of BST . \\nSmaller values will be on left and larger value on right ."
                    }
                ]
            },
            {
                "id": 1931599,
                "content": [
                    {
                        "username": "Atulsid151",
                        "content": "Oh man !!! I am a bit busy today, and this hard problem"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[3,1,2,5,4,6]\\nanswer for this is 19 .\\ncan anyone tell me the 19 arrangements , my answer is 9 only ."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Now i got it . \\nThanks brother \\uD83D\\uDC4D"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Prashu Deshmukh](/prashudeshmukh3006) yeah you are right\n\nthe right 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n-- (swap the 6 and 4)\n- [3,1,2,5,6,4]\n- [3,5,1,2,6,4]\n- [3,5,6,1,2,4]\n- [3,5,6,4,1,2]\n- [3,1,5,6,4,2]\n- [3,5,1,6,4,2]\n- [3,5,6,1,4,2]\n- [3,1,5,6,2,4]\n- [3,5,1,6,2,4]\n- [3,1,5,2,6,4]\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) I am not able to depict it properly .\\nBut my question is that in last 10 arrangements if we will insert nodes one by one then 3,2,1 will form a straight line in left subtree , but originally it was zig zag"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Consider [3,2,1,5,4,6]\\nHere we will insert nodes in the following oredr\\n3-->2-->1-->5-->4-->6\\nthen left sub tree will become\\n                    3\\n                  /\\n                2\\n               /\\n             1\\n\\nBut originally it was\\n                              3\\n                             /\\n                           1\\n                             \\\\\\n                               2"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@prashudeshmukh3006](/prashudeshmukh3006) it's similar because if you construct the BST from scratch, the BST will look the same as the original BST. \n\nit's the same as [2,1,3] and [2,3,1] from first example\n\n\"We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST\""
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Positions of 2 and 1 are disturbed"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw)  How come last 10 arrangements are identical to the original BST ?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "here's the 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n--\n- [3,2,1,5,4,6]\n- [3,5,2,1,4,6]\n- [3,5,4,2,1,6]\n- [3,5,4,6,2,1]\n- [3,2,5,4,6,1]\n- [3,5,2,4,6,1]\n- [3,5,4,2,6,1]\n- [3,2,5,4,1,6]\n- [3,5,2,4,1,6]\n- [3,2,5,1,4,6]"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Is it only me who reads the title like this: \\nNumber of Ways to Reorder Array to Get Same Bullshit\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "This is the type of question. When you see this in an interview, you know you\\'re not going to get the job in 10 seconds."
                    },
                    {
                        "username": "sigmale",
                        "content": "If you have a basic combinatorics knowledge then please do solve it by your own, I spent 2 hours and got my solution finally accepted (streak rizz), its worth trying if you have studied combinatorics.\\nIn case you\\'re confused about your combinatorics ability, here\\'s a question, if you can solve it then you can solve the above problem as well.\\n\\nProblem: Given n numbers (distinct) in a sequence, find the number of permutations of these n numbers such that relative ordering of some fixed m numbers (m<=n) should not change.\\neg. L= [ 1,2,3,4], here n=4 and if m=3, lets say 1,2,3 there relative order should remain same, then number of permutations become 4.(You can check by yourself)"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "public int numOfWays(int[] nums) {\\n    comb = generate(nums.length + 1);\\n    return ways(Arrays.stream(nums).boxed().collect(Collectors.toList())) - 1;\\n  }\\n\\n  private static final int kMod = 1_000_000_007;\\n  // comb[n][k] := C(n, k)\\n  private List<List<Integer>> comb;\\n\\n  private int ways(List<Integer> nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    List<Integer> left = new ArrayList<>();\\n    List<Integer> right = new ArrayList<>();\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums.get(i) < nums.get(0))\\n        left.add(nums.get(i));\\n      else\\n        right.add(nums.get(i));\\n\\n    long ans = comb.get(nums.size() - 1).get(left.size());\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return (int) ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> comb = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      comb.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb.get(i).size() - 1; ++j)\\n        comb.get(i).set(j, (comb.get(i - 1).get(j - 1) + comb.get(i - 1).get(j)) % kMod);\\n\\n    return comb;\\n  }"
                    },
                    {
                        "username": "user7478F",
                        "content": "The head will remain same\\nFor the rest of elements in nums i.e nums[1:], calculate ways in which the sequence of right childs and left childs is unchanged,\\n\\nEx. [3,4,5,1,2]\\nIn this example 4 should always come before 5 and 1 should always come before 2, we can change elements such that the places of element is changed but not the order of their traversing.\\n"
                    },
                    {
                        "username": "rcdarwinn",
                        "content": "me : decides to commit .\\nleetcode : just sit watch and learn.\\n -- going to see pascal triangle and binomial cofficient as suggested by [@mufia001](/mufia001) ps : learning "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**I smell the weekend is coming**"
                    },
                    {
                        "username": "ajv97",
                        "content": "I just time travelled to stop Leetcode from posting this question in the Daily Challenge but spiderman 2099 said this is a canon event for all of us."
                    }
                ]
            },
            {
                "id": 1931566,
                "content": [
                    {
                        "username": "Atulsid151",
                        "content": "Oh man !!! I am a bit busy today, and this hard problem"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[3,1,2,5,4,6]\\nanswer for this is 19 .\\ncan anyone tell me the 19 arrangements , my answer is 9 only ."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Now i got it . \\nThanks brother \\uD83D\\uDC4D"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Prashu Deshmukh](/prashudeshmukh3006) yeah you are right\n\nthe right 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n-- (swap the 6 and 4)\n- [3,1,2,5,6,4]\n- [3,5,1,2,6,4]\n- [3,5,6,1,2,4]\n- [3,5,6,4,1,2]\n- [3,1,5,6,4,2]\n- [3,5,1,6,4,2]\n- [3,5,6,1,4,2]\n- [3,1,5,6,2,4]\n- [3,5,1,6,2,4]\n- [3,1,5,2,6,4]\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) I am not able to depict it properly .\\nBut my question is that in last 10 arrangements if we will insert nodes one by one then 3,2,1 will form a straight line in left subtree , but originally it was zig zag"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Consider [3,2,1,5,4,6]\\nHere we will insert nodes in the following oredr\\n3-->2-->1-->5-->4-->6\\nthen left sub tree will become\\n                    3\\n                  /\\n                2\\n               /\\n             1\\n\\nBut originally it was\\n                              3\\n                             /\\n                           1\\n                             \\\\\\n                               2"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@prashudeshmukh3006](/prashudeshmukh3006) it's similar because if you construct the BST from scratch, the BST will look the same as the original BST. \n\nit's the same as [2,1,3] and [2,3,1] from first example\n\n\"We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST\""
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Positions of 2 and 1 are disturbed"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw)  How come last 10 arrangements are identical to the original BST ?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "here's the 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n--\n- [3,2,1,5,4,6]\n- [3,5,2,1,4,6]\n- [3,5,4,2,1,6]\n- [3,5,4,6,2,1]\n- [3,2,5,4,6,1]\n- [3,5,2,4,6,1]\n- [3,5,4,2,6,1]\n- [3,2,5,4,1,6]\n- [3,5,2,4,1,6]\n- [3,2,5,1,4,6]"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Is it only me who reads the title like this: \\nNumber of Ways to Reorder Array to Get Same Bullshit\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "This is the type of question. When you see this in an interview, you know you\\'re not going to get the job in 10 seconds."
                    },
                    {
                        "username": "sigmale",
                        "content": "If you have a basic combinatorics knowledge then please do solve it by your own, I spent 2 hours and got my solution finally accepted (streak rizz), its worth trying if you have studied combinatorics.\\nIn case you\\'re confused about your combinatorics ability, here\\'s a question, if you can solve it then you can solve the above problem as well.\\n\\nProblem: Given n numbers (distinct) in a sequence, find the number of permutations of these n numbers such that relative ordering of some fixed m numbers (m<=n) should not change.\\neg. L= [ 1,2,3,4], here n=4 and if m=3, lets say 1,2,3 there relative order should remain same, then number of permutations become 4.(You can check by yourself)"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "public int numOfWays(int[] nums) {\\n    comb = generate(nums.length + 1);\\n    return ways(Arrays.stream(nums).boxed().collect(Collectors.toList())) - 1;\\n  }\\n\\n  private static final int kMod = 1_000_000_007;\\n  // comb[n][k] := C(n, k)\\n  private List<List<Integer>> comb;\\n\\n  private int ways(List<Integer> nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    List<Integer> left = new ArrayList<>();\\n    List<Integer> right = new ArrayList<>();\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums.get(i) < nums.get(0))\\n        left.add(nums.get(i));\\n      else\\n        right.add(nums.get(i));\\n\\n    long ans = comb.get(nums.size() - 1).get(left.size());\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return (int) ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> comb = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      comb.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb.get(i).size() - 1; ++j)\\n        comb.get(i).set(j, (comb.get(i - 1).get(j - 1) + comb.get(i - 1).get(j)) % kMod);\\n\\n    return comb;\\n  }"
                    },
                    {
                        "username": "user7478F",
                        "content": "The head will remain same\\nFor the rest of elements in nums i.e nums[1:], calculate ways in which the sequence of right childs and left childs is unchanged,\\n\\nEx. [3,4,5,1,2]\\nIn this example 4 should always come before 5 and 1 should always come before 2, we can change elements such that the places of element is changed but not the order of their traversing.\\n"
                    },
                    {
                        "username": "rcdarwinn",
                        "content": "me : decides to commit .\\nleetcode : just sit watch and learn.\\n -- going to see pascal triangle and binomial cofficient as suggested by [@mufia001](/mufia001) ps : learning "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**I smell the weekend is coming**"
                    },
                    {
                        "username": "ajv97",
                        "content": "I just time travelled to stop Leetcode from posting this question in the Daily Challenge but spiderman 2099 said this is a canon event for all of us."
                    }
                ]
            },
            {
                "id": 1931559,
                "content": [
                    {
                        "username": "Atulsid151",
                        "content": "Oh man !!! I am a bit busy today, and this hard problem"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[3,1,2,5,4,6]\\nanswer for this is 19 .\\ncan anyone tell me the 19 arrangements , my answer is 9 only ."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Now i got it . \\nThanks brother \\uD83D\\uDC4D"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Prashu Deshmukh](/prashudeshmukh3006) yeah you are right\n\nthe right 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n-- (swap the 6 and 4)\n- [3,1,2,5,6,4]\n- [3,5,1,2,6,4]\n- [3,5,6,1,2,4]\n- [3,5,6,4,1,2]\n- [3,1,5,6,4,2]\n- [3,5,1,6,4,2]\n- [3,5,6,1,4,2]\n- [3,1,5,6,2,4]\n- [3,5,1,6,2,4]\n- [3,1,5,2,6,4]\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) I am not able to depict it properly .\\nBut my question is that in last 10 arrangements if we will insert nodes one by one then 3,2,1 will form a straight line in left subtree , but originally it was zig zag"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Consider [3,2,1,5,4,6]\\nHere we will insert nodes in the following oredr\\n3-->2-->1-->5-->4-->6\\nthen left sub tree will become\\n                    3\\n                  /\\n                2\\n               /\\n             1\\n\\nBut originally it was\\n                              3\\n                             /\\n                           1\\n                             \\\\\\n                               2"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@prashudeshmukh3006](/prashudeshmukh3006) it's similar because if you construct the BST from scratch, the BST will look the same as the original BST. \n\nit's the same as [2,1,3] and [2,3,1] from first example\n\n\"We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST\""
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Positions of 2 and 1 are disturbed"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw)  How come last 10 arrangements are identical to the original BST ?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "here's the 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n--\n- [3,2,1,5,4,6]\n- [3,5,2,1,4,6]\n- [3,5,4,2,1,6]\n- [3,5,4,6,2,1]\n- [3,2,5,4,6,1]\n- [3,5,2,4,6,1]\n- [3,5,4,2,6,1]\n- [3,2,5,4,1,6]\n- [3,5,2,4,1,6]\n- [3,2,5,1,4,6]"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Is it only me who reads the title like this: \\nNumber of Ways to Reorder Array to Get Same Bullshit\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "This is the type of question. When you see this in an interview, you know you\\'re not going to get the job in 10 seconds."
                    },
                    {
                        "username": "sigmale",
                        "content": "If you have a basic combinatorics knowledge then please do solve it by your own, I spent 2 hours and got my solution finally accepted (streak rizz), its worth trying if you have studied combinatorics.\\nIn case you\\'re confused about your combinatorics ability, here\\'s a question, if you can solve it then you can solve the above problem as well.\\n\\nProblem: Given n numbers (distinct) in a sequence, find the number of permutations of these n numbers such that relative ordering of some fixed m numbers (m<=n) should not change.\\neg. L= [ 1,2,3,4], here n=4 and if m=3, lets say 1,2,3 there relative order should remain same, then number of permutations become 4.(You can check by yourself)"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "public int numOfWays(int[] nums) {\\n    comb = generate(nums.length + 1);\\n    return ways(Arrays.stream(nums).boxed().collect(Collectors.toList())) - 1;\\n  }\\n\\n  private static final int kMod = 1_000_000_007;\\n  // comb[n][k] := C(n, k)\\n  private List<List<Integer>> comb;\\n\\n  private int ways(List<Integer> nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    List<Integer> left = new ArrayList<>();\\n    List<Integer> right = new ArrayList<>();\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums.get(i) < nums.get(0))\\n        left.add(nums.get(i));\\n      else\\n        right.add(nums.get(i));\\n\\n    long ans = comb.get(nums.size() - 1).get(left.size());\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return (int) ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> comb = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      comb.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb.get(i).size() - 1; ++j)\\n        comb.get(i).set(j, (comb.get(i - 1).get(j - 1) + comb.get(i - 1).get(j)) % kMod);\\n\\n    return comb;\\n  }"
                    },
                    {
                        "username": "user7478F",
                        "content": "The head will remain same\\nFor the rest of elements in nums i.e nums[1:], calculate ways in which the sequence of right childs and left childs is unchanged,\\n\\nEx. [3,4,5,1,2]\\nIn this example 4 should always come before 5 and 1 should always come before 2, we can change elements such that the places of element is changed but not the order of their traversing.\\n"
                    },
                    {
                        "username": "rcdarwinn",
                        "content": "me : decides to commit .\\nleetcode : just sit watch and learn.\\n -- going to see pascal triangle and binomial cofficient as suggested by [@mufia001](/mufia001) ps : learning "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**I smell the weekend is coming**"
                    },
                    {
                        "username": "ajv97",
                        "content": "I just time travelled to stop Leetcode from posting this question in the Daily Challenge but spiderman 2099 said this is a canon event for all of us."
                    }
                ]
            },
            {
                "id": 1931542,
                "content": [
                    {
                        "username": "Atulsid151",
                        "content": "Oh man !!! I am a bit busy today, and this hard problem"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[3,1,2,5,4,6]\\nanswer for this is 19 .\\ncan anyone tell me the 19 arrangements , my answer is 9 only ."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Now i got it . \\nThanks brother \\uD83D\\uDC4D"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Prashu Deshmukh](/prashudeshmukh3006) yeah you are right\n\nthe right 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n-- (swap the 6 and 4)\n- [3,1,2,5,6,4]\n- [3,5,1,2,6,4]\n- [3,5,6,1,2,4]\n- [3,5,6,4,1,2]\n- [3,1,5,6,4,2]\n- [3,5,1,6,4,2]\n- [3,5,6,1,4,2]\n- [3,1,5,6,2,4]\n- [3,5,1,6,2,4]\n- [3,1,5,2,6,4]\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) I am not able to depict it properly .\\nBut my question is that in last 10 arrangements if we will insert nodes one by one then 3,2,1 will form a straight line in left subtree , but originally it was zig zag"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Consider [3,2,1,5,4,6]\\nHere we will insert nodes in the following oredr\\n3-->2-->1-->5-->4-->6\\nthen left sub tree will become\\n                    3\\n                  /\\n                2\\n               /\\n             1\\n\\nBut originally it was\\n                              3\\n                             /\\n                           1\\n                             \\\\\\n                               2"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@prashudeshmukh3006](/prashudeshmukh3006) it's similar because if you construct the BST from scratch, the BST will look the same as the original BST. \n\nit's the same as [2,1,3] and [2,3,1] from first example\n\n\"We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST\""
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Positions of 2 and 1 are disturbed"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw)  How come last 10 arrangements are identical to the original BST ?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "here's the 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n--\n- [3,2,1,5,4,6]\n- [3,5,2,1,4,6]\n- [3,5,4,2,1,6]\n- [3,5,4,6,2,1]\n- [3,2,5,4,6,1]\n- [3,5,2,4,6,1]\n- [3,5,4,2,6,1]\n- [3,2,5,4,1,6]\n- [3,5,2,4,1,6]\n- [3,2,5,1,4,6]"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Is it only me who reads the title like this: \\nNumber of Ways to Reorder Array to Get Same Bullshit\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "This is the type of question. When you see this in an interview, you know you\\'re not going to get the job in 10 seconds."
                    },
                    {
                        "username": "sigmale",
                        "content": "If you have a basic combinatorics knowledge then please do solve it by your own, I spent 2 hours and got my solution finally accepted (streak rizz), its worth trying if you have studied combinatorics.\\nIn case you\\'re confused about your combinatorics ability, here\\'s a question, if you can solve it then you can solve the above problem as well.\\n\\nProblem: Given n numbers (distinct) in a sequence, find the number of permutations of these n numbers such that relative ordering of some fixed m numbers (m<=n) should not change.\\neg. L= [ 1,2,3,4], here n=4 and if m=3, lets say 1,2,3 there relative order should remain same, then number of permutations become 4.(You can check by yourself)"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "public int numOfWays(int[] nums) {\\n    comb = generate(nums.length + 1);\\n    return ways(Arrays.stream(nums).boxed().collect(Collectors.toList())) - 1;\\n  }\\n\\n  private static final int kMod = 1_000_000_007;\\n  // comb[n][k] := C(n, k)\\n  private List<List<Integer>> comb;\\n\\n  private int ways(List<Integer> nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    List<Integer> left = new ArrayList<>();\\n    List<Integer> right = new ArrayList<>();\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums.get(i) < nums.get(0))\\n        left.add(nums.get(i));\\n      else\\n        right.add(nums.get(i));\\n\\n    long ans = comb.get(nums.size() - 1).get(left.size());\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return (int) ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> comb = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      comb.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb.get(i).size() - 1; ++j)\\n        comb.get(i).set(j, (comb.get(i - 1).get(j - 1) + comb.get(i - 1).get(j)) % kMod);\\n\\n    return comb;\\n  }"
                    },
                    {
                        "username": "user7478F",
                        "content": "The head will remain same\\nFor the rest of elements in nums i.e nums[1:], calculate ways in which the sequence of right childs and left childs is unchanged,\\n\\nEx. [3,4,5,1,2]\\nIn this example 4 should always come before 5 and 1 should always come before 2, we can change elements such that the places of element is changed but not the order of their traversing.\\n"
                    },
                    {
                        "username": "rcdarwinn",
                        "content": "me : decides to commit .\\nleetcode : just sit watch and learn.\\n -- going to see pascal triangle and binomial cofficient as suggested by [@mufia001](/mufia001) ps : learning "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**I smell the weekend is coming**"
                    },
                    {
                        "username": "ajv97",
                        "content": "I just time travelled to stop Leetcode from posting this question in the Daily Challenge but spiderman 2099 said this is a canon event for all of us."
                    }
                ]
            },
            {
                "id": 1931532,
                "content": [
                    {
                        "username": "Atulsid151",
                        "content": "Oh man !!! I am a bit busy today, and this hard problem"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[3,1,2,5,4,6]\\nanswer for this is 19 .\\ncan anyone tell me the 19 arrangements , my answer is 9 only ."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Now i got it . \\nThanks brother \\uD83D\\uDC4D"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Prashu Deshmukh](/prashudeshmukh3006) yeah you are right\n\nthe right 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n-- (swap the 6 and 4)\n- [3,1,2,5,6,4]\n- [3,5,1,2,6,4]\n- [3,5,6,1,2,4]\n- [3,5,6,4,1,2]\n- [3,1,5,6,4,2]\n- [3,5,1,6,4,2]\n- [3,5,6,1,4,2]\n- [3,1,5,6,2,4]\n- [3,5,1,6,2,4]\n- [3,1,5,2,6,4]\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) I am not able to depict it properly .\\nBut my question is that in last 10 arrangements if we will insert nodes one by one then 3,2,1 will form a straight line in left subtree , but originally it was zig zag"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Consider [3,2,1,5,4,6]\\nHere we will insert nodes in the following oredr\\n3-->2-->1-->5-->4-->6\\nthen left sub tree will become\\n                    3\\n                  /\\n                2\\n               /\\n             1\\n\\nBut originally it was\\n                              3\\n                             /\\n                           1\\n                             \\\\\\n                               2"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@prashudeshmukh3006](/prashudeshmukh3006) it's similar because if you construct the BST from scratch, the BST will look the same as the original BST. \n\nit's the same as [2,1,3] and [2,3,1] from first example\n\n\"We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST\""
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Positions of 2 and 1 are disturbed"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw)  How come last 10 arrangements are identical to the original BST ?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "here's the 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n--\n- [3,2,1,5,4,6]\n- [3,5,2,1,4,6]\n- [3,5,4,2,1,6]\n- [3,5,4,6,2,1]\n- [3,2,5,4,6,1]\n- [3,5,2,4,6,1]\n- [3,5,4,2,6,1]\n- [3,2,5,4,1,6]\n- [3,5,2,4,1,6]\n- [3,2,5,1,4,6]"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Is it only me who reads the title like this: \\nNumber of Ways to Reorder Array to Get Same Bullshit\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "This is the type of question. When you see this in an interview, you know you\\'re not going to get the job in 10 seconds."
                    },
                    {
                        "username": "sigmale",
                        "content": "If you have a basic combinatorics knowledge then please do solve it by your own, I spent 2 hours and got my solution finally accepted (streak rizz), its worth trying if you have studied combinatorics.\\nIn case you\\'re confused about your combinatorics ability, here\\'s a question, if you can solve it then you can solve the above problem as well.\\n\\nProblem: Given n numbers (distinct) in a sequence, find the number of permutations of these n numbers such that relative ordering of some fixed m numbers (m<=n) should not change.\\neg. L= [ 1,2,3,4], here n=4 and if m=3, lets say 1,2,3 there relative order should remain same, then number of permutations become 4.(You can check by yourself)"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "public int numOfWays(int[] nums) {\\n    comb = generate(nums.length + 1);\\n    return ways(Arrays.stream(nums).boxed().collect(Collectors.toList())) - 1;\\n  }\\n\\n  private static final int kMod = 1_000_000_007;\\n  // comb[n][k] := C(n, k)\\n  private List<List<Integer>> comb;\\n\\n  private int ways(List<Integer> nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    List<Integer> left = new ArrayList<>();\\n    List<Integer> right = new ArrayList<>();\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums.get(i) < nums.get(0))\\n        left.add(nums.get(i));\\n      else\\n        right.add(nums.get(i));\\n\\n    long ans = comb.get(nums.size() - 1).get(left.size());\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return (int) ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> comb = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      comb.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb.get(i).size() - 1; ++j)\\n        comb.get(i).set(j, (comb.get(i - 1).get(j - 1) + comb.get(i - 1).get(j)) % kMod);\\n\\n    return comb;\\n  }"
                    },
                    {
                        "username": "user7478F",
                        "content": "The head will remain same\\nFor the rest of elements in nums i.e nums[1:], calculate ways in which the sequence of right childs and left childs is unchanged,\\n\\nEx. [3,4,5,1,2]\\nIn this example 4 should always come before 5 and 1 should always come before 2, we can change elements such that the places of element is changed but not the order of their traversing.\\n"
                    },
                    {
                        "username": "rcdarwinn",
                        "content": "me : decides to commit .\\nleetcode : just sit watch and learn.\\n -- going to see pascal triangle and binomial cofficient as suggested by [@mufia001](/mufia001) ps : learning "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**I smell the weekend is coming**"
                    },
                    {
                        "username": "ajv97",
                        "content": "I just time travelled to stop Leetcode from posting this question in the Daily Challenge but spiderman 2099 said this is a canon event for all of us."
                    }
                ]
            },
            {
                "id": 1931514,
                "content": [
                    {
                        "username": "Atulsid151",
                        "content": "Oh man !!! I am a bit busy today, and this hard problem"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[3,1,2,5,4,6]\\nanswer for this is 19 .\\ncan anyone tell me the 19 arrangements , my answer is 9 only ."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Now i got it . \\nThanks brother \\uD83D\\uDC4D"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Prashu Deshmukh](/prashudeshmukh3006) yeah you are right\n\nthe right 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n-- (swap the 6 and 4)\n- [3,1,2,5,6,4]\n- [3,5,1,2,6,4]\n- [3,5,6,1,2,4]\n- [3,5,6,4,1,2]\n- [3,1,5,6,4,2]\n- [3,5,1,6,4,2]\n- [3,5,6,1,4,2]\n- [3,1,5,6,2,4]\n- [3,5,1,6,2,4]\n- [3,1,5,2,6,4]\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) I am not able to depict it properly .\\nBut my question is that in last 10 arrangements if we will insert nodes one by one then 3,2,1 will form a straight line in left subtree , but originally it was zig zag"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Consider [3,2,1,5,4,6]\\nHere we will insert nodes in the following oredr\\n3-->2-->1-->5-->4-->6\\nthen left sub tree will become\\n                    3\\n                  /\\n                2\\n               /\\n             1\\n\\nBut originally it was\\n                              3\\n                             /\\n                           1\\n                             \\\\\\n                               2"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@prashudeshmukh3006](/prashudeshmukh3006) it's similar because if you construct the BST from scratch, the BST will look the same as the original BST. \n\nit's the same as [2,1,3] and [2,3,1] from first example\n\n\"We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST\""
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Positions of 2 and 1 are disturbed"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw)  How come last 10 arrangements are identical to the original BST ?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "here's the 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n--\n- [3,2,1,5,4,6]\n- [3,5,2,1,4,6]\n- [3,5,4,2,1,6]\n- [3,5,4,6,2,1]\n- [3,2,5,4,6,1]\n- [3,5,2,4,6,1]\n- [3,5,4,2,6,1]\n- [3,2,5,4,1,6]\n- [3,5,2,4,1,6]\n- [3,2,5,1,4,6]"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Is it only me who reads the title like this: \\nNumber of Ways to Reorder Array to Get Same Bullshit\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "This is the type of question. When you see this in an interview, you know you\\'re not going to get the job in 10 seconds."
                    },
                    {
                        "username": "sigmale",
                        "content": "If you have a basic combinatorics knowledge then please do solve it by your own, I spent 2 hours and got my solution finally accepted (streak rizz), its worth trying if you have studied combinatorics.\\nIn case you\\'re confused about your combinatorics ability, here\\'s a question, if you can solve it then you can solve the above problem as well.\\n\\nProblem: Given n numbers (distinct) in a sequence, find the number of permutations of these n numbers such that relative ordering of some fixed m numbers (m<=n) should not change.\\neg. L= [ 1,2,3,4], here n=4 and if m=3, lets say 1,2,3 there relative order should remain same, then number of permutations become 4.(You can check by yourself)"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "public int numOfWays(int[] nums) {\\n    comb = generate(nums.length + 1);\\n    return ways(Arrays.stream(nums).boxed().collect(Collectors.toList())) - 1;\\n  }\\n\\n  private static final int kMod = 1_000_000_007;\\n  // comb[n][k] := C(n, k)\\n  private List<List<Integer>> comb;\\n\\n  private int ways(List<Integer> nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    List<Integer> left = new ArrayList<>();\\n    List<Integer> right = new ArrayList<>();\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums.get(i) < nums.get(0))\\n        left.add(nums.get(i));\\n      else\\n        right.add(nums.get(i));\\n\\n    long ans = comb.get(nums.size() - 1).get(left.size());\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return (int) ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> comb = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      comb.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb.get(i).size() - 1; ++j)\\n        comb.get(i).set(j, (comb.get(i - 1).get(j - 1) + comb.get(i - 1).get(j)) % kMod);\\n\\n    return comb;\\n  }"
                    },
                    {
                        "username": "user7478F",
                        "content": "The head will remain same\\nFor the rest of elements in nums i.e nums[1:], calculate ways in which the sequence of right childs and left childs is unchanged,\\n\\nEx. [3,4,5,1,2]\\nIn this example 4 should always come before 5 and 1 should always come before 2, we can change elements such that the places of element is changed but not the order of their traversing.\\n"
                    },
                    {
                        "username": "rcdarwinn",
                        "content": "me : decides to commit .\\nleetcode : just sit watch and learn.\\n -- going to see pascal triangle and binomial cofficient as suggested by [@mufia001](/mufia001) ps : learning "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**I smell the weekend is coming**"
                    },
                    {
                        "username": "ajv97",
                        "content": "I just time travelled to stop Leetcode from posting this question in the Daily Challenge but spiderman 2099 said this is a canon event for all of us."
                    }
                ]
            },
            {
                "id": 1931478,
                "content": [
                    {
                        "username": "Atulsid151",
                        "content": "Oh man !!! I am a bit busy today, and this hard problem"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[3,1,2,5,4,6]\\nanswer for this is 19 .\\ncan anyone tell me the 19 arrangements , my answer is 9 only ."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Now i got it . \\nThanks brother \\uD83D\\uDC4D"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Prashu Deshmukh](/prashudeshmukh3006) yeah you are right\n\nthe right 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n-- (swap the 6 and 4)\n- [3,1,2,5,6,4]\n- [3,5,1,2,6,4]\n- [3,5,6,1,2,4]\n- [3,5,6,4,1,2]\n- [3,1,5,6,4,2]\n- [3,5,1,6,4,2]\n- [3,5,6,1,4,2]\n- [3,1,5,6,2,4]\n- [3,5,1,6,2,4]\n- [3,1,5,2,6,4]\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) I am not able to depict it properly .\\nBut my question is that in last 10 arrangements if we will insert nodes one by one then 3,2,1 will form a straight line in left subtree , but originally it was zig zag"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Consider [3,2,1,5,4,6]\\nHere we will insert nodes in the following oredr\\n3-->2-->1-->5-->4-->6\\nthen left sub tree will become\\n                    3\\n                  /\\n                2\\n               /\\n             1\\n\\nBut originally it was\\n                              3\\n                             /\\n                           1\\n                             \\\\\\n                               2"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@prashudeshmukh3006](/prashudeshmukh3006) it's similar because if you construct the BST from scratch, the BST will look the same as the original BST. \n\nit's the same as [2,1,3] and [2,3,1] from first example\n\n\"We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST\""
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Positions of 2 and 1 are disturbed"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw)  How come last 10 arrangements are identical to the original BST ?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "here's the 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n--\n- [3,2,1,5,4,6]\n- [3,5,2,1,4,6]\n- [3,5,4,2,1,6]\n- [3,5,4,6,2,1]\n- [3,2,5,4,6,1]\n- [3,5,2,4,6,1]\n- [3,5,4,2,6,1]\n- [3,2,5,4,1,6]\n- [3,5,2,4,1,6]\n- [3,2,5,1,4,6]"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Is it only me who reads the title like this: \\nNumber of Ways to Reorder Array to Get Same Bullshit\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "This is the type of question. When you see this in an interview, you know you\\'re not going to get the job in 10 seconds."
                    },
                    {
                        "username": "sigmale",
                        "content": "If you have a basic combinatorics knowledge then please do solve it by your own, I spent 2 hours and got my solution finally accepted (streak rizz), its worth trying if you have studied combinatorics.\\nIn case you\\'re confused about your combinatorics ability, here\\'s a question, if you can solve it then you can solve the above problem as well.\\n\\nProblem: Given n numbers (distinct) in a sequence, find the number of permutations of these n numbers such that relative ordering of some fixed m numbers (m<=n) should not change.\\neg. L= [ 1,2,3,4], here n=4 and if m=3, lets say 1,2,3 there relative order should remain same, then number of permutations become 4.(You can check by yourself)"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "public int numOfWays(int[] nums) {\\n    comb = generate(nums.length + 1);\\n    return ways(Arrays.stream(nums).boxed().collect(Collectors.toList())) - 1;\\n  }\\n\\n  private static final int kMod = 1_000_000_007;\\n  // comb[n][k] := C(n, k)\\n  private List<List<Integer>> comb;\\n\\n  private int ways(List<Integer> nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    List<Integer> left = new ArrayList<>();\\n    List<Integer> right = new ArrayList<>();\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums.get(i) < nums.get(0))\\n        left.add(nums.get(i));\\n      else\\n        right.add(nums.get(i));\\n\\n    long ans = comb.get(nums.size() - 1).get(left.size());\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return (int) ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> comb = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      comb.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb.get(i).size() - 1; ++j)\\n        comb.get(i).set(j, (comb.get(i - 1).get(j - 1) + comb.get(i - 1).get(j)) % kMod);\\n\\n    return comb;\\n  }"
                    },
                    {
                        "username": "user7478F",
                        "content": "The head will remain same\\nFor the rest of elements in nums i.e nums[1:], calculate ways in which the sequence of right childs and left childs is unchanged,\\n\\nEx. [3,4,5,1,2]\\nIn this example 4 should always come before 5 and 1 should always come before 2, we can change elements such that the places of element is changed but not the order of their traversing.\\n"
                    },
                    {
                        "username": "rcdarwinn",
                        "content": "me : decides to commit .\\nleetcode : just sit watch and learn.\\n -- going to see pascal triangle and binomial cofficient as suggested by [@mufia001](/mufia001) ps : learning "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**I smell the weekend is coming**"
                    },
                    {
                        "username": "ajv97",
                        "content": "I just time travelled to stop Leetcode from posting this question in the Daily Challenge but spiderman 2099 said this is a canon event for all of us."
                    }
                ]
            },
            {
                "id": 1931476,
                "content": [
                    {
                        "username": "Atulsid151",
                        "content": "Oh man !!! I am a bit busy today, and this hard problem"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[3,1,2,5,4,6]\\nanswer for this is 19 .\\ncan anyone tell me the 19 arrangements , my answer is 9 only ."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Now i got it . \\nThanks brother \\uD83D\\uDC4D"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Prashu Deshmukh](/prashudeshmukh3006) yeah you are right\n\nthe right 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n-- (swap the 6 and 4)\n- [3,1,2,5,6,4]\n- [3,5,1,2,6,4]\n- [3,5,6,1,2,4]\n- [3,5,6,4,1,2]\n- [3,1,5,6,4,2]\n- [3,5,1,6,4,2]\n- [3,5,6,1,4,2]\n- [3,1,5,6,2,4]\n- [3,5,1,6,2,4]\n- [3,1,5,2,6,4]\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) I am not able to depict it properly .\\nBut my question is that in last 10 arrangements if we will insert nodes one by one then 3,2,1 will form a straight line in left subtree , but originally it was zig zag"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Consider [3,2,1,5,4,6]\\nHere we will insert nodes in the following oredr\\n3-->2-->1-->5-->4-->6\\nthen left sub tree will become\\n                    3\\n                  /\\n                2\\n               /\\n             1\\n\\nBut originally it was\\n                              3\\n                             /\\n                           1\\n                             \\\\\\n                               2"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@prashudeshmukh3006](/prashudeshmukh3006) it's similar because if you construct the BST from scratch, the BST will look the same as the original BST. \n\nit's the same as [2,1,3] and [2,3,1] from first example\n\n\"We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST\""
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Positions of 2 and 1 are disturbed"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw)  How come last 10 arrangements are identical to the original BST ?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "here's the 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n--\n- [3,2,1,5,4,6]\n- [3,5,2,1,4,6]\n- [3,5,4,2,1,6]\n- [3,5,4,6,2,1]\n- [3,2,5,4,6,1]\n- [3,5,2,4,6,1]\n- [3,5,4,2,6,1]\n- [3,2,5,4,1,6]\n- [3,5,2,4,1,6]\n- [3,2,5,1,4,6]"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Is it only me who reads the title like this: \\nNumber of Ways to Reorder Array to Get Same Bullshit\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "This is the type of question. When you see this in an interview, you know you\\'re not going to get the job in 10 seconds."
                    },
                    {
                        "username": "sigmale",
                        "content": "If you have a basic combinatorics knowledge then please do solve it by your own, I spent 2 hours and got my solution finally accepted (streak rizz), its worth trying if you have studied combinatorics.\\nIn case you\\'re confused about your combinatorics ability, here\\'s a question, if you can solve it then you can solve the above problem as well.\\n\\nProblem: Given n numbers (distinct) in a sequence, find the number of permutations of these n numbers such that relative ordering of some fixed m numbers (m<=n) should not change.\\neg. L= [ 1,2,3,4], here n=4 and if m=3, lets say 1,2,3 there relative order should remain same, then number of permutations become 4.(You can check by yourself)"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "public int numOfWays(int[] nums) {\\n    comb = generate(nums.length + 1);\\n    return ways(Arrays.stream(nums).boxed().collect(Collectors.toList())) - 1;\\n  }\\n\\n  private static final int kMod = 1_000_000_007;\\n  // comb[n][k] := C(n, k)\\n  private List<List<Integer>> comb;\\n\\n  private int ways(List<Integer> nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    List<Integer> left = new ArrayList<>();\\n    List<Integer> right = new ArrayList<>();\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums.get(i) < nums.get(0))\\n        left.add(nums.get(i));\\n      else\\n        right.add(nums.get(i));\\n\\n    long ans = comb.get(nums.size() - 1).get(left.size());\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return (int) ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> comb = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      comb.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb.get(i).size() - 1; ++j)\\n        comb.get(i).set(j, (comb.get(i - 1).get(j - 1) + comb.get(i - 1).get(j)) % kMod);\\n\\n    return comb;\\n  }"
                    },
                    {
                        "username": "user7478F",
                        "content": "The head will remain same\\nFor the rest of elements in nums i.e nums[1:], calculate ways in which the sequence of right childs and left childs is unchanged,\\n\\nEx. [3,4,5,1,2]\\nIn this example 4 should always come before 5 and 1 should always come before 2, we can change elements such that the places of element is changed but not the order of their traversing.\\n"
                    },
                    {
                        "username": "rcdarwinn",
                        "content": "me : decides to commit .\\nleetcode : just sit watch and learn.\\n -- going to see pascal triangle and binomial cofficient as suggested by [@mufia001](/mufia001) ps : learning "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**I smell the weekend is coming**"
                    },
                    {
                        "username": "ajv97",
                        "content": "I just time travelled to stop Leetcode from posting this question in the Daily Challenge but spiderman 2099 said this is a canon event for all of us."
                    }
                ]
            },
            {
                "id": 1931432,
                "content": [
                    {
                        "username": "Atulsid151",
                        "content": "Oh man !!! I am a bit busy today, and this hard problem"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[3,1,2,5,4,6]\\nanswer for this is 19 .\\ncan anyone tell me the 19 arrangements , my answer is 9 only ."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Now i got it . \\nThanks brother \\uD83D\\uDC4D"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Prashu Deshmukh](/prashudeshmukh3006) yeah you are right\n\nthe right 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n-- (swap the 6 and 4)\n- [3,1,2,5,6,4]\n- [3,5,1,2,6,4]\n- [3,5,6,1,2,4]\n- [3,5,6,4,1,2]\n- [3,1,5,6,4,2]\n- [3,5,1,6,4,2]\n- [3,5,6,1,4,2]\n- [3,1,5,6,2,4]\n- [3,5,1,6,2,4]\n- [3,1,5,2,6,4]\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) I am not able to depict it properly .\\nBut my question is that in last 10 arrangements if we will insert nodes one by one then 3,2,1 will form a straight line in left subtree , but originally it was zig zag"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Consider [3,2,1,5,4,6]\\nHere we will insert nodes in the following oredr\\n3-->2-->1-->5-->4-->6\\nthen left sub tree will become\\n                    3\\n                  /\\n                2\\n               /\\n             1\\n\\nBut originally it was\\n                              3\\n                             /\\n                           1\\n                             \\\\\\n                               2"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@prashudeshmukh3006](/prashudeshmukh3006) it's similar because if you construct the BST from scratch, the BST will look the same as the original BST. \n\nit's the same as [2,1,3] and [2,3,1] from first example\n\n\"We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST\""
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Positions of 2 and 1 are disturbed"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw)  How come last 10 arrangements are identical to the original BST ?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "here's the 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n--\n- [3,2,1,5,4,6]\n- [3,5,2,1,4,6]\n- [3,5,4,2,1,6]\n- [3,5,4,6,2,1]\n- [3,2,5,4,6,1]\n- [3,5,2,4,6,1]\n- [3,5,4,2,6,1]\n- [3,2,5,4,1,6]\n- [3,5,2,4,1,6]\n- [3,2,5,1,4,6]"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Is it only me who reads the title like this: \\nNumber of Ways to Reorder Array to Get Same Bullshit\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "This is the type of question. When you see this in an interview, you know you\\'re not going to get the job in 10 seconds."
                    },
                    {
                        "username": "sigmale",
                        "content": "If you have a basic combinatorics knowledge then please do solve it by your own, I spent 2 hours and got my solution finally accepted (streak rizz), its worth trying if you have studied combinatorics.\\nIn case you\\'re confused about your combinatorics ability, here\\'s a question, if you can solve it then you can solve the above problem as well.\\n\\nProblem: Given n numbers (distinct) in a sequence, find the number of permutations of these n numbers such that relative ordering of some fixed m numbers (m<=n) should not change.\\neg. L= [ 1,2,3,4], here n=4 and if m=3, lets say 1,2,3 there relative order should remain same, then number of permutations become 4.(You can check by yourself)"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "public int numOfWays(int[] nums) {\\n    comb = generate(nums.length + 1);\\n    return ways(Arrays.stream(nums).boxed().collect(Collectors.toList())) - 1;\\n  }\\n\\n  private static final int kMod = 1_000_000_007;\\n  // comb[n][k] := C(n, k)\\n  private List<List<Integer>> comb;\\n\\n  private int ways(List<Integer> nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    List<Integer> left = new ArrayList<>();\\n    List<Integer> right = new ArrayList<>();\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums.get(i) < nums.get(0))\\n        left.add(nums.get(i));\\n      else\\n        right.add(nums.get(i));\\n\\n    long ans = comb.get(nums.size() - 1).get(left.size());\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return (int) ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> comb = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      comb.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb.get(i).size() - 1; ++j)\\n        comb.get(i).set(j, (comb.get(i - 1).get(j - 1) + comb.get(i - 1).get(j)) % kMod);\\n\\n    return comb;\\n  }"
                    },
                    {
                        "username": "user7478F",
                        "content": "The head will remain same\\nFor the rest of elements in nums i.e nums[1:], calculate ways in which the sequence of right childs and left childs is unchanged,\\n\\nEx. [3,4,5,1,2]\\nIn this example 4 should always come before 5 and 1 should always come before 2, we can change elements such that the places of element is changed but not the order of their traversing.\\n"
                    },
                    {
                        "username": "rcdarwinn",
                        "content": "me : decides to commit .\\nleetcode : just sit watch and learn.\\n -- going to see pascal triangle and binomial cofficient as suggested by [@mufia001](/mufia001) ps : learning "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**I smell the weekend is coming**"
                    },
                    {
                        "username": "ajv97",
                        "content": "I just time travelled to stop Leetcode from posting this question in the Daily Challenge but spiderman 2099 said this is a canon event for all of us."
                    }
                ]
            },
            {
                "id": 1931410,
                "content": [
                    {
                        "username": "Atulsid151",
                        "content": "Oh man !!! I am a bit busy today, and this hard problem"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[3,1,2,5,4,6]\\nanswer for this is 19 .\\ncan anyone tell me the 19 arrangements , my answer is 9 only ."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Now i got it . \\nThanks brother \\uD83D\\uDC4D"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Prashu Deshmukh](/prashudeshmukh3006) yeah you are right\n\nthe right 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n-- (swap the 6 and 4)\n- [3,1,2,5,6,4]\n- [3,5,1,2,6,4]\n- [3,5,6,1,2,4]\n- [3,5,6,4,1,2]\n- [3,1,5,6,4,2]\n- [3,5,1,6,4,2]\n- [3,5,6,1,4,2]\n- [3,1,5,6,2,4]\n- [3,5,1,6,2,4]\n- [3,1,5,2,6,4]\n"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) I am not able to depict it properly .\\nBut my question is that in last 10 arrangements if we will insert nodes one by one then 3,2,1 will form a straight line in left subtree , but originally it was zig zag"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Consider [3,2,1,5,4,6]\\nHere we will insert nodes in the following oredr\\n3-->2-->1-->5-->4-->6\\nthen left sub tree will become\\n                    3\\n                  /\\n                2\\n               /\\n             1\\n\\nBut originally it was\\n                              3\\n                             /\\n                           1\\n                             \\\\\\n                               2"
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@prashudeshmukh3006](/prashudeshmukh3006) it's similar because if you construct the BST from scratch, the BST will look the same as the original BST. \n\nit's the same as [2,1,3] and [2,3,1] from first example\n\n\"We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST\""
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw) Positions of 2 and 1 are disturbed"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "[@EricRaw](/EricRaw)  How come last 10 arrangements are identical to the original BST ?"
                    },
                    {
                        "username": "EricRaw",
                        "content": "here's the 19 arrangements:\n- [3,5,1,2,4,6]\n- [3,5,4,1,2,6]\n- [3,5,4,6,1,2]\n- [3,1,5,4,6,2]\n- [3,5,1,4,6,2]\n- [3,5,4,1,6,2]\n- [3.1.5.4.2.6]\n- [3,5,1,4,2,6]\n- [3,1,5,2,4,6]\n--\n- [3,2,1,5,4,6]\n- [3,5,2,1,4,6]\n- [3,5,4,2,1,6]\n- [3,5,4,6,2,1]\n- [3,2,5,4,6,1]\n- [3,5,2,4,6,1]\n- [3,5,4,2,6,1]\n- [3,2,5,4,1,6]\n- [3,5,2,4,1,6]\n- [3,2,5,1,4,6]"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Is it only me who reads the title like this: \\nNumber of Ways to Reorder Array to Get Same Bullshit\\n"
                    },
                    {
                        "username": "SG-C",
                        "content": "This is the type of question. When you see this in an interview, you know you\\'re not going to get the job in 10 seconds."
                    },
                    {
                        "username": "sigmale",
                        "content": "If you have a basic combinatorics knowledge then please do solve it by your own, I spent 2 hours and got my solution finally accepted (streak rizz), its worth trying if you have studied combinatorics.\\nIn case you\\'re confused about your combinatorics ability, here\\'s a question, if you can solve it then you can solve the above problem as well.\\n\\nProblem: Given n numbers (distinct) in a sequence, find the number of permutations of these n numbers such that relative ordering of some fixed m numbers (m<=n) should not change.\\neg. L= [ 1,2,3,4], here n=4 and if m=3, lets say 1,2,3 there relative order should remain same, then number of permutations become 4.(You can check by yourself)"
                    },
                    {
                        "username": "teckyshubham",
                        "content": "public int numOfWays(int[] nums) {\\n    comb = generate(nums.length + 1);\\n    return ways(Arrays.stream(nums).boxed().collect(Collectors.toList())) - 1;\\n  }\\n\\n  private static final int kMod = 1_000_000_007;\\n  // comb[n][k] := C(n, k)\\n  private List<List<Integer>> comb;\\n\\n  private int ways(List<Integer> nums) {\\n    if (nums.size() <= 2)\\n      return 1;\\n\\n    List<Integer> left = new ArrayList<>();\\n    List<Integer> right = new ArrayList<>();\\n\\n    for (int i = 1; i < nums.size(); ++i)\\n      if (nums.get(i) < nums.get(0))\\n        left.add(nums.get(i));\\n      else\\n        right.add(nums.get(i));\\n\\n    long ans = comb.get(nums.size() - 1).get(left.size());\\n    ans = (ans * ways(left)) % kMod;\\n    ans = (ans * ways(right)) % kMod;\\n    return (int) ans;\\n  }\\n\\n  // 118. Pascal\\'s Triangle\\n  public List<List<Integer>> generate(int numRows) {\\n    List<List<Integer>> comb = new ArrayList<>();\\n\\n    for (int i = 0; i < numRows; ++i) {\\n      Integer[] temp = new Integer[i + 1];\\n      Arrays.fill(temp, 1);\\n      comb.add(Arrays.asList(temp));\\n    }\\n\\n    for (int i = 2; i < numRows; ++i)\\n      for (int j = 1; j < comb.get(i).size() - 1; ++j)\\n        comb.get(i).set(j, (comb.get(i - 1).get(j - 1) + comb.get(i - 1).get(j)) % kMod);\\n\\n    return comb;\\n  }"
                    },
                    {
                        "username": "user7478F",
                        "content": "The head will remain same\\nFor the rest of elements in nums i.e nums[1:], calculate ways in which the sequence of right childs and left childs is unchanged,\\n\\nEx. [3,4,5,1,2]\\nIn this example 4 should always come before 5 and 1 should always come before 2, we can change elements such that the places of element is changed but not the order of their traversing.\\n"
                    },
                    {
                        "username": "rcdarwinn",
                        "content": "me : decides to commit .\\nleetcode : just sit watch and learn.\\n -- going to see pascal triangle and binomial cofficient as suggested by [@mufia001](/mufia001) ps : learning "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**I smell the weekend is coming**"
                    },
                    {
                        "username": "ajv97",
                        "content": "I just time travelled to stop Leetcode from posting this question in the Daily Challenge but spiderman 2099 said this is a canon event for all of us."
                    }
                ]
            },
            {
                "id": 1931391,
                "content": [
                    {
                        "username": "ruturajpanditrao777",
                        "content": "My intuition says this is more of a Permutations and Combinations question...Like for the first test case of 3,1,4,5,2, Root always needs to go first so fix that. For remaining 1,4,5,2 the relative order of numbers less than root has to be same, like 1 has to be before 2, no matter where they occur in the array. Same for elements greater than root, 4 has to occur before 5 no matter where they occur in the array. "
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "I\\'m out \\uD83D\\uDE22"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "Editorial supremacy!"
                    },
                    {
                        "username": "shoorveerrathour",
                        "content": "Leetcode is so naugty|"
                    },
                    {
                        "username": "rishinith",
                        "content": "This is a amazing explanation\nhttps://www.youtube.com/watch?v=fXZ5YGalS2w\n"
                    },
                    {
                        "username": "amshanaks313",
                        "content": "my streak: \"aaah shut here we go again.....\""
                    },
                    {
                        "username": "daring-calf",
                        "content": "I almost thought today was Saturday."
                    },
                    {
                        "username": "IlkinDigital",
                        "content": "Officially giving up my 100 day streak o7"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who worry about the time spent computing the binomial coefficient. Try to work out the math for two layers manually, and watch out for opportunities to cancel."
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It isn't particularly easy to describe without revealing, so I just leave the spoiler here:\n\nDenote the size of the subtrees be `leftSize` and `rightSize`, denote the count of the sequences of the subtrees be `leftCount` and `rightCount`, editorial implies:\n\nThe size of the tree is `treeSize = leftSize + rightSize + 1`, The count of sequence of the tree is `treeCount = C(leftCount + rightCount, leftCount) * leftCount * rightCount`.\n\nComputing binomial coefficients is just a hassle, can we do better? Yes - with this trick. The first step is the gem - the rest is just manipulations.\n\n```\nConsider treeCount/(treeSize!) \n= C(leftSize + rightSize, leftSize) * leftCount * rightCount.\n= C(treeSize - 1, leftSize) * leftCount * rightCount.\n= (treeSize - 1)! * leftCount * rightCount / (leftSize! * rightSize! * treeSize!)\n= (leftCount/leftSize!) * (rightCount/rightSize!) * 1/treeSize [See how the treeSize! and (treeSize - 1)! just cancels!]\n```\n\n> As an aside - whenever I read math stuff and I read the word `consider`. I start to cry. How on earth anyone come up with that expression to start considering. This one in particular, the intuition comes from I feel like the expressions are all multiplications and the factorials are all over the numerator and denominator, so it is only natural to hope they cancels.\n\nSo instead of computing the `treeCount` - we can compute the `treeFraction = treeCount/treeSize!` instead. Note that we also return the `treeSize`, so the `treeCount` can always be recovered. Now we have this much simpler recurrence:\n\n`treeFraction = leftFraction * rightFraction / treeSize`\n\nInstead of having to compute a binomial coefficient (pre-compute or otherwise), every internal node only need a multiplication and a division.\n\nEven better, instead of doing a division (in which you need modular inverse, a non-trivial operation), return the numerator and denominator as a tuple, those can be computed mod `1e9+7` - no need for big numbers.\n\nAll the way up, you will have `rootFraction`, recall that `rootFraction = rootCount/(rootSize!)`, but `rootSize` is obviously just `n`. So you simply multiply the `rootNumerator` by `n!` and then divide the `rootNumerator` by the `rootDenominator` using modular inverse only once, and you are done.\n\n> Spoting this opportunity is non-trivial, that's why I leave this hint about cancelation and hope people pick it up.\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cecilia5](/cecilia5) By any chance isn\\'t [that](https://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences) what you\\'re talking about?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@psionl0](/psionl0) There exist a solution that allow you to not compute the binomial coefficients at all. [You still need to think about them, you just don\\'t need to compute them because they cancel each other]"
                    },
                    {
                        "username": "psionl0",
                        "content": "At every recursive level, you will need to do a combination calculation so Pascal\\'s triangle is more useful than trying to calculate the coefficients on the fly."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "my daily streak ends here!"
                    }
                ]
            },
            {
                "id": 1931386,
                "content": [
                    {
                        "username": "ruturajpanditrao777",
                        "content": "My intuition says this is more of a Permutations and Combinations question...Like for the first test case of 3,1,4,5,2, Root always needs to go first so fix that. For remaining 1,4,5,2 the relative order of numbers less than root has to be same, like 1 has to be before 2, no matter where they occur in the array. Same for elements greater than root, 4 has to occur before 5 no matter where they occur in the array. "
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "I\\'m out \\uD83D\\uDE22"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "Editorial supremacy!"
                    },
                    {
                        "username": "shoorveerrathour",
                        "content": "Leetcode is so naugty|"
                    },
                    {
                        "username": "rishinith",
                        "content": "This is a amazing explanation\nhttps://www.youtube.com/watch?v=fXZ5YGalS2w\n"
                    },
                    {
                        "username": "amshanaks313",
                        "content": "my streak: \"aaah shut here we go again.....\""
                    },
                    {
                        "username": "daring-calf",
                        "content": "I almost thought today was Saturday."
                    },
                    {
                        "username": "IlkinDigital",
                        "content": "Officially giving up my 100 day streak o7"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who worry about the time spent computing the binomial coefficient. Try to work out the math for two layers manually, and watch out for opportunities to cancel."
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It isn't particularly easy to describe without revealing, so I just leave the spoiler here:\n\nDenote the size of the subtrees be `leftSize` and `rightSize`, denote the count of the sequences of the subtrees be `leftCount` and `rightCount`, editorial implies:\n\nThe size of the tree is `treeSize = leftSize + rightSize + 1`, The count of sequence of the tree is `treeCount = C(leftCount + rightCount, leftCount) * leftCount * rightCount`.\n\nComputing binomial coefficients is just a hassle, can we do better? Yes - with this trick. The first step is the gem - the rest is just manipulations.\n\n```\nConsider treeCount/(treeSize!) \n= C(leftSize + rightSize, leftSize) * leftCount * rightCount.\n= C(treeSize - 1, leftSize) * leftCount * rightCount.\n= (treeSize - 1)! * leftCount * rightCount / (leftSize! * rightSize! * treeSize!)\n= (leftCount/leftSize!) * (rightCount/rightSize!) * 1/treeSize [See how the treeSize! and (treeSize - 1)! just cancels!]\n```\n\n> As an aside - whenever I read math stuff and I read the word `consider`. I start to cry. How on earth anyone come up with that expression to start considering. This one in particular, the intuition comes from I feel like the expressions are all multiplications and the factorials are all over the numerator and denominator, so it is only natural to hope they cancels.\n\nSo instead of computing the `treeCount` - we can compute the `treeFraction = treeCount/treeSize!` instead. Note that we also return the `treeSize`, so the `treeCount` can always be recovered. Now we have this much simpler recurrence:\n\n`treeFraction = leftFraction * rightFraction / treeSize`\n\nInstead of having to compute a binomial coefficient (pre-compute or otherwise), every internal node only need a multiplication and a division.\n\nEven better, instead of doing a division (in which you need modular inverse, a non-trivial operation), return the numerator and denominator as a tuple, those can be computed mod `1e9+7` - no need for big numbers.\n\nAll the way up, you will have `rootFraction`, recall that `rootFraction = rootCount/(rootSize!)`, but `rootSize` is obviously just `n`. So you simply multiply the `rootNumerator` by `n!` and then divide the `rootNumerator` by the `rootDenominator` using modular inverse only once, and you are done.\n\n> Spoting this opportunity is non-trivial, that's why I leave this hint about cancelation and hope people pick it up.\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cecilia5](/cecilia5) By any chance isn\\'t [that](https://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences) what you\\'re talking about?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@psionl0](/psionl0) There exist a solution that allow you to not compute the binomial coefficients at all. [You still need to think about them, you just don\\'t need to compute them because they cancel each other]"
                    },
                    {
                        "username": "psionl0",
                        "content": "At every recursive level, you will need to do a combination calculation so Pascal\\'s triangle is more useful than trying to calculate the coefficients on the fly."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "my daily streak ends here!"
                    }
                ]
            },
            {
                "id": 1931382,
                "content": [
                    {
                        "username": "ruturajpanditrao777",
                        "content": "My intuition says this is more of a Permutations and Combinations question...Like for the first test case of 3,1,4,5,2, Root always needs to go first so fix that. For remaining 1,4,5,2 the relative order of numbers less than root has to be same, like 1 has to be before 2, no matter where they occur in the array. Same for elements greater than root, 4 has to occur before 5 no matter where they occur in the array. "
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "I\\'m out \\uD83D\\uDE22"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "Editorial supremacy!"
                    },
                    {
                        "username": "shoorveerrathour",
                        "content": "Leetcode is so naugty|"
                    },
                    {
                        "username": "rishinith",
                        "content": "This is a amazing explanation\nhttps://www.youtube.com/watch?v=fXZ5YGalS2w\n"
                    },
                    {
                        "username": "amshanaks313",
                        "content": "my streak: \"aaah shut here we go again.....\""
                    },
                    {
                        "username": "daring-calf",
                        "content": "I almost thought today was Saturday."
                    },
                    {
                        "username": "IlkinDigital",
                        "content": "Officially giving up my 100 day streak o7"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who worry about the time spent computing the binomial coefficient. Try to work out the math for two layers manually, and watch out for opportunities to cancel."
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It isn't particularly easy to describe without revealing, so I just leave the spoiler here:\n\nDenote the size of the subtrees be `leftSize` and `rightSize`, denote the count of the sequences of the subtrees be `leftCount` and `rightCount`, editorial implies:\n\nThe size of the tree is `treeSize = leftSize + rightSize + 1`, The count of sequence of the tree is `treeCount = C(leftCount + rightCount, leftCount) * leftCount * rightCount`.\n\nComputing binomial coefficients is just a hassle, can we do better? Yes - with this trick. The first step is the gem - the rest is just manipulations.\n\n```\nConsider treeCount/(treeSize!) \n= C(leftSize + rightSize, leftSize) * leftCount * rightCount.\n= C(treeSize - 1, leftSize) * leftCount * rightCount.\n= (treeSize - 1)! * leftCount * rightCount / (leftSize! * rightSize! * treeSize!)\n= (leftCount/leftSize!) * (rightCount/rightSize!) * 1/treeSize [See how the treeSize! and (treeSize - 1)! just cancels!]\n```\n\n> As an aside - whenever I read math stuff and I read the word `consider`. I start to cry. How on earth anyone come up with that expression to start considering. This one in particular, the intuition comes from I feel like the expressions are all multiplications and the factorials are all over the numerator and denominator, so it is only natural to hope they cancels.\n\nSo instead of computing the `treeCount` - we can compute the `treeFraction = treeCount/treeSize!` instead. Note that we also return the `treeSize`, so the `treeCount` can always be recovered. Now we have this much simpler recurrence:\n\n`treeFraction = leftFraction * rightFraction / treeSize`\n\nInstead of having to compute a binomial coefficient (pre-compute or otherwise), every internal node only need a multiplication and a division.\n\nEven better, instead of doing a division (in which you need modular inverse, a non-trivial operation), return the numerator and denominator as a tuple, those can be computed mod `1e9+7` - no need for big numbers.\n\nAll the way up, you will have `rootFraction`, recall that `rootFraction = rootCount/(rootSize!)`, but `rootSize` is obviously just `n`. So you simply multiply the `rootNumerator` by `n!` and then divide the `rootNumerator` by the `rootDenominator` using modular inverse only once, and you are done.\n\n> Spoting this opportunity is non-trivial, that's why I leave this hint about cancelation and hope people pick it up.\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cecilia5](/cecilia5) By any chance isn\\'t [that](https://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences) what you\\'re talking about?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@psionl0](/psionl0) There exist a solution that allow you to not compute the binomial coefficients at all. [You still need to think about them, you just don\\'t need to compute them because they cancel each other]"
                    },
                    {
                        "username": "psionl0",
                        "content": "At every recursive level, you will need to do a combination calculation so Pascal\\'s triangle is more useful than trying to calculate the coefficients on the fly."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "my daily streak ends here!"
                    }
                ]
            },
            {
                "id": 1931369,
                "content": [
                    {
                        "username": "ruturajpanditrao777",
                        "content": "My intuition says this is more of a Permutations and Combinations question...Like for the first test case of 3,1,4,5,2, Root always needs to go first so fix that. For remaining 1,4,5,2 the relative order of numbers less than root has to be same, like 1 has to be before 2, no matter where they occur in the array. Same for elements greater than root, 4 has to occur before 5 no matter where they occur in the array. "
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "I\\'m out \\uD83D\\uDE22"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "Editorial supremacy!"
                    },
                    {
                        "username": "shoorveerrathour",
                        "content": "Leetcode is so naugty|"
                    },
                    {
                        "username": "rishinith",
                        "content": "This is a amazing explanation\nhttps://www.youtube.com/watch?v=fXZ5YGalS2w\n"
                    },
                    {
                        "username": "amshanaks313",
                        "content": "my streak: \"aaah shut here we go again.....\""
                    },
                    {
                        "username": "daring-calf",
                        "content": "I almost thought today was Saturday."
                    },
                    {
                        "username": "IlkinDigital",
                        "content": "Officially giving up my 100 day streak o7"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who worry about the time spent computing the binomial coefficient. Try to work out the math for two layers manually, and watch out for opportunities to cancel."
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It isn't particularly easy to describe without revealing, so I just leave the spoiler here:\n\nDenote the size of the subtrees be `leftSize` and `rightSize`, denote the count of the sequences of the subtrees be `leftCount` and `rightCount`, editorial implies:\n\nThe size of the tree is `treeSize = leftSize + rightSize + 1`, The count of sequence of the tree is `treeCount = C(leftCount + rightCount, leftCount) * leftCount * rightCount`.\n\nComputing binomial coefficients is just a hassle, can we do better? Yes - with this trick. The first step is the gem - the rest is just manipulations.\n\n```\nConsider treeCount/(treeSize!) \n= C(leftSize + rightSize, leftSize) * leftCount * rightCount.\n= C(treeSize - 1, leftSize) * leftCount * rightCount.\n= (treeSize - 1)! * leftCount * rightCount / (leftSize! * rightSize! * treeSize!)\n= (leftCount/leftSize!) * (rightCount/rightSize!) * 1/treeSize [See how the treeSize! and (treeSize - 1)! just cancels!]\n```\n\n> As an aside - whenever I read math stuff and I read the word `consider`. I start to cry. How on earth anyone come up with that expression to start considering. This one in particular, the intuition comes from I feel like the expressions are all multiplications and the factorials are all over the numerator and denominator, so it is only natural to hope they cancels.\n\nSo instead of computing the `treeCount` - we can compute the `treeFraction = treeCount/treeSize!` instead. Note that we also return the `treeSize`, so the `treeCount` can always be recovered. Now we have this much simpler recurrence:\n\n`treeFraction = leftFraction * rightFraction / treeSize`\n\nInstead of having to compute a binomial coefficient (pre-compute or otherwise), every internal node only need a multiplication and a division.\n\nEven better, instead of doing a division (in which you need modular inverse, a non-trivial operation), return the numerator and denominator as a tuple, those can be computed mod `1e9+7` - no need for big numbers.\n\nAll the way up, you will have `rootFraction`, recall that `rootFraction = rootCount/(rootSize!)`, but `rootSize` is obviously just `n`. So you simply multiply the `rootNumerator` by `n!` and then divide the `rootNumerator` by the `rootDenominator` using modular inverse only once, and you are done.\n\n> Spoting this opportunity is non-trivial, that's why I leave this hint about cancelation and hope people pick it up.\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cecilia5](/cecilia5) By any chance isn\\'t [that](https://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences) what you\\'re talking about?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@psionl0](/psionl0) There exist a solution that allow you to not compute the binomial coefficients at all. [You still need to think about them, you just don\\'t need to compute them because they cancel each other]"
                    },
                    {
                        "username": "psionl0",
                        "content": "At every recursive level, you will need to do a combination calculation so Pascal\\'s triangle is more useful than trying to calculate the coefficients on the fly."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "my daily streak ends here!"
                    }
                ]
            },
            {
                "id": 1931367,
                "content": [
                    {
                        "username": "ruturajpanditrao777",
                        "content": "My intuition says this is more of a Permutations and Combinations question...Like for the first test case of 3,1,4,5,2, Root always needs to go first so fix that. For remaining 1,4,5,2 the relative order of numbers less than root has to be same, like 1 has to be before 2, no matter where they occur in the array. Same for elements greater than root, 4 has to occur before 5 no matter where they occur in the array. "
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "I\\'m out \\uD83D\\uDE22"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "Editorial supremacy!"
                    },
                    {
                        "username": "shoorveerrathour",
                        "content": "Leetcode is so naugty|"
                    },
                    {
                        "username": "rishinith",
                        "content": "This is a amazing explanation\nhttps://www.youtube.com/watch?v=fXZ5YGalS2w\n"
                    },
                    {
                        "username": "amshanaks313",
                        "content": "my streak: \"aaah shut here we go again.....\""
                    },
                    {
                        "username": "daring-calf",
                        "content": "I almost thought today was Saturday."
                    },
                    {
                        "username": "IlkinDigital",
                        "content": "Officially giving up my 100 day streak o7"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who worry about the time spent computing the binomial coefficient. Try to work out the math for two layers manually, and watch out for opportunities to cancel."
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It isn't particularly easy to describe without revealing, so I just leave the spoiler here:\n\nDenote the size of the subtrees be `leftSize` and `rightSize`, denote the count of the sequences of the subtrees be `leftCount` and `rightCount`, editorial implies:\n\nThe size of the tree is `treeSize = leftSize + rightSize + 1`, The count of sequence of the tree is `treeCount = C(leftCount + rightCount, leftCount) * leftCount * rightCount`.\n\nComputing binomial coefficients is just a hassle, can we do better? Yes - with this trick. The first step is the gem - the rest is just manipulations.\n\n```\nConsider treeCount/(treeSize!) \n= C(leftSize + rightSize, leftSize) * leftCount * rightCount.\n= C(treeSize - 1, leftSize) * leftCount * rightCount.\n= (treeSize - 1)! * leftCount * rightCount / (leftSize! * rightSize! * treeSize!)\n= (leftCount/leftSize!) * (rightCount/rightSize!) * 1/treeSize [See how the treeSize! and (treeSize - 1)! just cancels!]\n```\n\n> As an aside - whenever I read math stuff and I read the word `consider`. I start to cry. How on earth anyone come up with that expression to start considering. This one in particular, the intuition comes from I feel like the expressions are all multiplications and the factorials are all over the numerator and denominator, so it is only natural to hope they cancels.\n\nSo instead of computing the `treeCount` - we can compute the `treeFraction = treeCount/treeSize!` instead. Note that we also return the `treeSize`, so the `treeCount` can always be recovered. Now we have this much simpler recurrence:\n\n`treeFraction = leftFraction * rightFraction / treeSize`\n\nInstead of having to compute a binomial coefficient (pre-compute or otherwise), every internal node only need a multiplication and a division.\n\nEven better, instead of doing a division (in which you need modular inverse, a non-trivial operation), return the numerator and denominator as a tuple, those can be computed mod `1e9+7` - no need for big numbers.\n\nAll the way up, you will have `rootFraction`, recall that `rootFraction = rootCount/(rootSize!)`, but `rootSize` is obviously just `n`. So you simply multiply the `rootNumerator` by `n!` and then divide the `rootNumerator` by the `rootDenominator` using modular inverse only once, and you are done.\n\n> Spoting this opportunity is non-trivial, that's why I leave this hint about cancelation and hope people pick it up.\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cecilia5](/cecilia5) By any chance isn\\'t [that](https://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences) what you\\'re talking about?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@psionl0](/psionl0) There exist a solution that allow you to not compute the binomial coefficients at all. [You still need to think about them, you just don\\'t need to compute them because they cancel each other]"
                    },
                    {
                        "username": "psionl0",
                        "content": "At every recursive level, you will need to do a combination calculation so Pascal\\'s triangle is more useful than trying to calculate the coefficients on the fly."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "my daily streak ends here!"
                    }
                ]
            },
            {
                "id": 1931345,
                "content": [
                    {
                        "username": "ruturajpanditrao777",
                        "content": "My intuition says this is more of a Permutations and Combinations question...Like for the first test case of 3,1,4,5,2, Root always needs to go first so fix that. For remaining 1,4,5,2 the relative order of numbers less than root has to be same, like 1 has to be before 2, no matter where they occur in the array. Same for elements greater than root, 4 has to occur before 5 no matter where they occur in the array. "
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "I\\'m out \\uD83D\\uDE22"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "Editorial supremacy!"
                    },
                    {
                        "username": "shoorveerrathour",
                        "content": "Leetcode is so naugty|"
                    },
                    {
                        "username": "rishinith",
                        "content": "This is a amazing explanation\nhttps://www.youtube.com/watch?v=fXZ5YGalS2w\n"
                    },
                    {
                        "username": "amshanaks313",
                        "content": "my streak: \"aaah shut here we go again.....\""
                    },
                    {
                        "username": "daring-calf",
                        "content": "I almost thought today was Saturday."
                    },
                    {
                        "username": "IlkinDigital",
                        "content": "Officially giving up my 100 day streak o7"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who worry about the time spent computing the binomial coefficient. Try to work out the math for two layers manually, and watch out for opportunities to cancel."
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It isn't particularly easy to describe without revealing, so I just leave the spoiler here:\n\nDenote the size of the subtrees be `leftSize` and `rightSize`, denote the count of the sequences of the subtrees be `leftCount` and `rightCount`, editorial implies:\n\nThe size of the tree is `treeSize = leftSize + rightSize + 1`, The count of sequence of the tree is `treeCount = C(leftCount + rightCount, leftCount) * leftCount * rightCount`.\n\nComputing binomial coefficients is just a hassle, can we do better? Yes - with this trick. The first step is the gem - the rest is just manipulations.\n\n```\nConsider treeCount/(treeSize!) \n= C(leftSize + rightSize, leftSize) * leftCount * rightCount.\n= C(treeSize - 1, leftSize) * leftCount * rightCount.\n= (treeSize - 1)! * leftCount * rightCount / (leftSize! * rightSize! * treeSize!)\n= (leftCount/leftSize!) * (rightCount/rightSize!) * 1/treeSize [See how the treeSize! and (treeSize - 1)! just cancels!]\n```\n\n> As an aside - whenever I read math stuff and I read the word `consider`. I start to cry. How on earth anyone come up with that expression to start considering. This one in particular, the intuition comes from I feel like the expressions are all multiplications and the factorials are all over the numerator and denominator, so it is only natural to hope they cancels.\n\nSo instead of computing the `treeCount` - we can compute the `treeFraction = treeCount/treeSize!` instead. Note that we also return the `treeSize`, so the `treeCount` can always be recovered. Now we have this much simpler recurrence:\n\n`treeFraction = leftFraction * rightFraction / treeSize`\n\nInstead of having to compute a binomial coefficient (pre-compute or otherwise), every internal node only need a multiplication and a division.\n\nEven better, instead of doing a division (in which you need modular inverse, a non-trivial operation), return the numerator and denominator as a tuple, those can be computed mod `1e9+7` - no need for big numbers.\n\nAll the way up, you will have `rootFraction`, recall that `rootFraction = rootCount/(rootSize!)`, but `rootSize` is obviously just `n`. So you simply multiply the `rootNumerator` by `n!` and then divide the `rootNumerator` by the `rootDenominator` using modular inverse only once, and you are done.\n\n> Spoting this opportunity is non-trivial, that's why I leave this hint about cancelation and hope people pick it up.\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cecilia5](/cecilia5) By any chance isn\\'t [that](https://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences) what you\\'re talking about?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@psionl0](/psionl0) There exist a solution that allow you to not compute the binomial coefficients at all. [You still need to think about them, you just don\\'t need to compute them because they cancel each other]"
                    },
                    {
                        "username": "psionl0",
                        "content": "At every recursive level, you will need to do a combination calculation so Pascal\\'s triangle is more useful than trying to calculate the coefficients on the fly."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "my daily streak ends here!"
                    }
                ]
            },
            {
                "id": 1931300,
                "content": [
                    {
                        "username": "ruturajpanditrao777",
                        "content": "My intuition says this is more of a Permutations and Combinations question...Like for the first test case of 3,1,4,5,2, Root always needs to go first so fix that. For remaining 1,4,5,2 the relative order of numbers less than root has to be same, like 1 has to be before 2, no matter where they occur in the array. Same for elements greater than root, 4 has to occur before 5 no matter where they occur in the array. "
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "I\\'m out \\uD83D\\uDE22"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "Editorial supremacy!"
                    },
                    {
                        "username": "shoorveerrathour",
                        "content": "Leetcode is so naugty|"
                    },
                    {
                        "username": "rishinith",
                        "content": "This is a amazing explanation\nhttps://www.youtube.com/watch?v=fXZ5YGalS2w\n"
                    },
                    {
                        "username": "amshanaks313",
                        "content": "my streak: \"aaah shut here we go again.....\""
                    },
                    {
                        "username": "daring-calf",
                        "content": "I almost thought today was Saturday."
                    },
                    {
                        "username": "IlkinDigital",
                        "content": "Officially giving up my 100 day streak o7"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who worry about the time spent computing the binomial coefficient. Try to work out the math for two layers manually, and watch out for opportunities to cancel."
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It isn't particularly easy to describe without revealing, so I just leave the spoiler here:\n\nDenote the size of the subtrees be `leftSize` and `rightSize`, denote the count of the sequences of the subtrees be `leftCount` and `rightCount`, editorial implies:\n\nThe size of the tree is `treeSize = leftSize + rightSize + 1`, The count of sequence of the tree is `treeCount = C(leftCount + rightCount, leftCount) * leftCount * rightCount`.\n\nComputing binomial coefficients is just a hassle, can we do better? Yes - with this trick. The first step is the gem - the rest is just manipulations.\n\n```\nConsider treeCount/(treeSize!) \n= C(leftSize + rightSize, leftSize) * leftCount * rightCount.\n= C(treeSize - 1, leftSize) * leftCount * rightCount.\n= (treeSize - 1)! * leftCount * rightCount / (leftSize! * rightSize! * treeSize!)\n= (leftCount/leftSize!) * (rightCount/rightSize!) * 1/treeSize [See how the treeSize! and (treeSize - 1)! just cancels!]\n```\n\n> As an aside - whenever I read math stuff and I read the word `consider`. I start to cry. How on earth anyone come up with that expression to start considering. This one in particular, the intuition comes from I feel like the expressions are all multiplications and the factorials are all over the numerator and denominator, so it is only natural to hope they cancels.\n\nSo instead of computing the `treeCount` - we can compute the `treeFraction = treeCount/treeSize!` instead. Note that we also return the `treeSize`, so the `treeCount` can always be recovered. Now we have this much simpler recurrence:\n\n`treeFraction = leftFraction * rightFraction / treeSize`\n\nInstead of having to compute a binomial coefficient (pre-compute or otherwise), every internal node only need a multiplication and a division.\n\nEven better, instead of doing a division (in which you need modular inverse, a non-trivial operation), return the numerator and denominator as a tuple, those can be computed mod `1e9+7` - no need for big numbers.\n\nAll the way up, you will have `rootFraction`, recall that `rootFraction = rootCount/(rootSize!)`, but `rootSize` is obviously just `n`. So you simply multiply the `rootNumerator` by `n!` and then divide the `rootNumerator` by the `rootDenominator` using modular inverse only once, and you are done.\n\n> Spoting this opportunity is non-trivial, that's why I leave this hint about cancelation and hope people pick it up.\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cecilia5](/cecilia5) By any chance isn\\'t [that](https://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences) what you\\'re talking about?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@psionl0](/psionl0) There exist a solution that allow you to not compute the binomial coefficients at all. [You still need to think about them, you just don\\'t need to compute them because they cancel each other]"
                    },
                    {
                        "username": "psionl0",
                        "content": "At every recursive level, you will need to do a combination calculation so Pascal\\'s triangle is more useful than trying to calculate the coefficients on the fly."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "my daily streak ends here!"
                    }
                ]
            },
            {
                "id": 1931280,
                "content": [
                    {
                        "username": "ruturajpanditrao777",
                        "content": "My intuition says this is more of a Permutations and Combinations question...Like for the first test case of 3,1,4,5,2, Root always needs to go first so fix that. For remaining 1,4,5,2 the relative order of numbers less than root has to be same, like 1 has to be before 2, no matter where they occur in the array. Same for elements greater than root, 4 has to occur before 5 no matter where they occur in the array. "
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "I\\'m out \\uD83D\\uDE22"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "Editorial supremacy!"
                    },
                    {
                        "username": "shoorveerrathour",
                        "content": "Leetcode is so naugty|"
                    },
                    {
                        "username": "rishinith",
                        "content": "This is a amazing explanation\nhttps://www.youtube.com/watch?v=fXZ5YGalS2w\n"
                    },
                    {
                        "username": "amshanaks313",
                        "content": "my streak: \"aaah shut here we go again.....\""
                    },
                    {
                        "username": "daring-calf",
                        "content": "I almost thought today was Saturday."
                    },
                    {
                        "username": "IlkinDigital",
                        "content": "Officially giving up my 100 day streak o7"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who worry about the time spent computing the binomial coefficient. Try to work out the math for two layers manually, and watch out for opportunities to cancel."
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It isn't particularly easy to describe without revealing, so I just leave the spoiler here:\n\nDenote the size of the subtrees be `leftSize` and `rightSize`, denote the count of the sequences of the subtrees be `leftCount` and `rightCount`, editorial implies:\n\nThe size of the tree is `treeSize = leftSize + rightSize + 1`, The count of sequence of the tree is `treeCount = C(leftCount + rightCount, leftCount) * leftCount * rightCount`.\n\nComputing binomial coefficients is just a hassle, can we do better? Yes - with this trick. The first step is the gem - the rest is just manipulations.\n\n```\nConsider treeCount/(treeSize!) \n= C(leftSize + rightSize, leftSize) * leftCount * rightCount.\n= C(treeSize - 1, leftSize) * leftCount * rightCount.\n= (treeSize - 1)! * leftCount * rightCount / (leftSize! * rightSize! * treeSize!)\n= (leftCount/leftSize!) * (rightCount/rightSize!) * 1/treeSize [See how the treeSize! and (treeSize - 1)! just cancels!]\n```\n\n> As an aside - whenever I read math stuff and I read the word `consider`. I start to cry. How on earth anyone come up with that expression to start considering. This one in particular, the intuition comes from I feel like the expressions are all multiplications and the factorials are all over the numerator and denominator, so it is only natural to hope they cancels.\n\nSo instead of computing the `treeCount` - we can compute the `treeFraction = treeCount/treeSize!` instead. Note that we also return the `treeSize`, so the `treeCount` can always be recovered. Now we have this much simpler recurrence:\n\n`treeFraction = leftFraction * rightFraction / treeSize`\n\nInstead of having to compute a binomial coefficient (pre-compute or otherwise), every internal node only need a multiplication and a division.\n\nEven better, instead of doing a division (in which you need modular inverse, a non-trivial operation), return the numerator and denominator as a tuple, those can be computed mod `1e9+7` - no need for big numbers.\n\nAll the way up, you will have `rootFraction`, recall that `rootFraction = rootCount/(rootSize!)`, but `rootSize` is obviously just `n`. So you simply multiply the `rootNumerator` by `n!` and then divide the `rootNumerator` by the `rootDenominator` using modular inverse only once, and you are done.\n\n> Spoting this opportunity is non-trivial, that's why I leave this hint about cancelation and hope people pick it up.\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cecilia5](/cecilia5) By any chance isn\\'t [that](https://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences) what you\\'re talking about?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@psionl0](/psionl0) There exist a solution that allow you to not compute the binomial coefficients at all. [You still need to think about them, you just don\\'t need to compute them because they cancel each other]"
                    },
                    {
                        "username": "psionl0",
                        "content": "At every recursive level, you will need to do a combination calculation so Pascal\\'s triangle is more useful than trying to calculate the coefficients on the fly."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "my daily streak ends here!"
                    }
                ]
            },
            {
                "id": 1931279,
                "content": [
                    {
                        "username": "ruturajpanditrao777",
                        "content": "My intuition says this is more of a Permutations and Combinations question...Like for the first test case of 3,1,4,5,2, Root always needs to go first so fix that. For remaining 1,4,5,2 the relative order of numbers less than root has to be same, like 1 has to be before 2, no matter where they occur in the array. Same for elements greater than root, 4 has to occur before 5 no matter where they occur in the array. "
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "I\\'m out \\uD83D\\uDE22"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "Editorial supremacy!"
                    },
                    {
                        "username": "shoorveerrathour",
                        "content": "Leetcode is so naugty|"
                    },
                    {
                        "username": "rishinith",
                        "content": "This is a amazing explanation\nhttps://www.youtube.com/watch?v=fXZ5YGalS2w\n"
                    },
                    {
                        "username": "amshanaks313",
                        "content": "my streak: \"aaah shut here we go again.....\""
                    },
                    {
                        "username": "daring-calf",
                        "content": "I almost thought today was Saturday."
                    },
                    {
                        "username": "IlkinDigital",
                        "content": "Officially giving up my 100 day streak o7"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who worry about the time spent computing the binomial coefficient. Try to work out the math for two layers manually, and watch out for opportunities to cancel."
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It isn't particularly easy to describe without revealing, so I just leave the spoiler here:\n\nDenote the size of the subtrees be `leftSize` and `rightSize`, denote the count of the sequences of the subtrees be `leftCount` and `rightCount`, editorial implies:\n\nThe size of the tree is `treeSize = leftSize + rightSize + 1`, The count of sequence of the tree is `treeCount = C(leftCount + rightCount, leftCount) * leftCount * rightCount`.\n\nComputing binomial coefficients is just a hassle, can we do better? Yes - with this trick. The first step is the gem - the rest is just manipulations.\n\n```\nConsider treeCount/(treeSize!) \n= C(leftSize + rightSize, leftSize) * leftCount * rightCount.\n= C(treeSize - 1, leftSize) * leftCount * rightCount.\n= (treeSize - 1)! * leftCount * rightCount / (leftSize! * rightSize! * treeSize!)\n= (leftCount/leftSize!) * (rightCount/rightSize!) * 1/treeSize [See how the treeSize! and (treeSize - 1)! just cancels!]\n```\n\n> As an aside - whenever I read math stuff and I read the word `consider`. I start to cry. How on earth anyone come up with that expression to start considering. This one in particular, the intuition comes from I feel like the expressions are all multiplications and the factorials are all over the numerator and denominator, so it is only natural to hope they cancels.\n\nSo instead of computing the `treeCount` - we can compute the `treeFraction = treeCount/treeSize!` instead. Note that we also return the `treeSize`, so the `treeCount` can always be recovered. Now we have this much simpler recurrence:\n\n`treeFraction = leftFraction * rightFraction / treeSize`\n\nInstead of having to compute a binomial coefficient (pre-compute or otherwise), every internal node only need a multiplication and a division.\n\nEven better, instead of doing a division (in which you need modular inverse, a non-trivial operation), return the numerator and denominator as a tuple, those can be computed mod `1e9+7` - no need for big numbers.\n\nAll the way up, you will have `rootFraction`, recall that `rootFraction = rootCount/(rootSize!)`, but `rootSize` is obviously just `n`. So you simply multiply the `rootNumerator` by `n!` and then divide the `rootNumerator` by the `rootDenominator` using modular inverse only once, and you are done.\n\n> Spoting this opportunity is non-trivial, that's why I leave this hint about cancelation and hope people pick it up.\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cecilia5](/cecilia5) By any chance isn\\'t [that](https://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences) what you\\'re talking about?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@psionl0](/psionl0) There exist a solution that allow you to not compute the binomial coefficients at all. [You still need to think about them, you just don\\'t need to compute them because they cancel each other]"
                    },
                    {
                        "username": "psionl0",
                        "content": "At every recursive level, you will need to do a combination calculation so Pascal\\'s triangle is more useful than trying to calculate the coefficients on the fly."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "my daily streak ends here!"
                    }
                ]
            },
            {
                "id": 1931268,
                "content": [
                    {
                        "username": "ruturajpanditrao777",
                        "content": "My intuition says this is more of a Permutations and Combinations question...Like for the first test case of 3,1,4,5,2, Root always needs to go first so fix that. For remaining 1,4,5,2 the relative order of numbers less than root has to be same, like 1 has to be before 2, no matter where they occur in the array. Same for elements greater than root, 4 has to occur before 5 no matter where they occur in the array. "
                    },
                    {
                        "username": "vijayvardhan6",
                        "content": "I\\'m out \\uD83D\\uDE22"
                    },
                    {
                        "username": "Swastik_Gorai",
                        "content": "Editorial supremacy!"
                    },
                    {
                        "username": "shoorveerrathour",
                        "content": "Leetcode is so naugty|"
                    },
                    {
                        "username": "rishinith",
                        "content": "This is a amazing explanation\nhttps://www.youtube.com/watch?v=fXZ5YGalS2w\n"
                    },
                    {
                        "username": "amshanaks313",
                        "content": "my streak: \"aaah shut here we go again.....\""
                    },
                    {
                        "username": "daring-calf",
                        "content": "I almost thought today was Saturday."
                    },
                    {
                        "username": "IlkinDigital",
                        "content": "Officially giving up my 100 day streak o7"
                    },
                    {
                        "username": "cecilia5",
                        "content": "For those who worry about the time spent computing the binomial coefficient. Try to work out the math for two layers manually, and watch out for opportunities to cancel."
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) It isn't particularly easy to describe without revealing, so I just leave the spoiler here:\n\nDenote the size of the subtrees be `leftSize` and `rightSize`, denote the count of the sequences of the subtrees be `leftCount` and `rightCount`, editorial implies:\n\nThe size of the tree is `treeSize = leftSize + rightSize + 1`, The count of sequence of the tree is `treeCount = C(leftCount + rightCount, leftCount) * leftCount * rightCount`.\n\nComputing binomial coefficients is just a hassle, can we do better? Yes - with this trick. The first step is the gem - the rest is just manipulations.\n\n```\nConsider treeCount/(treeSize!) \n= C(leftSize + rightSize, leftSize) * leftCount * rightCount.\n= C(treeSize - 1, leftSize) * leftCount * rightCount.\n= (treeSize - 1)! * leftCount * rightCount / (leftSize! * rightSize! * treeSize!)\n= (leftCount/leftSize!) * (rightCount/rightSize!) * 1/treeSize [See how the treeSize! and (treeSize - 1)! just cancels!]\n```\n\n> As an aside - whenever I read math stuff and I read the word `consider`. I start to cry. How on earth anyone come up with that expression to start considering. This one in particular, the intuition comes from I feel like the expressions are all multiplications and the factorials are all over the numerator and denominator, so it is only natural to hope they cancels.\n\nSo instead of computing the `treeCount` - we can compute the `treeFraction = treeCount/treeSize!` instead. Note that we also return the `treeSize`, so the `treeCount` can always be recovered. Now we have this much simpler recurrence:\n\n`treeFraction = leftFraction * rightFraction / treeSize`\n\nInstead of having to compute a binomial coefficient (pre-compute or otherwise), every internal node only need a multiplication and a division.\n\nEven better, instead of doing a division (in which you need modular inverse, a non-trivial operation), return the numerator and denominator as a tuple, those can be computed mod `1e9+7` - no need for big numbers.\n\nAll the way up, you will have `rootFraction`, recall that `rootFraction = rootCount/(rootSize!)`, but `rootSize` is obviously just `n`. So you simply multiply the `rootNumerator` by `n!` and then divide the `rootNumerator` by the `rootDenominator` using modular inverse only once, and you are done.\n\n> Spoting this opportunity is non-trivial, that's why I leave this hint about cancelation and hope people pick it up.\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@cecilia5](/cecilia5) By any chance isn\\'t [that](https://math.stackexchange.com/questions/666288/number-of-ways-to-interleave-two-ordered-sequences) what you\\'re talking about?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@psionl0](/psionl0) There exist a solution that allow you to not compute the binomial coefficients at all. [You still need to think about them, you just don\\'t need to compute them because they cancel each other]"
                    },
                    {
                        "username": "psionl0",
                        "content": "At every recursive level, you will need to do a combination calculation so Pascal\\'s triangle is more useful than trying to calculate the coefficients on the fly."
                    },
                    {
                        "username": "coder_pawn",
                        "content": "my daily streak ends here!"
                    }
                ]
            }
        ]
    }
]