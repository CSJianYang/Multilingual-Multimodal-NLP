[
    {
        "title": "Remove Covered Intervals",
        "question_content": "Given an array intervals where intervals[i] = [li, ri] represent the interval [li, ri), remove all intervals that are covered by another interval in the list.\nThe interval [a, b) is covered by the interval [c, d) if and only if c <= a and b <= d.\nReturn the number of remaining intervals.\n&nbsp;\nExample 1:\n\nInput: intervals = [[1,4],[3,6],[2,8]]\nOutput: 2\nExplanation: Interval [3,6] is covered by [2,8], therefore it is removed.\n\nExample 2:\n\nInput: intervals = [[1,4],[2,3]]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= intervals.length <= 1000\n\tintervals[i].length == 2\n\t0 <= li < ri <= 105\n\tAll the given intervals are unique.",
        "solutions": [
            {
                "id": 451277,
                "title": "java-c-python-sort-solution",
                "content": "# Intuition\\nImagine that, after removing all covered intervals,\\nall intervals must have different bounds,\\nAfter sorting, their left and right bound are increasing at the same time.\\n<br>\\n\\n# Test Case\\nHere are some useful small test cases for debugging.\\n`[[1,2],[1,3]]`\\n`[[1,3],[1,8],[5,8]]`\\n`[[1,6],[4,6],[4,8]]`\\n<br>\\n\\n# Solution 1, sort\\nSort the array, and note the previous `left` and `right` bound.\\nFor evert interval `v`,\\nif `v[0] > left && v[1] > right`,\\nIt\\'s a new uncovered interval,\\nso we increment `++res`.\\n\\nComplexity: time `O(sort)`, space `O(sort)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int removeCoveredIntervals(int[][] A) {\\n        int res = 0, left = -1, right = -1;\\n        Arrays.sort(A, (a, b) -> a[0] - b[0]);\\n        for (int[] v : A) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++res;\\n            }\\n            right = Math.max(right, v[1]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int removeCoveredIntervals(vector<vector<int>>& A) {\\n        int res = 0, left = -1, right = -1;\\n        sort(A.begin(), A.end());\\n        for (auto& v: A) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++res;\\n            }\\n            right = max(right, v[1]);\\n        }\\n        return res;\\n    }\\n```\\n\\n\\n# Solution 2, sort left ascending and right decending\\nIn this solution, we sort on left first.\\nWhen left are same, we sort right in decending order.\\n\\nFor example: [[1,5],[1,4],[1,3],[1,2]]\\n\\nComplexity: time `O(sort)`, space `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int removeCoveredIntervals2(int[][] A) {\\n        int res = 0, right = 0;\\n        Arrays.sort(A, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        for (int[] v : A) {\\n            if (v[1] > right) {\\n                ++res;\\n                right = v[1];\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```python\\n    def removeCoveredIntervals(self, A):\\n        res = right = 0\\n        A.sort(key=lambda a: (a[0], -a[1]))\\n        for i, j in A:\\n            res += j > right\\n            right = max(right, j)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int removeCoveredIntervals(int[][] A) {\\n        int res = 0, left = -1, right = -1;\\n        Arrays.sort(A, (a, b) -> a[0] - b[0]);\\n        for (int[] v : A) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++res;\\n            }\\n            right = Math.max(right, v[1]);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int removeCoveredIntervals(vector<vector<int>>& A) {\\n        int res = 0, left = -1, right = -1;\\n        sort(A.begin(), A.end());\\n        for (auto& v: A) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++res;\\n            }\\n            right = max(right, v[1]);\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int removeCoveredIntervals2(int[][] A) {\\n        int res = 0, right = 0;\\n        Arrays.sort(A, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        for (int[] v : A) {\\n            if (v[1] > right) {\\n                ++res;\\n                right = v[1];\\n            }\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def removeCoveredIntervals(self, A):\\n        res = right = 0\\n        A.sort(key=lambda a: (a[0], -a[1]))\\n        for i, j in A:\\n            res += j > right\\n            right = max(right, j)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 451284,
                "title": "java-python-3-simple-codes-w-explanation-and-analysis",
                "content": "**Sort intervals in such an order that only previous ones are possible to cover current one.**\\n1. Sort by the left bound, and when left bounds are equal, sort right bounds by reverse order; Therefore, **no interval can cover previous ones**;\\n2. Loop through the `intervals`, whenever current right most bound <  next interval\\'s right bound, it means current interval can NOT cover next interval, update right most bound and increase counter by 1.\\n \\n```java\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (i, j) -> (i[0] == j[0] ? j[1] - i[1] : i[0] - j[0]));\\n        int count = 0, cur = 0;\\n        for (int[] a : intervals) {\\n            if (cur < a[1]) {\\n                cur = a[1];\\n                ++count;\\n            }\\n        }\\n        return count;        \\n    }\\n```\\n```python\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        count = cur = 0\\n        for _, r in sorted(intervals, key=lambda i: (i[0], -i[1])):\\n            if cur < r:\\n                cur = r\\n                count += 1\\n        return count\\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(1)` - excluding sorting space, where `n` = `intervals.length`.",
                "solutionTags": [],
                "code": "```java\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (i, j) -> (i[0] == j[0] ? j[1] - i[1] : i[0] - j[0]));\\n        int count = 0, cur = 0;\\n        for (int[] a : intervals) {\\n            if (cur < a[1]) {\\n                cur = a[1];\\n                ++count;\\n            }\\n        }\\n        return count;        \\n    }\\n```\n```python\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        count = cur = 0\\n        for _, r in sorted(intervals, key=lambda i: (i[0], -i[1])):\\n            if cur < r:\\n                cur = r\\n                count += 1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1784527,
                "title": "c-easy-to-understand-sorting-short-simple",
                "content": "# 1288. Remove Covered Intervals\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Approach using simple sorting & comparison with previous element\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star the repository\\uD83D\\uDE09 \\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**EXPLANATION**\\n\\n```\\n1.The interval [a, b) is covered by the interval [c, d) if and only if c <= a and b <= d.\\n\\teg Interval [3,6] is covered by [2,8], therefore it should be removed.\\n\\t\\n\\tLet see the Number line :)\\n\\t\\n\\t                                           1  2  3  4  5  6  7  8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1-------4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         3--------6\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  2-----------------8\\n\\tclearly we can see that [3 6] is covered by [2,8] and therefore it should be removed.\\n\\n2. We will Sort the vector in ascending order to get this type of arrangement.\\n\\t\\t//e.g. (1,5), (1,8), (2,9), (3,5), (4,7), (4,9)\\n\\t\\t\\n3. For finding the remaining interaval, ifa[1][0] && a[1][1] both greater than a[0][0] && a[0][1],\\nthis means the previous interval is not covered by the next one, therefore we will increase the count.\\n\\t\\t\\tconsider the case [[1,3],[2,4],[4,8]]\\n\\t\\t\\t\\t\\t\\t\\t\\t1   2  3  4  5  6  7  8\\n\\t\\t\\t\\t\\t\\t\\t\\t1------3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t2-----4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      4-----------8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\tNo interval is completely overlaped by other therefore remainig interaval are 3.\\n\\t\\t\\t\\n\\t\\t\\thow answer is 3 , at first cnt is initialised to 1\\n\\t\\t\\tnow a[0,0] i.e 1 and a[1,0] i.e 2   1 < 2 also,\\n\\t\\t\\t    a[0,1] i.e 3 and a[1,1] i.e 4   3 < 4    , therefore cnt is incremented by 2 now,\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\talso a[2,0] and a[2,1] satisy same condition with a[1,0] and a[1,1] , cnt becomes 3\\n```\\n\\n**Time Complexity: O(n logn)\\nSpace Complexity: O(1)**\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        // sorting the intervals(vector)\\n        sort(intervals.begin(),intervals.end());        \\n           \\n        int x1 = intervals[0][0];\\n        int x2 = intervals[0][1];\\n        \\n\\t\\t int res = 1;  //one for x1 and x2;\\n\\t\\t\\n\\t\\t// ifa[i][0] && a[i][1] both greater than a[i-1][0] && a[i-1][1]\\n\\t\\t// increase the cnt.\\n        for(int i= 1; i<intervals.size(); ++i)\\n        {\\n            if(intervals[i][0] > x1 && intervals[i][1] > x2)\\n                ++res;\\n            \\n\\t\\t\\t// updating x1 & x2 with next intervals\\n\\t\\t\\tas we are comparing from upcoming ones.\\n            if(intervals[i][1] > x2)\\n            {\\n                x1 = intervals[i][0];\\n                x2 = intervals [i][1];\\n            }\\n        }\\n        \\n        return res;       // return cnt\\n    }\\n\\n}; \\n   \\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Approach using simple sorting & comparison with previous element\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star the repository\\uD83D\\uDE09 \\n```\n```\\n1.The interval [a, b) is covered by the interval [c, d) if and only if c <= a and b <= d.\\n\\teg Interval [3,6] is covered by [2,8], therefore it should be removed.\\n\\t\\n\\tLet see the Number line :)\\n\\t\\n\\t                                           1  2  3  4  5  6  7  8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   1-------4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t         3--------6\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  2-----------------8\\n\\tclearly we can see that [3 6] is covered by [2,8] and therefore it should be removed.\\n\\n2. We will Sort the vector in ascending order to get this type of arrangement.\\n\\t\\t//e.g. (1,5), (1,8), (2,9), (3,5), (4,7), (4,9)\\n\\t\\t\\n3. For finding the remaining interaval, ifa[1][0] && a[1][1] both greater than a[0][0] && a[0][1],\\nthis means the previous interval is not covered by the next one, therefore we will increase the count.\\n\\t\\t\\tconsider the case [[1,3],[2,4],[4,8]]\\n\\t\\t\\t\\t\\t\\t\\t\\t1   2  3  4  5  6  7  8\\n\\t\\t\\t\\t\\t\\t\\t\\t1------3\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t2-----4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t      4-----------8\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\tNo interval is completely overlaped by other therefore remainig interaval are 3.\\n\\t\\t\\t\\n\\t\\t\\thow answer is 3 , at first cnt is initialised to 1\\n\\t\\t\\tnow a[0,0] i.e 1 and a[1,0] i.e 2   1 < 2 also,\\n\\t\\t\\t    a[0,1] i.e 3 and a[1,1] i.e 4   3 < 4    , therefore cnt is incremented by 2 now,\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\talso a[2,0] and a[2,1] satisy same condition with a[1,0] and a[1,1] , cnt becomes 3\\n```\n```\\n\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        // sorting the intervals(vector)\\n        sort(intervals.begin(),intervals.end());        \\n           \\n        int x1 = intervals[0][0];\\n        int x2 = intervals[0][1];\\n        \\n\\t\\t int res = 1;  //one for x1 and x2;\\n\\t\\t\\n\\t\\t// ifa[i][0] && a[i][1] both greater than a[i-1][0] && a[i-1][1]\\n\\t\\t// increase the cnt.\\n        for(int i= 1; i<intervals.size(); ++i)\\n        {\\n            if(intervals[i][0] > x1 && intervals[i][1] > x2)\\n                ++res;\\n            \\n\\t\\t\\t// updating x1 & x2 with next intervals\\n\\t\\t\\tas we are comparing from upcoming ones.\\n            if(intervals[i][1] > x2)\\n            {\\n                x1 = intervals[i][0];\\n                x2 = intervals [i][1];\\n            }\\n        }\\n        \\n        return res;       // return cnt\\n    }\\n\\n}; \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784520,
                "title": "python3-sorting-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nAs for almost all problems related to intervals, we have to sort them first by the starting position. The next problem is how to define whether an interval is covered? After the sorting, we know that the start of every subsequent interval is greater or equal to all previous interval starts but we can\\'t say the same about ends. \\nFirst of all, we don\\'t need to remember the end positions of all previous intervals, and only keep track of the longest interval seen before. If the end of the current interval lies in the range of some long previous interval that means it is covered. Second of all, we need to handle an edge case when the starts of some intervals are the same and the trick with the longest interval won\\'t work. For example, there are might be a case like this `[[1,2],[1,4],[3,4]]`:\\n```\\n__\\n____\\n   ____\\n```\\nFor that we can make sure that in case of a tie, the sorting function puts a longer interval in the first place:\\n```\\n____\\n__\\n   ____\\n```\\n\\n*For reference: https://www.programiz.com/python-programming/methods/built-in/sorted*\\n\\nTime: **O(Nlog(N))** - sorting\\nSpace: **O(N)** - sorting\\n\\nRuntime: 100 ms, faster than **78.70%** of Python3 online submissions for Remove Covered Intervals.\\nMemory Usage: 14.5 MB, less than **86.23%** of Python3 online submissions for Remove Covered Intervals.\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        res, longest = len(intervals), 0\\n        srtd = sorted(intervals, key = lambda i: (i[0], -i[1]))\\n        \\n        for _, end in srtd:\\n            if end <= longest:\\n                res -= 1\\n            else:\\n                longest = end\\n                \\n        return res\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n__\\n____\\n   ____\\n```\n```\\n____\\n__\\n   ____\\n```\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        res, longest = len(intervals), 0\\n        srtd = sorted(intervals, key = lambda i: (i[0], -i[1]))\\n        \\n        for _, end in srtd:\\n            if end <= longest:\\n                res -= 1\\n            else:\\n                longest = end\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878251,
                "title": "java-python-sorting-clean-concise-o-nlogn",
                "content": "**Idea**\\n- Sort `intervals` by increasing of `startTime` and decreasing of `endTime`\\n- `last = -1`: `last` is the farest end time of browsed `intervals`\\n- For each `interval` in `intervals`\\n\\t- If `interval.endTime <= last`, means `interval` is overlapped then we count `removed`\\n\\t- else `last = interval.endTime`\\n- `Result` = `number of intervals` - `removed`\\n\\n**Complexity**\\n- Time: `O(NlogN)`\\n- Space: `O(1)`\\n\\n**Python**\\n```python\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort(key = lambda x:(x[0], -x[1]))\\n        last = -1\\n        removed = 0\\n        for i in intervals:\\n            if i[1] <= last:\\n                removed += 1\\n            else:\\n                last = i[1]\\n        return len(intervals) - removed\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int removed = 0, last = -1;\\n        Arrays.sort(intervals, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        for (int[] i : intervals) {\\n            if (i[1] <= last) {\\n                removed += 1;\\n            } else {\\n                last = i[1];\\n            }\\n        }\\n        return intervals.length - removed;\\n    }\\n}\\n```\\n\\nFeel free to ask your question in the comments, help to **vote** if this post is useful to you.",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort(key = lambda x:(x[0], -x[1]))\\n        last = -1\\n        removed = 0\\n        for i in intervals:\\n            if i[1] <= last:\\n                removed += 1\\n            else:\\n                last = i[1]\\n        return len(intervals) - removed\\n```\n```java\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int removed = 0, last = -1;\\n        Arrays.sort(intervals, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        for (int[] i : intervals) {\\n            if (i[1] <= last) {\\n                removed += 1;\\n            } else {\\n                last = i[1];\\n            }\\n        }\\n        return intervals.length - removed;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878505,
                "title": "python-sort-starts-in-o-n-log-n-explained",
                "content": "Let us sort our intervals by their starts and traverse them one by one (if we have the same ends, we first choose intervals with smaller ends, so they will be traversed first) Also let us keep `right` variable, which will be the biggest right end of interval so far. So, what does it mean that one interval is covered by some other? It means that `end <= right`: we have some previous interval with end more than current end and start which is less than current interval.\\n\\n**Complexity**: for time complexity we sort intervals in `O(n log n)` and then traverse them in `O(n)`. Space complexity is `O(n)` if we are not allowed to change `intervals` and `O(log n)` we are allowed to modify `intervals`.\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        right, rem, n = -1, 0, len(intervals)\\n        for _, end in intervals:\\n            if end <= right:\\n                rem += 1\\n            else:\\n                right = end\\n        return n - rem\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        right, rem, n = -1, 0, len(intervals)\\n        for _, end in intervals:\\n            if end <= right:\\n                rem += 1\\n            else:\\n                right = end\\n        return n - rem\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878981,
                "title": "c-sort-with-brief-explanation-o-nlogn-runtime-o-1-memory",
                "content": "**Brief Explanation**\\n* Sort intervals in the following manner:\\n  1. If start times are different, then interval having lesser start time will come first.\\n  2. If start times are same, then interval having higher end time will come first.\\n  \\n  *e.g.* [[3,5], [1,2], [9,11], [4,6], [4,8]] is *sorted* as [[1,2], [3,5], [4,8], [4,6], [9,11]]\\n  **2nd** condition ensures that the ***covered interval always comes after covering interval***.\\n\\n* Simply iterate over sorted intervals and keep track of maximum end time seen.\\n* While iterating, if some interval has end time less than or equal to maximum end time seen, then that is a covered interval.\\n**Why?** Because, we already know that start time of previous interval will be either before or equal to the start time of current interval.\\n* Exclude all the **covered intervals** and return the number of remaining intervals.\\n\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const auto& x, const auto& y){\\n            return x[0] != y[0] ? x[0] < y[0] : x[1] > y[1];\\n        });\\n        int covered_intervals = 0, maximum_end = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][1] <= maximum_end) {\\n                covered_intervals++;\\n            }\\n            maximum_end = max(maximum_end, intervals[i][1]);\\n        }\\n        return intervals.size() - covered_intervals;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](const auto& x, const auto& y){\\n            return x[0] != y[0] ? x[0] < y[0] : x[1] > y[1];\\n        });\\n        int covered_intervals = 0, maximum_end = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][1] <= maximum_end) {\\n                covered_intervals++;\\n            }\\n            maximum_end = max(maximum_end, intervals[i][1]);\\n        }\\n        return intervals.size() - covered_intervals;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785080,
                "title": "c-detailed-explanation-w-image-dry-run-sorting",
                "content": "***Brief note about Question-***\\n* We have to *remove all intervals that are covered by another interval in the array.*\\n```\\nLet\\'s take an example not given in question -\\nSuppose our array given to us is arr[]: [[1,3],[2,5],[3,4]]\\n\\nSo, the answer should be 2.\\nBecause interval [3,4] is the interval which is covered by interval [2,5], so that interval is neglected and\\nremaining two interval are included in our answer.\\n```\\n_______________\\n***Why Sorting ?***\\n* I am not going to say it always happen, but till now whenever i have solved problems based on interval, then **problem becomes more easy to solve if we will sort it**.\\n* You may ask, **why sorting?** Mabybe their is a way to solve problem without sorting, but after doing sorting, we are gonna confirm from either one side, that yess, now I arranged intervals either in ascending or desecnding order.\\n* **Sorting also helps us in traversing the array**.\\n___________\\n***How we will Implement-***\\n* Firstly, we have to **sort the array in ascending order**.\\n* After sorting, we know that **all intervals are arranged according to their start time**.\\n* Now, we maintain two variables, named as `maximum_left` and `maximum_right`.\\n* Intially, both the variables are intiliazed with value as `-1`.\\n* We start traversing the array and if we find a condition `arr[i][0] > maximum_left && arr[i][1] > maximum_right`, we will increment our answer saying that this could never be a part of anthor interval.\\n* If this so happen, then at that point we will update our maximum_left variable.\\n* Also, maximum right variable will be updated with `max(maximum_right, arr[i][1])` where `arr[i][1`] is the ending time of the interval.\\n* And lastly, we will simply return our answer.\\n* See below example for more clarification.\\n___________________\\n***Taking an example-***\\n* Suppose an array is given to us as arr[]: [[5,9],[2,5],[3,4],[1,3],[6,8]]\\n* So, after sorting it array looks like  arr[]: **[[1,3],[2,5],[3,4],[5,9],[6,8]]**\\n* ![image](https://assets.leetcode.com/users/images/5dca59a2-cc85-49ee-b073-2730bef2faa3_1645331383.9049485.jpeg)\\n\\n* I will dry run an example, hope that u got it.\\n__________________________\\n***Solution - I (Accepted)-***\\n```\\nTime Complexity --> O(n * log(n)) // as we are using sorting, and n is the size of the array \\nSpace Complexity --> O(1) \\n\\nIt paases [ 34 /  34] in built test cases\\n```\\n_______\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        sort(arr.begin(), arr.end()); // sort the array\\n        \\n        int maximum_left = -1, maximum_right = -1; // declaring variables\\n        \\n        int ans = 0; // conatains our answer\\n        \\n        for(int i = 0; i < n; i++) // start traversing the array\\n        {\\n            // check condition\\n            if(arr[i][0] > maximum_left && arr[i][1] > maximum_right)\\n            {\\n                ans++; // increment answer\\n                maximum_left = arr[i][0];  // update maximum left\\n            }\\n            maximum_right = max(maximum_right, arr[i][1]); // update maximum right\\n        }\\n        \\n        return ans; // lastly return answer\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our array given to us is arr[]: [[1,3],[2,5],[3,4]]\\n\\nSo, the answer should be 2.\\nBecause interval [3,4] is the interval which is covered by interval [2,5], so that interval is neglected and\\nremaining two interval are included in our answer.\\n```\n```\\nTime Complexity --> O(n * log(n)) // as we are using sorting, and n is the size of the array \\nSpace Complexity --> O(1) \\n\\nIt paases [ 34 /  34] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        sort(arr.begin(), arr.end()); // sort the array\\n        \\n        int maximum_left = -1, maximum_right = -1; // declaring variables\\n        \\n        int ans = 0; // conatains our answer\\n        \\n        for(int i = 0; i < n; i++) // start traversing the array\\n        {\\n            // check condition\\n            if(arr[i][0] > maximum_left && arr[i][1] > maximum_right)\\n            {\\n                ans++; // increment answer\\n                maximum_left = arr[i][0];  // update maximum left\\n            }\\n            maximum_right = max(maximum_right, arr[i][1]); // update maximum right\\n        }\\n        \\n        return ans; // lastly return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878152,
                "title": "remove-covered-intervals-with-explanation-c-beats-100",
                "content": "We simply count the overlapping intervals and thus the answer is `intervals.size()` - `number of overlapping intervals`\\n\\n##### Crux:\\n* We need to sort intervals by their start time, **ascending**. The first starting interval needs to be checked previously.\\n* If two intervals\\' start times are equal, then the interval with the **greater** finishing time needs to be placed before the other one.\\n\\n#####  Solution:\\n* Sort intervals\\n* Declare a variable `end`  to hold the latest covered interval.\\n* If any interval i\\'s finish time is less than `end` then i is overlapping, thus it needs to be removed.\\n\\n#### C++\\n\\n```\\n\\tint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), \\n             [] (const vector<int>& v1, const vector<int>& v2) { \\n                 if(v1[0] != v2[0]) return v1[0] < v2[0];\\n                 else return v1[1] > v2[1];\\n        });\\n        \\n        int ans = intervals.size(), end = INT_MIN;\\n        \\n        for(int i = 0; i < intervals.size(); i++) {\\n\\t\\t\\t// If the current intervals end previously than the latest checkpoint\\n\\t\\t\\t// Then it\\'s overlapping, so decrease answer.\\n            if(intervals[i][1] <= end) --ans; \\n\\t\\t\\t\\n\\t\\t\\t// Otherwise, make this intervals finishing time the latest.\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n\\n##### Time Complexity: `O(n logn)` \\n##### Space Complexity: `O(1)`",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), \\n             [] (const vector<int>& v1, const vector<int>& v2) { \\n                 if(v1[0] != v2[0]) return v1[0] < v2[0];\\n                 else return v1[1] > v2[1];\\n        });\\n        \\n        int ans = intervals.size(), end = INT_MIN;\\n        \\n        for(int i = 0; i < intervals.size(); i++) {\\n\\t\\t\\t// If the current intervals end previously than the latest checkpoint\\n\\t\\t\\t// Then it\\'s overlapping, so decrease answer.\\n            if(intervals[i][1] <= end) --ans; \\n\\t\\t\\t\\n\\t\\t\\t// Otherwise, make this intervals finishing time the latest.\\n            else end = intervals[i][1];\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878478,
                "title": "python-simple-solution-explained-video-code-fastest",
                "content": "[](https://www.youtube.com/watch?v=emPnw5m2nN0)\\nhttps://www.youtube.com/watch?v=emPnw5m2nN0\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals, key = lambda x : (x[0], -x[1]))\\n        \\n        res = 0\\n        ending = 0\\n        \\n        for _, end in intervals:\\n            if end > ending:\\n                res += 1\\n                ending = end\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals, key = lambda x : (x[0], -x[1]))\\n        \\n        res = 0\\n        ending = 0\\n        \\n        for _, end in intervals:\\n            if end > ending:\\n                res += 1\\n                ending = end\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878287,
                "title": "c-simple-solution-using-sort-beats-96-in-time-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b){\\n        if (a[0] != b[0]){\\n            return a[0] < b[0];\\n        }else{\\n            return a[1] > b[1];\\n        }\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // - Sort the intervals in increasing order of starting point\\n        // - If starting points are same, in decreasing order of ending point\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int _max = INT_MIN;\\n        int count = 0;\\n        \\n        // - Compare the ending points in the sorted intervals\\n\\t\\t\\n        // - If at any index the ending point is less than the current maximum ending point\\n        //   that interval is the included one \\n\\t\\t//   (remember the starting point of the current is already greater than that\\n\\t\\t//   of all the previous intervals, so now when the ending point is lesser than the current max ending point\\n\\t\\t//   it means that interval is included in atleast one of the previous intervals)\\n\\t\\t\\n        // - Count the included ones and return size()-count\\n\\t\\t\\n\\t\\t// Note: If the starting index are equal, we sorted according to decreasing ending index so that it can be\\n\\t\\t// counted too as an included one\\n\\t\\t\\n        for (int i = 0; i<intervals.size(); i++){\\n            if (intervals[i][1] <= _max){\\n                count ++;\\n            }else{\\n                _max = intervals[i][1];\\n            }\\n        }\\n        return intervals.size()-count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>& a, vector<int>& b){\\n        if (a[0] != b[0]){\\n            return a[0] < b[0];\\n        }else{\\n            return a[1] > b[1];\\n        }\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // - Sort the intervals in increasing order of starting point\\n        // - If starting points are same, in decreasing order of ending point\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        int _max = INT_MIN;\\n        int count = 0;\\n        \\n        // - Compare the ending points in the sorted intervals\\n\\t\\t\\n        // - If at any index the ending point is less than the current maximum ending point\\n        //   that interval is the included one \\n\\t\\t//   (remember the starting point of the current is already greater than that\\n\\t\\t//   of all the previous intervals, so now when the ending point is lesser than the current max ending point\\n\\t\\t//   it means that interval is included in atleast one of the previous intervals)\\n\\t\\t\\n        // - Count the included ones and return size()-count\\n\\t\\t\\n\\t\\t// Note: If the starting index are equal, we sorted according to decreasing ending index so that it can be\\n\\t\\t// counted too as an included one\\n\\t\\t\\n        for (int i = 0; i<intervals.size(); i++){\\n            if (intervals[i][1] <= _max){\\n                count ++;\\n            }else{\\n                _max = intervals[i][1];\\n            }\\n        }\\n        return intervals.size()-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784874,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n*logn*)**\\n**Java**\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]));\\n        int count = 0, cur = 0;\\n        for(int interval[] : intervals){\\n            if(cur < interval[1]){\\n                cur = interval[1];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]))\\n    let count = 0, cur = 0\\n    for(let interval of intervals){\\n        if(cur < interval[1]){\\n            cur = interval[1]\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        count = cur = 0\\n        for _, i in sorted(intervals, key = lambda a: (a[0], -a[1])):\\n            if(cur < i):\\n                cur = i\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) -> (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]));\\n        int count = 0, cur = 0;\\n        for(int interval[] : intervals){\\n            if(cur < interval[1]){\\n                cur = interval[1];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]))\\n    let count = 0, cur = 0\\n    for(let interval of intervals){\\n        if(cur < interval[1]){\\n            cur = interval[1]\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```\n```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        count = cur = 0\\n        for _, i in sorted(intervals, key = lambda a: (a[0], -a[1])):\\n            if(cur < i):\\n                cur = i\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785636,
                "title": "c-greedy-algorithm-easy-short-simple-clean",
                "content": "Use greedy approach to sort and then merge the intervals, compare the previous interval with the next interval and overlap.\\nSimilar to **Merge intervals** question.\\n\\n```class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        pair<int,int> curr;\\n        int c=1;\\n        curr.first=intervals[0][0];\\n        curr.second=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if((curr.first<=intervals[i][0] && curr.second>=intervals[i][1]) || (curr.first>=intervals[i][0] && curr.second<=intervals[i][1])){\\n           curr.first=min(curr.first,intervals[i][0]);\\n             curr.second=max(curr.second,intervals[i][1]);   \\n            }else{\\n                c++;\\n                curr.first=intervals[i][0];\\n                curr.second=intervals[i][1];\\n            }\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        pair<int,int> curr;\\n        int c=1;\\n        curr.first=intervals[0][0];\\n        curr.second=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if((curr.first<=intervals[i][0] && curr.second>=intervals[i][1]) || (curr.first>=intervals[i][0] && curr.second<=intervals[i][1])){\\n           curr.first=min(curr.first,intervals[i][0]);\\n             curr.second=max(curr.second,intervals[i][1]);   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 878605,
                "title": "java-nothing-fancy",
                "content": "```\\n\\t\\tArrays.sort(intervals,(a,b)->{\\n            return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\\n        });\\n        \\n        int max = intervals[0][1];\\n        int ans = 1;\\n        \\n        for(int[] interval : intervals){\\n            if(interval[1] > max){\\n                ans++;\\n                max = interval[1];\\n            }\\n        }\\n        \\n        return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tArrays.sort(intervals,(a,b)->{\\n            return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];\\n        });\\n        \\n        int max = intervals[0][1];\\n        int ans = 1;\\n        \\n        for(int[] interval : intervals){\\n            if(interval[1] > max){\\n                ans++;\\n                max = interval[1];\\n            }\\n        }\\n        \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451420,
                "title": "c-o-nlogn-n-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n   //[[1,2],[3,4],[5,9],[5,7],[5,6],[6,9]]\\n   //[[1,6], [1,4]]\\n    \\n\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        auto thisway = [&](vector<int> a , vector<int> b){\\n            return (a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\\n        };\\n        sort(intervals.begin() , intervals.end(), thisway);\\n        vector<int> cur = intervals[0];\\n        int total = n;\\n        for(int i = 1; i < n; ++i){             // first we are sorting by left of the each interval in increasing order and \\n            if(cur[1] >= intervals[i][1]){      // if equal lefts are there then by right in decreasing order\\n                --total;                        // then we are basically initially choosing a interval and then checking how many further\\n            }                                   // interval are its subsets otherwise take this new interval as we have already sorted \\n            else{                               // by first element so it means either this interval that we are checking is\\n                cur = intervals[i];             // has range outside our tillnow choosen interval \\n            }                                   // so we decide to update our choosen interval to this one.\\n        }                                       // then same goes on... \\n        return total;                           // [[2,4],[2,3],[3,6],[3,4],[3,3][4,9],[4,3]]   \\n    }                                           // [[6,9],[6,8],[6,7],[7,8],[9,14],[9,13],[10,12],[12,15]]\\n\\n};                                              \\n                                                \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   //[[1,2],[3,4],[5,9],[5,7],[5,6],[6,9]]\\n   //[[1,6], [1,4]]\\n    \\n\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        auto thisway = [&](vector<int> a , vector<int> b){\\n            return (a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]));\\n        };\\n        sort(intervals.begin() , intervals.end(), thisway);\\n        vector<int> cur = intervals[0];\\n        int total = n;\\n        for(int i = 1; i < n; ++i){             // first we are sorting by left of the each interval in increasing order and \\n            if(cur[1] >= intervals[i][1]){      // if equal lefts are there then by right in decreasing order\\n                --total;                        // then we are basically initially choosing a interval and then checking how many further\\n            }                                   // interval are its subsets otherwise take this new interval as we have already sorted \\n            else{                               // by first element so it means either this interval that we are checking is\\n                cur = intervals[i];             // has range outside our tillnow choosen interval \\n            }                                   // so we decide to update our choosen interval to this one.\\n        }                                       // then same goes on... \\n        return total;                           // [[2,4],[2,3],[3,6],[3,4],[3,3][4,9],[4,3]]   \\n    }                                           // [[6,9],[6,8],[6,7],[7,8],[9,14],[9,13],[10,12],[12,15]]\\n\\n};                                              \\n                                                \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785047,
                "title": "python-simple-python-solution-by-sorting-the-list",
                "content": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n\\n\\t\\t\\tintervals=sorted(intervals)\\n\\n\\t\\t\\ti=0\\n\\t\\t\\twhile i<len(intervals)-1:\\n\\n\\t\\t\\t\\t\\ta,b = intervals[i]\\n\\t\\t\\t\\t\\tp,q = intervals[i+1]\\n\\n\\t\\t\\t\\t\\tif a <= p and q <= b:\\n\\t\\t\\t\\t\\t\\tintervals.remove(intervals[i+1])\\n\\t\\t\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\t\\t\\telif p <= a and b <= q:\\n\\t\\t\\t\\t\\t\\tintervals.remove(intervals[i])\\n\\t\\t\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\t\\t\\ti=i+1\\n\\t\\t\\treturn len(intervals)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n\\n\\t\\t\\tintervals=sorted(intervals)\\n\\n\\t\\t\\ti=0\\n\\t\\t\\twhile i<len(intervals)-1:\\n\\n\\t\\t\\t\\t\\ta,b = intervals[i]\\n\\t\\t\\t\\t\\tp,q = intervals[i+1]\\n\\n\\t\\t\\t\\t\\tif a <= p and q <= b:\\n\\t\\t\\t\\t\\t\\tintervals.remove(intervals[i+1])\\n\\t\\t\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\t\\t\\telif p <= a and b <= q:\\n\\t\\t\\t\\t\\t\\tintervals.remove(intervals[i])\\n\\t\\t\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\t\\t\\ti=i+1\\n\\t\\t\\treturn len(intervals)\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1786515,
                "title": "easy-c-sol-sorting-o-nlogn",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        int res = 0,left = -1, right = -1;\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        for(auto v: intervals){\\n            if(v[0] > left && v[1] > right){\\n                left = v[0];\\n                res++;\\n            }\\n            right = max(right, v[1]);\\n            \\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        int res = 0,left = -1, right = -1;\\n        \\n        sort(intervals.begin(),intervals.end());\\n        \\n        for(auto v: intervals){\\n            if(v[0] > left && v[1] > right){\\n                left = v[0];\\n                res++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1786421,
                "title": "javascript-simple-solution-with-explanation",
                "content": "It helps to boil this problem down to essencials.\\n\\nFirst, you have an array of elements with could have overlapping sub-elements.\\n\\nIf a sub-element is completely contained by another, it can be skipped.\\n\\nThe key to this problem is to begin sorting the elements, first by left index, and if the same, by right index.\\n\\nIf they are sorted in this way, u know that you can iterate though every element, and the next will have to have the same or greater than start array value, and so you simply want to check if its end index is less than the prev.  If so, u can add it to the overlap count, if not, update the prev index to current for the next interation.\\n\\nCredit to Deadication for helping to simplify my understanding of the problem.\\n\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n  intervals.sort((a,b)=> a[0]-b[0] || b[1]-a[1]);\\n  let overlap=0;\\n  for (i=1,prev=0; i<intervals.length; i++)\\n//    if ((intervals[prev][0] <= intervals[i][0]) //no need to check, already done in sort\\n//      && (intervals[prev][1] >= intervals[i][1]))\\n\\tif (intervals[prev][1] >= intervals[i][1]) // just look at 2nd index\\n      overlap++  // add to skipped elements\\n    else\\n      prev=i; // didn\\'t overlap, so we can advance our previous element\\n  return intervals.length-overlap;\\n};\\n```\\n\\nIf this explanation helped you, please upvote so others might notice it as well.  Thanks!",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeCoveredIntervals = function(intervals) {\\n  intervals.sort((a,b)=> a[0]-b[0] || b[1]-a[1]);\\n  let overlap=0;\\n  for (i=1,prev=0; i<intervals.length; i++)\\n//    if ((intervals[prev][0] <= intervals[i][0]) //no need to check, already done in sort\\n//      && (intervals[prev][1] >= intervals[i][1]))\\n\\tif (intervals[prev][1] >= intervals[i][1]) // just look at 2nd index\\n      overlap++  // add to skipped elements\\n    else\\n      prev=i; // didn\\'t overlap, so we can advance our previous element\\n  return intervals.length-overlap;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878391,
                "title": "java-clean-code-no-sort-fast-than-100",
                "content": "* **Please upvote if helpful!!**\\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\n        int count = 0;\\n        for (int i = 0; i < intervals.length; i++) {\\n\\n            int a = intervals[i][0];\\n            int b = intervals[i][1];\\n\\n            for (int j = 0; j < intervals.length; j++) {\\n\\n                int c = intervals[j][0];\\n                int d = intervals[j][1];\\n\\n                if (i != j && c <= a && b <= d) {\\n                    count++;\\n                    break;  // important step.!!\\n                    //interval[c,d) is the inner loop. as we found out Interval [a,b) (outer loop)\\n                    // is covered by interval [c,d).\\n                    //we need to break the inner loop and check the next [a,b).\\n                }\\n\\n            }\\n        }\\n\\n        return intervals.length - count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\n        int count = 0;\\n        for (int i = 0; i < intervals.length; i++) {\\n\\n            int a = intervals[i][0];\\n            int b = intervals[i][1];\\n\\n            for (int j = 0; j < intervals.length; j++) {\\n\\n                int c = intervals[j][0];\\n                int d = intervals[j][1];\\n\\n                if (i != j && c <= a && b <= d) {\\n                    count++;\\n                    break;  // important step.!!\\n                    //interval[c,d) is the inner loop. as we found out Interval [a,b) (outer loop)\\n                    // is covered by interval [c,d).\\n                    //we need to break the inner loop and check the next [a,b).\\n                }\\n\\n            }\\n        }\\n\\n        return intervals.length - count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451250,
                "title": "java-simple-sort",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        Arrays.sort(intervals, new Comparator<int[]>(){\\n            public int compare(int[] e1, int[] e2){\\n                if(e1[0] < e2[0]) return -1;\\n                if(e2[0] < e1[0]) return 1;\\n                if(e1[1] > e2[1]) return -1;\\n                return 1;\\n            }\\n        });\\n        \\n        int count = 1;\\n        int[] prev = intervals[0];\\n        for(int i = 1; i < n; i++){\\n            if(intervals[i][0] >= prev[0] && intervals[i][1] <= prev[1]) continue;\\n            prev = intervals[i];\\n            count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        Arrays.sort(intervals, new Comparator<int[]>(){\\n            public int compare(int[] e1, int[] e2){\\n                if(e1[0] < e2[0]) return -1;\\n                if(e2[0] < e1[0]) return 1;\\n                if(e1[1] > e2[1]) return -1;\\n                return 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1786713,
                "title": "easy-c-solution-using-sorting-and-constant-extra-space",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019ll sort the array first.\\n- Take 2 variables to keep the current interval as *l & r*. Initialize them with -1.\\n- Now iterate over all the elements and we have to find the intervals, for every interval we\\u2019ll increase the count as we\\u2019re adding one interval.\\n- Check this 2 conditions **`intervals[i][0] > l` & `intervals[i][1] > r`,** if both satisfied then replace the l with first element of the current vector as it indicates the starting index.\\n- Increase the count & after every loop update r as the ending point can be change in every iteration.\\n- **Time complexity:** O(nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size(), count=0, l=-1, r=-1;\\n        sort(intervals.begin(), intervals.end());\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            if(intervals[i][0] > l && intervals[i][1] > r){\\n                l = intervals[i][0];\\n                count++;\\n            }\\n            r = max(r, intervals[i][1]);\\n        }\\n        return count;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size(), count=0, l=-1, r=-1;\\n        sort(intervals.begin(), intervals.end());\\n        \\n        \\n        for(int i=0; i<n; i++){\\n            if(intervals[i][0] > l && intervals[i][1] > r){\\n                l = intervals[i][0];\\n                count++;\\n            }\\n            r = max(r, intervals[i][1]);\\n        }\\n        return count;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879665,
                "title": "python-faster-than-99-using-dict",
                "content": "The idea is to keep a track of the highest ending time for every starting time and storing it as a key.\\nEx - [[1,2],[1,4],[2,6]]\\nwe would store : {1:4 , 2:6}\\nWe only need the max ones becuase the ones lesser than that will be included in the highest one anyway.\\n\\nLike in our example, [1,2] is in [1,4] that\\'s why we don\\'t need it.\\n\\nthen we just use the dictionary to find out any other matching intervals and return ans.\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        d=dict()   \\n        high=-1\\n        ans=0\\n        totalIntervals = len(intervals)\\n\\t\\t\\n        for i in range(len(intervals)):\\n            if intervals[i][0] in d.keys():\\n                if d[intervals[i][0]]< intervals[i][1]:\\n                    d[intervals[i][0]] = intervals[i][1]\\n            else:\\n                d[intervals[i][0]]  = intervals[i][1]\\n        for i in sorted(d):\\n            if d[i] > high:\\n                high = d[i]\\n                ans+=1\\n        return ans\\n            \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        d=dict()   \\n        high=-1\\n        ans=0\\n        totalIntervals = len(intervals)\\n\\t\\t\\n        for i in range(len(intervals)):\\n            if intervals[i][0] in d.keys():\\n                if d[intervals[i][0]]< intervals[i][1]:\\n                    d[intervals[i][0]] = intervals[i][1]\\n            else:\\n                d[intervals[i][0]]  = intervals[i][1]\\n        for i in sorted(d):\\n            if d[i] > high:\\n                high = d[i]\\n                ans+=1\\n        return ans\\n            \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 878528,
                "title": "c-sort-by-ascending-start-and-descending-end-and-count-intervals-that-are-not-covered",
                "content": "```csharp\\npublic int RemoveCoveredIntervals(int[][] intervals) \\n{\\n\\tArray.Sort(intervals, (x, y) => x[0] == y[0] ? y[1] - x[1] : x[0] - y[0]);\\n\\tint count = 0;\\n\\tint right = 0;\\n\\n\\tfor(int i = 0; i < intervals.Length; i++)\\n\\t{\\n\\t\\tif (intervals[i][1] > right) \\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tright = intervals[i][1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int RemoveCoveredIntervals(int[][] intervals) \\n{\\n\\tArray.Sort(intervals, (x, y) => x[0] == y[0] ? y[1] - x[1] : x[0] - y[0]);\\n\\tint count = 0;\\n\\tint right = 0;\\n\\n\\tfor(int i = 0; i < intervals.Length; i++)\\n\\t{\\n\\t\\tif (intervals[i][1] > right) \\n\\t\\t{\\n\\t\\t\\tcount++;\\n\\t\\t\\tright = intervals[i][1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878162,
                "title": "java-1-sort-and-count-2-heap-comments-added",
                "content": "If you liked this solution, **please upvote my post**\\n\\n**1 Solution** - using sorting and no additional space\\n*Time - O(n\\u2022logn)*\\n*Spase - O(1)*\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int size = intervals.length;\\n        if (size <= 1) return size;\\n\\t\\t// sort in ASC order by start of interval. and in DESC by end of interval\\n\\t\\t// in this case biggest interval will be in the beginning\\n        Arrays.sort(intervals, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n\\t\\t// at least one intervall will be\\n        int counter = 1;\\n        int[] prev = intervals[0];\\n        \\n        for (int r = 1; r < size; r++) {\\n            int[] next = intervals[r];\\n\\t\\t\\t// if prev coverst next - just continue\\n            if (prev[0] <= next[0] && prev[1] >= next[1]) {\\n                continue;\\n            }\\n            // in other case shift reference and inc counter\\n            prev = next;\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```\\n\\n**2 Solution** - using Priority queue.\\n*Time - O(n\\u2022logn)*\\nQueue Create - about O(n) time\\nQueue poll 1 item - will be logn. So in sum - O(n\\u2022logn) - correct me if I am wrong\\n*Spase - O(n)* - however it is just a reference to a Queue. which works with references. So we could assume it O(1)\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int size = intervals.length;\\n        if (size <= 1) return size;\\n\\t\\t// sort in ASC order by start of interval. and in DESC by end of interval\\n\\t\\t// in this case biggest interval will be in the beginning\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        for (int r = 0; r < size; r++) {\\n            queue.add(intervals[r]);\\n        }\\n        \\n\\t\\t// at least one intervall will be\\n        int counter = 1;\\n        int[] prev = queue.poll();\\n        while(!queue.isEmpty()) {\\n            int[] next = queue.poll();\\n\\t\\t\\t// if prev coverst next - just continue\\n            if (prev[0] <= next[0] && prev[1] >= next[1]) {\\n                continue;\\n            }\\n            // in other case shift reference and inc counter\\n            prev = next;\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int size = intervals.length;\\n        if (size <= 1) return size;\\n\\t\\t// sort in ASC order by start of interval. and in DESC by end of interval\\n\\t\\t// in this case biggest interval will be in the beginning\\n        Arrays.sort(intervals, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n\\t\\t// at least one intervall will be\\n        int counter = 1;\\n        int[] prev = intervals[0];\\n        \\n        for (int r = 1; r < size; r++) {\\n            int[] next = intervals[r];\\n\\t\\t\\t// if prev coverst next - just continue\\n            if (prev[0] <= next[0] && prev[1] >= next[1]) {\\n                continue;\\n            }\\n            // in other case shift reference and inc counter\\n            prev = next;\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int size = intervals.length;\\n        if (size <= 1) return size;\\n\\t\\t// sort in ASC order by start of interval. and in DESC by end of interval\\n\\t\\t// in this case biggest interval will be in the beginning\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        for (int r = 0; r < size; r++) {\\n            queue.add(intervals[r]);\\n        }\\n        \\n\\t\\t// at least one intervall will be\\n        int counter = 1;\\n        int[] prev = queue.poll();\\n        while(!queue.isEmpty()) {\\n            int[] next = queue.poll();\\n\\t\\t\\t// if prev coverst next - just continue\\n            if (prev[0] <= next[0] && prev[1] >= next[1]) {\\n                continue;\\n            }\\n            // in other case shift reference and inc counter\\n            prev = next;\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878617,
                "title": "python-simple-sort",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/e7a7a92e-574f-450f-8e40-86c7f363454d_1601818491.404752.png)\\n\\nSort the array in reverse order according to the finished time. But if the finished time is same, then sort in -starting time. \\nSay you got, [[1,2],[1,4],[3,4]]...\\nSorting will give you [[1,4],[3,4],[1,2]] (As finished time is same for the first two, it is sorted according to - starting time.. (-1 > -3))\\n\\nNow al you have to do is check if interval in index (i) covers the interval in index (i+1), if so, then we put the bigger interval forward to check for the next. \\nfor instance, [1,4] covers [3,4].. so we don\\'t really need [3,4] to compare with others, so, we replace that with [1,4] and then compare following intervals with [1,4]\\n\\nps: I am really bad at making people understand things. But if it helped any one of you, it is worth it. Thank you <3\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(reverse=True,key=lambda x:(x[1],-x[0]))\\n        slen = len(intervals)\\n        count = slen\\n        for i in range(slen-1):\\n            if intervals[i][0]<=intervals[i+1][0] and intervals[i][1]>=intervals[i+1][1]:\\n                intervals[i+1] = intervals[i]\\n                count-=1\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(reverse=True,key=lambda x:(x[1],-x[0]))\\n        slen = len(intervals)\\n        count = slen\\n        for i in range(slen-1):\\n            if intervals[i][0]<=intervals[i+1][0] and intervals[i][1]>=intervals[i+1][1]:\\n                intervals[i+1] = intervals[i]\\n                count-=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653762,
                "title": "javascript-solution",
                "content": "**Use of Stack:**\\n\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => b[0] - a[0] || a[1] - b[1]);\\n\\n    const stack = [];\\n    stack.push(intervals.pop());\\n    \\n    while (intervals.length > 0) {\\n        const [currStart, currEnd] = intervals.pop();\\n        const [prevStart, prevEnd] = stack[stack.length - 1];\\n        \\n        if (currStart >= prevStart && currEnd <= prevEnd) {\\n            continue;\\n        } else {\\n            stack.push([currStart, currEnd]);\\n        }\\n    }\\n    \\n    return stack.length;\\n};\\n```\\n\\n<br>\\n\\n----\\n\\n<br>\\n\\n**Without the Use of Stack:**\\n\\n\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n    \\n    let count = 0;\\n    let curr = 0;\\n    let prev = 0;\\n    \\n    for (let prev = 0, curr = 1; curr < intervals.length; curr++) {\\n        const [prevStart, prevEnd] = intervals[prev];\\n        const [currStart, currEnd] = intervals[curr];\\n            \\n        if (prevStart <= currStart && prevEnd >= currEnd) {\\n            // there is a consumption\\n            count++;\\n        } else {\\n            prev = curr;\\n        }\\n    }\\n    \\n    return intervals.length - count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => b[0] - a[0] || a[1] - b[1]);\\n\\n    const stack = [];\\n    stack.push(intervals.pop());\\n    \\n    while (intervals.length > 0) {\\n        const [currStart, currEnd] = intervals.pop();\\n        const [prevStart, prevEnd] = stack[stack.length - 1];\\n        \\n        if (currStart >= prevStart && currEnd <= prevEnd) {\\n            continue;\\n        } else {\\n            stack.push([currStart, currEnd]);\\n        }\\n    }\\n    \\n    return stack.length;\\n};\\n```\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n    \\n    let count = 0;\\n    let curr = 0;\\n    let prev = 0;\\n    \\n    for (let prev = 0, curr = 1; curr < intervals.length; curr++) {\\n        const [prevStart, prevEnd] = intervals[prev];\\n        const [currStart, currEnd] = intervals[curr];\\n            \\n        if (prevStart <= currStart && prevEnd >= currEnd) {\\n            // there is a consumption\\n            count++;\\n        } else {\\n            prev = curr;\\n        }\\n    }\\n    \\n    return intervals.length - count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786706,
                "title": "c-sorting-stack-easy-understanding-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        //Sorting intervals \\n        sort(intervals.begin(), intervals.end());\\n\\t\\t\\n\\t\\tstack<vector<int>> st;\\n        \\n        for(auto x: intervals){\\n            //This is case where the *upcoming interval covers our stored intervals*\\n            while(!st.empty() && st.top()[0] >= x[0] && st.top()[1] <= x[1]){\\n                st.pop();\\n            }\\n            \\n            //This is case where *upcoming interval is smaller and gets covered by \\n            //already stored top interval*\\n            if(!st.empty() && st.top()[0] <= x[0] && st.top()[1] >= x[1]) continue;\\n            \\n            //If the upcoming interval is non-intersecting hence,\\n            st.push(x);\\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        //Sorting intervals \\n        sort(intervals.begin(), intervals.end());\\n\\t\\t\\n\\t\\tstack<vector<int>> st;\\n        \\n        for(auto x: intervals){\\n            //This is case where the *upcoming interval covers our stored intervals*\\n            while(!st.empty() && st.top()[0] >= x[0] && st.top()[1] <= x[1]){\\n                st.pop();\\n            }\\n            \\n            //This is case where *upcoming interval is smaller and gets covered by \\n            //already stored top interval*\\n            if(!st.empty() && st.top()[0] <= x[0] && st.top()[1] >= x[1]) continue;\\n            \\n            //If the upcoming interval is non-intersecting hence,\\n            st.push(x);\\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786299,
                "title": "c-sorting-with-comparator-function-o-nlogn-runtime-o-1-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a , vector<int>& b){\\n        if(a[0] != b[0]) return a[0]<b[0];\\n        return a[1]>b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int count = 0; \\n        int curMax = -1;\\n        for(int i=0; i<intervals.size(); i++){\\n            if( intervals[i][1]<=curMax ) count++;\\n            curMax = max(curMax,intervals[i][1]);\\n        } \\n        return intervals.size() - count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a , vector<int>& b){\\n        if(a[0] != b[0]) return a[0]<b[0];\\n        return a[1]>b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int count = 0; \\n        int curMax = -1;\\n        for(int i=0; i<intervals.size(); i++){\\n            if( intervals[i][1]<=curMax ) count++;\\n            curMax = max(curMax,intervals[i][1]);\\n        } \\n        return intervals.size() - count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785768,
                "title": "java-custom-sorting-easy-sol-explained",
                "content": "```\\nclass intervalsComparator implements Comparator<int[]> {\\n    @Override\\n    public int compare(int[] entry1, int[] entry2) {\\n\\t\\t// sort acc to ascending start of interval\\n\\t\\t//if start is same then sort acc to descending end of interval\\n        if (entry1[0] > entry2[0]) {\\n            return 1;\\n        } else if(entry1[0] < entry2[0]) {\\n            return -1;\\n        } else if(entry1[1] > entry2[1]) {\\n            return -1;\\n        } else if(entry1[1] < entry2[1]) {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n\\n        Arrays.sort(intervals, new intervalsComparator());\\n\\t\\t//max ending yet\\n        int maxEnd = intervals[0][1];\\n\\t\\t//max case, all intervals are individual and included\\n        int res = intervals.length;\\n        for(int i = 1; i < intervals.length; i++) {\\n\\t\\t\\n\\t\\t\\t//this interval\\'s start is higher than prev(since, ascending order)\\n\\t\\t\\t\\n            if(intervals[i][1] <= maxEnd) { \\n\\t\\t\\t//this interval\\'s end time is lesser than max end time encountered yet\\n\\t\\t\\t// this will be absorbed, so reduce total individual intervals\\n                res--; \\n            }\\n\\t\\t\\t// keep a track on max end time encountered for future intervals\\n            maxEnd = Math.max(maxEnd, intervals[i][1]); \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass intervalsComparator implements Comparator<int[]> {\\n    @Override\\n    public int compare(int[] entry1, int[] entry2) {\\n\\t\\t// sort acc to ascending start of interval\\n\\t\\t//if start is same then sort acc to descending end of interval\\n        if (entry1[0] > entry2[0]) {\\n            return 1;\\n        } else if(entry1[0] < entry2[0]) {\\n            return -1;\\n        } else if(entry1[1] > entry2[1]) {\\n            return -1;\\n        } else if(entry1[1] < entry2[1]) {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n\\n        Arrays.sort(intervals, new intervalsComparator());\\n\\t\\t//max ending yet\\n        int maxEnd = intervals[0][1];\\n\\t\\t//max case, all intervals are individual and included\\n        int res = intervals.length;\\n        for(int i = 1; i < intervals.length; i++) {\\n\\t\\t\\n\\t\\t\\t//this interval\\'s start is higher than prev(since, ascending order)\\n\\t\\t\\t\\n            if(intervals[i][1] <= maxEnd) { \\n\\t\\t\\t//this interval\\'s end time is lesser than max end time encountered yet\\n\\t\\t\\t// this will be absorbed, so reduce total individual intervals\\n                res--; \\n            }\\n\\t\\t\\t// keep a track on max end time encountered for future intervals\\n            maxEnd = Math.max(maxEnd, intervals[i][1]); \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784556,
                "title": "c-brute-force-accepted-solution-with-explanation",
                "content": "# Daily Challenge:-20/02/2022.\\n**Approach:-** This is very simple Brute force approach.\\nBecause the constrains are very Less that\\'s why brute force works.\\n\\n**What I\\'m Doing:-**\\n*Itrate from 0 to length of given interval array.*\\n-->For every ith Interval we check ,how many interval it is covering.\\n-->If any jth interval is covered by any ith interval,then we are doing two things.\\n    -->increment the count of covered interval.\\n   **-->To mark it covered ,we change its 1st value of covered interval(i.e jth) to -1.\\n   -->And during next itration we skip those intervals,which are already covered by some other intervals.**\\n   \\n-->At the end the variable count will indicate how many intervals we have covered.\\n-->So left uncovered interval are n-count. So return n-count.\\n\\n\\n**Time Complexity= O(n^2);\\nAuxiliary Space= O(1);**\\n\\nNote:-Approach By Sorting is Another  Optimized Approach, But I\\'m Not Covering it here.\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n       int count=0; \\n        int n=intervals.size();\\n        for(int i=0;i<n;i++) \\n        {\\n            if(intervals[i][0]==-1) //If that Interval is Already Covered,Skip that.\\n                continue;\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j||intervals[j][0]==-1) //i==j means same interval and intervals[j][0]==-1 means already covered.\\n                    continue;\\n                else if((intervals[i][0]<=intervals[j][0])&&(intervals[j][1]<=intervals[i][1]))\\n                {\\n                    /*Otherwise if jth interval is covered by ith.\\n                    Mark jth as Covered by Changing it\\'s first value to -1;\\n                    And Increment the Count of Covered Interval.*/\\n                    intervals[j][0]=-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        int left_uncovered=n-count; //Left uncovered Intervals.\\n        return left_uncovered; //return it.\\n    }\\n};\\n```\\n*If you find it helpful, Please Upvote.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n       int count=0; \\n        int n=intervals.size();\\n        for(int i=0;i<n;i++) \\n        {\\n            if(intervals[i][0]==-1) //If that Interval is Already Covered,Skip that.\\n                continue;\\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j||intervals[j][0]==-1) //i==j means same interval and intervals[j][0]==-1 means already covered.\\n                    continue;\\n                else if((intervals[i][0]<=intervals[j][0])&&(intervals[j][1]<=intervals[i][1]))\\n                {\\n                    /*Otherwise if jth interval is covered by ith.\\n                    Mark jth as Covered by Changing it\\'s first value to -1;\\n                    And Increment the Count of Covered Interval.*/\\n                    intervals[j][0]=-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        int left_uncovered=n-count; //Left uncovered Intervals.\\n        return left_uncovered; //return it.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878296,
                "title": "remove-covered-intervals-java-explained",
                "content": "The problem states :` Interval [a,b) is covered by interval [c,d) if and only if c <= a and b <= d.`\\nSolution is from the hints provied in problem: `Compare each interval to all others and check if it is covered by any interval.`\\n\\n**Outer Loop:**\\n* \\t The Interval that\\'s being checked (let\\'s say `X [a,b)`)\\n* \\t If it\\'s `null` means already covered by other interval\\n\\n**Inner Loop:**\\n* Check If we are comparing `X` with itself. Let\\'s call the new Interval `Y [c,d)` and it shouldn\\'t be null.\\n* now if the `c <=a and b<=d` condition is satisfied then make `X` as `null` and break this loop.\\n\\n**Count Loop:** Count all the Intervals that are not null and return the same.\\n\\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\tint count = 0;\\n\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\tif (intervals[i] != null)\\n\\t\\t\\tfor (int j = 0; j < intervals.length; j++) {\\n\\t\\t\\t\\tif (i != j && intervals[j] != null) {\\n\\t\\t\\t\\t\\tif (intervals[j][0] <= intervals[i][0] && intervals[i][1] <= intervals[j][1]) {\\n\\t\\t\\t\\t\\t\\tintervals[i] = null;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n\\tfor (int[] interval : intervals) {\\n\\t\\tif (interval != null) count++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\tint count = 0;\\n\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\tif (intervals[i] != null)\\n\\t\\t\\tfor (int j = 0; j < intervals.length; j++) {\\n\\t\\t\\t\\tif (i != j && intervals[j] != null) {\\n\\t\\t\\t\\t\\tif (intervals[j][0] <= intervals[i][0] && intervals[i][1] <= intervals[j][1]) {\\n\\t\\t\\t\\t\\t\\tintervals[i] = null;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n\\tfor (int[] interval : intervals) {\\n\\t\\tif (interval != null) count++;\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 689094,
                "title": "java-simple-sort",
                "content": "1, sort\\n2, loop every interval, comparing end of interval,  with the highest end:\\nsince the current start is always >= than all prev start, \\nif the curr end is <= the highest end, it will make sure to be included with another one;\\n```\\n    public int removeCoveredIntervals(int[][] is) {\\n        Arrays.sort(is, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int n = is.length, res = 0, end = Integer.MIN_VALUE;  \\n        for (int[] i : is) {\\n            if (i[1] > end) end = i[1];\\n            else res++;\\n        }\\n        return n - res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int removeCoveredIntervals(int[][] is) {\\n        Arrays.sort(is, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        int n = is.length, res = 0, end = Integer.MIN_VALUE;  \\n        for (int[] i : is) {\\n            if (i[1] > end) end = i[1];\\n            else res++;\\n        }\\n        return n - res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 494727,
                "title": "easy-java-solution-beats-95-runtime",
                "content": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n        \\n        Arrays.sort(intervals, (i1, i2) -> i1[0] - i2[0]);\\n        int count = 1;\\n        for (int i = 0, j = 1; j < intervals.length; j++) {\\n            if (intervals[i][1] < intervals[j][1]) {\\n                i = j;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n        \\n        Arrays.sort(intervals, (i1, i2) -> i1[0] - i2[0]);\\n        int count = 1;\\n        for (int i = 0, j = 1; j < intervals.length; j++) {\\n            if (intervals[i][1] < intervals[j][1]) {\\n                i = j;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786906,
                "title": "python3-brute-force-40-faster",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, new: List[List[int]]) -> int:\\n        arr=[]\\n        for i in range(len(new)):\\n            for j in range(len(new)):\\n                if i!=j and new[j][0] <= new[i][0] and new[i][1] <= new[j][1]:\\n                    arr.append(new[i])\\n                    break\\n        return len(new)-len(arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, new: List[List[int]]) -> int:\\n        arr=[]\\n        for i in range(len(new)):\\n            for j in range(len(new)):\\n                if i!=j and new[j][0] <= new[i][0] and new[i][1] <= new[j][1]:\\n                    arr.append(new[i])\\n                    break\\n        return len(new)-len(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786721,
                "title": "python-sorting-faster-than-85",
                "content": "```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n\\t    n = allIntervals = len(intervals)\\n\\t\\tl = 0\\n\\t\\tr = 1\\n\\t\\t\\n\\t\\t# this built in function can sort by first element as well as second\\n\\t\\t# so given sorted [l1,u1],[l2,u2] it can also satisfy l1 = l2 AND u1 < u2\\n\\t\\tintervals.sort()\\n\\t\\t\\n\\t\\t# we have a left and right pointer\\n\\t\\twhile r < n:\\n\\t\\t    # we check for equal lower bound\\n\\t\\t\\t# we will shift both left and right if equal since we only really need the interval with greatest upper bound among equal lower bounds\\n\\t\\t\\t# the greater upper bound the larger the interval\\n\\t\\t\\t# the interval with same lower bound but lower upper bound is also covered, hence the allIntervals decrement\\n\\t\\t    while r<n and intervals[l][0] == intervals[r][0]:\\n\\t\\t\\t    l += 1\\n\\t\\t\\t\\tr += 1\\n\\t\\t\\t\\tallIntervals -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# we scan through the upper bounds\\n\\t\\t\\t# we only shift right - left will serve as the basis for maximum upper bound\\n\\t\\t\\t# if current max upper bound is greater than interval[r], this also makes interval[r] covered, hence the allIntervals decrement\\n\\t\\t\\twhile r<n and intervals[l][1] >= intervals[r][1]:\\n\\t\\t\\t    r += 1\\n\\t\\t\\t\\tallIntervals -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\tl = r\\n\\t\\t\\tr += 1\\n\\t\\t\\t\\n\\t\\treturn allIntervals\\n\\t\\t\\t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n\\t    n = allIntervals = len(intervals)\\n\\t\\tl = 0\\n\\t\\tr = 1\\n\\t\\t\\n\\t\\t# this built in function can sort by first element as well as second\\n\\t\\t# so given sorted [l1,u1],[l2,u2] it can also satisfy l1 = l2 AND u1 < u2\\n\\t\\tintervals.sort()\\n\\t\\t\\n\\t\\t# we have a left and right pointer\\n\\t\\twhile r < n:\\n\\t\\t    # we check for equal lower bound\\n\\t\\t\\t# we will shift both left and right if equal since we only really need the interval with greatest upper bound among equal lower bounds\\n\\t\\t\\t# the greater upper bound the larger the interval\\n\\t\\t\\t# the interval with same lower bound but lower upper bound is also covered, hence the allIntervals decrement\\n\\t\\t    while r<n and intervals[l][0] == intervals[r][0]:\\n\\t\\t\\t    l += 1\\n\\t\\t\\t\\tr += 1\\n\\t\\t\\t\\tallIntervals -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\t# we scan through the upper bounds\\n\\t\\t\\t# we only shift right - left will serve as the basis for maximum upper bound\\n\\t\\t\\t# if current max upper bound is greater than interval[r], this also makes interval[r] covered, hence the allIntervals decrement\\n\\t\\t\\twhile r<n and intervals[l][1] >= intervals[r][1]:\\n\\t\\t\\t    r += 1\\n\\t\\t\\t\\tallIntervals -= 1\\n\\t\\t\\t\\t\\n\\t\\t\\tl = r\\n\\t\\t\\tr += 1\\n\\t\\t\\t\\n\\t\\treturn allIntervals\\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786656,
                "title": "python-simple-code",
                "content": "```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(intervals)\\n        c = n\\n        for i in range(n):\\n            for j in intervals[:i] + intervals[i+1:]:\\n                if intervals[i][0] >= j[0] and intervals[i][1] <= j[1]:\\n                    c-=1\\n                    break\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeCoveredIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(intervals)\\n        c = n\\n        for i in range(n):\\n            for j in intervals[:i] + intervals[i+1:]:\\n                if intervals[i][0] >= j[0] and intervals[i][1] <= j[1]:\\n                    c-=1\\n                    break\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786623,
                "title": "js-100-ms-better-than-58",
                "content": "```\\n\\nconst removeCoveredIntervals = function(its) {\\n    let r = 0;\\n    its.sort((a, b) => a[0] - b[0]);\\n    const c = [-1, -1]\\n    for (let it of its) {\\n        if (it[0] > c[0] && it[1] > c[1]) {\\n            c[0] = it[0];\\n            r++;\\n        }\\n        c[1] = Math.max(c[1], it[1]);\\n    }\\n    return r;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst removeCoveredIntervals = function(its) {\\n    let r = 0;\\n    its.sort((a, b) => a[0] - b[0]);\\n    const c = [-1, -1]\\n    for (let it of its) {\\n        if (it[0] > c[0] && it[1] > c[1]) {\\n            c[0] = it[0];\\n            r++;\\n        }\\n        c[1] = Math.max(c[1], it[1]);\\n    }\\n    return r;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786525,
                "title": "python-3-greedy-solution-and-explanation",
                "content": "\\n# \\uD83C\\uDF1F[Python 3] Greedy Sort Solution and Explanation\\n\\n## 1\\uFE0F\\u20E3 Greedy Naive Approach:\\n* Step 1. Sort intervals by first index\\n* Setp 2. Compare with current interval and last interval, so we can check whether current interval and last interval overlaps and covered by intervals[i][1] <= lastInterval[1].\\n> **(Edge Case)** : Since we compare two intervals ending point, once current interval\\'s ending point is **smaller** than last interval\\'s, in most of time it works.\\n> But there is a edge case that these two interval\\'s starting point are equal. So we could add another **if statement** to update last interval to a larger interval\\n## Dry run\\n```\\nIntervals = [[1,4],[3,6],[2,8],[1,5],[2,3]]\\n#sorted\\n[[1, 4], [1, 5], [2, 8], [2, 3], [3, 6]]\\n# [1,4] and [1,5] is one of our edge cases\\nInit => count = 1, lastInterval = [1, 4]\\n# In for loop\\ni = 1 => count = 1, lastInterval = [1, 5] #Edge case swap lastInterval\\ni = 2 => count = 2, lastInterval = [2, 8]\\ni = 3 => count = 2, lastInterval = [2, 8] # [2, 3]\\'s ending point is smaller than [2, 8]\\ni = 4 => count = 2, lastInterval = [2, 8] # [3, 6]\\'s ending point is smaller than [2, 8]\\n\\nFinal => return 2\\n```\\n\\n## Complexity Analysis\\n* Time: O(Nlog(N)) : Let N be length of intervals\\n* Space: O(N) :  Sorting in Python\\n\\n\\n## Code\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:    \\n        intervals.sort(key = lambda x: x[0])        \\n        lastInterval = intervals[0]\\n        count = 1\\n        for i in range(1, len(intervals)):\\n            # Basic logic\\n            if intervals[i][1] <= lastInterval[1]:\\n                continue\\n            # In case both inverval share same start point, we update lastInterval\\n            elif intervals[i][0] == lastInterval[0] and lastInterval[1] <= intervals[i][1]:\\n                lastInterval = intervals[i]\\n                continue\\n            # Update last interval and increase count\\n            lastInterval = intervals[i]\\n            count += 1\\n        return count\\n```\\n\\n## 2\\uFE0F\\u20E3 Greedy Improved Approach:\\n\\n**In order two deal with the edge case this time we sort intervals not only by first index of interval and both second index with large number first**\\n* Step 1. Sort intervals by first index (Smaller first index, and larger second index)\\n* Setp 2. Compare with current interval and last interval, so we can check whether current interval and last interval overlaps and covered by intervals[i][1] <= lastInterval[1].\\n## Exapmle\\n\\n```\\nIntervals = [[1,4],[3,6],[2,8],[1,5],[2,3]]\\nintervals.sort(key = lambda x: x[0])\\n> [[1, 4], [1, 5], [2, 8], [2, 3], [3, 6]]\\n\\nintervals.sort(key = lambda x: (x[0], -x[1]))\\n> [[1, 5], [1, 4], [2, 8], [2, 3], [3, 6]]\\n```\\n\\n## Complexity Analysis\\n* Time: O(Nlog(N)) : Let N be length of intervals\\n* Space: O(N) :  Sorting in Python\\n\\n\\n## Code\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        # To deal with edge case, we sort both (x[0] and -x[1])\\n        intervals.sort(key = lambda x: (x[0], -x[1]))        \\n        lastInterval = intervals[0]\\n        count = 1\\n        print(intervals)\\n        for i in range(1, len(intervals)):\\n            # Basic logic\\n            if intervals[i][1] <= lastInterval[1]:\\n                continue\\n            # Update last interval and increase count\\n            lastInterval = intervals[i]\\n            count += 1\\n        return count\\n```\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nIntervals = [[1,4],[3,6],[2,8],[1,5],[2,3]]\\n#sorted\\n[[1, 4], [1, 5], [2, 8], [2, 3], [3, 6]]\\n# [1,4] and [1,5] is one of our edge cases\\nInit => count = 1, lastInterval = [1, 4]\\n# In for loop\\ni = 1 => count = 1, lastInterval = [1, 5] #Edge case swap lastInterval\\ni = 2 => count = 2, lastInterval = [2, 8]\\ni = 3 => count = 2, lastInterval = [2, 8] # [2, 3]\\'s ending point is smaller than [2, 8]\\ni = 4 => count = 2, lastInterval = [2, 8] # [3, 6]\\'s ending point is smaller than [2, 8]\\n\\nFinal => return 2\\n```\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:    \\n        intervals.sort(key = lambda x: x[0])        \\n        lastInterval = intervals[0]\\n        count = 1\\n        for i in range(1, len(intervals)):\\n            # Basic logic\\n            if intervals[i][1] <= lastInterval[1]:\\n                continue\\n            # In case both inverval share same start point, we update lastInterval\\n            elif intervals[i][0] == lastInterval[0] and lastInterval[1] <= intervals[i][1]:\\n                lastInterval = intervals[i]\\n                continue\\n            # Update last interval and increase count\\n            lastInterval = intervals[i]\\n            count += 1\\n        return count\\n```\n```\\nIntervals = [[1,4],[3,6],[2,8],[1,5],[2,3]]\\nintervals.sort(key = lambda x: x[0])\\n> [[1, 4], [1, 5], [2, 8], [2, 3], [3, 6]]\\n\\nintervals.sort(key = lambda x: (x[0], -x[1]))\\n> [[1, 5], [1, 4], [2, 8], [2, 3], [3, 6]]\\n```\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        # To deal with edge case, we sort both (x[0] and -x[1])\\n        intervals.sort(key = lambda x: (x[0], -x[1]))        \\n        lastInterval = intervals[0]\\n        count = 1\\n        print(intervals)\\n        for i in range(1, len(intervals)):\\n            # Basic logic\\n            if intervals[i][1] <= lastInterval[1]:\\n                continue\\n            # Update last interval and increase count\\n            lastInterval = intervals[i]\\n            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786131,
                "title": "clean-and-concise-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NlogN)\\n    // Space Complexity:- O(1)\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // sort intervals on the basis of l, and if l is same, then decreasing r\\n        sort(intervals.begin(),intervals.end(),[&](const vector<int>& p1,const vector<int>& p2){\\n            if(p1[0]==p2[0]){\\n                return p1[1]>p2[1];\\n            }\\n            return p1[0]<p2[0];\\n        });\\n        \\n        int n = intervals.size();\\n        int ans = n,rmax = intervals[0][1];\\n        for(int i=1;i<n;i++){\\n            // track rmax, if rmax>=curr r of interval, this interval is covered\\n            if(rmax>=intervals[i][1]){\\n                ans--;\\n            }\\n            else{\\n                rmax = intervals[i][1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NlogN)\\n    // Space Complexity:- O(1)\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // sort intervals on the basis of l, and if l is same, then decreasing r\\n        sort(intervals.begin(),intervals.end(),[&](const vector<int>& p1,const vector<int>& p2){\\n            if(p1[0]==p2[0]){\\n                return p1[1]>p2[1];\\n            }\\n            return p1[0]<p2[0];\\n        });\\n        \\n        int n = intervals.size();\\n        int ans = n,rmax = intervals[0][1];\\n        for(int i=1;i<n;i++){\\n            // track rmax, if rmax>=curr r of interval, this interval is covered\\n            if(rmax>=intervals[i][1]){\\n                ans--;\\n            }\\n            else{\\n                rmax = intervals[i][1];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786026,
                "title": "python-3-90ms-sorted-matrix-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals, key = lambda x : (x[0], -x[1]))\\n        res = 0\\n        ending = 0\\n        for _, end in intervals:\\n            if end > ending:\\n                res += 1\\n                ending = end\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals = sorted(intervals, key = lambda x : (x[0], -x[1]))\\n        res = 0\\n        ending = 0\\n        for _, end in intervals:\\n            if end > ending:\\n                res += 1\\n                ending = end\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786009,
                "title": "c-simple-solution-o-nlogn",
                "content": "* Multiply each **r** by **-1** to make it negative.\\n* Sort the intervals.\\n* Now we do care only for our right pointer **r**, because **L** will be in increasing order.\\n* Keep checking **r** one by one and track the only last uncovered right pointer.\\n* Save answer as the difference between total intervals and covered intervals.\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        for(int i = 0; i < n; i++) {\\n            intervals[i][1] *= -1;\\n        }\\n        \\n        sort(intervals.begin(), intervals.end());\\n        int prevR = intervals[0][1] * -1;\\n        int cnt = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int currR = intervals[i][1] * -1;\\n            if(currR <= prevR) ++cnt;\\n            else prevR = currR;\\n        }\\n        \\n        return n - cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        for(int i = 0; i < n; i++) {\\n            intervals[i][1] *= -1;\\n        }\\n        \\n        sort(intervals.begin(), intervals.end());\\n        int prevR = intervals[0][1] * -1;\\n        int cnt = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            int currR = intervals[i][1] * -1;\\n            if(currR <= prevR) ++cnt;\\n            else prevR = currR;\\n        }\\n        \\n        return n - cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785734,
                "title": "simple-c-solution-easy-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) \\n    {\\n        \\n        int n = intervals.size();\\n        int ans=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            int s = intervals[i].front();       //start point of a interval\\n            int e = intervals[i].back();        //end point\\n            int c = 0;\\n            for(int  j = 0;j<n;++j)\\n            {\\n                int a = intervals[j].front();       //start \\n                int b = intervals[j].back();        //end\\n                \\n                if(s>=a && b>=e)\\n                    ++c;\\n            }\\n            if(c>1)                 //greater than one because c=1 will count the same iterval also\\n                ++ans;              //count extra interval present\\n        }\\n        return n-ans;               //return remaining no of interval\\n        \\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE IF FOUND HELPFUL.**\\n**HAPPY LEARNING. HAPPY CODING.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) \\n    {\\n        \\n        int n = intervals.size();\\n        int ans=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            int s = intervals[i].front();       //start point of a interval\\n            int e = intervals[i].back();        //end point\\n            int c = 0;\\n            for(int  j = 0;j<n;++j)\\n            {\\n                int a = intervals[j].front();       //start \\n                int b = intervals[j].back();        //end\\n                \\n                if(s>=a && b>=e)\\n                    ++c;\\n            }\\n            if(c>1)                 //greater than one because c=1 will count the same iterval also\\n                ++ans;              //count extra interval present\\n        }\\n        return n-ans;               //return remaining no of interval\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785700,
                "title": "sort-solution-java",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b) -> a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);\\n        int count=1;\\n        int ind=0;\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[ind][1]<intervals[i][1]){\\n                count++;\\n                ind=i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(a,b) -> a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);\\n        int count=1;\\n        int ind=0;\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[ind][1]<intervals[i][1]){\\n                count++;\\n                ind=i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785633,
                "title": "best-java-solution",
                "content": "```\\n public int removeCoveredIntervals(int[][] intervals) {\\n \\n    Arrays.sort(intervals, (a,b)->(a[0]==b[0]?b[1]-a[1]:a[0]-b[0]));\\n       \\n\\tint max=intervals[0][1];\\n    int count=1;\\n        \\n        for(int i=1;i<intervals.length;i++){\\n            if(max<intervals[i][1] ){\\n                count++;\\n                max=intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n public int removeCoveredIntervals(int[][] intervals) {\\n \\n    Arrays.sort(intervals, (a,b)->(a[0]==b[0]?b[1]-a[1]:a[0]-b[0]));\\n       \\n\\tint max=intervals[0][1];\\n    int count=1;\\n        \\n        for(int i=1;i<intervals.length;i++){\\n            if(max<intervals[i][1] ){\\n                count++;\\n                max=intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1785581,
                "title": "c-o-nlogn-solution-using-comparator-function",
                "content": "Sort the intervals in non-decreasing order of their starting time.\\nThen calculate the number of intervals that completely overlap.\\nReturn total number of intervals-number of intervals that completely overlap.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(vector <int> &a, vector <int> &b)\\n    {\\n        if(a[0]<b[0])\\n            return true;\\n        else if(a[0]==b[0])\\n        {\\n            if(a[1]>b[1])\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end(),cmp);\\n        \\n        int st=v[0][0],en=v[0][1],i,c=0;\\n        \\n        for(i=1;i<v.size();i++)\\n        {\\n            if(v[i][0]>=st and v[i][1]<=en)\\n                ++c;\\n            else\\n            {\\n                st=v[i][0];\\n                en=v[i][1];\\n            }\\n        }\\n        \\n        return v.size()-c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    static bool cmp(vector <int> &a, vector <int> &b)\\n    {\\n        if(a[0]<b[0])\\n            return true;\\n        else if(a[0]==b[0])\\n        {\\n            if(a[1]>b[1])\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& v) {\\n        sort(v.begin(),v.end(),cmp);\\n        \\n        int st=v[0][0],en=v[0][1],i,c=0;\\n        \\n        for(i=1;i<v.size();i++)\\n        {\\n            if(v[i][0]>=st and v[i][1]<=en)\\n                ++c;\\n            else\\n            {\\n                st=v[i][0];\\n                en=v[i][1];\\n            }\\n        }\\n        \\n        return v.size()-c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785555,
                "title": "c-sort-solution-with-explanation",
                "content": "##### **Solution:- Using sorting**\\nSort the array, and note the previous left and right bound.\\nFor evert interval v,\\nif v[0] > left && v[1] > right,\\nIt\\'s a new uncovered interval,\\nso we increment ++result.\\n\\nComplexity: time O(sort), space O(sort)\\n\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = 0, left = -1, right = -1;\\n        sort(intervals.begin(), intervals.end());\\n        for (auto& v: intervals) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++result;\\n            }\\n            right = max(right, v[1]);\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Don\\'t be selfish, do upvote, if somewhere it helped you :)**\\n*Happy Coding.*",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = 0, left = -1, right = -1;\\n        sort(intervals.begin(), intervals.end());\\n        for (auto& v: intervals) {\\n            if (v[0] > left && v[1] > right) {\\n                left = v[0];\\n                ++result;\\n            }\\n            right = max(right, v[1]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785343,
                "title": "java-easy-solution-2ms",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int pairs = intervals.length;\\n        boolean[] check = new boolean[pairs];\\n        for(int i = 0; i< pairs ;i++){\\n            if(!check[i]){\\n                for(int j = i+1;j<pairs;j++){\\n                    if(!check[j]){\\n                        if(intervals[i][0]<=intervals[j][0] && intervals[j][1]<=intervals[i][1]){\\n                            check[j] = true;\\n                        }\\n                        else if(intervals[i][0]>=intervals[j][0] && intervals[j][1]>=intervals[i][1]){\\n                            check[i] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(boolean b : check){\\n            if(!b){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int pairs = intervals.length;\\n        boolean[] check = new boolean[pairs];\\n        for(int i = 0; i< pairs ;i++){\\n            if(!check[i]){\\n                for(int j = i+1;j<pairs;j++){\\n                    if(!check[j]){\\n                        if(intervals[i][0]<=intervals[j][0] && intervals[j][1]<=intervals[i][1]){\\n                            check[j] = true;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 879763,
                "title": "c-simple-sorting-solution-explained-100-time-60-space",
                "content": "This solution requires sorting and I have to admit it took me a bit to notice I was massively underperforming with it, since my sorting function was not getting parameters as references - my bad and lesson learnt: do not focus just on the algorithm, but also consider the basics \\uD83E\\uDD26\\u200D\\u2642\\uFE0F\\n\\nAnyway, without further ado, let\\'s indeed focus on what matters - our function will have just 2 support variables:\\n* `len` to store of the length of the input;\\n* `res` to keep track of our result and initially set to the value of `len`.\\n\\nWe then proceed to sort by our helper function `cmp`, sorting by starting period first (increasing order) and, when they match, ending period second (decreasing).\\n\\nThere is a reason for that: we are then going to loop throug the sorted array, storing the highest ending value found so far in `ed`, then we can have 2 scenarios for each new interval parsed:\\n* the current ending period is `<= ed` and this means, since by definition we know that the starting periods are increasing, that with the previous starting period being `>=` the current one, this current interval is covered and thus we decrease `res` (marking a removal);\\n* the current ending period is `> ed` , then we just update `ed` to this value, ready for another loop.\\n\\nAs you might infer, having the finishing periods in decreasing order is the invariant that allows us to keep looping like this when the starting periods are identical; also note that an alternative approach might be to keep parsing a series sorted by only one criteria, but then updating both starting and finishing stored values at each step with a more complex logic, for no gain (and some more computation, but on linear instead of linearithmic time).\\n\\nOnce we are done, we just return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[0] != b[0] ? a[0] < b[0] : a[1] > b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // support variables\\n        int len = intervals.size(), res = len;\\n        // sorting by beginning, then ending time\\n        sort(begin(intervals), end(intervals), cmp);\\n        for (int i = 1, ed = intervals[0][1]; i < len; i++){\\n            if (intervals[i][1] <= ed) res--;\\n            else ed = intervals[i][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[0] != b[0] ? a[0] < b[0] : a[1] > b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // support variables\\n        int len = intervals.size(), res = len;\\n        // sorting by beginning, then ending time\\n        sort(begin(intervals), end(intervals), cmp);\\n        for (int i = 1, ed = intervals[0][1]; i < len; i++){\\n            if (intervals[i][1] <= ed) res--;\\n            else ed = intervals[i][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879677,
                "title": "c-sorting-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = 1;\\n        sort(intervals.begin(), intervals.end());\\n        int x1 = intervals[0][0], x2 = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++) {\\n            if(intervals[i][0] > x1 && intervals[i][1] > x2) result++;\\n            if(intervals[i][1] > x2) {\\n                x1 = intervals[i][0];\\n                x2 = intervals[i][1];\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = 1;\\n        sort(intervals.begin(), intervals.end());\\n        int x1 = intervals[0][0], x2 = intervals[0][1];\\n        for(int i = 1; i < intervals.size(); i++) {\\n            if(intervals[i][0] > x1 && intervals[i][1] > x2) result++;\\n            if(intervals[i][1] > x2) {\\n                x1 = intervals[i][0];\\n                x2 = intervals[i][1];\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878461,
                "title": "c-linq-one-liner",
                "content": "```csharp\\npublic int RemoveCoveredIntervals(int[][] intervals) =>\\n\\tintervals.OrderBy(i => i[0]).ThenByDescending(i => i[1])\\n\\t\\t.Aggregate((Result: 0, Right: 0), (t, i) => i[1] > t.Right ? (t.Result + 1, i[1]) : t).Result;\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int RemoveCoveredIntervals(int[][] intervals) =>\\n\\tintervals.OrderBy(i => i[0]).ThenByDescending(i => i[1])\\n\\t\\t.Aggregate((Result: 0, Right: 0), (t, i) => i[1] > t.Right ? (t.Result + 1, i[1]) : t).Result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878418,
                "title": "python-super-simple-clean-solution-faster-than-99-3",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        total = len(intervals)\\n        intervals.sort(key = lambda a: a[0])\\n        curr = [-1, -1]\\n        count = 0\\n        for inter in intervals:\\n            \\n            if inter[0]>=curr[0] and inter[1]<=curr[1]:\\n                count+=1\\n                continue\\n                \\n            elif inter[0]<=curr[0] and inter[1]>=curr[1]:\\n                count+=1\\n                \\n            curr = inter\\n            \\n        return total-count\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        total = len(intervals)\\n        intervals.sort(key = lambda a: a[0])\\n        curr = [-1, -1]\\n        count = 0\\n        for inter in intervals:\\n            \\n            if inter[0]>=curr[0] and inter[1]<=curr[1]:\\n                count+=1\\n                continue\\n                \\n            elif inter[0]<=curr[0] and inter[1]>=curr[1]:\\n                count+=1\\n                \\n            curr = inter\\n            \\n        return total-count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853816,
                "title": "python-o-nlogn-o-n-beats-100",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        end = intervals[0][1]\\n        count = 1\\n        \\n        for i in intervals:\\n            if i[1]>end:\\n                end = i[1]\\n                count += 1\\n        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        end = intervals[0][1]\\n        count = 1\\n        \\n        for i in intervals:\\n            if i[1]>end:\\n                end = i[1]\\n                count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828159,
                "title": "sorting-c-easy-with-explanation-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is very Simple **Sort the Intervals** on the basis of their **starting Time** and Try to find out the Number of Overlapping Intervals and finally Return-`Total_intervals-overlapping intervals`\\n\\n**In order to find out the Overlapping intervals we have 3 cases as Below:-**\\n```\\nCase 1:- [1,4],[2,3] completely Overlapped. here increment the number of overlapping\\nintervals by 1, and don\\'t update the start and end pointer.\\n\\nCase 2:- [1,2],[1,4] completely Overlapped. here increment the number of overlapping\\nintervals by 1 and update the end pointer.\\nCase 3:- [1,4],[3,5] Partially Overlapped. Here Intervals are Partially Overlapped so\\n don\\'t increment the number of Intervals but Update the start and End Pointers.\\n```\\n\\n# Complexity\\n- Time complexity:O(N * Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& inter) {\\n        sort(inter.begin(),inter.end());\\n        int st = inter[0][0],end = inter[0][1],ans = 0;\\n        for(int i = 1;i<inter.size();i++)\\n        {\\n            if(inter[i][0]>=st && inter[i][1]<=end) ans++;\\n            else if(inter[i][0]==st && inter[i][1]>=end)\\n            {\\n                ans++;\\n                end = inter[i][1];\\n            }\\n            else if(inter[i][0]>=end || inter[i][1]>=end)\\n            {\\n                st = inter[i][0];\\n                end = max(end,inter[i][1]);\\n            }\\n        }\\n        return inter.size()-ans;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/12d8a5ec-5f24-4267-80b3-e9881846a5e9_1690537589.6755645.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nCase 1:- [1,4],[2,3] completely Overlapped. here increment the number of overlapping\\nintervals by 1, and don\\'t update the start and end pointer.\\n\\nCase 2:- [1,2],[1,4] completely Overlapped. here increment the number of overlapping\\nintervals by 1 and update the end pointer.\\nCase 3:- [1,4],[3,5] Partially Overlapped. Here Intervals are Partially Overlapped so\\n don\\'t increment the number of Intervals but Update the start and End Pointers.\\n```\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& inter) {\\n        sort(inter.begin(),inter.end());\\n        int st = inter[0][0],end = inter[0][1],ans = 0;\\n        for(int i = 1;i<inter.size();i++)\\n        {\\n            if(inter[i][0]>=st && inter[i][1]<=end) ans++;\\n            else if(inter[i][0]==st && inter[i][1]>=end)\\n            {\\n                ans++;\\n                end = inter[i][1];\\n            }\\n            else if(inter[i][0]>=end || inter[i][1]>=end)\\n            {\\n                st = inter[i][0];\\n                end = max(end,inter[i][1]);\\n            }\\n        }\\n        return inter.size()-ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561311,
                "title": "c-clean-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = intervals.size();\\n\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\\n            return a[0] < b[0];\\n        });\\n\\n        for (int i = 0; i < intervals.size()-1; i++) {\\n            // ex: (1, 2) & (1, 4) -> remove (1, 2)\\n            if (intervals[i][0] == intervals[i+1][0]) {\\n                if (intervals[i][1] < intervals[i+1][1]) {\\n                    result--;\\n                    continue;\\n                }\\n            }\\n\\n            // ex: (1, 4) & (2, 8) -> seperate intervals\\n            if (intervals[i][1] < intervals[i+1][1]) continue;\\n\\n            // ex: (2, 8) & (3, 6) -> remove (3, 6)\\n            intervals[i+1] = intervals[i];\\n            result--;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int result = intervals.size();\\n\\n        sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\\n            return a[0] < b[0];\\n        });\\n\\n        for (int i = 0; i < intervals.size()-1; i++) {\\n            // ex: (1, 2) & (1, 4) -> remove (1, 2)\\n            if (intervals[i][0] == intervals[i+1][0]) {\\n                if (intervals[i][1] < intervals[i+1][1]) {\\n                    result--;\\n                    continue;\\n                }\\n            }\\n\\n            // ex: (1, 4) & (2, 8) -> seperate intervals\\n            if (intervals[i][1] < intervals[i+1][1]) continue;\\n\\n            // ex: (2, 8) & (3, 6) -> remove (3, 6)\\n            intervals[i+1] = intervals[i];\\n            result--;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174581,
                "title": "java-code-with-comments",
                "content": "```\\n\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n        // Sort the intervals (l, r) based on \\'l\\' value. \\n        // If two intervals have same \\'l\\' value sort them based on highest \\'r\\' value.\\n        Arrays.sort(intervals, (interval1, interval2) -> {\\n            if (interval1[0] != interval2[0]) {\\n               return interval1[0] - interval2[0]; \\n            } else {\\n                return interval2[1] - interval1[1]; \\n            }\\n            \\n        });\\n        \\n        int removed = 0;\\n        \\n        // Start with reference interval.\\n        int[] referenceInterval = intervals[0];\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            // Check if each interval is mergable by comparing it with our reference interval.\\n            // If the current interval is with in our reference interval merge the current interval\\n            // to reference interval.\\n            if (intervals[i][0] >= referenceInterval[0] && intervals[i][1] <= referenceInterval[1]) {\\n                // note that as part of merging there is no need to update the right value into our \\n                // reference interval as right value in reference interval is already the highest value.\\n                referenceInterval[0] =  intervals[i][0];\\n                removed++;\\n                continue;\\n            }\\n            // If not make current interval as our reference interval.\\n            referenceInterval = intervals[i];\\n        }\\n        \\n        // Return remaining intervals.\\n        return intervals.length - removed;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n        // Sort the intervals (l, r) based on \\'l\\' value. \\n        // If two intervals have same \\'l\\' value sort them based on highest \\'r\\' value.\\n        Arrays.sort(intervals, (interval1, interval2) -> {\\n            if (interval1[0] != interval2[0]) {\\n               return interval1[0] - interval2[0]; \\n            } else {\\n                return interval2[1] - interval1[1]; \\n            }\\n            \\n        });\\n        \\n        int removed = 0;\\n        \\n        // Start with reference interval.\\n        int[] referenceInterval = intervals[0];\\n        \\n        for (int i = 1; i < intervals.length; i++) {\\n            // Check if each interval is mergable by comparing it with our reference interval.\\n            // If the current interval is with in our reference interval merge the current interval\\n            // to reference interval.\\n            if (intervals[i][0] >= referenceInterval[0] && intervals[i][1] <= referenceInterval[1]) {\\n                // note that as part of merging there is no need to update the right value into our \\n                // reference interval as right value in reference interval is already the highest value.\\n                referenceInterval[0] =  intervals[i][0];\\n                removed++;\\n                continue;\\n            }\\n            // If not make current interval as our reference interval.\\n            referenceInterval = intervals[i];\\n        }\\n        \\n        // Return remaining intervals.\\n        return intervals.length - removed;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797740,
                "title": "sort-left-in-ascending-and-right-in-descending-by-using-custom-comparator-function-c",
                "content": "sort left ascending and right decending\\nIn this solution, we sort on left first.\\nWhen left are same, we sort right in decending order.\\n\\nFor example: [[1,5],[1,4],[1,3],[1,2]]\\n\\nComplexity: time O(sort), space O(sort)\\n\\n```\\n#define all(x) (x).begin(),(x).end()\\nclass Solution {\\npublic:\\n    // here is custom comparator function to sort left in ascending and right in descending\\n    \\n    static bool cmp(vector<int>&v1,vector<int>&v2){\\n          if (v1[0] != v2[0]) {\\n        return v1[0] < v2[0];\\n    }\\n    return v1[1] > v2[1];\\n    }\\n\\t\\npublic:\\n   \\n    int removeCoveredIntervals(vector<vector<int>>&v) {\\n             \\n         int n=v.size();\\n         sort(all(v),cmp);\\n         int cnt=1;\\n         int l=v[0][0],r=v[0][1];\\n        for(int i=1;i<n;i++){\\n            // here no need to check for left value as we have sorted left value in ascending order\\n            // so it will always less than current one\\n            if(v[i][1]>r){\\n                // when we get right greater than previous one we increment count by 1\\n                // and set right value to current one\\n                cnt++;\\n                r=v[i][1];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n#define all(x) (x).begin(),(x).end()\\nclass Solution {\\npublic:\\n    // here is custom comparator function to sort left in ascending and right in descending\\n    \\n    static bool cmp(vector<int>&v1,vector<int>&v2){\\n          if (v1[0] != v2[0]) {\\n        return v1[0] < v2[0];\\n    }\\n    return v1[1] > v2[1];\\n    }\\n\\t\\npublic:\\n   \\n    int removeCoveredIntervals(vector<vector<int>>&v) {\\n             \\n         int n=v.size();\\n         sort(all(v),cmp);\\n         int cnt=1;\\n         int l=v[0][0],r=v[0][1];\\n        for(int i=1;i<n;i++){\\n            // here no need to check for left value as we have sorted left value in ascending order\\n            // so it will always less than current one\\n            if(v[i][1]>r){\\n                // when we get right greater than previous one we increment count by 1\\n                // and set right value to current one\\n                cnt++;\\n                r=v[i][1];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786948,
                "title": "python-solution-sort-simple-2-approaches",
                "content": "**Approach 1:**\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        each = 0\\n        while each < len(intervals)-1:\\n            first, second = intervals[each], intervals[each+1]\\n            if first[0]>=second[0] and first[1]<=second[1]:\\n                intervals.pop(each)\\n            elif first[0]<=second[0] and first[1]>=second[1]:\\n                intervals.pop(each+1)\\n            else:\\n                each+=1\\n        return len(intervals)\\n```\\n\\n**Approach 2:**\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda i:(i[0], -i[1]))\\n        result = [intervals[0]]\\n        for l, r in intervals[1:]:\\n            prevL, prevR = result[-1]\\n            if prevL <= l and prevR >= r:\\n                continue\\n            result.append([l, r])\\n        return len(result)\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()\\n        each = 0\\n        while each < len(intervals)-1:\\n            first, second = intervals[each], intervals[each+1]\\n            if first[0]>=second[0] and first[1]<=second[1]:\\n                intervals.pop(each)\\n            elif first[0]<=second[0] and first[1]>=second[1]:\\n                intervals.pop(each+1)\\n            else:\\n                each+=1\\n        return len(intervals)\\n```\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda i:(i[0], -i[1]))\\n        result = [intervals[0]]\\n        for l, r in intervals[1:]:\\n            prevL, prevR = result[-1]\\n            if prevL <= l and prevR >= r:\\n                continue\\n            result.append([l, r])\\n        return len(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786160,
                "title": "c-o-nlogn-custom-2d-vector-sort",
                "content": "Approach: \\n* Sort the given list where left is ascending order and right is descending order\\n* Traverse the sorted list and compare with previous position of the list. \\n* If the right interval of previous position is smaller than the current position, save the previous position and increase the result by 1.\\n```\\nbool cmp (const vector<int>& left, const vector<int>& right)\\n    {\\n        if(left[0] != right[0])\\n            return left[0] < right[0];\\n        return left[1] > right[1];\\n    }\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int intervalCount = intervals.size();\\n        int result = 1, prevPos = 0;\\n        for(int i = 1; i<intervalCount; i++){\\n            if(intervals[i][1] > intervals[prevPos][1]){\\n                prevPos = i, result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool cmp (const vector<int>& left, const vector<int>& right)\\n    {\\n        if(left[0] != right[0])\\n            return left[0] < right[0];\\n        return left[1] > right[1];\\n    }\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        int intervalCount = intervals.size();\\n        int result = 1, prevPos = 0;\\n        for(int i = 1; i<intervalCount; i++){\\n            if(intervals[i][1] > intervals[prevPos][1]){\\n                prevPos = i, result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785828,
                "title": "simple-solution",
                "content": "Simple solution using for loop.\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    let count = intervals.length\\n    for (var [index1, i1] of intervals.entries()) {\\n        for (var [index2, i2] of intervals.entries()) {\\n            if (index2 !== index1) {\\n                if (i2[0] <= i1[0] && i1[1] <= i2[1]) {\\n                    count--\\n                    break\\n                }   \\n            }\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar removeCoveredIntervals = function(intervals) {\\n    let count = intervals.length\\n    for (var [index1, i1] of intervals.entries()) {\\n        for (var [index2, i2] of intervals.entries()) {\\n            if (index2 !== index1) {\\n                if (i2[0] <= i1[0] && i1[1] <= i2[1]) {\\n                    count--\\n                    break\\n                }   \\n            }\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785721,
                "title": "simple-java-solution-with-explaination-nlogn",
                "content": "Idea is sort the array according to start interval in increasing order. if start is same then use end interval to sort in decreasing order. \\n```\\n\\tprivate int compare(int[] a, int[] b) {\\n\\t\\tif (a[0] == b[0]) {\\n\\t\\t\\treturn b[1] - a[1];\\n\\t\\t}\\n\\t\\treturn a[0] - b[0];\\n\\t}\\n```\\n\\ne.g. ->\\ni/p -> [[1, 2],[1, 4],[3, 4]]\\nsort -> [[1, 4],[1, 2],[3, 4]]\\n\\ni/p->[[1, 4],[3, 6],[2, 8]]\\nsort -> [[1, 4],[2, 8],[3, 6]]\\n\\ni/p -> [[3, 11],[5, 12],[4, 10]]\\nsort-> [[3, 11],[4, 10],[5, 12]]\\n\\nso by this we can see if current element start<=next element start and current element end>= next element end, consume it and increment counter to indicate one element is deleted. as soon as above condition met try to consume as many as we can.\\nbasically check how many elements we can consume with in current element start and end boundary.\\nnow after first iteration we have consumed what max possible. now again repeat same step for next current element start and end.\\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tArrays.sort(intervals, this::compare);\\n\\t\\tint i = 0;\\n\\t\\t//counter to store deleted elements count.\\n\\t\\tint c = 0;\\n\\t\\t//iterate every element\\n\\t\\twhile (i < intervals.length) {\\n\\t\\t//set current element as min and max\\n\\t\\t\\tint min = intervals[i][0];\\n\\t\\t\\tint max = intervals[i][1];\\n\\t\\t\\t//check how many elements we can consume with in current min and max\\n\\t\\t\\twhile (i < intervals.length - 1 && min <= intervals[i + 1][0] && max >= intervals[i + 1][1]) {\\n\\t\\t\\t\\tc++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\t//return length of new array after deletion.\\n\\t\\treturn intervals.length - c;\\n\\t}\\n\\t//sort\\n\\tprivate int compare(int[] a, int[] b) {\\n\\t\\tif (a[0] == b[0]) {\\n\\t\\t\\treturn b[1] - a[1];\\n\\t\\t}\\n\\t\\treturn a[0] - b[0];\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n\\tprivate int compare(int[] a, int[] b) {\\n\\t\\tif (a[0] == b[0]) {\\n\\t\\t\\treturn b[1] - a[1];\\n\\t\\t}\\n\\t\\treturn a[0] - b[0];\\n\\t}\\n```\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tArrays.sort(intervals, this::compare);\\n\\t\\tint i = 0;\\n\\t\\t//counter to store deleted elements count.\\n\\t\\tint c = 0;\\n\\t\\t//iterate every element\\n\\t\\twhile (i < intervals.length) {\\n\\t\\t//set current element as min and max\\n\\t\\t\\tint min = intervals[i][0];\\n\\t\\t\\tint max = intervals[i][1];\\n\\t\\t\\t//check how many elements we can consume with in current min and max\\n\\t\\t\\twhile (i < intervals.length - 1 && min <= intervals[i + 1][0] && max >= intervals[i + 1][1]) {\\n\\t\\t\\t\\tc++;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\t//return length of new array after deletion.\\n\\t\\treturn intervals.length - c;\\n\\t}\\n\\t//sort\\n\\tprivate int compare(int[] a, int[] b) {\\n\\t\\tif (a[0] == b[0]) {\\n\\t\\t\\treturn b[1] - a[1];\\n\\t\\t}\\n\\t\\treturn a[0] - b[0];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1785524,
                "title": "c-solution-using-vector-of-pair",
                "content": "The intuition is that first we need first element as small as possible and second element as large as possible .\\nSo we make a pair and sort it by first element in ascending order and second element in descending order using a comparator.\\nThen simply iterate through all elements and whenever we get second element greater than previous greater we update mx and increase ans.\\n\\nTime complexity: time to sort the pair ```O(sort)```.\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Comparator to sort pair by first element in ascending order  and then by second element in descending order\\n    \\n    template<typename P> struct Cmp \\n{ \\n    bool operator()(const P &p1, const P &p2) \\n    { \\n        if(p1.first < p2.first) return true; \\n        if(p1.first == p2.first) return p1.second > p2.second; \\n        return false; \\n    } \\n};\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        vector<pair<int,int>>p;\\n        for(int i=0;i<n;i++){\\n            p.push_back({intervals[i][0],intervals[i][1]});\\n        }\\n        sort(p.begin(),p.end(),Cmp<pair<int,int>>());\\n        int mx=p[0].second;\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            if(p[i].second>mx){\\n                mx=p[i].second;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nfurther the question can be dveloped to return the intervals which remains after removing covered elements.\\nIn this case we can modify pair and comparator accordingly ,here we use pair of pair to store index of intervals so that we can obtain original sequence.\\nAnd store ans in another vector.\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    template<typename P> struct Cmp \\n{ \\n    bool operator()(const P &p1, const P &p2) \\n    { \\n        if(p1.first < p2.first) return true; \\n        if(p1.first == p2.first) return p1.second.first > p2.second.first; \\n        return false; \\n    } \\n};\\n    vector<vector<int>> removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        int temp[n];\\n        vector<pair<int,pair<int,int>>>p;\\n        for(int i=0;i<n;i++){\\n            temp[i]=1;\\n            p.push_back({intervals[i][0],{intervals[i][1],i}});\\n        }\\n        sort(p.begin(),p.end(),Cmp<pair<int,pair<int,int>>>());\\n        int mx=p[0].second.first;\\n        for(int i=1;i<n;i++){\\n            if(p[i].second.first>mx){\\n                mx=p[i].second.first;\\n            }else{\\n                temp[p[i].second.second]=0;\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++){\\n            if(temp[i]!=0)\\n                ans.push_back({intervals[i][0],intervals[i][1]});\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease do upvote if helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```O(sort)```\n```\\nclass Solution {\\npublic:\\n    \\n    // Comparator to sort pair by first element in ascending order  and then by second element in descending order\\n    \\n    template<typename P> struct Cmp \\n{ \\n    bool operator()(const P &p1, const P &p2) \\n    { \\n        if(p1.first < p2.first) return true; \\n        if(p1.first == p2.first) return p1.second > p2.second; \\n        return false; \\n    } \\n};\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        vector<pair<int,int>>p;\\n        for(int i=0;i<n;i++){\\n            p.push_back({intervals[i][0],intervals[i][1]});\\n        }\\n        sort(p.begin(),p.end(),Cmp<pair<int,int>>());\\n        int mx=p[0].second;\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            if(p[i].second>mx){\\n                mx=p[i].second;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    template<typename P> struct Cmp \\n{ \\n    bool operator()(const P &p1, const P &p2) \\n    { \\n        if(p1.first < p2.first) return true; \\n        if(p1.first == p2.first) return p1.second.first > p2.second.first; \\n        return false; \\n    } \\n};\\n    vector<vector<int>> removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size();\\n        int temp[n];\\n        vector<pair<int,pair<int,int>>>p;\\n        for(int i=0;i<n;i++){\\n            temp[i]=1;\\n            p.push_back({intervals[i][0],{intervals[i][1],i}});\\n        }\\n        sort(p.begin(),p.end(),Cmp<pair<int,pair<int,int>>>());\\n        int mx=p[0].second.first;\\n        for(int i=1;i<n;i++){\\n            if(p[i].second.first>mx){\\n                mx=p[i].second.first;\\n            }else{\\n                temp[p[i].second.second]=0;\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(int i=0;i<n;i++){\\n            if(temp[i]!=0)\\n                ans.push_back({intervals[i][0],intervals[i][1]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785482,
                "title": "c-80-faster-2-pointers-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool static com(vector<int>&a,vector<int>&b)\\n    {\\n        if(a[0]==b[0])\\n        {\\n            return a[1]>b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& box) \\n    {\\n        //diamond notes\\n        //sort as mentioned above \\n        //and then make 2 pointers i=1,j=1,and check if condtions satisfy then do i++ until it is satisfied and then do c++ and put some conditons for edge cases.\\n        sort(box.begin(),box.end(),com);\\n        int c=0;\\n        int i=1;\\n        int j=0;\\n        bool ch=true;\\n        while(i<box.size() && j<box.size())\\n        {\\n            while(i<box.size() && box[j][0]<=box[i][0] && box[j][1]>=box[i][1])\\n            {\\n                ch=false;\\n                i++;\\n            }\\n            c++;\\n            j=i;\\n            i++;\\n        }\\n        if(j<box.size())c++;\\n        if(c==0)return 1;\\n        if(ch)return box.size();\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static com(vector<int>&a,vector<int>&b)\\n    {\\n        if(a[0]==b[0])\\n        {\\n            return a[1]>b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& box) \\n    {\\n        //diamond notes\\n        //sort as mentioned above \\n        //and then make 2 pointers i=1,j=1,and check if condtions satisfy then do i++ until it is satisfied and then do c++ and put some conditons for edge cases.\\n        sort(box.begin(),box.end(),com);\\n        int c=0;\\n        int i=1;\\n        int j=0;\\n        bool ch=true;\\n        while(i<box.size() && j<box.size())\\n        {\\n            while(i<box.size() && box[j][0]<=box[i][0] && box[j][1]>=box[i][1])\\n            {\\n                ch=false;\\n                i++;\\n            }\\n            c++;\\n            j=i;\\n            i++;\\n        }\\n        if(j<box.size())c++;\\n        if(c==0)return 1;\\n        if(ch)return box.size();\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785129,
                "title": "memory-100-00-time-24-ms-in-c-very-simple-solution-inline-sort",
                "content": "If first value is equal then we will check second value.\\n\\n\\u2B06\\uFE0F **Please Upvote**\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& v) {\\n        \\n        \\n        sort( v.begin( ), v.end( ), [ ]( const auto& lhs, const auto& rhs )\\n            {\\n                if(lhs[0] == rhs[0]) return lhs[1] > rhs[1];\\n                return lhs[0] < rhs[0];\\n            });\\n        \\n        \\n        int n = v.size(), ans = 1, pos = 0;\\n        for(int i = 1; i<n; i++) {\\n            if(v[i][1] <= v[pos][1]) continue;\\n            ++ans;\\n            pos = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& v) {\\n        \\n        \\n        sort( v.begin( ), v.end( ), [ ]( const auto& lhs, const auto& rhs )\\n            {\\n                if(lhs[0] == rhs[0]) return lhs[1] > rhs[1];\\n                return lhs[0] < rhs[0];\\n            });\\n        \\n        \\n        int n = v.size(), ans = 1, pos = 0;\\n        for(int i = 1; i<n; i++) {\\n            if(v[i][1] <= v[pos][1]) continue;\\n            ++ans;\\n            pos = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780969,
                "title": "python-simple-solution-easy-90-fast-and-space",
                "content": "```\\n\\t    inte.sort(key=lambda x:x[0])\\n        count=0\\n        for i in range(1,len(inte)):\\n            if inte[i-1][0]<=inte[i][0] and inte[i-1][1]>=inte[i][1]:\\n                inte[i]=inte[i-1]\\n                count+=1\\n            elif inte[i-1][0]==inte[i][0] and inte[i-1][1]<=inte[i][1]:\\n                count+=1\\n        return len(inte)-count\\n```",
                "solutionTags": [],
                "code": "```\\n\\t    inte.sort(key=lambda x:x[0])\\n        count=0\\n        for i in range(1,len(inte)):\\n            if inte[i-1][0]<=inte[i][0] and inte[i-1][1]>=inte[i][1]:\\n                inte[i]=inte[i-1]\\n                count+=1\\n            elif inte[i-1][0]==inte[i][0] and inte[i-1][1]<=inte[i][1]:\\n                count+=1\\n        return len(inte)-count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429212,
                "title": "two-golang-solutions-with-images-for-explanation",
                "content": "In both of these solutions we sort `intervals` by the following:\\n\\n* If `intervals[i][0]` equals `intervals[j][0]` we can return the decending order of `intervals[i][1]` and `intervals[j][1]`.\\n* else, we can return the increasing order of `intervals[i][0]`, and `intervals[j][0]`.\\n\\nSince we sort `intervals` by their start values. For example, we don\\'t have to worry about `c <= a` if we have the intervals `[a, b)`, and `[c, d)`.\\n\\nAnd since we have sorted `intervals` by their end values if their start values are equal. All we have to do is check whether `d >= b` if we have the intervals `[a, b)`, and `[c, d)`. \\n\\n**Solution One:**\\n---\\n\\nIn this solution, we remove intervals from `intervals`.\\n\\n![](https://i.imgur.com/gqLasto.png)\\n\\n``` go\\nfunc removeCoveredIntervals(intervals [][]int) int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        if intervals[i][0] == intervals[j][0] {\\n            return intervals[i][1] > intervals[j][1]\\n        }\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    for i := 0; i < len(intervals) - 1; i++ {\\n        if intervals[i][1] >= intervals[i + 1][1] {\\n            intervals = append(intervals[:i + 1], intervals[i + 2:]...)\\n            i--\\n        }\\n    }\\n    return len(intervals)\\n}\\n```\\n\\n**Solution 2:**\\n---\\n\\nIn this solution, we just count the remaining intervals.\\n\\n![image](https://assets.leetcode.com/users/images/cc8fcb19-0d9b-4763-8dbd-193c6d0f08aa_1630075203.7147284.png)\\n\\n``` go\\nfunc removeCoveredIntervals(intervals [][]int) int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        if intervals[i][0] == intervals[j][0] {\\n            return intervals[i][1] > intervals[j][1]\\n        }\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    end, res := 0, 0\\n    \\n    for _, interval := range intervals {\\n        if interval[1] > end {\\n            end = interval[1]\\n            res++\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc removeCoveredIntervals(intervals [][]int) int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        if intervals[i][0] == intervals[j][0] {\\n            return intervals[i][1] > intervals[j][1]\\n        }\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    for i := 0; i < len(intervals) - 1; i++ {\\n        if intervals[i][1] >= intervals[i + 1][1] {\\n            intervals = append(intervals[:i + 1], intervals[i + 2:]...)\\n            i--\\n        }\\n    }\\n    return len(intervals)\\n}\\n```\n``` go\\nfunc removeCoveredIntervals(intervals [][]int) int {\\n    sort.Slice(intervals, func(i, j int) bool {\\n        if intervals[i][0] == intervals[j][0] {\\n            return intervals[i][1] > intervals[j][1]\\n        }\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    end, res := 0, 0\\n    \\n    for _, interval := range intervals {\\n        if interval[1] > end {\\n            end = interval[1]\\n            res++\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127260,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-log-n-time-o-1-space",
                "content": "**Explanation**\\nThe idea is to sort the array in ascending order in regards to the start value of each interval. This guarantees that each interval to the right of a given interval has a start value which is either equal to or greater than the given start value.\\nIntervals with the same start value are sorted in descending order in regards to the end value within their bucket (a subarray consisting of intervals with the same start value). If we examine the first interval of a bucket, we will achieve a maximum converage within the bucket.\\n\\nAfter sorting, we loop through the intervals from left to right and check if the end value of each interval is greater than the currently highest one. If this is the case, the interval with the previously highest end value does not cover the given interval so it does not need to be removed. The highest end value will then be replaced by the given one, again guaranteeing a maximum coverage because the higher the end value, the more candidates might be covered by the given interval.\\nIn any other case, a coverage is given and a deletion will be required.\\n________________________\\n**Definitions**\\n`n`: Size of the input list.\\n________________________\\n**Runtime Complexity**\\n`O(n * log(n))` (sort).\\n_______________________\\n**Space Complexity**\\n`O(1)`\\n_______________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[0], -x[1],))\\n        output = len(intervals)\\n        end = intervals[0][1]\\n        \\n        for i in range(1, len(intervals)):\\n            if intervals[i][1] <= end:\\n                output -= 1\\n            else:\\n                end = intervals[i][1]\\n                \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[0], -x[1],))\\n        output = len(intervals)\\n        end = intervals[0][1]\\n        \\n        for i in range(1, len(intervals)):\\n            if intervals[i][1] <= end:\\n                output -= 1\\n            else:\\n                end = intervals[i][1]\\n                \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879224,
                "title": "python-3-solution-with-a-detailed-walk-through",
                "content": "While the solution has more lines of codes than the official, this one feels more natural in case of a real interview.\\n\\n**Idea**:\\nWe will count intervals ```cnt``` that are overlapped. Then the result with be ```len(intervals) - cnt```.\\nWe sort ```intervals``` by the first element and by the negative value of the last element. Thus, we ensure that the first interval in sorted ```intervals``` will be an interval that starts the earliest but goes as far right as possible. \\n\\n*Example: between [8, 21] and [8, 23], the element [8, 23] will go first because it\\'s wider.*\\n\\nThen we initialize ```curr_st``` and ```curr_end```: current start and current end. They\\'re equal to the borders of the first element.\\nIn a loop, let\\'s compare consecutive elements\\' borders with ```curr_st``` and ```curr_end```. If we see that the whole element lays between ```curr_st``` and ```curr_end```, then we will increment ```cnt```.\\nThe trickly part is how to move ```curr_st``` and ```curr_end``` along the list. Apparently, we will move ```curr_st``` in any case but will move ```curr_end``` iff the right border of the list\\'s element is larger than the current value of ```curr_end``` (because we want to have ```curr_end``` as far right as possible in order to capture next elements that potentially will start and end before ```curr_end```). \\n\\n```\\ndef removeCoveredIntervals(intervals):\\n    cnt = 0\\n    intervals.sort(key = lambda x: (x[0], -x[1]))\\n    curr_st, curr_end = intervals[0][0], intervals[0][1]\\n    for interval in intervals[1:]:\\n        if curr_st <= interval[0] < curr_end and curr_st < interval[1] <= curr_end:\\n            cnt += 1\\n        curr_st = interval[0]\\n        curr_end = max(curr_end, interval[1])\\n    return len(intervals) - cnt\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```cnt```\n```len(intervals) - cnt```\n```intervals```\n```intervals```\n```curr_st```\n```curr_end```\n```curr_st```\n```curr_end```\n```curr_st```\n```curr_end```\n```cnt```\n```curr_st```\n```curr_end```\n```curr_st```\n```curr_end```\n```curr_end```\n```curr_end```\n```curr_end```\n```\\ndef removeCoveredIntervals(intervals):\\n    cnt = 0\\n    intervals.sort(key = lambda x: (x[0], -x[1]))\\n    curr_st, curr_end = intervals[0][0], intervals[0][1]\\n    for interval in intervals[1:]:\\n        if curr_st <= interval[0] < curr_end and curr_st < interval[1] <= curr_end:\\n            cnt += 1\\n        curr_st = interval[0]\\n        curr_end = max(curr_end, interval[1])\\n    return len(intervals) - cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 878686,
                "title": "100-faster-c-36ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& a) {\\n        \\n        sort(a.begin(),a.end(),[](const vector<int>& x,const vector<int>& y){\\n            return x[0] < y[0]; \\n        });\\n        \\n        int s = a[0][0];\\n        int e = a[0][1];\\n        \\n        int c = a.size();\\n        \\n        for(int i=1;i<a.size();i++){\\n            if(s == a[i][0]){\\n                c--;\\n                e = max(e,a[i][1]);\\n            }\\n            else if(e == a[i][1]){\\n                c--;\\n                s = min(s,a[i][0]);\\n            }\\n            else if(s < a[i][0] && e > a[i][1]){\\n                c--;\\n                s = min(s,a[i][0]);\\n                e = max(e,a[i][1]);\\n            }\\n            else {\\n                s = a[i][0];\\n                e = a[i][1];\\n            }\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& a) {\\n        \\n        sort(a.begin(),a.end(),[](const vector<int>& x,const vector<int>& y){\\n            return x[0] < y[0]; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 878216,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        totalIntervals = len(intervals)\\n        for i in range(len(intervals)):\\n            for j in range(len(intervals)):\\n                if j!=i:\\n                    if intervals[j][0]<=intervals[i][0] and intervals[j][1]>=intervals[i][1]:\\n                        totalIntervals-=1\\n                        break\\n        return totalIntervals\\n                    \\n            \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        totalIntervals = len(intervals)\\n        for i in range(len(intervals)):\\n            for j in range(len(intervals)):\\n                if j!=i:\\n                    if intervals[j][0]<=intervals[i][0] and intervals[j][1]>=intervals[i][1]:\\n                        totalIntervals-=1\\n                        break\\n        return totalIntervals\\n                    \\n            \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 878123,
                "title": "java-heap-4-ms",
                "content": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        public int x, y;\\n        \\n        public Pair(int a, int b){\\n            this.x = a;\\n            this.y = b;\\n        }\\n        \\n        public int compareTo(Pair p){\\n            if(this.x == p.x)\\n                return p.y - this.y;   // if x matches then sort in descending order of y\\n            else\\n                return this.x - p.x;   // else sort in ascending order of x\\n        }\\n    }\\n    \\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int N = intervals.length;\\n        int i;\\n        PriorityQueue<Pair> queue = new PriorityQueue<Pair>();\\n        \\n        for(i = 0; i < N; i++){\\n            queue.offer(new Pair(intervals[i][0], intervals[i][1]));\\n        }\\n        \\n        Pair latest = new Pair(Integer.MIN_VALUE, Integer.MIN_VALUE);\\n        int count = 0;\\n        Pair p = null;\\n        \\n        while(!queue.isEmpty()){\\n            p = queue.poll();\\n            // check if p is NOT inside latest\\n            if(count == 0 || !(latest.x <= p.x && latest.y >= p.y)){\\n                latest = p;\\n                ++count;\\n            }\\n        }\\n    \\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair implements Comparable<Pair>{\\n        public int x, y;\\n        \\n        public Pair(int a, int b){\\n            this.x = a;\\n            this.y = b;\\n        }\\n        \\n        public int compareTo(Pair p){\\n            if(this.x == p.x)\\n                return p.y - this.y;   // if x matches then sort in descending order of y\\n            else\\n                return this.x - p.x;   // else sort in ascending order of x\\n        }\\n    }\\n    \\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int N = intervals.length;\\n        int i;\\n        PriorityQueue<Pair> queue = new PriorityQueue<Pair>();\\n        \\n        for(i = 0; i < N; i++){\\n            queue.offer(new Pair(intervals[i][0], intervals[i][1]));\\n        }\\n        \\n        Pair latest = new Pair(Integer.MIN_VALUE, Integer.MIN_VALUE);\\n        int count = 0;\\n        Pair p = null;\\n        \\n        while(!queue.isEmpty()){\\n            p = queue.poll();\\n            // check if p is NOT inside latest\\n            if(count == 0 || !(latest.x <= p.x && latest.y >= p.y)){\\n                latest = p;\\n                ++count;\\n            }\\n        }\\n    \\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645755,
                "title": "sort-and-stack",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:x[0])\\n        remaining = []\\n        for interval in intervals:\\n            if not remaining:\\n                remaining.append(interval)\\n            else:\\n                prev = remaining[-1]\\n                if prev[0] == interval[0] and prev[1] < interval[1]:\\n                    remaining.pop()\\n                if prev[1] < interval[1]:\\n                    remaining.append(interval)\\n                \\n        return len(remaining)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:x[0])\\n        remaining = []\\n        for interval in intervals:\\n            if not remaining:\\n                remaining.append(interval)\\n            else:\\n                prev = remaining[-1]\\n                if prev[0] == interval[0] and prev[1] < interval[1]:\\n                    remaining.pop()\\n                if prev[1] < interval[1]:\\n                    remaining.append(interval)\\n                \\n        return len(remaining)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558963,
                "title": "c-its-more-like-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int count=0;\\n        int len=intervals.size();\\n        int flag=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            flag=0;\\n            for(int j=i-1;j>=0 && flag==0;j--)\\n            {\\n                if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<=intervals[j][1] )\\n                {\\n                    count++;\\n                    flag=1;\\n                }\\n            }\\n            for(int j=i+1;j<len && flag==0;j++)\\n            {\\n                if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<=intervals[j][1] )\\n                {\\n                    count++;\\n                    flag=1;\\n                }\\n            }\\n        }\\n        return len-count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int count=0;\\n        int len=intervals.size();\\n        int flag=0;\\n        for(int i=0;i<len;i++)\\n        {\\n            flag=0;\\n            for(int j=i-1;j>=0 && flag==0;j--)\\n            {\\n                if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<=intervals[j][1] )\\n                {\\n                    count++;\\n                    flag=1;\\n                }\\n            }\\n            for(int j=i+1;j<len && flag==0;j++)\\n            {\\n                if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<=intervals[j][1] )\\n                {\\n                    count++;\\n                    flag=1;\\n                }\\n            }\\n        }\\n        return len-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505856,
                "title": "easy-cpp-solution-sort-runtime-99-memory-usage-100",
                "content": "```\\nint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b) {\\n            if (a[0] != b[0]) return a[0] < b[0];\\n            return a[1] - a[0] >= b[1] - b[0];\\n        });\\n        int cnt = 1, left = intervals[0][0], right = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] == left && intervals[i][1] > right) {\\n                right = intervals[i][1];\\n            } else if (intervals[i][0] > left  && intervals[i][1] > right) {\\n                cnt++;\\n                left = intervals[i][0];\\n                right = intervals[i][1];\\n            }\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [],
                "code": "```\\nint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), [](vector<int> &a, vector<int> &b) {\\n            if (a[0] != b[0]) return a[0] < b[0];\\n            return a[1] - a[0] >= b[1] - b[0];\\n        });\\n        int cnt = 1, left = intervals[0][0], right = intervals[0][1];\\n        for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][0] == left && intervals[i][1] > right) {\\n                right = intervals[i][1];\\n            } else if (intervals[i][0] > left  && intervals[i][1] > right) {\\n                cnt++;\\n                left = intervals[i][0];\\n                right = intervals[i][1];\\n            }\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 505817,
                "title": "simple-java-solution-with-priority-queue",
                "content": "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> a[0] - b[0]);\\n        \\n        for(int[] interval : intervals)\\n            pq.offer(interval);\\n        \\n        int[] latest = {-1,-1};\\n        int count = 0;\\n        while(!pq.isEmpty())\\n        {\\n           int[] polled = pq.poll(); \\n           if(count == 0 || !(latest[0] <= polled[0] && latest[1] >= polled[1]))\\n           {\\n               latest = polled;\\n               count++;\\n           }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> a[0] - b[0]);\\n        \\n        for(int[] interval : intervals)\\n            pq.offer(interval);\\n        \\n        int[] latest = {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 471735,
                "title": "c-clear-concise-70-90",
                "content": "Basic idea: \\n- Sort \\n- Loop through the intervals: decrease the counter (# intervals after removal) when the max end is no less than the end of the current interval\\n\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int res = intervals.size(), mx = 0;\\n        sort(intervals.begin(), intervals.end());\\n        for (auto& v: intervals) {\\n            if (mx >= v[1]) \\n                res--;\\n            else\\n                mx = v[1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int res = intervals.size(), mx = 0;\\n        sort(intervals.begin(), intervals.end());\\n        for (auto& v: intervals) {\\n            if (mx >= v[1]) \\n                res--;\\n            else\\n                mx = v[1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464407,
                "title": "a-simple-java-solution-faster-than-90-34-accepted-runtime-5-ms",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,new Comparator<int[]>(){\\n           public int compare(int[] o1,int[] o2){\\n               // return o1[0]-o2[0];\\n\\t\\t\\t   return o1[0]-o2[0]!=0?o1[0]-o2[0]:o2[1]-o1[1];\\n           } \\n        });\\n        int max=intervals[0][1];\\n        int ret=intervals.length;\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[i][1]<=max){\\n                ret--;\\n            }else{\\n                max=intervals[i][1];\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,new Comparator<int[]>(){\\n           public int compare(int[] o1,int[] o2){\\n               // return o1[0]-o2[0];\\n\\t\\t\\t   return o1[0]-o2[0]!=0?o1[0]-o2[0]:o2[1]-o1[1];\\n           } \\n        });\\n        int max=intervals[0][1];\\n        int ret=intervals.length;\\n        for(int i=1;i<intervals.length;i++){\\n            if(intervals[i][1]<=max){\\n                ret--;\\n            }else{\\n                max=intervals[i][1];\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451362,
                "title": "java-solution-with-and-without-sort",
                "content": "**With sorting**:\\n\\nSorting makes it obvious that we get smallest intervals first and just keep mapping the previous big interval and the current interval to get the solution.\\n```\\nclass Solution {\\n    static class Data{\\n        int x,y;\\n        Data(int x,int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Data[] d = new Data[intervals.length];\\n        for(int i=0;i<intervals.length;++i) d[i] = new Data(intervals[i][0],intervals[i][1]);\\n        Arrays.sort(d,new Comparator<Data>(){\\n            public int compare(Data d1,Data d2){\\n                if(d1.x < d2.x) return -1;\\n                if(d2.x < d1.x) return 1;\\n                return -1 * (d1.y - d2.y);\\n            }\\n        });\\n        \\n        int rem = 1,prev = 0;\\n        \\n        for(int i=1;i<d.length;++i){\\n            if(d[i].x >= d[prev].x && d[i].y <= d[prev].y) continue;\\n            prev = i;\\n            rem++;\\n        }\\n        \\n        return rem;\\n    }\\n}\\n```\\n\\n**Without Sorting:**\\n\\n* We can make use of the constraints `0 <= intervals[i][0] < intervals[i][1] <= 10^5` a bit.\\n* Every interval has a start and an end.\\n* In this approach, we map the start with it\\'s best end.\\n* So for example, for `[[1,4],[3,6],[2,8],[1,20]]`, the table(as in `pairs` array) would look like:\\n\\n   * 1 => 20\\n   * 2 => 8\\n   * 3 => 6\\n* Now, we just percolate down from `1` to `3` keeping the best end at hand.\\n* In the above example, we keep `20` with us first. Since it annihilates everything, it is the only interval that remains. \\n* If we get a new end greater than the current one, we update the `prev` in the below code accordingly.\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n       int[] pairs = new int[100001];\\n       int start = -1,end = -1;\\n       for(int i=0;i<intervals.length;++i){\\n           pairs[intervals[i][0]] = Math.max(pairs[intervals[i][0]],intervals[i][1]);\\n           if(start == -1 || start > intervals[i][0]) start = intervals[i][0];\\n           if(end == -1 || end < intervals[i][1]) end = intervals[i][1];\\n       } \\n        \\n       int rem = 0,prev = 0;\\n       for(int i=start;i<=end;++i){\\n           if(pairs[i] > prev){\\n               rem++;\\n               prev = pairs[i];\\n           }\\n       } \\n        \\n       return rem; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static class Data{\\n        int x,y;\\n        Data(int x,int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Data[] d = new Data[intervals.length];\\n        for(int i=0;i<intervals.length;++i) d[i] = new Data(intervals[i][0],intervals[i][1]);\\n        Arrays.sort(d,new Comparator<Data>(){\\n            public int compare(Data d1,Data d2){\\n                if(d1.x < d2.x) return -1;\\n                if(d2.x < d1.x) return 1;\\n                return -1 * (d1.y - d2.y);\\n            }\\n        });\\n        \\n        int rem = 1,prev = 0;\\n        \\n        for(int i=1;i<d.length;++i){\\n            if(d[i].x >= d[prev].x && d[i].y <= d[prev].y) continue;\\n            prev = i;\\n            rem++;\\n        }\\n        \\n        return rem;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n       int[] pairs = new int[100001];\\n       int start = -1,end = -1;\\n       for(int i=0;i<intervals.length;++i){\\n           pairs[intervals[i][0]] = Math.max(pairs[intervals[i][0]],intervals[i][1]);\\n           if(start == -1 || start > intervals[i][0]) start = intervals[i][0];\\n           if(end == -1 || end < intervals[i][1]) end = intervals[i][1];\\n       } \\n        \\n       int rem = 0,prev = 0;\\n       for(int i=start;i<=end;++i){\\n           if(pairs[i] > prev){\\n               rem++;\\n               prev = pairs[i];\\n           }\\n       } \\n        \\n       return rem; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451265,
                "title": "sort-interval-compare-java",
                "content": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)->(a[0]-b[0]!=0?a[0]-b[0]:b[1]-a[1]));\\n        int n = intervals.length;\\n        int[] first = intervals[0];\\n        int count=1;\\n        for(int i=1;i<n;i++) {\\n            if(!covers(first,intervals[i])) {\\n                first = intervals[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private boolean covers(int[] a,int[] b) {\\n        return a[0]<=b[0] && a[1]>=b[1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a,b)->(a[0]-b[0]!=0?a[0]-b[0]:b[1]-a[1]));\\n        int n = intervals.length;\\n        int[] first = intervals[0];\\n        int count=1;\\n        for(int i=1;i<n;i++) {\\n            if(!covers(first,intervals[i])) {\\n                first = intervals[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private boolean covers(int[] a,int[] b) {\\n        return a[0]<=b[0] && a[1]>=b[1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3268710,
                "title": "c-sorting-nlogn",
                "content": "Sort the intervals according to their start time and for case where we start time is same, keep intervals befor whose end is greater, as it might cover more intervals with same start time. Not process these intervals and maintain what is the max current interval end point and its coresponding start time. Now if an interval overlaps increment the count and our max interval will remain same else update the mx interval to the current interval \\n\\nSee the diagram to visualise it.\\n\\n![image](https://assets.leetcode.com/users/images/52520111-364c-47c9-85ac-ffc6f64fca41_1678194732.8177066.png)\\n\\nCode \\n\\n```\\nbool comp(vector<int>A, vector<int>B){\\n        if(A[0] == B[0])\\n            return A[1] > B[1];\\n        return A[0] < B[0] ;\\n    }\\n\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(),comp) ;\\n        int ans = 0 , n = intervals.size();\\n        pair<int, int>mx = {intervals[0][0], intervals[0][1]};\\n        for(int i = 1 ; i < n; i++){\\n            int start = intervals[i][0], end = intervals[i][1] ;\\n            if(mx.first<=start && mx.second >= end){\\n                ans ++ ;\\n            }\\n            else\\n                mx = {start, end};\\n        }\\n        \\n        return n - ans ;\\n    }\\n};\\n```\\n\\nTC- O(n log n)\\nSc - O(1)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nbool comp(vector<int>A, vector<int>B){\\n        if(A[0] == B[0])\\n            return A[1] > B[1];\\n        return A[0] < B[0] ;\\n    }\\n\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(),comp) ;\\n        int ans = 0 , n = intervals.size();\\n        pair<int, int>mx = {intervals[0][0], intervals[0][1]};\\n        for(int i = 1 ; i < n; i++){\\n            int start = intervals[i][0], end = intervals[i][1] ;\\n            if(mx.first<=start && mx.second >= end){\\n                ans ++ ;\\n            }\\n            else\\n                mx = {start, end};\\n        }\\n        \\n        return n - ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613415,
                "title": "python-solution-simple-sorting",
                "content": "```\\nclass Solution:\\n    # Sort the intervals by beginning, with end reversed, so that the larger one with occur before the smaller one\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: [x[0], -x[1]])\\n        result, start_old, end_old = 0, -float(\\'inf\\'), -float(\\'inf\\')\\n        for start, end in intervals:\\n            if not end <= end_old:\\n                result += 1\\n                start_old, end_old = start, end\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Sort the intervals by beginning, with end reversed, so that the larger one with occur before the smaller one\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: [x[0], -x[1]])\\n        result, start_old, end_old = 0, -float(\\'inf\\'), -float(\\'inf\\')\\n        for start, end in intervals:\\n            if not end <= end_old:\\n                result += 1\\n                start_old, end_old = start, end\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518941,
                "title": "easy-python-stack-solution",
                "content": "```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        res=[]\\n        for i in sorted(intervals,key=lambda x:(x[1],-x[0])):\\n           while res and i[0]<=res[-1][0] and i[1]>=res[-1][1]:\\n                res.pop()\\n           res.append(i)\\n        return len(res)        \\n```",
                "solutionTags": [],
                "code": "```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        res=[]\\n        for i in sorted(intervals,key=lambda x:(x[1],-x[0])):\\n           while res and i[0]<=res[-1][0] and i[1]>=res[-1][1]:\\n                res.pop()\\n           res.append(i)\\n        return len(res)        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2296877,
                "title": "beats-100-percent-cpp-solutions-very-easy",
                "content": "class Solution {\\npublic:\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        if(a[0]>b[0])return false;\\n        if(a[0]==b[0] && b[1]>a[1])return false;\\n        return true;\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        int ans =0;\\n        int n=intervals.size();\\n        int y =intervals[0][1];\\n        for(int i =1;i<n;i++){\\n            if(y>=intervals[i][1]){\\n                ans++;\\n            }\\n            else{\\n                y=intervals[i][1];\\n            }\\n        }\\n        return n-ans;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        if(a[0]>b[0])return false;\\n        if(a[0]==b[0] && b[1]>a[1])return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2215102,
                "title": "simple-concise-c-heap-solution",
                "content": "Similar as the meeting scheduler\\nNote that the current pair don\\'t need to be updated every time.\\nAlso, there are 3 scenarios for whether to remove a pair (whether it is covered )\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        \\n        // Pair< start, end>\\n        // intervals are unique\\n        \\n        /*\\n            Algorithm:\\n            1. Use a min-heap <pair<int, int>> store intervals\\n               Sort by their \"start time\"\\n            2. Iterate until there is only one item in the heap\\n            \\n            3. Each time: pop one interval and compare with top()\\n               - Since pop.first must < top.first:\\n               - If pop.second(end time) > top.second(end time):\\n                 top() is covered by pop. remove top! (pop again)\\n               - count++;\\n               \\n            4. return count;\\n            \\n            Time: 1. build heap 2. iterate\\n                 O((N * logN))\\n            Space: O(N) for heap\\n        */\\n        \\n        \\n        priority_queue< pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\\n        \\n        for(auto interval: intervals){\\n            min_heap.push(make_pair(interval[0], interval[1]));\\n        }\\n        \\n        // At least one interval!\\n        int count=1;\\n      \\n        pair<int, int> cur;    \\n        // Becareful: update cur if needed!\\n        cur = min_heap.top(); min_heap.pop();\\n        \\n        // If only one item, don\\'t enter!\\n        while(!min_heap.empty()){\\n\\n            // Make next_cur the next top of the min_heap every iteration!\\n            pair<int, int> next_cur = min_heap.top();\\n            \\n            // e.g. cur: [2,8]  next_cur: [3,6]          \\n            if(cur.second >= next_cur.second){\\n                // Pop next_cur, cur remains\\n                min_heap.pop();               \\n            }\\n            // e.g. cur: [1,2]  next_cur: [1,4]\\n            else if(cur.first == next_cur.first && cur.second <= next_cur.second){\\n                // remove cur(already popped), update cur to be next_cur!\\n                cur = next_cur; min_heap.pop();  \\n            }\\n            // e.g. cur: [1,4] next_cur: [2,8]\\n            else{\\n                // update cur to be next_cur, count+1\\n                cur = next_cur; min_heap.pop();         \\n                count++;\\n            }\\n        }\\n        \\n        // At least one pair in intervals!\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        \\n        \\n        // Pair< start, end>\\n        // intervals are unique\\n        \\n        /*\\n            Algorithm:\\n            1. Use a min-heap <pair<int, int>> store intervals\\n               Sort by their \"start time\"\\n            2. Iterate until there is only one item in the heap\\n            \\n            3. Each time: pop one interval and compare with top()\\n               - Since pop.first must < top.first:\\n               - If pop.second(end time) > top.second(end time):\\n                 top() is covered by pop. remove top! (pop again)\\n               - count++;\\n               \\n            4. return count;\\n            \\n            Time: 1. build heap 2. iterate\\n                 O((N * logN))\\n            Space: O(N) for heap\\n        */\\n        \\n        \\n        priority_queue< pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\\n        \\n        for(auto interval: intervals){\\n            min_heap.push(make_pair(interval[0], interval[1]));\\n        }\\n        \\n        // At least one interval!\\n        int count=1;\\n      \\n        pair<int, int> cur;    \\n        // Becareful: update cur if needed!\\n        cur = min_heap.top(); min_heap.pop();\\n        \\n        // If only one item, don\\'t enter!\\n        while(!min_heap.empty()){\\n\\n            // Make next_cur the next top of the min_heap every iteration!\\n            pair<int, int> next_cur = min_heap.top();\\n            \\n            // e.g. cur: [2,8]  next_cur: [3,6]          \\n            if(cur.second >= next_cur.second){\\n                // Pop next_cur, cur remains\\n                min_heap.pop();               \\n            }\\n            // e.g. cur: [1,2]  next_cur: [1,4]\\n            else if(cur.first == next_cur.first && cur.second <= next_cur.second){\\n                // remove cur(already popped), update cur to be next_cur!\\n                cur = next_cur; min_heap.pop();  \\n            }\\n            // e.g. cur: [1,4] next_cur: [2,8]\\n            else{\\n                // update cur to be next_cur, count+1\\n                cur = next_cur; min_heap.pop();         \\n                count++;\\n            }\\n        }\\n        \\n        // At least one pair in intervals!\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180568,
                "title": "python-3-solution",
                "content": "class Solution:\\n\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:(x[0], -1*x[1]))\\n        \\n        left = intervals[0][0]\\n        right = intervals[0][1]\\n        \\n        res = 0\\n        \\n        for i in range(1, len(intervals)):\\n            intv = intervals[i]\\n            \\n            #covered intervals\\n            if left <= intv[0] and right >= intv[1]:\\n                res += 1\\n            \\n            #intersected intervals\\n            if right >= intv[0] and right <= intv[1]:\\n                right = intv[1]\\n            \\n            #neither covered nor intersected\\n            if right < intv[0]:\\n                left = intv[0]\\n                right = intv[1]\\n                \\n        return len(intervals) - res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x:(x[0], -1*x[1]))\\n        \\n        left = intervals[0][0]\\n        right = intervals[0][1]\\n        \\n        res = 0\\n        \\n        for i in range(1, len(intervals)):\\n            intv = intervals[i]\\n            \\n            #covered intervals\\n            if left <= intv[0] and right >= intv[1]:\\n                res += 1\\n            \\n            #intersected intervals\\n            if right >= intv[0] and right <= intv[1]:\\n                right = intv[1]\\n            \\n            #neither covered nor intersected\\n            if right < intv[0]:\\n                left = intv[0]\\n                right = intv[1]\\n                \\n        return len(intervals) - res",
                "codeTag": "Java"
            },
            {
                "id": 2093214,
                "title": "java-using-sorting-easy-to-understand",
                "content": "```\\n\\tpublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tint removed = 0;\\n\\t\\tint last = -1;\\n\\n\\t\\t// Sort left ascending, right descending\\n\\t\\tArrays.sort(intervals, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tif (intervals[i][1] <= last) {\\n\\t\\t\\t\\tremoved++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlast = intervals[i][1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn intervals.length - removed;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n\\tpublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tint removed = 0;\\n\\t\\tint last = -1;\\n\\n\\t\\t// Sort left ascending, right descending\\n\\t\\tArrays.sort(intervals, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tif (intervals[i][1] <= last) {\\n\\t\\t\\t\\tremoved++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlast = intervals[i][1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn intervals.length - removed;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067116,
                "title": "super-easy-solution-c",
                "content": "Concept:Just sort the vector and then we will insert element in stack but before inserting we will check if it is over lapping or not.\\nIf yes then we can count it.\\nNow there are 2 case suppose you get example [[1,5],[2,3]] then 2,3 is inside 1,5 and now suppose you get.\\n[[1,4],[1,5]]. It is sorted but you should apply additinal condition because [1,5] covers [1,4].It happens because we sorted it using STL function it sort according to first element.This is a extra case.Now update stack by poping inital top and add new element.\\nEasy Right.\\nHappy LeetCoding.\\nUpvote and comment down below for doubts.\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int c=0;\\n        stack<vector<int>>s;\\n        sort(intervals.begin(),intervals.end());\\n        for(int i=0;i<intervals.size();i++)\\n        {\\n            if(s.empty())\\n                s.push(intervals[i]);\\n            else{\\n                auto top=s.top();\\n                if(top[0]<=intervals[i][0]&&top[1]>=intervals[i][1])\\n                {\\n                    c++;\\n                }\\n                else if(top[0]==intervals[i][0]&&top[1]<=intervals[i][1])\\n                {\\n                    c++;\\n                    s.pop();\\n                    s.push({top[0],intervals[i][1]});\\n                }\\n                else\\n                    s.push(intervals[i]);\\n            }\\n        }\\n        return intervals.size()-c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int c=0;\\n        stack<vector<int>>s;\\n        sort(intervals.begin(),intervals.end());\\n        for(int i=0;i<intervals.size();i++)\\n        {\\n            if(s.empty())\\n                s.push(intervals[i]);\\n            else{\\n                auto top=s.top();\\n                if(top[0]<=intervals[i][0]&&top[1]>=intervals[i][1])\\n                {\\n                    c++;\\n                }\\n                else if(top[0]==intervals[i][0]&&top[1]<=intervals[i][1])\\n                {\\n                    c++;\\n                    s.pop();\\n                    s.push({top[0],intervals[i][1]});\\n                }\\n                else\\n                    s.push(intervals[i]);\\n            }\\n        }\\n        return intervals.size()-c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788542,
                "title": "c-explained-with-comments-easy-solution-sorting-greedy-technique",
                "content": "**Time Complexity: O(n log n)**\\n**Space Complexity: Constant O(1)**\\n\\n**Approach Intution:** The intuition behind using the greedy approach is that we want that the overlapping intervals should be eliminated. In order to find the overlaping intervals we need to find the intervals which lies in the range of the larger intervals, this can be done by maintaining the intervals of the nearby range adjacent to each other. This can be done by applying sorting, but sorting need to be applied strategically which we will see while implementing the solution.\\n```\\nclass Solution {\\nprivate:\\n//here we have made our custom compare function to sort the vector of intervals in such a way that the intervals which starts from the beginning stays at the first\\n//if the two intervals have same starting point then the intervals which has more range will stays at the first position.\\n    static bool cmp(vector<int>a, vector<int>b){\\n\\t//if the starting point of both of them is same then we need to check for the ending point the interval having greater ending point has larger area of coverage and will occupy place before other\\n        if(a[0] == b[0]){\\n            return a[1]>b[1];\\n        }\\n        //first the main priority is to find the smaller starting point out of them \\n        return a[0]<b[0];\\n    }\\n\\t\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        \\n\\t\\t//we have initialized our ans to 1 because there will always be an interval with which other intervals will be compared in the starting.\\n        int ans = 1;\\n\\t\\t//we have decided to start the loop from 1 and 0th indexed interval we have considered ours as the interval which we have to include because there is no one forward to it which can overlap its coverage.\\n        vector<int>previousInterval = intervals[0];\\n        \\n        for(int i = 1; i<intervals.size(); i++){\\n\\t\\t//if the i th(current) interval lies in the range of the previously included interval then no need to include it in our counting \\n\\n//check that we are checking only the exit bound, not the starting bound because we know that the intervals are sorted in increasing order, so the intervals after the current will have the start bound greater than or equal to the one we are holding\\n            if(intervals[i][1]<=previousInterval[1]){\\n                continue;\\n            }\\n\\t\\t\\t\\n//if the i th(current) interval lies in the range of the previously included interval then no need to include it in our counting \\n            else{\\n                ans++;\\n                previousInterval = intervals[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n//here we have made our custom compare function to sort the vector of intervals in such a way that the intervals which starts from the beginning stays at the first\\n//if the two intervals have same starting point then the intervals which has more range will stays at the first position.\\n    static bool cmp(vector<int>a, vector<int>b){\\n\\t//if the starting point of both of them is same then we need to check for the ending point the interval having greater ending point has larger area of coverage and will occupy place before other\\n        if(a[0] == b[0]){\\n            return a[1]>b[1];\\n        }\\n        //first the main priority is to find the smaller starting point out of them \\n        return a[0]<b[0];\\n    }\\n\\t\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), cmp);\\n        \\n\\t\\t//we have initialized our ans to 1 because there will always be an interval with which other intervals will be compared in the starting.\\n        int ans = 1;\\n\\t\\t//we have decided to start the loop from 1 and 0th indexed interval we have considered ours as the interval which we have to include because there is no one forward to it which can overlap its coverage.\\n        vector<int>previousInterval = intervals[0];\\n        \\n        for(int i = 1; i<intervals.size(); i++){\\n\\t\\t//if the i th(current) interval lies in the range of the previously included interval then no need to include it in our counting \\n\\n//check that we are checking only the exit bound, not the starting bound because we know that the intervals are sorted in increasing order, so the intervals after the current will have the start bound greater than or equal to the one we are holding\\n            if(intervals[i][1]<=previousInterval[1]){\\n                continue;\\n            }\\n\\t\\t\\t\\n//if the i th(current) interval lies in the range of the previously included interval then no need to include it in our counting \\n            else{\\n                ans++;\\n                previousInterval = intervals[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787434,
                "title": "python3-heap-easy-implementation-beats-90",
                "content": "```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        events = defaultdict(list)\\n        \\n        for s, e in intervals:\\n            heapq.heappush(events[s], -e)\\n        \\n        res = 0\\n        cur_te = -10 ** 5\\n        for ts in sorted(list(events.keys())):\\n            te = -heapq.heappop(events[ts])\\n            if te > cur_te:\\n                cur_te = te\\n                res += 1\\n                \\n        return res\\n```\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        events = defaultdict(list)\\n        \\n        for s, e in intervals:\\n            heapq.heappush(events[s], -e)\\n        \\n        res = 0\\n        cur_te = -10 ** 5\\n        for ts in sorted(list(events.keys())):\\n            te = -heapq.heappop(events[ts])\\n            if te > cur_te:\\n                cur_te = te\\n                res += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787345,
                "title": "two-java-solutions",
                "content": "## Brute Force\\n**Base idea:** for every interval, check if any other interval covers it.\\n\\nInitially, we assume that no interval is covered, i.e. `remaining -> len(intervals)`. Then, for every interval, we check if any other interval covers it, if it\\'s covered we\\'d have 1 less interval remaining.\\n\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int len = intervals.length;\\n        int remaining = len;\\n        for (int i = 0; i < len; i++) {\\n            int[] a = intervals[i];\\n            for (int j = 0; j < len; j++) {\\n                if (i == j) continue;\\n                \\n                int[] b = intervals[j];\\n                if (aIsCoveredByb(a, b)) {\\n                    remaining--;\\n                    break;\\n                }\\n            }\\n        }\\n        return remaining;\\n    }\\n    \\n    private boolean aIsCoveredByb(int[] a, int[] b) {\\n        return b[0] <= a[0] && a[1] <= b[1];\\n    }\\n}\\n```\\n\\n## Sorting\\n**Base idea:** We should be able to oganize the array in a way that the larger intervals come before, or after the intervals they cover.\\n\\nThe tricky part is finding an appropriate way to sort (at least for me it was). To sort, put the intervals with the lowest lower bounds and the largest higher bounds first. e.g.\\n\\n`[[1,4],[3,6],[2,8],[1,5]] -> sort -> [[1,5],[1,4],[2,8],[3,6]]`\\n\\nThis will put intervals that cover other intervals before the intervals they cover. Now we can fixate the largest interval (the first one) and go from left to right, every time we find an interval it covers, we have one less remaining interval.\\nIf we are met with one interval it doesn\\'t cover, that means we already went through all the intervals covered by the previous `large` interval, and we have a new `large` interval so we fixate it, and keep going until the end of the array. e.g.\\n\\n```\\n[[1,5],[1,4],[1,2],[2,8],[3,6]]\\n   |-----^-----|     |-----|\\n        -1    -1          -1\\n   \\n[[1,4],[2,3],[4,5],[6,7]]\\n   |-----|     |     |\\n        -1\\n```\\n\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) ->  {\\n            int firstDiff = a[0] - b[0];\\n            return firstDiff != 0 ? firstDiff : b[1] - a[1];\\n        });\\n        \\n        int len = intervals.length;\\n        int remaining = len;\\n        for (int i = 0, j = 1; j < len; j++) {\\n            int[] a = intervals[j];\\n            int[] b = intervals[i];\\n            if (aIsCoveredByb(a, b)) remaining--;\\n            else i = j;\\n        }\\n        return remaining;\\n    }\\n\\n    private boolean aIsCoveredByb(int[] a, int[] b) {\\n        return b[0] <= a[0] && a[1] <= b[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int len = intervals.length;\\n        int remaining = len;\\n        for (int i = 0; i < len; i++) {\\n            int[] a = intervals[i];\\n            for (int j = 0; j < len; j++) {\\n                if (i == j) continue;\\n                \\n                int[] b = intervals[j];\\n                if (aIsCoveredByb(a, b)) {\\n                    remaining--;\\n                    break;\\n                }\\n            }\\n        }\\n        return remaining;\\n    }\\n    \\n    private boolean aIsCoveredByb(int[] a, int[] b) {\\n        return b[0] <= a[0] && a[1] <= b[1];\\n    }\\n}\\n```\n```\\n[[1,5],[1,4],[1,2],[2,8],[3,6]]\\n   |-----^-----|     |-----|\\n        -1    -1          -1\\n   \\n[[1,4],[2,3],[4,5],[6,7]]\\n   |-----|     |     |\\n        -1\\n```\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals, (a, b) ->  {\\n            int firstDiff = a[0] - b[0];\\n            return firstDiff != 0 ? firstDiff : b[1] - a[1];\\n        });\\n        \\n        int len = intervals.length;\\n        int remaining = len;\\n        for (int i = 0, j = 1; j < len; j++) {\\n            int[] a = intervals[j];\\n            int[] b = intervals[i];\\n            if (aIsCoveredByb(a, b)) remaining--;\\n            else i = j;\\n        }\\n        return remaining;\\n    }\\n\\n    private boolean aIsCoveredByb(int[] a, int[] b) {\\n        return b[0] <= a[0] && a[1] <= b[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787074,
                "title": "c-easy-to-understand-sorting-short-simple-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        int ans=0;\\n\\t\\t//sort the vector\\n        sort(intervals.begin(),intervals.end());\\n        vector<int> temp = intervals[0];\\n        for(auto it : intervals)\\n        {\\n            if(temp[1]>=it[1])\\n            {\\n                ans++;\\n            }\\n            else if(temp[0]==it[0])\\n            {\\n                ans++;\\n                temp = it;\\n            }\\n            else\\n            {\\n                temp = it;\\n            }\\n        }\\n        cout<<ans;\\n        return n-ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        int ans=0;\\n\\t\\t//sort the vector\\n        sort(intervals.begin(),intervals.end());\\n        vector<int> temp = intervals[0];\\n        for(auto it : intervals)\\n        {\\n            if(temp[1]>=it[1])\\n            {\\n                ans++;\\n            }\\n            else if(temp[0]==it[0])\\n            {\\n                ans++;\\n                temp = it;\\n            }\\n            else\\n            {\\n                temp = it;\\n            }\\n        }\\n        cout<<ans;\\n        return n-ans+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1786995,
                "title": "please-help-c",
                "content": "Can someone please tell me that why  this code gives wrong answer  ;-\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int r=0,max=intervals[0][1];\\n        int l=intervals.size();\\n        for(int i=1;i<l;i++)\\n        {\\n            if(intervals[i][1]<=max)\\n                r++;\\n           else if(intervals[i][0]==intervals[i-1][0])\\n                r++;\\n            \\n            \\n            if(max<intervals[i][1])\\n                max=intervals[i][1];\\n        }\\n        return l-r;\\n    }\\n};\\n```\\nwhereas this code gives right answer :-\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int r=1;\\n        int x=intervals[0][0],y=intervals[0][1];\\n        int l=intervals.size();\\n        for(int i=1;i<l;i++)\\n        {\\n           if(intervals[i][0]>x &&  intervals[i][1]>y)\\n            r++;\\n            if(intervals[i][1]>y)\\n            {\\n                y=intervals[i][1];\\n                x=intervals[i][0];\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```\\nThanks in Advance",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int r=0,max=intervals[0][1];\\n        int l=intervals.size();\\n        for(int i=1;i<l;i++)\\n        {\\n            if(intervals[i][1]<=max)\\n                r++;\\n           else if(intervals[i][0]==intervals[i-1][0])\\n                r++;\\n            \\n            \\n            if(max<intervals[i][1])\\n                max=intervals[i][1];\\n        }\\n        return l-r;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int r=1;\\n        int x=intervals[0][0],y=intervals[0][1];\\n        int l=intervals.size();\\n        for(int i=1;i<l;i++)\\n        {\\n           if(intervals[i][0]>x &&  intervals[i][1]>y)\\n            r++;\\n            if(intervals[i][1]>y)\\n            {\\n                y=intervals[i][1];\\n                x=intervals[i][0];\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786989,
                "title": "java-simple-solution-sort",
                "content": "**Runtime: 8 ms, faster than 56.63% of Java online submissions for Remove Covered Intervals.\\nMemory Usage: 46.7 MB, less than 14.20% of Java online submissions for Remove Covered Intervals.**\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int count = 0;\\n        Arrays.sort(intervals,(a,b)->a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        int end = intervals[0][1];\\n        for(int i = 1;i<intervals.length;i++){\\n            if(intervals[i][1] <= end)count++;\\n            end = Math.max(end,intervals[i][1]);\\n        }\\n        return intervals.length - count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int count = 0;\\n        Arrays.sort(intervals,(a,b)->a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\\n        int end = intervals[0][1];\\n        for(int i = 1;i<intervals.length;i++){\\n            if(intervals[i][1] <= end)count++;\\n            end = Math.max(end,intervals[i][1]);\\n        }\\n        return intervals.length - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786945,
                "title": "python-easy-and-clean-solution-explained",
                "content": "Approach is to take 1st interval as a **TRAP** \\nTraverse the remaining array and check whether some interval falls into the trap or trap itself falls into another trap and update the trap.\\n\\n***Code Breakdown:***\\n________________________________________________________________________\\n```\\n if i[0] == trap[0] or i[1] <= trap[1]:\\n```\\nif start is same, guaranteed one falls into the trap, \\n``` eg: [2,6], [2,3]```\\n\\n**or** If any interval has upper bound lesser than trap\\'s upperbound\\n``` eg: trap  = [1,8]``` and  an interval ```[2,4] ``` comes it will fall into the existing trap, lower boud will play no role here because array is sorted.\\n___________________________________________________________________________________\\n```\\ntrap[1] = max(trap[1], i[1])\\n```\\nif any interval falls into the trap we will just change the upperbound of the trap, in order to reduce duplicates.\\n``` eg:  [1,8],[2,4],[2,9]```\\nSo here , in this example we can see 2nd interval is falling under 1st interval as well as in 3rd interval, and we cant count it twice.\\n_________________________________________________________________________________\\n```\\nelse:  trap = i\\n```\\nelse if at any particular iteration if trap didn\\'t work we will change the trap to current range.\\n__________________________________________________________________________________\\n```\\n return len(intervals) -  count\\n ```\\n We have counted the number interval trapped,\\n and we have to return the number of intervals that are not trapped.\\n __________________________________________________________________________________\\n \\n \\n **Full Code:**\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()            \\n        trap, count = intervals[0], 0                     \\n        for i in intervals[1:]:                 \\n            if i[0] == trap[0] or i[1] <= trap[1]:       \\n                count += 1\\n                trap[1] = max(trap[1], i[1])       \\n            else:  trap = i\\n        return len(intervals) -  count\\n```",
                "solutionTags": [],
                "code": "```\\n if i[0] == trap[0] or i[1] <= trap[1]:\\n```\n``` eg: [2,6], [2,3]```\n``` eg: trap  = [1,8]```\n```[2,4] ```\n```\\ntrap[1] = max(trap[1], i[1])\\n```\n``` eg:  [1,8],[2,4],[2,9]```\n```\\nelse:  trap = i\\n```\n```\\n return len(intervals) -  count\\n ```\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort()            \\n        trap, count = intervals[0], 0                     \\n        for i in intervals[1:]:                 \\n            if i[0] == trap[0] or i[1] <= trap[1]:       \\n                count += 1\\n                trap[1] = max(trap[1], i[1])       \\n            else:  trap = i\\n        return len(intervals) -  count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786913,
                "title": "java-easy-solution-basic-sorting-solution",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] Intervals) {\\n        \\n    \\n    \\n        // Code here // Code here\\n        ArrayList<int[]>a=new ArrayList<int[]>();\\n        int n=Intervals.length;\\n        if(n==1)\\n        return 1;\\n        for(int i=0;i<n;i++) //making arraylist as deleting and shifting is not be to be taken cared much in ArrayList as compared to Array\\n        {\\n           // System.out.println(Arrays.toString(Intervals[i]));\\n            int part[]=new int[2];\\n            part[0]=Intervals[i][0];\\n            part[1]=Intervals[i][1];\\n            a.add(part);\\n            \\n        }\\n        Collections.sort(a,new Comparator<int[]>(){      //sorting using first value first, then on the second value if first one is equal\\n            @Override\\n            public int compare(int o1[],int o2[])\\n            {\\n                if(o1[0]!=o2[0])\\n                return o1[0]-o2[0];\\n                return o2[1]-o1[1];\\n            }\\n        });\\n        int length=a.size();\\n    /*     for(int k=0;k<length;k++)\\n        {\\n            System.out.println(Arrays.toString(a.get(k)));\\n        }*/\\n      //  int len=a.size();\\n        int i=0;\\n        length--;\\n        while(true)\\n        {\\n        if(a.get(i)[0]<=a.get(i+1)[0] && a.get(i)[1]>=a.get(i+1)[1])\\n        {\\n        \\n           \\n            a.remove(i+1);\\n            length--;\\n             if(i==(length))\\n            break;\\n        }\\n        \\n        else   // we will move to next pair of element only if we are sure that next pair cant be consumed by present one;\\n        {\\n          //  System.out.println((a.size())+\"--\"+length+\" \"+i+\"(((\");\\n            i++;\\n           int o=a.size();\\n           if((i+1)>=(o))\\n           break;\\n           \\n           \\n            \\n        }\\n        \\n        \\n        }\\n        int l=a.size();//System.out.println(\"**\");\\n        for(int j=0;j<l;j++)\\n        {\\n            System.out.println(Arrays.toString(a.get(j)));\\n        }\\n        int y=a.size();\\n       return y;\\n        \\n        \\n        \\n    }\\n}\\n\\n```\\n\\nRead Comments ,It will definitely help,\\nlook for further optimization.",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] Intervals) {\\n        \\n    \\n    \\n        // Code here // Code here\\n        ArrayList<int[]>a=new ArrayList<int[]>();\\n        int n=Intervals.length;\\n        if(n==1)\\n        return 1;\\n        for(int i=0;i<n;i++) //making arraylist as deleting and shifting is not be to be taken cared much in ArrayList as compared to Array\\n        {\\n           // System.out.println(Arrays.toString(Intervals[i]));\\n            int part[]=new int[2];\\n            part[0]=Intervals[i][0];\\n            part[1]=Intervals[i][1];\\n            a.add(part);\\n            \\n        }\\n        Collections.sort(a,new Comparator<int[]>(){      //sorting using first value first, then on the second value if first one is equal\\n            @Override\\n            public int compare(int o1[],int o2[])\\n            {\\n                if(o1[0]!=o2[0])\\n                return o1[0]-o2[0];\\n                return o2[1]-o1[1];\\n            }\\n        });\\n        int length=a.size();\\n    /*     for(int k=0;k<length;k++)\\n        {\\n            System.out.println(Arrays.toString(a.get(k)));\\n        }*/\\n      //  int len=a.size();\\n        int i=0;\\n        length--;\\n        while(true)\\n        {\\n        if(a.get(i)[0]<=a.get(i+1)[0] && a.get(i)[1]>=a.get(i+1)[1])\\n        {\\n        \\n           \\n            a.remove(i+1);\\n            length--;\\n             if(i==(length))\\n            break;\\n        }\\n        \\n        else   // we will move to next pair of element only if we are sure that next pair cant be consumed by present one;\\n        {\\n          //  System.out.println((a.size())+\"--\"+length+\" \"+i+\"(((\");\\n            i++;\\n           int o=a.size();\\n           if((i+1)>=(o))\\n           break;\\n           \\n           \\n            \\n        }\\n        \\n        \\n        }\\n        int l=a.size();//System.out.println(\"**\");\\n        for(int j=0;j<l;j++)\\n        {\\n            System.out.println(Arrays.toString(a.get(j)));\\n        }\\n        int y=a.size();\\n       return y;\\n        \\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786895,
                "title": "java-solution",
                "content": "Sort the start based on ascending order. If start time of 2 intervals is same, then sort it based on desending order of end time. Once the intervals are sorted, start couting the intervals and once the end time is more than current max end time, increment the counter.\\t\\n\\t\\n\\t\\n\\tpublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tArrays.sort(intervals, (a, b) -> (a[0] == b[0]) ? b[1] - a[1] : a[0] - b[0]);\\n\\t\\tint count = 0;\\n\\t\\tint end = 0;\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tif (end < intervals[i][1]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Sort the start based on ascending order. If start time of 2 intervals is same, then sort it based on desending order of end time. Once the intervals are sorted, start couting the intervals and once the end time is more than current max end time, increment the counter.\\t\\n\\t\\n\\t\\n\\tpublic int removeCoveredIntervals(int[][] intervals) {\\n\\t\\tArrays.sort(intervals, (a, b) -> (a[0] == b[0]) ? b[1] - a[1] : a[0] - b[0]);\\n\\t\\tint count = 0;\\n\\t\\tint end = 0;\\n\\t\\tfor (int i = 0; i < intervals.length; i++) {\\n\\t\\t\\tif (end < intervals[i][1]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "C++"
            },
            {
                "id": 1786823,
                "title": "python-maxheap-solution",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        \\n        intervals.sort(key=lambda x: x[1], reverse=True) \\n        intervals.sort(key=lambda x: x[0]) # We shell sort it by the first number.\\n\\n        heap = []\\n        \\n        # If its bigger then -1 * peak(heap) [largest] we shell push it to the heap.\\n        for l, r in intervals:\\n            \\n            if len(heap) == 0:\\n                heapq.heappush(heap, -r)\\n            \\n            else:\\n                \\n                # This is supposed to be the largest number.\\n                if heap[0] > -r:\\n                    heapq.heappush(heap, -r)\\n        \\n        return len(heap)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        \\n        intervals.sort(key=lambda x: x[1], reverse=True) \\n        intervals.sort(key=lambda x: x[0]) # We shell sort it by the first number.\\n\\n        heap = []\\n        \\n        # If its bigger then -1 * peak(heap) [largest] we shell push it to the heap.\\n        for l, r in intervals:\\n            \\n            if len(heap) == 0:\\n                heapq.heappush(heap, -r)\\n            \\n            else:\\n                \\n                # This is supposed to be the largest number.\\n                if heap[0] > -r:\\n                    heapq.heappush(heap, -r)\\n        \\n        return len(heap)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786761,
                "title": "java-easy-solution-o-nlogn-tc-greedy-approach",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n=intervals.length;\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        int res=n;\\n        for(int i=0,j=1;j<n;j++){\\n            if(intervals[i][1]>=intervals[j][1])\\n                res--;\\n            else{\\n                if(intervals[i][0]==intervals[j][0])\\n                    res--;\\n                i=j;\\n            }\\n        }\\n     return res;       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n=intervals.length;\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        int res=n;\\n        for(int i=0,j=1;j<n;j++){\\n            if(intervals[i][1]>=intervals[j][1])\\n                res--;\\n            else{\\n                if(intervals[i][0]==intervals[j][0])\\n                    res--;\\n                i=j;\\n            }\\n        }\\n     return res;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786740,
                "title": "python-sorting-simple-solution",
                "content": "## Logic:\\n1. Sort the intervals on the basis of start position and then on end position in reverse order.\\n2. Iterate over the intervals and check whether the next interval would be covered by previous interval. If true then the current interval can be removed.\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        count = len(intervals)\\n        start, end = intervals[0]\\n        \\n        for i in range(1, len(intervals)):\\n            if start <= intervals[i][0] and intervals[i][1] <= end:\\n                count -= 1\\n            else:\\n                start, end = intervals[i][0], intervals[i][1]\\n        return count\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key = lambda x: (x[0], -x[1]))\\n        count = len(intervals)\\n        start, end = intervals[0]\\n        \\n        for i in range(1, len(intervals)):\\n            if start <= intervals[i][0] and intervals[i][1] <= end:\\n                count -= 1\\n            else:\\n                start, end = intervals[i][0], intervals[i][1]\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786660,
                "title": "python-faster-than-78-simple",
                "content": "* Sort the intervals list with respect to the first element of inner pair.\\n* create a stack st\\n* first append the first pair in the stack st\\n* iterate over the intervals list, check if the pair is present in the top of the stack\\n* if present, pass\\n* if not present, check if the top of the stack is present in the pair, if present -> pop the top of stack and append the pair\\n* else, append the pair..!!\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        \\n        intervals = sorted(intervals, key = lambda x: x[0])\\n        \\n        st = []\\n        first = intervals[0]\\n        st.append(first)\\n        \\n        for l in intervals:\\n            \\n            if l!=first: \\n            \\n                x = st[-1]\\n                if l[0]<x[1] and l[0]>=x[0]:\\n                    if l[1]<=x[1]:\\n                        pass\\n                    elif x[0]>=l[0] and x[1]<=l[1]:\\n                            st.pop()\\n                            st.append(l)\\n                    else:\\n                        st.append(l)\\n                else:\\n                    st.append(l)\\n\\n        return len(st)\\n        \\n```\\n\\n**PLS UPVOTE IF YOU LIKE MY SOLUTION, HOPE YOU LIKE THIS.**",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        \\n        intervals = sorted(intervals, key = lambda x: x[0])\\n        \\n        st = []\\n        first = intervals[0]\\n        st.append(first)\\n        \\n        for l in intervals:\\n            \\n            if l!=first: \\n            \\n                x = st[-1]\\n                if l[0]<x[1] and l[0]>=x[0]:\\n                    if l[1]<=x[1]:\\n                        pass\\n                    elif x[0]>=l[0] and x[1]<=l[1]:\\n                            st.pop()\\n                            st.append(l)\\n                    else:\\n                        st.append(l)\\n                else:\\n                    st.append(l)\\n\\n        return len(st)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786657,
                "title": "c",
                "content": "```\\n\\n bool comp ( const vector<int> &v1 , const vector<int> &v2 )\\n    {\\n        if ( v1[0] < v2[0] ) return true ; \\n        else if ( v1[0] == v2[0] ) \\n        {\\n            if ( v1[1] > v2[1] ) return true ; \\n        }\\n        return false ; \\n    }\\nclass Solution {\\npublic:\\n   \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort ( intervals.begin() , intervals.end() , comp ) ;\\n        int ans = intervals.size() ;\\n        int prevx = intervals[0][0] , prevy = intervals[0][1] ;\\n        \\n      \\n        for ( int i = 1 ; i < intervals.size() ; i++ )\\n        {\\n            int newx = intervals[i][0] , newy = intervals[i][1] ;\\n            if ( newx >= prevx and newy <= prevy ) ans-- ; \\n            prevx = min ( prevx , newx ) , prevy = max ( prevy , newy ) ; \\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n bool comp ( const vector<int> &v1 , const vector<int> &v2 )\\n    {\\n        if ( v1[0] < v2[0] ) return true ; \\n        else if ( v1[0] == v2[0] ) \\n        {\\n            if ( v1[1] > v2[1] ) return true ; \\n        }\\n        return false ; \\n    }\\nclass Solution {\\npublic:\\n   \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort ( intervals.begin() , intervals.end() , comp ) ;\\n        int ans = intervals.size() ;\\n        int prevx = intervals[0][0] , prevy = intervals[0][1] ;\\n        \\n      \\n        for ( int i = 1 ; i < intervals.size() ; i++ )\\n        {\\n            int newx = intervals[i][0] , newy = intervals[i][1] ;\\n            if ( newx >= prevx and newy <= prevy ) ans-- ; \\n            prevx = min ( prevx , newx ) , prevy = max ( prevy , newy ) ; \\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786655,
                "title": "python-easy-to-read-and-understand",
                "content": "Sort on a[0] and if same then -a[1]\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key= lambda x: (x[0], -x[1]))\\n        ans, right = 0, 0\\n        for u, v in intervals:\\n            if v > right:\\n                ans += 1\\n            right = max(right, v)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "Sort on a[0] and if same then -a[1]\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key= lambda x: (x[0], -x[1]))\\n        ans, right = 0, 0\\n        for u, v in intervals:\\n            if v > right:\\n                ans += 1\\n            right = max(right, v)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1786612,
                "title": "c-brute-force-time-o-n-2",
                "content": "This is a brute force method and the code can be passed.\\nTime complexity is O(N^2) \\nSpace complexity is O(N) \\n\\n# Source Code \\n```C++\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<vector<int>>& v = intervals;\\n        sort(v.begin(), v.end(), [](auto r, auto l) {\\n\\t\\t\\treturn r[0]!=l[0]?r[0]<l[0]:r[1]>l[1] ;\\n\\t\\t}); \\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        vector<bool> covered(n,false);\\n        for(int i = 0; i<n; i++) {\\n            int start =v[i][0];\\n            int end = v[i][1];\\n            int j = i+1;\\n            while(j<n && v[j][0]<=end) {\\n                if(v[j][1]<=end && !covered[j]) {\\n                    covered[j] = true;   \\n                    cnt++;\\n                }\\n                j++;\\n            }\\n        }\\n        return n-cnt;\\n    }\\n};\\n```\\n\\n# Code with comment\\n```C++\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<vector<int>>& v = intervals;\\n        sort(v.begin(), v.end(), [](auto r, auto l) {\\n\\t\\t\\treturn r[0]!=l[0]?r[0]<l[0]:r[1]>l[1] ;\\n\\t\\t}); \\n\\t\\t// [[1,2],[1,4],[3,4]] will be sorted into [[1,4],[1,2],[3,4]]\\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        vector<bool> covered(n,false);\\n        for(int i = 0; i<n; i++) {\\n            int start =v[i][0];\\n            int end = v[i][1];\\n            int j = i+1;\\n\\t\\t\\t//for each interval_i [start_i, end_i], \\n\\t\\t\\t//we can run the following loop\\n            while(j<n && v[j][0]<=end) {\\n\\t\\t\\t\\t//for all j that start_i <= start_j <= end_i, run the loop for j here. \\n\\t\\t\\t\\t//becase start_j  have already in interval_i, so we only need to check if end_j ini nterval_i\\n\\t\\t\\t\\t//if it is, then count up. \\n                if(v[j][1]<=end && !covered[j]) {\\n                    covered[j] = true;   \\n\\t\\t\\t\\t\\t//set covered[j] as true so interval only can be counted when first time to be covered.\\n                    cnt++;\\n                }\\n                j++;\\n            }\\n        }\\n        return n-cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<vector<int>>& v = intervals;\\n        sort(v.begin(), v.end(), [](auto r, auto l) {\\n\\t\\t\\treturn r[0]!=l[0]?r[0]<l[0]:r[1]>l[1] ;\\n\\t\\t}); \\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        vector<bool> covered(n,false);\\n        for(int i = 0; i<n; i++) {\\n            int start =v[i][0];\\n            int end = v[i][1];\\n            int j = i+1;\\n            while(j<n && v[j][0]<=end) {\\n                if(v[j][1]<=end && !covered[j]) {\\n                    covered[j] = true;   \\n                    cnt++;\\n                }\\n                j++;\\n            }\\n        }\\n        return n-cnt;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<vector<int>>& v = intervals;\\n        sort(v.begin(), v.end(), [](auto r, auto l) {\\n\\t\\t\\treturn r[0]!=l[0]?r[0]<l[0]:r[1]>l[1] ;\\n\\t\\t}); \\n\\t\\t// [[1,2],[1,4],[3,4]] will be sorted into [[1,4],[1,2],[3,4]]\\n        \\n        int n = v.size();\\n        int cnt = 0;\\n        vector<bool> covered(n,false);\\n        for(int i = 0; i<n; i++) {\\n            int start =v[i][0];\\n            int end = v[i][1];\\n            int j = i+1;\\n\\t\\t\\t//for each interval_i [start_i, end_i], \\n\\t\\t\\t//we can run the following loop\\n            while(j<n && v[j][0]<=end) {\\n\\t\\t\\t\\t//for all j that start_i <= start_j <= end_i, run the loop for j here. \\n\\t\\t\\t\\t//becase start_j  have already in interval_i, so we only need to check if end_j ini nterval_i\\n\\t\\t\\t\\t//if it is, then count up. \\n                if(v[j][1]<=end && !covered[j]) {\\n                    covered[j] = true;   \\n\\t\\t\\t\\t\\t//set covered[j] as true so interval only can be counted when first time to be covered.\\n                    cnt++;\\n                }\\n                j++;\\n            }\\n        }\\n        return n-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786597,
                "title": "c-daily-leetcoding-challenge-feb-20-sorting",
                "content": "```\\n\\tint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int size = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        \\n        stack<vector<int>> st;\\n        st.push(intervals[0]);\\n        \\n        for(int i=1; i<size; i++){\\n            vector<int> top = st.top();\\n            if(top[0] <= intervals[i][0] and top[1] >= intervals[i][1]){\\n                continue;\\n            }else if(top[0] == intervals[i][0] and top[1] < intervals[i][1]){\\n                st.pop();\\n            }\\n            st.push(intervals[i]);\\n        }\\n        \\n        return st.size();\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\tint removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int size = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        \\n        stack<vector<int>> st;\\n        st.push(intervals[0]);\\n        \\n        for(int i=1; i<size; i++){\\n            vector<int> top = st.top();\\n            if(top[0] <= intervals[i][0] and top[1] >= intervals[i][1]){\\n                continue;\\n            }else if(top[0] == intervals[i][0] and top[1] < intervals[i][1]){\\n                st.pop();\\n            }\\n            st.push(intervals[i]);\\n        }\\n        \\n        return st.size();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1786568,
                "title": "java-o-n-solution-using-treemap",
                "content": "This is the solution using treemap to store maximum interval taken by every starting point.\\nmain logic:\\ntreemap stores in sorted order.\\ntime complexity: O(n)\\nSpace Complexity: O(n) (Worst case Scenerio)\\n\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length,ans = 0;\\n\\t\\t//using treemap to store maximum ending of every starting point.\\n        TreeMap<Integer,Integer> map = new TreeMap<Integer,Integer>();\\n        for(int[] i : intervals)\\n        {\\n            map.put(i[0],Math.max(map.getOrDefault(i[0],0),i[1]));\\n        }\\n\\t\\t// initializing flag to store first key.\\n        int end = 0,flag = 0;\\n        for (Map.Entry<Integer,Integer> entry : map.entrySet())\\n        {\\n            if(flag == 0)\\n            {\\n                end = entry.getValue();\\n                flag = 1;\\n                ans++;\\n            }\\n            else\\n            {\\n\\t\\t\\t// if the current ending point is greater than previous ending point. then ans will be incremented.\\n                int t = entry.getValue();\\n                if(t>end)\\n                {\\n                    end = t;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length,ans = 0;\\n\\t\\t//using treemap to store maximum ending of every starting point.\\n        TreeMap<Integer,Integer> map = new TreeMap<Integer,Integer>();\\n        for(int[] i : intervals)\\n        {\\n            map.put(i[0],Math.max(map.getOrDefault(i[0],0),i[1]));\\n        }\\n\\t\\t// initializing flag to store first key.\\n        int end = 0,flag = 0;\\n        for (Map.Entry<Integer,Integer> entry : map.entrySet())\\n        {\\n            if(flag == 0)\\n            {\\n                end = entry.getValue();\\n                flag = 1;\\n                ans++;\\n            }\\n            else\\n            {\\n\\t\\t\\t// if the current ending point is greater than previous ending point. then ans will be incremented.\\n                int t = entry.getValue();\\n                if(t>end)\\n                {\\n                    end = t;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786542,
                "title": "java-faster-than-98",
                "content": "```\\n public int removeCoveredIntervals(int[][] intervals) {\\n     Arrays.sort(intervals, (a, b) -> ((a[0]-b[0]) == 0 ? b[1]-a[1] : a[0]-b[0]) ); \\n     \\n     int count = 1;\\n     int base[] = intervals[0];\\n     for(int i=1; i<intervals.length; i++){\\n        if(intervals[i][1] > base[1]){\\n          base = intervals[i]; \\n          count++;  \\n        }\\n         \\n     }   \\n     return count; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int removeCoveredIntervals(int[][] intervals) {\\n     Arrays.sort(intervals, (a, b) -> ((a[0]-b[0]) == 0 ? b[1]-a[1] : a[0]-b[0]) ); \\n     \\n     int count = 1;\\n     int base[] = intervals[0];\\n     for(int i=1; i<intervals.length; i++){\\n        if(intervals[i][1] > base[1]){\\n          base = intervals[i]; \\n          count++;  \\n        }\\n         \\n     }   \\n     return count; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786506,
                "title": "java-easy-to-understand-written-notes",
                "content": "**\\n           int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            int c=intervals[j][0];\\n            int d=intervals[j][1];\\n\\t\\t\\t\\n\\t\\tWe will be sorting array on the basis of 1st value......\\n\\t\\t\\t\\nLets explore some test cases [1,4] ,[2,8], [3,6]\\n.................................................................... ith.......jth........................................................................................................\\n\\nand 2nd test case is  [1,2], [1,4]\\n...........................................ith......jth...................................................................................................................................\\n\\nif ith interval covers jth interval then (c>=a && b>=d).\\n\\nif jth interval covers ith interval then (c==a && b<=d)\\n\\n**\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n       Arrays.sort(intervals,(a,b)-> a[0]-b[0]);\\n        int i=0;\\n        int j=1;\\n        int ans=0;\\n        while(j<intervals.length){\\n            int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            int c=intervals[j][0];\\n            int d=intervals[j][1];\\n             \\n            //if ith interval covers jth interval...............\\n            if(c>=a && b>=d){\\n                intervals[j]=intervals[i];\\n                ans++;\\n                i=j;\\n            // if jth interval cover ith interval...............\\n            }else if(c==a && b<=d){\\n                ans++;\\n               i=j; \\n             // no cover....................   \\n            }else{\\n                i++;\\n            }\\n            \\n            j++; \\n        }\\n        return intervals.length-ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n       Arrays.sort(intervals,(a,b)-> a[0]-b[0]);\\n        int i=0;\\n        int j=1;\\n        int ans=0;\\n        while(j<intervals.length){\\n            int a=intervals[i][0];\\n            int b=intervals[i][1];\\n            int c=intervals[j][0];\\n            int d=intervals[j][1];\\n             \\n            //if ith interval covers jth interval...............\\n            if(c>=a && b>=d){\\n                intervals[j]=intervals[i];\\n                ans++;\\n                i=j;\\n            // if jth interval cover ith interval...............\\n            }else if(c==a && b<=d){\\n                ans++;\\n               i=j; \\n             // no cover....................   \\n            }else{\\n                i++;\\n            }\\n            \\n            j++; \\n        }\\n        return intervals.length-ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786423,
                "title": "python-3-using-sorting-and-a-stack-92ms-14-5mb",
                "content": "It helps to sort the provided array first according to start indices. That way we can use simple if-else logic in order to determine which ranges get to stay and which don\\'t. After the entire for loop ends we simply return the number of items that are remaining in the stack.\\n\\nThe time compelxity is `O(nlogn)` because we sort the array (remember Python uses Timsort which has `O(nlogn)` worst-case complexity) and the space complexity is `O(n)` because at worst none of the intervals will overlap and our stack will simply be the original array.\\n\\n### Algorithm\\n\\nThe intuition is that there are three total cases:\\n1. The current interval is contained in the interval at the top of the stack.\\n2. The interval at the top of the stack is contained in the current interval.\\n3. Neither.\\n\\nFor #1 we don\\'t want to do anything and continue to the next iteration. For #2, since the top of the stack is now irrelevant, we pop it and push the current interval to the top. For any other case we simply push it to the top of the stack.\\n\\nIf we didn\\'t sort the array then we\\'d have to search the entire stack array and remove overlapping intervals rather than having to simply compare with the top.\\n\\nThe flowchart is as follows:\\n\\n![image](https://assets.leetcode.com/users/images/bb9f7370-7d6c-4d6e-8468-da7693b029fb_1645363363.7521431.png)\\n\\n\\n\\n### Code\\n\\n```\\ndef removeCoveredIntervals(intervals: List[List[int]]) -> int:\\n\\tintervals = sorted(intervals, key=lambda x: x[0])\\n\\tstack = [intervals[0]]\\n\\n\\tfor interval in intervals[1:]:\\n\\t\\tstart, end = interval\\n\\t\\ttop_start, top_end = stack[-1]\\n\\n\\t\\tif (start >= top_start) and (end <= top_end):\\n\\t\\t\\tcontinue            \\n\\t\\telif (start <= top_start) and (end >= top_end):\\n\\t\\t\\tstack.pop()\\n\\t\\t\\tstack.append(interval)\\n\\t\\telse:\\n\\t\\t\\tstack.append(interval)\\n\\n\\treturn len(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\ndef removeCoveredIntervals(intervals: List[List[int]]) -> int:\\n\\tintervals = sorted(intervals, key=lambda x: x[0])\\n\\tstack = [intervals[0]]\\n\\n\\tfor interval in intervals[1:]:\\n\\t\\tstart, end = interval\\n\\t\\ttop_start, top_end = stack[-1]\\n\\n\\t\\tif (start >= top_start) and (end <= top_end):\\n\\t\\t\\tcontinue            \\n\\t\\telif (start <= top_start) and (end >= top_end):\\n\\t\\t\\tstack.pop()\\n\\t\\t\\tstack.append(interval)\\n\\t\\telse:\\n\\t\\t\\tstack.append(interval)\\n\\n\\treturn len(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1786390,
                "title": "c-easy-solution-detailed-explanation",
                "content": "Everything is explained in the code with examples\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // Sorting the intervals \\n        sort(intervals.begin(), intervals.end());\\n        \\n        // Storing the first interval\\n        vector<int> previous;\\n        previous.push_back(intervals[0][0]);\\n        previous.push_back(intervals[0][1]);\\n        \\n        // There\\'ll be atleast one interval in the final answer\\n        int remaining = 1;\\n        \\n        for(int i=1; i<intervals.size(); i++){\\n            // Storing the current interval\\n            vector<int> current = {intervals[i][0], intervals[i][1]};\\n            \\n            // Current interval is covered by the previous interval\\n            // Ex: previous = [1,6], current = [3,5] ==> Final: [1,6]\\n            if(current[1] <= previous[1]){\\n                continue;\\n            }\\n            \\n            // Previous interval is covered by the current interval\\n            // Ex: previous = [1,5], current = [1,6] ==> Final: [1,6]\\n            if(current[0] == previous[0] && current[1] > previous[1]){\\n                previous[1] = current[1];\\n                continue;\\n            }\\n            \\n            // Other cases: Current interval is not covered by the previous interval or vice versa\\n            remaining++;\\n            \\n            // Updating the previous interval with current interval\\n            previous[0] = current[0];\\n            previous[1] = current[1];\\n        }\\n        return remaining;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        // Sorting the intervals \\n        sort(intervals.begin(), intervals.end());\\n        \\n        // Storing the first interval\\n        vector<int> previous;\\n        previous.push_back(intervals[0][0]);\\n        previous.push_back(intervals[0][1]);\\n        \\n        // There\\'ll be atleast one interval in the final answer\\n        int remaining = 1;\\n        \\n        for(int i=1; i<intervals.size(); i++){\\n            // Storing the current interval\\n            vector<int> current = {intervals[i][0], intervals[i][1]};\\n            \\n            // Current interval is covered by the previous interval\\n            // Ex: previous = [1,6], current = [3,5] ==> Final: [1,6]\\n            if(current[1] <= previous[1]){\\n                continue;\\n            }\\n            \\n            // Previous interval is covered by the current interval\\n            // Ex: previous = [1,5], current = [1,6] ==> Final: [1,6]\\n            if(current[0] == previous[0] && current[1] > previous[1]){\\n                previous[1] = current[1];\\n                continue;\\n            }\\n            \\n            // Other cases: Current interval is not covered by the previous interval or vice versa\\n            remaining++;\\n            \\n            // Updating the previous interval with current interval\\n            previous[0] = current[0];\\n            previous[1] = current[1];\\n        }\\n        return remaining;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1786300,
                "title": "easy-brute-force",
                "content": "```\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<pair<int,int>> myVec;\\n        int m = intervals.size();\\n        int n = 2;\\n        for(int i=0;i<m;i++){\\n                myVec.push_back({intervals[i][1],intervals[i][0]});\\n        }\\n        sort(myVec.rbegin(),myVec.rend());\\n        int start,end;\\n        start = myVec[0].second;\\n        end = myVec[0].first;\\n        for(int i=0;i<m;i++){\\n            cout << myVec[i].first << myVec[i].second << endl;\\n        }\\n        int count=0;\\n        for(int i=1;i<m;i++){\\n            if(end >= myVec[i].first and start <= myVec[i].second){\\n                count++;\\n                //cout << \"interation #\" << i << endl;\\n            }\\n            else if(end==myVec[i].first and start > myVec[i].second)\\n            {\\n                count++;\\n              //  end=myVec[i].first;\\n                start=myVec[i].second;\\n            }\\n            else if(end>myVec[i].first and start == myVec[i].second)\\n            {    count++;\\n                end = myVec[i].first;\\n                \\n            }\\n            else{\\n                 start = myVec[i].second;\\n                 end = myVec[i].first;\\n            }\\n        }\\n       // cout << count;\\n        return m-count;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        vector<pair<int,int>> myVec;\\n        int m = intervals.size();\\n        int n = 2;\\n        for(int i=0;i<m;i++){\\n                myVec.push_back({intervals[i][1],intervals[i][0]});\\n        }\\n        sort(myVec.rbegin(),myVec.rend());\\n        int start,end;\\n        start = myVec[0].second;\\n        end = myVec[0].first;\\n        for(int i=0;i<m;i++){\\n            cout << myVec[i].first << myVec[i].second << endl;\\n        }\\n        int count=0;\\n        for(int i=1;i<m;i++){\\n            if(end >= myVec[i].first and start <= myVec[i].second){\\n                count++;\\n                //cout << \"interation #\" << i << endl;\\n            }\\n            else if(end==myVec[i].first and start > myVec[i].second)\\n            {\\n                count++;\\n              //  end=myVec[i].first;\\n                start=myVec[i].second;\\n            }\\n            else if(end>myVec[i].first and start == myVec[i].second)\\n            {    count++;\\n                end = myVec[i].first;\\n                \\n            }\\n            else{\\n                 start = myVec[i].second;\\n                 end = myVec[i].first;\\n            }\\n        }\\n       // cout << count;\\n        return m-count;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1786242,
                "title": "c-solution-easy-to-understand-simple",
                "content": "\\n\\nclass Solution {\\n\\n\\npublic:\\n\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]>b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n\\t\\n    int removeCoveredIntervals(vector<vector<int>>& nums) {\\n\\t\\n        sort(nums.begin(),nums.end(),cmp);\\n        int n=nums.size();\\n        int ans=0;\\n        int end=nums[0][1];\\n        for(int i=1;i<n;i++){\\n            if(nums[i][1]<=end) {\\n            ans++;\\n            }\\n            else{\\n                end=nums[i][1];\\n            }\\n        }\\n        return n-ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n\\npublic:\\n\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]>b[1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1786216,
                "title": "c-straight-forward-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a,vector<int>b){\\n        if(a[0]!=b[0])  return a[0]<b[0];\\n        else return a[1]>b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        int ans=1;\\n        int prev_a=intervals[0][0];\\n        int prev_b=intervals[0][1];\\n        int i=1;\\n        while(i<intervals.size()){\\n            if(intervals[i][1]>prev_b)\\n            {\\n                prev_b=intervals[i][1];\\n                ans++;\\n            }\\n            i++;\\n            \\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a,vector<int>b){\\n        if(a[0]!=b[0])  return a[0]<b[0];\\n        else return a[1]>b[1];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),comp);\\n        int ans=1;\\n        int prev_a=intervals[0][0];\\n        int prev_b=intervals[0][1];\\n        int i=1;\\n        while(i<intervals.size()){\\n            if(intervals[i][1]>prev_b)\\n            {\\n                prev_b=intervals[i][1];\\n                ans++;\\n            }\\n            i++;\\n            \\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786154,
                "title": "c-greedy-sort-using-comparator-easy-to-understand-explaination",
                "content": "[**@Iemprashant**](https://leetcode.com/iemprashant/) \\uD83D\\uDE80\\n**1288. Remove Covered Intervals**\\n```\\n1. C++ Code. \\uD83C\\uDF93\\n2. Please Upvote if it helps\\u2B06\\uFE0F\\n3. Detailed Approach \\u2705\\n4. Github Repository for code:->\\n\\n```\\n\\u26A1[ GithubRepo](https://github.com/iemprashant/LeetHub)\\n \\n**Observation** \\uD83D\\uDCCD\\n```\\nIdea-1=>if we get a particular then the intervals between that is covered=> [1,4] is max so all [1,2], [1,3] are covered\\nIdea-2=>if we sort the intervals then , the second interval start would be covered in the first one. (as [a,b) covers [c,d) when  a<=c && d<=b) ,So sorting will cover the a<=c condition.\\nIdea-3=> for covering the second condition we will sort the array in increasing order of start also if start  is same, we will sort in decreasing by finsih.\\n```\\n**=>[1,4],[2,9],[1,2],[3,6]**\\n```\\n       =>1____2____3____4____5____6____7____8____9\\n         1--------------4\\n              2---------------------------------9\\n         1----2      \\n                   3-----------------6\\n```\\n Clearly we Can see [3,6] is covererd\\n**Approach** \\uD83D\\uDEA9 \\n1:-> First sort the arrary using Comparator.\\n2:-> Compartor will sort in the ascending , when start is same then sort finish in decending.\\n3:-> Put size of interval in ans variable.\\n4:-> Now take a count of max reach done at every interval, initialize with -1.\\n5:-> Traverse the vector, as start is sorted and start condition is covered already (IDEA-2) , We will check only Condition 2.\\n6:->Now if finish of curr vector is less than max reach ,So Inteval is covered=> decrease ans by one.\\n7:->if finish of curr vector is greater than maxreach, so Update the maxreach.\\n8:-> Return the ans.\\uD83D\\uDE03\\n**CODE** \\uD83D\\uDCCB\\n```\\n\\nbool campare(vector<int>a,vector<int>b){\\n    if(a[0]< b[0]){\\n        return true;\\n    }\\n    if(a[0]== b[0] && a[1]>b[1]){\\n        return true;\\n    }\\n    return false;\\n}\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),campare);\\n        int anssize=intervals.size();\\n        if(anssize==1){\\n            return anssize;\\n        }\\n        int maxreach=-1;\\n        for(int i=0;i<intervals.size();i++){\\n            (intervals[i][1]<=maxreach)?anssize--:(maxreach=intervals[i][1]);\\n        }\\n        return anssize;\\n    }\\n};\\n```\\n\\nPlease Upvote if it helps\\u2B06\\uFE0F",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n1. C++ Code. \\uD83C\\uDF93\\n2. Please Upvote if it helps\\u2B06\\uFE0F\\n3. Detailed Approach \\u2705\\n4. Github Repository for code:->\\n\\n```\n```\\nIdea-1=>if we get a particular then the intervals between that is covered=> [1,4] is max so all [1,2], [1,3] are covered\\nIdea-2=>if we sort the intervals then , the second interval start would be covered in the first one. (as [a,b) covers [c,d) when  a<=c && d<=b) ,So sorting will cover the a<=c condition.\\nIdea-3=> for covering the second condition we will sort the array in increasing order of start also if start  is same, we will sort in decreasing by finsih.\\n```\n```\\n       =>1____2____3____4____5____6____7____8____9\\n         1--------------4\\n              2---------------------------------9\\n         1----2      \\n                   3-----------------6\\n```\n```\\n\\nbool campare(vector<int>a,vector<int>b){\\n    if(a[0]< b[0]){\\n        return true;\\n    }\\n    if(a[0]== b[0] && a[1]>b[1]){\\n        return true;\\n    }\\n    return false;\\n}\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),campare);\\n        int anssize=intervals.size();\\n        if(anssize==1){\\n            return anssize;\\n        }\\n        int maxreach=-1;\\n        for(int i=0;i<intervals.size();i++){\\n            (intervals[i][1]<=maxreach)?anssize--:(maxreach=intervals[i][1]);\\n        }\\n        return anssize;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786080,
                "title": "fast-and-easy-to-understand-o-nlg-n-time-and-o-1-memory-c-solution",
                "content": "This question can be solved greedily, you want to look at the big intervals first then check if the smaller ones are a subinterval.\\n\\nTo do that I implemented a custom comparator that asserts the fact that if there exists an interval [st<sub>i</sub>, fn<sub>i</sub>] and [st<sub>i+1</sub>, fn<sub>i+1</sub>] either st<sub>i+1</sub> > st<sub>i</sub> or (st<sub>i+1</sub> == st<sub>i</sub> and fn<sub>i</sub> >= fn<sub>i+1</sub>).\\n\\nAfter sorting the intervals grab the first element in the intervals array and save it in a tmp variable because it is part of your solution since all the coming elements have a starting value that is greater than it or and ending value that is smaller than it.\\n\\nThen iterate on the intervals array, If you come across an interval that is covered by the tmp variable simply skip that interval, however if you come across an interval that is not covered replace the tmp\\'s value with the new interval\\'s value. You can do that safely because the sorting ensures that no upcoming starting value will be less than the tmp\\'s starting value, thus no uncovered interval will be missed.\\n\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        auto cmp = [](vector<int>& v1, vector<int>& v2)->bool {\\n            return v1[0] < v2[0] or (v1[0] == v2[0] and v1[1] >= v2[1]);\\n        };\\n        \\n        sort(intervals.begin(), intervals.end(), cmp);\\n        \\n        int ans = 1;\\n        \\n        vector<int> tmp = intervals[0];\\n        \\n        for (int i = 1; i < intervals.size(); ++i) {\\n            int st = max(intervals[i][0], tmp[0]);\\n            int fn = min(intervals[i][1], tmp[1]);\\n            \\n            if (st != intervals[i][0] or fn != intervals[i][1]) {\\n                tmp = intervals[i]; ans +=1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        auto cmp = [](vector<int>& v1, vector<int>& v2)->bool {\\n            return v1[0] < v2[0] or (v1[0] == v2[0] and v1[1] >= v2[1]);\\n        };\\n        \\n        sort(intervals.begin(), intervals.end(), cmp);\\n        \\n        int ans = 1;\\n        \\n        vector<int> tmp = intervals[0];\\n        \\n        for (int i = 1; i < intervals.size(); ++i) {\\n            int st = max(intervals[i][0], tmp[0]);\\n            int fn = min(intervals[i][1], tmp[1]);\\n            \\n            if (st != intervals[i][0] or fn != intervals[i][1]) {\\n                tmp = intervals[i]; ans +=1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785918,
                "title": "c-simple-solution-easy-to-understand-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),[](const vector<int> &a,const vector<int> &b){\\n            if(a[0]!=b[0]){\\n                return a[0]<b[0];\\n            }else {\\n                return a[1]>b[1];\\n            }\\n        });\\n        int num=0;\\n        bool check = 0;\\n        int l,r;\\n        int i=0;\\n        while(i<intervals.size()){\\n            if(check){\\n                if(intervals[i][0]>=l and intervals[i][1]<=r){\\n                    i++;\\n                }else{\\n                    check=0;\\n                }\\n            }else{\\n                num++;\\n                check=1;\\n                l=intervals[i][0],r=intervals[i][1];\\n                i++;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),[](const vector<int> &a,const vector<int> &b){\\n            if(a[0]!=b[0]){\\n                return a[0]<b[0];\\n            }else {\\n                return a[1]>b[1];\\n            }\\n        });\\n        int num=0;\\n        bool check = 0;\\n        int l,r;\\n        int i=0;\\n        while(i<intervals.size()){\\n            if(check){\\n                if(intervals[i][0]>=l and intervals[i][1]<=r){\\n                    i++;\\n                }else{\\n                    check=0;\\n                }\\n            }else{\\n                num++;\\n                check=1;\\n                l=intervals[i][0],r=intervals[i][1];\\n                i++;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785871,
                "title": "c-easy-to-understand-sorting",
                "content": "If we simply apply ``` sort(intervals.begin(), intervals.end()) ``` then output will be ``` [[1,2],[1,4],[3,4]] ```. \\n\\nIn this case covering interval [1,4] is coming after the covered interval [1,2].\\n\\nHence we have to modify the sorting in such a way that whenever two intervals have same start, the interval having higher end value should come first. Following function is used for the same.\\n\\n```\\nbool static compare( const vector<int>& v1, const vector<int>& v2 ) \\n    {\\n        if(v1[0]==v2[0])\\n            return v1[1]>v2[1];\\n        else\\n            return v1[0] < v2[0];\\n    }\\n```\\t\\nCode:\\n```\\nclass Solution {\\npublic:\\n    \\n    bool static compare( const vector<int>& v1, const vector<int>& v2 ) \\n    {\\n        if(v1[0]==v2[0])\\n            return v1[1]>v2[1];\\n        else\\n            return v1[0] < v2[0];\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) \\n    {\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        int count = 0, start = 0;\\n        \\n        for(int i=1; i<intervals.size(); i++)\\n        {\\n            if(intervals[start][1] >= intervals[i][1])\\n                count++;\\n            else\\n                start = i;\\n        }\\n        return intervals.size()-count;\\n    }\\n};\\n```\\n\\n\\n\\t\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "``` sort(intervals.begin(), intervals.end()) ```\n``` [[1,2],[1,4],[3,4]] ```\n```\\nbool static compare( const vector<int>& v1, const vector<int>& v2 ) \\n    {\\n        if(v1[0]==v2[0])\\n            return v1[1]>v2[1];\\n        else\\n            return v1[0] < v2[0];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool static compare( const vector<int>& v1, const vector<int>& v2 ) \\n    {\\n        if(v1[0]==v2[0])\\n            return v1[1]>v2[1];\\n        else\\n            return v1[0] < v2[0];\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) \\n    {\\n        \\n        sort(intervals.begin(), intervals.end(), compare);\\n        int count = 0, start = 0;\\n        \\n        for(int i=1; i<intervals.size(); i++)\\n        {\\n            if(intervals[start][1] >= intervals[i][1])\\n                count++;\\n            else\\n                start = i;\\n        }\\n        return intervals.size()-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785803,
                "title": "java-sorting-just-calculate-the-right-maximum",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n\\t\\t//  consider no overlapping by default so answer will be the size of the intervals[][]\\n\\t\\tint answer = n;\\n        Arrays.sort(intervals, (a, b) -> {\\n            if (a[0] != b[0]) {\\n                return a[0] - b[0];\\n            }\\n            return b[1] - a[1];\\n        });\\n        \\n        //  right Maximum reach\\n        int rightSpan = intervals[0][1];\\n        for (int i = 1; i < n; i++) {\\n            int[] interval = intervals[i];\\n            int start = interval[0];\\n            int end = interval[1];\\n            if (end <= rightSpan) {\\n\\t\\t\\t    //  every time we see an overlapping decrease our answer by one \\n                answer--;\\n            } else {\\n\\t\\t\\t\\t// if no overlapping this means the current end is greater than the \\n\\t\\t\\t\\t// previous end so update the rightSpan\\n                rightSpan = end;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n\\n/*\\n\\nNOTE : * we are not considering the start of the current interval because we have \\n\\t     sorted our array on the basis of start time.\\n\\t   * If the start time are same we want the interval with the greater end time \\n     \\t to maximize the covering of intervals.\\n\\n*/\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n\\t\\t//  consider no overlapping by default so answer will be the size of the intervals[][]\\n\\t\\tint answer = n;\\n        Arrays.sort(intervals, (a, b) -> {\\n            if (a[0] != b[0]) {\\n                return a[0] - b[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1785760,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        \\n        // if start time is different then one with lesser start time will come first\\n        // if start time is same then the one with larger end time will come first\\n        \\n        sort(intervals.begin(), intervals.end(), [&](vector<int> &i1, vector<int> &i2) {\\n            if(i1[0] == i2[0]) return i1[1] > i2[1];\\n            else return i1[0] < i2[0];\\n        });\\n        int maxEnd = -1;\\n        int cnt = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(maxEnd >= intervals[i][1]) {\\n                cnt++;\\n            } \\n            maxEnd = max(maxEnd, intervals[i][1]);\\n        }\\n        return n - cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        \\n        // if start time is different then one with lesser start time will come first\\n        // if start time is same then the one with larger end time will come first\\n        \\n        sort(intervals.begin(), intervals.end(), [&](vector<int> &i1, vector<int> &i2) {\\n            if(i1[0] == i2[0]) return i1[1] > i2[1];\\n            else return i1[0] < i2[0];\\n        });\\n        int maxEnd = -1;\\n        int cnt = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(maxEnd >= intervals[i][1]) {\\n                cnt++;\\n            } \\n            maxEnd = max(maxEnd, intervals[i][1]);\\n        }\\n        return n - cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785717,
                "title": "python-sort-o-nlogn-with-comments",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        # sort the interval by its 0th index\\n        intervals.sort()\\n        ans = 1\\n        i = 1\\n        curr = intervals[0]\\n        while i < len(intervals):\\n            # if [1,3] [1,5] [1,7] exists we should ideally count them as 1 as 1,7 will cover both 1,3 and 1,5\\n            if curr[0]==intervals[i][0]:\\n                curr = [curr[0],max(curr[1],intervals[i][1])]\\n            # when a previous interval couldn\\'t cover current interval,\\n            # add 1 to ans and update curr\\n            elif curr[1] < intervals[i][1]:\\n                ans+=1\\n                curr = intervals[i]\\n            i+=1\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        # sort the interval by its 0th index\\n        intervals.sort()\\n        ans = 1\\n        i = 1\\n        curr = intervals[0]\\n        while i < len(intervals):\\n            # if [1,3] [1,5] [1,7] exists we should ideally count them as 1 as 1,7 will cover both 1,3 and 1,5\\n            if curr[0]==intervals[i][0]:\\n                curr = [curr[0],max(curr[1],intervals[i][1])]\\n            # when a previous interval couldn\\'t cover current interval,\\n            # add 1 to ans and update curr\\n            elif curr[1] < intervals[i][1]:\\n                ans+=1\\n                curr = intervals[i]\\n            i+=1\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785678,
                "title": "python-sorting-98-faster-96-space-efficient",
                "content": "![image](https://assets.leetcode.com/users/images/f63b972a-f6c3-4342-8107-8da12e59aa6d_1645342587.2552063.png)\\n\\n```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        c = len(intervals)\\n        intervals.sort(key=lambda x: x[0])\\n        x, y = intervals[0]\\n        for i in range(1, len(intervals)):\\n            if x <= intervals[i][0] and intervals[i][1] <= y:\\n                c -= 1\\n                continue\\n            if intervals[i][0] <= x and y <= intervals[i][1]:\\n                c -= 1\\n            x, y = intervals[i][0], intervals[i][1]\\n        return c\\n```\\n\\n**Pleas upvote if you find it useful and interesting!!!\\nThank you.**",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        c = len(intervals)\\n        intervals.sort(key=lambda x: x[0])\\n        x, y = intervals[0]\\n        for i in range(1, len(intervals)):\\n            if x <= intervals[i][0] and intervals[i][1] <= y:\\n                c -= 1\\n                continue\\n            if intervals[i][0] <= x and y <= intervals[i][1]:\\n                c -= 1\\n            x, y = intervals[i][0], intervals[i][1]\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785593,
                "title": "c-very-easy-solution-using-stack",
                "content": "c++ solution using stack\\n```\\n int removeCoveredIntervals(vector<vector<int>>& inter) {\\n        sort(inter.begin(),inter.end());\\n        stack<vector<int>>st;\\n        for(auto x:inter)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(x);\\n            }\\n            else\\n            {\\n                vector<int>v=st.top();\\n                if(x[1]<=v[1])\\n                    continue;\\n                else if(x[0]==v[0]&&x[1]>v[1])\\n                {\\n                    st.pop();\\n                    \\n                }\\n               st.push(x);\\n            }\\n            \\n        }\\n        return st.size();\\n    }\\n\\t\\n\\t//if u find it helpfull please upvote.",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "c++ solution using stack\\n```\\n int removeCoveredIntervals(vector<vector<int>>& inter) {\\n        sort(inter.begin(),inter.end());\\n        stack<vector<int>>st;\\n        for(auto x:inter)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(x);\\n            }\\n            else\\n            {\\n                vector<int>v=st.top();\\n                if(x[1]<=v[1])\\n                    continue;\\n                else if(x[0]==v[0]&&x[1]>v[1])\\n                {\\n                    st.pop();\\n                    \\n                }\\n               st.push(x);\\n            }\\n            \\n        }\\n        return st.size();\\n    }\\n\\t\\n\\t//if u find it helpfull please upvote.",
                "codeTag": "Unknown"
            },
            {
                "id": 1785569,
                "title": "clear-explanation-intuitive-java",
                "content": "It is obvious that we will consider all the intervals with larger length before considering the shorter ones. Now we have two options, either to sort by the end time or start time. \\n\\nLet\\'s sort by the end time. Consider you have intervals: `[[1,10],[3,4],[5,6],[1,2]]`\\nAfter sorting the intervals from end time our intervals array will be: `[[1,2],[3,4],[5,6],[1,10]]`\\nAs we can see, our very last interval `[1,10]` covers all the intervals before it, but we wont be able to keep track of the interval it covers as it is the last element in the array, hence we discard sorting by end time. ( There might be a solution which sorts by end time, so if you have come across one feel free to share) \\n\\nLet\\'s sort by start time. Considering the same intervals, After sorting by start time we will have `[[1,2],[1,10],[3,4],[5,6]]`\\nNow as we can see `[1,2]` comes under `[1,10]` but for simplicity we will consider having `[1,10]` before `[1,2]` because it covers large interval length. Hence we will sort by start time first, in case the start time is equal we will have the larger end time first. So now our array will look something like:` [[1,10],[1,2],[3,4],[5,6]]`\\n\\nWe will take each interval one by one and see if it covers next one:\\n\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0) return 0;\\n        Arrays.sort(intervals, (i1,i2) -> (i1[0]==i2[0]?i2[1]-i1[1]:i1[0]-i2[0]));\\n        int c = intervals[0][0], d = intervals[0][1];\\n        int ans = intervals.length;\\n        for(int i=1;i<intervals.length;i++){\\n            int a = intervals[i][0], b = intervals[i][1];\\n            if(c<=a && b<=d) ans--; \\n            else {\\n                c = a;\\n                d = b;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        if(intervals == null || intervals.length == 0) return 0;\\n        Arrays.sort(intervals, (i1,i2) -> (i1[0]==i2[0]?i2[1]-i1[1]:i1[0]-i2[0]));\\n        int c = intervals[0][0], d = intervals[0][1];\\n        int ans = intervals.length;\\n        for(int i=1;i<intervals.length;i++){\\n            int a = intervals[i][0], b = intervals[i][1];\\n            if(c<=a && b<=d) ans--; \\n            else {\\n                c = a;\\n                d = b;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785514,
                "title": "java-merge-intervals-approach",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int start;\\n        int end;\\n        Pair(int start,int end){\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Pair p[] = new Pair[intervals.length];\\n        for(int i=0;i<intervals.length;i++){\\n            p[i]=new Pair(intervals[i][0], intervals[i][1]);\\n        }\\n        Arrays.sort(p, new Comparator<Pair>(){\\n            public int compare(Pair p1, Pair p2){\\n                if(p1.start!=p2.start)\\n                    return p1.start-p2.start;\\n                return p2.end-p1.end;\\n            }\\n        });\\n        Stack<Pair> st = new Stack<Pair>();\\n        int ans=0;\\n        st.push(p[0]);\\n        for(int i=1;i<p.length;i++){\\n            Pair top = st.peek();\\n            if(p[i].start>=top.start && p[i].end<=top.end){\\n                continue;\\n            }\\n            st.push(p[i]);\\n            \\n            \\n        }\\n        \\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int start;\\n        int end;\\n        Pair(int start,int end){\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Pair p[] = new Pair[intervals.length];\\n        for(int i=0;i<intervals.length;i++){\\n            p[i]=new Pair(intervals[i][0], intervals[i][1]);\\n        }\\n        Arrays.sort(p, new Comparator<Pair>(){\\n            public int compare(Pair p1, Pair p2){\\n                if(p1.start!=p2.start)\\n                    return p1.start-p2.start;\\n                return p2.end-p1.end;\\n            }\\n        });\\n        Stack<Pair> st = new Stack<Pair>();\\n        int ans=0;\\n        st.push(p[0]);\\n        for(int i=1;i<p.length;i++){\\n            Pair top = st.peek();\\n            if(p[i].start>=top.start && p[i].end<=top.end){\\n                continue;\\n            }\\n            st.push(p[i]);\\n            \\n            \\n        }\\n        \\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785494,
                "title": "greedy-simple-o-nlogn-tc-and-o-n-space",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    static bool sortcol(const vector<int>& v1,const vector<int>& v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }else{\\n            return v1[0]<v2[0];\\n        }\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),sortcol);\\n        vector<pair<int,int>>vec;\\n        auto it=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(it[0]<=intervals[i][0] and it[1]>=intervals[i][1]){\\n                continue;\\n            }else{\\n                vec.push_back({it[0],it[1]});\\n                it=intervals[i];\\n            }\\n        }\\n        return vec.size()+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool sortcol(const vector<int>& v1,const vector<int>& v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }else{\\n            return v1[0]<v2[0];\\n        }\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),sortcol);\\n        vector<pair<int,int>>vec;\\n        auto it=intervals[0];\\n        for(int i=1;i<intervals.size();i++){\\n            if(it[0]<=intervals[i][0] and it[1]>=intervals[i][1]){\\n                continue;\\n            }else{\\n                vec.push_back({it[0],it[1]});\\n                it=intervals[i];\\n            }\\n        }\\n        return vec.size()+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785478,
                "title": "c-easy-sorting-solution-approach-explained",
                "content": "First we sort the intervals based on their starting value, then we keep storing the max time and min time till now. If any interval is in between min and max i.e. it has been covered already so we increment count. Count will give us number of intervals to be removed. So, number of intervals left= Total no. of intervals- count.\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>v1, vector<int>v2){\\n        if(v1[0]==v2[0]) return v1[1]>v2[1]; //If starting value is same, sort on the basis of second value\\n        return v1[0]<v2[0];\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size(),count=0;\\n        if(n==1) return 1; \\n        sort(intervals.begin(),intervals.end(), comp);\\n        int mini=intervals[0][0], maxi=intervals[0][1];\\n        \\n        for(int i=1; i<intervals.size();i++){\\n            if(intervals[i][0]>=mini && intervals[i][1]<=maxi) count++;\\n            maxi=max(maxi,intervals[i][1]);\\n            mini=min(mini,intervals[i][0]);\\n        }\\n        return n-count;\\n    }\\n};\\n```\\nHope you found this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int>v1, vector<int>v2){\\n        if(v1[0]==v2[0]) return v1[1]>v2[1]; //If starting value is same, sort on the basis of second value\\n        return v1[0]<v2[0];\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int n=intervals.size(),count=0;\\n        if(n==1) return 1; \\n        sort(intervals.begin(),intervals.end(), comp);\\n        int mini=intervals[0][0], maxi=intervals[0][1];\\n        \\n        for(int i=1; i<intervals.size();i++){\\n            if(intervals[i][0]>=mini && intervals[i][1]<=maxi) count++;\\n            maxi=max(maxi,intervals[i][1]);\\n            mini=min(mini,intervals[i][0]);\\n        }\\n        return n-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785331,
                "title": "c-detailed-explanation-of-sort-and-edge-case-logic",
                "content": "First and foremost, we sort the intervals by each\\'s start value. Therefore, an input like `[[1,4],[3,6],[2,8]]` becomes `[[1,4],[2,8],[3,6]]`. Note how we now do not need to explicitly check whether a given interval\\'s start is >= the previous one.\\n\\nAll we need to do now is to traverse through this sorted list of intervals. For each interval, we need to check whether the right index (6 in `(3,6)`) is <= the previous right index (8 in `(2,8)`). If so, the current interval `(3,6)` will be covered by the previous one `(2,8)` and hence we don\\'t count it in the list of intervals that will remain.\\n\\nIf however, the current interval\\'s right index (8 in `(2,8)`) is greater than the previous interval\\'s right index (4 in `(1,4)`), then there is no overlap and hence we must count the current interval.\\n\\n---\\n\\nHowever, there is an **edge case** here which needs to be considered. Say we have something like `[[3,9],[3,10]]` after sorting. Now obviously `[3,9]` is covered by `[3,10]` but because 10 > 9, we will end up counting both.\\n\\nThis issue essentially occurs because at each step we are checking whether the previous interval can cover the current one, but not vice versa, which is precisely the case in this above example. Note an important point here. Because we are sorting the intervals (albeit by the start index), the above scenario can occur only if `prev_left == cur_left`. We know for a fact that `cur_left` can never be greater than `prev_left`, and if the current interval can cover the previous interval, then `prev_left has to be == cur_left`.\\n\\nThe solution for this issue is simple enough:\\nWhile sorting, we shall normally choose the interval whose start index is smaller. If, however, the cur_left == prev_left, then we shall choose the interval whose end index is greater (i.e. we arrange intervals in descending order of their end indices).\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n\\t\\tsort(intervals.begin(), intervals.end(),\\n             [](vector<int> a, vector<int> b)\\n             { return (a[0] != b[0]) ? (a[0] < b[0]) : a[1] > b[1]; }\\n            );\\n        \\n        int prev_left = -1, prev_right = -1;\\n        int cnt = 0;\\n        \\n        for(int i = 0; i < intervals.size(); i++)\\n        {\\n            int cur_left = intervals[i][0], cur_right = intervals[i][1];\\n            \\n            // if cur_right > prev_right i.e. we do not have an overlapping interval\\n            if(cur_right > prev_right)\\n            {\\n                // update prev_right to now indicate to current interval\\'s right\\n                prev_right = cur_right;\\n                // this interval cannot be covered so include it\\n                ++cnt;\\n            }\\n\\n\\t\\t\\t// update prev_left to now indicate to current interval\\'s left\\n            prev_left = cur_left;\\n        }\\n        \\n        return cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n\\t\\tsort(intervals.begin(), intervals.end(),\\n             [](vector<int> a, vector<int> b)\\n             { return (a[0] != b[0]) ? (a[0] < b[0]) : a[1] > b[1]; }\\n            );\\n        \\n        int prev_left = -1, prev_right = -1;\\n        int cnt = 0;\\n        \\n        for(int i = 0; i < intervals.size(); i++)\\n        {\\n            int cur_left = intervals[i][0], cur_right = intervals[i][1];\\n            \\n            // if cur_right > prev_right i.e. we do not have an overlapping interval\\n            if(cur_right > prev_right)\\n            {\\n                // update prev_right to now indicate to current interval\\'s right\\n                prev_right = cur_right;\\n                // this interval cannot be covered so include it\\n                ++cnt;\\n            }\\n\\n\\t\\t\\t// update prev_left to now indicate to current interval\\'s left\\n            prev_left = cur_left;\\n        }\\n        \\n        return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785283,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comparator(vector<int>a, vector<int>b){\\n        if(a[0] > b[0]) \\n            return false;\\n        else if (a[0] == b[0] && a[1] < b[1]){\\n            return false;\\n        }\\n        return true;\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(), comparator);\\n        int start = intervals[0][0];\\n        int end = intervals[0][1];\\n        int count=1;\\n        \\n        for(int i=1;i<intervals.size();i++){\\n            if(start <= intervals[i][0] && end >= intervals[i][1])\\n                continue;\\n            else{\\n                ++count;\\n                start = intervals[i][0];\\n                end = intervals[i][1];\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    static bool comparator(vector<int>a, vector<int>b){\\n        if(a[0] > b[0]) \\n            return false;\\n        else if (a[0] == b[0] && a[1] < b[1]){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1785058,
                "title": "c-very-easy-solution-simple",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    void func(vector<vector<int>>&intervals)\\n    {\\n        int n= intervals.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(intervals[i-1][0]==intervals[i][0])\\n            {\\n                if(intervals[i-1][1]<intervals[i][1])\\n                    swap(intervals[i-1][1],intervals[i][1]);\\n            }\\n        }\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals)\\n\\t{\\n        \\n      sort(intervals.begin(),intervals.end());          // sort them based on interval(i)\\n\\t\\t\\tfunc(intervals);         // if interval [i]== interval [i-1] then we consider the larger interval\\n        int count=1, low= intervals[0][0], high=intervals[0][1];         // we always consider the first value after the sorting \\n       for(int i=1;i<intervals.size();i++)\\n       {\\n          if(intervals[i][1]>high)\\n          {\\n              count++;       // increment everytime we are out of the higher bound\\n              high= intervals[i][1];\\n          }\\n       }\\n        return count;  \\n     }\\n};\\n\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    void func(vector<vector<int>>&intervals)\\n    {\\n        int n= intervals.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(intervals[i-1][0]==intervals[i][0])\\n            {\\n                if(intervals[i-1][1]<intervals[i][1])\\n                    swap(intervals[i-1][1],intervals[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1785028,
                "title": "2-solutions-c-sorting",
                "content": "***Applying Brute force after Sorting:***\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1 ,vector<int>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int cnt=0;\\n        for(int i=1;i<intervals.size();i++){\\n            int s=intervals[i][0];\\n            int e=intervals[i][1];\\n            for(int j=i-1;j>=0;j--){\\n                int currs=intervals[j][0];\\n                int curre=intervals[j][1];\\n                if(s>=currs && e<=curre){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```\\n\\n***Better Approach :***\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1 ,vector<int>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int cnt=0;\\n        int mxend=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][1]<=mxend){\\n                cnt++;\\n            }\\n            else{\\n                mxend=intervals[i][1];\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```\\n### *Please Upvote if you like the approach :)*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1 ,vector<int>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int cnt=0;\\n        for(int i=1;i<intervals.size();i++){\\n            int s=intervals[i][0];\\n            int e=intervals[i][1];\\n            for(int j=i-1;j>=0;j--){\\n                int currs=intervals[j][0];\\n                int curre=intervals[j][1];\\n                if(s>=currs && e<=curre){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&v1 ,vector<int>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end(),cmp);\\n        int cnt=0;\\n        int mxend=intervals[0][1];\\n        for(int i=1;i<intervals.size();i++){\\n            if(intervals[i][1]<=mxend){\\n                cnt++;\\n            }\\n            else{\\n                mxend=intervals[i][1];\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784895,
                "title": "java-sorting",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(arr1,arr2)->Integer.compare(arr1[0],arr2[0]));\\n        int[] curr=new int[]{-1,-1};\\n        int result=0;\\n        for(int[] interval:intervals){\\n            if(interval[0]>curr[0] && interval[1]>curr[1]){\\n                curr[0]=interval[0];\\n                result++;\\n            }\\n            curr[1]=Math.max(curr[1],interval[1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        Arrays.sort(intervals,(arr1,arr2)->Integer.compare(arr1[0],arr2[0]));\\n        int[] curr=new int[]{-1,-1};\\n        int result=0;\\n        for(int[] interval:intervals){\\n            if(interval[0]>curr[0] && interval[1]>curr[1]){\\n                curr[0]=interval[0];\\n                result++;\\n            }\\n            curr[1]=Math.max(curr[1],interval[1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784493,
                "title": "java-reuse-lc-56-explained",
                "content": "**Idea:**\\n* The solution is pretty similar to that of [LC 56. Merge Intervals](https://leetcode.com/problems/merge-intervals/discuss/1645484/Java-or-Greedy-or-Simple-with-comments)\\n* Sort by start time\\n* Start remaining intervals with value = size(intervals), i.e. initially all intervals are remaining \\n* For each interval pair, check if one is covered by the other. \\n* If either covers the other then, then this interval will be used for the next iteration. Reduce remaining by 1\\n* Else the latter interval will be used for the next iteration\\n\\n**Example:** [[1, 4],[3, 6],[2, 8]]\\n```\\nSort by start = [[1, 4],[2, 8],[3, 6]]\\n\\nprev = [1, 4], current = [2, 8], remaining = 3\\nneither covers the other, update prev = [2, 8], current = [3, 6]\\n\\nprev = [2, 8], current = [3, 6], remaining = 3\\nprev covers current, remaining = 2\\n\\n[Ans] 2\\n```\\n>**T/S:** O(n lg n)/O(n)\\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\tArrays.sort(intervals, Comparator.comparingInt(i -> i[0]));\\n\\tvar remaining = intervals.length;\\n\\n\\tfor (int i = 1, prev[] = intervals[0]; i < intervals.length; i++)\\n\\t\\tif (prev[0] <= intervals[i][0] && intervals[i][1] <= prev[1]) {\\n\\t\\t\\tremaining--;\\n\\t\\t} else {\\n\\t\\t\\tif (intervals[i][0] <= prev[0] && prev[1] <= intervals[i][1])\\n\\t\\t\\t\\tremaining--;\\n\\t\\t\\tprev = intervals[i];\\n\\t\\t}\\n\\n\\treturn remaining;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nSort by start = [[1, 4],[2, 8],[3, 6]]\\n\\nprev = [1, 4], current = [2, 8], remaining = 3\\nneither covers the other, update prev = [2, 8], current = [3, 6]\\n\\nprev = [2, 8], current = [3, 6], remaining = 3\\nprev covers current, remaining = 2\\n\\n[Ans] 2\\n```\n```\\npublic int removeCoveredIntervals(int[][] intervals) {\\n\\tArrays.sort(intervals, Comparator.comparingInt(i -> i[0]));\\n\\tvar remaining = intervals.length;\\n\\n\\tfor (int i = 1, prev[] = intervals[0]; i < intervals.length; i++)\\n\\t\\tif (prev[0] <= intervals[i][0] && intervals[i][1] <= prev[1]) {\\n\\t\\t\\tremaining--;\\n\\t\\t} else {\\n\\t\\t\\tif (intervals[i][0] <= prev[0] && prev[1] <= intervals[i][1])\\n\\t\\t\\t\\tremaining--;\\n\\t\\t\\tprev = intervals[i];\\n\\t\\t}\\n\\n\\treturn remaining;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1784479,
                "title": "java-easy-solution-beats-99-of-submission-runtime-2ms",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int count=0;\\n        for(int i=0;i<intervals.length;i++)\\n        {\\n            for(int j=0;j<intervals.length;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<= intervals[j][1])\\n                    {\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return intervals.length-count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int count=0;\\n        for(int i=0;i<intervals.length;i++)\\n        {\\n            for(int j=0;j<intervals.length;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    if(intervals[i][0]>=intervals[j][0] && intervals[i][1]<= intervals[j][1])\\n                    {\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return intervals.length-count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688141,
                "title": "c-custom-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    static bool comp(vector<int>a, vector<int>b){\\n             if(a[0] > b[0]) return false;\\n             else if(a[0] == b[0] && a[1] < b[1]) return false;\\n             return true;\\n    }\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n         \\n          sort(intervals.begin(),intervals.end(),comp);\\n         int maximum_end = intervals[0][1], covered_intervals = 0;\\n         for (int i = 1; i < intervals.size(); i++) {\\n            if (intervals[i][1] <= maximum_end) {\\n                covered_intervals++;\\n            }\\n            maximum_end = max(maximum_end, intervals[i][1]);\\n        }\\n        return intervals.size() - covered_intervals;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    static bool comp(vector<int>a, vector<int>b){\\n             if(a[0] > b[0]) return false;\\n             else if(a[0] == b[0] && a[1] < b[1]) return false;\\n             return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1549430,
                "title": "python-sort-solution-with-explanation",
                "content": "The logic is very straigtforward and easy to understand. If there is any part that\\'s not clear, please feel free to ask. \\n```\\n    def removeCoveredIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n    #Sort the list with increasing first index, and decreasing second index if the first index is same as previous element.\\n       \\n    #Example: [[1,2],[1,4],[2,4]]  will become [[1,4],[1,2],[2,4]] --> increasing on first and decreasing on second index\\n        \\n    # We need this because in above example [1,4] will give us maximum range. If we picked [1,2], the algorithm would think [1,4] is also needed to increase the range. Hoever if we just picked [1,4] in the first place, we won\\'t need [1,2]\\n    \\n        sored_interval = sorted(intervals, key = lambda x:(x[0],-x[1]) )\\n        start = float(\\'inf\\')\\n        end = float(\\'-inf\\')\\n        total = 0\\n        \\n        for interval in sored_interval:\\n            if interval[0] < start or interval[1] > end:\\n                total +=1\\n            prev = interval[0]\\n            start = min(start,interval[0])\\n            end = max(end,interval[1])\\n        return total\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    def removeCoveredIntervals(self, intervals):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n    #Sort the list with increasing first index, and decreasing second index if the first index is same as previous element.\\n       \\n    #Example: [[1,2],[1,4],[2,4]]  will become [[1,4],[1,2],[2,4]] --> increasing on first and decreasing on second index\\n        \\n    # We need this because in above example [1,4] will give us maximum range. If we picked [1,2], the algorithm would think [1,4] is also needed to increase the range. Hoever if we just picked [1,4] in the first place, we won\\'t need [1,2]\\n    \\n        sored_interval = sorted(intervals, key = lambda x:(x[0],-x[1]) )\\n        start = float(\\'inf\\')\\n        end = float(\\'-inf\\')\\n        total = 0\\n        \\n        for interval in sored_interval:\\n            if interval[0] < start or interval[1] > end:\\n                total +=1\\n            prev = interval[0]\\n            start = min(start,interval[0])\\n            end = max(end,interval[1])\\n        return total\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1423517,
                "title": "simple-c-24ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int begin = INT_MAX;\\n        int end = INT_MIN;\\n        begin = min(begin,intervals[0][0]);\\n        end = max(end,intervals[0][1]);\\n        vector<vector<int>>interim;\\n        interim.push_back({begin,end});\\n        for(int i = 1;i<intervals.size();i++)\\n        {\\n           int val1 = intervals[i][0];\\n           int val2 = intervals[i][1];\\n           if(val1>=interim.back()[0] and val2<=interim.back()[1])\\n               continue;\\n         \\n           else if(val1<=interim.back()[0] and val2>interim.back()[1])\\n           {\\n               interim.back()[0] = val1;\\n               interim.back()[1] = val2;\\n           }\\n              else if(val1>=interim.back()[0] and val2>interim.back()[1])\\n               interim.push_back({val1,val2});\\n        }\\n        int n = interim.size();\\n        return n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(),intervals.end());\\n        int begin = INT_MAX;\\n        int end = INT_MIN;\\n        begin = min(begin,intervals[0][0]);\\n        end = max(end,intervals[0][1]);\\n        vector<vector<int>>interim;\\n        interim.push_back({begin,end});\\n        for(int i = 1;i<intervals.size();i++)\\n        {\\n           int val1 = intervals[i][0];\\n           int val2 = intervals[i][1];\\n           if(val1>=interim.back()[0] and val2<=interim.back()[1])\\n               continue;\\n         \\n           else if(val1<=interim.back()[0] and val2>interim.back()[1])\\n           {\\n               interim.back()[0] = val1;\\n               interim.back()[1] = val2;\\n           }\\n              else if(val1>=interim.back()[0] and val2>interim.back()[1])\\n               interim.push_back({val1,val2});\\n        }\\n        int n = interim.size();\\n        return n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319872,
                "title": "java-brute-force-sorting-3ms-beats-97-t-c-o-nlogn-s-c-o-1",
                "content": "\\n\\n\\t// Brute Force\\n\\t// O(n*n) O(1)\\n\\tpublic int removeCoveredIntervals1(int[][] intervals) {\\n\\n\\t\\tint len = intervals.length, rem = len;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (overlap(intervals[i], intervals[j])) {\\n\\t\\t\\t\\t\\trem--;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn rem;\\n\\t}\\n\\n\\t// Overlapping\\n\\t// O(1) O(1)\\n\\tpublic boolean overlap(int[] cand, int[] interval) {\\n\\t\\treturn (interval[0] <= cand[0] && cand[1] <= interval[1]);\\n\\t}\\n\\n\\t// Sorting\\n\\t// O(nlogn) O(1)\\n\\tpublic int removeCoveredIntervals2(int[][] intervals) {\\n\\n\\t\\tint len = intervals.length, rem = len;\\n\\t\\tArrays.sort(intervals, new Comparator<int[]>() {\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn (o1[0] != o2[0]) ? o1[0] - o2[0] : o2[1] - o1[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tint end = intervals[0][1];\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tif (intervals[i][1] <= end)\\n\\t\\t\\t\\trem--;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t}\\n\\t\\treturn rem;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\t// Brute Force\\n\\t// O(n*n) O(1)\\n\\tpublic int removeCoveredIntervals1(int[][] intervals) {\\n\\n\\t\\tint len = intervals.length, rem = len;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tfor (int j = 0; j < len; j++) {\\n\\t\\t\\t\\tif (i == j)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (overlap(intervals[i], intervals[j])) {\\n\\t\\t\\t\\t\\trem--;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn rem;\\n\\t}\\n\\n\\t// Overlapping\\n\\t// O(1) O(1)\\n\\tpublic boolean overlap(int[] cand, int[] interval) {\\n\\t\\treturn (interval[0] <= cand[0] && cand[1] <= interval[1]);\\n\\t}\\n\\n\\t// Sorting\\n\\t// O(nlogn) O(1)\\n\\tpublic int removeCoveredIntervals2(int[][] intervals) {\\n\\n\\t\\tint len = intervals.length, rem = len;\\n\\t\\tArrays.sort(intervals, new Comparator<int[]>() {\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn (o1[0] != o2[0]) ? o1[0] - o2[0] : o2[1] - o1[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tint end = intervals[0][1];\\n\\t\\tfor (int i = 1; i < len; i++) {\\n\\t\\t\\tif (intervals[i][1] <= end)\\n\\t\\t\\t\\trem--;\\n\\t\\t\\telse\\n\\t\\t\\t\\tend = intervals[i][1];\\n\\t\\t}\\n\\t\\treturn rem;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1275377,
                "title": "easy-c-solution-o-nlogn-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int> a,pair<int,int> b) {\\n          if(a.first==b.first) return a.second>b.second;\\n          else return a.first<b.first;\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& in) {\\n          vector<pair<int,int>> px;\\n          for(int i=0; i<in.size(); i++) px.push_back(make_pair(in[i][0],in[i][1]));\\n          sort(px.begin(),px.end(),comp);\\n          pair<int,int> cur=px.front();\\n          int del=0;\\n          for(int i=1; i<px.size(); i++) {\\n                 del+=(cur.first<=px[i].first && px[i].second<=cur.second);\\n                 cur=make_pair(min(px[i].first,cur.first),max(cur.second,px[i].second)); \\n          }\\n        return (int)in.size()-del; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(pair<int,int> a,pair<int,int> b) {\\n          if(a.first==b.first) return a.second>b.second;\\n          else return a.first<b.first;\\n    }\\n    int removeCoveredIntervals(vector<vector<int>>& in) {\\n          vector<pair<int,int>> px;\\n          for(int i=0; i<in.size(); i++) px.push_back(make_pair(in[i][0],in[i][1]));\\n          sort(px.begin(),px.end(),comp);\\n          pair<int,int> cur=px.front();\\n          int del=0;\\n          for(int i=1; i<px.size(); i++) {\\n                 del+=(cur.first<=px[i].first && px[i].second<=cur.second);\\n                 cur=make_pair(min(px[i].first,cur.first),max(cur.second,px[i].second)); \\n          }\\n        return (int)in.size()-del; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252228,
                "title": "easy-c-solution-commnted",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        //sort the intervals\\n        \\n        sort(intervals.begin(),intervals.end());\\n        int i=0;\\n        int j=1;\\n        int len=intervals.size();\\n        int removed=0;\\n        while(j<len)\\n        {\\n            //check whether interval i is covered by interval j\\n            if(intervals[j][0]<=intervals[i][0] && intervals[i][1]<=intervals[j][1])\\n            {\\n                //remove interval i since it is covered\\n                removed++;\\n                i=j;\\n                j++;\\n            }\\n            //check if interval j is covered by interval i\\n            else if(intervals[i][0]<=intervals[j][0] && intervals[j][1]<=intervals[i][1])\\n            {\\n                //remove interval j\\n                removed++;\\n                j++;\\n            }\\n            else\\n            {\\n                //if none of them have covered by each other\\n                i=j;\\n                j++;\\n            }\\n        }\\n        \\n        //return the remaining intervals\\n        return len-removed;\\n    }\\n};\\n```\\n**Please upote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        //sort the intervals\\n        \\n        sort(intervals.begin(),intervals.end());\\n        int i=0;\\n        int j=1;\\n        int len=intervals.size();\\n        int removed=0;\\n        while(j<len)\\n        {\\n            //check whether interval i is covered by interval j\\n            if(intervals[j][0]<=intervals[i][0] && intervals[i][1]<=intervals[j][1])\\n            {\\n                //remove interval i since it is covered\\n                removed++;\\n                i=j;\\n                j++;\\n            }\\n            //check if interval j is covered by interval i\\n            else if(intervals[i][0]<=intervals[j][0] && intervals[j][1]<=intervals[i][1])\\n            {\\n                //remove interval j\\n                removed++;\\n                j++;\\n            }\\n            else\\n            {\\n                //if none of them have covered by each other\\n                i=j;\\n                j++;\\n            }\\n        }\\n        \\n        //return the remaining intervals\\n        return len-removed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207022,
                "title": "c-greedy-solution-time-o-n-2-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int res = intervals.size();\\n        cout << res;\\n        \\n        for(int i = 0; i<intervals.size(); i++)\\n        {\\n            for(int j = 0; j<intervals.size(); j++)\\n            { \\n                if(i != j && intervals[i][0] >= intervals[j][0] && intervals[i][1] <= intervals[j][1] )\\n                { \\n                    res--;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}:\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        int res = intervals.size();\\n        cout << res;\\n        \\n        for(int i = 0; i<intervals.size(); i++)\\n        {\\n            for(int j = 0; j<intervals.size(); j++)\\n            { \\n                if(i != j && intervals[i][0] >= intervals[j][0] && intervals[i][1] <= intervals[j][1] )\\n                { \\n                    res--;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}:\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1205487,
                "title": "javascript-short-and-easy-solution-94-56",
                "content": "Runtime: 80 ms, faster than 94.87% of JavaScript online submissions for Remove Covered Intervals.\\nMemory Usage: 40.6 MB, less than 56.41% of JavaScript online submissions for Remove Covered Intervals.\\n```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals = intervals.sort((a,b)=>a[0]-b[0]);\\n    var result = [intervals[0]];\\n    for(i=1;i<intervals.length;i++){\\n        if(result[0][0]<=intervals[i][0] && result[0][1]>=intervals[i][1]) continue;\\n        if(result[0][0]>=intervals[i][0] && result[0][1]<=intervals[i][1]) result.shift();\\n        result.unshift(intervals[i]);    \\n    }\\n    return result.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals = intervals.sort((a,b)=>a[0]-b[0]);\\n    var result = [intervals[0]];\\n    for(i=1;i<intervals.length;i++){\\n        if(result[0][0]<=intervals[i][0] && result[0][1]>=intervals[i][1]) continue;\\n        if(result[0][0]>=intervals[i][0] && result[0][1]<=intervals[i][1]) result.shift();\\n        result.unshift(intervals[i]);    \\n    }\\n    return result.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1169591,
                "title": "c-priority-queue-beginner-friendly-commented-code",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    // IF START IS EQUAL THEN ARRANGE ON THE BASIS OF END VALUE AND PUT PAIR WITH MORE END VALUE FIRST\\n    struct comp{\\n        bool operator()(pair<int,int> p1,pair<int,int> p2){\\n            if(p1.first==p2.first)\\n                return p1.second<p2.second;\\n            return p1.first>p2.first;\\n        }\\n    };\\n    \\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,comp> pq;\\n        \\n        for(int i=0;i<intervals.size();i++)pq.push({intervals[i][0],intervals[i][1]});\\n        \\n        int x=0;                      // CALCULATE NO OF INTERVALS WHICH ARE TO BE REMOVED\\n        int start=pq.top().first;\\n        int end=pq.top().second;\\n        pq.pop();\\n        \\n        while(pq.size()!=0){\\n            pair<int,int> p=pq.top();pq.pop();\\n            if(p.first>=start && p.second<=end)x++;  // IF INTERVAL RESIDES IN THE BOUNDARY WE CREATED INCREASE X\\n            start=min(start,p.first);\\n            end=max(end,p.second);\\n        }\\n        cout<<x;\\n        return intervals.size()-x;  //RETURN ANSWER\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    // IF START IS EQUAL THEN ARRANGE ON THE BASIS OF END VALUE AND PUT PAIR WITH MORE END VALUE FIRST\\n    struct comp{\\n        bool operator()(pair<int,int> p1,pair<int,int> p2){\\n            if(p1.first==p2.first)\\n                return p1.second<p2.second;\\n            return p1.first>p2.first;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1137907,
                "title": "simple-java-solution-explained",
                "content": "Idea is say we have the test case : [[3,10],[4,10],[5,14],[5,11],[5,12]]\\nPost sorting : 3,10 / 4,10 / 5,14 / 5,12 / 5,11\\nAccording to this fitst our higher limit is 10. and the upper limit is already sorted in ascending order.\\ntherfore 4,10 is always in range of 3,10 hence not incremented. (In genenal all ranges which have upper limit less 10 lie btw 3,10)\\nthe next higher range is 14 .... all the numbers after it have higher ranges less than 14... hence the answer returned will be 2.\\nThis could be flawed only if a test case such as 15,14 would exist. but the testcases are such lower range has to be less than the upper range.\\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n\\t\\t//If the lower limit are not same it is sorted in descending. if the lower limit is same then in ascending.\\n        Arrays.sort(intervals,(a,b) -> a[0]==b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        // for(int i=0;i<intervals.length;i++)\\n        //     System.out.println(intervals[i][0]+\" \"+intervals[i][1]);\\n        \\n        int count = 0;\\n        int higher = Integer.MIN_VALUE;\\n        for(int i=0;i<intervals.length;i++)\\n        {\\n            \\n            if(intervals[i][1]>higher)\\n            {\\n                count++;\\n                higher = intervals[i][1];\\n                // System.out.println(count+\" \"+intervals[i][0]+\" \"+higher)//\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        \\n\\t\\t//If the lower limit are not same it is sorted in descending. if the lower limit is same then in ascending.\\n        Arrays.sort(intervals,(a,b) -> a[0]==b[0] ? b[1] - a[1] : a[0] - b[0]);\\n        // for(int i=0;i<intervals.length;i++)\\n        //     System.out.println(intervals[i][0]+\" \"+intervals[i][1]);\\n        \\n        int count = 0;\\n        int higher = Integer.MIN_VALUE;\\n        for(int i=0;i<intervals.length;i++)\\n        {\\n            \\n            if(intervals[i][1]>higher)\\n            {\\n                count++;\\n                higher = intervals[i][1];\\n                // System.out.println(count+\" \"+intervals[i][0]+\" \"+higher)//\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115118,
                "title": "4-line-simple-code-with-98-56-faster-with-o-1-space",
                "content": "JAVA CODE IS:\\n#   \\n```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n      Arrays.sort(intervals,(a,b) -> b[0]!=a[0] ? a[0]-b[0] : b[1]-a[1]);\\n      int max=0,remove=0;\\n       for(int a[] : intervals){\\n           if(a[1]<=max) remove++;\\n           max=Math.max(max,a[1]);\\n       }\\n        return intervals.length-remove;\\n    }\\n}\\n```\\n***PLEASE,UPVOTE IF THIS IS HELPFUL***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n      Arrays.sort(intervals,(a,b) -> b[0]!=a[0] ? a[0]-b[0] : b[1]-a[1]);\\n      int max=0,remove=0;\\n       for(int a[] : intervals){\\n           if(a[1]<=max) remove++;\\n           max=Math.max(max,a[1]);\\n       }\\n        return intervals.length-remove;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103130,
                "title": "java-2-solutions-brute-force-optimized-clean-solution",
                "content": "```\\nBRUTE FORCE O(n*n)\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int i=0;\\n      int count=0;\\n      for(int arr[]:intervals){\\n        boolean ci=false;                // cuvered interval\\n        int a=arr[0];\\n        int b=arr[1];\\n      \\n        for(int j=0;j<intervals.length;j++){\\n          if(i==j) continue;\\n           int c=intervals[j][0];\\n           int d=intervals[j][1];\\n      \\n\\t\\t   if(c<=a && b<=d){\\n                ci=true;\\n          }\\n          \\n        }\\n        if(!ci) { count++;\\n               \\n                }\\n        i++;\\n      }\\n       return count;\\n    }\\n}\\n```\\n```\\nO(nlogn) OPTIMIZED\\n if(intervals.length==1){\\n            return 1;\\n        }\\n      \\n           Arrays.sort(intervals, new java.util.Comparator<int[]>() {\\n    public int compare(int[] a, int[] b) {\\n        if(a[0]!=b[0]) return Integer.compare(a[0], b[0]);\\n        return Integer.compare(b[1], a[1]);\\n      \\n    }\\n});\\n      int last = 0;\\n        if(intervals.length==1){\\n            return 1;\\n        }\\n        last = intervals[0][1]-1;\\n        int res = 1;\\n        for(int i=1;i<intervals.length;i++){\\n            if(last<intervals[i][0] || last<intervals[i][1]-1){\\n                   last=intervals[i][1]-1;\\n                    res++;\\n            }\\n        }\\n        return res;\\n```",
                "solutionTags": [],
                "code": "```\\nBRUTE FORCE O(n*n)\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int i=0;\\n      int count=0;\\n      for(int arr[]:intervals){\\n        boolean ci=false;                // cuvered interval\\n        int a=arr[0];\\n        int b=arr[1];\\n      \\n        for(int j=0;j<intervals.length;j++){\\n          if(i==j) continue;\\n           int c=intervals[j][0];\\n           int d=intervals[j][1];\\n      \\n\\t\\t   if(c<=a && b<=d){\\n                ci=true;\\n          }\\n          \\n        }\\n        if(!ci) { count++;\\n               \\n                }\\n        i++;\\n      }\\n       return count;\\n    }\\n}\\n```\n```\\nO(nlogn) OPTIMIZED\\n if(intervals.length==1){\\n            return 1;\\n        }\\n      \\n           Arrays.sort(intervals, new java.util.Comparator<int[]>() {\\n    public int compare(int[] a, int[] b) {\\n        if(a[0]!=b[0]) return Integer.compare(a[0], b[0]);\\n        return Integer.compare(b[1], a[1]);\\n      \\n    }\\n});\\n      int last = 0;\\n        if(intervals.length==1){\\n            return 1;\\n        }\\n        last = intervals[0][1]-1;\\n        int res = 1;\\n        for(int i=1;i<intervals.length;i++){\\n            if(last<intervals[i][0] || last<intervals[i][1]-1){\\n                   last=intervals[i][1]-1;\\n                    res++;\\n            }\\n        }\\n        return res;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001457,
                "title": "python3-very-clean-simple-and-intuitive-greedy-o-nlogn-custom-sort",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[0], -x[1]))\\n        count = 0\\n        prev_end = -1\\n        \\n        for interval in intervals:\\n            if interval[1] <= prev_end:\\n                count += 1\\n            else:\\n                prev_end = interval[1]\\n                \\n        return (len(intervals) - count)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        intervals.sort(key=lambda x: (x[0], -x[1]))\\n        count = 0\\n        prev_end = -1\\n        \\n        for interval in intervals:\\n            if interval[1] <= prev_end:\\n                count += 1\\n            else:\\n                prev_end = interval[1]\\n                \\n        return (len(intervals) - count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910732,
                "title": "python-o-1-space-o-n-log-n-solution-easy",
                "content": "```\\nclass Solution(object):\\n    def isOverlapping(self, cs, ce, ps, pe):\\n        return cs <= ps <= pe <= ce or ps <= cs <= ce <= pe\\n\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort()\\n\\n        length = len(intervals)\\n        previousStart = intervals[0][0]\\n        previousEnd = intervals[0][1]\\n\\n        for i in range(1, len(intervals)):\\n            currentInterval = intervals[i]\\n\\n            currentStart = currentInterval[0]\\n\\n            currentEnd = currentInterval[1]\\n\\n            if self.isOverlapping(currentStart, currentEnd, previousStart, previousEnd):\\n                previousStart = min(previousStart, currentStart)\\n                previousEnd = max(previousEnd, currentEnd)\\n                length -= 1\\n            else:\\n                previousStart = currentStart\\n                previousEnd = currentEnd\\n\\n        return length               \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isOverlapping(self, cs, ce, ps, pe):\\n        return cs <= ps <= pe <= ce or ps <= cs <= ce <= pe\\n\\n    def removeCoveredIntervals(self, intervals):\\n        intervals.sort()\\n\\n        length = len(intervals)\\n        previousStart = intervals[0][0]\\n        previousEnd = intervals[0][1]\\n\\n        for i in range(1, len(intervals)):\\n            currentInterval = intervals[i]\\n\\n            currentStart = currentInterval[0]\\n\\n            currentEnd = currentInterval[1]\\n\\n            if self.isOverlapping(currentStart, currentEnd, previousStart, previousEnd):\\n                previousStart = min(previousStart, currentStart)\\n                previousEnd = max(previousEnd, currentEnd)\\n                length -= 1\\n            else:\\n                previousStart = currentStart\\n                previousEnd = currentEnd\\n\\n        return length               \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 908025,
                "title": "c-o-nlogn-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool static sortbysec(const pair<int,int> &a, const pair<int,int> &b) \\n        { \\n            if(a.first == b.first){\\n            return (a.second > b.second); }\\n            return a.first<b.first;\\n        }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size()==0){\\n            return 0;\\n        }\\n        vector<pair<int,int> > p;\\n        vector<int> v;\\n        int cnt=0;\\n        for(int i=0;i<intervals.size();i++){\\n            p.push_back(make_pair(intervals[i][0], intervals[i][1]));\\n        }\\n        sort(p.begin(), p.end(), sortbysec);\\n        for(int i=0;i<p.size();i++){\\n            v.push_back(p[i].second);\\n\\t\\t   }\\n        for(int i=0, j=1;i<v.size() && j<v.size();){\\n            if(v[i]<v[j]){\\n                i=j;\\n                j++;\\n            }\\n            else{\\n                cnt++;\\n                j++;\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static sortbysec(const pair<int,int> &a, const pair<int,int> &b) \\n        { \\n            if(a.first == b.first){\\n            return (a.second > b.second); }\\n            return a.first<b.first;\\n        }\\n    int removeCoveredIntervals(vector<vector<int>>& intervals) {\\n        if(intervals.size()==0){\\n            return 0;\\n        }\\n        vector<pair<int,int> > p;\\n        vector<int> v;\\n        int cnt=0;\\n        for(int i=0;i<intervals.size();i++){\\n            p.push_back(make_pair(intervals[i][0], intervals[i][1]));\\n        }\\n        sort(p.begin(), p.end(), sortbysec);\\n        for(int i=0;i<p.size();i++){\\n            v.push_back(p[i].second);\\n\\t\\t   }\\n        for(int i=0, j=1;i<v.size() && j<v.size();){\\n            if(v[i]<v[j]){\\n                i=j;\\n                j++;\\n            }\\n            else{\\n                cnt++;\\n                j++;\\n            }\\n        }\\n        return intervals.size()-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892292,
                "title": "javascript-greedy-time-o-n-log-n-space-o-log-n",
                "content": "```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n   \\n    let prevEnd = 0\\n    let count = 0\\n\\n    for(let i of intervals){\\n        const end = i[1]\\n        if(end > prevEnd){\\n            count++\\n            prevEnd = end\\n        }\\n    }\\n    return count\\n};\\n```\\ntime: O(n log n)\\nspace: O(log n)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeCoveredIntervals = function(intervals) {\\n    intervals.sort((a, b) => a[0] - b[0] || b[1] - a[1]);\\n   \\n    let prevEnd = 0\\n    let count = 0\\n\\n    for(let i of intervals){\\n        const end = i[1]\\n        if(end > prevEnd){\\n            count++\\n            prevEnd = end\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 890516,
                "title": "simple-python3-solution-with-clear-comments-faster-than-98-other-python-solutions",
                "content": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n            \\n        # edge cases (empty, only one)\\n        \\n        if len(intervals) == 0:\\n            return 0\\n        \\n        if len(intervals) == 1:\\n            return 1\\n        \\n        result = 1 # has to have at least one at this point, e.g. [1,4], [1,5]\\n                \\n        # need to sort!!!!\\n\\t\\t# we want to have smaller starting bounds first and then break ties using the smaller end bound\\n        \\n        lastSorted = sorted(intervals, key=lambda interval:interval[1])\\n        intervals = sorted(lastSorted, key=lambda interval:interval[0])\\n \\n        firstInterval = intervals[0]\\n        \\n        currStart = firstInterval[0]\\n        currEnd = firstInterval[1]\\n           \\n\\t\\t# since we already grabbed the first interval, start with the second and continue until the end\\n        for interval in intervals[1:]:\\n            tempStart = interval[0]\\n            tempEnd = interval[1]\\n            \\n            # 1) new interval falls entirely within current interval\\n            if tempEnd <= currEnd:\\n                # do nothing!! this is a covered interval\\n                doNothing = 0\\n\\t\\t\\t\\t\\n            # 2) new interval has same start and either same end or longer end\\n            elif tempStart == currStart and tempEnd >= currEnd:\\n                # this new one covers our current, and we switch to use it next\\n                currStart = tempStart\\n                currEnd = tempEnd\\n\\t\\t\\t\\t\\n            # 3) new interval falls completely to the right\\n            elif tempStart >= currEnd:\\n                result += 1 # counting our previous interval as uncovered\\n                currStart = tempStart\\n                currEnd = tempEnd\\n\\t\\t\\t\\t\\n            # 4) partial overlap\\n            elif tempStart > currStart and tempEnd > currEnd:\\n                result += 1\\n                currStart = tempStart\\n                currEnd = tempEnd\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n            \\n        # edge cases (empty, only one)\\n        \\n        if len(intervals) == 0:\\n            return 0\\n        \\n        if len(intervals) == 1:\\n            return 1\\n        \\n        result = 1 # has to have at least one at this point, e.g. [1,4], [1,5]\\n                \\n        # need to sort!!!!\\n\\t\\t# we want to have smaller starting bounds first and then break ties using the smaller end bound\\n        \\n        lastSorted = sorted(intervals, key=lambda interval:interval[1])\\n        intervals = sorted(lastSorted, key=lambda interval:interval[0])\\n \\n        firstInterval = intervals[0]\\n        \\n        currStart = firstInterval[0]\\n        currEnd = firstInterval[1]\\n           \\n\\t\\t# since we already grabbed the first interval, start with the second and continue until the end\\n        for interval in intervals[1:]:\\n            tempStart = interval[0]\\n            tempEnd = interval[1]\\n            \\n            # 1) new interval falls entirely within current interval\\n            if tempEnd <= currEnd:\\n                # do nothing!! this is a covered interval\\n                doNothing = 0\\n\\t\\t\\t\\t\\n            # 2) new interval has same start and either same end or longer end\\n            elif tempStart == currStart and tempEnd >= currEnd:\\n                # this new one covers our current, and we switch to use it next\\n                currStart = tempStart\\n                currEnd = tempEnd\\n\\t\\t\\t\\t\\n            # 3) new interval falls completely to the right\\n            elif tempStart >= currEnd:\\n                result += 1 # counting our previous interval as uncovered\\n                currStart = tempStart\\n                currEnd = tempEnd\\n\\t\\t\\t\\t\\n            # 4) partial overlap\\n            elif tempStart > currStart and tempEnd > currEnd:\\n                result += 1\\n                currStart = tempStart\\n                currEnd = tempEnd\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888568,
                "title": "java-nlogn-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        int count = 0;\\n        \\n        Arrays.sort(intervals , (a,b)->{\\n          return a[0] - b[0];\\n     });\\n        int beg = -1;\\n        int end = -1;\\n        int res = 0;\\n        for(int i=0 ; i<intervals.length ; i++){\\n          if(intervals[i][0] >beg && intervals[i][1]> end){\\n            beg = intervals[i][0];\\n            res++;\\n          }\\n          end = Math.max(end , intervals[i][1]);\\n        }\\n      return res;\\n       \\n    } \\n  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeCoveredIntervals(int[][] intervals) {\\n        int n = intervals.length;\\n        int count = 0;\\n        \\n        Arrays.sort(intervals , (a,b)->{\\n          return a[0] - b[0];\\n     });\\n        int beg = -1;\\n        int end = -1;\\n        int res = 0;\\n        for(int i=0 ; i<intervals.length ; i++){\\n          if(intervals[i][0] >beg && intervals[i][1]> end){\\n            beg = intervals[i][0];\\n            res++;\\n          }\\n          end = Math.max(end , intervals[i][1]);\\n        }\\n      return res;\\n       \\n    } \\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885354,
                "title": "python-3-two-solutions-explanation-stack-implementation",
                "content": "**Test Case**\\n\\nHere are some useful small test cases for debugging.\\n\\n`[[1,2],[1,3]]`\\n`[[1,3],[1,8],[5,8]]`\\n`[[1,6],[4,6],[4,8]]`\\n\\n# **Solution - 1**\\n\\nThe Idea is to use a `stack` and keep track of the `Covered Intervals` using the top of stack and replacing it when needed\\n\\n1.  Sort the `intervals` list\\n2.  Initialize the `stack`\\n3.  If stack[-1][0] (`a`)  <= intervals[i][0] (`c`) and stack[-1][1] (`b`)  <= intervals[i][0] (`d`) , we pass , as the range is already covered by `stack[-1]`\\n4.  If stack[-1][0] (`a`)  >= intervals[i][0] (`c`) and stack[-1][1] (`b`)  >= intervals[i][0] (`d`) , we update `stack[-1]` , as the range is not covered by `stack[-1]`\\n5.  In all other case , we append to the `stack`\\n\\n```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        stack = []\\n        \\n        n = len(intervals)\\n        \\n\\t\\t#### [1]\\n        intervals.sort(key=lambda x: (x[0],-x[1]))\\n        \\n        i = 0\\n        \\n        while i < n:\\n            if stack:\\n                while i < n:\\n\\t\\t\\t\\t\\t##### [3]\\n                    if stack[-1][0] <= intervals[i][0] and intervals[i][1] <= stack[-1][1]:\\n                        pass\\n\\t\\t\\t\\t\\t##### [4]\\n                    elif stack[-1][0] >= intervals[i][0] and intervals[i][1] >= stack[-1][1]:\\n                        stack[-1] = intervals[i]\\n\\t\\t\\t\\t\\t##### [5]\\n                    else:\\n                        stack += [intervals[i]]\\n                    i += 1\\n            else:\\n\\t\\t\\t\\t##### [2]\\n                stack += [intervals[i]]\\n                i += 1\\n        \\n        \\n        return len(stack)\\n```\\n\\n# **Solution - 2**\\nIdea is to only keep track of the `second index` of each `interval[i]`\\n\\n1.  Sort the `intervals` list\\n2.  Initialize `previous_end=0` and `res=0`\\n3.  if `current_end` > `previous_end` , increment `res` and update `previous_end` with `current_end`\\n\\n```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        ### [1]\\n        intervals.sort(key=lambda x: [x[0], -x[1]])\\n\\n        ### [2]\\n        previous_end, res = 0, 0\\n        \\n        for _, current_end in intervals:\\n\\t\\t    ### [3]\\n            if current_end > previous_end:\\n                res += 1\\n                previous_end = current_end\\n        \\n        return res\\n```\\n\\nIf you like the solutions do `Up Vote`",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        stack = []\\n        \\n        n = len(intervals)\\n        \\n\\t\\t#### [1]\\n        intervals.sort(key=lambda x: (x[0],-x[1]))\\n        \\n        i = 0\\n        \\n        while i < n:\\n            if stack:\\n                while i < n:\\n\\t\\t\\t\\t\\t##### [3]\\n                    if stack[-1][0] <= intervals[i][0] and intervals[i][1] <= stack[-1][1]:\\n                        pass\\n\\t\\t\\t\\t\\t##### [4]\\n                    elif stack[-1][0] >= intervals[i][0] and intervals[i][1] >= stack[-1][1]:\\n                        stack[-1] = intervals[i]\\n\\t\\t\\t\\t\\t##### [5]\\n                    else:\\n                        stack += [intervals[i]]\\n                    i += 1\\n            else:\\n\\t\\t\\t\\t##### [2]\\n                stack += [intervals[i]]\\n                i += 1\\n        \\n        \\n        return len(stack)\\n```\n```\\ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\\n        ### [1]\\n        intervals.sort(key=lambda x: [x[0], -x[1]])\\n\\n        ### [2]\\n        previous_end, res = 0, 0\\n        \\n        for _, current_end in intervals:\\n\\t\\t    ### [3]\\n            if current_end > previous_end:\\n                res += 1\\n                previous_end = current_end\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1566210,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-covered-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LavenderViking",
                        "content": "Solutions pass w/o getting [[1,4],[3,6],[2,8],[1,9]] correctly. I.e. users will be accepted even if they forgot sorting decreasing by second value."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "nah this is a stack problem"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "brute force solution works :O"
                    },
                    {
                        "username": "ruokay",
                        "content": "just like every interval problem :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of the easier ones tbh. Insert Interval is a nightmare "
                    }
                ]
            },
            {
                "id": 1568319,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-covered-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LavenderViking",
                        "content": "Solutions pass w/o getting [[1,4],[3,6],[2,8],[1,9]] correctly. I.e. users will be accepted even if they forgot sorting decreasing by second value."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "nah this is a stack problem"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "brute force solution works :O"
                    },
                    {
                        "username": "ruokay",
                        "content": "just like every interval problem :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of the easier ones tbh. Insert Interval is a nightmare "
                    }
                ]
            },
            {
                "id": 2008477,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-covered-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LavenderViking",
                        "content": "Solutions pass w/o getting [[1,4],[3,6],[2,8],[1,9]] correctly. I.e. users will be accepted even if they forgot sorting decreasing by second value."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "nah this is a stack problem"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "brute force solution works :O"
                    },
                    {
                        "username": "ruokay",
                        "content": "just like every interval problem :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of the easier ones tbh. Insert Interval is a nightmare "
                    }
                ]
            },
            {
                "id": 1980424,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-covered-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LavenderViking",
                        "content": "Solutions pass w/o getting [[1,4],[3,6],[2,8],[1,9]] correctly. I.e. users will be accepted even if they forgot sorting decreasing by second value."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "nah this is a stack problem"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "brute force solution works :O"
                    },
                    {
                        "username": "ruokay",
                        "content": "just like every interval problem :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of the easier ones tbh. Insert Interval is a nightmare "
                    }
                ]
            },
            {
                "id": 1905429,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-covered-intervals/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "LavenderViking",
                        "content": "Solutions pass w/o getting [[1,4],[3,6],[2,8],[1,9]] correctly. I.e. users will be accepted even if they forgot sorting decreasing by second value."
                    },
                    {
                        "username": "Eckhart01",
                        "content": "nah this is a stack problem"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "brute force solution works :O"
                    },
                    {
                        "username": "ruokay",
                        "content": "just like every interval problem :)"
                    },
                    {
                        "username": "mochiball",
                        "content": "This is one of the easier ones tbh. Insert Interval is a nightmare "
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Falling Path Sum II",
        "question_content": "<p>Given an <code>n x n</code> integer matrix <code>grid</code>, return <em>the minimum sum of a <strong>falling path with non-zero shifts</strong></em>.</p>\n\n<p>A <strong>falling path with non-zero shifts</strong> is a choice of exactly one element from each row of <code>grid</code> such that no two elements chosen in adjacent rows are in the same column.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/08/10/falling-grid.jpg\" style=\"width: 244px; height: 245px;\" />\n<pre>\n<strong>Input:</strong> grid = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> 13\n<strong>Explanation:</strong> \nThe possible falling paths are:\n[1,5,9], [1,5,7], [1,6,7], [1,6,8],\n[2,4,8], [2,4,9], [2,6,7], [2,6,8],\n[3,4,8], [3,4,9], [3,5,7], [3,5,9]\nThe falling path with the smallest sum is&nbsp;[1,5,7], so the answer is&nbsp;13.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[7]]\n<strong>Output:</strong> 7\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == grid.length == grid[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 200</code></li>\n\t<li><code>-99 &lt;= grid[i][j] &lt;= 99</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 451273,
                "title": "python-dp-o-mn",
                "content": "\\nFind the 2 minimum value in the previous row.\\n\\n**Python:**\\n```python\\n    def minFallingPathSum(self, A):\\n        for i in xrange(1, len(A)):\\n            r = heapq.nsmallest(2, A[i - 1])\\n            for j in xrange(len(A[0])):\\n                A[i][j] += r[1] if A[i - 1][j] == r[0] else r[0]\\n        return min(A[-1])\\n```",
                "solutionTags": [],
                "code": "```python\\n    def minFallingPathSum(self, A):\\n        for i in xrange(1, len(A)):\\n            r = heapq.nsmallest(2, A[i - 1])\\n            for j in xrange(len(A[0])):\\n                A[i][j] += r[1] if A[i - 1][j] == r[0] else r[0]\\n        return min(A[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 452207,
                "title": "c-o-nm-o-1",
                "content": "Think about the most straightforward solution: find the minimum element in the first row, add it to the minimum element in the second row, and so on.\\n\\nThat should work, unless two minimum elements are in the same column. To account for that, let\\'s remember the position `pos` of the minimum element `fm`. Also, we need to remember the second minimum element `sm`.\\n\\nFor the next row, we will use `fm` for columns different than `pos`, and `sm` otherwise.\\n```\\nint minFallingPathSum(vector<vector<int>>& arr) {\\n    int fm = 0, sm = 0, pos = -1;\\n    for (auto i = 0; i < arr.size(); ++i) {\\n        auto fm2 = INT_MAX, sm2 = INT_MAX, pos2 = -1;\\n        for (auto j = 0; j < arr[i].size(); ++j) {\\n            auto mn = j != pos ? fm : sm;\\n            if (arr[i][j] + mn < fm2) {\\n                sm2 = fm2;\\n                fm2 = arr[i][j] + mn;\\n                pos2 = j;\\n            } else sm2 = min(sm2, arr[i][j] + mn);\\n        }\\n        fm = fm2, sm = sm2, pos = pos2;\\n    }\\n    return fm;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minFallingPathSum(vector<vector<int>>& arr) {\\n    int fm = 0, sm = 0, pos = -1;\\n    for (auto i = 0; i < arr.size(); ++i) {\\n        auto fm2 = INT_MAX, sm2 = INT_MAX, pos2 = -1;\\n        for (auto j = 0; j < arr[i].size(); ++j) {\\n            auto mn = j != pos ? fm : sm;\\n            if (arr[i][j] + mn < fm2) {\\n                sm2 = fm2;\\n                fm2 = arr[i][j] + mn;\\n                pos2 = j;\\n            } else sm2 = min(sm2, arr[i][j] + mn);\\n        }\\n        fm = fm2, sm = sm2, pos = pos2;\\n    }\\n    return fm;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 723719,
                "title": "c-easy-dp-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size() ;\\n        vector<int> dp ;\\n        dp = arr[n-1] ;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            int firstmin=INT_MAX,secondmin=INT_MAX,firstminindex ;\\n            for (int j=0;j<n;j++){\\n                if (firstmin>dp[j]){                    //calculating first min\\n                    firstmin = dp[j] ;\\n                    firstminindex = j ;\\n                }\\n            }for (int j=0;j<n;j++){\\n                if (j==firstminindex)continue ;                          //second min\\n                secondmin = min(secondmin,dp[j]) ;\\n            }\\n            for (int j=0;j<n;j++){\\n                if (j==firstminindex) dp[j]=arr[i][j]+secondmin ;  \\n                else dp[j] = arr[i][j]+firstmin ;\\n            }\\n        }\\n        return *min_element(dp.begin(),dp.end());\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size() ;\\n        vector<int> dp ;\\n        dp = arr[n-1] ;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            int firstmin=INT_MAX,secondmin=INT_MAX,firstminindex ;\\n            for (int j=0;j<n;j++){\\n                if (firstmin>dp[j]){                    //calculating first min\\n                    firstmin = dp[j] ;\\n                    firstminindex = j ;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 451255,
                "title": "c-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int f(vector<vector<int>>& arr, int i, int j) {\\n        if(i == arr.size())\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = 0; k < arr[0].size(); k++) {\\n            if(k == j)\\n                continue;\\n            int curr = arr[i][j] + f(arr, i + 1, k);\\n            ans = min(ans, curr);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int ans = INT_MAX;\\n        memset(dp, -1, sizeof dp);\\n        for(int j = 0; j < arr[0].size(); j++) {\\n            ans = min(ans, f(arr, 0, j));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int f(vector<vector<int>>& arr, int i, int j) {\\n        if(i == arr.size())\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = 0; k < arr[0].size(); k++) {\\n            if(k == j)\\n                continue;\\n            int curr = arr[i][j] + f(arr, i + 1, k);\\n            ans = min(ans, curr);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int ans = INT_MAX;\\n        memset(dp, -1, sizeof dp);\\n        for(int j = 0; j < arr[0].size(); j++) {\\n            ans = min(ans, f(arr, 0, j));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451258,
                "title": "simple-dp-java-same-problem-as-paint-house-2-265",
                "content": "For every element in every column starting from second last row,\\ncount minimum on the left & minimum on the right.\\n\\n```\\npublic int minFallingPathSum(int[][] arr) {\\n        int n = arr.length;\\n        for (int row=n-2;row>=0;row--) {\\n            for (int col=0;col<n;col++) {\\n                int min = Integer.MAX_VALUE;\\n                // Values to the left.\\n                for(int k=0;k<col;k++) {\\n                    min = Math.min(arr[row+1][k],min);\\n                }\\n                // Values to the right.\\n                for (int k=col+1;k<n;k++) {\\n                    min = Math.min(arr[row+1][k],min);\\n                }\\n                arr[row][col]+= min;\\n            }\\n        }\\n        int result = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; ++i) {\\n            result = Math.min(result, arr[0][i]);\\n        }\\n        return result;\\n    }\\n```\\n\\nAs mentioned by @wushangzhen, This problem is very similar to problem no 265 [Paint House 2](https://leetcode.com/problems/paint-house-ii/).(PREMIUM)",
                "solutionTags": [],
                "code": "```\\npublic int minFallingPathSum(int[][] arr) {\\n        int n = arr.length;\\n        for (int row=n-2;row>=0;row--) {\\n            for (int col=0;col<n;col++) {\\n                int min = Integer.MAX_VALUE;\\n                // Values to the left.\\n                for(int k=0;k<col;k++) {\\n                    min = Math.min(arr[row+1][k],min);\\n                }\\n                // Values to the right.\\n                for (int k=col+1;k<n;k++) {\\n                    min = Math.min(arr[row+1][k],min);\\n                }\\n                arr[row][col]+= min;\\n            }\\n        }\\n        int result = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; ++i) {\\n            result = Math.min(result, arr[0][i]);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067940,
                "title": "recursion-memoization-iterative-iterative-with-space-optimisaton",
                "content": "**Recursion & Memoization:**\\n```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& grid, int i, int j, vector<vector<int>>&dp){\\n        if(i == grid.size())\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans =  INT_MAX;\\n        for(int k = 0; k < grid[0].size(); k++){\\n            if(j == k)\\n                continue;\\n            ans = min(ans, fun(grid,i + 1, k, dp) + grid[i][j]);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        if(n == 1)\\n            return grid[0][0];\\n        vector<vector<int>>dp(n, vector<int>(n, -1));\\n        int ans = INT_MAX;\\n        for(int j = 0; j < n; j++)\\n            ans = min(ans, fun(grid, 0, j, dp));\\n        return ans;\\n    }\\n};\\n```\\n\\n**Iterative DP**\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        if(n == 1)\\n            return grid[0][0];\\n \\n        vector<vector<int>>dp(n, vector<int>(n));\\n       \\n        for(int j = 0; j < n; j++)\\n            dp[0][j] = grid[0][j];\\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                int ans = INT_MAX;\\n                for(int k = 0; k < n; k++){\\n                    if(j == k)\\n                        continue;\\n                     ans = min(ans, dp[i - 1][k] + grid[i][j]);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return *min_element(dp[n - 1].begin(), dp[n - 1].end());\\n    }\\n};\\n```\\n\\n**Iterative with space optimisation**\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        if(n == 1)\\n            return grid[0][0];\\n        \\n        vector<int>prev(n);\\n        //base case :\\n        for(int j = 0; j < n; j++)\\n            prev[j] = grid[0][j];\\n        \\n        for(int i = 1; i < n; i++){\\n            vector<int> curr(n);\\n            for(int j = 0; j < n; j++){\\n                int ans = INT_MAX;\\n                for(int k = 0; k < n; k++){\\n                    if(j == k)\\n                        continue;\\n                     ans = min(ans, prev[k] + grid[i][j]);\\n                }\\n                curr[j] = ans;\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(prev.begin(), prev.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& grid, int i, int j, vector<vector<int>>&dp){\\n        if(i == grid.size())\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans =  INT_MAX;\\n        for(int k = 0; k < grid[0].size(); k++){\\n            if(j == k)\\n                continue;\\n            ans = min(ans, fun(grid,i + 1, k, dp) + grid[i][j]);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        if(n == 1)\\n            return grid[0][0];\\n        vector<vector<int>>dp(n, vector<int>(n, -1));\\n        int ans = INT_MAX;\\n        for(int j = 0; j < n; j++)\\n            ans = min(ans, fun(grid, 0, j, dp));\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        if(n == 1)\\n            return grid[0][0];\\n \\n        vector<vector<int>>dp(n, vector<int>(n));\\n       \\n        for(int j = 0; j < n; j++)\\n            dp[0][j] = grid[0][j];\\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                int ans = INT_MAX;\\n                for(int k = 0; k < n; k++){\\n                    if(j == k)\\n                        continue;\\n                     ans = min(ans, dp[i - 1][k] + grid[i][j]);\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        return *min_element(dp[n - 1].begin(), dp[n - 1].end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        if(n == 1)\\n            return grid[0][0];\\n        \\n        vector<int>prev(n);\\n        //base case :\\n        for(int j = 0; j < n; j++)\\n            prev[j] = grid[0][j];\\n        \\n        for(int i = 1; i < n; i++){\\n            vector<int> curr(n);\\n            for(int j = 0; j < n; j++){\\n                int ans = INT_MAX;\\n                for(int k = 0; k < n; k++){\\n                    if(j == k)\\n                        continue;\\n                     ans = min(ans, prev[k] + grid[i][j]);\\n                }\\n                curr[j] = ans;\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(prev.begin(), prev.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660734,
                "title": "simple-dp-java-o-nm-o-1",
                "content": "Find FirstMin and SecondMin values for previous rows.\\nIf FirstMin is same as the value of current elements\\'s previous row\\'s same column value add SecondMin else add FirstMin.\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        for(int i=1; i<A.length; i++)\\n        {\\n            int[] min = getMinOneAndTwo(A[i-1]);\\n            for(int j=0; j<A.length; j++)\\n            {\\n                if(A[i-1][j]==min[0])\\n                    A[i][j]+=min[1];\\n                else\\n                    A[i][j]+=min[0];                    \\n            }\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<A.length; i++)\\n        {\\n            min=Math.min(min, A[A.length-1][i]);\\n        }\\n        return min;\\n    }\\n    \\n    private int[] getMinOneAndTwo(int[] nums)\\n    {\\n        int[] res = new int[2];\\n        res[0] = res[1] = Integer.MAX_VALUE;\\n        for(int num:nums)\\n        {\\n            if(res[0]>num)\\n            {\\n                res[1]=res[0];\\n                res[0]=num;\\n                continue;\\n            }\\n            if(res[1]>num)\\n            {\\n                res[1]=num;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        for(int i=1; i<A.length; i++)\\n        {\\n            int[] min = getMinOneAndTwo(A[i-1]);\\n            for(int j=0; j<A.length; j++)\\n            {\\n                if(A[i-1][j]==min[0])\\n                    A[i][j]+=min[1];\\n                else\\n                    A[i][j]+=min[0];                    \\n            }\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<A.length; i++)\\n        {\\n            min=Math.min(min, A[A.length-1][i]);\\n        }\\n        return min;\\n    }\\n    \\n    private int[] getMinOneAndTwo(int[] nums)\\n    {\\n        int[] res = new int[2];\\n        res[0] = res[1] = Integer.MAX_VALUE;\\n        for(int num:nums)\\n        {\\n            if(res[0]>num)\\n            {\\n                res[1]=res[0];\\n                res[0]=num;\\n                continue;\\n            }\\n            if(res[1]>num)\\n            {\\n                res[1]=num;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016436,
                "title": "c-3-solution-dynamic-programming-easy",
                "content": "**Recursive Solution : (TLE)**\\n```\\nclass Solution {\\npublic:\\n    int path(int i,int j,vector<vector<int>>& grid){\\n        if(j<0 || j>=grid.size()) return 1e8;\\n        if(i==0) return grid[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid.size();k++){\\n            if(k==j) continue;\\n            ans=min(ans,grid[i][j]+path(i-1,k,grid));\\n        }\\n        return ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int mini=INT_MAX;\\n        for(int i=0;i<grid.size();i++){\\n            mini=min(mini,path(grid.size()-1,i,grid));\\n        }\\n        return mini;\\n    }\\n};\\n```\\n**Memoization Solution :**\\n```\\nclass Solution {\\npublic:\\n    int path(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& dp){\\n        if(j<0 || j>=grid.size()) return 1e8;\\n        if(i==0) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid.size();k++){\\n            if(k==j) continue;\\n            ans=min(ans,grid[i][j]+path(i-1,k,grid,dp));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int mini=INT_MAX;\\n        vector<vector<int>> dp(grid.size(),vector<int> (grid[0].size(),-1));\\n        for(int i=0;i<grid.size();i++){\\n            mini=min(mini,path(grid.size()-1,i,grid,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```\\n**Tabulation Solution :**\\n```\\nclass Solution {\\npublic:    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        vector<vector<int>> dp(grid.size(),vector<int> (grid[0].size(),-1));\\n        for(int i=0;i<grid.size();i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n        \\n        int mini=INT_MAX;\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=0;j<grid.size();j++){\\n                int ans=INT_MAX;\\n                for(int k=0;k<grid.size();k++){\\n                    if(j==k) continue;\\n                    ans=min(ans,grid[i][j]+dp[i-1][k]);\\n                }\\n                dp[i][j]=ans;\\n            }\\n        }\\n        for(int i=0;i<grid[0].size();i++){\\n            mini=min(mini,dp[grid.size()-1][i]);\\n        }\\n        return mini;\\n    }\\n};\\n```\\n\\n**Please Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int path(int i,int j,vector<vector<int>>& grid){\\n        if(j<0 || j>=grid.size()) return 1e8;\\n        if(i==0) return grid[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid.size();k++){\\n            if(k==j) continue;\\n            ans=min(ans,grid[i][j]+path(i-1,k,grid));\\n        }\\n        return ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int mini=INT_MAX;\\n        for(int i=0;i<grid.size();i++){\\n            mini=min(mini,path(grid.size()-1,i,grid));\\n        }\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int path(int i,int j,vector<vector<int>>& grid,vector<vector<int>>& dp){\\n        if(j<0 || j>=grid.size()) return 1e8;\\n        if(i==0) return grid[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=INT_MAX;\\n        for(int k=0;k<grid.size();k++){\\n            if(k==j) continue;\\n            ans=min(ans,grid[i][j]+path(i-1,k,grid,dp));\\n        }\\n        return dp[i][j]=ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int mini=INT_MAX;\\n        vector<vector<int>> dp(grid.size(),vector<int> (grid[0].size(),-1));\\n        for(int i=0;i<grid.size();i++){\\n            mini=min(mini,path(grid.size()-1,i,grid,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        vector<vector<int>> dp(grid.size(),vector<int> (grid[0].size(),-1));\\n        for(int i=0;i<grid.size();i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n        \\n        int mini=INT_MAX;\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=0;j<grid.size();j++){\\n                int ans=INT_MAX;\\n                for(int k=0;k<grid.size();k++){\\n                    if(j==k) continue;\\n                    ans=min(ans,grid[i][j]+dp[i-1][k]);\\n                }\\n                dp[i][j]=ans;\\n            }\\n        }\\n        for(int i=0;i<grid[0].size();i++){\\n            mini=min(mini,dp[grid.size()-1][i]);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689243,
                "title": "java-simple-dp",
                "content": "```\\n    public int minFallingPathSum(int[][] arr) {\\n        int m = arr.length, n = arr[0].length, dp[][] = new int[m][n], res = Integer.MAX_VALUE;\\n        for (int i = 0; i < m; i++) {\\n            if (i == 0) {dp[i] = arr[i]; continue;}\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < n; k++) {\\n                    if (j != k) dp[i][j] = Math.min(dp[i][j], arr[i][j] + dp[i - 1][k]);\\n                }\\n                if (i == m - 1) res = Math.min(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nVersion 2:  (Thanks to @saurabhrk for helps in debugging)\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        int m = arr.length, n = arr[0].length, dp[][] = new int[m][2], min[][] = new int[m][2];\\n        for (int i = 0; i < m; i++) {\\n            min[i] = getMin(arr[i]);\\n            if (i == 0) {dp[i] = new int[] {arr[i][min[i][0]], arr[i][min[i][1]]}; continue;}\\n            for (int j = 0; j < 2; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < 2; k++) {\\n                    if (min[i][j] != min[i - 1][k]) {\\n                        dp[i][j] = Math.min(dp[i][j], arr[i][min[i][j]] + dp[i - 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        return Math.min(dp[m - 1][0], dp[m - 1][1]);\\n    }\\n    \\n    private int[] getMin(int[] arr) {\\n        int a = Integer.MAX_VALUE, b = a, x = 0, y = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] <= a) {\\n                b = a;\\n                y = x;\\n                a = arr[i];\\n                x = i;\\n            } else if (arr[i] < b) {\\n                b = arr[i];\\n                y = i;\\n            }\\n        }\\n        return new int[]{x, y};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minFallingPathSum(int[][] arr) {\\n        int m = arr.length, n = arr[0].length, dp[][] = new int[m][n], res = Integer.MAX_VALUE;\\n        for (int i = 0; i < m; i++) {\\n            if (i == 0) {dp[i] = arr[i]; continue;}\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < n; k++) {\\n                    if (j != k) dp[i][j] = Math.min(dp[i][j], arr[i][j] + dp[i - 1][k]);\\n                }\\n                if (i == m - 1) res = Math.min(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        int m = arr.length, n = arr[0].length, dp[][] = new int[m][2], min[][] = new int[m][2];\\n        for (int i = 0; i < m; i++) {\\n            min[i] = getMin(arr[i]);\\n            if (i == 0) {dp[i] = new int[] {arr[i][min[i][0]], arr[i][min[i][1]]}; continue;}\\n            for (int j = 0; j < 2; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                for (int k = 0; k < 2; k++) {\\n                    if (min[i][j] != min[i - 1][k]) {\\n                        dp[i][j] = Math.min(dp[i][j], arr[i][min[i][j]] + dp[i - 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        return Math.min(dp[m - 1][0], dp[m - 1][1]);\\n    }\\n    \\n    private int[] getMin(int[] arr) {\\n        int a = Integer.MAX_VALUE, b = a, x = 0, y = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] <= a) {\\n                b = a;\\n                y = x;\\n                a = arr[i];\\n                x = i;\\n            } else if (arr[i] < b) {\\n                b = arr[i];\\n                y = i;\\n            }\\n        }\\n        return new int[]{x, y};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451252,
                "title": "simple-python-o-mn-time-and-o-n-space-dp-solution",
                "content": "Memo is an array that keeps track of the minimum falling path in each row, and solve function is to figure out the two minimum number in the current array.\\n\\nFor each level, as long as the index of current number does not equals to the index of the previous minimum path, we can choose the minimum path, otherwise choose the second minimum path.\\n\\nFor this reason, only keep track of two number in each row is enough.\\n\\nTime complexity analysis: For each row, I use O(n) time to build minimum path, and O(n) time to find the two optimal path, so overall all time complexity is O(2mn) = O(mn)\\n```\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        rl, cl = len(arr), len(arr[0])\\n        memo = [float(\\'inf\\') for _ in range(cl)]\\n        \\n        #m1, m2 are the two smallest number in the given arr, and i1 is the index of the smallest number\\n        def find_two_smallest(a):\\n            m1, m2 = float(\\'inf\\'), float(\\'inf\\')\\n            for i, x in enumerate(a):\\n                if x <= m1:\\n                    m1, m2, i1 = x, m1, i\\n                elif x < m2:\\n                    m2 = x\\n            return [m1, m2, i1]\\n        \\n        d = find_two_smallest(arr[0])\\n        for i in range(1,rl):\\n            for j in range(cl):\\n                if d[2] == j:\\n                    memo[j] = d[1] + arr[i][j]\\n                else:\\n                    memo[j] = d[0] + arr[i][j]\\n            d = find_two_smallest(memo)\\n        return d[0]",
                "solutionTags": [],
                "code": "Memo is an array that keeps track of the minimum falling path in each row, and solve function is to figure out the two minimum number in the current array.\\n\\nFor each level, as long as the index of current number does not equals to the index of the previous minimum path, we can choose the minimum path, otherwise choose the second minimum path.\\n\\nFor this reason, only keep track of two number in each row is enough.\\n\\nTime complexity analysis: For each row, I use O(n) time to build minimum path, and O(n) time to find the two optimal path, so overall all time complexity is O(2mn) = O(mn)\\n```\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        rl, cl = len(arr), len(arr[0])\\n        memo = [float(\\'inf\\') for _ in range(cl)]\\n        \\n        #m1, m2 are the two smallest number in the given arr, and i1 is the index of the smallest number\\n        def find_two_smallest(a):\\n            m1, m2 = float(\\'inf\\'), float(\\'inf\\')\\n            for i, x in enumerate(a):\\n                if x <= m1:\\n                    m1, m2, i1 = x, m1, i\\n                elif x < m2:\\n                    m2 = x\\n            return [m1, m2, i1]\\n        \\n        d = find_two_smallest(arr[0])\\n        for i in range(1,rl):\\n            for j in range(cl):\\n                if d[2] == j:\\n                    memo[j] = d[1] + arr[i][j]\\n                else:\\n                    memo[j] = d[0] + arr[i][j]\\n            d = find_two_smallest(memo)\\n        return d[0]",
                "codeTag": "Java"
            },
            {
                "id": 451471,
                "title": "swift-runtime-error",
                "content": "```\\nclass Solution {\\n    func minFallingPathSum(_ arr: [[Int]]) -> Int {\\n        let count = arr.count \\n        var newArr = arr\\n        for i in 1..<count {\\n            for j in 0..<count {\\n                let val = newArr[i][j]\\n                var minV = Int.max\\n                for t in 0..<count where t != j {\\n                    minV = min(minV, val + newArr[i-1][t])    \\n                }\\n                newArr[i][j] = minV\\n            }\\n        }\\n        return newArr[count-1].min()! \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func minFallingPathSum(_ arr: [[Int]]) -> Int {\\n        let count = arr.count \\n        var newArr = arr\\n        for i in 1..<count {\\n            for j in 0..<count {\\n                let val = newArr[i][j]\\n                var minV = Int.max\\n                for t in 0..<count where t != j {\\n                    minV = min(minV, val + newArr[i-1][t])    \\n                }\\n                newArr[i][j] = minV\\n            }\\n        }\\n        return newArr[count-1].min()! \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967759,
                "title": "java-80-faster-tabulation-minimun-second-minimum-same-as-paint-fence-2",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int min=Integer.MAX_VALUE,smin = Integer.MAX_VALUE,n=grid.length;\\n        int[][] dp = new int[n][n];\\n        for(int i=0;i<n;i++){\\n            if(min > grid[n-1][i]){\\n                smin = min;\\n                min = grid[n-1][i];\\n            }else if(grid[n-1][i] < smin && grid[n-1][i] != min) smin = grid[n-1][i];\\n            map.put(grid[n-1][i],map.getOrDefault(grid[n-1][i],0)+1);\\n            dp[n-1][i] = grid[n-1][i];\\n        }\\n        if(map.get(min) > 1) smin = min;\\n        for(int i=n-2;i>=0;i--){\\n            map = new HashMap<>();\\n            int nMin=Integer.MAX_VALUE,nSmin = Integer.MAX_VALUE;\\n            for(int j=0;j<n;j++){\\n                if(dp[i+1][j] == min) dp[i][j] = grid[i][j] + smin;\\n                else dp[i][j] = grid[i][j] + min;\\n                \\n                if(nMin > dp[i][j]){\\n                    nSmin = nMin;\\n                    nMin = dp[i][j];\\n                }else if(dp[i][j] < nSmin && dp[i][j] != nMin) nSmin = dp[i][j];\\n                map.put(dp[i][j],map.getOrDefault(dp[i][j],0)+1);\\n            }\\n            if(map.get(nMin) > 1) nSmin = nMin;\\n            min = nMin;\\n            smin = nSmin;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int min=Integer.MAX_VALUE,smin = Integer.MAX_VALUE,n=grid.length;\\n        int[][] dp = new int[n][n];\\n        for(int i=0;i<n;i++){\\n            if(min > grid[n-1][i]){\\n                smin = min;\\n                min = grid[n-1][i];\\n            }else if(grid[n-1][i] < smin && grid[n-1][i] != min) smin = grid[n-1][i];\\n            map.put(grid[n-1][i],map.getOrDefault(grid[n-1][i],0)+1);\\n            dp[n-1][i] = grid[n-1][i];\\n        }\\n        if(map.get(min) > 1) smin = min;\\n        for(int i=n-2;i>=0;i--){\\n            map = new HashMap<>();\\n            int nMin=Integer.MAX_VALUE,nSmin = Integer.MAX_VALUE;\\n            for(int j=0;j<n;j++){\\n                if(dp[i+1][j] == min) dp[i][j] = grid[i][j] + smin;\\n                else dp[i][j] = grid[i][j] + min;\\n                \\n                if(nMin > dp[i][j]){\\n                    nSmin = nMin;\\n                    nMin = dp[i][j];\\n                }else if(dp[i][j] < nSmin && dp[i][j] != nMin) nSmin = dp[i][j];\\n                map.put(dp[i][j],map.getOrDefault(dp[i][j],0)+1);\\n            }\\n            if(map.get(nMin) > 1) nSmin = nMin;\\n            min = nMin;\\n            smin = nSmin;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 618129,
                "title": "cpp-simple-easy-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& arr,int i,int j,vector<vector<int>> &dp) {\\n        if(dp[i+1][j]!=INT_MAX)\\n            return dp[i+1][j];\\n        int s=INT_MAX;\\n        if(j==arr.size())\\n            return 0;\\n        for(int p=0;p<arr[j].size();p++){\\n            if(p==i)\\n                continue;\\n            else\\n                s=min(s,arr[j][p]+dfs(arr,p,j+1,dp));\\n        }\\n        return dp[i+1][j]=s;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        vector<vector<int>>dp(202, vector<int>(202,INT_MAX));\\n        return dfs(arr,-1,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& arr,int i,int j,vector<vector<int>> &dp) {\\n        if(dp[i+1][j]!=INT_MAX)\\n            return dp[i+1][j];\\n        int s=INT_MAX;\\n        if(j==arr.size())\\n            return 0;\\n        for(int p=0;p<arr[j].size();p++){\\n            if(p==i)\\n                continue;\\n            else\\n                s=min(s,arr[j][p]+dfs(arr,p,j+1,dp));\\n        }\\n        return dp[i+1][j]=s;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        vector<vector<int>>dp(202, vector<int>(202,INT_MAX));\\n        return dfs(arr,-1,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451262,
                "title": "java-recursion-memoization",
                "content": "```\\nclass Solution {\\n    public static int func(int[][] arr, int n, int m, int i, int k, int[][] dp){\\n        if(i == n) return 0;\\n        if(dp[i][k] != -1) return dp[i][k];\\n        int min = Integer.MAX_VALUE;\\n        for(int j = 0; j < m; j++){\\n            if(j == k) continue;\\n            min = Math.min(min, func(arr, n, m, i + 1, j, dp));\\n        }\\n        if(min != Integer.MAX_VALUE) min += arr[i][k];\\n        return dp[i][k] = min;\\n    }\\n    \\n    public int minFallingPathSum(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        int[][] dp = new int[n][m];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++) dp[i][j] = -1;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int j = 0; j < m; j++){\\n            min = Math.min(min, func(arr, n, m, 0, j, dp));\\n        }\\n        return min;\\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public static int func(int[][] arr, int n, int m, int i, int k, int[][] dp){\\n        if(i == n) return 0;\\n        if(dp[i][k] != -1) return dp[i][k];\\n        int min = Integer.MAX_VALUE;\\n        for(int j = 0; j < m; j++){\\n            if(j == k) continue;\\n            min = Math.min(min, func(arr, n, m, i + 1, j, dp));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3796518,
                "title": "c-easy-explained-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsidering every column of top row as starting point. Then calculating minimum for every starting point till the end.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsider every column of top row as starting point. Call recursion for those points, if index goes out of range return maximum and for bottom index return the matrix value. Go to every column of the adjacent row (except the column right below it,) using a loop. Take the minimum, update it & return it. Voila!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int row, int col, vector<vector<int>> &nums,vector<vector<int>> &dp)\\n    {\\n        if(col<0 || col>nums[0].size()-1) return 1e9; // for out of index\\n        if(row==nums.size()-1) return nums[row][col];// when reached the bottom\\n        if(dp[row][col] != -1) return dp[row][col]; // return already calculated\\n        int ans=INT_MAX;\\n        for(int k=0;k<nums.size();k++){ // check for every column except just below one\\n            if(k!=col)\\n                ans=min(ans,nums[row][col]+solve(row+1,k,nums,dp)); // take minimum\\n        }\\n        return dp[row][col] = ans; // return answer\\n    }\\n    int minFallingPathSum(vector<vector<int>>& nums) {\\n        int ans = INT_MAX;\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        for(int i=0;i<m;i++) // considering every column of top row as starting point\\n            ans = min(ans,solve(0,i,nums,dp));//taking minimum for every starting point\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int row, int col, vector<vector<int>> &nums,vector<vector<int>> &dp)\\n    {\\n        if(col<0 || col>nums[0].size()-1) return 1e9; // for out of index\\n        if(row==nums.size()-1) return nums[row][col];// when reached the bottom\\n        if(dp[row][col] != -1) return dp[row][col]; // return already calculated\\n        int ans=INT_MAX;\\n        for(int k=0;k<nums.size();k++){ // check for every column except just below one\\n            if(k!=col)\\n                ans=min(ans,nums[row][col]+solve(row+1,k,nums,dp)); // take minimum\\n        }\\n        return dp[row][col] = ans; // return answer\\n    }\\n    int minFallingPathSum(vector<vector<int>>& nums) {\\n        int ans = INT_MAX;\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        for(int i=0;i<m;i++) // considering every column of top row as starting point\\n            ans = min(ans,solve(0,i,nums,dp));//taking minimum for every starting point\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636227,
                "title": "c-recursion-memoization-tabulation-space-optimization-explained",
                "content": "# Intuition\\nQuestion is similar to minimum falling path sum with a difference in direction. Here we the direction to move ahead from current position (row, col) will be (row+1, c); c will range from 0 to n leaving the previous column value col.\\nHere we have a variable starting and ending point so we can start from any cell in 0th row and end at any cell in n-1th row. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## Recursion:\\n1. Express in indexes. We need i for row and j for column traversal.\\n2. We explore all the possibilities.\\n3. Figure out the minimum.\\n\\nSay we have m cols and we start from n-1th row and move upwards.\\n\\n```\\nfor(int j=0; j < n; j++) {\\n    // Try every start position possibility\\n    // Minimum of all the possibilities is our answer.\\n    mini = min(mini, solve(n-1, j, grid));\\n}\\n```\\nsolve(i, j) -> minimum path sum to react i, j from any cell in n-1th\\n\\nBase Case:\\n\\n1. if we reach the destination if(i==0)\\n2. out of bounds check if(j<0 or j>=m)\\n\\nCheck code below.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. Recursion: For every cell we are exploring n paths and we are moving up to n rows: O(n^n)\\n2. Memoization: O(n*n) -> for every row n possibilities\\n3. Tabulation: O(N*N) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. Recursion: O(n) ->stack space\\n2. Memoization: O(n*n) -> for dp array + O(n) ->stack space\\n3. Tabulation: to eliminate stack space -> O(n*n) ->for dp array\\n4. Space Optimization: O(n)\\n\\n# Code\\n1. Recursion\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        // Base condition if we reach teh destination\\n        if(i == 0) return grid[i][j];\\n\\n        // Out of bounds check: We return a huge value so that the path is never taken.\\n        if(i<0 or j < 0 or j >= n) return 1e8;\\n\\n        int mini = 1e8;\\n\\n        for(int k =0; k<n; k++) {\\n            // such that no two elements chosen in adjacent rows are in the same column.\\n            if(k!=j) {\\n                // Minimum of all possibilities\\n                mini = min(mini, grid[i][j] + solve(i-1, k, grid));\\n            }\\n        }\\n\\n        return mini;\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int mini = 1e9;\\n\\n        for(int j=0; j < n; j++) {\\n            // Try every start position possibility\\n            // Minimum of all the possibilities is our answer.\\n            mini = min(mini, solve(n-1, j, grid));\\n        }\\n    }\\n};\\n```\\n2. Memoization\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp) {\\n        int n = grid.size();\\n\\n        if(i == 0) return grid[i][j];\\n\\n        if(i<0 or j < 0 or j >= n) return 1e8;\\n\\n        if(dp[i][j] != -1000) return dp[i][j];\\n\\n        int mini = 1e8;\\n\\n        for(int k =0; k<n; k++) {\\n            if(k!=j) {\\n                mini = min(mini, grid[i][j] + solve(i-1, k, grid, dp));\\n            }\\n        }\\n\\n        return dp[i][j] = mini;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int mini = 1e9;\\n        vector<vector<int>> dp(n, vector<int> (n+1, -1000));\\n        for(int j=0; j < n; j++) {\\n            mini = min(mini, solve(n-1, j, grid, dp));\\n        }\\n\\n        return mini;\\n    }\\n};\\n```\\n3. Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int mini = 1e9;\\n\\n        vector<vector<int>> dp(n+1, vector<int> (n+1, 0));\\n\\n        // To satisfy base condition\\n        for(int j=0; j<n; j++) dp[0][j] = grid[0][j];\\n\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                int mini = 1e8;\\n\\n                for(int k =0; k<n; k++) {\\n                    if(k!=j) {\\n                        mini = min(mini, grid[i][j] + dp[i-1][k]);\\n                    }\\n                }\\n\\n                dp[i][j] = mini;\\n            }\\n        }\\n\\n        for(int j=0; j < n; j++) {\\n            mini = min(mini, dp[n-1][j]);\\n        }\\n\\n        return mini;\\n    }\\n};\\n```\\n4. Space Optimization\\nWe can optimize the 2D array space to 1-D array as for calculation we require only the previous row not the entire dp matrix\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int mini = 1e9;\\n\\n        vector<int> prev(n+1, 0);\\n        vector<int> curr(n+1, 0);\\n\\n        for(int j=0; j<n; j++) prev[j] = grid[0][j];\\n\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                int mini = 1e8;\\n\\n                for(int k =0; k<n; k++) {\\n                    if(k!=j) {\\n                        mini = min(mini, grid[i][j] + prev[k]);\\n                    }\\n                }\\n\\n                curr[j] = mini;\\n            }\\n            prev = curr;\\n        }\\n\\n        for(int j=0; j < n; j++) {\\n            mini = min(mini, prev[j]);\\n        }\\n\\n        return mini;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor(int j=0; j < n; j++) {\\n    // Try every start position possibility\\n    // Minimum of all the possibilities is our answer.\\n    mini = min(mini, solve(n-1, j, grid));\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        // Base condition if we reach teh destination\\n        if(i == 0) return grid[i][j];\\n\\n        // Out of bounds check: We return a huge value so that the path is never taken.\\n        if(i<0 or j < 0 or j >= n) return 1e8;\\n\\n        int mini = 1e8;\\n\\n        for(int k =0; k<n; k++) {\\n            // such that no two elements chosen in adjacent rows are in the same column.\\n            if(k!=j) {\\n                // Minimum of all possibilities\\n                mini = min(mini, grid[i][j] + solve(i-1, k, grid));\\n            }\\n        }\\n\\n        return mini;\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int mini = 1e9;\\n\\n        for(int j=0; j < n; j++) {\\n            // Try every start position possibility\\n            // Minimum of all the possibilities is our answer.\\n            mini = min(mini, solve(n-1, j, grid));\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& grid, vector<vector<int>> &dp) {\\n        int n = grid.size();\\n\\n        if(i == 0) return grid[i][j];\\n\\n        if(i<0 or j < 0 or j >= n) return 1e8;\\n\\n        if(dp[i][j] != -1000) return dp[i][j];\\n\\n        int mini = 1e8;\\n\\n        for(int k =0; k<n; k++) {\\n            if(k!=j) {\\n                mini = min(mini, grid[i][j] + solve(i-1, k, grid, dp));\\n            }\\n        }\\n\\n        return dp[i][j] = mini;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int mini = 1e9;\\n        vector<vector<int>> dp(n, vector<int> (n+1, -1000));\\n        for(int j=0; j < n; j++) {\\n            mini = min(mini, solve(n-1, j, grid, dp));\\n        }\\n\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int mini = 1e9;\\n\\n        vector<vector<int>> dp(n+1, vector<int> (n+1, 0));\\n\\n        // To satisfy base condition\\n        for(int j=0; j<n; j++) dp[0][j] = grid[0][j];\\n\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                int mini = 1e8;\\n\\n                for(int k =0; k<n; k++) {\\n                    if(k!=j) {\\n                        mini = min(mini, grid[i][j] + dp[i-1][k]);\\n                    }\\n                }\\n\\n                dp[i][j] = mini;\\n            }\\n        }\\n\\n        for(int j=0; j < n; j++) {\\n            mini = min(mini, dp[n-1][j]);\\n        }\\n\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int mini = 1e9;\\n\\n        vector<int> prev(n+1, 0);\\n        vector<int> curr(n+1, 0);\\n\\n        for(int j=0; j<n; j++) prev[j] = grid[0][j];\\n\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                int mini = 1e8;\\n\\n                for(int k =0; k<n; k++) {\\n                    if(k!=j) {\\n                        mini = min(mini, grid[i][j] + prev[k]);\\n                    }\\n                }\\n\\n                curr[j] = mini;\\n            }\\n            prev = curr;\\n        }\\n\\n        for(int j=0; j < n; j++) {\\n            mini = min(mini, prev[j]);\\n        }\\n\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906958,
                "title": "easy-java-solution-using-consisting-of-simple-solution-as-well-as-recursion-and-dp-solution",
                "content": "# 1. Simple JAVA Solution\\n- In this solution, We start from second last row and update each element in the current row of the grid by adding the smallest element in the next row and by not considering the element adjacent to the current element(the element which is right below the current element).\\n- When all the rows will be traversed, we\\'ll have the minimum path sum for each element in the first row of the grid.\\n- Using this we\\'ll find the smallest element in the first row which will be our result.\\n\\n        class Solution {\\n            public int minFallingPathSum(int[][] grid) {\\n                int minSum = Integer.MAX_VALUE;\\n                int n = grid.length;\\n                if(n==1)return grid[0][0];\\n\\n                for(int i=n-2;i>=0;i--){\\n                    \\n                    for(int j=0;j<n;j++){\\n                        int min = minNum(grid, j, i+1, n);\\n                        grid[i][j] +=min;\\n                    }\\n                }\\n                for(int i=0;i<n;i++){\\n                    minSum =Math.min(minSum, grid[0][i]);\\n                }\\n                \\n                return minSum;\\n\\n            }\\n\\n            // finding the smallest element in (i+1)th row \\n            public int minNum(int[][] grid, int index, int row, int n){\\n                int min = Integer.MAX_VALUE;\\n                for(int i=0;i<n;i++){\\n                    if(i!=index){\\n                        min = Math.min(min,grid[row][i]);\\n                    }\\n                }\\n                return min;\\n            }\\n        }\\n\\n\\n# 2. Recursion and DP:\\n\\n\\n        class Solution {\\n            public int minFallingPathSum(int[][] grid) {\\n                int n = grid.length;\\n                int dp[][]= new int[n][n]; // fill this matrix withb zeroes\\n                for(int i=0;i<n;i++){\\n                    for(int j=0;j<n;j++){\\n                        dp[i][j]=-1;\\n                    }\\n                }\\n\\n                // function which will return the minimum sum \\n                int minSum = helper(0, -1, n, grid, dp);\\n                return minSum;\\n            }\\n\\n            //method to caculate the minimum sum at each row\\n            public int helper(int currRow, int prevCol, int n, int[][] grid, int dp[][]){\\n                if(currRow==n) return 0; // when we\\'ve reached the end of the matrix// when the previous element is already filled then return the value of that element\\n                if(prevCol!=-1 && dp[currRow][prevCol]!=-1) return dp[currRow][prevCol]; \\n\\n                int ans = Integer.MAX_VALUE; // store the answer which is minimum of all the sums\\n                for(int i=0;i<n;i++){\\n                    if(i==prevCol) continue; // when the current column is adjancent to previous column then move to other column\\n\\n                    // currMin will be the sum of element at current index \\n                    // plus minimum sum in next row\\n                    int currMin = grid[currRow][i] + helper(currRow+1, i , n, grid, dp);\\n\\n                    ans = Math.min(ans,currMin);\\n                }\\n                if(prevCol != -1) dp[currRow][prevCol]= ans;\\n                \\n                return ans;\\n            }\\n        }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public int minFallingPathSum(int[][] grid) {\\n                int minSum = Integer.MAX_VALUE;\\n                int n = grid.length;\\n                if(n==1)return grid[0][0];\\n\\n                for(int i=n-2;i>=0;i--){\\n                    \\n                    for(int j=0;j<n;j++){\\n                        int min = minNum(grid, j, i+1, n);\\n                        grid[i][j] +=min;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 453288,
                "title": "dynamic-programming-java",
                "content": "\\nSimple Java using Dynamic Programming - \\n    \\n    public int minFallingPathSum(int[][] A) {\\n        \\n        for(int i = 1; i < A.length; i++) {\\n            for(int j = 0; j < A[0].length; j++) {\\n                \\n                int min = Integer.MAX_VALUE;\\n                \\n                // Min for elements on left of current column\\n                for(int k = 0; k < j; k++) {\\n                    min = Math.min(min, A[i-1][k]);\\n                }\\n                \\n                // Min for elements on right of current column\\n                for(int k = j+1; k < A[0].length; k++) {\\n                    min = Math.min(min, A[i-1][k]);\\n                }\\n\\n                // Set Min for elements other than current column in previous row + current\\n                A[i][j] = A[i][j] + min;\\n            }\\n        }\\n        \\n        int tempRow = A.length-1;\\n        int result = Integer.MAX_VALUE;\\n        \\n        // Result is minimum of the last row\\n        for(int i = 0; i < A[0].length; i++) {\\n            result = Math.min(result, A[tempRow][i]);    \\n        }\\n\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "\\nSimple Java using Dynamic Programming - \\n    \\n    public int minFallingPathSum(int[][] A) {\\n        \\n        for(int i = 1; i < A.length; i++) {\\n            for(int j = 0; j < A[0].length; j++) {\\n                \\n                int min = Integer.MAX_VALUE;\\n                \\n                // Min for elements on left of current column\\n                for(int k = 0; k < j; k++) {\\n                    min = Math.min(min, A[i-1][k]);\\n                }\\n                \\n                // Min for elements on right of current column\\n                for(int k = j+1; k < A[0].length; k++) {\\n                    min = Math.min(min, A[i-1][k]);\\n                }\\n\\n                // Set Min for elements other than current column in previous row + current\\n                A[i][j] = A[i][j] + min;\\n            }\\n        }\\n        \\n        int tempRow = A.length-1;\\n        int result = Integer.MAX_VALUE;\\n        \\n        // Result is minimum of the last row\\n        for(int i = 0; i < A[0].length; i++) {\\n            result = Math.min(result, A[tempRow][i]);    \\n        }\\n\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 451325,
                "title": "java-solution-dp-tabulation-o-m-n",
                "content": "Same problem as Paint House II\\nUsing a minimum array to store the minimum in a row except itself at the index position and using the same index to lookup for the next row.\\n```\\npublic int minFallingPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        if( m == 0)\\n            return 0;\\n        int dp[][] = new int[m][n];\\n        for(int i = 0; i < n; i++) {\\n            dp[0][i] = arr[0][i];\\n        }\\n        \\n        for(int i = 1; i < m; i++) {\\n            dp[i-1] = minArray(dp[i-1]);\\n            for(int j = 0; j < n; j++) {\\n                dp[i][j] = dp[i-1][j] + arr[i][j];\\n            }\\n        }\\n        int min = dp[m-1][0];\\n        for(int i = 1; i < n; i++) {\\n            min = Math.min(dp[m-1][i], min);\\n        }\\n        return min;\\n    }\\n    \\n    int[] minArray(int[] arr) {\\n        int minArray[] = new int[arr.length];\\n        minArray[0] = Integer.MAX_VALUE;\\n        int min = arr[0];\\n        int n = arr.length;\\n        for(int i = 1; i < n; i++) {\\n            minArray[i] = min;\\n            min = Math.min(min, arr[i]);\\n        }\\n        min = arr[n-1];\\n        for(int i=n-2; i >= 0; i--) {\\n            minArray[i] = Math.min(minArray[i], min);\\n            min = Math.min(arr[i], min);\\n        }\\n        return minArray;\\n    }",
                "solutionTags": [],
                "code": "Same problem as Paint House II\\nUsing a minimum array to store the minimum in a row except itself at the index position and using the same index to lookup for the next row.\\n```\\npublic int minFallingPathSum(int[][] arr) {\\n        int m = arr.length;\\n        int n = arr[0].length;\\n        if( m == 0)\\n            return 0;\\n        int dp[][] = new int[m][n];\\n        for(int i = 0; i < n; i++) {\\n            dp[0][i] = arr[0][i];\\n        }\\n        \\n        for(int i = 1; i < m; i++) {\\n            dp[i-1] = minArray(dp[i-1]);\\n            for(int j = 0; j < n; j++) {\\n                dp[i][j] = dp[i-1][j] + arr[i][j];\\n            }\\n        }\\n        int min = dp[m-1][0];\\n        for(int i = 1; i < n; i++) {\\n            min = Math.min(dp[m-1][i], min);\\n        }\\n        return min;\\n    }\\n    \\n    int[] minArray(int[] arr) {\\n        int minArray[] = new int[arr.length];\\n        minArray[0] = Integer.MAX_VALUE;\\n        int min = arr[0];\\n        int n = arr.length;\\n        for(int i = 1; i < n; i++) {\\n            minArray[i] = min;\\n            min = Math.min(min, arr[i]);\\n        }\\n        min = arr[n-1];\\n        for(int i=n-2; i >= 0; i--) {\\n            minArray[i] = Math.min(minArray[i], min);\\n            min = Math.min(arr[i], min);\\n        }\\n        return minArray;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3612913,
                "title": "c-dp-solve-ith-row-get-1st-2nd-minimum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        if(grid.size()==1)return grid[0][0];\\n        int mn1=INT_MAX,mn2=INT_MAX,ind1=-1,ind2=-1,i,j,n=grid.size(),ans1=0,ans2=0,i1=-1,i2=-1;\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                for(j = 0; j < n; j++){\\n                    if(grid[i][j] < mn1){\\n                        mn2 = mn1;\\n                        mn1 = grid[i][j];\\n                        ind1 = j;\\n                    }else if(grid[i][j]<mn2){\\n                        mn2 = grid[i][j];\\n                        ind2 = j;\\n                    }\\n                }\\n            }else{\\n                for(j = 0; j < n; j++){\\n                    if(j != ind1){\\n                        grid[i][j] += mn1;\\n                    }else{\\n                        grid[i][j] += mn2;\\n                    }\\n                }\\n                mn1 = mn2 = INT_MAX;\\n                for(j = 0; j < n; j++){\\n                    if(grid[i][j] < mn1){\\n                        mn2 = mn1;\\n                        mn1 = grid[i][j];\\n                        ind1 = j;\\n                    }else if(grid[i][j]<mn2){\\n                        mn2 = grid[i][j];\\n                        ind2 = j;\\n                    }\\n                }\\n            }\\n            // cout<<mn1<<\" \"<<mn2<<endl;\\n        }\\n        // for(auto &i: grid){\\n        //     for(auto &j: i)cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return min(mn1,mn2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        if(grid.size()==1)return grid[0][0];\\n        int mn1=INT_MAX,mn2=INT_MAX,ind1=-1,ind2=-1,i,j,n=grid.size(),ans1=0,ans2=0,i1=-1,i2=-1;\\n        for(i = 0; i < n; i++){\\n            if(i==0){\\n                for(j = 0; j < n; j++){\\n                    if(grid[i][j] < mn1){\\n                        mn2 = mn1;\\n                        mn1 = grid[i][j];\\n                        ind1 = j;\\n                    }else if(grid[i][j]<mn2){\\n                        mn2 = grid[i][j];\\n                        ind2 = j;\\n                    }\\n                }\\n            }else{\\n                for(j = 0; j < n; j++){\\n                    if(j != ind1){\\n                        grid[i][j] += mn1;\\n                    }else{\\n                        grid[i][j] += mn2;\\n                    }\\n                }\\n                mn1 = mn2 = INT_MAX;\\n                for(j = 0; j < n; j++){\\n                    if(grid[i][j] < mn1){\\n                        mn2 = mn1;\\n                        mn1 = grid[i][j];\\n                        ind1 = j;\\n                    }else if(grid[i][j]<mn2){\\n                        mn2 = grid[i][j];\\n                        ind2 = j;\\n                    }\\n                }\\n            }\\n            // cout<<mn1<<\" \"<<mn2<<endl;\\n        }\\n        // for(auto &i: grid){\\n        //     for(auto &j: i)cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return min(mn1,mn2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3034837,
                "title": "3-approaches-recursion-memoization-tabulation-c",
                "content": "**Please, Upvote if you learned something form here!**\\n\\n# Approach1 - Recursion (gives TLE)\\n- Time complexity: O(Exponential)\\n- Space complexity: O(n + n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int r , int c , int n , vector<vector<int>> &mat){\\n        if(r==n-1)  return mat[r][c];\\n        \\n        int mini = INT_MAX;\\n        for(int i=0 ; i<n ; i++){\\n            if(i!=c){\\n                mini = min(mini , mat[r][c] + solve(r+1 , i , n , mat));\\n            }\\n        }\\n        return mini;\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int res=INT_MAX;\\n        for(int i=0 ; i<n ; i++) res = min(res , solve(0 , i , n ,mat));\\n        return res;\\n    }\\n};\\n```\\n# Approach 2 - DP Memoization\\n- Time complexity: O(n*n)\\n- Space complexity: O(n + n) + O(n*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int r , int c , int n , vector<vector<int>> &mat , vector<vector<int>> &memo){\\n        if(r==n-1)  return memo[r][c] = mat[r][c];\\n        if(memo[r][c]!=-1)  return memo[r][c];\\n\\n        int mini = INT_MAX;\\n        for(int i=0 ; i<n ; i++){\\n            if(i!=c){\\n                mini = min(mini , mat[r][c] + solve(r+1 , i , n , mat , memo));\\n            }\\n        }\\n        return memo[r][c]=mini;\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n\\n        int n = mat.size();\\n        vector<vector<int>> memo(n , vector<int> (n , -1));\\n        int res=INT_MAX;\\n\\n        for(int i=0 ; i<n ; i++) solve(0 , i , n ,mat , memo);\\n\\n        return *min_element(memo[0].begin() , memo[0].end());\\n    }\\n};\\n```\\n# Approach 3 - DP Tabulation\\n- Time complexity: O(n*n*n)\\n- Space complexity: O(n-2 * n * n-1) ~ O(n ^ 3)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n\\n        int n = mat.size();\\n        vector<vector<int>> dp(n , vector<int> (n , INT_MAX));\\n        for(int i=0 ; i<n ; i++) dp[n-1][i] = mat[n-1][i];\\n\\n        for(int i=n-2 ; i>=0 ; i--){\\n            for(int j=0 ; j<n ; j++){\\n                for(int k=0 ; k<n ; k++){\\n                    if(k!=j){\\n                        dp[i][j] = min(dp[i][j] , dp[i+1][k]+mat[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return *min_element(dp[0].begin() , dp[0].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int r , int c , int n , vector<vector<int>> &mat){\\n        if(r==n-1)  return mat[r][c];\\n        \\n        int mini = INT_MAX;\\n        for(int i=0 ; i<n ; i++){\\n            if(i!=c){\\n                mini = min(mini , mat[r][c] + solve(r+1 , i , n , mat));\\n            }\\n        }\\n        return mini;\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int res=INT_MAX;\\n        for(int i=0 ; i<n ; i++) res = min(res , solve(0 , i , n ,mat));\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int r , int c , int n , vector<vector<int>> &mat , vector<vector<int>> &memo){\\n        if(r==n-1)  return memo[r][c] = mat[r][c];\\n        if(memo[r][c]!=-1)  return memo[r][c];\\n\\n        int mini = INT_MAX;\\n        for(int i=0 ; i<n ; i++){\\n            if(i!=c){\\n                mini = min(mini , mat[r][c] + solve(r+1 , i , n , mat , memo));\\n            }\\n        }\\n        return memo[r][c]=mini;\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n\\n        int n = mat.size();\\n        vector<vector<int>> memo(n , vector<int> (n , -1));\\n        int res=INT_MAX;\\n\\n        for(int i=0 ; i<n ; i++) solve(0 , i , n ,mat , memo);\\n\\n        return *min_element(memo[0].begin() , memo[0].end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n\\n        int n = mat.size();\\n        vector<vector<int>> dp(n , vector<int> (n , INT_MAX));\\n        for(int i=0 ; i<n ; i++) dp[n-1][i] = mat[n-1][i];\\n\\n        for(int i=n-2 ; i>=0 ; i--){\\n            for(int j=0 ; j<n ; j++){\\n                for(int k=0 ; k<n ; k++){\\n                    if(k!=j){\\n                        dp[i][j] = min(dp[i][j] , dp[i+1][k]+mat[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return *min_element(dp[0].begin() , dp[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924600,
                "title": "recursion-memoization-easy-and-beginner-friendly",
                "content": "\\n# Approach\\nExplore all paths during recursion excluding the current column, same as minimum falling path sum (medium).\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>> &grid,vector<vector<int>> &dp){\\n        int n = grid.size();\\n        if(i == 0) return grid[0][j];\\n        if(j < 0 || j > n-1) return 1e9;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int mini = 1e9;\\n        if(j != 0){\\n        for(int a=0;a<=j-1;a++){\\n           mini = min(mini,grid[i][j] + f(i-1,a,grid,dp));\\n        }\\n        }\\n\\n        if(j != n-1){\\n        for(int a=j+1;a<=n-1;a++){\\n           mini = min(mini,grid[i][j] + f(i-1,a,grid,dp));\\n        }\\n        }\\n\\n        return dp[i][j] = mini;\\n    } \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int mini = 1e9;\\n        int n = grid.size();\\n        vector<vector<int>> dp(n+1,vector<int> (n+1,-1));\\n        \\n        for(int i=0;i<n;i++){\\n           mini = min(mini,f(n-1,i,grid,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int j,vector<vector<int>> &grid,vector<vector<int>> &dp){\\n        int n = grid.size();\\n        if(i == 0) return grid[0][j];\\n        if(j < 0 || j > n-1) return 1e9;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int mini = 1e9;\\n        if(j != 0){\\n        for(int a=0;a<=j-1;a++){\\n           mini = min(mini,grid[i][j] + f(i-1,a,grid,dp));\\n        }\\n        }\\n\\n        if(j != n-1){\\n        for(int a=j+1;a<=n-1;a++){\\n           mini = min(mini,grid[i][j] + f(i-1,a,grid,dp));\\n        }\\n        }\\n\\n        return dp[i][j] = mini;\\n    } \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int mini = 1e9;\\n        int n = grid.size();\\n        vector<vector<int>> dp(n+1,vector<int> (n+1,-1));\\n        \\n        for(int i=0;i<n;i++){\\n           mini = min(mini,f(n-1,i,grid,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893868,
                "title": "c-best-solution-space-optimization-o-n",
                "content": "\\n\\n# Space Optimization \\n- We only need two vectors rather than whole dp array.  \\n- Prev to store the previously calculated values. \\n- Curr to store the minimum path based on previous path sum. \\n\\n# Complexity\\n- Time complexity: O(n*m) Traverse the given grid.\\n- Space complexity: O(N) Just 2 vectors. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int n = arr.size() ;\\n        vector<int> prev(n,0), curr(n,0) ;\\n\\n        // Initialze the first row \\n        for( int j=0 ; j<n ; j++ ) prev[j] = arr[0][j]; \\n\\n        for(int i = 1; i < arr.size(); ++i){\\n            for(int j = 0; j < arr[0].size(); ++j){\\n\\n                curr[j] = INT_MAX;\\n\\n                for(int k = 0; k < arr[0].size(); ++k){\\n                    if(j == k)\\n                        continue;\\n                    curr[j] = min(prev[k] + arr[i][j],curr[j]);\\n                }\\n            }\\n            prev = curr ;\\n        }\\n        \\n        int ans = INT_MAX;\\n\\n        for(int i = 0; i < prev.size(); ++i)\\n            ans = min(prev[i],ans);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int n = arr.size() ;\\n        vector<int> prev(n,0), curr(n,0) ;\\n\\n        // Initialze the first row \\n        for( int j=0 ; j<n ; j++ ) prev[j] = arr[0][j]; \\n\\n        for(int i = 1; i < arr.size(); ++i){\\n            for(int j = 0; j < arr[0].size(); ++j){\\n\\n                curr[j] = INT_MAX;\\n\\n                for(int k = 0; k < arr[0].size(); ++k){\\n                    if(j == k)\\n                        continue;\\n                    curr[j] = min(prev[k] + arr[i][j],curr[j]);\\n                }\\n            }\\n            prev = curr ;\\n        }\\n        \\n        int ans = INT_MAX;\\n\\n        for(int i = 0; i < prev.size(); ++i)\\n            ans = min(prev[i],ans);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634292,
                "title": "python-short-and-easy",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(1, len(grid)):\\n            sorted_row = sorted(grid[i-1])\\n            for j in range(len(grid[i])):\\n                grid[i][j] += sorted_row[0 + sorted_row[0] == grid[i-1][j]]\\n        return min(grid[-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        for i in range(1, len(grid)):\\n            sorted_row = sorted(grid[i-1])\\n            for j in range(len(grid[i])):\\n                grid[i][j] += sorted_row[0 + sorted_row[0] == grid[i-1][j]]\\n        return min(grid[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300419,
                "title": "simple-recursion-memoization-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public static int dp[][] = new int[201][201];\\n    public int minFallingPathSum(int[][] a) {\\n        int i,j,n=a.length;\\n        \\n        for(i=0;i<201;i++)\\n\\t\\t{\\n\\t\\t    for(j=0;j<201;j++)\\n\\t\\t    {\\n\\t\\t        dp[i][j]=-1;\\n\\t\\t    }\\n\\t\\t}\\n\\t      int  sum = func(n-1,a,n);\\n          return sum;\\n    }\\n    public static int func(int row, int a[][], int last)\\n\\t{\\n\\t    int n=a.length;\\n\\t    //base case\\n\\t    if(row==0)\\n\\t    {\\n\\t        int minx = 100001;\\n\\t        for(int i=0;i<n;i++)\\n\\t        {\\n\\t            if(i!=last)\\n\\t            minx = Math.min(minx, a[row][i]);\\n\\t        }\\n\\t        return minx;\\n\\t    }\\n\\t    \\n\\t    if(dp[row][last]!=-1) //memoization\\n\\t    return dp[row][last];\\n\\t    \\n\\t    int minx=100001;\\n\\t    for(int i=0;i<n;i++)\\n\\t    {\\n\\t        if(i!=last)\\n\\t        {\\n\\t            int sum = a[row][i] + func(row-1,a,i);\\n\\t            if(sum<minx)\\n\\t            minx=sum;\\n\\t        }\\n\\t    }\\n\\t    return dp[row][last] = minx;   \\n\\t}\\n}\\n**//exactly similar to ninja and training!!! watch striver dp lecture on grids/2d dp**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public static int dp[][] = new int[201][201];\\n    public int minFallingPathSum(int[][] a) {\\n        int i,j,n=a.length;\\n        \\n        for(i=0;i<201;i++)\\n\\t\\t{\\n\\t\\t    for(j=0;j<201;j++)\\n\\t\\t    {\\n\\t\\t        dp[i][j]=-1;\\n\\t\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 1114132,
                "title": "easy-c-o-n-3-time-and-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int temp=arr[i-1][j];\\n                arr[i-1][j]=INT_MAX;\\n                arr[i][j]+=*min_element(arr[i-1].begin(),arr[i-1].end());\\n                arr[i-1][j]=temp;\\n            }\\n        }\\n        \\n        return *min_element(arr[n-1].begin(),arr[n-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int n=arr.size();\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int temp=arr[i-1][j];\\n                arr[i-1][j]=INT_MAX;\\n                arr[i][j]+=*min_element(arr[i-1].begin(),arr[i-1].end());\\n                arr[i-1][j]=temp;\\n            }\\n        }\\n        \\n        return *min_element(arr[n-1].begin(),arr[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751357,
                "title": "python-3-simple-dynamic-programming",
                "content": "```\\nfrom heapq import nsmallest\\n\\n\\nclass Solution:\\n    def minFallingPathSum(self, arr) -> int:\\n        \"\"\"\\n        Given a square matrix of integers, this program uses dynamic\\n        programming to determine the minimum falling path sum following\\n        the rule that the values chosen from consecutive rows cannot be\\n        from the same column.\\n\\n        :param arr: square matrix of integers\\n        :type arr: list[list[int]]\\n        :return: minimum falling path sum\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize:\\n        - Number of rows (rows) and number of columns (cols) are the\\n          same value for a square matrix.\\n        - Return quickly with the result when matrix is 1 x 1. \\n        \"\"\"\\n        rows = len(arr)\\n        cols = rows\\n        if rows == 1:\\n            return arr[0][0]\\n\\n        \"\"\"\\n        Dynamic Programming:\\n        - Overwrite the arr matrix\\n        - Compute a falling path sum for each element in a row\\n          using the falling path sums from the previous row.\\n        - Use the minimum path sum from the previous row unless\\n          it is in the column, in which case use the second\\n          minimum path sum.\\n        - Return the minimum path sum in the bottom row as the answer.\\n        \"\"\"\\n        for row in range(1, rows):\\n            min_path_sum, min_path_sum_2nd = nsmallest(2, arr[row - 1])\\n            for col in range(cols):\\n                if arr[row - 1][col] == min_path_sum:\\n                    arr[row][col] += min_path_sum_2nd\\n                else:\\n                    arr[row][col] += min_path_sum\\n        return min(arr[rows - 1])\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom heapq import nsmallest\\n\\n\\nclass Solution:\\n    def minFallingPathSum(self, arr) -> int:\\n        \"\"\"\\n        Given a square matrix of integers, this program uses dynamic\\n        programming to determine the minimum falling path sum following\\n        the rule that the values chosen from consecutive rows cannot be\\n        from the same column.\\n\\n        :param arr: square matrix of integers\\n        :type arr: list[list[int]]\\n        :return: minimum falling path sum\\n        :rtype: int\\n        \"\"\"\\n\\n        \"\"\"\\n        Initialize:\\n        - Number of rows (rows) and number of columns (cols) are the\\n          same value for a square matrix.\\n        - Return quickly with the result when matrix is 1 x 1. \\n        \"\"\"\\n        rows = len(arr)\\n        cols = rows\\n        if rows == 1:\\n            return arr[0][0]\\n\\n        \"\"\"\\n        Dynamic Programming:\\n        - Overwrite the arr matrix\\n        - Compute a falling path sum for each element in a row\\n          using the falling path sums from the previous row.\\n        - Use the minimum path sum from the previous row unless\\n          it is in the column, in which case use the second\\n          minimum path sum.\\n        - Return the minimum path sum in the bottom row as the answer.\\n        \"\"\"\\n        for row in range(1, rows):\\n            min_path_sum, min_path_sum_2nd = nsmallest(2, arr[row - 1])\\n            for col in range(cols):\\n                if arr[row - 1][col] == min_path_sum:\\n                    arr[row][col] += min_path_sum_2nd\\n                else:\\n                    arr[row][col] += min_path_sum\\n        return min(arr[rows - 1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745208,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n\\n// This problem is similar to the Minimum Falling path sum 1;\\n\\n    public int minFallingPathSum(int[][] arr) {\\n        \\n\\t\\t/* Given 2D array ;\\n\\t\\t[[1,2,3],\\n\\t\\t[4,5,6],\\n\\t\\t[7,8,9]]\\n\\t\\t*/\\n        \\n        for(int i=1;i<arr.length;i++){\\n            \\n            for(int j=0;j<arr[0].length;j++){\\n               int min=Integer.MAX_VALUE;\\n                for(int k=0;k<arr[0].length;k++){\\n                    \\n                    if(k != j && arr[i-1][k] < min){\\n                        min = arr[i-1][k];\\n                    }\\n                }\\n                \\n                arr[i][j] += min;\\n            }\\n            \\n        }\\n    /* \\n\\tUpdated 2D array ;\\n\\t\\t[[1,2,3],\\n\\t\\t[6,6,7],\\n\\t\\t[13,14,15]]\\n\\n\\t\\t*/ \\n\\t\\t\\n        int[] lastRow = arr[arr.length-1];\\n        int min = Integer.MAX_VALUE;\\n        for(int i:lastRow){\\n            if(i< min){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```\\n More Efficent way to do is to keep track of two min values and then update the curr row with depending on the fact that for the current col if min is  in the prev col  then use the second min and otherrwise .\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        \\n        for(int i=1;i<arr.length;i++){\\n            int min =Integer.MAX_VALUE;\\n            int secondMin = min;\\n            for(int j=0;j<arr[0].length;j++){\\n                if(arr[i-1][j] <= min){\\n                    secondMin = min;\\n                    min = arr[i-1][j];\\n                }\\n                if(arr[i-1][j] < secondMin && arr[i-1][j] > min){\\n                    secondMin = arr[i-1][j];\\n                   \\n                }\\n              \\n            }\\n            for(int j=0;j<arr[0].length;j++){\\n                \\n                if(arr[i-1][j] == min){\\n                    arr[i][j] += secondMin;\\n                }\\n                else if(arr[i-1][j] == secondMin){\\n                    arr[i][j] += min;\\n                }\\n                else{\\n                    arr[i][j] += min;\\n                }\\n            }\\n        }\\n        int[] lastRow = arr[arr.length-1];\\n        int min = Integer.MAX_VALUE;\\n        for(int i:lastRow){\\n            if(i< min){\\n                min = i;\\n            }\\n        }\\n        return min;\\n        \\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n// This problem is similar to the Minimum Falling path sum 1;\\n\\n    public int minFallingPathSum(int[][] arr) {\\n        \\n\\t\\t/* Given 2D array ;\\n\\t\\t[[1,2,3],\\n\\t\\t[4,5,6],\\n\\t\\t[7,8,9]]\\n\\t\\t*/\\n        \\n        for(int i=1;i<arr.length;i++){\\n            \\n            for(int j=0;j<arr[0].length;j++){\\n               int min=Integer.MAX_VALUE;\\n                for(int k=0;k<arr[0].length;k++){\\n                    \\n                    if(k != j && arr[i-1][k] < min){\\n                        min = arr[i-1][k];\\n                    }\\n                }\\n                \\n                arr[i][j] += min;\\n            }\\n            \\n        }\\n    /* \\n\\tUpdated 2D array ;\\n\\t\\t[[1,2,3],\\n\\t\\t[6,6,7],\\n\\t\\t[13,14,15]]\\n\\n\\t\\t*/ \\n\\t\\t\\n        int[] lastRow = arr[arr.length-1];\\n        int min = Integer.MAX_VALUE;\\n        for(int i:lastRow){\\n            if(i< min){\\n                min = i;\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452649,
                "title": "c-java-o-mn-brute-force-without-extra-space-two-variables",
                "content": "if you like it, please vote it, otherwise, please let us discuss it. Thanks,\\n```\\n    public int MinFallingPathSum(int[][] arr) {\\n        int liRow = arr.Length;\\n     \\n        int liFirstMin = arr[0][0];\\n        int liSecondMin = int.MaxValue;\\n        \\n        for( int i = 1; i < liRow; ++ i ) {\\n            if ( arr[0][i] < liFirstMin ) {\\n                liSecondMin = liFirstMin;\\n                liFirstMin = arr[0][i];\\n                \\n            } else if ( arr[0][i] < liSecondMin )\\n                liSecondMin = arr[0][i];\\n        }\\n        \\n        for( int i = 1; i < liRow; ++i ) {\\n            int liTempFirst = int.MaxValue;\\n            int liTempSecond = int.MaxValue;\\n            \\n            for( int j = 0; j < liRow; ++j ) {\\n                arr[i][j] += arr[i-1][j] == liFirstMin? liSecondMin : liFirstMin;\\n                \\n                if ( arr[i][j] < liTempFirst ) {\\n                    liTempSecond = liTempFirst;\\n                    liTempFirst = arr[i][j];\\n                } else if ( arr[i][j] < liTempSecond )\\n                    liTempSecond = arr[i][j];\\n            }\\n            liFirstMin = liTempFirst;\\n            liSecondMin = liTempSecond;\\n        }   \\n        \\n        return liFirstMin;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "if you like it, please vote it, otherwise, please let us discuss it. Thanks,\\n```\\n    public int MinFallingPathSum(int[][] arr) {\\n        int liRow = arr.Length;\\n     \\n        int liFirstMin = arr[0][0];\\n        int liSecondMin = int.MaxValue;\\n        \\n        for( int i = 1; i < liRow; ++ i ) {\\n            if ( arr[0][i] < liFirstMin ) {\\n                liSecondMin = liFirstMin;\\n                liFirstMin = arr[0][i];\\n                \\n            } else if ( arr[0][i] < liSecondMin )\\n                liSecondMin = arr[0][i];\\n        }\\n        \\n        for( int i = 1; i < liRow; ++i ) {\\n            int liTempFirst = int.MaxValue;\\n            int liTempSecond = int.MaxValue;\\n            \\n            for( int j = 0; j < liRow; ++j ) {\\n                arr[i][j] += arr[i-1][j] == liFirstMin? liSecondMin : liFirstMin;\\n                \\n                if ( arr[i][j] < liTempFirst ) {\\n                    liTempSecond = liTempFirst;\\n                    liTempFirst = arr[i][j];\\n                } else if ( arr[i][j] < liTempSecond )\\n                    liTempSecond = arr[i][j];\\n            }\\n            liFirstMin = liTempFirst;\\n            liSecondMin = liTempSecond;\\n        }   \\n        \\n        return liFirstMin;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 451310,
                "title": "c-dp-o-m-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        vector <vector <int>> dp = arr;\\n        for(int i = 1; i < arr.size(); ++i)\\n            for(int j = 0; j < arr[0].size(); ++j){\\n                dp[i][j] = INT_MAX;\\n                for(int k = 0; k < arr[0].size(); ++k){\\n                    if(j == k)\\n                        continue;\\n                    dp[i][j] = min(dp[i - 1][k] + arr[i][j],dp[i][j]);\\n                }\\n            }\\n        \\n        int result = INT_MAX;\\n        for(int i = 0; i < arr[0].size(); ++i)\\n            result = min(dp[dp.size() - 1][i],result);\\n        return result;\\n    }\\n};\\n```\\n\\nIdea :\\n- Consider the path as selecting one element from each row satisfying the conditions\\n- Assume the optimal path contains an arbitrary arr[i][j] . Then the optimal path would choose the lowest optimal path so far from the previous row (excepting column j).\\n- The final row will contain the smallest paths for all j if element j of the final row was a part of the optimal path.\\n- Minimum of these will be the answer.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        vector <vector <int>> dp = arr;\\n        for(int i = 1; i < arr.size(); ++i)\\n            for(int j = 0; j < arr[0].size(); ++j){\\n                dp[i][j] = INT_MAX;\\n                for(int k = 0; k < arr[0].size(); ++k){\\n                    if(j == k)\\n                        continue;\\n                    dp[i][j] = min(dp[i - 1][k] + arr[i][j],dp[i][j]);\\n                }\\n            }\\n        \\n        int result = INT_MAX;\\n        for(int i = 0; i < arr[0].size(); ++i)\\n            result = min(dp[dp.size() - 1][i],result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939859,
                "title": "java-easy-understanding-run-time-beats-92-1-memory-beats-86-7",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Each Level Find two smallest number and record it.\\n2. Edit the next level with those two numbers\\n3. Looping until the last level\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Looping for the matrix\\n2. Using first loop to find current level two minimum number(only need record the first minimum number index)\\n3. Using Second loop to edit the value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) change input\\nO(n^2) deep copy a new input\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int result = Integer.MAX_VALUE;\\n        if(matrix == null || matrix.length < 1){\\n            return 0;\\n        }\\n        if(matrix.length == 1){\\n            return matrix[0][0];\\n        }\\n        \\n\\n        for(int i = 0; i < matrix.length - 1; i++){\\n            int min1 = Integer.MAX_VALUE;\\n            int min2 = Integer.MAX_VALUE;\\n            int min1Index = -1;\\n            for(int j = 0; j < matrix[i].length; j++){\\n                if(min1 > matrix[i][j]){\\n                    min2 = min1;\\n                    min1 = matrix[i][j];\\n                    min1Index = j;\\n                }else if(min2 > matrix[i][j]){\\n                    min2 = matrix[i][j];\\n                }\\n            }\\n            for(int j = 0; j < matrix[i].length; j++){\\n                if(min1Index != j){\\n                    matrix[i + 1][j] += min1;\\n                }else{\\n                    matrix[i + 1][j] += min2;\\n                }\\n                if(i + 1 == matrix.length - 1){\\n                    result = Math.min(matrix[i + 1][j], result);\\n                }\\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int result = Integer.MAX_VALUE;\\n        if(matrix == null || matrix.length < 1){\\n            return 0;\\n        }\\n        if(matrix.length == 1){\\n            return matrix[0][0];\\n        }\\n        \\n\\n        for(int i = 0; i < matrix.length - 1; i++){\\n            int min1 = Integer.MAX_VALUE;\\n            int min2 = Integer.MAX_VALUE;\\n            int min1Index = -1;\\n            for(int j = 0; j < matrix[i].length; j++){\\n                if(min1 > matrix[i][j]){\\n                    min2 = min1;\\n                    min1 = matrix[i][j];\\n                    min1Index = j;\\n                }else if(min2 > matrix[i][j]){\\n                    min2 = matrix[i][j];\\n                }\\n            }\\n            for(int j = 0; j < matrix[i].length; j++){\\n                if(min1Index != j){\\n                    matrix[i + 1][j] += min1;\\n                }else{\\n                    matrix[i + 1][j] += min2;\\n                }\\n                if(i + 1 == matrix.length - 1){\\n                    result = Math.min(matrix[i + 1][j], result);\\n                }\\n            }\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471256,
                "title": "java-solution-top-down-recursion-memoization-and-bottom-up-dp",
                "content": "### Solution- 1: Recursion\\n```\\npublic int minFallingPathSum(int[][] nums) {\\n        int rows = nums.length;\\n        int cols = rows;\\n        int result = Integer.MAX_VALUE;\\n\\n        for (int j = 0; j < cols; j++) {\\n            result = Math.min(result, recurHelper(nums, rows - 1, j));\\n        }\\n        return result;\\n    }\\n    \\n    public int recurHelper(int[][] nums, int rowIndex, int colIndex) {\\n        if (rowIndex < 0 || colIndex < 0 || colIndex > nums[0].length) {\\n            return 200;\\n        } else if (rowIndex == 0) {\\n            return nums[rowIndex][colIndex];\\n        }\\n\\n        int res = nums[rowIndex][colIndex];\\n        int val = 250;\\n        for (int i = 0; i < nums[0].length; i++) {\\n            if (i == colIndex) {\\n                continue;\\n            }\\n            val = Math.min(val, recurHelper(nums, rowIndex - 1, i));\\n        }\\n        return res + val;\\n    }\\n```\\n\\n### Solution-2: Memoization\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int minFallingPathSum(int[][] nums) {\\n        int rows = nums.length;\\n        int cols = rows;\\n        dp = new int[rows][cols];\\n        for (int i = 0; i < rows; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n\\n        for (int j = 0; j < cols; j++) {\\n            result = Math.min(result, recurHelper(nums, rows - 1, j));\\n        }\\n        return result;\\n    }\\n    \\n    public int recurHelper(int[][] nums, int rowIndex, int colIndex) {\\n        if (rowIndex < 0 || colIndex < 0 || colIndex > nums[0].length) {\\n            return Integer.MAX_VALUE;\\n        } else if (rowIndex == 0) {\\n            return nums[rowIndex][colIndex];\\n        }else {\\n            if (dp[rowIndex][colIndex] != Integer.MAX_VALUE) {\\n                return dp[rowIndex][colIndex];\\n            } else {\\n                int res = nums[rowIndex][colIndex];\\n                int val = Integer.MAX_VALUE;\\n                for (int i = 0; i < nums[0].length; i++) {\\n                    if (i == colIndex) {\\n                        continue;\\n                    }\\n                    val = Math.min(val, recurHelper(nums, rowIndex - 1, i));\\n                }\\n                dp[rowIndex][colIndex] = res + val;\\n                return res + val;\\n            }\\n        }\\n    }\\n}\\n```\\n### Solution-3: Bottom Up DP:\\n```\\npublic int minFallingPathSum(int[][] nums) {\\n        int result = Integer.MAX_VALUE;\\n        int[][] dp = new int[nums.length][nums[0].length];\\n        for (int i = 0; i < nums[0].length; i++) {\\n            dp[0][i] = nums[0][i];\\n        }\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n            for (int j = 0; j < nums[0].length; j++) {\\n                for (int k = 0; k < nums[0].length; k++) {\\n                    if (k != j) {\\n                        dp[i][j] = Math.min(dp[i][j], nums[i][j] + dp[i - 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < nums[0].length; i++) {\\n            result = Math.min(result, dp[nums.length - 1][i]);\\n        }\\n        return result;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int minFallingPathSum(int[][] nums) {\\n        int rows = nums.length;\\n        int cols = rows;\\n        int result = Integer.MAX_VALUE;\\n\\n        for (int j = 0; j < cols; j++) {\\n            result = Math.min(result, recurHelper(nums, rows - 1, j));\\n        }\\n        return result;\\n    }\\n    \\n    public int recurHelper(int[][] nums, int rowIndex, int colIndex) {\\n        if (rowIndex < 0 || colIndex < 0 || colIndex > nums[0].length) {\\n            return 200;\\n        } else if (rowIndex == 0) {\\n            return nums[rowIndex][colIndex];\\n        }\\n\\n        int res = nums[rowIndex][colIndex];\\n        int val = 250;\\n        for (int i = 0; i < nums[0].length; i++) {\\n            if (i == colIndex) {\\n                continue;\\n            }\\n            val = Math.min(val, recurHelper(nums, rowIndex - 1, i));\\n        }\\n        return res + val;\\n    }\\n```\n```\\nclass Solution {\\n    int[][] dp;\\n    public int minFallingPathSum(int[][] nums) {\\n        int rows = nums.length;\\n        int cols = rows;\\n        dp = new int[rows][cols];\\n        for (int i = 0; i < rows; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n\\n        for (int j = 0; j < cols; j++) {\\n            result = Math.min(result, recurHelper(nums, rows - 1, j));\\n        }\\n        return result;\\n    }\\n    \\n    public int recurHelper(int[][] nums, int rowIndex, int colIndex) {\\n        if (rowIndex < 0 || colIndex < 0 || colIndex > nums[0].length) {\\n            return Integer.MAX_VALUE;\\n        } else if (rowIndex == 0) {\\n            return nums[rowIndex][colIndex];\\n        }else {\\n            if (dp[rowIndex][colIndex] != Integer.MAX_VALUE) {\\n                return dp[rowIndex][colIndex];\\n            } else {\\n                int res = nums[rowIndex][colIndex];\\n                int val = Integer.MAX_VALUE;\\n                for (int i = 0; i < nums[0].length; i++) {\\n                    if (i == colIndex) {\\n                        continue;\\n                    }\\n                    val = Math.min(val, recurHelper(nums, rowIndex - 1, i));\\n                }\\n                dp[rowIndex][colIndex] = res + val;\\n                return res + val;\\n            }\\n        }\\n    }\\n}\\n```\n```\\npublic int minFallingPathSum(int[][] nums) {\\n        int result = Integer.MAX_VALUE;\\n        int[][] dp = new int[nums.length][nums[0].length];\\n        for (int i = 0; i < nums[0].length; i++) {\\n            dp[0][i] = nums[0][i];\\n        }\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n            for (int j = 0; j < nums[0].length; j++) {\\n                for (int k = 0; k < nums[0].length; k++) {\\n                    if (k != j) {\\n                        dp[i][j] = Math.min(dp[i][j], nums[i][j] + dp[i - 1][k]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < nums[0].length; i++) {\\n            result = Math.min(result, dp[nums.length - 1][i]);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437605,
                "title": "beats-100-simple-java-code",
                "content": "\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        for(int i=1;i<grid.length;i++){\\n            int p=0,min=grid[i-1][0],nmin=Integer.MAX_VALUE,q=0;\\n            for(int j=0;j<grid.length;j++){\\n                if(grid[i-1][j]<min){\\n                    min=grid[i-1][j];\\n                    p=j;\\n                }\\n            }\\n            for(int j=0;j<grid.length;j++){\\n                if(j!=p&&grid[i-1][j]>=min&& grid[i-1][j]<nmin){\\n                    nmin=grid[i-1][j];\\n                }\\n            }\\n            for(int j=0;j<grid.length;j++){\\n                if(j!=p)\\n                    grid[i][j]+=min;\\n                else\\n                    grid[i][j]+=nmin;\\n            }\\n            // System.out.println(min+\" \"+nmin);\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<grid[0].length;i++){\\n            ans=Math.min(ans,grid[grid.length-1][i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        for(int i=1;i<grid.length;i++){\\n            int p=0,min=grid[i-1][0],nmin=Integer.MAX_VALUE,q=0;\\n            for(int j=0;j<grid.length;j++){\\n                if(grid[i-1][j]<min){\\n                    min=grid[i-1][j];\\n                    p=j;\\n                }\\n            }\\n            for(int j=0;j<grid.length;j++){\\n                if(j!=p&&grid[i-1][j]>=min&& grid[i-1][j]<nmin){\\n                    nmin=grid[i-1][j];\\n                }\\n            }\\n            for(int j=0;j<grid.length;j++){\\n                if(j!=p)\\n                    grid[i][j]+=min;\\n                else\\n                    grid[i][j]+=nmin;\\n            }\\n            // System.out.println(min+\" \"+nmin);\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<grid[0].length;i++){\\n            ans=Math.min(ans,grid[grid.length-1][i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390535,
                "title": "memoization-c-easiest-cpp-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int ind, int prev, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        //(ind is representing the current row number and prev representing the index which is not included as answer)\\n        int n = grid.size();\\n        //Base case\\n        if(ind == n) return 0;//if current row index reached n(end of matrix)\\n        if(dp[ind][prev+1] != -1) return dp[ind][prev+1];//checking if we have already calculated answer for this indexes\\n        int ans = INT_MAX;//to find minimum answer, initialze answer with max value\\n        //iterate through each column in the current row\\n        for(int j=0;j<n;j++){\\n            //If current column is not equal to the previous column, the nonly we are going to pick that element\\n            if(j != prev){\\n                //current picked element - grid[ind][j]\\n                int pick = grid[ind][j] + solve(ind+1, j, grid, dp);\\n                ans = min(ans, pick);\\n            }\\n        }\\n        //store the solution to the current subproblem in dp array\\n        return dp[ind][prev+1] = ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = INT_MAX;\\n        //initialize dp array with -1 values to keep track of subproblems\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n        //iterate through each column in the first row\\n        for(int i=0;i<n;i++){\\n            //finding the minimum falling path sum for each starting column\\n            ans = min(ans, solve(0, -1, grid, dp));\\n\\t\\t\\t//we passed -1 as prev, because for 1st row we have to check for all column values\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**I hope you find this solution helpful. If so, then please upvote it...\\u270C\\uD83C\\uDFFB\\uD83E\\uDD17**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int ind, int prev, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        //(ind is representing the current row number and prev representing the index which is not included as answer)\\n        int n = grid.size();\\n        //Base case\\n        if(ind == n) return 0;//if current row index reached n(end of matrix)\\n        if(dp[ind][prev+1] != -1) return dp[ind][prev+1];//checking if we have already calculated answer for this indexes\\n        int ans = INT_MAX;//to find minimum answer, initialze answer with max value\\n        //iterate through each column in the current row\\n        for(int j=0;j<n;j++){\\n            //If current column is not equal to the previous column, the nonly we are going to pick that element\\n            if(j != prev){\\n                //current picked element - grid[ind][j]\\n                int pick = grid[ind][j] + solve(ind+1, j, grid, dp);\\n                ans = min(ans, pick);\\n            }\\n        }\\n        //store the solution to the current subproblem in dp array\\n        return dp[ind][prev+1] = ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int ans = INT_MAX;\\n        //initialize dp array with -1 values to keep track of subproblems\\n        vector<vector<int>> dp(n, vector<int>(n+1, -1));\\n        //iterate through each column in the first row\\n        for(int i=0;i<n;i++){\\n            //finding the minimum falling path sum for each starting column\\n            ans = min(ans, solve(0, -1, grid, dp));\\n\\t\\t\\t//we passed -1 as prev, because for 1st row we have to check for all column values\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338295,
                "title": "c-short-sweet-time-o-m-n-space-o-1",
                "content": "````\\nclass Solution\\n{\\npublic:\\n    int minFallingPathSum(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        if (n == 1)\\n            return grid[0][0];\\n        else if (n == 2)\\n        {\\n            return max(grid[0][0] + grid[1][1], grid[0][1] + grid[1][0]);\\n        }\\n        priority_queue<vector<int>> pq;\\n        vector<int> v1, v2;\\n        int j;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i == 0)\\n            {\\n                for (j = 0; j < n; j++)\\n                {\\n                    pq.push({grid[i][j], j});\\n                    if (pq.size() > 2)\\n                    {\\n                        pq.pop();\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                v2 = pq.top();\\n                pq.pop();\\n                v1 = pq.top();\\n                pq.pop();\\n                for (j = 0; j < n; j++)\\n                {\\n                    if (v1[1] == j)\\n                    {\\n                        grid[i][j] += v2[0];\\n                    }\\n                    else\\n                    {\\n                        grid[i][j] += v1[0];\\n                    }\\n                    pq.push({grid[i][j], j});\\n                    if (pq.size() > 2)\\n                    {\\n                        pq.pop();\\n                    }\\n                }\\n            }\\n        }\\n        // for(auto &i: grid){\\n        //     for(auto &j: i)cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        v2 = pq.top();\\n        pq.pop();\\n        v1 = pq.top();\\n        pq.pop();\\n        return min(v1[0], v2[0]);\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution\\n{\\npublic:\\n    int minFallingPathSum(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n        if (n == 1)\\n            return grid[0][0];\\n        else if (n == 2)\\n        {\\n            return max(grid[0][0] + grid[1][1], grid[0][1] + grid[1][0]);\\n        }\\n        priority_queue<vector<int>> pq;\\n        vector<int> v1, v2;\\n        int j;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (i == 0)\\n            {\\n                for (j = 0; j < n; j++)\\n                {\\n                    pq.push({grid[i][j], j});\\n                    if (pq.size() > 2)\\n                    {\\n                        pq.pop();\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                v2 = pq.top();\\n                pq.pop();\\n                v1 = pq.top();\\n                pq.pop();\\n                for (j = 0; j < n; j++)\\n                {\\n                    if (v1[1] == j)\\n                    {\\n                        grid[i][j] += v2[0];\\n                    }\\n                    else\\n                    {\\n                        grid[i][j] += v1[0];\\n                    }\\n                    pq.push({grid[i][j], j});\\n                    if (pq.size() > 2)\\n                    {\\n                        pq.pop();\\n                    }\\n                }\\n            }\\n        }\\n        // for(auto &i: grid){\\n        //     for(auto &j: i)cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        v2 = pq.top();\\n        pq.pop();\\n        v1 = pq.top();\\n        pq.pop();\\n        return min(v1[0], v2[0]);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3251155,
                "title": "c-memoization-tabulation-space-optimization-dynamic-programming",
                "content": "\\n\\n# Memoization\\n```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, int n, int m, vector<vector<int>>& dp) {\\n        if (i == 0) return grid[i][j];\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int mini = INT_MAX;\\n        for (int it=0; it<m; it++) {\\n            if (it != j) mini = min(mini, grid[i][j] + f(i-1, it, grid, n, m, dp));\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        for (int j=0; j<m; j++) {\\n            ans = min(ans, f(n-1, j, grid, n, m, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        for (int j=0; j<m; j++) dp[0][j] = grid[0][j];\\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                int mini = INT_MAX;\\n                for (int it=0; it<m; it++) {\\n                    if (it != j) mini = min(mini, grid[i][j] + dp[i-1][it]);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        for (int j=0; j<m; j++) {\\n            ans = min(ans, dp[n-1][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        vector<int> prev(m, 0), cur(m, 0);\\n        for (int j=0; j<m; j++) prev[j] = grid[0][j];\\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                int mini = INT_MAX;\\n                for (int it=0; it<m; it++) {\\n                    if (it != j) mini = min(mini, grid[i][j] + prev[it]);\\n                }\\n                cur[j] = mini;\\n            }\\n            prev = cur;\\n        }\\n        for (int j=0; j<m; j++) {\\n            ans = min(ans, prev[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j, vector<vector<int>>& grid, int n, int m, vector<vector<int>>& dp) {\\n        if (i == 0) return grid[i][j];\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int mini = INT_MAX;\\n        for (int it=0; it<m; it++) {\\n            if (it != j) mini = min(mini, grid[i][j] + f(i-1, it, grid, n, m, dp));\\n        }\\n        return dp[i][j] = mini;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        for (int j=0; j<m; j++) {\\n            ans = min(ans, f(n-1, j, grid, n, m, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        for (int j=0; j<m; j++) dp[0][j] = grid[0][j];\\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                int mini = INT_MAX;\\n                for (int it=0; it<m; it++) {\\n                    if (it != j) mini = min(mini, grid[i][j] + dp[i-1][it]);\\n                }\\n                dp[i][j] = mini;\\n            }\\n        }\\n        for (int j=0; j<m; j++) {\\n            ans = min(ans, dp[n-1][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int ans = INT_MAX;\\n        vector<int> prev(m, 0), cur(m, 0);\\n        for (int j=0; j<m; j++) prev[j] = grid[0][j];\\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<m; j++) {\\n                int mini = INT_MAX;\\n                for (int it=0; it<m; it++) {\\n                    if (it != j) mini = min(mini, grid[i][j] + prev[it]);\\n                }\\n                cur[j] = mini;\\n            }\\n            prev = cur;\\n        }\\n        for (int j=0; j<m; j++) {\\n            ans = min(ans, prev[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016033,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        if(n == 1 and m == 1) return matrix[0][0];\\n        vector<vector<int>> dp(n+2, vector<int>(m+2, 0));\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                int mn = INT_MAX;\\n                for(int x=1; x<=m; x++) {\\n                    if(x != j) {\\n                        mn = min(dp[i-1][x], mn);\\n                    }\\n                }\\n                dp[i][j] = matrix[i - 1][j - 1] + mn;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1; i<=m; i++) {\\n            ans = min(ans, dp[n][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        if(n == 1 and m == 1) return matrix[0][0];\\n        vector<vector<int>> dp(n+2, vector<int>(m+2, 0));\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=m; j++) {\\n                int mn = INT_MAX;\\n                for(int x=1; x<=m; x++) {\\n                    if(x != j) {\\n                        mn = min(dp[i-1][x], mn);\\n                    }\\n                }\\n                dp[i][j] = matrix[i - 1][j - 1] + mn;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1; i<=m; i++) {\\n            ans = min(ans, dp[n][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906243,
                "title": "c-solution-using-simple-recursion-and-dp",
                "content": "# Intuition\\nApproach with simple Recusion intially and then implement DP\\n\\n# Approach\\nDepth First Search, For every row we move go down we check by adding the row cells value other than one exactly below the current cell as it is given in the constraint.\\n\\n# Complexity\\n- Time complexity:\\n    O(N^N) where  N is the number of cells in a row (Before DP)\\n    Optimized the huge complexity by introducing DP which       reduces the complexity to O(N^2) \\n\\n- Space complexity:\\n     Quadratic Complexity of O(N^2).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[203][203]={-1};\\n    Solution()\\n    {\\n        memset(dp,-1,sizeof(dp));   //DP intialization\\n    }\\n    int help(vector<vector<int>>& g,int i,int j)\\n    {\\n        if(i==g.size()) return 0;       //Base Condition to return the final row answer\\n        if(i>g.size()||j>=g.size()||i<0||j<0) return 200;  //Base Condition to return huge garbage value when index go out of bounds\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int sol=INT_MAX;\\n        for(int k=0;k<g.size();k++) // loop for checking all possible path Combination\\n        {\\n            if(k!=j)        //Constraint for neglecting the cell directly below the current cell\\n            {\\n                sol=min(sol,g[i][j]+help(g,i+1,k));\\n            }\\n        }\\n        return dp[i][j]=sol;\\n\\n    }\\n    int minFallingPathSum(vector<vector<int>>& g) {\\n        int sol=INT_MAX;\\n        if(g.size()==1) return g[0][0];\\n        for(int i=0;i<g.size();i++)     //to try each cell in the intial row\\n        {\\n            sol=min(sol,help(g,0,i));\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[203][203]={-1};\\n    Solution()\\n    {\\n        memset(dp,-1,sizeof(dp));   //DP intialization\\n    }\\n    int help(vector<vector<int>>& g,int i,int j)\\n    {\\n        if(i==g.size()) return 0;       //Base Condition to return the final row answer\\n        if(i>g.size()||j>=g.size()||i<0||j<0) return 200;  //Base Condition to return huge garbage value when index go out of bounds\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int sol=INT_MAX;\\n        for(int k=0;k<g.size();k++) // loop for checking all possible path Combination\\n        {\\n            if(k!=j)        //Constraint for neglecting the cell directly below the current cell\\n            {\\n                sol=min(sol,g[i][j]+help(g,i+1,k));\\n            }\\n        }\\n        return dp[i][j]=sol;\\n\\n    }\\n    int minFallingPathSum(vector<vector<int>>& g) {\\n        int sol=INT_MAX;\\n        if(g.size()==1) return g[0][0];\\n        for(int i=0;i<g.size();i++)     //to try each cell in the intial row\\n        {\\n            sol=min(sol,help(g,0,i));\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554196,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Bottom Up DP***\\n\\n* ***Time Complexity :- O(N * M * M)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                // find the minimum from the prev row\\n                \\n                int mini = INT_MAX;\\n                \\n                for(int k = 0; k < m; k++)\\n                {\\n                    if(k != j)\\n                    {\\n                        mini = min(mini, grid[i - 1][k]);\\n                    }\\n                }\\n                \\n                // update grid[i][j]\\n                \\n                grid[i][j] += mini;\\n            }\\n        }\\n        \\n        return *min_element(grid[n - 1].begin(), grid[n - 1].end());\\n    }\\n};\\n```\\n\\n* ***Optimized***\\n\\n* ***Using Bottom Up DP***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        // find the smallest and second smallest of 1st row\\n        \\n        int mini_1 = INT_MAX;\\n        \\n        int mini_idx_1 = 0;\\n        \\n        int mini_2 = INT_MAX;\\n            \\n        int mini_idx_2 = 0;\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            if(grid[0][j] < mini_1)\\n            {\\n                mini_2 = mini_1;\\n                \\n                mini_idx_2 = mini_idx_1;\\n                \\n                mini_1 = grid[0][j];\\n                \\n                mini_idx_1 = j;\\n            }\\n            else if(grid[0][j] < mini_2)\\n            {\\n                mini_2 = grid[0][j];\\n                \\n                mini_idx_2 = j;\\n            }\\n        }\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            // update curr row\\n            \\n            for(int j = 0; j < m; j++)\\n            {\\n                if(mini_idx_1 != j)\\n                {\\n                    grid[i][j] += mini_1;\\n                }\\n                else\\n                {\\n                    grid[i][j] += mini_2;\\n                }\\n            }\\n            \\n            // find smallest and second smallest from curr row\\n            \\n            mini_1 = INT_MAX;\\n        \\n            mini_idx_1 = 0;\\n        \\n            mini_2 = INT_MAX;\\n            \\n            mini_idx_2 = 0;\\n        \\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] < mini_1)\\n                {\\n                    mini_2 = mini_1;\\n                \\n                    mini_idx_2 = mini_idx_1;\\n                \\n                    mini_1 = grid[i][j];\\n                \\n                    mini_idx_1 = j;\\n                }\\n                else if(grid[i][j] < mini_2)\\n                {\\n                    mini_2 = grid[i][j];\\n                \\n                    mini_idx_2 = j;\\n                }\\n            }\\n        }\\n        \\n        return *min_element(grid[n - 1].begin(), grid[n - 1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                // find the minimum from the prev row\\n                \\n                int mini = INT_MAX;\\n                \\n                for(int k = 0; k < m; k++)\\n                {\\n                    if(k != j)\\n                    {\\n                        mini = min(mini, grid[i - 1][k]);\\n                    }\\n                }\\n                \\n                // update grid[i][j]\\n                \\n                grid[i][j] += mini;\\n            }\\n        }\\n        \\n        return *min_element(grid[n - 1].begin(), grid[n - 1].end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        // find the smallest and second smallest of 1st row\\n        \\n        int mini_1 = INT_MAX;\\n        \\n        int mini_idx_1 = 0;\\n        \\n        int mini_2 = INT_MAX;\\n            \\n        int mini_idx_2 = 0;\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            if(grid[0][j] < mini_1)\\n            {\\n                mini_2 = mini_1;\\n                \\n                mini_idx_2 = mini_idx_1;\\n                \\n                mini_1 = grid[0][j];\\n                \\n                mini_idx_1 = j;\\n            }\\n            else if(grid[0][j] < mini_2)\\n            {\\n                mini_2 = grid[0][j];\\n                \\n                mini_idx_2 = j;\\n            }\\n        }\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            // update curr row\\n            \\n            for(int j = 0; j < m; j++)\\n            {\\n                if(mini_idx_1 != j)\\n                {\\n                    grid[i][j] += mini_1;\\n                }\\n                else\\n                {\\n                    grid[i][j] += mini_2;\\n                }\\n            }\\n            \\n            // find smallest and second smallest from curr row\\n            \\n            mini_1 = INT_MAX;\\n        \\n            mini_idx_1 = 0;\\n        \\n            mini_2 = INT_MAX;\\n            \\n            mini_idx_2 = 0;\\n        \\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid[i][j] < mini_1)\\n                {\\n                    mini_2 = mini_1;\\n                \\n                    mini_idx_2 = mini_idx_1;\\n                \\n                    mini_1 = grid[i][j];\\n                \\n                    mini_idx_1 = j;\\n                }\\n                else if(grid[i][j] < mini_2)\\n                {\\n                    mini_2 = grid[i][j];\\n                \\n                    mini_idx_2 = j;\\n                }\\n            }\\n        }\\n        \\n        return *min_element(grid[n - 1].begin(), grid[n - 1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407410,
                "title": "python-bottom-up-optimal-tc-o-n-2-sc-o-1-solution-with-explanation",
                "content": "### bottom-up (dp)\\n```O(N^3)``` approach will TLE.\\n```dp[i][j]``` means minimum falling path sum from top to location```[i, j]```\\nstate transition function is ```dp[i][j] = grid[i][j] + min([dp[i-1][k] for k in range(len(grid[0])) if k != j])```\\nSo, we can use a PQ (min heap) to track previous row\\'s the first and second min value and its index\\nat ```dp[i][j]```, if ```j``` is the same as the first min value\\'s index, use second min value, otherwise, use the first min value.\\ntc is ```O(N^2logN)```, sc is ```O(N^2)```\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        dp = [[0] * n for _ in range(n)]\\n        minHeap = []\\n        for j in range(n):\\n            dp[0][j] = grid[0][j]\\n            heappush(minHeap, (dp[0][j], j))\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = heappop(minHeap), heappop(minHeap)\\n            minHeap = []\\n            for j in range(n):\\n                dp[i][j] = grid[i][j] + (firstMinValue if j!= firstMinIdx else secondMinValue)\\n                heappush(minHeap, (dp[i][j], j))\\n        return minHeap[0][0]\\n```\\nI found dp array is unnecessary, just use min heap to store ```dp[i-1]```\\ntc is ```O(N^2logN)```, sc is ```O(N)```\\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        minHeap = []\\n        for j in range(n):\\n            heappush(minHeap, (grid[0][j], j))\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = heappop(minHeap), heappop(minHeap)\\n            minHeap = []\\n            for j in range(n):\\n                dp_i_j = grid[i][j] + (firstMinValue if j!= firstMinIdx else secondMinValue)\\n                heappush(minHeap, (dp_i_j, j))\\n        return minHeap[0][0]\\n```\\nnow, just find the first min valuse and its index, and the second min value during calculating ```dp_i_j```\\ntc is ```O(len(grid)*len(grid[0]))```, sc is ```O(1)```\\nanother mothod ```O(N^2)``` is to use prefix and suffix array to find min value, but sc is ```O(N)```\\n```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        firstMin, secondMin = [float(\\'inf\\'), -1], [float(\\'inf\\'), -1]\\n        \\n        for j in range(n):\\n            if grid[0][j] < firstMin[0]:\\n                secondMin = firstMin[:] # copy firstMin, without `[:]` will not copy\\n                firstMin[0], firstMin[1] = grid[0][j], j\\n            elif grid[0][j] < secondMin[0]:\\n                secondMin[0], secondMin[1] = grid[0][j], j\\n\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = firstMin, secondMin\\n            firstMin, secondMin = [float(\\'inf\\'), -1], [float(\\'inf\\'), -1]\\n            for j in range(n):\\n                dp_i_j = grid[i][j] + (firstMinValue if j != firstMinIdx else secondMinValue)\\n                if dp_i_j < firstMin[0]:\\n                    secondMin = firstMin[:] # copy firstMin, without `[:]` will not copy\\n                    firstMin[0], firstMin[1] = dp_i_j, j\\n                elif dp_i_j < secondMin[0]:\\n                    secondMin[0], secondMin[1] = dp_i_j, j\\n        return firstMin[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```O(N^3)```\n```dp[i][j]```\n```[i, j]```\n```dp[i][j] = grid[i][j] + min([dp[i-1][k] for k in range(len(grid[0])) if k != j])```\n```dp[i][j]```\n```j```\n```O(N^2logN)```\n```O(N^2)```\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        dp = [[0] * n for _ in range(n)]\\n        minHeap = []\\n        for j in range(n):\\n            dp[0][j] = grid[0][j]\\n            heappush(minHeap, (dp[0][j], j))\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = heappop(minHeap), heappop(minHeap)\\n            minHeap = []\\n            for j in range(n):\\n                dp[i][j] = grid[i][j] + (firstMinValue if j!= firstMinIdx else secondMinValue)\\n                heappush(minHeap, (dp[i][j], j))\\n        return minHeap[0][0]\\n```\n```dp[i-1]```\n```O(N^2logN)```\n```O(N)```\n```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        minHeap = []\\n        for j in range(n):\\n            heappush(minHeap, (grid[0][j], j))\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = heappop(minHeap), heappop(minHeap)\\n            minHeap = []\\n            for j in range(n):\\n                dp_i_j = grid[i][j] + (firstMinValue if j!= firstMinIdx else secondMinValue)\\n                heappush(minHeap, (dp_i_j, j))\\n        return minHeap[0][0]\\n```\n```dp_i_j```\n```O(len(grid)*len(grid[0]))```\n```O(1)```\n```O(N^2)```\n```O(N)```\n```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        if len(grid) == 1: return grid[0][0]\\n        n = len(grid)\\n        firstMin, secondMin = [float(\\'inf\\'), -1], [float(\\'inf\\'), -1]\\n        \\n        for j in range(n):\\n            if grid[0][j] < firstMin[0]:\\n                secondMin = firstMin[:] # copy firstMin, without `[:]` will not copy\\n                firstMin[0], firstMin[1] = grid[0][j], j\\n            elif grid[0][j] < secondMin[0]:\\n                secondMin[0], secondMin[1] = grid[0][j], j\\n\\n        for i in range(1, n):\\n            (firstMinValue, firstMinIdx), (secondMinValue, _) = firstMin, secondMin\\n            firstMin, secondMin = [float(\\'inf\\'), -1], [float(\\'inf\\'), -1]\\n            for j in range(n):\\n                dp_i_j = grid[i][j] + (firstMinValue if j != firstMinIdx else secondMinValue)\\n                if dp_i_j < firstMin[0]:\\n                    secondMin = firstMin[:] # copy firstMin, without `[:]` will not copy\\n                    firstMin[0], firstMin[1] = dp_i_j, j\\n                elif dp_i_j < secondMin[0]:\\n                    secondMin[0], secondMin[1] = dp_i_j, j\\n        return firstMin[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306834,
                "title": "c-tabulation-o-n-n-tc-o-1-sc",
                "content": "\\tint minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==0) return grid[0][0];\\n        int min1=INT_MAX,min2=INT_MAX;\\n        for(int i=1;i<n;i++){\\n            min1=INT_MAX;\\n            min2=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                if(grid[i-1][j]<=min1) {\\n                    min2=min1;\\n                    min1=grid[i-1][j];\\n                }\\n                else if(grid[i-1][j]<min2) min2=grid[i-1][j];\\n            }\\n            for(int j=0;j<n;j++){\\n                if(grid[i-1][j]==min1) grid[i][j]+=min2;\\n                else grid[i][j]+=min1;\\n            }\\n        }\\n        min1=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(grid[n-1][i]<min1) min1=grid[n-1][i];\\n        }\\n        return min1;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==0) return grid[0][0];\\n        int min1=INT_MAX,min2=INT_MAX;\\n        for(int i=1;i<n;i++){\\n            min1=INT_MAX;\\n            min2=INT_MAX;\\n            for(int j=0;j<n;j++){\\n                if(grid[i-1][j]<=min1) {\\n                    min2=min1;\\n                    min1=grid[i-1][j];\\n                }\\n                else if(grid[i-1][j]<min2) min2=grid[i-1][j];\\n            }\\n            for(int j=0;j<n;j++){\\n                if(grid[i-1][j]==min1) grid[i][j]+=min2;\\n                else grid[i][j]+=min1;\\n            }\\n        }\\n        min1=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(grid[n-1][i]<min1) min1=grid[n-1][i];\\n        }\\n        return min1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2271931,
                "title": "just-like-minimum-falling-path-sum-problem",
                "content": "```\\n\\n// time : O(n^3)\\n//space : O(n^2)\\n\\nclass Solution {\\npublic:\\n    \\n    int const inf=1e9 ;\\n    int solve(vector<vector<int>>& matrix,vector<vector<int>>& dp, int r,int c,int i,int j){\\n        if(j<0 || j>=c)\\n            return inf;\\n        if(i==r-1)\\n            return matrix[r-1][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int k=0;k<c;k++){\\n            if(j==k)\\n                continue;\\n            ans=min(ans,solve(matrix,dp,r,c,i+1,k)+matrix[i][j]);\\n        }\\n        \\n        \\n        \\n        return dp[i][j]=ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<vector<int>> dp(r,vector<int>(c,-1));\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<c;i++){\\n            ans=min(ans,solve(matrix,dp,r,c,0,i));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n//You forgot to UPVOTE !!!\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n// time : O(n^3)\\n//space : O(n^2)\\n\\nclass Solution {\\npublic:\\n    \\n    int const inf=1e9 ;\\n    int solve(vector<vector<int>>& matrix,vector<vector<int>>& dp, int r,int c,int i,int j){\\n        if(j<0 || j>=c)\\n            return inf;\\n        if(i==r-1)\\n            return matrix[r-1][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int k=0;k<c;k++){\\n            if(j==k)\\n                continue;\\n            ans=min(ans,solve(matrix,dp,r,c,i+1,k)+matrix[i][j]);\\n        }\\n        \\n        \\n        \\n        return dp[i][j]=ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<vector<int>> dp(r,vector<int>(c,-1));\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<c;i++){\\n            ans=min(ans,solve(matrix,dp,r,c,0,i));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n//You forgot to UPVOTE !!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235338,
                "title": "java-memoization-solution",
                "content": "Remember that memoization solutions take more time to execute but are easy to understand and they form the basics for the tabulation solution.\\n\\nIf you like the solution then please UPVOTE.\\n\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int[][] dp = new int[m][m];\\n        \\n        for(int i = 0 ; i < m ; i++)\\n            for(int j = 0 ; j < m ; j++)\\n                dp[i][j] = -1;\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0 ; i < m ; i++)\\n            min = Math.min(min , path(grid , m , 0 , i , dp));\\n        \\n        return min;\\n    }\\n    \\n    public int path(int[][] grid , int m , int r , int c , int[][] dp){\\n        if(c>=m)\\n            return Integer.MAX_VALUE-10000;\\n        \\n        if(dp[r][c] != -1)  return dp[r][c];\\n        \\n        if(r == m-1)\\n            return grid[r][c];\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            if(i != c)\\n            min = Math.min(min , grid[r][c] + path(grid , m , r+1 , i , dp));\\n        }\\n        \\n        return dp[r][c] = min;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int[][] dp = new int[m][m];\\n        \\n        for(int i = 0 ; i < m ; i++)\\n            for(int j = 0 ; j < m ; j++)\\n                dp[i][j] = -1;\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0 ; i < m ; i++)\\n            min = Math.min(min , path(grid , m , 0 , i , dp));\\n        \\n        return min;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2227805,
                "title": "c-o-n2-o-1-full-explanation",
                "content": "We will be traversing from top row to the bottom. \\nStore the result of prev row in an array say dp.\\nLets take an example of matrix:\\n1 2 3\\n4 5 6\\n7 8 9\\nfor first row, our dp array is 1 2 3\\nfor next row, we will be adding the minimum of the dp array to each index taking into act that element of prev array is not from the same index.\\nso for 4 5 6\\nthe additional value is 2 1 1\\nhere for index j, we will be adding minimum value of dp array without that index j element.\\nand if we notice, it can be found that we just need to calculate first and second minimums and add them.\\ncheck out the code for better understanding.\\nupvote if it helps:)\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==1) return grid[0][0];\\n        vector<int> dp(n);\\n        for(int i=0; i<n; i++) dp[i]=grid[0][i];\\n        for(int i=1; i<n; i++) {\\n            int minone=INT_MAX, mintwo=INT_MAX;\\n            for(int j=0; j<n; j++) {\\n                if(minone>dp[j]) {\\n                    mintwo=minone, minone=dp[j];\\n                }\\n                else if(mintwo>dp[j]) mintwo=dp[j];\\n            }\\n            for(int j=0; j<n; j++) {\\n                if(dp[j]==minone) dp[j]=mintwo+grid[i][j];\\n                else dp[j]=minone+grid[i][j];\\n            }\\n        }\\n        int ans=dp[0];\\n        for(int i=1; i<n; i++) ans=min(ans,dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(n==1) return grid[0][0];\\n        vector<int> dp(n);\\n        for(int i=0; i<n; i++) dp[i]=grid[0][i];\\n        for(int i=1; i<n; i++) {\\n            int minone=INT_MAX, mintwo=INT_MAX;\\n            for(int j=0; j<n; j++) {\\n                if(minone>dp[j]) {\\n                    mintwo=minone, minone=dp[j];\\n                }\\n                else if(mintwo>dp[j]) mintwo=dp[j];\\n            }\\n            for(int j=0; j<n; j++) {\\n                if(dp[j]==minone) dp[j]=mintwo+grid[i][j];\\n                else dp[j]=minone+grid[i][j];\\n            }\\n        }\\n        int ans=dp[0];\\n        for(int i=1; i<n; i++) ans=min(ans,dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114161,
                "title": "java-recursive-memoized-tabulated",
                "content": "**Pure Recursion (TLE)**\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        if(grid.length==1)\\n            return grid[0][0];\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<grid.length;i++){\\n            ans = Math.min(ans,minPath(grid,i,0));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int[][] arr,int last,int ind){\\n        int n = arr.length;\\n        if(ind==arr.length-1){\\n            int ans = Integer.MAX_VALUE;\\n            for(int i=0;i<arr.length;i++){\\n                if(i!=last) ans = Math.min(ans,arr[ind][i]);\\n            }\\n            return ans;\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            if(i!=last)\\n            min = Math.min(min,arr[ind][i] + minPath(arr,i,ind+1));\\n        }\\n        return min;\\n    }\\n}\\n```\\n\\n**Memoization (TLE on 11th test case)**\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        if(grid.length==1 && grid[0].length==1)\\n            return grid[0][0];\\n        else if(grid.length==1){\\n            int[] arr = grid[0];\\n            Arrays.sort(arr);\\n            return arr[0];\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        int n = grid.length;\\n        for(int i=0;i<grid.length;i++){\\n            int[][] dp = new int[n][n];\\n            ans = Math.min(ans,minPath(grid,i,0,dp));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int[][] arr,int last,int ind,int[][] dp){\\n        int n = arr.length;\\n        if(ind==arr.length-1){\\n            int ans = Integer.MAX_VALUE;\\n            for(int i=0;i<arr.length;i++){\\n                if(i!=last) ans = Math.min(ans,arr[ind][i]);\\n            }\\n            return dp[ind][last] = ans;\\n        }\\n        if(dp[ind][last]!=0) return dp[ind][last];\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            if(i!=last)\\n            min = Math.min(min,arr[ind][i] + minPath(arr,i,ind+1,dp));\\n        }\\n        return dp[ind][last]=min;\\n    }\\n}\\n```\\n\\n**Tabulation (Accepted)**\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        if(grid.length==1 && grid[0].length==1)\\n            return grid[0][0];\\n        int n = grid.length;\\n        int[][] dp = new int[n][n];\\n        return minPath(grid,dp);\\n    }\\n    private int minPath(int[][] arr,int[][] dp){\\n        for(int i=0;i<arr.length;i++){\\n            dp[arr.length-1][i] = arr[arr.length-1][i];\\n        }\\n        int n = arr.length;\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int ans = Integer.MAX_VALUE;\\n            for(int k=0;k<n;k++){\\n                if(k!=j){\\n                    ans = Math.min(ans,arr[i][j]+dp[i+1][k]);\\n                    }\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            ans = Math.min(ans,dp[0][i]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        if(grid.length==1)\\n            return grid[0][0];\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<grid.length;i++){\\n            ans = Math.min(ans,minPath(grid,i,0));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int[][] arr,int last,int ind){\\n        int n = arr.length;\\n        if(ind==arr.length-1){\\n            int ans = Integer.MAX_VALUE;\\n            for(int i=0;i<arr.length;i++){\\n                if(i!=last) ans = Math.min(ans,arr[ind][i]);\\n            }\\n            return ans;\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            if(i!=last)\\n            min = Math.min(min,arr[ind][i] + minPath(arr,i,ind+1));\\n        }\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        if(grid.length==1 && grid[0].length==1)\\n            return grid[0][0];\\n        else if(grid.length==1){\\n            int[] arr = grid[0];\\n            Arrays.sort(arr);\\n            return arr[0];\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        int n = grid.length;\\n        for(int i=0;i<grid.length;i++){\\n            int[][] dp = new int[n][n];\\n            ans = Math.min(ans,minPath(grid,i,0,dp));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int[][] arr,int last,int ind,int[][] dp){\\n        int n = arr.length;\\n        if(ind==arr.length-1){\\n            int ans = Integer.MAX_VALUE;\\n            for(int i=0;i<arr.length;i++){\\n                if(i!=last) ans = Math.min(ans,arr[ind][i]);\\n            }\\n            return dp[ind][last] = ans;\\n        }\\n        if(dp[ind][last]!=0) return dp[ind][last];\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            if(i!=last)\\n            min = Math.min(min,arr[ind][i] + minPath(arr,i,ind+1,dp));\\n        }\\n        return dp[ind][last]=min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        if(grid.length==1 && grid[0].length==1)\\n            return grid[0][0];\\n        int n = grid.length;\\n        int[][] dp = new int[n][n];\\n        return minPath(grid,dp);\\n    }\\n    private int minPath(int[][] arr,int[][] dp){\\n        for(int i=0;i<arr.length;i++){\\n            dp[arr.length-1][i] = arr[arr.length-1][i];\\n        }\\n        int n = arr.length;\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int ans = Integer.MAX_VALUE;\\n            for(int k=0;k<n;k++){\\n                if(k!=j){\\n                    ans = Math.min(ans,arr[i][j]+dp[i+1][k]);\\n                    }\\n                }\\n                dp[i][j] = ans;\\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            ans = Math.min(ans,dp[0][i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106717,
                "title": "c-tabulation-easy-solution",
                "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n         int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        // base case\\n        for(int i=0;i<m;i++){\\n            int temp=1e9;\\n            for(int j=0;j<m;j++){\\n                if(j!=i){\\n           temp=min(temp,matrix[0][j]);\\n                }\\n            }\\n             dp[0][i]=temp;\\n        }\\n        \\n\\n     \\n        for(int i=1;i<n;i++){\\n        \\n            for(int k=0;k<m;k++){\\n                int temp=INT_MAX; \\n           for(int j=0;j<m;j++){\\n             if(j!=k){\\n            int leftd=matrix[i][j];\\n            leftd+=dp[i-1][j];\\n            temp=min(temp,leftd);\\n             }\\n          }\\n                dp[i][k]=temp;\\n            }\\n        }\\n                int ans1=INT_MAX;\\n          for(int j=0;j<m;j++){\\n           \\n            ans1=min(ans1,dp[n-1][j]);\\n        }      \\n      if(ans1==1e9)return matrix[0][0];\\n        return ans1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n         int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,0));\\n        // base case\\n        for(int i=0;i<m;i++){\\n            int temp=1e9;\\n            for(int j=0;j<m;j++){\\n                if(j!=i){\\n           temp=min(temp,matrix[0][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2069869,
                "title": "java-o-m-n-solution",
                "content": "Add the minimum element from previous row to the element in current row.\\n\\nIf the minimum element from previous row is in the same column then  use the second minimum element from previous row\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int min = 100,secondMin = 100;\\n        \\n        // find min and secondMin element in the first row\\n        for(int j=0;j<n;++j){\\n            if(min > grid[0][j]){\\n                secondMin = min;\\n                min = grid[0][j];\\n            }\\n            else if(secondMin > grid[0][j]) secondMin = grid[0][j];\\n        }\\n        \\n        for(int i=1;i<n;++i){\\n            int t1 = Integer.MAX_VALUE,t2 = Integer.MAX_VALUE; // temp min,secondMin \\n            for(int j=0;j<n;++j){\\n                grid[i][j] += grid[i-1][j] == min ? secondMin  : min;\\n                \\n                if(t1 > grid[i][j]){\\n                  t2 = t1;\\n                  t1 = grid[i][j];\\n                }\\n                else if(t2 > grid[i][j]) t2 = grid[i][j];\\n            }\\n            min = t1; secondMin  = t2;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int min = 100,secondMin = 100;\\n        \\n        // find min and secondMin element in the first row\\n        for(int j=0;j<n;++j){\\n            if(min > grid[0][j]){\\n                secondMin = min;\\n                min = grid[0][j];\\n            }\\n            else if(secondMin > grid[0][j]) secondMin = grid[0][j];\\n        }\\n        \\n        for(int i=1;i<n;++i){\\n            int t1 = Integer.MAX_VALUE,t2 = Integer.MAX_VALUE; // temp min,secondMin \\n            for(int j=0;j<n;++j){\\n                grid[i][j] += grid[i-1][j] == min ? secondMin  : min;\\n                \\n                if(t1 > grid[i][j]){\\n                  t2 = t1;\\n                  t1 = grid[i][j];\\n                }\\n                else if(t2 > grid[i][j]) t2 = grid[i][j];\\n            }\\n            min = t1; secondMin  = t2;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998001,
                "title": "python-dp-solution-min-and-second-min-faster-than-79-77",
                "content": "**Algorithm:**\\n1. Find the **minimum** and **second minimum** of the previous row.\\n2. If the current row\\'s element is not adjacent to the minimum of prev. row then add minimum to the current element.\\n3. Otherwise add second minimum to the current element.\\n\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        min1 = min11 = float(\\'inf\\')                     # min1 -> minimum , min11 -> second minimum in even indexed row\\n        min2 = min22 = float(\\'inf\\')                     # min2 -> minimum , min22 -> second minimum in odd indexed row\\n        for i in range(rows):\\n            for j in range(cols):\\n                if i==0:\\n                    if grid[i][j]<=min1:                # Logic to find minimum and second minimum\\n                        min11 = min1\\n                        min1 = grid[i][j]\\n                    elif grid[i][j]<min11:\\n                        min11 = grid[i][j]    \\n                else:\\n                    if i%2:\\n                        if grid[i-1][j]==min1:          # If adjacent -> then add the second minimum value\\n                            grid[i][j] += min11\\n                        else:                           # Else -> add the minimum value\\n                            grid[i][j] += min1\\n                        if grid[i][j]<min2:             # Logic to find minimum and second minimum\\n                            min22 = min2\\n                            min2 = grid[i][j]\\n                        elif grid[i][j]<min22:\\n                            min22 = grid[i][j]\\n                    else:\\n                        if grid[i-1][j]==min2:\\n                            grid[i][j] += min22\\n                        else:\\n                            grid[i][j] += min2\\n                        if grid[i][j]<min1:             # Logic to find minimum and second minimum\\n                            min11 = min1\\n                            min1 = grid[i][j]\\n                        elif grid[i][j]<min11:\\n                            min11 = grid[i][j]    \\n            if i%2:                                     # Reset the minimum and second minimum values accordingly\\n                min1 = min11 = float(\\'inf\\')\\n            else:\\n                min2 = min22 = float(\\'inf\\')\\n        return min(grid[-1])                            # Return the minimum element in last row\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        min1 = min11 = float(\\'inf\\')                     # min1 -> minimum , min11 -> second minimum in even indexed row\\n        min2 = min22 = float(\\'inf\\')                     # min2 -> minimum , min22 -> second minimum in odd indexed row\\n        for i in range(rows):\\n            for j in range(cols):\\n                if i==0:\\n                    if grid[i][j]<=min1:                # Logic to find minimum and second minimum\\n                        min11 = min1\\n                        min1 = grid[i][j]\\n                    elif grid[i][j]<min11:\\n                        min11 = grid[i][j]    \\n                else:\\n                    if i%2:\\n                        if grid[i-1][j]==min1:          # If adjacent -> then add the second minimum value\\n                            grid[i][j] += min11\\n                        else:                           # Else -> add the minimum value\\n                            grid[i][j] += min1\\n                        if grid[i][j]<min2:             # Logic to find minimum and second minimum\\n                            min22 = min2\\n                            min2 = grid[i][j]\\n                        elif grid[i][j]<min22:\\n                            min22 = grid[i][j]\\n                    else:\\n                        if grid[i-1][j]==min2:\\n                            grid[i][j] += min22\\n                        else:\\n                            grid[i][j] += min2\\n                        if grid[i][j]<min1:             # Logic to find minimum and second minimum\\n                            min11 = min1\\n                            min1 = grid[i][j]\\n                        elif grid[i][j]<min11:\\n                            min11 = grid[i][j]    \\n            if i%2:                                     # Reset the minimum and second minimum values accordingly\\n                min1 = min11 = float(\\'inf\\')\\n            else:\\n                min2 = min22 = float(\\'inf\\')\\n        return min(grid[-1])                            # Return the minimum element in last row\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883513,
                "title": "c-dp-easy-to-understand-solution-explanation",
                "content": "1.For each row, run a loop through all columns and skip the column taken in the last row.\\n2. For each column, call the recursive function and take minimum sum.\\n\\nStates: row, lastColumn\\nWhat is getting stored in dp array: sum of the path\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[205][205];\\n    \\n    int pathSum(vector<vector<int>>& grid, int row, int lastCol){\\n        if(row==grid.size()) return 0;\\n        if(dp[row][lastCol] != -1) return dp[row][lastCol];\\n        \\n        dp[row][lastCol] = 1e9;\\n        \\n        for(int i=0; i<grid.size(); i++){\\n            if(i==lastCol) continue;\\n            dp[row][lastCol] = min(dp[row][lastCol], \\n                                  pathSum(grid, row+1, i) + grid[row][i]);\\n        }\\n        \\n        return dp[row][lastCol];\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        memset(dp,-1, sizeof dp);\\n        return pathSum(grid, 0, grid.size());\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[205][205];\\n    \\n    int pathSum(vector<vector<int>>& grid, int row, int lastCol){\\n        if(row==grid.size()) return 0;\\n        if(dp[row][lastCol] != -1) return dp[row][lastCol];\\n        \\n        dp[row][lastCol] = 1e9;\\n        \\n        for(int i=0; i<grid.size(); i++){\\n            if(i==lastCol) continue;\\n            dp[row][lastCol] = min(dp[row][lastCol], \\n                                  pathSum(grid, row+1, i) + grid[row][i]);\\n        }\\n        \\n        return dp[row][lastCol];\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        memset(dp,-1, sizeof dp);\\n        return pathSum(grid, 0, grid.size());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1728013,
                "title": "easy-solution-dp-memoization-c",
                "content": "```\\nclass Solution {\\n    int dp[202][202];\\npublic:\\n    int solve(vector<vector<int>>& grid, int i, int j, int n, int m){\\n        if (i==n-1) return grid[i][j];\\n        if (dp[i][j]!=-1) return dp[i][j];\\n        int res=INT_MAX;\\n\\t\\t// traverse all elements of next row except same column.\\n        for (int ind=0;ind<m;ind++){\\n            if (ind!=j){\\n                res=min(res,grid[i][j]+solve(grid,i+1,ind,n,m));\\n            }\\n        }\\n        return dp[i][j]=res;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int min_val=INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t// this loop is for all elements of first row\\n        for (int i=0;i<m;i++){\\n            min_val=min(min_val,solve(grid,0,i,n,m));\\n        }\\n        return min_val;\\n    }\\n};\\n```\\n\\nPS: do \"UPVOTE\" if you liked this solution :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[202][202];\\npublic:\\n    int solve(vector<vector<int>>& grid, int i, int j, int n, int m){\\n        if (i==n-1) return grid[i][j];\\n        if (dp[i][j]!=-1) return dp[i][j];\\n        int res=INT_MAX;\\n\\t\\t// traverse all elements of next row except same column.\\n        for (int ind=0;ind<m;ind++){\\n            if (ind!=j){\\n                res=min(res,grid[i][j]+solve(grid,i+1,ind,n,m));\\n            }\\n        }\\n        return dp[i][j]=res;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int min_val=INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t// this loop is for all elements of first row\\n        for (int i=0;i<m;i++){\\n            min_val=min(min_val,solve(grid,0,i,n,m));\\n        }\\n        return min_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723740,
                "title": "c-memoization-simple-solution-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int solve(vector<vector<int>>& grid,int i,int j)\\n    {\\n        if(i==grid.size())//base case\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1)//if already computed return from there itself\\n        {\\n            return dp[i][j];\\n        }\\n        int res=INT_MAX;\\n        for(int k=0;k<grid[0].size();k++)\\n        {\\n            //we cant move in same column so if at any point it equals we have to skip it\\n            if(k==j)\\n               continue;\\n            //calulate for other columns recursively\\n            int ans=grid[i][j]+solve(grid,i+1,k);\\n            res=min(res,ans);//store the minimum result\\n        }\\n        return dp[i][j]=res;//store in dp matrix to avoid duplicate calls and return it\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int ans=INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n        if(grid.size()==1)//if size of grid is 1 return the element itself\\n        {\\n            return grid[0][0];\\n        }\\n        for(int i=0;i<grid[0].size();i++)//traverse over every column and find minimum ans\\n        {\\n            ans=min(ans,solve(grid,0,i));\\n        }\\n        return ans;    \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[201][201];\\n    int solve(vector<vector<int>>& grid,int i,int j)\\n    {\\n        if(i==grid.size())//base case\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1702457,
                "title": "t-c-o-n-2-s-c-o-n-all-methods-from-o-n-3-to-o-n-2-min-fall-path-2",
                "content": "BOTTOM UP - T.C : O(n^2); S.C : O(n)  [cummulative array used to reduce the T.C]\\n```\\nint n;\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        n = matrix.size();\\n        \\n        if(n == 1){\\n            return matrix[0][0];\\n        }\\n        vector<int> dp = matrix[n-1];\\n        vector<int> pre(n);\\n        vector<int> suf(n);\\n\\n        \\n        for(int i = n-2;i>=0;i--){\\n        \\n            pre[0] = dp[0];\\n            for(int k = 1;k<n;k++){\\n                pre[k] = min(pre[k-1],dp[k]);\\n            }\\n\\n            suf[n-1] = dp[n-1];\\n            for(int k = n-2;k>=0;k--){\\n                suf[k] = min(suf[k+1],dp[k]);\\n            }\\n            \\n            for(int j = 0;j<n;j++){\\n\\n                int left = (j-1>=0 ? pre[j-1]:1e9);\\n                int right = (j+1<n ? suf[j+1]:1e9);\\n\\n                dp[j] = min(left,right) + matrix[i][j];\\n            }\\n\\n        }\\n        int ans = 1e9;\\n        for(int i = 0;i<n;i++){     \\n            ans = min(ans,dp[i]);\\n        }\\n        return ans;  \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/f87a5dc7-e342-4ad1-baef-3d6c853c6d8b_1642603087.6757252.png)\\n\\nBOTTOM-UP - O(n^3)\\n\\n```\\nint n;\\nint dp[201][201];\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        n = matrix.size();\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                dp[i][j] = INT_MIN;\\n            }\\n        }\\n        if(n == 1){\\n            return matrix[0][0];\\n        }\\n        \\n        for(int i = n-1;i>=0;i--){\\n            for(int j = 0;j<n;j++){\\n\\n                if(i == n-1){\\n                    dp[i][j] = matrix[i][j];\\n                    continue;\\n                }\\n\\n                dp[i][j] = 1e9;\\n                for(int k = 0;k<n;k++){\\n\\n                    if(j == k){\\n                        continue;\\n                    }\\n\\n                    dp[i][j] = min(dp[i][j],dp[i+1][k]+matrix[i][j]);\\n\\n                }\\n\\n            }\\n\\n        }\\n        int ans = 1e9;\\n        for(int i = 0;i<n;i++){    //on this basis we can reduce the T.C to \\n            ans = min(ans,dp[0][i]);\\n        }\\n        return ans;  \\n    }\\n};\\n```\\nTOP-DOWN  -- O(n^3)\\n```\\nint n;\\nint dp[201][201];\\nclass Solution {\\npublic:\\n    int util(int row, int col, vector<vector<int>>& mat){\\n        if(row >= n){\\n            return 0;\\n        }\\n\\n        if(dp[row][col] != INT_MIN){\\n            return dp[row][col];\\n        }\\n        int ans = 1e9;\\n        for(int i = 0;i<n;i++){\\n            if(col == i){\\n                continue;\\n            }\\n            ans = min(ans,util(row+1,i,mat)+mat[row][col]);\\n        }\\n        return dp[row][col] = ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        n = matrix.size();\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                dp[i][j] = INT_MIN;\\n            }\\n        }\\n        if(n == 1){\\n            return matrix[0][0];\\n        }\\n        int ans = INT_MAX;\\n        \\n        for(int i= 0;i<n;i++){\\n            ans = min(ans,util(0,i,matrix));\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint n;\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        n = matrix.size();\\n        \\n        if(n == 1){\\n            return matrix[0][0];\\n        }\\n        vector<int> dp = matrix[n-1];\\n        vector<int> pre(n);\\n        vector<int> suf(n);\\n\\n        \\n        for(int i = n-2;i>=0;i--){\\n        \\n            pre[0] = dp[0];\\n            for(int k = 1;k<n;k++){\\n                pre[k] = min(pre[k-1],dp[k]);\\n            }\\n\\n            suf[n-1] = dp[n-1];\\n            for(int k = n-2;k>=0;k--){\\n                suf[k] = min(suf[k+1],dp[k]);\\n            }\\n            \\n            for(int j = 0;j<n;j++){\\n\\n                int left = (j-1>=0 ? pre[j-1]:1e9);\\n                int right = (j+1<n ? suf[j+1]:1e9);\\n\\n                dp[j] = min(left,right) + matrix[i][j];\\n            }\\n\\n        }\\n        int ans = 1e9;\\n        for(int i = 0;i<n;i++){     \\n            ans = min(ans,dp[i]);\\n        }\\n        return ans;  \\n    }\\n};\\n```\n```\\nint n;\\nint dp[201][201];\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        n = matrix.size();\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                dp[i][j] = INT_MIN;\\n            }\\n        }\\n        if(n == 1){\\n            return matrix[0][0];\\n        }\\n        \\n        for(int i = n-1;i>=0;i--){\\n            for(int j = 0;j<n;j++){\\n\\n                if(i == n-1){\\n                    dp[i][j] = matrix[i][j];\\n                    continue;\\n                }\\n\\n                dp[i][j] = 1e9;\\n                for(int k = 0;k<n;k++){\\n\\n                    if(j == k){\\n                        continue;\\n                    }\\n\\n                    dp[i][j] = min(dp[i][j],dp[i+1][k]+matrix[i][j]);\\n\\n                }\\n\\n            }\\n\\n        }\\n        int ans = 1e9;\\n        for(int i = 0;i<n;i++){    //on this basis we can reduce the T.C to \\n            ans = min(ans,dp[0][i]);\\n        }\\n        return ans;  \\n    }\\n};\\n```\n```\\nint n;\\nint dp[201][201];\\nclass Solution {\\npublic:\\n    int util(int row, int col, vector<vector<int>>& mat){\\n        if(row >= n){\\n            return 0;\\n        }\\n\\n        if(dp[row][col] != INT_MIN){\\n            return dp[row][col];\\n        }\\n        int ans = 1e9;\\n        for(int i = 0;i<n;i++){\\n            if(col == i){\\n                continue;\\n            }\\n            ans = min(ans,util(row+1,i,mat)+mat[row][col]);\\n        }\\n        return dp[row][col] = ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        n = matrix.size();\\n        \\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<n;j++){\\n                dp[i][j] = INT_MIN;\\n            }\\n        }\\n        if(n == 1){\\n            return matrix[0][0];\\n        }\\n        int ans = INT_MAX;\\n        \\n        for(int i= 0;i<n;i++){\\n            ans = min(ans,util(0,i,matrix));\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598176,
                "title": "simple-c-recursion-memoization-dp-easy-understand",
                "content": "\\n```\\n int fun(vector<vector<int>>& grid,int i,int j,int m,int n,vector<vector<int>>& dp){\\n        if(i<0 || i>=m || j<0 || j>=n) return INT_MAX;\\n        \\n        if(i==m-1) return grid[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int op=INT_MAX;\\n        for(int k=0;k<n;k++){\\n            if(j!=k) op=min(op,fun(grid,i+1,k,m,n,dp));\\n        }\\n        \\n        return dp[i][j]=grid[i][j]+op;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> dp(m+1,vector<int>(n+1,-1));\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<n;j++){\\n            ans=min(ans,fun(grid,0,j,m,n,dp));\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n int fun(vector<vector<int>>& grid,int i,int j,int m,int n,vector<vector<int>>& dp){\\n        if(i<0 || i>=m || j<0 || j>=n) return INT_MAX;\\n        \\n        if(i==m-1) return grid[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int op=INT_MAX;\\n        for(int k=0;k<n;k++){\\n            if(j!=k) op=min(op,fun(grid,i+1,k,m,n,dp));\\n        }\\n        \\n        return dp[i][j]=grid[i][j]+op;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> dp(m+1,vector<int>(n+1,-1));\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<n;j++){\\n            ans=min(ans,fun(grid,0,j,m,n,dp));\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1422780,
                "title": "100-faster-recursion-memoization",
                "content": "```\\nclass Solution {\\n    class pair{\\n        int col;\\n        int val;\\n        pair(int col,int val){\\n            this.col=col;\\n            this.val=val;\\n        }\\n    }\\n    \\n    Integer[][]  dp;\\n    \\n    public int minFallingPathSum(int[][] grid) {\\n        dp=new Integer[grid.length+1][grid[0].length+1];\\n        List<List<pair>> mins=new ArrayList<>();\\n         \\n        for(int i=0;i<grid.length;i++){\\n           \\n            int min1=(int)1e9,min2=(int)1e9,c1=0,c2=0;\\n            List<pair> arr=new ArrayList<>(); \\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]<=min1){\\n                    \\n                    min2=min1;\\n                    c2=c1;\\n                    min1=grid[i][j];\\n                    c1=j;\\n                }else if(grid[i][j]<min2){\\n                    min2=grid[i][j];\\n                    c2=j;\\n                }\\n            }\\n            arr.add(new pair(c1,min1));\\n            arr.add(new pair(c2,min2));\\n            mins.add(arr);\\n        }\\n        \\n        int min=(int)1e9;\\n       for(int i=0;i<2;i++){\\n           int col=mins.get(0).get(i).col;\\n           min=Math.min(min,solve(mins,1,col)+mins.get(0).get(i).val);\\n       }\\n        return min;\\n    }\\n    \\n    public int solve(List<List<pair>> mins,int r,int c){\\n        if(r==mins.size())return 0;\\n        \\n        if(dp[r][c]!=null)return dp[r][c];\\n        \\n        int min=(int)1e9;        \\n            for(int i=0;i<2;i++){\\n               int col= mins.get(r).get(i).col;\\n                if(c!=col){\\n                   min=Math.min(min, solve(mins,r+1,col)+mins.get(r).get(i).val);\\n                }\\n            }\\n        return  dp[r][c]= min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class pair{\\n        int col;\\n        int val;\\n        pair(int col,int val){\\n            this.col=col;\\n            this.val=val;\\n        }\\n    }\\n    \\n    Integer[][]  dp;\\n    \\n    public int minFallingPathSum(int[][] grid) {\\n        dp=new Integer[grid.length+1][grid[0].length+1];\\n        List<List<pair>> mins=new ArrayList<>();\\n         \\n        for(int i=0;i<grid.length;i++){\\n           \\n            int min1=(int)1e9,min2=(int)1e9,c1=0,c2=0;\\n            List<pair> arr=new ArrayList<>(); \\n            for(int j=0;j<grid[i].length;j++){\\n                if(grid[i][j]<=min1){\\n                    \\n                    min2=min1;\\n                    c2=c1;\\n                    min1=grid[i][j];\\n                    c1=j;\\n                }else if(grid[i][j]<min2){\\n                    min2=grid[i][j];\\n                    c2=j;\\n                }\\n            }\\n            arr.add(new pair(c1,min1));\\n            arr.add(new pair(c2,min2));\\n            mins.add(arr);\\n        }\\n        \\n        int min=(int)1e9;\\n       for(int i=0;i<2;i++){\\n           int col=mins.get(0).get(i).col;\\n           min=Math.min(min,solve(mins,1,col)+mins.get(0).get(i).val);\\n       }\\n        return min;\\n    }\\n    \\n    public int solve(List<List<pair>> mins,int r,int c){\\n        if(r==mins.size())return 0;\\n        \\n        if(dp[r][c]!=null)return dp[r][c];\\n        \\n        int min=(int)1e9;        \\n            for(int i=0;i<2;i++){\\n               int col= mins.get(r).get(i).col;\\n                if(c!=col){\\n                   min=Math.min(min, solve(mins,r+1,col)+mins.get(r).get(i).val);\\n                }\\n            }\\n        return  dp[r][c]= min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354549,
                "title": "java-dynamic-programming-t-c-o-n-2-s-c-o-n-2",
                "content": "\\n\\n\\t// Bottom Up\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumBU2(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, min1 = 0, min2 = 0;\\n\\t\\tint[][] dp = new int[n + 1][n];\\n\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tint nmin1 = Integer.MAX_VALUE, nmin2 = Integer.MAX_VALUE;\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tdp[i][j] = (min1 != dp[i + 1][j]) ? min1 + matrix[i][j] : min2 + matrix[i][j];\\n\\t\\t\\t\\tif (dp[i][j] < nmin1) {\\n\\t\\t\\t\\t\\tnmin2 = nmin1;\\n\\t\\t\\t\\t\\tnmin1 = dp[i][j];\\n\\t\\t\\t\\t} else if (dp[i][j] < nmin2)\\n\\t\\t\\t\\t\\tnmin2 = dp[i][j];\\n\\t\\t\\t}\\n\\t\\t\\tmin1 = nmin1;\\n\\t\\t\\tmin2 = nmin2;\\n\\t\\t}\\n\\n\\t\\treturn min1;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\n\\t// Bottom Up\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumBU2(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, min1 = 0, min2 = 0;\\n\\t\\tint[][] dp = new int[n + 1][n];\\n\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tint nmin1 = Integer.MAX_VALUE, nmin2 = Integer.MAX_VALUE;\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tdp[i][j] = (min1 != dp[i + 1][j]) ? min1 + matrix[i][j] : min2 + matrix[i][j];\\n\\t\\t\\t\\tif (dp[i][j] < nmin1) {\\n\\t\\t\\t\\t\\tnmin2 = nmin1;\\n\\t\\t\\t\\t\\tnmin1 = dp[i][j];\\n\\t\\t\\t\\t} else if (dp[i][j] < nmin2)\\n\\t\\t\\t\\t\\tnmin2 = dp[i][j];\\n\\t\\t\\t}\\n\\t\\t\\tmin1 = nmin1;\\n\\t\\t\\tmin2 = nmin2;\\n\\t\\t}\\n\\n\\t\\treturn min1;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1354547,
                "title": "java-dynamic-programming-t-c-o-n-3-s-c-o-n-2",
                "content": "\\n\\t// Bottom Up\\n\\t// O(n^3) O(n^2)\\n\\tpublic int minFallingPathSumBU1(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, ans = Integer.MAX_VALUE;\\n\\t\\tint[][] dp = new int[n + 1][n];\\n\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor (int k = 0; k < n; k++) {\\n\\t\\t\\t\\t\\tif (j == k)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][k]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[i][j] = min + matrix[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tans = Math.min(ans, dp[0][i]);\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// Bottom Up\\n\\t// O(n^3) O(n^2)\\n\\tpublic int minFallingPathSumBU1(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, ans = Integer.MAX_VALUE;\\n\\t\\tint[][] dp = new int[n + 1][n];\\n\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor (int k = 0; k < n; k++) {\\n\\t\\t\\t\\t\\tif (j == k)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][k]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[i][j] = min + matrix[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tans = Math.min(ans, dp[0][i]);\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1217988,
                "title": "python-simple-dp",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        nrows, ncols = len(arr), len(arr[0])\\n        res = [[0] * ncols for _ in range(nrows)]\\n\\n        res[0] = arr[0]\\n\\n        for r in range(1, nrows):\\n            for c in range(ncols):\\n                tmp_min = []\\n                for i in range(nrows):\\n                    if i != c:\\n                        tmp_min.append(res[r - 1][i] + arr[r][c])\\n                res[r][c] = min(tmp_min)\\n\\n        return min(res[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        nrows, ncols = len(arr), len(arr[0])\\n        res = [[0] * ncols for _ in range(nrows)]\\n\\n        res[0] = arr[0]\\n\\n        for r in range(1, nrows):\\n            for c in range(ncols):\\n                tmp_min = []\\n                for i in range(nrows):\\n                    if i != c:\\n                        tmp_min.append(res[r - 1][i] + arr[r][c])\\n                res[r][c] = min(tmp_min)\\n\\n        return min(res[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195449,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    \\n    int dp[201][201] = {0};\\n    int D[201][201];\\n    int helperMinFallingPathSum(int r, vector<vector<int>>& arr, int prevcol)\\n    {\\n        if(r == arr.size())\\n            return 0;\\n        \\n        if(D[r][prevcol] != -1)\\n            return D[r][prevcol];\\n        \\n        int temp=INT_MAX;\\n        \\n        for(int j=0; j<arr.size(); j++)\\n        {\\n            if((r==0) or (r>0 and dp[r-1][j] == 0))\\n            {\\n                dp[r][j] = 1;\\n                temp = min(temp, arr[r][j] +  helperMinFallingPathSum(r+1, arr, j));\\n                dp[r][j] = 0;\\n            }\\n        }\\n        \\n        D[r][prevcol] = temp;\\n        return temp;\\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        \\n        memset(D, -1, sizeof(D));\\n        return helperMinFallingPathSum(0, arr, 0);\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = INT_MAX;\\n    \\n    int dp[201][201] = {0};\\n    int D[201][201];\\n    int helperMinFallingPathSum(int r, vector<vector<int>>& arr, int prevcol)\\n    {\\n        if(r == arr.size())\\n            return 0;\\n        \\n        if(D[r][prevcol] != -1)\\n            return D[r][prevcol];\\n        \\n        int temp=INT_MAX;\\n        \\n        for(int j=0; j<arr.size(); j++)\\n        {\\n            if((r==0) or (r>0 and dp[r-1][j] == 0))\\n            {\\n                dp[r][j] = 1;\\n                temp = min(temp, arr[r][j] +  helperMinFallingPathSum(r+1, arr, j));\\n                dp[r][j] = 0;\\n            }\\n        }\\n        \\n        D[r][prevcol] = temp;\\n        return temp;\\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        \\n        memset(D, -1, sizeof(D));\\n        return helperMinFallingPathSum(0, arr, 0);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500818,
                "title": "javascript-easy-to-understand-with-explanation-and-variable-names",
                "content": "Lets say we start with this array of arrays:\\n```\\n[\\n  [1,2,3],\\n  [4,5,6],\\n  [7,8,9],\\n]\\n```\\nWe  need to figure out what it takes to get the minimum number on each row. Lets take it one step at a time, starting with the top row. If we are only given the top row, we can immediately see the minimum number is 1. However, once we expand this out to two rows, that\\'s where the work starts. Let\\'s pretend we have this array now:\\n```\\n[\\n\\t[1,2,3],\\n\\t[4,5,6],\\n]\\n```\\nSo, let\\'s walk through the minimum amount of steps for each cell. \\n- For the middle left cell, we see that we can combine 4 with either 2 or 3. \\n- For the middle center cell, we see that we can combine 5 with either 1 or 3.\\n- For the middle right cell, we see that we can combine 6 with either 1 or 2.\\n```\\n[\\n\\t[1,2,3],\\n\\t[(6 or 7),(6 or 8),(7 or 8)],\\n]\\n```\\nBecause we want to minimize the numbers in each row, we simply take the min of the given possibilities which further reduces the array to this:\\n```\\n[\\n\\t[1,2,3],\\n\\t[6,6,7],\\n]\\n```\\nNow, we can add an arbitrary amount of rows. All we need to do, is look at the previous row (which we\\'ve already calculated), and add the smallest number possible! This is what we have with 3 rows (with the middle calculated):\\n```\\n[\\n\\t[1,2,3],\\n\\t[6,6,7],\\n\\t[7,8,9],\\n]\\n```\\nOne last time, let\\'s walk through the minimum amount of steps for each cell. \\n- For the bottom left cell, we see that we can combine 7 with either 6 or 7. \\n- For the bottom center cell, we see that we can combine 8 with either 6 or 7.\\n- For the bottom right cell, we see that we can combine 9 with either 6 or 6.\\n\\nAfter finding the minimums, the final array looks like this:\\n```\\n[\\n\\t[1,2,3],\\n\\t[6,6,7],\\n\\t[13,14,15],\\n]\\n```\\nAt last, we return the minimum value in the last row! \\n```javascript\\nvar minFallingPathSum = function(arr) {    \\n    for (var i = 1; i < arr.length; i++) {\\n        for (var j = 0; j < arr[0].length; j++) {\\n            const previousRow = arr[i-1]\\n            const minNum = previousRow.reduce((acc,num,i) => {\\n                if (i === j) return acc;\\n                return Math.min(acc, num)\\n            }, Infinity)\\n            arr[i][j] += minNum\\n        }\\n    }\\n    return Math.min(...arr[arr.length -1])\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[\\n  [1,2,3],\\n  [4,5,6],\\n  [7,8,9],\\n]\\n```\n```\\n[\\n\\t[1,2,3],\\n\\t[4,5,6],\\n]\\n```\n```\\n[\\n\\t[1,2,3],\\n\\t[(6 or 7),(6 or 8),(7 or 8)],\\n]\\n```\n```\\n[\\n\\t[1,2,3],\\n\\t[6,6,7],\\n]\\n```\n```\\n[\\n\\t[1,2,3],\\n\\t[6,6,7],\\n\\t[7,8,9],\\n]\\n```\n```\\n[\\n\\t[1,2,3],\\n\\t[6,6,7],\\n\\t[13,14,15],\\n]\\n```\n```javascript\\nvar minFallingPathSum = function(arr) {    \\n    for (var i = 1; i < arr.length; i++) {\\n        for (var j = 0; j < arr[0].length; j++) {\\n            const previousRow = arr[i-1]\\n            const minNum = previousRow.reduce((acc,num,i) => {\\n                if (i === j) return acc;\\n                return Math.min(acc, num)\\n            }, Infinity)\\n            arr[i][j] += minNum\\n        }\\n    }\\n    return Math.min(...arr[arr.length -1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 474078,
                "title": "java-o-n-n-dp-3ms-100-space-with-explaination",
                "content": "1 go through the grid need n* n (arr.length == arr[0].length)\\n2 `dp[i][j] `= `arr[i][j]` + min(`dp[i-1]`) , we can get row min when go through grid, and also need to keep 2 min value from pre row to ensure \"no two elements chosen in adjacent rows are in the same column\"\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        if(arr == null)\\n            return 0;\\n        int r = arr.length, c = arr[0].length;\\n        int[][] dp = new int[r][c];\\n        int min = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;\\n        //init\\n        for(int i = 0; i < c; i++){\\n            dp[0][i] = arr[0][i];\\n            if(dp[0][i] <= min) {\\n                min2 = min;\\n                min = dp[0][i];\\n            }else {\\n                min2 = Math.min(dp[0][i], min2);\\n            }\\n        }\\n        for(int i = 1; i < r; i++) {\\n            int cur_min = Integer.MAX_VALUE;\\n            int cur_min2 = Integer.MAX_VALUE;\\n            for(int j = 0; j < c; j++) {\\n                dp[i][j] = dp[i-1][j] == min ? min2 + arr[i][j] : min + arr[i][j];\\n                if(dp[i][j] <= cur_min) {\\n                    cur_min2 = cur_min;\\n                    cur_min = dp[i][j];\\n                }else {\\n                    cur_min2 = Math.min(dp[i][j], cur_min2);\\n                }\\n            }\\n            min = cur_min;\\n            min2 = cur_min2;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        if(arr == null)\\n            return 0;\\n        int r = arr.length, c = arr[0].length;\\n        int[][] dp = new int[r][c];\\n        int min = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;\\n        //init\\n        for(int i = 0; i < c; i++){\\n            dp[0][i] = arr[0][i];\\n            if(dp[0][i] <= min) {\\n                min2 = min;\\n                min = dp[0][i];\\n            }else {\\n                min2 = Math.min(dp[0][i], min2);\\n            }\\n        }\\n        for(int i = 1; i < r; i++) {\\n            int cur_min = Integer.MAX_VALUE;\\n            int cur_min2 = Integer.MAX_VALUE;\\n            for(int j = 0; j < c; j++) {\\n                dp[i][j] = dp[i-1][j] == min ? min2 + arr[i][j] : min + arr[i][j];\\n                if(dp[i][j] <= cur_min) {\\n                    cur_min2 = cur_min;\\n                    cur_min = dp[i][j];\\n                }else {\\n                    cur_min2 = Math.min(dp[i][j], cur_min2);\\n                }\\n            }\\n            min = cur_min;\\n            min2 = cur_min2;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452292,
                "title": "dp-javascript",
                "content": "1. for each row we are looking for two mins\\n2.  for the each row\\'s element we are adding the minimum numbe unless the element above is the minimum, in this case add the second minimum\\n3.  the last row min number is the answer\\n```\\nvar minFallingPathSum = function(arr) {\\n    var n = arr.length;\\n    for (i=1;i<n;i++) {\\n        let [m1,m2] = [...arr[i-1]].sort((a,b) => a - b).slice(0, 2);\\n        for(j=0;j<n;j++) {\\n            arr[i][j] += arr[i-1][j] !== m1 ? m1 : m2\\n        }\\n    }\\n    return Math.min(...arr[n-1])\\n};\\n",
                "solutionTags": [],
                "code": "1. for each row we are looking for two mins\\n2.  for the each row\\'s element we are adding the minimum numbe unless the element above is the minimum, in this case add the second minimum\\n3.  the last row min number is the answer\\n```\\nvar minFallingPathSum = function(arr) {\\n    var n = arr.length;\\n    for (i=1;i<n;i++) {\\n        let [m1,m2] = [...arr[i-1]].sort((a,b) => a - b).slice(0, 2);\\n        for(j=0;j<n;j++) {\\n            arr[i][j] += arr[i-1][j] !== m1 ? m1 : m2\\n        }\\n    }\\n    return Math.min(...arr[n-1])\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3462634,
                "title": "dpp-c-solution-tabulation-with-space-optimisation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int mini=INT_MAX;\\n        int n = mat.size();\\n        vector<int> prev(n,0);\\n        for(int i=0;i<n;i++){\\n            vector<int> curr(n,0);\\n            for(int j=0;j<n;j++){\\n                if(i==0){\\n                    curr[j]=mat[i][j];\\n                    continue;\\n                }\\n                int abx = INT_MAX;\\n                for(int k=0;k<n;k++){\\n                    if(j==k) continue;\\n                    int st = mat[i][j]+prev[k];\\n                    abx=min(abx,st);\\n                }\\n                curr[j]=abx;\\n            }\\n            prev=curr;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            mini=min(mini,prev[i]);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int mini=INT_MAX;\\n        int n = mat.size();\\n        vector<int> prev(n,0);\\n        for(int i=0;i<n;i++){\\n            vector<int> curr(n,0);\\n            for(int j=0;j<n;j++){\\n                if(i==0){\\n                    curr[j]=mat[i][j];\\n                    continue;\\n                }\\n                int abx = INT_MAX;\\n                for(int k=0;k<n;k++){\\n                    if(j==k) continue;\\n                    int st = mat[i][j]+prev[k];\\n                    abx=min(abx,st);\\n                }\\n                curr[j]=abx;\\n            }\\n            prev=curr;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            mini=min(mini,prev[i]);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461833,
                "title": "c-ez-solution-recursive-3d-dp-2d-dp-explained",
                "content": "The first approach will be the recursive approach which will result in TLE \\u274C\\nThis involves keeping a track of the previous column so that we do not choose it during the current state.\\n```\\nclass Solution {\\npublic:    \\n    int calc(vector<vector<int>>& triangle,int i,int j,int prev){\\n        int a=1e9,b=1e9;       \\n        if(i==triangle.size()-1&&prev!=j) \\n            return triangle[i][j];      \\n      \\n        for(int k=0;k<triangle[0].size();k++)\\n            if(prev!=j)\\n                a=min(a,triangle[i][j]+calc(triangle,i+1,k,j));        \\n        return a;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<matrix[0].size();i++)       \\n            ans=min(ans,calc(matrix,0,i,-1));\\n        return ans;\\n    }\\n};\\n```\\n\\n3D DP [Memoization] TLE \\u274C\\n```\\nclass Solution {\\npublic:\\n     int dp[101][101][101];\\n    int calc(vector<vector<int>>& triangle,int i,int j,int prev){\\n        int a=1e9,b=1e9;       \\n        if(i==triangle.size()-1&&prev!=j) \\n            return triangle[i][j];\\n        if(prev!=-1&&dp[i][j][prev]!=-1) return dp[i][j][prev];\\n      \\n        for(int k=0;k<triangle[0].size();k++)\\n            if(prev!=j)\\n                a=min(a,triangle[i][j]+calc(triangle,i+1,k,j));\\n        if(prev!=-1)\\n            dp[i][j][prev]=a;\\n        return a;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<matrix[0].size();i++){\\n            memset(dp,-1,sizeof(dp));\\n            ans=min(ans,calc(matrix,0,i,-1));\\n        }      \\n        return ans;\\n    }\\n};\\n```\\n\\nConverting to 2D DP [Accepted] \\u2705\\nWe do the same thing as the previous solution except that instead of using a seperate variable to keep track of the previous column we can just call the recursive function on those column which are valid. In this case any column not adjacent to the current column in the next row is deemed to be valid. So we use `abs(j-k)` to determine the validity of the next state.\\n```\\nclass Solution {\\npublic:\\n     int dp[201][201];\\n    int calc(vector<vector<int>>& triangle,int i,int j){\\n        int a=1e9;       \\n        if(i==triangle.size()-1) \\n            return triangle[i][j];\\n        if(dp[i][j]!=-1) \\n            return dp[i][j];\\n      \\n        for(int k=0;k<triangle[0].size();k++)\\n            if(abs(j-k)>0)\\n                a=min(a,triangle[i][j]+calc(triangle,i+1,k));        \\n           return dp[i][j]=a;       \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans=INT_MAX;\\n         memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<matrix[0].size();i++){           \\n            ans=min(ans,calc(matrix,0,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int calc(vector<vector<int>>& triangle,int i,int j,int prev){\\n        int a=1e9,b=1e9;       \\n        if(i==triangle.size()-1&&prev!=j) \\n            return triangle[i][j];      \\n      \\n        for(int k=0;k<triangle[0].size();k++)\\n            if(prev!=j)\\n                a=min(a,triangle[i][j]+calc(triangle,i+1,k,j));        \\n        return a;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<matrix[0].size();i++)       \\n            ans=min(ans,calc(matrix,0,i,-1));\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     int dp[101][101][101];\\n    int calc(vector<vector<int>>& triangle,int i,int j,int prev){\\n        int a=1e9,b=1e9;       \\n        if(i==triangle.size()-1&&prev!=j) \\n            return triangle[i][j];\\n        if(prev!=-1&&dp[i][j][prev]!=-1) return dp[i][j][prev];\\n      \\n        for(int k=0;k<triangle[0].size();k++)\\n            if(prev!=j)\\n                a=min(a,triangle[i][j]+calc(triangle,i+1,k,j));\\n        if(prev!=-1)\\n            dp[i][j][prev]=a;\\n        return a;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<matrix[0].size();i++){\\n            memset(dp,-1,sizeof(dp));\\n            ans=min(ans,calc(matrix,0,i,-1));\\n        }      \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     int dp[201][201];\\n    int calc(vector<vector<int>>& triangle,int i,int j){\\n        int a=1e9;       \\n        if(i==triangle.size()-1) \\n            return triangle[i][j];\\n        if(dp[i][j]!=-1) \\n            return dp[i][j];\\n      \\n        for(int k=0;k<triangle[0].size();k++)\\n            if(abs(j-k)>0)\\n                a=min(a,triangle[i][j]+calc(triangle,i+1,k));        \\n           return dp[i][j]=a;       \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans=INT_MAX;\\n         memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<matrix[0].size();i++){           \\n            ans=min(ans,calc(matrix,0,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306333,
                "title": "java-100-working-solution-easy",
                "content": "```class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n= grid.length;\\n        if(n==1){\\n            return grid[0][0];\\n        }\\n        int[][] dp= new int[201][201];\\n        for(int i=0; i<201; i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        \\n        int ans= (int)(1e9);\\n        for(int i=0; i<n; i++){\\n            ans= Math.min(ans, solve(grid,0,i,n-1,dp));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int solve(int[][] grid, int i, int j, int n, int[][] dp){\\n        if(j<0 || j>n){\\n            return 0;\\n        }\\n        \\n        if(i==n){\\n            return grid[i][j];\\n        }\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        int ans= (int)(1e9);\\n        for(int k=0; k<=n; k++){\\n            if(k==j){\\n                continue;\\n            }\\n            ans= Math.min(ans, grid[i][j]+solve(grid,i+1,k,n,dp));\\n        }\\n        \\n        return dp[i][j]= ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n= grid.length;\\n        if(n==1){\\n            return grid[0][0];\\n        }\\n        int[][] dp= new int[201][201];\\n        for(int i=0; i<201; i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        \\n        int ans= (int)(1e9);\\n        for(int i=0; i<n; i++){\\n            ans= Math.min(ans, solve(grid,0,i,n-1,dp));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int solve(int[][] grid, int i, int j, int n, int[][] dp){\\n        if(j<0 || j>n){\\n            return 0;\\n        }\\n        \\n        if(i==n){\\n            return grid[i][j];\\n        }\\n        \\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        int ans= (int)(1e9);\\n        for(int k=0; k<=n; k++){\\n            if(k==j){\\n                continue;\\n            }\\n            ans= Math.min(ans, grid[i][j]+solve(grid,i+1,k,n,dp));\\n        }\\n        \\n        return dp[i][j]= ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3198643,
                "title": "dp-optimization-store-2-minimums-from-previous-row",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        dp = [[float(\\'inf\\')] * n for _ in range(n)]\\n        m = sm = (float(\\'inf\\'), -1)\\n        for i in range(n):\\n            dp[0][i] = grid[0][i]\\n            m, sm, temp = sorted([m, sm, (dp[0][i], i)])\\n        for i in range(1, n):\\n            for j in range(n):\\n                if m[1] != j:\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][m[1]] + grid[i][j])\\n                if sm[1] != j:\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][sm[1]] + grid[i][j])\\n            m = sm = (float(\\'inf\\'), -1)\\n            for j in range(n):\\n                m, sm, temp = sorted([m, sm, (dp[i][j], j)])\\n        return m[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        dp = [[float(\\'inf\\')] * n for _ in range(n)]\\n        m = sm = (float(\\'inf\\'), -1)\\n        for i in range(n):\\n            dp[0][i] = grid[0][i]\\n            m, sm, temp = sorted([m, sm, (dp[0][i], i)])\\n        for i in range(1, n):\\n            for j in range(n):\\n                if m[1] != j:\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][m[1]] + grid[i][j])\\n                if sm[1] != j:\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][sm[1]] + grid[i][j])\\n            m = sm = (float(\\'inf\\'), -1)\\n            for j in range(n):\\n                m, sm, temp = sorted([m, sm, (dp[i][j], j)])\\n        return m[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147443,
                "title": "c-easy-understanding-space-optimized",
                "content": "In this problem, we are asked to give the maximum path sum without selecting the adjacent rows with same column values i.e. we can select any other previous element other than that.\\nUsing priority queue(min heap) for the last row will give us the minimum sum up to last row and also we can optimise the space as we not using n x n matrix/grid as dp. At last we just need to return the min of all which we can get form the top of the priority queue itself.\\n\\nCode implementation:\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        for(int j=0; j<n; j++)pq.push({grid[0][j],j});\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>curr;\\n            \\n            for(int j=0; j<n; j++)\\n            {\\n                if(pq.top().second==j)\\n                {\\n                    auto it=pq.top();\\n                    pq.pop();\\n                    curr.push({pq.top().first+grid[i][j],j});\\n                    pq.push(it);\\n                }\\n                else\\n                {\\n                   curr.push({pq.top().first+grid[i][j],j}); \\n                }\\n            }\\n            \\n            pq=curr;\\n        }\\n        \\n       return pq.top().first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        \\n        for(int j=0; j<n; j++)pq.push({grid[0][j],j});\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>curr;\\n            \\n            for(int j=0; j<n; j++)\\n            {\\n                if(pq.top().second==j)\\n                {\\n                    auto it=pq.top();\\n                    pq.pop();\\n                    curr.push({pq.top().first+grid[i][j],j});\\n                    pq.push(it);\\n                }\\n                else\\n                {\\n                   curr.push({pq.top().first+grid[i][j],j}); \\n                }\\n            }\\n            \\n            pq=curr;\\n        }\\n        \\n       return pq.top().first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908982,
                "title": "swift-268-ms",
                "content": "```\\nprivate class MinPair {\\n    var min1 = Int.max\\n    var min1Pos = -1\\n    var min2 = Int.max\\n\\n    func update(pos: Int, val: Int) {\\n        if min1 > val {\\n            min2 = min1\\n            min1 = val\\n            min1Pos = pos\\n        } else {\\n            min2 = min(min2, val)\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    func minFallingPathSum(_ grid: [[Int]]) -> Int {\\n        let n = grid.count\\n        if n == 1 { return grid[0][0] }\\n        var prevMin = MinPair()\\n        for (i, k) in grid[n - 1].enumerated() {\\n            prevMin.update(pos: i, val: k)\\n        }\\n        for i in 0 ..< n - 1 {\\n            let newMin = MinPair()\\n            for (i, k) in grid[n - i - 2].enumerated() {\\n                newMin.update(pos: i, val: k + (i == prevMin.min1Pos ? prevMin.min2 : prevMin.min1))\\n            }\\n            prevMin = newMin\\n        }\\n        return prevMin.min1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nprivate class MinPair {\\n    var min1 = Int.max\\n    var min1Pos = -1\\n    var min2 = Int.max\\n\\n    func update(pos: Int, val: Int) {\\n        if min1 > val {\\n            min2 = min1\\n            min1 = val\\n            min1Pos = pos\\n        } else {\\n            min2 = min(min2, val)\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    func minFallingPathSum(_ grid: [[Int]]) -> Int {\\n        let n = grid.count\\n        if n == 1 { return grid[0][0] }\\n        var prevMin = MinPair()\\n        for (i, k) in grid[n - 1].enumerated() {\\n            prevMin.update(pos: i, val: k)\\n        }\\n        for i in 0 ..< n - 1 {\\n            let newMin = MinPair()\\n            for (i, k) in grid[n - i - 2].enumerated() {\\n                newMin.update(pos: i, val: k + (i == prevMin.min1Pos ? prevMin.min2 : prevMin.min1))\\n            }\\n            prevMin = newMin\\n        }\\n        return prevMin.min1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908778,
                "title": "python-easy-dp-beats-98-27",
                "content": "![image](https://assets.leetcode.com/users/images/d14685e6-bad0-491e-90e2-837a66a44c5e_1670962237.6519592.png)\\n\\n```\\ndef minFallingPathSum(self, g: List[List[int]]) -> int:\\n        l=len(g)\\n        for i in range(1,l):\\n            temp =  sorted(g[i-1])\\n            for j in range(l):\\n                if g[i-1][j] == temp[0]:\\n                    g[i][j] += temp[1]\\n                else:\\n                    g[i][j] += temp[0]\\n        return min(g[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef minFallingPathSum(self, g: List[List[int]]) -> int:\\n        l=len(g)\\n        for i in range(1,l):\\n            temp =  sorted(g[i-1])\\n            for j in range(l):\\n                if g[i-1][j] == temp[0]:\\n                    g[i][j] += temp[1]\\n                else:\\n                    g[i][j] += temp[0]\\n        return min(g[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2908774,
                "title": "python3-clean-solution-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        N = len(grid)\\n        DP = grid[0]\\n\\n        for i in range(1, N):\\n            indx1 = DP.index(min(DP))\\n            indx2 = DP.index(min(DP[:indx1] + DP[indx1+1:]))\\n            for j in range(N):\\n                if j != indx1:\\n                    grid[i][j] += DP[indx1]\\n                else:\\n                    grid[i][j] += DP[indx2]\\n            DP = grid[i]\\n\\n        return min(DP)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        N = len(grid)\\n        DP = grid[0]\\n\\n        for i in range(1, N):\\n            indx1 = DP.index(min(DP))\\n            indx2 = DP.index(min(DP[:indx1] + DP[indx1+1:]))\\n            for j in range(N):\\n                if j != indx1:\\n                    grid[i][j] += DP[indx1]\\n                else:\\n                    grid[i][j] += DP[indx2]\\n            DP = grid[i]\\n\\n        return min(DP)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906900,
                "title": "bottom-s-up-rec-with-memoization-o-n-2-time-and-o-1-space-complexity",
                "content": "# Complexity\\n- Time complexity: $$O(n^3)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Recursion with Memoisation (TLE 11/15)\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n = len(matrix)\\n        memo = {}\\n\\n        def fall(i, j):\\n            if i == n - 1:\\n                return matrix[i][j]\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            minSum = float(\"inf\")\\n            for k in range(n):\\n                if k != j:\\n                    minSum = min(fall(i + 1, k), minSum)\\n            minSum += matrix[i][j]\\n            memo[(i, j)] = minSum\\n            return minSum \\n\\n        minSum = float(\"inf\")\\n        for i in range(n):\\n            minSum = min(fall(0, i), minSum)\\n        return minSum\\n```\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Bottoms-Up DP Approach\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def twoMins(arr: list[int]) -> tuple[int]:\\n            min1, min2 = float(\"inf\"), float(\"inf\")\\n            for i in range(len(arr)):\\n                if arr[i] < min1:\\n                    min2 = min1\\n                    min1 = arr[i]\\n                elif arr[i] <= min2:\\n                    min2 = arr[i]\\n            return (min1, min2)\\n\\n        n = len(matrix)\\n        for i in range(n - 2, -1, -1):\\n            min1, min2 = twoMins(matrix[i + 1])\\n            for j in range(n):\\n                if matrix[i + 1][j] == min1:\\n                    matrix[i][j] += min2\\n                else:\\n                    matrix[i][j] += min1\\n        return min(matrix[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n = len(matrix)\\n        memo = {}\\n\\n        def fall(i, j):\\n            if i == n - 1:\\n                return matrix[i][j]\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n            minSum = float(\"inf\")\\n            for k in range(n):\\n                if k != j:\\n                    minSum = min(fall(i + 1, k), minSum)\\n            minSum += matrix[i][j]\\n            memo[(i, j)] = minSum\\n            return minSum \\n\\n        minSum = float(\"inf\")\\n        for i in range(n):\\n            minSum = min(fall(0, i), minSum)\\n        return minSum\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def twoMins(arr: list[int]) -> tuple[int]:\\n            min1, min2 = float(\"inf\"), float(\"inf\")\\n            for i in range(len(arr)):\\n                if arr[i] < min1:\\n                    min2 = min1\\n                    min1 = arr[i]\\n                elif arr[i] <= min2:\\n                    min2 = arr[i]\\n            return (min1, min2)\\n\\n        n = len(matrix)\\n        for i in range(n - 2, -1, -1):\\n            min1, min2 = twoMins(matrix[i + 1])\\n            for j in range(n):\\n                if matrix[i + 1][j] == min1:\\n                    matrix[i][j] += min2\\n                else:\\n                    matrix[i][j] += min1\\n        return min(matrix[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889834,
                "title": "easy-c-o-n-n-n-log-n-priority-queue",
                "content": "The heap (priority queue) stores the data of the previous row. Each value is stored along with its column\\'s index which helps in finding out whether the minimum value (from the previous row) is accessible or not. Feel free to comment if you have any doubts :) \\n\\n![image](https://assets.leetcode.com/users/images/19d24866-ea84-4cb1-bbba-20455102e201_1670481820.9855487.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "The heap (priority queue) stores the data of the previous row. Each value is stored along with its column\\'s index which helps in finding out whether the minimum value (from the previous row) is accessible or not. Feel free to comment if you have any doubts :) \\n\\n![image](https://assets.leetcode.com/users/images/19d24866-ea84-4cb1-bbba-20455102e201_1670481820.9855487.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2804142,
                "title": "from-recursive-to-memorization-to-tabulation",
                "content": "# Intuition\\nat any particular cell grid(i,j) we need the minm of all cells of f(i+1,{0 to j-1}) and all minm of cells of f(i+1,{j+1 to n-1})\\n\\n\\n# I have shared both recursive/memo code and alternate tabulation code on same code space . Have a look into the soln and do let me know if any confusion . Please do upvote if you find the soln helpful \\uD83D\\uDE80\\n\\n# Code\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    Integer memo[][];\\n\\n    public int minFallingPathSum(int[][] grid) {   \\n         m=grid.length;\\n         n=grid[0].length;\\n        //<<---------------for Recursive Soln--------------->>\\n         memo=new Integer[m][n];//memo [][]\\n\\n         int recRes=Integer.MAX_VALUE;\\n\\n         //iterate over the 1st rows col \\n        //  for(int col=0;col<n;col++)\\n        //            recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));\\n\\n      //<<---------------for Recursive Soln--------------->>\\n        //  return recRes;\\n\\n          //<<---------------for Tabulation  Soln--------------->>\\n         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);\\n         return Tabulation_Ans;\\n    }\\n\\n    public int minFallingPathSum_Rec(int[][] grid,int i,int j){\\n            \\n            if(j<0 || j>=n || i<0 || i>=m)\\n                           return Integer.MAX_VALUE;\\n\\n            if(i==m-1)\\n                     return grid[i][j];\\n\\n            if(memo[i][j]!=null)\\n                        return memo[i][j];\\n\\n            int lowerLeftSum=Integer.MAX_VALUE;\\n            int lowerRightSum=Integer.MAX_VALUE;\\n\\n            for(int col=0;col<=j-1;col++)\\n                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));\\n\\n            for(int col=j+1;col<=n-1;col++)\\n                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));\\n\\n          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\\n\\n     }//rec--->>memorization\\n\\n\\n\\n\\n     int minFallingPathSum_Tabulation(int[][] grid){\\n          int dp[][]=new int[m][n];\\n\\n          for(int i=m-1;i>=0;i--){\\n              for(int j=n-1;j>=0;j--){\\n                    \\n                    if(i==m-1)\\n                     {\\n                         dp[i][j]=grid[i][j];\\n                         continue;\\n                     }//base case : if the last row \\n                \\n                int lowerLeftSum=Integer.MAX_VALUE;\\n                int lowerRightSum=Integer.MAX_VALUE;\\n                //for lower left sum calculation \\n                for(int col=0;col<=j-1;col++){\\n                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));\\n                }\\n                \\n                //for lower right sum calculation \\n                for(int col=j+1;col<=n-1;col++){\\n                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));\\n                \\n                }\\n                \\n                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\\n              \\n              }//inner \\n          }//ouer \\n           \\n\\n          int Ans=Integer.MAX_VALUE;\\n\\n          for(int COL=0;COL<n;COL++){\\n              Ans=Math.min(Ans,dp[0][COL]);\\n          }\\n          \\n          return Ans;\\n     \\n     }//tabulation soln:derived from the recursive soln \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    Integer memo[][];\\n\\n    public int minFallingPathSum(int[][] grid) {   \\n         m=grid.length;\\n         n=grid[0].length;\\n        //<<---------------for Recursive Soln--------------->>\\n         memo=new Integer[m][n];//memo [][]\\n\\n         int recRes=Integer.MAX_VALUE;\\n\\n         //iterate over the 1st rows col \\n        //  for(int col=0;col<n;col++)\\n        //            recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));\\n\\n      //<<---------------for Recursive Soln--------------->>\\n        //  return recRes;\\n\\n          //<<---------------for Tabulation  Soln--------------->>\\n         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);\\n         return Tabulation_Ans;\\n    }\\n\\n    public int minFallingPathSum_Rec(int[][] grid,int i,int j){\\n            \\n            if(j<0 || j>=n || i<0 || i>=m)\\n                           return Integer.MAX_VALUE;\\n\\n            if(i==m-1)\\n                     return grid[i][j];\\n\\n            if(memo[i][j]!=null)\\n                        return memo[i][j];\\n\\n            int lowerLeftSum=Integer.MAX_VALUE;\\n            int lowerRightSum=Integer.MAX_VALUE;\\n\\n            for(int col=0;col<=j-1;col++)\\n                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));\\n\\n            for(int col=j+1;col<=n-1;col++)\\n                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));\\n\\n          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\\n\\n     }//rec--->>memorization\\n\\n\\n\\n\\n     int minFallingPathSum_Tabulation(int[][] grid){\\n          int dp[][]=new int[m][n];\\n\\n          for(int i=m-1;i>=0;i--){\\n              for(int j=n-1;j>=0;j--){\\n                    \\n                    if(i==m-1)\\n                     {\\n                         dp[i][j]=grid[i][j];\\n                         continue;\\n                     }//base case : if the last row \\n                \\n                int lowerLeftSum=Integer.MAX_VALUE;\\n                int lowerRightSum=Integer.MAX_VALUE;\\n                //for lower left sum calculation \\n                for(int col=0;col<=j-1;col++){\\n                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));\\n                }\\n                \\n                //for lower right sum calculation \\n                for(int col=j+1;col<=n-1;col++){\\n                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));\\n                \\n                }\\n                \\n                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\\n              \\n              }//inner \\n          }//ouer \\n           \\n\\n          int Ans=Integer.MAX_VALUE;\\n\\n          for(int COL=0;COL<n;COL++){\\n              Ans=Math.min(Ans,dp[0][COL]);\\n          }\\n          \\n          return Ans;\\n     \\n     }//tabulation soln:derived from the recursive soln \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737868,
                "title": "c-dp-easiest-approach",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minFallingPathSum(vector<vector<int>>& grid) {\\n\\t\\t\\tint ans=INT_MAX,l=grid.size();\\n\\t\\t\\tfor(int i=1;i<l;i++){\\n\\t\\t\\t\\tans=INT_MAX;\\n\\t\\t\\t\\tfor(int j=0;j<l;j++){\\n\\t\\t\\t\\t\\tint maxx=INT_MAX;\\n\\t\\t\\t\\t\\tfor(int k=0;k<l;k++){\\n\\t\\t\\t\\t\\t\\tif(k!=j){\\n\\t\\t\\t\\t\\t\\t   maxx=min(maxx,grid[i][j]+grid[i-1][k]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgrid[i][j]=maxx;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<l;i++){\\n\\t\\t\\t\\tans=min(ans,grid[l-1][i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minFallingPathSum(vector<vector<int>>& grid) {\\n\\t\\t\\tint ans=INT_MAX,l=grid.size();\\n\\t\\t\\tfor(int i=1;i<l;i++){\\n\\t\\t\\t\\tans=INT_MAX;\\n\\t\\t\\t\\tfor(int j=0;j<l;j++){\\n\\t\\t\\t\\t\\tint maxx=INT_MAX;\\n\\t\\t\\t\\t\\tfor(int k=0;k<l;k++){\\n\\t\\t\\t\\t\\t\\tif(k!=j){\\n\\t\\t\\t\\t\\t\\t   maxx=min(maxx,grid[i][j]+grid[i-1][k]);\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2681286,
                "title": "c-easy-tabulation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        vector<vector<int>> dp(grid.size(),vector<int> (grid[0].size(),-1));\\n        for(int i=0;i<grid.size();i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n        \\n        int mini=INT_MAX;\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=0;j<grid.size();j++){\\n                int ans=INT_MAX;\\n                for(int k=0;k<grid.size();k++){\\n                    if(j==k) continue;\\n                    ans=min(ans,grid[i][j]+dp[i-1][k]);\\n                }\\n                dp[i][j]=ans;\\n            }\\n        }\\n        for(int i=0;i<grid[0].size();i++){\\n            mini=min(mini,dp[grid.size()-1][i]);\\n        }\\n        return mini;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        vector<vector<int>> dp(grid.size(),vector<int> (grid[0].size(),-1));\\n        for(int i=0;i<grid.size();i++){\\n            dp[0][i]=grid[0][i];\\n        }\\n        \\n        int mini=INT_MAX;\\n        for(int i=1;i<grid.size();i++){\\n            for(int j=0;j<grid.size();j++){\\n                int ans=INT_MAX;\\n                for(int k=0;k<grid.size();k++){\\n                    if(j==k) continue;\\n                    ans=min(ans,grid[i][j]+dp[i-1][k]);\\n                }\\n                dp[i][j]=ans;\\n            }\\n        }\\n        for(int i=0;i<grid[0].size();i++){\\n            mini=min(mini,dp[grid.size()-1][i]);\\n        }\\n        return mini;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647847,
                "title": "c-easy-dp-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        memset(dp, -1, sizeof(dp));\\n        return find(grid, 0, 0);\\n    }\\n    \\n    int find(vector<vector<int>>& grid, int i, int j) {\\n        if(i>=grid.size()) {\\n            return 0;\\n        }\\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        int mn = INT_MAX;\\n        for(int k=0; k<grid.size(); k++) {\\n            if(k==j && !(i==0 && j == 0)) {\\n                continue;\\n            }\\n            mn = min(mn, grid[i][k]+find(grid,i+1, k));\\n        }\\n        return dp[i][j]=mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        memset(dp, -1, sizeof(dp));\\n        return find(grid, 0, 0);\\n    }\\n    \\n    int find(vector<vector<int>>& grid, int i, int j) {\\n        if(i>=grid.size()) {\\n            return 0;\\n        }\\n        if(dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        int mn = INT_MAX;\\n        for(int k=0; k<grid.size(); k++) {\\n            if(k==j && !(i==0 && j == 0)) {\\n                continue;\\n            }\\n            mn = min(mn, grid[i][k]+find(grid,i+1, k));\\n        }\\n        return dp[i][j]=mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587340,
                "title": "java-easy-solution-simple-understanding-striver-approach-followed",
                "content": "class Solution {\\n  public int min(int i,int last,int m,int grid[][],int dp[][])\\n  {\\n    if(i<0)\\n      return 0;\\n    \\n    if(dp[i][last]!=-1)\\n      return dp[i][last];\\n     if(i == 0)\\n     {\\n       int min=Integer.MAX_VALUE;\\n       for(int j=0; j < m ; j++)\\n       {\\n         if(j!=last)\\n         {\\n           min=Math.min(min,grid[0][j]);\\n         }\\n       }\\n       return dp[i][last]=min;\\n     }\\n    int min=Integer.MAX_VALUE;\\n    for(int j=0;j<m;j++)\\n    {\\n        if(j!=last)\\n        {\\n          int acti=grid[i][j]+min(i-1,j,m,grid,dp);\\n          min=Math.min(min,acti);\\n        }\\n      }\\n    \\n    return dp[i][last]=min;\\n    }\\n    public int minFallingPathSum(int[][] grid) \\n    {\\n      int n=grid.length;\\n      int m=grid[0].length;\\n     int dp[][]=new int[n][m+1];\\n      for(int row[]:dp)\\n        Arrays.fill(row,-1);\\n       return min(n - 1, m,m, grid,dp);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n  public int min(int i,int last,int m,int grid[][],int dp[][])\\n  {\\n    if(i<0)\\n      return 0;\\n    \\n    if(dp[i][last]!=-1)\\n      return dp[i][last];\\n     if(i == 0)\\n     {\\n       int min=Integer.MAX_VALUE;\\n       for(int j=0; j < m ; j++)\\n       {\\n         if(j!=last)\\n         {\\n           min=Math.min(min,grid[0][j]);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2463777,
                "title": "easy-c-recursion-memoization-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int solve(vector<vector<int>>& grid, int i, int j, int n, int m){\\n        if(i==n-1)\\n            return grid[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int tempAns=INT_MAX;\\n        for(int k=0;k<m;k++){\\n            if(k!=j)\\n                tempAns=min(tempAns,grid[i][j]+solve(grid,i+1,k,n,m));\\n        }\\n        \\n        return dp[i][j]=tempAns;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<m;i++)\\n            ans=min(ans,solve(grid,0,i,n,m));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int solve(vector<vector<int>>& grid, int i, int j, int n, int m){\\n        if(i==n-1)\\n            return grid[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int tempAns=INT_MAX;\\n        for(int k=0;k<m;k++){\\n            if(k!=j)\\n                tempAns=min(tempAns,grid[i][j]+solve(grid,i+1,k,n,m));\\n        }\\n        \\n        return dp[i][j]=tempAns;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<m;i++)\\n            ans=min(ans,solve(grid,0,i,n,m));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457917,
                "title": "c-in-place-dp-paint-house-ii-easy-to-understand-elegant-o-n-space",
                "content": "Before we go ahead, this method doesn\\'t need to define a separate dp matrix, and is based heavily on the usage of min_element() command of c++.\\nFor every row, if we have the min falling path sums of the matrix up till the previous row at every index, we need to find a way to update the min falling path sum at each of the index in our current row. \\nNote that, you are always going to add the minimum falling path sum of the last row, unless the minimum value is in the same column as your index. \\nIn that case, you will go for the second smallest min falling sum of the above row. So, if we have the 2 smallest min falling path sum of each row, we can always find the min Falling Path Sum of the matrix. \\n\\nFor ease of explanation and to keep it beginner-friendly I have coded the approach in the original matrix itself, however you can do the same by just keeping 1 vector that represents the current row and the two smallest min falling path sums of the previous row. This will give us a *O(N)* space DP method. \\n\\nHere\\'s the easier version of the code, let me know if you have any doubts :)\\n\\n```class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        //find the two minimum elements of each row -> always one of two will be used\\n        int n =  grid.size(), m = grid[0].size();\\n      \\n        \\n        int min1, min2;\\n        for(int i = 1; i < n; i++)\\n        {\\n            auto it = min_element(grid[i-1].begin(), grid[i-1].end());\\n            int temp = *it;\\n            min1 = it - grid[i-1].begin();\\n             *it = INT_MAX;\\n            auto it2 = min_element(grid[i-1].begin(), grid[i-1].end());\\n            min2 = it2 - grid[i-1].begin();\\n            *it = temp;\\n            \\n            for(int j = 0; j < m; j++)\\n            {\\n                if(j == min1)\\n                {\\n                    grid[i][j] += grid[i-1][min2];\\n                }\\n                else{\\n                    grid[i][j] += grid[i-1][min1];\\n                }\\n            }\\n        }\\n        \\n        return *min_element(grid[n-1].begin(), grid[n-1].end());\\n    }\\n};\\n```\\n\\nEdit 1:\\nI found another question which can be done the same way - [Paint House II](https://leetcode.com/problems/paint-house-ii/)\\nI have used the same logic in the solution, but O(n) space (the one I described above) \\n\\n```\\nclass Solution {\\npublic:\\n    int minCostII(vector<vector<int>>& costs) {\\n        //basically min path falling sum\\n        \\n        int n = costs.size(), k = costs[0].size();\\n        if(n == 1)\\n        {\\n            return *min_element(costs[0].begin(), costs[0].end());\\n        }\\n        \\n        vector<int> next(n, 0);\\n        int m1 = min_element(costs[0].begin(), costs[0].end()) - costs[0].begin();\\n        int temp = costs[0][m1];\\n        costs[0][m1] = INT_MAX;\\n        int m2 = min_element(costs[0].begin(), costs[0].end()) - costs[0].begin();\\n        costs[0][m1]= temp;\\n        \\n        int M1 = costs[0][m1], M2 = costs[0][m2];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            next = costs[i];\\n            for(int j = 0; j < k; j++)\\n            {\\n                if(j == m1) next[j] += M2;\\n                else next[j] += M1;\\n            }\\n            \\n            m1 = min_element(next.begin(), next.end()) - next.begin();\\n            temp = next[m1];\\n            next[m1] = INT_MAX;\\n            m2 = min_element(next.begin(), next.end()) - next.begin();\\n            M1 = temp;\\n            M2 = next[m2];\\n        }\\n        \\n        return M1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        //find the two minimum elements of each row -> always one of two will be used\\n        int n =  grid.size(), m = grid[0].size();\\n      \\n        \\n        int min1, min2;\\n        for(int i = 1; i < n; i++)\\n        {\\n            auto it = min_element(grid[i-1].begin(), grid[i-1].end());\\n            int temp = *it;\\n            min1 = it - grid[i-1].begin();\\n             *it = INT_MAX;\\n            auto it2 = min_element(grid[i-1].begin(), grid[i-1].end());\\n            min2 = it2 - grid[i-1].begin();\\n            *it = temp;\\n            \\n            for(int j = 0; j < m; j++)\\n            {\\n                if(j == min1)\\n                {\\n                    grid[i][j] += grid[i-1][min2];\\n                }\\n                else{\\n                    grid[i][j] += grid[i-1][min1];\\n                }\\n            }\\n        }\\n        \\n        return *min_element(grid[n-1].begin(), grid[n-1].end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minCostII(vector<vector<int>>& costs) {\\n        //basically min path falling sum\\n        \\n        int n = costs.size(), k = costs[0].size();\\n        if(n == 1)\\n        {\\n            return *min_element(costs[0].begin(), costs[0].end());\\n        }\\n        \\n        vector<int> next(n, 0);\\n        int m1 = min_element(costs[0].begin(), costs[0].end()) - costs[0].begin();\\n        int temp = costs[0][m1];\\n        costs[0][m1] = INT_MAX;\\n        int m2 = min_element(costs[0].begin(), costs[0].end()) - costs[0].begin();\\n        costs[0][m1]= temp;\\n        \\n        int M1 = costs[0][m1], M2 = costs[0][m2];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            next = costs[i];\\n            for(int j = 0; j < k; j++)\\n            {\\n                if(j == m1) next[j] += M2;\\n                else next[j] += M1;\\n            }\\n            \\n            m1 = min_element(next.begin(), next.end()) - next.begin();\\n            temp = next[m1];\\n            next[m1] = INT_MAX;\\n            m2 = min_element(next.begin(), next.end()) - next.begin();\\n            M1 = temp;\\n            M2 = next[m2];\\n        }\\n        \\n        return M1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457048,
                "title": "java-clean-code-with-explanation",
                "content": "**The concept is similar to minimum path sum problem , but the only difference is there we have to start from the (0,0) position , But here we can start from any column from the 1st row and find the minimum path sum and  we have to take care that the column numbers of the elements are different .**\\n\\n**Please Upvote if you like my approach**\\n\\n```\\nclass Solution {\\n    int n,m;\\n    public int minFallingPathSum(int[][] grid) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        \\n        int dp[][] = new int[n][m];\\n        for(int r[]:dp)\\n            Arrays.fill(r,-1);\\n        \\n        int ans  = Integer.MAX_VALUE;\\n        \\n        for(int col = 0 ; col<m ; col++)\\n            ans = Math.min(ans , f(n-1 , col , dp , grid));\\n        return ans;\\n    }\\n    private int f(int i , int j , int[][] dp , int[][] mat)\\n    {\\n        if(j<0 || j>=m)return Integer.MAX_VALUE; // dont return 0 because it will be counted as min value so return a huge value so that it is overlooked\\n\\t\\t\\n        if(i ==0)return mat[0][j];\\n        if(dp[i][j] != -1)return dp[i][j];\\n        \\n        int ans  = Integer.MAX_VALUE;\\n        \\n         for(int col = 0 ; col<m ; col++)\\n         {\\n             if(col != j)\\n             {\\n                 ans = Math.min(mat[i][j] +  f(i-1 , col , dp ,mat), ans);\\n             }\\n         }\\n        return dp[i][j] = ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int n,m;\\n    public int minFallingPathSum(int[][] grid) {\\n        n = grid.length;\\n        m = grid[0].length;\\n        \\n        int dp[][] = new int[n][m];\\n        for(int r[]:dp)\\n            Arrays.fill(r,-1);\\n        \\n        int ans  = Integer.MAX_VALUE;\\n        \\n        for(int col = 0 ; col<m ; col++)\\n            ans = Math.min(ans , f(n-1 , col , dp , grid));\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2408050,
                "title": "concise-java-solution-dp",
                "content": "class Solution {\\n\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dp = new int[n][n];\\n        Arrays.stream(dp).forEach(a -> Arrays.fill(a, -1));\\n        \\n        for(int j=0; j<n; j++)dp[0][j] = grid[0][j];\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                int min = Integer.MAX_VALUE;\\n                for(int k=0; k<n; k++){\\n                    if(k != j){\\n                        min = Math.min(dp[i-1][k],min);\\n                    }\\n                }\\n                dp[i][j] = grid[i][j]+min;\\n            }\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int j=0; j<n; j++){\\n            res = Math.min(dp[n-1][j],res);\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dp = new int[n][n];\\n        Arrays.stream(dp).forEach(a -> Arrays.fill(a, -1));\\n        \\n        for(int j=0; j<n; j++)dp[0][j] = grid[0][j];\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                int min = Integer.MAX_VALUE;\\n                for(int k=0; k<n; k++){\\n                    if(k != j){\\n                        min = Math.min(dp[i-1][k],min);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2394239,
                "title": "java-solution-memoization-tabulation-space-optimization-dp",
                "content": "``` java []\\n\\n// Memoization, Top down Approach \\n// TC -> O(n*n*n)\\n// SC -> O(n*n) + Recursion stack Space\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length, min = Integer.MAX_VALUE;\\n        Integer[][] dp = new Integer[n][n];\\n        for(int j=0;j<n;j++){\\n            min= Math.min(min,solve(grid,n-1,j,dp));\\n        }\\n        return min;\\n    }\\n\\n\\n    private int solve(int[][] grid,int i,int j,Integer[][] dp){\\n        if(i==0)\\n           return grid[i][j];\\n        if(dp[i][j]!=null)\\n           return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for(int k=0;k<grid.length;k++){\\n            if(k==j)\\n               continue;\\n            min = Math.min(min,solve(grid,i-1,k,dp));\\n        }\\n        return dp[i][j] = grid[i][j] + min;\\n    }\\n}\\n```\\n\\n``` java []\\n// Tabulation, Bottom-up Approach\\n// TC -> O(n*n*n)\\n// SC -> O(n*n)\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dp = new int[n][n];\\n        \\n        for(int j=0;j<n;j++){\\n            dp[0][j] = grid[0][j]; \\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int min = Integer.MAX_VALUE;\\n                for(int k=0;k<n;k++){\\n                    if(k!=j)\\n                       min = Math.min(min,dp[i-1][k]);\\n                }\\n                dp[i][j] = min + grid[i][j];\\n            }\\n        }\\n        \\n        int sum=Integer.MAX_VALUE;\\n        for(int j=0;j<n;j++){\\n            sum= Math.min(sum,dp[n-1][j]);\\n        }\\n        return sum;\\n    }\\n}\\n```\\n``` java []\\n// Tabulation, Bottom-up Approach\\n// Space Optimization\\n\\n// TC -> O(n*n*n)\\n// SC -> O(1)\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int min = Integer.MAX_VALUE;\\n                for(int k=0;k<n;k++){\\n                    if(k!=j)\\n                       min = Math.min(min,grid[i-1][k]);\\n                }\\n                grid[i][j]+= min;\\n            }\\n        }\\n        \\n        int sum=Integer.MAX_VALUE;\\n        for(int j=0;j<n;j++){\\n            sum= Math.min(sum,grid[n-1][j]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` java []\\n\\n// Memoization, Top down Approach \\n// TC -> O(n*n*n)\\n// SC -> O(n*n) + Recursion stack Space\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length, min = Integer.MAX_VALUE;\\n        Integer[][] dp = new Integer[n][n];\\n        for(int j=0;j<n;j++){\\n            min= Math.min(min,solve(grid,n-1,j,dp));\\n        }\\n        return min;\\n    }\\n\\n\\n    private int solve(int[][] grid,int i,int j,Integer[][] dp){\\n        if(i==0)\\n           return grid[i][j];\\n        if(dp[i][j]!=null)\\n           return dp[i][j];\\n        int min = Integer.MAX_VALUE;\\n        for(int k=0;k<grid.length;k++){\\n            if(k==j)\\n               continue;\\n            min = Math.min(min,solve(grid,i-1,k,dp));\\n        }\\n        return dp[i][j] = grid[i][j] + min;\\n    }\\n}\\n```\n``` java []\\n// Tabulation, Bottom-up Approach\\n// TC -> O(n*n*n)\\n// SC -> O(n*n)\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dp = new int[n][n];\\n        \\n        for(int j=0;j<n;j++){\\n            dp[0][j] = grid[0][j]; \\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int min = Integer.MAX_VALUE;\\n                for(int k=0;k<n;k++){\\n                    if(k!=j)\\n                       min = Math.min(min,dp[i-1][k]);\\n                }\\n                dp[i][j] = min + grid[i][j];\\n            }\\n        }\\n        \\n        int sum=Integer.MAX_VALUE;\\n        for(int j=0;j<n;j++){\\n            sum= Math.min(sum,dp[n-1][j]);\\n        }\\n        return sum;\\n    }\\n}\\n```\n``` java []\\n// Tabulation, Bottom-up Approach\\n// Space Optimization\\n\\n// TC -> O(n*n*n)\\n// SC -> O(1)\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int min = Integer.MAX_VALUE;\\n                for(int k=0;k<n;k++){\\n                    if(k!=j)\\n                       min = Math.min(min,grid[i-1][k]);\\n                }\\n                grid[i][j]+= min;\\n            }\\n        }\\n        \\n        int sum=Integer.MAX_VALUE;\\n        for(int j=0;j<n;j++){\\n            sum= Math.min(sum,grid[n-1][j]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375740,
                "title": "easy-solution-o-1-space-dp-c",
                "content": "```\\nint minFallingPathSum(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n               int m2=INT_MAX;\\n                for(int k=0;k<m;k++)\\n                {\\n                    if(k!=j)\\n                    {\\n                        m2=min(m2,g[i-1][k]);\\n                    }\\n                }\\n                 g[i][j]+=m2;\\n            }\\n        }\\n        \\n        int mi=INT_MAX;\\n        for(int j=0;j<m;j++)\\n        {\\n            mi=min(mi,g[n-1][j]);\\n        }\\n        return mi;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint minFallingPathSum(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int m=g[0].size();\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n               int m2=INT_MAX;\\n                for(int k=0;k<m;k++)\\n                {\\n                    if(k!=j)\\n                    {\\n                        m2=min(m2,g[i-1][k]);\\n                    }\\n                }\\n                 g[i][j]+=m2;\\n            }\\n        }\\n        \\n        int mi=INT_MAX;\\n        for(int j=0;j<m;j++)\\n        {\\n            mi=min(mi,g[n-1][j]);\\n        }\\n        return mi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2354549,
                "title": "c-dp-solution",
                "content": "This problem is very similar to the previous part of this problem \\ni.e. [Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum/)\\nThe only difference is that, in that problem we had to choose between the upper, upper left or upper right adjacent cell in the matrix for the current element.\\nBut here we don\\'t have such an option. \\n\\n***Here we have to iterate through all the possiblities in the entire upper row for each element except for the element which is directly above the current element in the matrix, and then we have to find the minimum.***\\n\\nYou should first go and watch my solution for the previous question for a better understanding of this problem.\\n\\n[Minimum Falling Path Sum(My Solution)](https://leetcode.com/problems/minimum-falling-path-sum/discuss/2354399/c-recursive-memoized-code-dp)\\n\\nNow we can see how this problem is very much similar to the previous problem and with just a few tweaks in some lines of code we can solve this problem as well.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int i, int j, vector<vector<int>> &matrix, vector<vector<int>> &dp){\\n        \\n\\t\\t//to handle edge cases if the j index is less than 0 or greater than size of the array.\\n        if(j<0 or j>=matrix[0].size()) return 1e8;\\n\\t\\t\\n\\t\\t//base case\\n        if(i==0) return dp[0][j] = matrix[0][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int ans = INT_MAX;\\n         \\n\\t\\t //Here we have to iterate through all the possiblities in the entire upper row for each\\n\\t\\t //element except for the element which is directly above the current element in the\\n\\t\\t //matrix, and then we have to find the minimum.\\n        for(int k=0;k<matrix[0].size();k++){\\n            if(k==j) continue;\\n            ans = min(ans, matrix[i][j] + f(i-1, k, matrix, dp));\\n        }\\n        \\n        return dp[i][j] = ans;\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int mini = INT_MAX;\\n        int n = grid.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        \\n        for(int j=0;j<n;j++){\\n            \\n            mini = min(mini, f(n-1, j, grid, dp));\\n            \\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int f(int i, int j, vector<vector<int>> &matrix, vector<vector<int>> &dp){\\n        \\n\\t\\t//to handle edge cases if the j index is less than 0 or greater than size of the array.\\n        if(j<0 or j>=matrix[0].size()) return 1e8;\\n\\t\\t\\n\\t\\t//base case\\n        if(i==0) return dp[0][j] = matrix[0][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int ans = INT_MAX;\\n         \\n\\t\\t //Here we have to iterate through all the possiblities in the entire upper row for each\\n\\t\\t //element except for the element which is directly above the current element in the\\n\\t\\t //matrix, and then we have to find the minimum.\\n        for(int k=0;k<matrix[0].size();k++){\\n            if(k==j) continue;\\n            ans = min(ans, matrix[i][j] + f(i-1, k, matrix, dp));\\n        }\\n        \\n        return dp[i][j] = ans;\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int mini = INT_MAX;\\n        int n = grid.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        \\n        for(int j=0;j<n;j++){\\n            \\n            mini = min(mini, f(n-1, j, grid, dp));\\n            \\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336542,
                "title": "c-memoization-intutive",
                "content": "\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int n,vector<vector<int>>& matrix,vector<vector<int>> &dp)\\n    {\\n        if(i==n-1)\\n            return matrix[i][j];\\n        \\n         if(dp[i][j]!=-1)\\n             return dp[i][j];\\n        \\n        int temp=1e8;\\n        for(int k=0;k<n;k++)\\n        {\\n            if(k!=j)    //skip the same columns (adjcent cols)\\n            temp=min(temp,matrix[i][j]+solve(i+1,k,n,matrix,dp));\\n        }\\n        return dp[i][j]=temp;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int res=1e9;\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        for(int j=0;j<n;j++)\\n        {\\n            res=min(res,solve(0,j,n,matrix,dp));\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(int i,int j,int n,vector<vector<int>>& matrix,vector<vector<int>> &dp)\\n    {\\n        if(i==n-1)\\n            return matrix[i][j];\\n        \\n         if(dp[i][j]!=-1)\\n             return dp[i][j];\\n        \\n        int temp=1e8;\\n        for(int k=0;k<n;k++)\\n        {\\n            if(k!=j)    //skip the same columns (adjcent cols)\\n            temp=min(temp,matrix[i][j]+solve(i+1,k,n,matrix,dp));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2332474,
                "title": "c-simple-solution-using-dp-in-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>>dp(n, vector<int>(m));\\n        \\n        dp[0]=grid[0];\\n        \\n        int firstMini=INT_MAX, secondMini=INT_MAX;\\n        int firstIdx, secondIdx;\\n\\n        for(int i=1;i<n;i++){\\n            firstMini=INT_MAX, secondMini=INT_MAX;\\n            for(int j=0;j<m;j++){\\n                if(grid[i-1][j]<=firstMini){\\n                    secondMini=firstMini;\\n                    firstMini=grid[i-1][j];\\n                    firstIdx=j;\\n                }\\n                else if(grid[i-1][j]>firstMini && grid[i-1][j]<secondMini){\\n                    secondMini=grid[i-1][j];\\n                    secondIdx=j;\\n                }\\n            }\\n            for(int j=0;j<m;j++){\\n                if(j!=firstIdx)\\n                    grid[i][j]=grid[i][j]+firstMini;\\n                else\\n                   grid[i][j]=grid[i][j]+secondMini; \\n            }\\n        }\\n       \\n        return *min_element(grid[n-1].begin(), grid[n-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<vector<int>>dp(n, vector<int>(m));\\n        \\n        dp[0]=grid[0];\\n        \\n        int firstMini=INT_MAX, secondMini=INT_MAX;\\n        int firstIdx, secondIdx;\\n\\n        for(int i=1;i<n;i++){\\n            firstMini=INT_MAX, secondMini=INT_MAX;\\n            for(int j=0;j<m;j++){\\n                if(grid[i-1][j]<=firstMini){\\n                    secondMini=firstMini;\\n                    firstMini=grid[i-1][j];\\n                    firstIdx=j;\\n                }\\n                else if(grid[i-1][j]>firstMini && grid[i-1][j]<secondMini){\\n                    secondMini=grid[i-1][j];\\n                    secondIdx=j;\\n                }\\n            }\\n            for(int j=0;j<m;j++){\\n                if(j!=firstIdx)\\n                    grid[i][j]=grid[i][j]+firstMini;\\n                else\\n                   grid[i][j]=grid[i][j]+secondMini; \\n            }\\n        }\\n       \\n        return *min_element(grid[n-1].begin(), grid[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323489,
                "title": "python-prefix-suffix-approach-68-faster-73-less-space-notes",
                "content": "```\\n/*\\n    approach:\\n    Create a prefix and suffix array\\n    prefix array arr[i] position stores the minimum value in interval [0, i-1]\\n    suffix array arr[i] position stores the minimum value in interval [i+1, len(grid[0])]\\n    obtain the final array, where arr[i] = min(prefix[i], suffix[i])\\n    add elements of final array with next row of grid.\\n    Repeat the same process until we reach the last row of grid\\n    Return the minimum value of the final row obtained\\n*/\\n```\\n```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if m == 1 and n == 1:\\n            return grid[0][0]\\n        min_arr = [0 for _ in range(n)]\\n        for i in range(m):\\n            prefix = [float(\\'inf\\') for _ in range(n)]\\n            suffix = [float(\\'inf\\') for _ in range(n)]\\n            current_row = [elem1+elem2 for elem1, elem2 in zip(grid[i], min_arr)]\\n            for i in range(1, n):\\n                prefix[i] = min(prefix[i-1], current_row[i-1])\\n            for i in range(n-2, -1, -1):\\n                suffix[i] = min(suffix[i+1], current_row[i+1])\\n            min_arr = [min(pre, suff) for pre, suff in zip(prefix, suffix)]\\n        return min(min_arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Suffix Array"
                ],
                "code": "```\\n/*\\n    approach:\\n    Create a prefix and suffix array\\n    prefix array arr[i] position stores the minimum value in interval [0, i-1]\\n    suffix array arr[i] position stores the minimum value in interval [i+1, len(grid[0])]\\n    obtain the final array, where arr[i] = min(prefix[i], suffix[i])\\n    add elements of final array with next row of grid.\\n    Repeat the same process until we reach the last row of grid\\n    Return the minimum value of the final row obtained\\n*/\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if m == 1 and n == 1:\\n            return grid[0][0]\\n        min_arr = [0 for _ in range(n)]\\n        for i in range(m):\\n            prefix = [float(\\'inf\\') for _ in range(n)]\\n            suffix = [float(\\'inf\\') for _ in range(n)]\\n            current_row = [elem1+elem2 for elem1, elem2 in zip(grid[i], min_arr)]\\n            for i in range(1, n):\\n                prefix[i] = min(prefix[i-1], current_row[i-1])\\n            for i in range(n-2, -1, -1):\\n                suffix[i] = min(suffix[i+1], current_row[i+1])\\n            min_arr = [min(pre, suff) for pre, suff in zip(prefix, suffix)]\\n        return min(min_arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306676,
                "title": "heap-and-dynamic-programming",
                "content": "- **Ignore the heap implementation**\\n- **You can use the built-in library**\\n- **What to do**\\n1. Use min-heap to maintain the dp value in every row\\n2. Pop 2 smallest element from heap (log(n))\\n3. Row every [row, col] in the dp array, try to find the smallest value from the 1D array at index row - 1\\n4. But what? We need to exclude the value that is in the same column as the current col\\n5. How to? Check if the smallest value is equal to dp[row-1][col], if not -> pick it, otherwise, pick the second smallest value.\\n6. In the last row of 2D array, just poll smallest element from heap, it\\'s the result.\\n\\n```\\nfunc minFallingPathSum(matrix [][]int) int {\\n    n := len(matrix)\\n    dp := make([][]int, n)\\n    \\n    for i := 0; i < n; i++ {\\n        dp[i] = make([]int, n)\\n    }\\n    \\n    var heap minHeap\\n    \\n    for row := 0; row < n; row++ {\\n        if row == 0 {\\n            for col := 0; col < len(matrix[0]); col++ {\\n                dp[0][col] = matrix[0][col]\\n                heap.add(matrix[0][col])\\n            }\\n            \\n            continue\\n        }\\n        \\n        firstMin := heap.poll()\\n        secondMin := heap.poll()\\n        \\n        for col := 0; col < len(matrix[0]); col++ {\\n            if dp[row-1][col] == firstMin {\\n                dp[row][col] += secondMin + matrix[row][col]\\n            }  else {\\n                dp[row][col] += firstMin + matrix[row][col]\\n            }\\n        }\\n        \\n        heap.reset()\\n        \\n        for col := 0; col < len(matrix[0]); col++ {\\n            heap.add(dp[row][col])\\n        }\\n        \\n        if row == n-1 {\\n            return heap.poll()\\n        }\\n    }\\n    \\n    return heap.poll()\\n}\\n\\ntype minHeap []int\\n\\nfunc (m *minHeap) add(val int) {\\n    (*m) = append(*m, val)\\n    m.heapUp(len(*m)-1)\\n}\\n\\nfunc (m *minHeap) poll() int {\\n    item := (*m)[0]\\n    \\n    (*m)[0] = (*m)[len(*m)-1]\\n    *m = (*m)[:len(*m)-1]\\n    m.heapDown(0, len(*m)-1)\\n    \\n    return item\\n}\\n\\nfunc (m *minHeap) heapUp(p int) {\\n    parent := (p-1)/2\\n    \\n    if parent >= 0 && (*m)[p] < (*m)[parent] {\\n        (*m)[parent], (*m)[p] = (*m)[p], (*m)[parent]\\n        m.heapUp(parent)\\n    } \\n}\\n\\nfunc (m *minHeap) heapDown(p, limit int) {\\n    l, r := 2*p+1, 2*p+2\\n    smaller := p\\n    \\n    if l <= limit && (*m)[l] < (*m)[smaller] {\\n        smaller = l\\n    }\\n    \\n    if r <= limit && (*m)[r] < (*m)[smaller] {\\n        smaller = r\\n    }\\n    \\n    if smaller != p {\\n        (*m)[smaller], (*m)[p] = (*m)[p], (*m)[smaller]\\n        m.heapDown(smaller, limit)\\n    }\\n}\\n\\nfunc (m *minHeap) reset() {\\n    *m = (*m)[:0]\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Memoization",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunc minFallingPathSum(matrix [][]int) int {\\n    n := len(matrix)\\n    dp := make([][]int, n)\\n    \\n    for i := 0; i < n; i++ {\\n        dp[i] = make([]int, n)\\n    }\\n    \\n    var heap minHeap\\n    \\n    for row := 0; row < n; row++ {\\n        if row == 0 {\\n            for col := 0; col < len(matrix[0]); col++ {\\n                dp[0][col] = matrix[0][col]\\n                heap.add(matrix[0][col])\\n            }\\n            \\n            continue\\n        }\\n        \\n        firstMin := heap.poll()\\n        secondMin := heap.poll()\\n        \\n        for col := 0; col < len(matrix[0]); col++ {\\n            if dp[row-1][col] == firstMin {\\n                dp[row][col] += secondMin + matrix[row][col]\\n            }  else {\\n                dp[row][col] += firstMin + matrix[row][col]\\n            }\\n        }\\n        \\n        heap.reset()\\n        \\n        for col := 0; col < len(matrix[0]); col++ {\\n            heap.add(dp[row][col])\\n        }\\n        \\n        if row == n-1 {\\n            return heap.poll()\\n        }\\n    }\\n    \\n    return heap.poll()\\n}\\n\\ntype minHeap []int\\n\\nfunc (m *minHeap) add(val int) {\\n    (*m) = append(*m, val)\\n    m.heapUp(len(*m)-1)\\n}\\n\\nfunc (m *minHeap) poll() int {\\n    item := (*m)[0]\\n    \\n    (*m)[0] = (*m)[len(*m)-1]\\n    *m = (*m)[:len(*m)-1]\\n    m.heapDown(0, len(*m)-1)\\n    \\n    return item\\n}\\n\\nfunc (m *minHeap) heapUp(p int) {\\n    parent := (p-1)/2\\n    \\n    if parent >= 0 && (*m)[p] < (*m)[parent] {\\n        (*m)[parent], (*m)[p] = (*m)[p], (*m)[parent]\\n        m.heapUp(parent)\\n    } \\n}\\n\\nfunc (m *minHeap) heapDown(p, limit int) {\\n    l, r := 2*p+1, 2*p+2\\n    smaller := p\\n    \\n    if l <= limit && (*m)[l] < (*m)[smaller] {\\n        smaller = l\\n    }\\n    \\n    if r <= limit && (*m)[r] < (*m)[smaller] {\\n        smaller = r\\n    }\\n    \\n    if smaller != p {\\n        (*m)[smaller], (*m)[p] = (*m)[p], (*m)[smaller]\\n        m.heapDown(smaller, limit)\\n    }\\n}\\n\\nfunc (m *minHeap) reset() {\\n    *m = (*m)[:0]\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2303069,
                "title": "c-dp-recursion",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n***1. Recursion*** (TLE for 10 testcases)\\n```\\nclass Solution {\\npublic:\\n    int recur(int r, int i, vector<vector<int>>& matrix){\\n        if(r==matrix.size()-1 && i<matrix[0].size() && i>=0){\\n            return matrix[r][i];\\n        }\\n        if(i>=matrix[0].size() || i<0) return INT_MAX;\\n        \\n        int mini=INT_MAX;\\n        for(int k=0;k<matrix[0].size();k++){\\n            if(k!=i){\\n                mini=min(mini, recur(r+1, k, matrix));\\n            }\\n        }\\n        \\n        return matrix[r][i]+mini;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        \\n        int mini=INT_MAX;        \\n        for(int i=0;i<matrix[0].size();i++){\\n            mini=min(recur(0, i, matrix), mini);\\n        }\\n        return mini;\\n    }\\n};\\n```\\n\\n***2. Dynamic Programming***\\n```\\nclass Solution {\\npublic:\\n    int recur(int r, int i, vector<vector<int>>& matrix, vector<vector<int>>& dp){\\n        if(r==matrix.size()-1 && i<matrix[0].size() && i>=0){\\n            return matrix[r][i];\\n        }\\n        if(i>=matrix[0].size() || i<0) return INT_MAX;\\n        if(dp[r][i]!=INT_MAX)return dp[r][i];\\n        \\n        int mini=INT_MAX;\\n        for(int k=0;k<matrix[0].size();k++){\\n            if(k!=i){\\n                mini=min(mini, recur(r+1, k, matrix, dp));\\n            }\\n        }\\n        \\n        return dp[r][i] = matrix[r][i]+mini;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        vector<vector<int>> dp(rows, vector<int>(cols, INT_MAX));\\n        \\n        int mini=INT_MAX;        \\n        for(int i=0;i<matrix[0].size();i++){\\n            mini=min(recur(0, i, matrix, dp), mini);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int r, int i, vector<vector<int>>& matrix){\\n        if(r==matrix.size()-1 && i<matrix[0].size() && i>=0){\\n            return matrix[r][i];\\n        }\\n        if(i>=matrix[0].size() || i<0) return INT_MAX;\\n        \\n        int mini=INT_MAX;\\n        for(int k=0;k<matrix[0].size();k++){\\n            if(k!=i){\\n                mini=min(mini, recur(r+1, k, matrix));\\n            }\\n        }\\n        \\n        return matrix[r][i]+mini;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        \\n        int mini=INT_MAX;        \\n        for(int i=0;i<matrix[0].size();i++){\\n            mini=min(recur(0, i, matrix), mini);\\n        }\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int recur(int r, int i, vector<vector<int>>& matrix, vector<vector<int>>& dp){\\n        if(r==matrix.size()-1 && i<matrix[0].size() && i>=0){\\n            return matrix[r][i];\\n        }\\n        if(i>=matrix[0].size() || i<0) return INT_MAX;\\n        if(dp[r][i]!=INT_MAX)return dp[r][i];\\n        \\n        int mini=INT_MAX;\\n        for(int k=0;k<matrix[0].size();k++){\\n            if(k!=i){\\n                mini=min(mini, recur(r+1, k, matrix, dp));\\n            }\\n        }\\n        \\n        return dp[r][i] = matrix[r][i]+mini;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        vector<vector<int>> dp(rows, vector<int>(cols, INT_MAX));\\n        \\n        int mini=INT_MAX;        \\n        for(int i=0;i<matrix[0].size();i++){\\n            mini=min(recur(0, i, matrix, dp), mini);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280712,
                "title": "falling-path-sum-i-plus-priorityqueue",
                "content": "This question is a variant of Falling Path Sum I. The different is in this question, the choice of next row is not limited by adjacency, but expanded to the whole row apart from the block right below the current row. An intuitive algorithm is similar to Falling Path Sum I, but when we build the DP table, we need to look at every value other than the one below. In this algorithm, the complexity would be O(n^3), since to fill the table it is O(n^2), and for each block to go over the next row that is O(n), so overall it is O(n^3).\\n\\nAn obvious drawback of this algorithm is that for any given row, we are repeating looking at it in order to find the smallest value. It would be helpful if we could save on this process. Thus, I use a priority queue to store the dp values of the next row. When we fill the DP table, we find the smallest value from the PQ, and if the block right below the one we are looking has the same value as the smallest value, we continue to get the second smallest value from the PQ(might be the same as the first smallest we obtained but it works). This second smallest value is guaranteed to be viable, since there is only one block below the one we are looking at. When this operation is finished, put the obtained values back to the PQ to recover it. In this algorithm, the overall complexity is O(n(nlgn + nlgn)) = O(n^2 lgn). For each row we need to initialize the PQ by putting in the values from the last row which is O(nlgn), and for each block it takes O(lgn) to put either one or two elements back to the PQ. \\n\\nThe implementation is below:\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dp = new int[n][n];\\n        PriorityQueue<Integer> PQ = new PriorityQueue<>();\\n        for (int i = 0; i < n; i++) {\\n            dp[n - 1][i] = grid[n - 1][i];\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n\\t\\t    // For each new row, we clear the PQ, and add in the values from the next row.\\n            PQ.clear();\\n            for (int j = 0; j < n; j++) {\\n                PQ.add(dp[i + 1][j]);\\n            }\\n            for (int j = 0; j < n; j++) {\\n\\t\\t\\t    // Get the smallest from the PQ, which the min sum until the i + 1 row\\n                int smallest = PQ.poll();\\n\\t\\t\\t\\t// If the smallest value happens to be from the block below\\n                if (dp[i + 1][j] == smallest) {\\n\\t\\t\\t\\t    // We get the second smallest\\n                    int secondSmallest = PQ.poll();\\n                    dp[i][j] = grid[i][j] + secondSmallest;\\n\\t\\t\\t\\t\\t// Add these two elements back to recover PQ\\n                    PQ.add(smallest);\\n                    PQ.add(secondSmallest);\\n                } else {\\n\\t\\t\\t\\t    // The smallest we get is not the block below\\n                    dp[i][j] = grid[i][j] + smallest;\\n\\t\\t\\t\\t\\t// Add it back to recover\\n                    PQ.add(smallest);\\n                }\\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[0][i] < ans) ans = dp[0][i];\\n            System.out.println(Arrays.toString(dp[i]));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dp = new int[n][n];\\n        PriorityQueue<Integer> PQ = new PriorityQueue<>();\\n        for (int i = 0; i < n; i++) {\\n            dp[n - 1][i] = grid[n - 1][i];\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n\\t\\t    // For each new row, we clear the PQ, and add in the values from the next row.\\n            PQ.clear();\\n            for (int j = 0; j < n; j++) {\\n                PQ.add(dp[i + 1][j]);\\n            }\\n            for (int j = 0; j < n; j++) {\\n\\t\\t\\t    // Get the smallest from the PQ, which the min sum until the i + 1 row\\n                int smallest = PQ.poll();\\n\\t\\t\\t\\t// If the smallest value happens to be from the block below\\n                if (dp[i + 1][j] == smallest) {\\n\\t\\t\\t\\t    // We get the second smallest\\n                    int secondSmallest = PQ.poll();\\n                    dp[i][j] = grid[i][j] + secondSmallest;\\n\\t\\t\\t\\t\\t// Add these two elements back to recover PQ\\n                    PQ.add(smallest);\\n                    PQ.add(secondSmallest);\\n                } else {\\n\\t\\t\\t\\t    // The smallest we get is not the block below\\n                    dp[i][j] = grid[i][j] + smallest;\\n\\t\\t\\t\\t\\t// Add it back to recover\\n                    PQ.add(smallest);\\n                }\\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (dp[0][i] < ans) ans = dp[0][i];\\n            System.out.println(Arrays.toString(dp[i]));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249842,
                "title": "java-memoization-dp-solution",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n=grid.length;\\n        int[][] dp=new int[n][n];\\n        for(int[] row:dp) Arrays.fill(row,-1);\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n          ans=Math.min(ans, pathSum(n-1,i,grid,dp));\\n        }\\n        return ans;\\n    }\\n    \\n    static int pathSum(int i , int j , int[][] grid,int[][] dp){\\n        int n=grid.length;\\n        if(i<0||j>=n) return Integer.MAX_VALUE;\\n        \\n        if(i==0) return grid[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int mini = Integer.MAX_VALUE;\\n        for(int k = 0 ; k < n ; k++)\\n        {\\n            if(k != j)\\n            mini = Math.min(mini ,pathSum(i-1 , k , grid, dp));\\n        }\\n        return dp[i][j]= grid[i][j]+mini;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n=grid.length;\\n        int[][] dp=new int[n][n];\\n        for(int[] row:dp) Arrays.fill(row,-1);\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n          ans=Math.min(ans, pathSum(n-1,i,grid,dp));\\n        }\\n        return ans;\\n    }\\n    \\n    static int pathSum(int i , int j , int[][] grid,int[][] dp){\\n        int n=grid.length;\\n        if(i<0||j>=n) return Integer.MAX_VALUE;\\n        \\n        if(i==0) return grid[i][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int mini = Integer.MAX_VALUE;\\n        for(int k = 0 ; k < n ; k++)\\n        {\\n            if(k != j)\\n            mini = Math.min(mini ,pathSum(i-1 , k , grid, dp));\\n        }\\n        return dp[i][j]= grid[i][j]+mini;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214881,
                "title": "c-recursion-memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[201][201];\\n          int solve(vector<vector<int>>& grid, int n, int i , int j){\\n        \\n        // this indicates that we have reached the last row , therefore simply return grid[i][j]\\n        if(i==n-1)\\n            return grid[i][j];\\n        \\n        if(t[i][j]!=-1)\\n            return t[i][j];\\n              \\n        int tempAns=INT_MAX;\\n        \\n        // we will check for every cell in the next row , except the column we are currently at , and then check for minimum from all of the cells\\n              \\n        for(int k=0;k<n;k++){\\n            if(k!=j){\\n                int cost=grid[i][j]+solve(grid,n,i+1,k);\\n                tempAns=min(tempAns,cost);\\n            }\\n           \\n        }\\n        \\n        return t[i][j]=tempAns;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\t\\t\\n        // ATQ, n*n matrix si given \\n\\t\\t\\n        memset(t,-1,sizeof(t));\\n        \\n        int ans=INT_MAX;\\n        \\n        // as we know that the falling path can start from any cell in the first row, therefore we will check for minimum for every cell in the first row\\n        \\n        for(int i=0;i<n;i++){\\n            int cost= solve(grid,n,0,i);\\n            ans=min(ans,cost);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n```\\n\\nsimilar ques :[2304. Minimum Path Cost in a Grid](https://leetcode.com/problems/minimum-path-cost-in-a-grid/)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[201][201];\\n          int solve(vector<vector<int>>& grid, int n, int i , int j){\\n        \\n        // this indicates that we have reached the last row , therefore simply return grid[i][j]\\n        if(i==n-1)\\n            return grid[i][j];\\n        \\n        if(t[i][j]!=-1)\\n            return t[i][j];\\n              \\n        int tempAns=INT_MAX;\\n        \\n        // we will check for every cell in the next row , except the column we are currently at , and then check for minimum from all of the cells\\n              \\n        for(int k=0;k<n;k++){\\n            if(k!=j){\\n                int cost=grid[i][j]+solve(grid,n,i+1,k);\\n                tempAns=min(tempAns,cost);\\n            }\\n           \\n        }\\n        \\n        return t[i][j]=tempAns;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\t\\t\\n        // ATQ, n*n matrix si given \\n\\t\\t\\n        memset(t,-1,sizeof(t));\\n        \\n        int ans=INT_MAX;\\n        \\n        // as we know that the falling path can start from any cell in the first row, therefore we will check for minimum for every cell in the first row\\n        \\n        for(int i=0;i<n;i++){\\n            int cost= solve(grid,n,0,i);\\n            ans=min(ans,cost);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203654,
                "title": "c-recursion-memoization-tabulation-space-optimization-easy",
                "content": "**Kindly Upvote if you find this useful**\\nThe **4 Solutions** are:\\n1. Recursion\\n1. Memoization\\n1. Tabulation\\n1. Space Optimization\\n\\n**Recursion**\\n**TC:** O(N ^ (N ^ 3))\\n**SC:** O(N) [Len of the path]\\n```\\nclass Solution {\\npublic:\\n    int path(int i,int prev, vector<vector<int>>& grid){\\n        if(i == 0){\\n            int mini = INT_MAX;\\n            for(int j=0;j<grid.size();j++){\\n                if(j == prev) continue;\\n                mini = min(mini,grid[i][j]);\\n            }\\n            return mini;\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int j=0;j<grid.size();j++){\\n            if(j == prev) continue;\\n            mini = min(mini,grid[i][j] + path(i-1,j,grid));\\n        }\\n        return mini;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        int mini = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            mini = min(mini, path(n-1,-1,grid));\\n        }\\n        return mini;\\n    }\\n};\\n```\\n\\n**Memoization**\\n**TC:** O(N ^ 3)\\n**SC:** O(N) [Stack Space -> Len of the path] + O(N ^ 2) [2D DP Vector]\\n```\\nclass Solution {\\npublic:\\n    int path(int i,int prev, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        if(i == 0){\\n            int mini = INT_MAX;\\n            for(int j=0;j<grid.size();j++){\\n                if(j == prev) continue;\\n                mini = min(mini,grid[i][j]);\\n            }\\n            return mini;\\n        }\\n        \\n        if(dp[i][prev] != -1) return dp[i][prev];\\n        \\n        int mini = INT_MAX;\\n        for(int j=0;j<grid.size();j++){\\n            if(j == prev) continue;\\n            mini = min(mini,grid[i][j] + path(i-1,j,grid,dp));\\n        }\\n        return dp[i][prev] = mini;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n        \\n        int mini = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            mini = min(mini, path(n-1,n,grid,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```\\n\\n**Tabulation**\\n**TC:** O(N ^ 3)\\n**SC:** O(N ^ 2) [2D DP Vector]\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n                \\n        for(int i=0;i<n;i++){\\n            for(int prev=0;prev<=n;prev++){\\n                if(i == 0){\\n                    int mini = INT_MAX;\\n                    for(int j=0;j<n;j++){\\n                        if(j == prev) continue;\\n                        mini = min(mini, grid[i][j]);\\n                    }\\n                    dp[i][prev] = mini;\\n                }\\n                else{\\n                    int mini = INT_MAX;\\n                    for(int j=0;j<n;j++){\\n                        if(j == prev) continue;\\n                        mini = min(mini, grid[i][j] + dp[i-1][j]);\\n                    }\\n                    dp[i][prev] = mini;\\n                }\\n            }\\n        }   \\n        return dp[n-1][n];\\n    }\\n};\\n```\\n\\n**Space Optimization**\\n**TC:** O(N ^ 3)\\n**SC:** O(N) [1D DP Vector]\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n\\n        vector<int> dp(n+1,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int> temp(n+1,-1);\\n            for(int prev=0;prev<=n;prev++){\\n                if(i == 0){\\n                    int mini = INT_MAX;\\n                    for(int j=0;j<n;j++){\\n                        if(j == prev) continue;\\n                        mini = min(mini, grid[i][j]);\\n                    }\\n                    temp[prev] = mini;\\n                }\\n                else{\\n                    int mini = INT_MAX;\\n                    for(int j=0;j<n;j++){\\n                        if(j == prev) continue;\\n                        mini = min(mini, grid[i][j] + dp[j]);\\n                    }\\n                    temp[prev] = mini;\\n                }\\n            }\\n            dp = temp;\\n        }   \\n        return dp[n];\\n    }\\n};\\n```\\n\\n**Kindly Upvote if you find this useful**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int path(int i,int prev, vector<vector<int>>& grid){\\n        if(i == 0){\\n            int mini = INT_MAX;\\n            for(int j=0;j<grid.size();j++){\\n                if(j == prev) continue;\\n                mini = min(mini,grid[i][j]);\\n            }\\n            return mini;\\n        }\\n        \\n        int mini = INT_MAX;\\n        for(int j=0;j<grid.size();j++){\\n            if(j == prev) continue;\\n            mini = min(mini,grid[i][j] + path(i-1,j,grid));\\n        }\\n        return mini;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        int mini = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            mini = min(mini, path(n-1,-1,grid));\\n        }\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int path(int i,int prev, vector<vector<int>>& grid, vector<vector<int>>& dp){\\n        if(i == 0){\\n            int mini = INT_MAX;\\n            for(int j=0;j<grid.size();j++){\\n                if(j == prev) continue;\\n                mini = min(mini,grid[i][j]);\\n            }\\n            return mini;\\n        }\\n        \\n        if(dp[i][prev] != -1) return dp[i][prev];\\n        \\n        int mini = INT_MAX;\\n        for(int j=0;j<grid.size();j++){\\n            if(j == prev) continue;\\n            mini = min(mini,grid[i][j] + path(i-1,j,grid,dp));\\n        }\\n        return dp[i][prev] = mini;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n        \\n        int mini = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            mini = min(mini, path(n-1,n,grid,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(n+1,-1));\\n                \\n        for(int i=0;i<n;i++){\\n            for(int prev=0;prev<=n;prev++){\\n                if(i == 0){\\n                    int mini = INT_MAX;\\n                    for(int j=0;j<n;j++){\\n                        if(j == prev) continue;\\n                        mini = min(mini, grid[i][j]);\\n                    }\\n                    dp[i][prev] = mini;\\n                }\\n                else{\\n                    int mini = INT_MAX;\\n                    for(int j=0;j<n;j++){\\n                        if(j == prev) continue;\\n                        mini = min(mini, grid[i][j] + dp[i-1][j]);\\n                    }\\n                    dp[i][prev] = mini;\\n                }\\n            }\\n        }   \\n        return dp[n-1][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n\\n        vector<int> dp(n+1,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int> temp(n+1,-1);\\n            for(int prev=0;prev<=n;prev++){\\n                if(i == 0){\\n                    int mini = INT_MAX;\\n                    for(int j=0;j<n;j++){\\n                        if(j == prev) continue;\\n                        mini = min(mini, grid[i][j]);\\n                    }\\n                    temp[prev] = mini;\\n                }\\n                else{\\n                    int mini = INT_MAX;\\n                    for(int j=0;j<n;j++){\\n                        if(j == prev) continue;\\n                        mini = min(mini, grid[i][j] + dp[j]);\\n                    }\\n                    temp[prev] = mini;\\n                }\\n            }\\n            dp = temp;\\n        }   \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195321,
                "title": "3-ways-recursion-memo-tabulation-space-optimised-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n\\t// recursion + memoization\\n    int solve(int i, int prev , vector<vector<int>> &grid , vector<vector<int>> &dp){\\n        if(i==n-1){\\n            int minn = INT_MAX;\\n            for(int j=0; j<n ; j++){\\n                if(j!=prev)\\n                    minn = min(minn , grid[i][j]);\\n            }\\n            return minn;\\n        }\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        int minn = INT_MAX;\\n        for(int j=0; j<n ; j++){\\n            if(j!=prev)\\n                minn = min(minn , grid[i][j] + solve(i+1 , j , grid,dp));\\n        }\\n        return dp[i][prev] = minn;\\n    }\\n\\t\\n\\t// tabulation\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        vector<vector<int>> dp(n , vector<int>(n , INT_MAX));\\n        // return solve(0 , n , grid , dp);\\n        for(int j=0 ; j<n ; j++){\\n            dp[0][j] = grid[0][j];\\n        }\\n        \\n        for(int i=1 ; i<n ; i++){\\n            for(int j=0 ; j<n ; j++){\\n                int minn = INT_MAX;\\n                for(int k=0 ; k<n ; k++){\\n                    if(k!=j)\\n                        minn = min(minn , dp[i-1][k]);\\n                }\\n                dp[i][j] = grid[i][j] + minn;\\n            }\\n        }\\n        int minn = INT_MAX;\\n        for(int j=0 ; j<n ; j++){\\n            minn = min(minn , dp[n-1][j]);\\n        }\\n        return minn;\\n    }\\n    \\n\\t// space optimised DP\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        vector<int> prev(n , INT_MAX);\\n        for(int j=0 ; j<n ; j++){\\n            prev[j] = grid[0][j];\\n        }\\n        \\n        for(int i=1 ; i<n ; i++){\\n            vector<int> temp(n  , INT_MAX);\\n            for(int j=0 ; j<n ; j++){\\n                int minn = INT_MAX;\\n                for(int k=0 ; k<n ; k++){\\n                    if(j!=k){\\n                        minn = min(minn , prev[k]);\\n                    }\\n                }\\n                temp[j] = grid[i][j] + minn;\\n            }\\n            prev = temp;\\n        }\\n        \\n        int minn = INT_MAX;\\n        for(int j=0 ; j<n ; j++){\\n           minn = min(minn , prev[j]);\\n        }\\n        \\n        return minn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n\\t// recursion + memoization\\n    int solve(int i, int prev , vector<vector<int>> &grid , vector<vector<int>> &dp){\\n        if(i==n-1){\\n            int minn = INT_MAX;\\n            for(int j=0; j<n ; j++){\\n                if(j!=prev)\\n                    minn = min(minn , grid[i][j]);\\n            }\\n            return minn;\\n        }\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        int minn = INT_MAX;\\n        for(int j=0; j<n ; j++){\\n            if(j!=prev)\\n                minn = min(minn , grid[i][j] + solve(i+1 , j , grid,dp));\\n        }\\n        return dp[i][prev] = minn;\\n    }\\n\\t\\n\\t// tabulation\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        vector<vector<int>> dp(n , vector<int>(n , INT_MAX));\\n        // return solve(0 , n , grid , dp);\\n        for(int j=0 ; j<n ; j++){\\n            dp[0][j] = grid[0][j];\\n        }\\n        \\n        for(int i=1 ; i<n ; i++){\\n            for(int j=0 ; j<n ; j++){\\n                int minn = INT_MAX;\\n                for(int k=0 ; k<n ; k++){\\n                    if(k!=j)\\n                        minn = min(minn , dp[i-1][k]);\\n                }\\n                dp[i][j] = grid[i][j] + minn;\\n            }\\n        }\\n        int minn = INT_MAX;\\n        for(int j=0 ; j<n ; j++){\\n            minn = min(minn , dp[n-1][j]);\\n        }\\n        return minn;\\n    }\\n    \\n\\t// space optimised DP\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        vector<int> prev(n , INT_MAX);\\n        for(int j=0 ; j<n ; j++){\\n            prev[j] = grid[0][j];\\n        }\\n        \\n        for(int i=1 ; i<n ; i++){\\n            vector<int> temp(n  , INT_MAX);\\n            for(int j=0 ; j<n ; j++){\\n                int minn = INT_MAX;\\n                for(int k=0 ; k<n ; k++){\\n                    if(j!=k){\\n                        minn = min(minn , prev[k]);\\n                    }\\n                }\\n                temp[j] = grid[i][j] + minn;\\n            }\\n            prev = temp;\\n        }\\n        \\n        int minn = INT_MAX;\\n        for(int j=0 ; j<n ; j++){\\n           minn = min(minn , prev[j]);\\n        }\\n        \\n        return minn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184914,
                "title": "very-simple-python-solution-dp",
                "content": "We need to find the minimum possible falling path. Therefore, we will try to choose the smallest element from every row that does not violate the given condition.\\n\\nAlgorithm:\\n1. For every row, we calculate the smallest (min1) and the second smallest (min2) elements of the previous row.\\n2. Now for every element in the current row, we check if min1 is equal to the element above it.\\n3.  If this is true, then min1 and the current element are in the same column. So, we\\'ll choose the next smallest element which is min2.\\n4.  Otherwise, we\\'ll choose min1.\\n```\\ndef minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        def twoMins(arr):\\n            min1 = float(\"inf\")\\n            min2 = float(\"inf\")\\n            \\n            for num in arr:\\n                if num<min1:\\n                    min2 = min1\\n                    min1 = num\\n                \\n                elif num<min2:\\n                    min2 = num\\n            \\n            return (min1,min2)\\n        \\n        for i in range(1,m):\\n            min1, min2 = twoMins(grid[i-1])  #1\\n\\t\\t\\t\\n            for j in range(n):\\n                minVal = min1\\n                if min1 == grid[i-1][j]:     #2\\n                    minVal = min2            #3\\n\\t\\t\\t\\t\\t\\n                grid[i][j] = grid[i][j] + minVal\\n        \\n        return min(grid[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        def twoMins(arr):\\n            min1 = float(\"inf\")\\n            min2 = float(\"inf\")\\n            \\n            for num in arr:\\n                if num<min1:\\n                    min2 = min1\\n                    min1 = num\\n                \\n                elif num<min2:\\n                    min2 = num\\n            \\n            return (min1,min2)\\n        \\n        for i in range(1,m):\\n            min1, min2 = twoMins(grid[i-1])  #1\\n\\t\\t\\t\\n            for j in range(n):\\n                minVal = min1\\n                if min1 == grid[i-1][j]:     #2\\n                    minVal = min2            #3\\n\\t\\t\\t\\t\\t\\n                grid[i][j] = grid[i][j] + minVal\\n        \\n        return min(grid[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2167080,
                "title": "c-dp-recursion-memoization-tabulation-space-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n      int solve(int i,int j,vector<vector<int>>&grid){\\n    \\n    if(i==0) return grid[i][j];\\n          \\n    int ans=INT_MAX;\\n   for(int l=0;l<grid.size();l++ ){\\n       if(l!=j)\\n       ans=min(ans,solve(i-1,l,grid));\\n   }\\n    return ans==INT_MAX?ans:ans+grid[i][j];\\n}\\n    \\nint solveMemo(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n   \\n    if(i==0) return grid[i][j];\\n    \\n    if(dp[i][j]!=-1) return dp[i][j];\\n  int ans=INT_MAX;\\n   for(int l=0;l<grid.size();l++ ){\\n       if(l!=j)\\n       ans=min(ans,solveMemo(i-1,l,grid,dp));\\n   }\\n    return dp[i][j]= ans==INT_MAX?ans:ans+grid[i][j];\\n}\\n    \\n    \\nint solveTabu(vector<vector<int>>&grid){\\n    int n=grid.size();\\n           vector<vector<int>>dp(n,vector<int>(n,0));\\n           for(int i=0;i<n;i++){\\n               for(int j=0;j<n;j++){\\n                   if(i==0) dp[i][j]=grid[i][j];\\n                   else{\\n                     int ans=INT_MAX;\\n           for(int l=0;l<grid.size();l++ ){\\n               if(l!=j)\\n               ans=min(ans,dp[i-1][l]);\\n           }\\n         dp[i][j]= ans==INT_MAX?ans:ans+grid[i][j];\\n                       \\n                   }\\n               }\\n           }\\n           int ans=INT_MAX;\\n           for(int i=0;i<n;i++){\\n               ans=min(ans,dp[n-1][i]);\\n           }\\n           return ans;  \\n}\\n    \\n    \\n    int solveTabuSo(vector<vector<int>>&grid){\\n    int n=grid.size();\\n      vector<int>prev(grid[0]);\\n           for(int i=1;i<n;i++){\\n               vector<int>cur(n,0);\\n               for(int j=0;j<n;j++){\\n                     int ans=INT_MAX;\\n           for(int l=0;l<n;l++ ){\\n               if(l!=j)\\n               ans=min(ans,prev[l]);\\n           }\\n         cur[j]=ans+grid[i][j];\\n                        \\n               }\\n               prev=cur;\\n           }\\n           int ans=INT_MAX;\\n           for(int i=0;i<n;i++){\\n               ans=min(ans,prev[i]);\\n           }\\n           return ans;  \\n}\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n          int ans=INT_MAX;\\n        int n=grid.size();\\n        // vector<vector<int>>dp(n,vector<int>(n,-1));\\n        // for(int i=0;i<n;i++){\\n        //     ans=min(ans,solve(n-1,i,grid));\\n        // }\\n        //  for(int i=0;i<n;i++){\\n        //     ans=min(ans,solveMemo(n-1,i,grid,dp));\\n        // }\\n        // return ans;\\n        // return solveTabu(grid);\\n        return solveTabuSo(grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int solve(int i,int j,vector<vector<int>>&grid){\\n    \\n    if(i==0) return grid[i][j];\\n          \\n    int ans=INT_MAX;\\n   for(int l=0;l<grid.size();l++ ){\\n       if(l!=j)\\n       ans=min(ans,solve(i-1,l,grid));\\n   }\\n    return ans==INT_MAX?ans:ans+grid[i][j];\\n}\\n    \\nint solveMemo(int i,int j,vector<vector<int>>&grid,vector<vector<int>>&dp){\\n   \\n    if(i==0) return grid[i][j];\\n    \\n    if(dp[i][j]!=-1) return dp[i][j];\\n  int ans=INT_MAX;\\n   for(int l=0;l<grid.size();l++ ){\\n       if(l!=j)\\n       ans=min(ans,solveMemo(i-1,l,grid,dp));\\n   }\\n    return dp[i][j]= ans==INT_MAX?ans:ans+grid[i][j];\\n}\\n    \\n    \\nint solveTabu(vector<vector<int>>&grid){\\n    int n=grid.size();\\n           vector<vector<int>>dp(n,vector<int>(n,0));\\n           for(int i=0;i<n;i++){\\n               for(int j=0;j<n;j++){\\n                   if(i==0) dp[i][j]=grid[i][j];\\n                   else{\\n                     int ans=INT_MAX;\\n           for(int l=0;l<grid.size();l++ ){\\n               if(l!=j)\\n               ans=min(ans,dp[i-1][l]);\\n           }\\n         dp[i][j]= ans==INT_MAX?ans:ans+grid[i][j];\\n                       \\n                   }\\n               }\\n           }\\n           int ans=INT_MAX;\\n           for(int i=0;i<n;i++){\\n               ans=min(ans,dp[n-1][i]);\\n           }\\n           return ans;  \\n}\\n    \\n    \\n    int solveTabuSo(vector<vector<int>>&grid){\\n    int n=grid.size();\\n      vector<int>prev(grid[0]);\\n           for(int i=1;i<n;i++){\\n               vector<int>cur(n,0);\\n               for(int j=0;j<n;j++){\\n                     int ans=INT_MAX;\\n           for(int l=0;l<n;l++ ){\\n               if(l!=j)\\n               ans=min(ans,prev[l]);\\n           }\\n         cur[j]=ans+grid[i][j];\\n                        \\n               }\\n               prev=cur;\\n           }\\n           int ans=INT_MAX;\\n           for(int i=0;i<n;i++){\\n               ans=min(ans,prev[i]);\\n           }\\n           return ans;  \\n}\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n          int ans=INT_MAX;\\n        int n=grid.size();\\n        // vector<vector<int>>dp(n,vector<int>(n,-1));\\n        // for(int i=0;i<n;i++){\\n        //     ans=min(ans,solve(n-1,i,grid));\\n        // }\\n        //  for(int i=0;i<n;i++){\\n        //     ans=min(ans,solveMemo(n-1,i,grid,dp));\\n        // }\\n        // return ans;\\n        // return solveTabu(grid);\\n        return solveTabuSo(grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166810,
                "title": "java-o-n2-dp",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int[] dp = grid[0];\\n        for(int i = 1; i < n; i++) {\\n            int miniLeft = 99*2000;\\n            int miniRight = 99*2000;\\n            int[] ndp = new int[n];\\n            Arrays.fill(ndp, Integer.MAX_VALUE);\\n            for(int j = 0, k = n-1; j < n; j++,k--) {\\n                ndp[j] = Math.min(ndp[j], grid[i][j] + miniLeft);\\n                ndp[k] = Math.min(ndp[k], grid[i][k] + miniRight);\\n                miniLeft = Math.min(miniLeft, dp[j]);\\n                miniRight = Math.min(miniRight, dp[k]);\\n            }\\n            dp = ndp;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++) ans = Math.min(ans, dp[i]);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        int[] dp = grid[0];\\n        for(int i = 1; i < n; i++) {\\n            int miniLeft = 99*2000;\\n            int miniRight = 99*2000;\\n            int[] ndp = new int[n];\\n            Arrays.fill(ndp, Integer.MAX_VALUE);\\n            for(int j = 0, k = n-1; j < n; j++,k--) {\\n                ndp[j] = Math.min(ndp[j], grid[i][j] + miniLeft);\\n                ndp[k] = Math.min(ndp[k], grid[i][k] + miniRight);\\n                miniLeft = Math.min(miniLeft, dp[j]);\\n                miniRight = Math.min(miniRight, dp[k]);\\n            }\\n            dp = ndp;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++) ans = Math.min(ans, dp[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082612,
                "title": "new-concept-without-dp-through-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        multiset<int>s;\\n        int n = grid.size();\\n        for(int i = 0; i < n; ++ i){\\n            s.insert(grid[n-1][i]);\\n        }\\n        for(int i = n - 2; i >= 0; -- i){\\n            for(int j =  0; j < n; ++ j){\\n                int val = grid[i+1][j];\\n                s.erase(s.lower_bound(val));// This is to avoid the case when multiset delete all values of val, instead of just 1.\\n                grid[i][j] += *(s.begin());\\n                s.insert(val);\\n            }\\n            s.clear();\\n            for(int j = 0; j < n; ++ j){\\n                s.insert(grid[i][j]);\\n            }\\n        } \\n        return *min_element(grid[0].begin(),grid[0].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        multiset<int>s;\\n        int n = grid.size();\\n        for(int i = 0; i < n; ++ i){\\n            s.insert(grid[n-1][i]);\\n        }\\n        for(int i = n - 2; i >= 0; -- i){\\n            for(int j =  0; j < n; ++ j){\\n                int val = grid[i+1][j];\\n                s.erase(s.lower_bound(val));// This is to avoid the case when multiset delete all values of val, instead of just 1.\\n                grid[i][j] += *(s.begin());\\n                s.insert(val);\\n            }\\n            s.clear();\\n            for(int j = 0; j < n; ++ j){\\n                s.insert(grid[i][j]);\\n            }\\n        } \\n        return *min_element(grid[0].begin(),grid[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023288,
                "title": "java-memoization-solution",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int[][] dp = new int[grid.length+1][grid.length+1];\\n        for(int i=0;i<=grid.length;i++) {\\n            for(int j=0;j<=grid.length;j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return solve(grid, grid.length-1, grid.length, dp);\\n    }\\n    private int solve(int[][] grid, int ind, int last, int[][] dp) {\\n        if(ind<0){\\n            return 0;\\n        }\\n        if(dp[ind][last]!=-1) {\\n            return dp[ind][last];\\n        }\\n        int mini = Integer.MAX_VALUE;\\n        for(int i=0;i<grid.length;i++) {\\n            if(i!=last) {\\n                int point = grid[ind][i] + solve(grid, ind-1, i, dp);\\n                mini = Math.min(mini, point);\\n            }\\n        }\\n        return dp[ind][last] = mini;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int[][] dp = new int[grid.length+1][grid.length+1];\\n        for(int i=0;i<=grid.length;i++) {\\n            for(int j=0;j<=grid.length;j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return solve(grid, grid.length-1, grid.length, dp);\\n    }\\n    private int solve(int[][] grid, int ind, int last, int[][] dp) {\\n        if(ind<0){\\n            return 0;\\n        }\\n        if(dp[ind][last]!=-1) {\\n            return dp[ind][last];\\n        }\\n        int mini = Integer.MAX_VALUE;\\n        for(int i=0;i<grid.length;i++) {\\n            if(i!=last) {\\n                int point = grid[ind][i] + solve(grid, ind-1, i, dp);\\n                mini = Math.min(mini, point);\\n            }\\n        }\\n        return dp[ind][last] = mini;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871114,
                "title": "simple-solution",
                "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            dp[m-1][i]=grid[m-1][i];\\n        }\\n        \\n        for(int i=m-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int mn=INT_MAX;\\n               dp[i][j]=grid[i][j];\\n                for(int k=0;k<n;k++){\\n                    if(k!=j){\\n                        mn=min(mn,dp[i+1][k]);\\n                    }\\n                }\\n                dp[i][j]+=mn;\\n            }\\n        }\\n        int maxi=INT_MAX;\\n        for(int i=0;i<n;i++){\\n        maxi=min(maxi,dp[0][i]);\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            dp[m-1][i]=grid[m-1][i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1809119,
                "title": "c-recurstion-memoization-o-n-2-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n     int dp[201][201];\\n    int solve(vector<vector<int>> &grid, int n, int i, int j){\\n         if(i == n - 1) return grid[i][j];\\n         int cur_ans = INT_MAX;\\n         if(dp[i][j] != -1)  return dp[i][j];\\n         for(int idx = 0; idx<n; idx++){\\n             if(idx != j){\\n                 cur_ans = min(cur_ans, grid[i][j] + solve(grid, n, i+1, idx));\\n             }\\n         }\\n             return dp[i][j] = cur_ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int ans = INT_MAX;\\n        int n = grid.size();\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=0; i<n; i++){\\n            ans = min(ans, solve(grid, n, 0, i));\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n     int dp[201][201];\\n    int solve(vector<vector<int>> &grid, int n, int i, int j){\\n         if(i == n - 1) return grid[i][j];\\n         int cur_ans = INT_MAX;\\n         if(dp[i][j] != -1)  return dp[i][j];\\n         for(int idx = 0; idx<n; idx++){\\n             if(idx != j){\\n                 cur_ans = min(cur_ans, grid[i][j] + solve(grid, n, i+1, idx));\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1724553,
                "title": "a-graspable-recursive-solution-for-both-minimum-falling-path-sum-i-and-ii",
                "content": "931. Minimum Falling Path Sum\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int res = Integer.MAX_VALUE;\\n        Integer[][] memo = new Integer[matrix.length][matrix.length];\\n        for(int i=0; i<matrix.length; i++){\\n            res = Math.min(res, dfs(matrix, 0, i, memo));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int dfs(int[][] matrix, int row, int col, Integer[][] memo){\\n\\t\\t// discourage the path by returning +inf if we go out of bounds\\n        if(row == matrix.length || col < 0 || col == matrix.length){\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n\\t\\t// base case\\n        if(row == matrix.length - 1){\\n            return matrix[row][col];\\n        }\\n        \\n\\t\\t// return the memoized result\\n        if(memo[row][col] != null){\\n            return memo[row][col];\\n        }\\n        \\n\\t\\t// next row and same col\\n        int res = dfs(matrix, row + 1, col, memo) + matrix[row][col];\\n        \\n\\t\\t// next row and prev col\\n        res = Math.min(res, (dfs(matrix, row + 1, col - 1, memo) == Integer.MAX_VALUE ? Integer.MAX_VALUE : dfs(matrix, row + 1, col - 1, memo) + matrix[row][col]));\\n        \\n\\t\\t// next row and next col\\n        res = Math.min(res, (dfs(matrix, row + 1, col + 1, memo) == Integer.MAX_VALUE ? Integer.MAX_VALUE : dfs(matrix, row + 1, col + 1, memo) + matrix[row][col]));\\n        \\n\\t\\t// memoize the result\\n        memo[row][col] = res;\\n        return res;\\n    }\\n}\\n```\\n\\n1289. Minimum Falling Path Sum II\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int res = Integer.MAX_VALUE;\\n        Integer[][] memo = new Integer[matrix.length][matrix.length];\\n        for(int i=0; i<matrix.length; i++){\\n            res = Math.min(res, dfs(matrix, 0, i, memo));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int dfs(int[][] matrix, int row, int col, Integer[][] memo){\\n\\t\\t// discourage the path by returning +inf if we go out of bounds\\n        if(row == matrix.length || col < 0 || col == matrix.length){\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n\\t\\t// base case\\n        if(row == matrix.length - 1){\\n            return matrix[row][col];\\n        } \\n        \\n\\t\\t// return the memoized result\\n        if(memo[row][col] != null){\\n            return memo[row][col];\\n        }\\n        \\n\\t\\t// recursive case to choose the optimal column from the next row\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0; i<matrix.length; i++){\\n            if(i != col){\\n                res = Math.min(res, (dfs(matrix, row + 1, i, memo) == Integer.MAX_VALUE ? Integer.MAX_VALUE : dfs(matrix, row + 1, i, memo) + matrix[row][col])); \\n            }\\n        }\\n        \\n\\t\\t// memoize the result\\n        memo[row][col] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int res = Integer.MAX_VALUE;\\n        Integer[][] memo = new Integer[matrix.length][matrix.length];\\n        for(int i=0; i<matrix.length; i++){\\n            res = Math.min(res, dfs(matrix, 0, i, memo));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int dfs(int[][] matrix, int row, int col, Integer[][] memo){\\n\\t\\t// discourage the path by returning +inf if we go out of bounds\\n        if(row == matrix.length || col < 0 || col == matrix.length){\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n\\t\\t// base case\\n        if(row == matrix.length - 1){\\n            return matrix[row][col];\\n        }\\n        \\n\\t\\t// return the memoized result\\n        if(memo[row][col] != null){\\n            return memo[row][col];\\n        }\\n        \\n\\t\\t// next row and same col\\n        int res = dfs(matrix, row + 1, col, memo) + matrix[row][col];\\n        \\n\\t\\t// next row and prev col\\n        res = Math.min(res, (dfs(matrix, row + 1, col - 1, memo) == Integer.MAX_VALUE ? Integer.MAX_VALUE : dfs(matrix, row + 1, col - 1, memo) + matrix[row][col]));\\n        \\n\\t\\t// next row and next col\\n        res = Math.min(res, (dfs(matrix, row + 1, col + 1, memo) == Integer.MAX_VALUE ? Integer.MAX_VALUE : dfs(matrix, row + 1, col + 1, memo) + matrix[row][col]));\\n        \\n\\t\\t// memoize the result\\n        memo[row][col] = res;\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int res = Integer.MAX_VALUE;\\n        Integer[][] memo = new Integer[matrix.length][matrix.length];\\n        for(int i=0; i<matrix.length; i++){\\n            res = Math.min(res, dfs(matrix, 0, i, memo));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int dfs(int[][] matrix, int row, int col, Integer[][] memo){\\n\\t\\t// discourage the path by returning +inf if we go out of bounds\\n        if(row == matrix.length || col < 0 || col == matrix.length){\\n            return Integer.MAX_VALUE;\\n        }\\n        \\n\\t\\t// base case\\n        if(row == matrix.length - 1){\\n            return matrix[row][col];\\n        } \\n        \\n\\t\\t// return the memoized result\\n        if(memo[row][col] != null){\\n            return memo[row][col];\\n        }\\n        \\n\\t\\t// recursive case to choose the optimal column from the next row\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0; i<matrix.length; i++){\\n            if(i != col){\\n                res = Math.min(res, (dfs(matrix, row + 1, i, memo) == Integer.MAX_VALUE ? Integer.MAX_VALUE : dfs(matrix, row + 1, i, memo) + matrix[row][col])); \\n            }\\n        }\\n        \\n\\t\\t// memoize the result\\n        memo[row][col] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656344,
                "title": "java-o-n-n-by-tracking-2-mins-for-each-row",
                "content": "- keep tracking for 2 mins (lowMin and highMin) for each row\\n- if upper cell is equal to lowMin (grid[i-1][j]==lowMin) than we have to use highMin, otherwise lowMin\\n- grid[i][j] += lowMin ... or... highMin depending on grid[i-1][j]\\n```\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        for(int i=1;i<n;i++){\\n            int lowMin=Integer.MAX_VALUE, highMin=Integer.MAX_VALUE;\\n            for(int j=0;j<n;j++){\\n                if(grid[i-1][j]<=lowMin){\\n                    highMin=lowMin;\\n                    lowMin=grid[i-1][j];\\n                }else if(grid[i-1][j]<highMin){\\n                    highMin=grid[i-1][j];\\n                }\\n            }\\n            for(int j=0;j<n;j++){\\n                if(grid[i-1][j]==lowMin)    \\n                    grid[i][j]+=highMin;\\n                else\\n                    grid[i][j]+=lowMin;\\n            }\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int j=0;j<n;j++)\\n            min = Math.min(min, grid[n-1][j]);\\n        \\n        return min;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n        for(int i=1;i<n;i++){\\n            int lowMin=Integer.MAX_VALUE, highMin=Integer.MAX_VALUE;\\n            for(int j=0;j<n;j++){\\n                if(grid[i-1][j]<=lowMin){\\n                    highMin=lowMin;\\n                    lowMin=grid[i-1][j];\\n                }else if(grid[i-1][j]<highMin){\\n                    highMin=grid[i-1][j];\\n                }\\n            }\\n            for(int j=0;j<n;j++){\\n                if(grid[i-1][j]==lowMin)    \\n                    grid[i][j]+=highMin;\\n                else\\n                    grid[i][j]+=lowMin;\\n            }\\n        }\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int j=0;j<n;j++)\\n            min = Math.min(min, grid[n-1][j]);\\n        \\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1652462,
                "title": "c-o-n-m-solution-using-minimum-and-2nd-minimum",
                "content": "Find min and 2nd minof every dp row to be used when value equals the min value 2nd min value is used\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        if(m == 1)\\n        {\\n            int mi = INT_MAX;\\n        for(int i=0;i<n;i++)\\n           mi = min(matrix[0][i],mi);\\n        return mi;\\n        }\\n        int dp[m][n];\\n        int mi1 = INT_MAX;\\n        int mi2 = INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mi1 >= matrix[m-1][i])\\n            {\\n                mi2 = mi1;\\n                mi1 = matrix[m-1][i];\\n            }\\n            else\\n                if(mi2 > matrix[m-1][i])\\n                {\\n                    mi2 = matrix[m-1][i];\\n                }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mi1 == matrix[m-1][i])\\n                dp[m-1][i] = mi2;\\n            else\\n                dp[m-1][i] = mi1;\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                dp[i][j] = dp[i+1][j] != INT_MAX?dp[i+1][j]+matrix[i][j]:INT_MAX; // Find min vaue achived by starting from this cell \\n            }\\n        mi1 = INT_MAX;\\n        mi2 = INT_MAX;\\n        for(int j=0;j<n;j++)     // Finding Min and 2nd Min value\\n        {\\n            if(mi1 >= dp[i][j])\\n            {\\n                mi2 = mi1;\\n                mi1 = dp[i][j];\\n            }\\n            else\\n                if(mi2 > dp[i][j])\\n                {\\n                    mi2 = dp[i][j];\\n                }\\n        }\\n        for(int j=0;j<n;j++)\\n        {\\n            if(mi1 == dp[i][j])\\n                dp[i][j] = mi2;\\n            else\\n                dp[i][j] = mi1;\\n        }\\n        }\\n        int mi = INT_MAX;\\n        for(int i=0;i<n;i++)\\n           mi = min(dp[0][i],mi);\\n        return mi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        if(m == 1)\\n        {\\n            int mi = INT_MAX;\\n        for(int i=0;i<n;i++)\\n           mi = min(matrix[0][i],mi);\\n        return mi;\\n        }\\n        int dp[m][n];\\n        int mi1 = INT_MAX;\\n        int mi2 = INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mi1 >= matrix[m-1][i])\\n            {\\n                mi2 = mi1;\\n                mi1 = matrix[m-1][i];\\n            }\\n            else\\n                if(mi2 > matrix[m-1][i])\\n                {\\n                    mi2 = matrix[m-1][i];\\n                }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mi1 == matrix[m-1][i])\\n                dp[m-1][i] = mi2;\\n            else\\n                dp[m-1][i] = mi1;\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                dp[i][j] = dp[i+1][j] != INT_MAX?dp[i+1][j]+matrix[i][j]:INT_MAX; // Find min vaue achived by starting from this cell \\n            }\\n        mi1 = INT_MAX;\\n        mi2 = INT_MAX;\\n        for(int j=0;j<n;j++)     // Finding Min and 2nd Min value\\n        {\\n            if(mi1 >= dp[i][j])\\n            {\\n                mi2 = mi1;\\n                mi1 = dp[i][j];\\n            }\\n            else\\n                if(mi2 > dp[i][j])\\n                {\\n                    mi2 = dp[i][j];\\n                }\\n        }\\n        for(int j=0;j<n;j++)\\n        {\\n            if(mi1 == dp[i][j])\\n                dp[i][j] = mi2;\\n            else\\n                dp[i][j] = mi1;\\n        }\\n        }\\n        int mi = INT_MAX;\\n        for(int i=0;i<n;i++)\\n           mi = min(dp[0][i],mi);\\n        return mi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628375,
                "title": "very-easy-dp-approach",
                "content": "I am presenting naive dynamic programming approch which I came up with in , first few minutes.\\nwhat dp[i][j] denotes ?\\ndp[i][j] = minimum falling path if we select grid[i][j].\\nit means for **botom row** dp[i][j]=grid[i][j] as there is no row below it .\\nfor every other row \\n```\\ndp[i][j]=grid[i][j] + min{ dp[i+1][k] for all k = 0 to n-1 // n is the no. of columns.\\n```\\nwhy this algo ? as for dp[i][j] denotes minimum falling path starting from grid[i][j].\\nwhich will be equal to its own value ( grid[i][j] ) + minimum falling path we can get from next row .\\n**BUT THERE IS MORE TO THIS QUESTION .**\\n1. to find dp[i][j] we can not use value dp[i+1][j] . Ok we will make slight change .\\n2. what exactly we get after all this ? Ans dp matrix .\\n\\tdp matrix contains values of minimum falling paths . so if we start from i,j then dp[i][j] is the ans.\\nwhere to start ? Ans - from first row .\\nfinal solution - as we will be starting from first row , now we need to find minimum path \\n```so our ans is min. of dp[0][k] // for all k where k= 0 to n-1 where n is no. of columns.```\\nafter doing all this \\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(i==m-1){\\n                    dp[i][j]=grid[i][j]; // last row \\n                }\\n                else{int temp=0;\\n                    if(j!=n-1)\\n                     temp=dp[i+1][j+1]; // initialising temp as needed to find min. you can also set it to some very large value .\\n                    else{\\n                        temp=dp[i+1][j-1]; // initialising temp as needed to find min. you can also set it to some very large value .\\n                    }\\n                    for(int k=0;k!=n;k++)\\n                    {   if(k!=j)\\n                        temp=min(dp[i+1][k],temp);\\n                    }\\n                    dp[i][j]=temp+grid[i][j];\\n                        }\\n            }\\n        }\\n        int temp=dp[0][0];\\n        for(int i=0;i!=n;i++){\\n            temp=min(temp,dp[0][i]); // finding minimum from first row .\\n        }\\n        return temp;\\n    }\\n};\\n```\\n**Also do tell me whether this solution will be accepted in interviews or not . As i think it is going O(M*N^2)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][j]=grid[i][j] + min{ dp[i+1][k] for all k = 0 to n-1 // n is the no. of columns.\\n```\n```so our ans is min. of dp[0][k] // for all k where k= 0 to n-1 where n is no. of columns.```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n));\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(i==m-1){\\n                    dp[i][j]=grid[i][j]; // last row \\n                }\\n                else{int temp=0;\\n                    if(j!=n-1)\\n                     temp=dp[i+1][j+1]; // initialising temp as needed to find min. you can also set it to some very large value .\\n                    else{\\n                        temp=dp[i+1][j-1]; // initialising temp as needed to find min. you can also set it to some very large value .\\n                    }\\n                    for(int k=0;k!=n;k++)\\n                    {   if(k!=j)\\n                        temp=min(dp[i+1][k],temp);\\n                    }\\n                    dp[i][j]=temp+grid[i][j];\\n                        }\\n            }\\n        }\\n        int temp=dp[0][0];\\n        for(int i=0;i!=n;i++){\\n            temp=min(temp,dp[0][i]); // finding minimum from first row .\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603811,
                "title": "priority-queue-c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& g) {\\n        int r = g.size();\\n        int c = g[0].size();\\n        if(r == 1){\\n            int mn = g[0][0];\\n            for(int i = 0; i < c; i++){\\n                mn = min(mn, g[0][i]);\\n            }\\n            return mn;\\n        }else{\\n            priority_queue<int, vector<int>, greater<int> > pq;\\n            for(int i = 0; i < c; i++) pq.push(g[0][i]);\\n            // double loop\\n            for(int i = 1; i < r ; i++){\\n                for(int j = 0; j < c; j++){\\n                    if(pq.top() == g[i-1][j]){\\n                        int x = pq.top();\\n                        pq.pop();\\n                        g[i][j] += pq.top();\\n                        pq.push(x);\\n                    }else{\\n                        g[i][j] += pq.top();\\n                    }\\n                }\\n                while(!pq.empty()) pq.pop();\\n                for(int j = 0; j < c; j++) pq.push(g[i][j]);\\n            }\\n            \\n            return pq.top();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& g) {\\n        int r = g.size();\\n        int c = g[0].size();\\n        if(r == 1){\\n            int mn = g[0][0];\\n            for(int i = 0; i < c; i++){\\n                mn = min(mn, g[0][i]);\\n            }\\n            return mn;\\n        }else{\\n            priority_queue<int, vector<int>, greater<int> > pq;\\n            for(int i = 0; i < c; i++) pq.push(g[0][i]);\\n            // double loop\\n            for(int i = 1; i < r ; i++){\\n                for(int j = 0; j < c; j++){\\n                    if(pq.top() == g[i-1][j]){\\n                        int x = pq.top();\\n                        pq.pop();\\n                        g[i][j] += pq.top();\\n                        pq.push(x);\\n                    }else{\\n                        g[i][j] += pq.top();\\n                    }\\n                }\\n                while(!pq.empty()) pq.pop();\\n                for(int j = 0; j < c; j++) pq.push(g[i][j]);\\n            }\\n            \\n            return pq.top();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577762,
                "title": "simple-python-dp-solution-time-o-n-2-space-o-n",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # Time : O(N^2) \\n        # Space : O(N)\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        if cols == 1:\\n            return grid[0][0]\\n        \\n        dp = [float(\\'inf\\') for i in range(cols + 2) ]\\n        min_in_left = [float(\\'inf\\') if i in {0, cols +1} else 0 for i in range(cols + 2) ]\\n        min_in_right = [float(\\'inf\\') if i in {0, cols +1} else 0 for i in range(cols + 2) ]\\n        \\n        for i in range(rows-1,-1,-1):\\n            for j in range(1,cols+1):\\n                dp[j] = grid[i][j-1] + min(min_in_left[j-1], min_in_right[j+1])\\n            \\n            for j in range(1, cols+1):\\n                min_in_left[j] = min(dp[j], min_in_left[j-1])\\n                \\n            for j in range(cols, 0, -1):\\n                min_in_right[j] = min(dp[j], min_in_right[j+1])\\n    \\n        return min(dp)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        \\n        # Time : O(N^2) \\n        # Space : O(N)\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        if cols == 1:\\n            return grid[0][0]\\n        \\n        dp = [float(\\'inf\\') for i in range(cols + 2) ]\\n        min_in_left = [float(\\'inf\\') if i in {0, cols +1}",
                "codeTag": "Java"
            },
            {
                "id": 1553606,
                "title": "c-simple-solution-dp",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int x=grid.size();\\n        int y=grid[0].size();\\n        int dp[x][y];\\n        if(grid.size()==1)\\n        {\\n            return grid[0][0];\\n        }\\n        for(int i=0;i<x;i++)\\n        {\\n            dp[0][i]=grid[0][i];\\n        }\\n        for(int i=1;i<x;i++)\\n        {\\n            for(int j=0;j<y;j++)\\n            {\\n                int ans;ans=INT_MAX;\\n              \\n                   for(int l=0;l<y;l++)\\n                    {\\n                       \\n                       if(l==j)\\n                       {\\n                           continue;\\n                       }\\n                       else\\n                       {\\n                        ans=min(ans,dp[i-1][l]);\\n                       }\\n                    }\\n                dp[i][j]=grid[i][j]+ans;\\n                \\n              \\n                \\n            }\\n        }\\n        int min1=INT_MAX;\\n        \\n        for(int i=y-1;i>=0;i--)\\n        {\\n            min1=min(min1,dp[x-1][i]);\\n        }\\n        return min1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int x=grid.size();\\n        int y=grid[0].size();\\n        int dp[x][y];\\n        if(grid.size()==1)\\n        {\\n            return grid[0][0];\\n        }\\n        for(int i=0;i<x;i++)\\n        {\\n            dp[0][i]=grid[0][i];\\n        }\\n        for(int i=1;i<x;i++)\\n        {\\n            for(int j=0;j<y;j++)\\n            {\\n                int ans;ans=INT_MAX;\\n              \\n                   for(int l=0;l<y;l++)\\n                    {\\n                       \\n                       if(l==j)\\n                       {\\n                           continue;\\n                       }\\n                       else\\n                       {\\n                        ans=min(ans,dp[i-1][l]);\\n                       }\\n                    }\\n                dp[i][j]=grid[i][j]+ans;\\n                \\n              \\n                \\n            }\\n        }\\n        int min1=INT_MAX;\\n        \\n        for(int i=y-1;i>=0;i--)\\n        {\\n            min1=min(min1,dp[x-1][i]);\\n        }\\n        return min1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485606,
                "title": "c-dp-solution-90-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        if(n==1)\\n            return grid[0][0];\\n        vector<int>v(n);\\n        v=grid[0];\\n        sort(v.begin(),v.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {              \\n                if(v[0]==grid[i-1][j])\\n                    grid[i][j]+=v[1];\\n                else\\n                    grid[i][j]+=v[0];\\n            }\\n            v.clear();\\n            v=grid[i];\\n            sort(v.begin(),v.end());\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        if(n==1)\\n            return grid[0][0];\\n        vector<int>v(n);\\n        v=grid[0];\\n        sort(v.begin(),v.end());\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {              \\n                if(v[0]==grid[i-1][j])\\n                    grid[i][j]+=v[1];\\n                else\\n                    grid[i][j]+=v[0];\\n            }\\n            v.clear();\\n            v=grid[i];\\n            sort(v.begin(),v.end());\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438090,
                "title": "python-bottom-up-o-n-2-logn",
                "content": "Basic intuition is to pick first 2 min elements from above row,as we need only 1 extra element in case of column clash with previous element.\\n```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        if n==1: return grid[0][0]\\n        dp=[[sys.maxsize]*n for _ in range(n)]\\n        for j in range(n):\\n            dp[0][j]=grid[0][j]\\n        for i in range(1,n):\\n            arr=[(val,idx) for idx,val in enumerate(dp[i-1])]\\n            arr.sort()\\n            for j in range(n):\\n                val,idx=arr[0]\\n                if idx!=j:\\n                    dp[i][j]=min(dp[i][j],val+grid[i][j])\\n                val,idx=arr[1]\\n                if idx!=j:\\n                    dp[i][j]=min(dp[i][j],val+grid[i][j])\\n        return min(dp[n-1])\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        if n==1: return grid[0][0]\\n        dp=[[sys.maxsize]*n for _ in range(n)]\\n        for j in range(n):\\n            dp[0][j]=grid[0][j]\\n        for i in range(1,n):\\n            arr=[(val,idx) for idx,val in enumerate(dp[i-1])]\\n            arr.sort()\\n            for j in range(n):\\n                val,idx=arr[0]\\n                if idx!=j:\\n                    dp[i][j]=min(dp[i][j],val+grid[i][j])\\n                val,idx=arr[1]\\n                if idx!=j:\\n                    dp[i][j]=min(dp[i][j],val+grid[i][j])\\n        return min(dp[n-1])\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396568,
                "title": "recursion-memoizatoin",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int f(vector<vector<int>>& arr, int i, int j) {\\n        if(i == arr.size())\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = 0; k < arr[0].size(); k++) {\\n            if(k == j)\\n                continue;\\n            int curr = arr[i][j] + f(arr, i + 1, k);\\n            ans = min(ans, curr);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n       \\n        if(arr.size()==1)\\n        {\\n             int mn=INT_MAX;\\n            for(int i=0;i<arr[0].size();i++)\\n                mn=min(mn,arr[0][i]);\\n            \\n            return mn;\\n        }\\n        int ans = INT_MAX;\\n        memset(dp, -1, sizeof dp);\\n        for(int j = 0; j < arr[0].size(); j++) {\\n            ans = min(ans, f(arr, 0, j));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[201][201];\\n    int f(vector<vector<int>>& arr, int i, int j) {\\n        if(i == arr.size())\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        for(int k = 0; k < arr[0].size(); k++) {\\n            if(k == j)\\n                continue;\\n            int curr = arr[i][j] + f(arr, i + 1, k);\\n            ans = min(ans, curr);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n       \\n        if(arr.size()==1)\\n        {\\n             int mn=INT_MAX;\\n            for(int i=0;i<arr[0].size();i++)\\n                mn=min(mn,arr[0][i]);\\n            \\n            return mn;\\n        }\\n        int ans = INT_MAX;\\n        memset(dp, -1, sizeof dp);\\n        for(int j = 0; j < arr[0].size(); j++) {\\n            ans = min(ans, f(arr, 0, j));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394465,
                "title": "java-top-down-and-bottom-up",
                "content": "```\\n\\n1] TOP Down recursive -\\n\\n\\tclass Solution {\\n\\t\\tpublic int minFallingPathSum(int[][] arr) {\\n\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\t\\tint[][] memo = new int[arr.length][arr[0].length];\\n\\n\\t\\t\\tfor (int[] m : memo) {\\n\\t\\t\\t  Arrays.fill(m, -1);    \\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i=0;i<arr[0].length;i++) {\\n\\n\\t\\t\\t\\tint lm = mfp(arr, 0, i, memo);\\n\\n\\t\\t\\t\\tif (lm < min)\\n\\t\\t\\t\\t\\tmin = lm;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn min;\\n\\t\\t}\\n\\n\\t\\tpublic int mfp(int[][] arr, int cr, int cc, int[][] memo) {\\n\\n\\t\\t\\tif (cr == arr.length)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tif (memo[cr][cc] != -1) {\\n\\t\\t\\t\\treturn memo[cr][cc];\\n\\t\\t\\t}\\n\\n\\t\\t\\tint cv = arr[cr][cc];\\n\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\t\\tfor (int c=0;c<arr[0].length;c++) {\\n\\t\\t\\t\\tif (c != cc) {\\n\\t\\t\\t\\t\\tint rv = mfp(arr, cr+1, c, memo);\\n\\n\\t\\t\\t\\t\\tif (rv < min) {\\n\\t\\t\\t\\t\\t\\tmin = rv;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tmemo[cr][cc] = min+cv;\\n\\n\\t\\t\\treturn memo[cr][cc];\\n\\t\\t}\\n}\\n\\n2] Bottom up iterative\\n\\nclass Solution {\\n    \\n    public int minFallingPathSum(int[][] grid) {\\n        \\n        int[][] memo = new int[grid.length][grid[0].length];\\n        \\n        for (int c=0;c<grid[0].length;c++) {\\n            memo[grid.length-1][c] = grid[grid.length-1][c];\\n        }\\n        \\n        int gmin = Integer.MAX_VALUE;\\n        \\n        for (int i=memo.length-2;i>=0;i--) {\\n            for (int j = 0; j<memo[0].length;j++) {\\n                \\n                int min = Integer.MAX_VALUE;\\n                \\n                for (int k=0;k<memo[0].length;k++) {\\n                    if (k!= j && memo[i+1][k] < min) min = memo[i+1][k]; \\n                }\\n                \\n                memo[i][j] = min + grid[i][j];\\n            }\\n        }\\n        \\n        for (int i=0;i<memo.length;i++) {\\n            if (memo[0][i] < gmin) gmin = memo[0][i];\\n        }\\n        \\n        return gmin;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minFallingPathSum(int[][] arr) {\\n\\n\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\t\\tint[][] memo = new int[arr.length][arr[0].length];\\n\\n\\t\\t\\tfor (int[] m : memo) {\\n\\t\\t\\t  Arrays.fill(m, -1);    \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1353180,
                "title": "c-dp-pick-two-minima-and-solve",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        vector<vector<int> > dp(n,vector<int>(n,0));\\n        \\n        int min1 = INT_MAX, min2 = INT_MAX;\\n        //for first row only\\n        for(int j = 0; j < n; j++){\\n            dp[0][j] = arr[0][j];\\n            if(dp[0][j] < min1){\\n                min2 = min1;\\n                min1 = dp[0][j];\\n            }\\n            else if(dp[0][j] < min2){\\n                min2 = dp[0][j];\\n            }\\n        }\\n        int new_min1 = INT_MAX, new_min2 = INT_MAX;\\n        \\n        //Doing for all rows from 1 to n-1.\\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                dp[i][j] = arr[i][j];\\n                if(dp[i-1][j] == min1)\\n                    dp[i][j] += min2;\\n                else\\n                    dp[i][j] += min1;\\n                if(dp[i][j] < new_min1){\\n                    new_min2 = new_min1;\\n                    new_min1 = dp[i][j];\\n                }\\n                else if(dp[i][j] < new_min2)\\n                    new_min2 = dp[i][j];   \\n            }\\n            min2 = new_min2;\\n            min1 = new_min1;\\n                \\n            new_min1 = INT_MAX;\\n            new_min2 = INT_MAX;\\n        }\\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        vector<vector<int> > dp(n,vector<int>(n,0));\\n        \\n        int min1 = INT_MAX, min2 = INT_MAX;\\n        //for first row only\\n        for(int j = 0; j < n; j++){\\n            dp[0][j] = arr[0][j];\\n            if(dp[0][j] < min1){\\n                min2 = min1;\\n                min1 = dp[0][j];\\n            }\\n            else if(dp[0][j] < min2){\\n                min2 = dp[0][j];\\n            }\\n        }\\n        int new_min1 = INT_MAX, new_min2 = INT_MAX;\\n        \\n        //Doing for all rows from 1 to n-1.\\n        for(int i = 1; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                dp[i][j] = arr[i][j];\\n                if(dp[i-1][j] == min1)\\n                    dp[i][j] += min2;\\n                else\\n                    dp[i][j] += min1;\\n                if(dp[i][j] < new_min1){\\n                    new_min2 = new_min1;\\n                    new_min1 = dp[i][j];\\n                }\\n                else if(dp[i][j] < new_min2)\\n                    new_min2 = dp[i][j];   \\n            }\\n            min2 = new_min2;\\n            min1 = new_min1;\\n                \\n            new_min1 = INT_MAX;\\n            new_min2 = INT_MAX;\\n        }\\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326438,
                "title": "java-easy-dfs-with-memo",
                "content": "```\\nclass Solution {\\n    \\n    public int minFallingPathSum(int[][] arr1) {\\n                \\n        Integer[][]dp =new Integer[arr1.length][arr1[0].length];\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<arr1[0].length;i++)\\n        {\\n           min=Math.min(min,DFS(arr1,0,i,dp)); \\n        }\\n        \\n        return min;\\n    }   \\n    public int DFS(int [][]arr1,int i,int j,Integer[][] dp)\\n    {\\n         if(i==arr1.length)\\n         {\\n             return 0;\\n         }\\n         \\n        if(dp[i][j]!=null)\\n        {\\n            return dp[i][j];\\n        }\\n         \\n        int res=Integer.MAX_VALUE;\\n        for(int k=0;k<arr1[0].length;k++)\\n        {\\n            if(k!=j)\\n            {\\n                res=Math.min(res,arr1[i][k]+DFS(arr1,i+1,k,dp));\\n            }            \\n        }\\n        dp[i][j]=res;\\n        return dp[i][j];\\n    }\\n}\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int minFallingPathSum(int[][] arr1) {\\n                \\n        Integer[][]dp =new Integer[arr1.length][arr1[0].length];\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<arr1[0].length;i++)\\n        {\\n           min=Math.min(min,DFS(arr1,0,i,dp)); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1269574,
                "title": "dp-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        int m = arr[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,1003));\\n        dp[n-1] = arr[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<m;j++){\\n                 for(int k=0;k<m;k++){\\n                     if(k!=j){\\n                         dp[i][j] = min(dp[i][j],dp[i+1][k]+arr[i][j]);\\n                     }\\n                 }   \\n            }\\n        }\\n        int mn = 1004;            \\n        for(int i=0;i<m;i++){\\n            mn = min(mn,dp[0][i]);\\n        }\\n         return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int n = arr.size();\\n        int m = arr[0].size();\\n        vector<vector<int>> dp(n, vector<int> (m,1003));\\n        dp[n-1] = arr[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<m;j++){\\n                 for(int k=0;k<m;k++){\\n                     if(k!=j){\\n                         dp[i][j] = min(dp[i][j],dp[i+1][k]+arr[i][j]);\\n                     }\\n                 }   \\n            }\\n        }\\n        int mn = 1004;            \\n        for(int i=0;i<m;i++){\\n            mn = min(mn,dp[0][i]);\\n        }\\n         return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236217,
                "title": "simple-c-solution-reccurssion-dp",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<int>>arr;\\n    vector<vector<int>>dp;\\n    int findmin(int row,int prevcol){\\n        if(row==n){\\n            return 0;\\n        }\\n        if(prevcol!=-1){\\n            if(dp[row][prevcol]!=-1) return dp[row][prevcol];\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int j = 0;j<m;j++){\\n            if(j == prevcol) continue;\\n            ans = min(ans,arr[row][j] + findmin(row+1,j));\\n        }\\n        if(prevcol==-1) return ans;\\n        return dp[row][prevcol] = ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& _arr) {\\n        arr = _arr; \\n        n = arr.size();\\n        m = arr[0].size();\\n        dp.resize(n+3,vector<int>(m+3,-1));\\n        return findmin(0,-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<int>>arr;\\n    vector<vector<int>>dp;\\n    int findmin(int row,int prevcol){\\n        if(row==n){\\n            return 0;\\n        }\\n        if(prevcol!=-1){\\n            if(dp[row][prevcol]!=-1) return dp[row][prevcol];\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int j = 0;j<m;j++){\\n            if(j == prevcol) continue;\\n            ans = min(ans,arr[row][j] + findmin(row+1,j));\\n        }\\n        if(prevcol==-1) return ans;\\n        return dp[row][prevcol] = ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& _arr) {\\n        arr = _arr; \\n        n = arr.size();\\n        m = arr[0].size();\\n        dp.resize(n+3,vector<int>(m+3,-1));\\n        return findmin(0,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191551,
                "title": "easy-java-solution",
                "content": "```java\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    private int minPath(int[][] arr, int currRow, int lastPickedCol, int C, int[][] dp) {\\n        int path = Integer.MAX_VALUE;\\n        for (int col = 0; col < C; col++) {\\n            if (col != lastPickedCol) {\\n                if (currRow == 0) {\\n                    path = Math.min(path, arr[currRow][col]);\\n                    continue;\\n                }\\n                if (dp[currRow - 1][col] == Integer.MAX_VALUE) {\\n                    dp[currRow - 1][col] = minPath(arr, currRow - 1, col, C, dp);\\n                }\\n                path = Math.min(path, arr[currRow][col] + dp[currRow - 1][col]);\\n            }\\n        }\\n        return path;\\n    }\\n\\n    public int minFallingPathSum(int[][] arr) {\\n        int C = arr[0].length;\\n        int R = arr.length;\\n        int[][] dp = new int[R][C];\\n        for (int i = 0; i < R; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        }\\n        return minPath(arr, R - 1, -1, C, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n    private int minPath(int[][] arr, int currRow, int lastPickedCol, int C, int[][] dp) {\\n        int path = Integer.MAX_VALUE;\\n        for (int col = 0; col < C; col++) {\\n            if (col != lastPickedCol) {\\n                if (currRow == 0) {\\n                    path = Math.min(path, arr[currRow][col]);\\n                    continue;\\n                }\\n                if (dp[currRow - 1][col] == Integer.MAX_VALUE) {\\n                    dp[currRow - 1][col] = minPath(arr, currRow - 1, col, C, dp);\\n                }\\n                path = Math.min(path, arr[currRow][col] + dp[currRow - 1][col]);\\n            }\\n        }\\n        return path;\\n    }\\n\\n    public int minFallingPathSum(int[][] arr) {\\n        int C = arr[0].length;\\n        int R = arr.length;\\n        int[][] dp = new int[R][C];\\n        for (int i = 0; i < R; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        }\\n        return minPath(arr, R - 1, -1, C, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991186,
                "title": "python-dp-bottom-up-approach",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, a: List[List[int]]) -> int:\\n        m = len(a)\\n        n = len(a[0])\\n        dp = [[0 for i in range(n)] for j in range(m)]\\n        for i in range(n):\\n            dp[-1][i]=a[-1][i]\\n        for j in range(m-2,-1,-1):\\n            for  i in range(n):\\n                arr = dp[j+1].copy()\\n                arr.pop(i)\\n                dp[j][i] = min(arr)+a[j][i]\\n        return min(dp[0])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, a: List[List[int]]) -> int:\\n        m = len(a)\\n        n = len(a[0])\\n        dp = [[0 for i in range(n)] for j in range(m)]\\n        for i in range(n):\\n            dp[-1][i]=a[-1][i]\\n        for j in range(m-2,-1,-1):\\n            for  i in range(n):\\n                arr = dp[j+1].copy()\\n                arr.pop(i)\\n                dp[j][i] = min(arr)+a[j][i]\\n        return min(dp[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 912626,
                "title": "python-dp-simple-and-short-solution-o-n-n",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, arr):\\n        n = len(arr)\\n        for row in range(n - 2, -1, -1):\\n            for col in range(n):\\n                arr[row][col] += min(arr[row + 1][:col] + arr[row + 1][col + 1:])\\n        return min(arr[0])\\n```\\n\\nStart loop from second last row, and simply update ```arr[row][col]``` we currently in with minimum value from next row ```row+1``` excluding the column we currently in by using python\\'s magic ```arr[row + 1][:col] + arr[row + 1][col + 1:]``` When loop finishes return minimum value from ```row=0```\\nI believe it is O(n*n) and constant space O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, arr):\\n        n = len(arr)\\n        for row in range(n - 2, -1, -1):\\n            for col in range(n):\\n                arr[row][col] += min(arr[row + 1][:col] + arr[row + 1][col + 1:])\\n        return min(arr[0])\\n```\n```arr[row][col]```\n```row+1```\n```arr[row + 1][:col] + arr[row + 1][col + 1:]```\n```row=0```",
                "codeTag": "Java"
            },
            {
                "id": 912120,
                "title": "using-multiset-c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr)\\n    {\\n        int r=arr.size();\\n        int c=r;\\n        int ans=INT_MAX;\\n        multiset<int>s,S;\\n        for(int i=0;i<r;i++)\\n        {\\n            S=s;\\n            s.clear();\\n            for(int j=0;j<c;j++)\\n            {\\n                if(i==0)\\n                {\\n                     s.insert(arr[i][j]);\\n                    continue;\\n                }\\n                S.erase(S.find(arr[i-1][j]));\\n                arr[i][j]=arr[i][j]+*S.begin();\\n                s.insert(arr[i][j]);\\n                S.insert(arr[i-1][j]);\\n                if(i==r-1)\\n                    ans=min(ans,arr[i][j]);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr)\\n    {\\n        int r=arr.size();\\n        int c=r;\\n        int ans=INT_MAX;\\n        multiset<int>s,S;\\n        for(int i=0;i<r;i++)\\n        {\\n            S=s;\\n            s.clear();\\n            for(int j=0;j<c;j++)\\n            {\\n                if(i==0)\\n                {\\n                     s.insert(arr[i][j]);\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 872740,
                "title": "faster-than-100-00-of-python3-online-submissions",
                "content": "```\\nclass Solution(object):\\n    def minFallingPathSum(self, arr):\\n        \"\"\"\\n        :type arr: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(arr), len(arr[0])\\n        i = 1\\n        while i < m:\\n            a = arr[i - 1][:]\\n            min1 = a.index(min(a))\\n            a[min1] = float(\\'inf\\')\\n            min2 = a.index(min(a))\\n            a = arr[i - 1]\\n            for j in range(n):\\n                if j == min1:\\n                    arr[i][j] += a[min2]\\n                else:\\n                    arr[i][j] += a[min1]\\n            i += 1\\n        return min(arr[-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minFallingPathSum(self, arr):\\n        \"\"\"\\n        :type arr: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m, n = len(arr), len(arr[0])\\n        i = 1\\n        while i < m:\\n            a = arr[i - 1][:]\\n            min1 = a.index(min(a))\\n            a[min1] = float(\\'inf\\')\\n            min2 = a.index(min(a))\\n            a = arr[i - 1]\\n            for j in range(n):\\n                if j == min1:\\n                    arr[i][j] += a[min2]\\n                else:\\n                    arr[i][j] += a[min1]\\n            i += 1\\n        return min(arr[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845611,
                "title": "java-solution-dp",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        // states\\n        int[][] f = new int[n][m];\\n        Queue<int[]> prevQueue = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] i, int[] j) {\\n                return j[1] - i[1];\\n            }\\n        });\\n        // initialize\\n        for (int j = 0; j < m; j++) {\\n            f[0][j] = arr[0][j];\\n            prevQueue.offer(new int[]{j, f[0][j]});\\n            if (prevQueue.size() > 2) {\\n                prevQueue.poll();\\n            }\\n        }\\n        // function\\n        for (int i = 1; i < n; i++) {\\n            Queue<int[]> newQueue = new PriorityQueue<>(new Comparator<int[]>() {\\n                @Override\\n                public int compare(int[] i, int[] j) {\\n                    return j[1] - i[1];\\n                }\\n            });\\n            int[] prevMin2 = prevQueue.poll();\\n            int[] prevMin1 = prevQueue.poll();\\n            for (int j = 0; j < m; j++) {\\n                if (prevMin1[0] != j) {\\n                    f[i][j] = prevMin1[1] + arr[i][j];\\n                } else {\\n                    f[i][j] = prevMin2[1] + arr[i][j];\\n                }\\n                newQueue.offer(new int[]{j, f[i][j]});\\n                if (newQueue.size() > 2) {\\n                    newQueue.poll();\\n                }\\n            }\\n            prevQueue = newQueue;\\n        }\\n        // answer\\n        int ans = Integer.MAX_VALUE;\\n        for (int i : f[n - 1]) {\\n            ans = Math.min(ans, i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        // states\\n        int[][] f = new int[n][m];\\n        Queue<int[]> prevQueue = new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] i, int[] j) {\\n                return j[1] - i[1];\\n            }\\n        });\\n        // initialize\\n        for (int j = 0; j < m; j++) {\\n            f[0][j] = arr[0][j];\\n            prevQueue.offer(new int[]{j, f[0][j]});\\n            if (prevQueue.size() > 2) {\\n                prevQueue.poll();\\n            }\\n        }\\n        // function\\n        for (int i = 1; i < n; i++) {\\n            Queue<int[]> newQueue = new PriorityQueue<>(new Comparator<int[]>() {\\n                @Override\\n                public int compare(int[] i, int[] j) {\\n                    return j[1] - i[1];\\n                }\\n            });\\n            int[] prevMin2 = prevQueue.poll();\\n            int[] prevMin1 = prevQueue.poll();\\n            for (int j = 0; j < m; j++) {\\n                if (prevMin1[0] != j) {\\n                    f[i][j] = prevMin1[1] + arr[i][j];\\n                } else {\\n                    f[i][j] = prevMin2[1] + arr[i][j];\\n                }\\n                newQueue.offer(new int[]{j, f[i][j]});\\n                if (newQueue.size() > 2) {\\n                    newQueue.poll();\\n                }\\n            }\\n            prevQueue = newQueue;\\n        }\\n        // answer\\n        int ans = Integer.MAX_VALUE;\\n        for (int i : f[n - 1]) {\\n            ans = Math.min(ans, i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804442,
                "title": "python-dynamic-programming-time-o-m-n-space-o-1",
                "content": "```\\nclass Solution(object):\\n    def minFallingPathSum(self, arr):\\n        \"\"\"\\n        :type arr: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m = len(arr)\\n        n = len(arr[0])\\n        \\n        for r in range(1,m):\\n            min1 = None\\n            min2 = None\\n            \\n            for c in range(n):\\n                cost = arr[r-1][c]\\n                \\n                if min1 is None or arr[r-1][min1]>cost:\\n                    min2 = min1\\n                    min1 = c\\n                elif min2 is None or arr[r-1][min2]>cost:\\n                    min2 = c\\n                    \\n            for c in range(n):\\n                \\n                if c == min1:\\n                    arr[r][c]+=arr[r-1][min2]\\n                else:\\n                    arr[r][c]+=arr[r-1][min1]\\n                    \\n                    \\n                    \\n        return min(arr[-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minFallingPathSum(self, arr):\\n        \"\"\"\\n        :type arr: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        m = len(arr)\\n        n = len(arr[0])\\n        \\n        for r in range(1,m):\\n            min1 = None\\n            min2 = None\\n            \\n            for c in range(n):\\n                cost = arr[r-1][c]\\n                \\n                if min1 is None or arr[r-1][min1]>cost:\\n                    min2 = min1\\n                    min1 = c\\n                elif min2 is None or arr[r-1][min2]>cost:\\n                    min2 = c\\n                    \\n            for c in range(n):\\n                \\n                if c == min1:\\n                    arr[r][c]+=arr[r-1][min2]\\n                else:\\n                    arr[r][c]+=arr[r-1][min1]\\n                    \\n                    \\n                    \\n        return min(arr[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787438,
                "title": "c-easy-to-understand-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int lmin[n], rmin[n];\\n        \\n        lmin[0] = INT_MAX, rmin[n - 1] = INT_MAX;\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < n; j++){\\n                lmin[j] = min(mat[i - 1][j - 1], lmin[j - 1]);\\n                rmin[n - 1 - j] = min(mat[i - 1][n - j], rmin[n - j]);\\n            }\\n            for(int j = 0; j < n; j++)\\n                mat[i][j] += min(lmin[j], rmin[j]);\\n        }\\n        return *min_element(mat[n - 1].begin(), mat[n - 1].end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int lmin[n], rmin[n];\\n        \\n        lmin[0] = INT_MAX, rmin[n - 1] = INT_MAX;\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < n; j++){\\n                lmin[j] = min(mat[i - 1][j - 1], lmin[j - 1]);\\n                rmin[n - 1 - j] = min(mat[i - 1][n - j], rmin[n - j]);\\n            }\\n            for(int j = 0; j < n; j++)\\n                mat[i][j] += min(lmin[j], rmin[j]);\\n        }\\n        return *min_element(mat[n - 1].begin(), mat[n - 1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755560,
                "title": "very-clean-dp-solution-commented",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {       //function with square grid input\\n        \\n        int n = arr.size() ;                        //int n is size of the array, number of rows\\n        vector<int> dp ;                            //dp vector of ints\\n        dp = arr[n-1] ;                             //dp is assigned as the array last row\\n        \\n        for(int i=n-2;i>=0;i--){                    //outer for loop starting from second to last row, decrementing\\n            \\n            int firstmin=INT_MAX,secondmin=INT_MAX,firstminindex ;    //min defines\\n            \\n            for (int j=0;j<n;j++){                  //for loop\\n                if (firstmin>dp[j]){                    //calculating first min \\n                    firstmin = dp[j] ;                  //find the smallest value in the row\\n                    firstminindex = j ;                 //find the index of the smallest value\\n                }\\n                \\n            }\\n            \\n            for (int j=0;j<n;j++){                  //for loop\\n                if (j==firstminindex)continue ;     //if col index the same as prev. min, just continue to next col.\\n                secondmin = min(secondmin,dp[j]) ;  //find the next highest number\\n            }\\n            \\n            for (int j=0;j<n;j++){                  //for loop\\n                if (j==firstminindex) dp[j]=arr[i][j]+secondmin ;  //if index is a hit, then set the number equal to the array plus second lowest number\\n                else dp[j] = arr[i][j]+firstmin ;                  //else set the number equal to the array plus the firstmin\\n            }\\n        }\\n        \\n        sort (dp.begin(),dp.end());             //sort low to high\\n        \\n        return dp.front(); //return the smallest val from dp\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {       //function with square grid input\\n        \\n        int n = arr.size() ;                        //int n is size of the array, number of rows\\n        vector<int> dp ;                            //dp vector of ints\\n        dp = arr[n-1] ;                             //dp is assigned as the array last row\\n        \\n        for(int i=n-2;i>=0;i--){                    //outer for loop starting from second to last row, decrementing\\n            \\n            int firstmin=INT_MAX,secondmin=INT_MAX,firstminindex ;    //min defines\\n            \\n            for (int j=0;j<n;j++){                  //for loop\\n                if (firstmin>dp[j]){                    //calculating first min \\n                    firstmin = dp[j] ;                  //find the smallest value in the row\\n                    firstminindex = j ;                 //find the index of the smallest value\\n                }\\n                \\n            }\\n            \\n            for (int j=0;j<n;j++){                  //for loop\\n                if (j==firstminindex)continue ;     //if col index the same as prev. min, just continue to next col.\\n                secondmin = min(secondmin,dp[j]) ;  //find the next highest number\\n            }\\n            \\n            for (int j=0;j<n;j++){                  //for loop\\n                if (j==firstminindex) dp[j]=arr[i][j]+secondmin ;  //if index is a hit, then set the number equal to the array plus second lowest number\\n                else dp[j] = arr[i][j]+firstmin ;                  //else set the number equal to the array plus the firstmin\\n            }\\n        }\\n        \\n        sort (dp.begin(),dp.end());             //sort low to high\\n        \\n        return dp.front(); //return the smallest val from dp\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723392,
                "title": "java-dp-solution-o-m-n-time-complexity-with-explanation",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        \\n        // Initializing minimum number and second minimum number in first row, and resp. column indices.\\n        // Example: [1, 3, 2] => (min1 = 1, col1 = 0), (min1 = 2, col2 = 2)\\n        int min1 = Integer.MAX_VALUE, col1 = -1, min2 = Integer.MAX_VALUE, col2 = -1;\\n        for(int j=0; j<A[0].length; j++) {\\n            if (A[0][j] < min1) {\\n                min2 = min1;\\n                col2 = col1;\\n                min1 = A[0][j];\\n                col1 = j;\\n            } else if (A[0][j] < min2) {\\n                min2 = A[0][j];\\n                col2 = j;\\n            }\\n        }\\n        \\n        for(int i=1; i<A.length; i++) {\\n            int newMin1 = Integer.MAX_VALUE, newCol1 = -1, newMin2 = Integer.MAX_VALUE, newCol2 = -1;\\n            \\n            for(int j=0; j<A[0].length; j++) {\\n                // If same column as minimum number, choose second minimum number\\n                if (j == col1) A[i][j] += min2;\\n                // For the rest of the row members, choose first mimimum number\\n                else A[i][j] += min1;\\n                \\n                // Store new minimum numbers and respective column indices\\n                if (A[i][j] < newMin1) {\\n                    newMin2 = newMin1;\\n                    newCol2 = newCol1;\\n                    newMin1 = A[i][j];\\n                    newCol1 = j;\\n                } else if (A[i][j] < newMin2) {\\n                    newMin2 = A[i][j];\\n                    newCol2 = j;\\n                }\\n            }\\n            // Update original minimum numbers and respective column indices\\n            min1 = newMin1; min2 = newMin2;\\n            col1 = newCol1; col2 = newCol2;\\n        }\\n        return min1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        \\n        // Initializing minimum number and second minimum number in first row, and resp. column indices.\\n        // Example: [1, 3, 2] => (min1 = 1, col1 = 0), (min1 = 2, col2 = 2)\\n        int min1 = Integer.MAX_VALUE, col1 = -1, min2 = Integer.MAX_VALUE, col2 = -1;\\n        for(int j=0; j<A[0].length; j++) {\\n            if (A[0][j] < min1) {\\n                min2 = min1;\\n                col2 = col1;\\n                min1 = A[0][j];\\n                col1 = j;\\n            } else if (A[0][j] < min2) {\\n                min2 = A[0][j];\\n                col2 = j;\\n            }\\n        }\\n        \\n        for(int i=1; i<A.length; i++) {\\n            int newMin1 = Integer.MAX_VALUE, newCol1 = -1, newMin2 = Integer.MAX_VALUE, newCol2 = -1;\\n            \\n            for(int j=0; j<A[0].length; j++) {\\n                // If same column as minimum number, choose second minimum number\\n                if (j == col1) A[i][j] += min2;\\n                // For the rest of the row members, choose first mimimum number\\n                else A[i][j] += min1;\\n                \\n                // Store new minimum numbers and respective column indices\\n                if (A[i][j] < newMin1) {\\n                    newMin2 = newMin1;\\n                    newCol2 = newCol1;\\n                    newMin1 = A[i][j];\\n                    newCol1 = j;\\n                } else if (A[i][j] < newMin2) {\\n                    newMin2 = A[i][j];\\n                    newCol2 = j;\\n                }\\n            }\\n            // Update original minimum numbers and respective column indices\\n            min1 = newMin1; min2 = newMin2;\\n            col1 = newCol1; col2 = newCol2;\\n        }\\n        return min1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717035,
                "title": "recursion-memorization-solution",
                "content": "```\\nclass Solution {\\n    int [][]dp;\\n    public boolean isValid(int m,int n,int i,int j){\\n        return i>=0 && i<m && j>=0 && j<n;\\n    }\\n    public int solve(int [][]arr,int i,int j){\\n        int m = arr.length,n = arr[0].length;\\n        if(i==m-1){\\n            dp[i][j] = arr[i][j];\\n            return dp[i][j];\\n        }\\n        if(dp[i][j]!=Integer.MAX_VALUE){\\n            return dp[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int k=0;k<n;k++){\\n            if(k!=j){\\n                dp[i+1][k] = solve(arr,i+1,k);\\n                min = Math.min(dp[i+1][k],min);\\n            }\\n        }\\n        dp[i][j] = arr[i][j] + min;\\n        return dp[i][j];\\n    }\\n    public int minFallingPathSum(int[][] arr) {\\n        int m = arr.length, n = arr[0].length;\\n        dp = new int[m][n];\\n        for(int []d : dp){\\n            Arrays.fill(d,Integer.MAX_VALUE);\\n        }\\n        int solution = Integer.MAX_VALUE;   \\n        for(int j=0;j<n;j++){\\n            int val = solve(arr,0,j);\\n            solution = Math.min(solution,val);\\n        }\\n        return solution;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int [][]dp;\\n    public boolean isValid(int m,int n,int i,int j){\\n        return i>=0 && i<m && j>=0 && j<n;\\n    }\\n    public int solve(int [][]arr,int i,int j){\\n        int m = arr.length,n = arr[0].length;\\n        if(i==m-1){\\n            dp[i][j] = arr[i][j];\\n            return dp[i][j];\\n        }\\n        if(dp[i][j]!=Integer.MAX_VALUE){\\n            return dp[i][j];\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int k=0;k<n;k++){\\n            if(k!=j){\\n                dp[i+1][k] = solve(arr,i+1,k);\\n                min = Math.min(dp[i+1][k],min);\\n            }\\n        }\\n        dp[i][j] = arr[i][j] + min;\\n        return dp[i][j];\\n    }\\n    public int minFallingPathSum(int[][] arr) {\\n        int m = arr.length, n = arr[0].length;\\n        dp = new int[m][n];\\n        for(int []d : dp){\\n            Arrays.fill(d,Integer.MAX_VALUE);\\n        }\\n        int solution = Integer.MAX_VALUE;   \\n        for(int j=0;j<n;j++){\\n            int val = solve(arr,0,j);\\n            solution = Math.min(solution,val);\\n        }\\n        return solution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 704434,
                "title": "easy-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        \\n        int m=arr.size();\\n        int n= arr[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,INT_MAX));\\n        int mine1=INT_MAX,mine2=INT_MAX,mine2l=-1,mine1l=-1;\\n        for(int j=0;j<n;j++)\\n        {\\n            dp[0][j]=arr[0][j];\\n            if(arr[0][j]<mine1)\\n            {\\n                mine2=mine1;\\n                mine1=arr[0][j];\\n                mine2l=mine1l;\\n                mine1l=j;\\n            }\\n            if(arr[0][j]<mine2 && (arr[0][j]>mine1|| (arr[0][j]==mine1&& j!=mine1l)))\\n            {\\n                mine2=arr[0][j];\\n                mine2l=j;\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            int nmine1=INT_MAX,nmine2=INT_MAX,nmine2l=-1,nmine1l=-1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j!=mine1l)\\n                    dp[i][j]=arr[i][j]+mine1;\\n                else\\n                    dp[i][j]=arr[i][j]+mine2;\\n                if(dp[i][j]<nmine1)\\n                {\\n                nmine2=nmine1;\\n                nmine1=dp[i][j];\\n                nmine2l=nmine1l;\\n                nmine1l=j;\\n                }\\n                if(dp[i][j]<nmine2 && (dp[i][j]>nmine1|| (dp[i][j]==nmine1&& j!=nmine1l)))\\n                {\\n                nmine2=dp[i][j];\\n                nmine2l=j;\\n                }\\n            }\\n            mine1=nmine1;\\n            mine2=nmine2;\\n            mine1l=nmine1l;\\n            mine2l=nmine2l;\\n        \\n    }\\n        \\n        return mine1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        \\n        int m=arr.size();\\n        int n= arr[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,INT_MAX));\\n        int mine1=INT_MAX,mine2=INT_MAX,mine2l=-1,mine1l=-1;\\n        for(int j=0;j<n;j++)\\n        {\\n            dp[0][j]=arr[0][j];\\n            if(arr[0][j]<mine1)\\n            {\\n                mine2=mine1;\\n                mine1=arr[0][j];\\n                mine2l=mine1l;\\n                mine1l=j;\\n            }\\n            if(arr[0][j]<mine2 && (arr[0][j]>mine1|| (arr[0][j]==mine1&& j!=mine1l)))\\n            {\\n                mine2=arr[0][j];\\n                mine2l=j;\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            int nmine1=INT_MAX,nmine2=INT_MAX,nmine2l=-1,nmine1l=-1;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j!=mine1l)\\n                    dp[i][j]=arr[i][j]+mine1;\\n                else\\n                    dp[i][j]=arr[i][j]+mine2;\\n                if(dp[i][j]<nmine1)\\n                {\\n                nmine2=nmine1;\\n                nmine1=dp[i][j];\\n                nmine2l=nmine1l;\\n                nmine1l=j;\\n                }\\n                if(dp[i][j]<nmine2 && (dp[i][j]>nmine1|| (dp[i][j]==nmine1&& j!=nmine1l)))\\n                {\\n                nmine2=dp[i][j];\\n                nmine2l=j;\\n                }\\n            }\\n            mine1=nmine1;\\n            mine2=nmine2;\\n            mine1l=nmine1l;\\n            mine2l=nmine2l;\\n        \\n    }\\n        \\n        return mine1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696538,
                "title": "python-dp-explanation-o-n-2",
                "content": "# NAIVE APPROACH\\n1. For each row, select the **smallest element**, then sum them up.\\n\\n\\n2. Now, consider the following 2D matrix\\n\\n```\\n\\t>1   2   3\\n\\t>4   5   6\\n\\t>7   8   9\\n\\nSmallest Sum = 1 + 4 + 7 = 11\\n```\\n3. Shortest path is marked as above, but this violates the \"**adjacent minimums must lie in different columns**\" rule\\n\\n```\\n\\t>1   2   3\\n\\t>4   5   6\\n\\t>7   8   9\\n\\nSmallest Sum = 1 + 4 + 7 = 11\\n```\\n\\n<br>\\n\\n# IMPROVED APPROACH\\n1. For each row, select the **2 smallest elements**, then sum either the smallest, or the second smallest, at every row. \\n\\n2. Let\\'s work our way **upwards** from the 2nd-last row. This means the **FIRST row shall hold the minimum total sums at each cell**.\\n\\n3. Why did we ignore the last row? Ask yourself, what is the minimum of each cell in last row = itself, no processing is needed.\\n\\n4. At each row, I\\'ll ask myself\\n\\n\\t* Can I add myself to the smallest in the **next row**?\\n\\t* I can, iff this **smallest is from a different column than myself**.\\n\\t* Otherwise, I must choose the second smallest in the **next row**.\\n<br>\\n\\n# SOLUTION\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\n\\nclass Solution:\\n    \\n    def getSmallestTwo(self, arr):\\n        smallest = min(arr)\\n        smallestIndex = arr.index(smallest)\\n        nextSmallest = min([arr[i] for i in range(len(arr)) if i != smallestIndex])\\n        return (smallest, nextSmallest)\\n        \\n        \\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        \\n        # GET DIMENSIONS\\n        n = len(arr)\\n        \\n        # EDGE CASE\\n        if n == 1:\\n            return min(arr)\\n        \\n        # SETUP OUR TOTAL SUM\\n        total = 0\\n        \\n        # START FROM THE 2ND LAST ROW, AND WORK OUR WAY UPWARDS - O(N^2)\\n        for i in range(n - 2, -1, -1):\\n            for j in range(n):\\n                \\n                # GET THE 2 SMALLEST ELEMENTS IN THE ROW BELOW\\n                smallest, nextSmallest = self.getSmallestTwo(arr[i + 1])\\n                \\n                # USE SMALLEST\\n                if arr[i + 1].index(smallest) != j:\\n                    arr[i][j] += smallest\\n                \\n                # USE NEXT SMALLEST\\n                else:\\n                    arr[i][j] += nextSmallest\\n        \\n        # OPTIONAL - TAKE A LOOK AT OUR FINAL MODIFIED MATRIX TO SEE WHAT\\'S CHANGED\\n        for row in arr: print(row)\\n            \\n        return min(arr[0])\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n\\t>1   2   3\\n\\t>4   5   6\\n\\t>7   8   9\\n\\nSmallest Sum = 1 + 4 + 7 = 11\\n```\n```\\n\\t>1   2   3\\n\\t>4   5   6\\n\\t>7   8   9\\n\\nSmallest Sum = 1 + 4 + 7 = 11\\n```\n```\\nfrom heapq import heappush, heappop, heapify\\n\\n\\nclass Solution:\\n    \\n    def getSmallestTwo(self, arr):\\n        smallest = min(arr)\\n        smallestIndex = arr.index(smallest)\\n        nextSmallest = min([arr[i] for i in range(len(arr)) if i != smallestIndex])\\n        return (smallest, nextSmallest)\\n        \\n        \\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        \\n        # GET DIMENSIONS\\n        n = len(arr)\\n        \\n        # EDGE CASE\\n        if n == 1:\\n            return min(arr)\\n        \\n        # SETUP OUR TOTAL SUM\\n        total = 0\\n        \\n        # START FROM THE 2ND LAST ROW, AND WORK OUR WAY UPWARDS - O(N^2)\\n        for i in range(n - 2, -1, -1):\\n            for j in range(n):\\n                \\n                # GET THE 2 SMALLEST ELEMENTS IN THE ROW BELOW\\n                smallest, nextSmallest = self.getSmallestTwo(arr[i + 1])\\n                \\n                # USE SMALLEST\\n                if arr[i + 1].index(smallest) != j:\\n                    arr[i][j] += smallest\\n                \\n                # USE NEXT SMALLEST\\n                else:\\n                    arr[i][j] += nextSmallest\\n        \\n        # OPTIONAL - TAKE A LOOK AT OUR FINAL MODIFIED MATRIX TO SEE WHAT\\'S CHANGED\\n        for row in arr: print(row)\\n            \\n        return min(arr[0])\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 647420,
                "title": "o-mn-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int n=arr.size(), m=arr[0].size();\\n        vector<int> pre(m), suff(m);\\n        for(int j=0; j<m; j++)\\n            if(j>0)\\n                pre[j]=min(pre[j-1], arr[0][j]);\\n            else\\n                pre[j]=arr[0][j];\\n        for(int j=m-1; j>=0; j--)\\n            if(j+1<m)\\n                suff[j]=min(suff[j+1], arr[0][j]);\\n            else\\n                suff[j]=arr[0][j];\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int left=1e4, right=1e4;\\n                if(j-1>=0)\\n                    left=pre[j-1];\\n                if(j+1<m)\\n                    right=suff[j+1];\\n                arr[i][j]+=min(left, right);\\n            }\\n            pre=suff=vector<int>(m);\\n            for(int j=0; j<m; j++)\\n                if(j>0)\\n                    pre[j]=min(pre[j-1], arr[i][j]);\\n                else\\n                    pre[j]=arr[i][j];\\n            for(int j=m-1; j>=0; j--)\\n                if(j+1<m)\\n                    suff[j]=min(suff[j+1], arr[i][j]);\\n                else\\n                    suff[j]=arr[i][j];\\n        }\\n        return *min_element(arr[n-1].begin(), arr[n-1].end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int n=arr.size(), m=arr[0].size();\\n        vector<int> pre(m), suff(m);\\n        for(int j=0; j<m; j++)\\n            if(j>0)\\n                pre[j]=min(pre[j-1], arr[0][j]);\\n            else\\n                pre[j]=arr[0][j];\\n        for(int j=m-1; j>=0; j--)\\n            if(j+1<m)\\n                suff[j]=min(suff[j+1], arr[0][j]);\\n            else\\n                suff[j]=arr[0][j];\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int left=1e4, right=1e4;\\n                if(j-1>=0)\\n                    left=pre[j-1];\\n                if(j+1<m)\\n                    right=suff[j+1];\\n                arr[i][j]+=min(left, right);\\n            }\\n            pre=suff=vector<int>(m);\\n            for(int j=0; j<m; j++)\\n                if(j>0)\\n                    pre[j]=min(pre[j-1], arr[i][j]);\\n                else\\n                    pre[j]=arr[i][j];\\n            for(int j=m-1; j>=0; j--)\\n                if(j+1<m)\\n                    suff[j]=min(suff[j+1], arr[i][j]);\\n                else\\n                    suff[j]=arr[i][j];\\n        }\\n        return *min_element(arr[n-1].begin(), arr[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628722,
                "title": "three-dp-solutions-optimized-one-after-another-with-full-explanation",
                "content": "**Solution#1:** Time Complexity: `O(m*n)` Space Complexity: `O(m*n)` \\n**Idea:**\\n* let\\'s maintain a 2d matrix `dp[][]` where `dp[i][j]` would be the falling path sum ending at `arr[i][j]` (this may not be minimum)\\n* We need the minimum value of the last row of the dp and return it as answer\\n* In order to maintain `dp[i][j]`, we need the minimum path sum on the row above, and left, and row above on the right. Whichever is minimum, we will carry forward to `dp[i][j]`.\\n* So, the optimal substructure is:\\n\\t* `dp[i][j] = min(dp[i-1][0..j-1], dp[i-1][j+1..cols-1]) + arr[i][j]`\\n\\t* consider the boundary elements appropriately when coding\\n* In the end, iterate over the last row of the dp, and determine the answer. (You can maintain the answer while determining `dp[i][j]` as well with few tweaks)\\n\\n```\\npublic int minFallingPathSum(int[][] arr) {\\n\\tint rows = arr.length,\\n\\t\\tcols = arr[0].length,\\n\\t\\tans = arr[0][0];\\n\\n\\tint[][] dp = new int[rows][cols];\\n\\tdp[0] = arr[0];\\n\\n\\tint[] minTill = new int[cols],\\n\\t\\tminFrom = new int[cols];\\n\\n\\tminTill[0] = arr[0][0];\\n\\tfor (int j = 1; j < cols; j++) {\\n\\t\\tminTill[j] = Math.min(minTill[j-1], arr[0][j]);\\n\\t}\\n\\n\\tminFrom[cols-1] = arr[0][cols-1];\\n\\tfor (int j = cols-2; j >= 0; j--) {\\n\\t\\tminFrom[j] = Math.min(minFrom[j+1], arr[0][j]);\\n\\t}\\n\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tint[] nextMinTill = new int[cols];\\n\\t\\tint ansCand = Integer.MAX_VALUE;\\n\\t\\t// System.out.println(\"minTill: \" + Arrays.toString(minTill));\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint cand1 = (j > 0)\\n\\t\\t\\t\\t\\t? minTill[j-1]\\n\\t\\t\\t\\t\\t: Integer.MAX_VALUE,\\n\\t\\t\\t\\tcand2 = j < cols-1\\n\\t\\t\\t\\t\\t? minFrom[j+1]\\n\\t\\t\\t\\t\\t: Integer.MAX_VALUE;\\n\\n\\t\\t\\tdp[i][j] = Math.min(cand1, cand2) + arr[i][j];\\n\\t\\t\\tansCand = Math.min(ansCand, dp[i][j]);\\n\\n\\t\\t\\tnextMinTill[j] = (j == 0)\\n\\t\\t\\t\\t? dp[i][j]\\n\\t\\t\\t\\t: Math.min(nextMinTill[j-1], dp[i][j]);\\n\\t\\t}\\n\\n\\t\\t// update minFrom\\n\\t\\tminFrom[cols-1] = dp[i][cols-1];\\n\\t\\tfor (int j = cols-2; j >= 0; j--) {\\n\\t\\t\\tminFrom[j] = Math.min(dp[i][j], minFrom[j+1]);\\n\\t\\t}\\n\\n\\t\\tminTill = nextMinTill;\\n\\t\\tans = ansCand;\\n\\t}\\n\\treturn ans;\\n```\\n\\n**Solution#2:** Time Complexity: `O(m*n)` Space Complexity: `O(n)` \\n* If you see carefully to the optimal substructure mentioned above, we decide the value of `dp[i][j]` based only upon the previous row of the 2d matrix `dp`.\\n* This means, we don\\'t need to maintinain the entire 2d matrix `dp`, we can only maintain current and previous row of the dp, keeping the rest of the things same.\\n\\n```\\npublic int minFallingPathSum(int[][] arr) {\\n\\tint rows = arr.length,\\n\\t\\tcols = arr[0].length,\\n\\t\\tans = arr[0][0];\\n\\n\\tint[][] dp = new int[2][cols];\\n\\tdp[0] = arr[0];\\n\\n\\tint[] minTill = new int[cols],\\n\\t\\tminFrom = new int[cols];\\n\\n\\tminTill[0] = arr[0][0];\\n\\tfor (int j = 1; j < cols; j++) {\\n\\t\\tminTill[j] = Math.min(minTill[j-1], arr[0][j]);\\n\\t}\\n\\n\\tminFrom[cols-1] = arr[0][cols-1];\\n\\tfor (int j = cols-2; j >= 0; j--) {\\n\\t\\tminFrom[j] = Math.min(minFrom[j+1], arr[0][j]);\\n\\t}\\n\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tint[] nextMinTill = new int[cols];\\n\\t\\tint ansCand = Integer.MAX_VALUE;\\n\\t\\t// System.out.println(\"minTill: \" + Arrays.toString(minTill));\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint cand1 = (j > 0)\\n\\t\\t\\t\\t\\t? minTill[j-1]\\n\\t\\t\\t\\t\\t: Integer.MAX_VALUE,\\n\\t\\t\\t\\tcand2 = j < cols-1\\n\\t\\t\\t\\t\\t? minFrom[j+1]\\n\\t\\t\\t\\t\\t: Integer.MAX_VALUE;\\n\\n\\t\\t\\tdp[1][j] = Math.min(cand1, cand2) + arr[i][j];\\n\\t\\t\\tansCand = Math.min(ansCand, dp[1][j]);\\n\\n\\t\\t\\tdp[0] = dp[1];\\n\\t\\t}\\n\\n\\t\\t// update minTill\\n\\t\\tminTill[0] = dp[0][0];\\n\\t\\tfor (int j = 1; j < cols; j++) {\\n\\t\\t\\tminTill[j] = Math.min(minTill[j-1], dp[0][j]);\\n\\t\\t}\\n\\n\\t\\t// update minFrom\\n\\t\\tminFrom[cols-1] = dp[0][cols-1];\\n\\t\\tfor (int j = cols-2; j >= 0; j--) {\\n\\t\\t\\tminFrom[j] = Math.min(dp[0][j], minFrom[j+1]);\\n\\t\\t}\\n\\n\\t\\tans = ansCand;\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Solution#3:** Time Complexity: `O(m*n)` Space Complexity: `O(1)` \\n* If you understand the problem carefully, all we need is, minimum value in each row.\\n* If the minimum value in current row is at the same column position as previous, than we need to consider the second minimum value in previous calculation. We also need to keep track of `prevPos` for this purpose.\\n\\n```\\npublic int minFallingPathSum(int[][] arr) {\\n\\tint rows = arr.length,\\n\\t\\tcols = arr[0].length,\\n\\t\\tprevPos = -1,\\n\\t\\tprevFirstMin = 0,\\n\\t\\tprevSecondMin = 0;\\n\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tint nextFirstMin = Integer.MAX_VALUE,\\n\\t\\t\\tnextSecondMin = Integer.MAX_VALUE,\\n\\t\\t\\tnextPos = -1;\\n\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint cur = arr[i][j] + (j == prevPos\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t? prevSecondMin\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t: prevFirstMin);\\n\\n\\t\\t\\tif (cur < nextFirstMin) {\\n\\t\\t\\t\\tnextPos = j;\\n\\t\\t\\t\\tnextSecondMin = nextFirstMin;\\n\\t\\t\\t\\tnextFirstMin = cur;\\n\\n\\t\\t\\t} else if (cur < nextSecondMin) {\\n\\t\\t\\t\\tnextSecondMin = cur;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprevFirstMin = nextFirstMin;\\n\\t\\tprevSecondMin = nextSecondMin;\\n\\t\\tprevPos = nextPos;\\n\\t}\\n\\n\\treturn prevFirstMin;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minFallingPathSum(int[][] arr) {\\n\\tint rows = arr.length,\\n\\t\\tcols = arr[0].length,\\n\\t\\tans = arr[0][0];\\n\\n\\tint[][] dp = new int[rows][cols];\\n\\tdp[0] = arr[0];\\n\\n\\tint[] minTill = new int[cols],\\n\\t\\tminFrom = new int[cols];\\n\\n\\tminTill[0] = arr[0][0];\\n\\tfor (int j = 1; j < cols; j++) {\\n\\t\\tminTill[j] = Math.min(minTill[j-1], arr[0][j]);\\n\\t}\\n\\n\\tminFrom[cols-1] = arr[0][cols-1];\\n\\tfor (int j = cols-2; j >= 0; j--) {\\n\\t\\tminFrom[j] = Math.min(minFrom[j+1], arr[0][j]);\\n\\t}\\n\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tint[] nextMinTill = new int[cols];\\n\\t\\tint ansCand = Integer.MAX_VALUE;\\n\\t\\t// System.out.println(\"minTill: \" + Arrays.toString(minTill));\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint cand1 = (j > 0)\\n\\t\\t\\t\\t\\t? minTill[j-1]\\n\\t\\t\\t\\t\\t: Integer.MAX_VALUE,\\n\\t\\t\\t\\tcand2 = j < cols-1\\n\\t\\t\\t\\t\\t? minFrom[j+1]\\n\\t\\t\\t\\t\\t: Integer.MAX_VALUE;\\n\\n\\t\\t\\tdp[i][j] = Math.min(cand1, cand2) + arr[i][j];\\n\\t\\t\\tansCand = Math.min(ansCand, dp[i][j]);\\n\\n\\t\\t\\tnextMinTill[j] = (j == 0)\\n\\t\\t\\t\\t? dp[i][j]\\n\\t\\t\\t\\t: Math.min(nextMinTill[j-1], dp[i][j]);\\n\\t\\t}\\n\\n\\t\\t// update minFrom\\n\\t\\tminFrom[cols-1] = dp[i][cols-1];\\n\\t\\tfor (int j = cols-2; j >= 0; j--) {\\n\\t\\t\\tminFrom[j] = Math.min(dp[i][j], minFrom[j+1]);\\n\\t\\t}\\n\\n\\t\\tminTill = nextMinTill;\\n\\t\\tans = ansCand;\\n\\t}\\n\\treturn ans;\\n```\n```\\npublic int minFallingPathSum(int[][] arr) {\\n\\tint rows = arr.length,\\n\\t\\tcols = arr[0].length,\\n\\t\\tans = arr[0][0];\\n\\n\\tint[][] dp = new int[2][cols];\\n\\tdp[0] = arr[0];\\n\\n\\tint[] minTill = new int[cols],\\n\\t\\tminFrom = new int[cols];\\n\\n\\tminTill[0] = arr[0][0];\\n\\tfor (int j = 1; j < cols; j++) {\\n\\t\\tminTill[j] = Math.min(minTill[j-1], arr[0][j]);\\n\\t}\\n\\n\\tminFrom[cols-1] = arr[0][cols-1];\\n\\tfor (int j = cols-2; j >= 0; j--) {\\n\\t\\tminFrom[j] = Math.min(minFrom[j+1], arr[0][j]);\\n\\t}\\n\\n\\tfor (int i = 1; i < rows; i++) {\\n\\t\\tint[] nextMinTill = new int[cols];\\n\\t\\tint ansCand = Integer.MAX_VALUE;\\n\\t\\t// System.out.println(\"minTill: \" + Arrays.toString(minTill));\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint cand1 = (j > 0)\\n\\t\\t\\t\\t\\t? minTill[j-1]\\n\\t\\t\\t\\t\\t: Integer.MAX_VALUE,\\n\\t\\t\\t\\tcand2 = j < cols-1\\n\\t\\t\\t\\t\\t? minFrom[j+1]\\n\\t\\t\\t\\t\\t: Integer.MAX_VALUE;\\n\\n\\t\\t\\tdp[1][j] = Math.min(cand1, cand2) + arr[i][j];\\n\\t\\t\\tansCand = Math.min(ansCand, dp[1][j]);\\n\\n\\t\\t\\tdp[0] = dp[1];\\n\\t\\t}\\n\\n\\t\\t// update minTill\\n\\t\\tminTill[0] = dp[0][0];\\n\\t\\tfor (int j = 1; j < cols; j++) {\\n\\t\\t\\tminTill[j] = Math.min(minTill[j-1], dp[0][j]);\\n\\t\\t}\\n\\n\\t\\t// update minFrom\\n\\t\\tminFrom[cols-1] = dp[0][cols-1];\\n\\t\\tfor (int j = cols-2; j >= 0; j--) {\\n\\t\\t\\tminFrom[j] = Math.min(dp[0][j], minFrom[j+1]);\\n\\t\\t}\\n\\n\\t\\tans = ansCand;\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\npublic int minFallingPathSum(int[][] arr) {\\n\\tint rows = arr.length,\\n\\t\\tcols = arr[0].length,\\n\\t\\tprevPos = -1,\\n\\t\\tprevFirstMin = 0,\\n\\t\\tprevSecondMin = 0;\\n\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tint nextFirstMin = Integer.MAX_VALUE,\\n\\t\\t\\tnextSecondMin = Integer.MAX_VALUE,\\n\\t\\t\\tnextPos = -1;\\n\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tint cur = arr[i][j] + (j == prevPos\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t? prevSecondMin\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t: prevFirstMin);\\n\\n\\t\\t\\tif (cur < nextFirstMin) {\\n\\t\\t\\t\\tnextPos = j;\\n\\t\\t\\t\\tnextSecondMin = nextFirstMin;\\n\\t\\t\\t\\tnextFirstMin = cur;\\n\\n\\t\\t\\t} else if (cur < nextSecondMin) {\\n\\t\\t\\t\\tnextSecondMin = cur;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprevFirstMin = nextFirstMin;\\n\\t\\tprevSecondMin = nextSecondMin;\\n\\t\\tprevPos = nextPos;\\n\\t}\\n\\n\\treturn prevFirstMin;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 596812,
                "title": "dp-python-memoization-and-tabulation",
                "content": "# Tabulation [AC] \\n\\n```python\\n# Time - O(N*M*M) | Space - O(N*M) \\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        dp = [[0 for i in range(len(arr[0]))] for j in range(len(arr)+1)]\\n        for i in range(len(arr)):\\n            for j in range(len(arr[0])):\\n                dp[i][j] = arr[i][j]\\n        for i in range(len(arr)-1,-1,-1):\\n            for j in range(len(arr[0])):\\n                mins = float(\"inf\")\\n                for idx in range(len(arr[0])):\\n                    if idx != j :\\n                        mins = min(mins,dp[i+1][idx])\\n                dp[i][j] += mins\\n        ans = min(dp[0])\\n        return ans\\n```\\n# Memoization [TLE]\\n```python\\n# Time - O(N*M*M) | Space - O(N*M) +O(N) -Recursion\\nclass Solution:\\n    def minFallingPathSum(self, arr):\\n        def dfs(arr,i,j,cache):\\n            if i > len(arr)-1 or j > len(arr[0]) -1: return 0\\n            if i < 0 or j < 0: return 0\\n            if cache[i][j] != float(\"inf\"):\\n                return cache[i][j]\\n            mins = float(\"inf\")\\n            for idx in range(len(arr[0])):\\n                if idx == j: continue\\n                mins = min(mins,dfs(arr,i+1,idx,cache)+arr[i][j])\\n            cache[i][j] = mins\\n            return mins\\n        \\n        minimum = float(\"inf\")\\n        cache = [[float(\"inf\") for i in range(len(arr[0])+1)] for j in range(len(arr)+1)]\\n        for i in range(len(arr)):\\n            minimum = min(minimum,dfs(arr,0,i,cache))\\n        return minimum\\n```",
                "solutionTags": [],
                "code": "```python\\n# Time - O(N*M*M) | Space - O(N*M) \\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        dp = [[0 for i in range(len(arr[0]))] for j in range(len(arr)+1)]\\n        for i in range(len(arr)):\\n            for j in range(len(arr[0])):\\n                dp[i][j] = arr[i][j]\\n        for i in range(len(arr)-1,-1,-1):\\n            for j in range(len(arr[0])):\\n                mins = float(\"inf\")\\n                for idx in range(len(arr[0])):\\n                    if idx != j :\\n                        mins = min(mins,dp[i+1][idx])\\n                dp[i][j] += mins\\n        ans = min(dp[0])\\n        return ans\\n```\n```python\\n# Time - O(N*M*M) | Space - O(N*M) +O(N) -Recursion\\nclass Solution:\\n    def minFallingPathSum(self, arr):\\n        def dfs(arr,i,j,cache):\\n            if i > len(arr)-1 or j > len(arr[0]) -1: return 0\\n            if i < 0 or j < 0: return 0\\n            if cache[i][j] != float(\"inf\"):\\n                return cache[i][j]\\n            mins = float(\"inf\")\\n            for idx in range(len(arr[0])):\\n                if idx == j: continue\\n                mins = min(mins,dfs(arr,i+1,idx,cache)+arr[i][j])\\n            cache[i][j] = mins\\n            return mins\\n        \\n        minimum = float(\"inf\")\\n        cache = [[float(\"inf\") for i in range(len(arr[0])+1)] for j in range(len(arr)+1)]\\n        for i in range(len(arr)):\\n            minimum = min(minimum,dfs(arr,0,i,cache))\\n        return minimum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593782,
                "title": "c-using-memoization-best-solution",
                "content": "\\n\\' \\' \\'\\n\\t\\n\\tint t[201][201];\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        memset(t,-1,sizeof(t));\\n        return recur(arr,0,-1);\\n    }\\n    \\n    int recur(vector<vector<int>>& a,int r,int prev_col)\\n    {\\n        if(r>=a.size())return 0;\\n        \\n        if(prev_col!=-1 && t[r][prev_col]!=-1)\\n        {return t[r][prev_col];}\\n        int mi=INT_MAX;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int z=INT_MAX;\\n            if(i!=prev_col)\\n            mi=min(mi,a[r][i]+recur(a,r+1,i));\\n           \\n        }\\n        if(prev_col!=-1)\\n        return t[r][prev_col]=mi;\\n        return mi;\\n    }\\n\\'",
                "solutionTags": [],
                "code": "\\n\\' \\' \\'\\n\\t\\n\\tint t[201][201];\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        memset(t,-1,sizeof(t));\\n        return recur(arr,0,-1);\\n    }\\n    \\n    int recur(vector<vector<int>>& a,int r,int prev_col)\\n    {\\n        if(r>=a.size())return 0;\\n        \\n        if(prev_col!=-1 && t[r][prev_col]!=-1)\\n        {return t[r][prev_col];}\\n        int mi=INT_MAX;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int z=INT_MAX;\\n            if(i!=prev_col)\\n            mi=min(mi,a[r][i]+recur(a,r+1,i));\\n           \\n        }\\n        if(prev_col!=-1)\\n        return t[r][prev_col]=mi;\\n        return mi;\\n    }\\n\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 452177,
                "title": "java-o-m-n-similar-to-paint-house",
                "content": "Java Another Version\\nSimilar to the paint house\\n\\nGet every row\\'s min and secondMin, record min\\'s index.\\nif current row\\'s index j == minIndex, value is arr[row][j] + secondMin. Otherwise arr[row][j] + min.\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        int[][] dp = new int[n][m];\\n        int min = Integer.MAX_VALUE;\\n        int minIndex = -1;\\n        int secondMin = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                if (i == 0) {\\n                    dp[i][j] = arr[i][j];\\n                } else {\\n                    if (j == minIndex) {\\n                        dp[i][j] = Math.min(secondMin + arr[i][j], dp[i][j]);\\n                    } else {\\n                        dp[i][j] = Math.min(min + arr[i][j], dp[i][j]);\\n                    }\\n                } \\n            }\\n            min = Integer.MAX_VALUE;\\n            minIndex = -1;\\n            secondMin = Integer.MAX_VALUE;\\n            for (int j = 0; j < m; j++) {\\n                if (min >= dp[i][j]) {\\n                    secondMin = min;\\n                    min = dp[i][j];\\n                    minIndex = j;\\n                } else if (secondMin > dp[i][j]) {\\n                    secondMin = dp[i][j];\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n        int[][] dp = new int[n][m];\\n        int min = Integer.MAX_VALUE;\\n        int minIndex = -1;\\n        int secondMin = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dp[i][j] = Integer.MAX_VALUE;\\n                if (i == 0) {\\n                    dp[i][j] = arr[i][j];\\n                } else {\\n                    if (j == minIndex) {\\n                        dp[i][j] = Math.min(secondMin + arr[i][j], dp[i][j]);\\n                    } else {\\n                        dp[i][j] = Math.min(min + arr[i][j], dp[i][j]);\\n                    }\\n                } \\n            }\\n            min = Integer.MAX_VALUE;\\n            minIndex = -1;\\n            secondMin = Integer.MAX_VALUE;\\n            for (int j = 0; j < m; j++) {\\n                if (min >= dp[i][j]) {\\n                    secondMin = min;\\n                    min = dp[i][j];\\n                    minIndex = j;\\n                } else if (secondMin > dp[i][j]) {\\n                    secondMin = dp[i][j];\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451706,
                "title": "c-dp-n-2-36ms",
                "content": "```\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int R = A.size();\\n        for(int i=1;i<R;++i){\\n            int fMin = INT_MAX, sMin = fMin;\\n            for(int j=0;j<R;++j){\\n                if(A[i-1][j]<fMin)  sMin=fMin,fMin=A[i-1][j];\\n                else if(A[i-1][j]<sMin) sMin=A[i-1][j];\\n            }\\n            for(int j=0;j<R;++j){\\n                A[i][j]+=A[i-1][j]==fMin?sMin:fMin;\\n            }\\n        }\\n        return *min_element(begin(A[R-1]),end(A[R-1]));\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int R = A.size();\\n        for(int i=1;i<R;++i){\\n            int fMin = INT_MAX, sMin = fMin;\\n            for(int j=0;j<R;++j){\\n                if(A[i-1][j]<fMin)  sMin=fMin,fMin=A[i-1][j];\\n                else if(A[i-1][j]<sMin) sMin=A[i-1][j];\\n            }\\n            for(int j=0;j<R;++j){\\n                A[i][j]+=A[i-1][j]==fMin?sMin:fMin;\\n            }\\n        }\\n        return *min_element(begin(A[R-1]),end(A[R-1]));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 451551,
                "title": "java-o-mn-time-with-o-1-extra-space",
                "content": "DP Solution. Idea is to keep computing the 2 minimum values in a row at every step and use them to add to the elements in the subsequent row based on the given condition. Finally, traverse through all the elements in the last row to find the minimum value\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        if (arr[0].length==1) {return arr[arr.length-1][0];}\\n        int[] custom = computeCustom(arr, 0);\\n        for (int i=1;i<arr.length;i++) {\\n            \\n            for (int j=0;j<arr[0].length;j++) {\\n                if (custom[1]!=j) {\\n                    arr[i][j]+=custom[0];\\n                } else {\\n                    arr[i][j]+=custom[2];\\n                }\\n            }\\n            custom = computeCustom(arr, i);\\n        }\\n        int result = arr[arr.length-1][0];\\n        for (int j=1;j<arr[0].length;j++) {\\n            result = Math.min(result, arr[arr.length-1][j]);\\n        }\\n        return result;\\n    }\\n    \\n    private int[] computeCustom(int[][] arr, int k) {\\n        int[] custom = new int[4];  // [min idx 2nd_min 2nd_idx];\\n        int[] row = arr[k];\\n        int min, min_2, idx, idx_2;\\n        if (row[0]<row[1]) {\\n            min = row[0];\\n            idx = 0;\\n            min_2 = row[1];\\n            idx_2 = 1;\\n        } else {\\n            min = row[1];\\n            idx = 1;\\n            min_2 = row[2];\\n            idx_2 = 2;            \\n        }\\n        for (int i=2;i<row.length;i++) {\\n            if (row[i]<min) {\\n                min_2 = min;\\n                idx_2 = idx;\\n                min = row[i];\\n                idx = i;\\n            } else if (row[i]<min_2) {\\n                min_2 = row[i];\\n                idx_2 = i;\\n            }\\n        }\\n        custom[0] = min;\\n        custom[1] = idx;\\n        custom[2] = min_2;\\n        custom[3] = idx_2;\\n        return custom;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        if (arr[0].length==1) {return arr[arr.length-1][0];}\\n        int[] custom = computeCustom(arr, 0);\\n        for (int i=1;i<arr.length;i++) {\\n            \\n            for (int j=0;j<arr[0].length;j++) {\\n                if (custom[1]!=j) {\\n                    arr[i][j]+=custom[0];\\n                } else {\\n                    arr[i][j]+=custom[2];\\n                }\\n            }\\n            custom = computeCustom(arr, i);\\n        }\\n        int result = arr[arr.length-1][0];\\n        for (int j=1;j<arr[0].length;j++) {\\n            result = Math.min(result, arr[arr.length-1][j]);\\n        }\\n        return result;\\n    }\\n    \\n    private int[] computeCustom(int[][] arr, int k) {\\n        int[] custom = new int[4];  // [min idx 2nd_min 2nd_idx];\\n        int[] row = arr[k];\\n        int min, min_2, idx, idx_2;\\n        if (row[0]<row[1]) {\\n            min = row[0];\\n            idx = 0;\\n            min_2 = row[1];\\n            idx_2 = 1;\\n        } else {\\n            min = row[1];\\n            idx = 1;\\n            min_2 = row[2];\\n            idx_2 = 2;            \\n        }\\n        for (int i=2;i<row.length;i++) {\\n            if (row[i]<min) {\\n                min_2 = min;\\n                idx_2 = idx;\\n                min = row[i];\\n                idx = i;\\n            } else if (row[i]<min_2) {\\n                min_2 = row[i];\\n                idx_2 = i;\\n            }\\n        }\\n        custom[0] = min;\\n        custom[1] = idx;\\n        custom[2] = min_2;\\n        custom[3] = idx_2;\\n        return custom;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451518,
                "title": "java-short-dp-solution-o-m-n-time-o-1-space",
                "content": "1. We can start the algorithm on the second row (1st index) because this row has already been computed based on array that is passed in. I.E. we don\\'t have to do anything.\\n\\n2. For each index value in the array i,j we want to find the sum of a value in the row above us plus a value in the row we are currently looking at that is not in the same column. As a brute force approach we can just iterate over all values in the row we are currently on checking (as long as we are not on the same column `k != j`) the minimum value based on all other values in the row.\\n\\n3. At the end, we have the minimum value from top to bottom somewhere in the last row, we just need to iterate over it to find it. Then we return the answer.\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        int res = Integer.MAX_VALUE, m = arr.length, n = arr[0].length;\\n        \\n        for(int i = 1; i < m; i++) { //start at 1 (second row) because 1st row is already calculated \\n            for(int j = 0; j < n; j++) {\\n                int min = Integer.MAX_VALUE;\\n                for(int k = 0; k < n; k++)\\n                    if(k != j) min = Math.min(arr[i-1][k], min); //check min for any value other than on same column\\n                arr[i][j] = arr[i][j] + min;\\n            } \\n        }\\n        for(int i = 0; i < n; i++) res = Math.min(arr[m-1][i], res); //find the smallest value in the last row (i.e. where we fell to)\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] arr) {\\n        int res = Integer.MAX_VALUE, m = arr.length, n = arr[0].length;\\n        \\n        for(int i = 1; i < m; i++) { //start at 1 (second row) because 1st row is already calculated \\n            for(int j = 0; j < n; j++) {\\n                int min = Integer.MAX_VALUE;\\n                for(int k = 0; k < n; k++)\\n                    if(k != j) min = Math.min(arr[i-1][k], min); //check min for any value other than on same column\\n                arr[i][j] = arr[i][j] + min;\\n            } \\n        }\\n        for(int i = 0; i < n; i++) res = Math.min(arr[m-1][i], res); //find the smallest value in the last row (i.e. where we fell to)\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451407,
                "title": "simplest-c-o-n-2-dp-solution-beats-100-with-comments",
                "content": "Initially I came up with the N^2logN solution. Find the minimum path to reach the above row apat from the current column for which we are finding right now and add the cur arr[i][j] path cost to the minimum we got. At the last final answer would be the minimum to reach the last row across all the columns. \\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n         multiset<int>ms;\\n         int res=INT_MAX;\\n         int n=arr.size();\\n         vector<vector<int>>dp(n,vector<int>(n));\\n         for(int j=0;j<n;j++)                    //First row cost \\n         {\\n             dp[0][j]=arr[0][j];\\n             ms.insert(dp[0][j]);\\n         }\\n         for(int i=1;i<n;i++)\\n         {\\n             for(int j=0;j<n;j++)\\n             {\\n                 ms.erase(ms.find(dp[i-1][j]));                     //erase the just above element\\n                 dp[i][j]=*ms.begin()+arr[i][j];                    // find the minimum for current cell\\n                 ms.insert(dp[i-1][j]);                    // insert to the multiset the val we have deleted \\n             }    \\n             if(i<n-1)\\n             {\\n               ms.clear();                              //insert cur row elements to the multiset now\\n               for(int j=0;j<n;j++)\\n               ms.insert(dp[i][j]);\\n             }\\n         }\\n         for(int j=0;j<n;j++)                                     // Find the final res\\n            res=min(res,dp[n-1][j]);\\n         return res;    \\n    }\\n};\\n```\\n\\n\\n**O(N^2) solution**\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n         int res=INT_MAX;\\n         int n=arr.size();\\n         vector<vector<int>>dp(n,vector<int>(n,INT_MAX));\\n         for(int j=0;j<n;j++)\\n             dp[0][j]=arr[0][j];\\n         for(int i=1;i<n;i++)\\n         {\\n\\t\\t\\t //Case 1\\n\\t\\t\\t int mi=INT_MAX-200;\\n             for(int j=0;j<n;j++)  // Came from the front from above row wrt to current position\\n             {\\n                 dp[i][j]=min(dp[i][j],mi+arr[i][j]);\\n                 mi=min(mi,dp[i-1][j]);\\n             }     \\n\\t\\t\\t //Case 2\\n\\t\\t\\t mi=INT_MAX-200;  \\n             for(int j=n-1;j>=0;j--)         // Can get minimum while comming from the back side of the above row wrt to cur position\\n             {\\n                 dp[i][j]=min(dp[i][j],mi+arr[i][j]);\\n                 mi=min(mi,dp[i-1][j]);\\n             }\\n         }\\n         for(int j=0;j<n;j++)\\n            res=min(res,dp[n-1][j]);\\n         return res;    \\n    }\\n};\\n```\\n\\nHappy Coding :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n         multiset<int>ms;\\n         int res=INT_MAX;\\n         int n=arr.size();\\n         vector<vector<int>>dp(n,vector<int>(n));\\n         for(int j=0;j<n;j++)                    //First row cost \\n         {\\n             dp[0][j]=arr[0][j];\\n             ms.insert(dp[0][j]);\\n         }\\n         for(int i=1;i<n;i++)\\n         {\\n             for(int j=0;j<n;j++)\\n             {\\n                 ms.erase(ms.find(dp[i-1][j]));                     //erase the just above element\\n                 dp[i][j]=*ms.begin()+arr[i][j];                    // find the minimum for current cell\\n                 ms.insert(dp[i-1][j]);                    // insert to the multiset the val we have deleted \\n             }    \\n             if(i<n-1)\\n             {\\n               ms.clear();                              //insert cur row elements to the multiset now\\n               for(int j=0;j<n;j++)\\n               ms.insert(dp[i][j]);\\n             }\\n         }\\n         for(int j=0;j<n;j++)                                     // Find the final res\\n            res=min(res,dp[n-1][j]);\\n         return res;    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n         int res=INT_MAX;\\n         int n=arr.size();\\n         vector<vector<int>>dp(n,vector<int>(n,INT_MAX));\\n         for(int j=0;j<n;j++)\\n             dp[0][j]=arr[0][j];\\n         for(int i=1;i<n;i++)\\n         {\\n\\t\\t\\t //Case 1\\n\\t\\t\\t int mi=INT_MAX-200;\\n             for(int j=0;j<n;j++)  // Came from the front from above row wrt to current position\\n             {\\n                 dp[i][j]=min(dp[i][j],mi+arr[i][j]);\\n                 mi=min(mi,dp[i-1][j]);\\n             }     \\n\\t\\t\\t //Case 2\\n\\t\\t\\t mi=INT_MAX-200;  \\n             for(int j=n-1;j>=0;j--)         // Can get minimum while comming from the back side of the above row wrt to cur position\\n             {\\n                 dp[i][j]=min(dp[i][j],mi+arr[i][j]);\\n                 mi=min(mi,dp[i-1][j]);\\n             }\\n         }\\n         for(int j=0;j<n;j++)\\n            res=min(res,dp[n-1][j]);\\n         return res;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451406,
                "title": "python-dp",
                "content": "```python\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        dp = arr[0][:]\\n        R, C = len(arr), len(arr[0])\\n        if R==1:return min(dp)\\n        for i in range(1, R):\\n            new_dp = arr[i][:]\\n            for j in range(C):\\n                new_dp[j] += min(dp[jj] for jj in range(C) if jj!=j) \\n            dp = new_dp[:]\\n        return min(dp)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        dp = arr[0][:]\\n        R, C = len(arr), len(arr[0])\\n        if R==1:return min(dp)\\n        for i in range(1, R):\\n            new_dp = arr[i][:]\\n            for j in range(C):\\n                new_dp[j] += min(dp[jj] for jj in range(C) if jj!=j) \\n            dp = new_dp[:]\\n        return min(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451379,
                "title": "python-dp",
                "content": "dp[i][j] = minimal sum to get to cell (i,j)\\nanswer: min(dp[-1])\\n\\nfor the given line get a min (the first one if there are multiple one)\\nand update the next line by forcing the choice of this min\\n\\n**ith line**\\n```\\nx x x x x min x x x x\\n```\\n**i+1 - th line**\\n```\\nx+min x+min x+min x+min x+min y + second min, x+min x+min x+min x+min\\n```\\n\\nlittle tricky because it feels like we can go down one column \\nit never does\\n\\nfor any given row, make sue the next row does pick its column breaking the rules\\n\\naccumulate the sum and reuse the input matrix as it wont be used again\\n\\n```\\nclass Solution(object):\\n    def minFallingPathSum(self, arr):\\n        for ii in range(0, len(arr) - 1):\\n            heap = []\\n                \\n            for jj in range(len(arr[ii])):\\n                heapq.heappush(heap, (-arr[ii][jj], jj))\\n                if len(heap) > 2:\\n                    heapq.heappop(heap)\\n                    \\n            v,u = heapq.heappop(heap), heapq.heappop(heap)\\n            u = [-u[0], u[1]] # min and index of min\\n            v = [-v[0], v[1]] # second min and index of second min\\n            \\n            for jj in range(len(arr[ii + 1])):\\n                if jj != u[1]:\\n                    arr[ii+1][jj] += u[0]\\n                else:\\n                    arr[ii+1][jj] += v[0]\\n        return min(arr[-1])\\n```\\n\\nused a max heap to get the 2 mins",
                "solutionTags": [],
                "code": "```\\nx x x x x min x x x x\\n```\n```\\nx+min x+min x+min x+min x+min y + second min, x+min x+min x+min x+min\\n```\n```\\nclass Solution(object):\\n    def minFallingPathSum(self, arr):\\n        for ii in range(0, len(arr) - 1):\\n            heap = []\\n                \\n            for jj in range(len(arr[ii])):\\n                heapq.heappush(heap, (-arr[ii][jj], jj))\\n                if len(heap) > 2:\\n                    heapq.heappop(heap)\\n                    \\n            v,u = heapq.heappop(heap), heapq.heappop(heap)\\n            u = [-u[0], u[1]] # min and index of min\\n            v = [-v[0], v[1]] # second min and index of second min\\n            \\n            for jj in range(len(arr[ii + 1])):\\n                if jj != u[1]:\\n                    arr[ii+1][jj] += u[0]\\n                else:\\n                    arr[ii+1][jj] += v[0]\\n        return min(arr[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451374,
                "title": "python3-bottom-up-dp",
                "content": "Algorithm: \\nAs of row `i`, `mfps[i][j] = arr[i][j] + min(mfps[i-1])` if `mfps[i-1][j] != min(fmps[i-1])` otherwise use 2nd minimum. \\n\\nImplementation: \\n```\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        for i in range(1, len(arr)): \\n            #find 1st & 2nd mininum\\n            m1 = m2 = float(\"inf\")\\n            for x in arr[i-1]: \\n                if x < m1: m1, m2 = x, m1\\n                elif x < m2: m2 = x\\n                    \\n            #update min falling path sum as of row i \\n            for j in range(len(arr[0])): \\n                arr[i][j] += (m1 if arr[i-1][j] != m1 else m2)\\n                    \\n        return min(arr[-1])\\n```\\nAnalysis:\\nTime complexity `O(MN)` where `M` is #rows and `N` is #columns\\nSpace complexity `O(1)`\\n\\nUpdate: \\nFaster runtime can be obtained if using `nsmallest` of `heapq` module to compute the 1st and 2nd minimum e.g.\\n\\n```\\nfrom heapq import nsmallest\\n\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        \\n        for i in range(1, len(arr)): \\n            m1, m2 = nsmallest(2, arr[i-1])\\n                    \\n            #update min falling path sum as of row i \\n            for j in range(len(arr[0])): \\n                arr[i][j] += (m1 if arr[i-1][j] != m1 else m2)\\n                    \\n        return min(arr[-1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        for i in range(1, len(arr)): \\n            #find 1st & 2nd mininum\\n            m1 = m2 = float(\"inf\")\\n            for x in arr[i-1]: \\n                if x < m1: m1, m2 = x, m1\\n                elif x < m2: m2 = x\\n                    \\n            #update min falling path sum as of row i \\n            for j in range(len(arr[0])): \\n                arr[i][j] += (m1 if arr[i-1][j] != m1 else m2)\\n                    \\n        return min(arr[-1])\\n```\n```\\nfrom heapq import nsmallest\\n\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        \\n        for i in range(1, len(arr)): \\n            m1, m2 = nsmallest(2, arr[i-1])\\n                    \\n            #update min falling path sum as of row i \\n            for j in range(len(arr[0])): \\n                arr[i][j] += (m1 if arr[i-1][j] != m1 else m2)\\n                    \\n        return min(arr[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451372,
                "title": "iterative-o-m-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int m = arr.size();\\n        if (m == 0) return 0;\\n        int n = arr[m-1].size();\\n        if (n == 0) return 0;\\n        \\n        for(int i=1; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int t = INT_MAX;\\n                for(int k=0; k<n; k++)\\n                    if (k!=j) t = min(t, arr[i][j] + arr[i-1][k]);\\n                arr[i][j] = t;\\n            }\\n        }\\n        int mini = INT_MAX;\\n        for(int i=0; i<n; i++)\\n            mini = min(mini, arr[m-1][i]), cout << arr[m-1][i] << \" \";\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& arr) {\\n        int m = arr.size();\\n        if (m == 0) return 0;\\n        int n = arr[m-1].size();\\n        if (n == 0) return 0;\\n        \\n        for(int i=1; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                int t = INT_MAX;\\n                for(int k=0; k<n; k++)\\n                    if (k!=j) t = min(t, arr[i][j] + arr[i-1][k]);\\n                arr[i][j] = t;\\n            }\\n        }\\n        int mini = INT_MAX;\\n        for(int i=0; i<n; i++)\\n            mini = min(mini, arr[m-1][i]), cout << arr[m-1][i] << \" \";\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4077355,
                "title": "o-mn-heap-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nm row length, n col length\\n**for methods:**\\ngetIndexFromHeap: 2*O(log(2)) = O(1)\\ngetTwoMin:  O(n * log(2)) = n\\n\\n**for the main code**\\no(m * (n + n * log(2))) = O(mn)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1): heap size is constant, always 2\\n# Code\\n```\\nclass Solution {\\n    PriorityQueue<int[]> queue = new PriorityQueue<>((a,b)->b[1] - a[1]);\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // heap: index and its value\\n        \\n        for (int j = 0; j<n; j++) {\\n            getTwoMin(0, grid);\\n        }\\n\\n        for (int i = 1; i<m; i++) {\\n            int[] minIndex = getIndexFromHeap();\\n\\n            for (int j = 0; j<n; j++) {\\n                // step 1: update the cur i, j from previous heap\\n                if (j != minIndex[1]) {\\n                    grid[i][j] += grid[i-1][minIndex[1]];\\n                } else{\\n                    grid[i][j] += grid[i-1][minIndex[0]];\\n                }\\n            }\\n            getTwoMin(i, grid);\\n        }\\n        int[] minIndex = getIndexFromHeap();\\n        System.out.println(minIndex[0]);\\n        int ans = Integer.MAX_VALUE;\\n        for (int j = 0; j<n; j++) {\\n            ans = Math.min(ans, grid[m-1][j]);\\n        }\\n        return n>=2 ? grid[m-1][minIndex[1]] : grid[m-1][minIndex[0]] ;\\n    }   \\n    public void getTwoMin(int rowIndex, int[][] grid) {\\n        queue.clear();\\n        for (int j = 0; j<grid[0].length; j++) {\\n            queue.add(new int[]{j, grid[rowIndex][j]});\\n            if (queue.size() > 2) {\\n                queue.poll();\\n            }\\n        }\\n    }\\n    public int[] getIndexFromHeap(){\\n        int index = 0;\\n        int[] minIndex = new int[2];\\n        minIndex[0] = -1;\\n        minIndex[1] = -1;\\n        while (!queue.isEmpty()) {\\n            int[] element = queue.poll();\\n            minIndex[index++] = element[0];\\n        }\\n        return minIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    PriorityQueue<int[]> queue = new PriorityQueue<>((a,b)->b[1] - a[1]);\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // heap: index and its value\\n        \\n        for (int j = 0; j<n; j++) {\\n            getTwoMin(0, grid);\\n        }\\n\\n        for (int i = 1; i<m; i++) {\\n            int[] minIndex = getIndexFromHeap();\\n\\n            for (int j = 0; j<n; j++) {\\n                // step 1: update the cur i, j from previous heap\\n                if (j != minIndex[1]) {\\n                    grid[i][j] += grid[i-1][minIndex[1]];\\n                } else{\\n                    grid[i][j] += grid[i-1][minIndex[0]];\\n                }\\n            }\\n            getTwoMin(i, grid);\\n        }\\n        int[] minIndex = getIndexFromHeap();\\n        System.out.println(minIndex[0]);\\n        int ans = Integer.MAX_VALUE;\\n        for (int j = 0; j<n; j++) {\\n            ans = Math.min(ans, grid[m-1][j]);\\n        }\\n        return n>=2 ? grid[m-1][minIndex[1]] : grid[m-1][minIndex[0]] ;\\n    }   \\n    public void getTwoMin(int rowIndex, int[][] grid) {\\n        queue.clear();\\n        for (int j = 0; j<grid[0].length; j++) {\\n            queue.add(new int[]{j, grid[rowIndex][j]});\\n            if (queue.size() > 2) {\\n                queue.poll();\\n            }\\n        }\\n    }\\n    public int[] getIndexFromHeap(){\\n        int index = 0;\\n        int[] minIndex = new int[2];\\n        minIndex[0] = -1;\\n        minIndex[1] = -1;\\n        while (!queue.isEmpty()) {\\n            int[] element = queue.poll();\\n            minIndex[index++] = element[0];\\n        }\\n        return minIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076969,
                "title": "recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    int f(int i,int j,int n,vector<vector<int>>&a,vector<vector<int>>&dp){\\n        if(i<0 || j<0 || i>=n || j>=n)return 1e8;\\n        if(i==n-1)return a[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=1e8;\\n        for(int k=0;k<n;k++){\\n            if(k!=j){\\n                ans=min(ans,a[i][j]+f(i+1,k,n,a,dp));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int ans=1e8;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        for(int k=0;k<n;k++){\\n            ans=min(ans,f(0,k,n,g,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int f(int i,int j,int n,vector<vector<int>>&a,vector<vector<int>>&dp){\\n        if(i<0 || j<0 || i>=n || j>=n)return 1e8;\\n        if(i==n-1)return a[i][j];\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        int ans=1e8;\\n        for(int k=0;k<n;k++){\\n            if(k!=j){\\n                ans=min(ans,a[i][j]+f(i+1,k,n,a,dp));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& g) {\\n        int n=g.size();\\n        int ans=1e8;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        for(int k=0;k<n;k++){\\n            ans=min(ans,f(0,k,n,g,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072397,
                "title": "memoization-tabulation-java",
                "content": "# Recursion + Memoization\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n\\n        int dp[][] = new int[n][m];\\n\\n        for(int  i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n\\n        int ans = (int)1e9;\\n        for(int col = 0; col < m; col++){\\n            ans = Math.min(ans, f(n-1, col, matrix, dp));\\n        }\\n        return ans;\\n    }\\n\\n    //recusrion + Memo\\n    public int f(int i, int j, int[][]a, int dp[][]){\\n        int m = a[0].length;\\n        if(i < 0 || j >= m || j < 0) return (int)1e9; // invalid case\\n        if(i == 0) return a[0][j]; //we\\'ve reached to the end\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        // here is the slight modificatio than Minimum falling path sum 1\\n        // just try out all possible answers from the previous row where current col is not equal to the previous col.\\n        int res = (int) 1e9;\\n        for(int col = 0; col < m; col++){\\n            if(col != j){\\n                int call = a[i][j] + f(i-1, col, a, dp); \\n                res = Math.min(call, res);\\n            }\\n        }\\n        return dp[i][j] = res;\\n    }\\n}\\n\\n\\n```\\n\\n# Tabulation\\n\\n# Code\\n\\n```\\npublic int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n\\n        int dp[][] = new int[n][m];\\n\\n        for(int i = 0; i < m; i++) dp[0][i] = matrix[0][i];\\n        for(int i = 1; i < n; i++){ //rows\\n           for(int j = 0; j < m; j++){\\n               // here slight modification to this. just traverse all the columns inteaad of the current column.\\n               int res = Integer.MAX_VALUE;\\n                for(int col = 0; col < m; col++){\\n                    if(col != j){\\n                        int call = matrix[i][j] + dp[i-1][col]; \\n                        res = Math.min(call, res);\\n                    }\\n                }\\n                dp[i][j] = res;\\n           }\\n        }\\n\\n        int mini = dp[n-1][0];\\n        for(int i = 1; i < m; i++) {\\n            mini = Math.min(mini, dp[n-1][i]);\\n        }\\n\\n        return mini;\\n\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n\\n        int dp[][] = new int[n][m];\\n\\n        for(int  i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n\\n        int ans = (int)1e9;\\n        for(int col = 0; col < m; col++){\\n            ans = Math.min(ans, f(n-1, col, matrix, dp));\\n        }\\n        return ans;\\n    }\\n\\n    //recusrion + Memo\\n    public int f(int i, int j, int[][]a, int dp[][]){\\n        int m = a[0].length;\\n        if(i < 0 || j >= m || j < 0) return (int)1e9; // invalid case\\n        if(i == 0) return a[0][j]; //we\\'ve reached to the end\\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        // here is the slight modificatio than Minimum falling path sum 1\\n        // just try out all possible answers from the previous row where current col is not equal to the previous col.\\n        int res = (int) 1e9;\\n        for(int col = 0; col < m; col++){\\n            if(col != j){\\n                int call = a[i][j] + f(i-1, col, a, dp); \\n                res = Math.min(call, res);\\n            }\\n        }\\n        return dp[i][j] = res;\\n    }\\n}\\n\\n\\n```\n```\\npublic int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n\\n        int dp[][] = new int[n][m];\\n\\n        for(int i = 0; i < m; i++) dp[0][i] = matrix[0][i];\\n        for(int i = 1; i < n; i++){ //rows\\n           for(int j = 0; j < m; j++){\\n               // here slight modification to this. just traverse all the columns inteaad of the current column.\\n               int res = Integer.MAX_VALUE;\\n                for(int col = 0; col < m; col++){\\n                    if(col != j){\\n                        int call = matrix[i][j] + dp[i-1][col]; \\n                        res = Math.min(call, res);\\n                    }\\n                }\\n                dp[i][j] = res;\\n           }\\n        }\\n\\n        int mini = dp[n-1][0];\\n        for(int i = 1; i < m; i++) {\\n            mini = Math.min(mini, dp[n-1][i]);\\n        }\\n\\n        return mini;\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045918,
                "title": "java-dp-top-down",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        this.memo = new int[grid.length][grid[0].length];\\n        for (int[] row : memo) Arrays.fill(row, -1);\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0;i < grid[0].length;i++) {\\n            min = Math.min(min, dp(grid,0, i));\\n        }\\n        return min;\\n    }\\n\\n    private int[][] memo;\\n\\n    public int dp(int[][] grid, int row, int col) {\\n        if (memo[row][col] != -1) {\\n            return memo[row][col];\\n        }\\n\\n        int minPath = Integer.MAX_VALUE;\\n\\n        for (int i = 0;i < grid.length && row != grid[0].length-1;i++) {\\n            if (i == col) {\\n                continue;\\n            }\\n\\n            minPath = Math.min(minPath, dp(grid, row+1, i) + grid[row][col]);\\n        } \\n        if (minPath == Integer.MAX_VALUE) minPath = grid[row][col];\\n        memo[row][col] = minPath;\\n        return minPath;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        this.memo = new int[grid.length][grid[0].length];\\n        for (int[] row : memo) Arrays.fill(row, -1);\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0;i < grid[0].length;i++) {\\n            min = Math.min(min, dp(grid,0, i));\\n        }\\n        return min;\\n    }\\n\\n    private int[][] memo;\\n\\n    public int dp(int[][] grid, int row, int col) {\\n        if (memo[row][col] != -1) {\\n            return memo[row][col];\\n        }\\n\\n        int minPath = Integer.MAX_VALUE;\\n\\n        for (int i = 0;i < grid.length && row != grid[0].length-1;i++) {\\n            if (i == col) {\\n                continue;\\n            }\\n\\n            minPath = Math.min(minPath, dp(grid, row+1, i) + grid[row][col]);\\n        } \\n        if (minPath == Integer.MAX_VALUE) minPath = grid[row][col];\\n        memo[row][col] = minPath;\\n        return minPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044351,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& grid,int x,int y){\\n        if(x >= n)\\n            return 0;\\n        if(dp[x][y+1] != -1)\\n            return dp[x][y+1];\\n        int ans = INT_MAX/2;\\n        for(int i = 0;i<m;i++){\\n            if(y == i)\\n                continue;\\n            ans = min(ans,solve(grid,x+1,i) + grid[x][i]);\\n        }\\n        return dp[x][y+1] = ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dp = vector<vector<int>>(n,vector<int>(m+1,-1));\\n        return solve(grid,0,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& grid,int x,int y){\\n        if(x >= n)\\n            return 0;\\n        if(dp[x][y+1] != -1)\\n            return dp[x][y+1];\\n        int ans = INT_MAX/2;\\n        for(int i = 0;i<m;i++){\\n            if(y == i)\\n                continue;\\n            ans = min(ans,solve(grid,x+1,i) + grid[x][i]);\\n        }\\n        return dp[x][y+1] = ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dp = vector<vector<int>>(n,vector<int>(m+1,-1));\\n        return solve(grid,0,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012160,
                "title": "100-easy-and-fast-c-solution-dp-tabulation",
                "content": "\\n# Complexity\\n- **Time complexity:O(n^3).**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:O(n*n).**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> dp(n,(vector<int>(n,0)));\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                int mini=INT_MAX;\\n                for(int k=0;k<n;k++)\\n                {\\n                    if(k!=j)\\n                    {\\n                        mini=min(mini,dp[i+1][k]);\\n                    }\\n                }\\n                dp[i][j]=grid[i][j]+mini;\\n            }\\n        }\\n        return *min_element(dp[0].begin(),dp[0].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> dp(n,(vector<int>(n,0)));\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            dp[n-1][i]=grid[n-1][i];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-1;j>=0;j--)\\n            {\\n                int mini=INT_MAX;\\n                for(int k=0;k<n;k++)\\n                {\\n                    if(k!=j)\\n                    {\\n                        mini=min(mini,dp[i+1][k]);\\n                    }\\n                }\\n                dp[i][j]=grid[i][j]+mini;\\n            }\\n        }\\n        return *min_element(dp[0].begin(),dp[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006655,
                "title": "c-dp-o-n-m",
                "content": "# Intuition\\nJust remember one thing we have to choose the smallest element in each row, but we cannot choose an element in the row if we have picked the same column element in the previous row!\\n\\nHow to do this?\\nWe should do one thing we have to know two smaller values so that if we have the smaller value appearing in the row then we might handle it with the next smaller value. That\\'s it we can implement it and find the answer in O(N*M).\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        pair<int, int> firstMini = {INT_MAX, -1};\\n        int secondMini = INT_MAX;\\n        for(int i=0;i<grid[0].size();i++) {\\n            if(grid[0][i]<firstMini.first) {\\n                secondMini = firstMini.first;\\n                firstMini = {grid[0][i], i};\\n            }\\n            else {\\n                secondMini = grid[0][i], secondMini; \\n            }\\n        }\\n\\n        for(int i=1;i<grid.size();i++) {\\n            pair<int, int> newFirstMini = {INT_MAX, -1};\\n            int newSecondMini = INT_MAX;\\n            for(int j=0;j<grid[0].size();j++) {\\n                int val = (j!=firstMini.second)? firstMini.first:secondMini;\\n                if((val + grid[i][j]) < newFirstMini.first) {\\n                    newSecondMini = newFirstMini.first;\\n                    newFirstMini = {val + grid[i][j], j};\\n                }\\n                else {\\n                    newSecondMini = min(newSecondMini, val + grid[i][j]);\\n                }\\n            }\\n            firstMini = newFirstMini;\\n            secondMini = newSecondMini;\\n        }\\n        return firstMini.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        pair<int, int> firstMini = {INT_MAX, -1};\\n        int secondMini = INT_MAX;\\n        for(int i=0;i<grid[0].size();i++) {\\n            if(grid[0][i]<firstMini.first) {\\n                secondMini = firstMini.first;\\n                firstMini = {grid[0][i], i};\\n            }\\n            else {\\n                secondMini = grid[0][i], secondMini; \\n            }\\n        }\\n\\n        for(int i=1;i<grid.size();i++) {\\n            pair<int, int> newFirstMini = {INT_MAX, -1};\\n            int newSecondMini = INT_MAX;\\n            for(int j=0;j<grid[0].size();j++) {\\n                int val = (j!=firstMini.second)? firstMini.first:secondMini;\\n                if((val + grid[i][j]) < newFirstMini.first) {\\n                    newSecondMini = newFirstMini.first;\\n                    newFirstMini = {val + grid[i][j], j};\\n                }\\n                else {\\n                    newSecondMini = min(newSecondMini, val + grid[i][j]);\\n                }\\n            }\\n            firstMini = newFirstMini;\\n            secondMini = newSecondMini;\\n        }\\n        return firstMini.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003009,
                "title": "simple-1d-vector-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<int>prev=grid[0];\\n        vector<int>curr(n,0);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                curr[j]=INT_MAX;\\n                for(int k=0;k<n;k++){\\n                    if(k!=j)curr[j]=min(curr[j],prev[k]);\\n                }\\n                curr[j]+=grid[i][j];\\n            }\\n            prev=curr;\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            ans=min(ans,prev[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<int>prev=grid[0];\\n        vector<int>curr(n,0);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                curr[j]=INT_MAX;\\n                for(int k=0;k<n;k++){\\n                    if(k!=j)curr[j]=min(curr[j],prev[k]);\\n                }\\n                curr[j]+=grid[i][j];\\n            }\\n            prev=curr;\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            ans=min(ans,prev[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979442,
                "title": "python-solution-with-using-previous-row-s-smallest-2-values",
                "content": "# Intuition\\nThe smallest in a row can be added to every element in next row except the element that has the same column. For the element in the same column, use the second-to-smallest in the row.\\n\\n# Approach\\nFor each row, maintain the two smallest. When adding to the next row, add previous row\\'s smallest to all elements except the one that has same column as previous row\\'s smallest. For that element, use previous row\\'s second-to-smallest. Once current row is computed, update current row\\'s two smallest and go to the next row and so on.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n) where m,n are #rows, #cols resp.\\n\\n- Space complexity:\\nO(1) since uses constant number of extra variables\\n\\n# Code\\n```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        # tuple: idx, val\\n        curr_smallest = (-1, 0)\\n        curr_second_smallest = (-1, 0)\\n\\n        for i in range(len(grid)):\\n            prev_smallest = curr_smallest\\n            prev_second_smallest = curr_second_smallest\\n            # grid max is 99\\n            curr_smallest = (-1, float(\\'inf\\'))\\n            curr_second_smallest = (-1, float(\\'inf\\'))\\n            for j in range(len(grid[0])):\\n                val = grid[i][j]\\n                val += prev_smallest[1] if j != prev_smallest[0] else prev_second_smallest[1]\\n                if val < curr_smallest[1]:\\n                    curr_second_smallest = curr_smallest\\n                    curr_smallest = (j, val)\\n                elif val < curr_second_smallest[1]:\\n                    curr_second_smallest = (j, val)\\n        \\n        return curr_smallest[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\\n        # tuple: idx, val\\n        curr_smallest = (-1, 0)\\n        curr_second_smallest = (-1, 0)\\n\\n        for i in range(len(grid)):\\n            prev_smallest = curr_smallest\\n            prev_second_smallest = curr_second_smallest\\n            # grid max is 99\\n            curr_smallest = (-1, float(\\'inf\\'))\\n            curr_second_smallest = (-1, float(\\'inf\\'))\\n            for j in range(len(grid[0])):\\n                val = grid[i][j]\\n                val += prev_smallest[1] if j != prev_smallest[0] else prev_second_smallest[1]\\n                if val < curr_smallest[1]:\\n                    curr_second_smallest = curr_smallest\\n                    curr_smallest = (j, val)\\n                elif val < curr_second_smallest[1]:\\n                    curr_second_smallest = (j, val)\\n        \\n        return curr_smallest[1]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567427,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1714777,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1568255,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1967986,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1715134,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1922984,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1915263,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1894810,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1872189,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1750208,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1567427,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1714777,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1568255,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1967986,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1715134,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1922984,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1915263,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1894810,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1872189,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            },
            {
                "id": 1750208,
                "content": [
                    {
                        "username": "Movsisyan",
                        "content": "The following test case is throwing runtime time error. \\n[[-73,61,43,-48,-36],[3,30,27,57,10],[96,-76,84,59,-15],[5,-49,76,31,-7],[97,91,61,-46,67]]"
                    },
                    {
                        "username": "rohit_rm",
                        "content": "facing same"
                    },
                    {
                        "username": "arctic_Oak",
                        "content": "Either I\\'ve become a pro in DP or this question is incorrectly marked as \"HARD\"! \\uD83D\\uDE42"
                    },
                    {
                        "username": "karanbangia14",
                        "content": "if you did it  in T.C O(n*n) and S.C O(1) then u r definitely god"
                    },
                    {
                        "username": "_shiv_70",
                        "content": "bro this question is incorrectly marked as hard even i was able to solve it in a one go\\nconsidering myself as beginner at dynamic programming"
                    },
                    {
                        "username": "KuShuLian",
                        "content": "![image](https://assets.leetcode.com/users/kushulian/image_1576374916.png)\\n![image](https://assets.leetcode.com/users/kushulian/image_1576374926.png)\\n"
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "is this the NINJA TRAINING problem from codeStudios with n tasks not 3 !!!"
                    },
                    {
                        "username": "RamanandYadav",
                        "content": "this question becomes hard type by mistake."
                    },
                    {
                        "username": "ltannn",
                        "content": "if you need the Editorial version of this problem, you can check out Paint House II !"
                    },
                    {
                        "username": "deadlysignal",
                        "content": "Easy question\\n"
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "class Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int n = grid.length;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int j=0; j<n; j++){\\n            ans = Math.min(ans, grid[0][j] + Dfn(grid, 1 , j));\\n        }\\n\\n        return ans;\\n    }\\n\\n    private int Dfn(int[][] grid, int i, int j){\\n        if(i >= grid.length) return 0;\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int k=0; k<grid[i].length && k!=j ; k++){\\n            ans = Math.min(ans, grid[i][k] + Dfn(grid, i+1, k));\\n        }\\n\\n        \\n        return ans;\\n    }\\n}\\n\\nCan You See Scomething Wrong In This Solution ?"
                    },
                    {
                        "username": "rohit_rm",
                        "content": " Why below code is not working ?\\n\\nclass Solution {\\n    public int minFallingPathSum(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int minVal = Integer.MAX_VALUE;\\n        Integer dp [][] = new Integer[m][n];\\n\\n        for(int i=0; i < n ; i++ ){\\n         minVal= Math.min(minVal, helper(grid, 0, i, m , n, i,dp));\\n        }\\n\\n        return minVal;\\n    }\\n\\n\\n    private int helper( int grid[][] , int row, int col, int m , int n, int prev, Integer dp[][]){\\n\\n        if(col < 0 || col>= n || (col== prev && row!=0)){\\n            return (int) 1e8;\\n        }\\n\\n        if( row == m-1 ){\\n            return grid[row][col];\\n        }\\n\\n        if(dp[row][col] != null){\\n            return dp[row][col];\\n        }\\n\\n        int left = grid[row][col] + helper(grid, row+1 , col-1 , m , n, col,dp);\\n        int right = grid[row][col] + helper(grid, row+1 , col+1 , m , n, col,dp);\\n        int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);\\n\\n        return dp[row][col]= Math.min(left, Math.min(right,front));\\n    }\\n}"
                    },
                    {
                        "username": "keshav3899",
                        "content": "You are including the adjacent row . i.e ( int front = grid[row][col] + helper(grid, row+1 , col , m , n, col,dp);)"
                    },
                    {
                        "username": "yashleetcode123",
                        "content": "My n**2 solution is giving tle please help `your inline code\\n\\n\\n        n=len(matrix)\\n        if n==1:\\n            return matrix[0][0]\\n        \\n        @lru_cache(maxsize=None)\\n        def dfs(i,k):\\n            \\n            if i==n:\\n                return 0\\n            # if arr[i][k]!=-10**5:\\n            #     return arr[i][k]\\n            # self.n1+=1\\n            # if self.n1>4*10**4:\\n            #     print(self.n1)\\n            ans=10**5\\n            for j in range(n):\\n                if j!=k:\\n                    \\n                \\n                    ans=min(ans,matrix[i][j]+dfs(i+1,j))\\n            # dp[(i,k)]=ans\\n            # arr[i][k]=ans\\n            return ans\\n            \\n            \\n       \\n        x=dfs(0,-1)\\n            \\n        return x\\nyour inline code...`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Convert Binary Number in a Linked List to Integer",
        "question_content": "<p>Given <code>head</code> which is a reference node to a singly-linked list. The value of each node in the linked list is either <code>0</code> or <code>1</code>. The linked list holds the binary representation of a number.</p>\n\n<p>Return the <em>decimal value</em> of the number in the linked list.</p>\n\n<p>The <strong>most significant bit</strong> is at the head of the linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/05/graph-1.png\" style=\"width: 426px; height: 108px;\" />\n<pre>\n<strong>Input:</strong> head = [1,0,1]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> (101) in base 2 = (5) in base 10\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [0]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The Linked List is not empty.</li>\n\t<li>Number of nodes will not exceed <code>30</code>.</li>\n\t<li>Each node&#39;s value is either <code>0</code> or <code>1</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 629087,
                "title": "detailed-explanation-java-faster-than-100-00",
                "content": "Using the number 123 as an example, then from basic Math, we know this:\\n-\\t1 is in the hundreds column so it\\u2019s value is 100\\n-\\t2 is in the tens column so it\\u2019s value is 20\\n-\\t3 is in the ones column so it\\u2019s value is just 3\\n\\nLet\\u2019s forget about binary for a second and focus on decimal counting since that\\u2019s what humans use. So, if we were to convert the string \\u201C123\\u201D to integer 123, we\\u2019ll go through each character one at a time.\\n\\nWhen we start with the first character, 1, we don\\u2019t really know it\\u2019s value is yet. i.e whether it\\u2019s in the millions or hundreds or thousands etc. But, we do know that if we encounter a character again, then it\\u2019s value has to go up by x10.\\n\\nSo if we get 1, we assume it\\u2019s just 1. Then we encounter 2. At this point, we realize that the previous was is no longer just a 1 but (1 x 10). So we do that arithmetic and then add the current value. This is how is looks like in tabular form.\\n\\n```\\nLoop\\tCharacter\\tOperation\\t  Result\\n1\\t    \\u20181\\u2019\\t        1\\t          1\\n2\\t    \\u20182\\u2019\\t        (1x10) + 2\\t  12\\n3\\t    \\u20183\\u2019\\t        (12*10) + 3\\t  123\\n```\\n\\n**Note**: Operation is always the previous multiplied by the counting system. In this this, we\\'re doing decimal so x10. If we were doing hex, it\\'ll x16. Binary will be x 2.\\n\\n\\nUsing this logic, let\\u2019s come back to binary. It\\u2019s exactly the same except for instead of multiplying by 10 when we encounter the next digit, we multiply by 2. So If we have a LinkeList `1 -> 0 -> 1` and apply the same logic, this is how it\\'ll be\\n \\n ```\\nLoop\\tCharacter\\tOperation\\t  Result\\n1\\t    \\u20181\\u2019\\t        1\\t          1\\n2\\t    \\u20180\\u2019\\t        (1x2) + 0\\t  2\\n3\\t    \\u20181\\u2019\\t        (2*2) + 1\\t  5\\n```\\n\\n\\n```\\npublic int getDecimalValue(ListNode head) {\\n       int sum = 0;\\n        \\n        while (head != null){\\n            sum *= 2;\\n            sum += head.val;\\n            head = head.next;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nLoop\\tCharacter\\tOperation\\t  Result\\n1\\t    \\u20181\\u2019\\t        1\\t          1\\n2\\t    \\u20182\\u2019\\t        (1x10) + 2\\t  12\\n3\\t    \\u20183\\u2019\\t        (12*10) + 3\\t  123\\n```\n```\\nLoop\\tCharacter\\tOperation\\t  Result\\n1\\t    \\u20181\\u2019\\t        1\\t          1\\n2\\t    \\u20180\\u2019\\t        (1x2) + 0\\t  2\\n3\\t    \\u20181\\u2019\\t        (2*2) + 1\\t  5\\n```\n```\\npublic int getDecimalValue(ListNode head) {\\n       int sum = 0;\\n        \\n        while (head != null){\\n            sum *= 2;\\n            sum += head.val;\\n            head = head.next;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455239,
                "title": "python-simple-20ms",
                "content": "Read the binary number from MSB to LSB\\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        answer = 0\\n        while head: \\n            answer = 2*answer + head.val \\n            head = head.next \\n        return answer \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        answer = 0\\n        while head: \\n            answer = 2*answer + head.val \\n            head = head.next \\n        return answer \\n```",
                "codeTag": "Java"
            },
            {
                "id": 451815,
                "title": "java-python-3-simulate-binary-operations",
                "content": "Please refer to the following excellent picture from **@YaoFrankie**.\\n<img src=\"https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_1290.png\" alt=\"\">\\n\\n\\n----\\n**Q & A**\\nQ1.  Can u explain what this line does: `ans = (ans << 1) | head.val`?\\nA1. `ans` starts with `0`, left shift `ans` for `1` bit, then bitwise `or` with `head.val`. \\ne.g., for test case: [0,1,0,1], the value of head is 0 -> 1 -> 0 -> 1. \\n\\nYou can compare it with the following, which has same result:\\n```\\nans = ans * 2 + head.val;\\n```\\n\\nIf anyone is having problems with bitwise operations then you can read this:\\n[link to article](https://dev.to/the_unconventional_coder/bit-manipulation-hacks-3n88) - credit to **@Abhinava_Ghosh**\\n\\n\\n\\nGoogle \"bitwise operations\" if still confused.\\n\\n**end of Q & A**\\n\\n----\\n\\n```java\\n    public int getDecimalValue(ListNode head) {\\n        int ans = 0;\\n        while (head != null) {\\n            ans = (ans << 1) | head.val;\\n            head = head.next;\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        ans = 0\\n        while head:\\n            ans = (ans << 1) | head.val\\n            head = head.next\\n        return ans\\n```\\nUse `walrus` operator in Python 3.8:\\n```python\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        ans = head.val\\n        while head := head.next:\\n            ans = ans << 1 | head.val\\n        return ans\\n```\\n**Analysis:**\\nTime: O(n), space: O(1), where n is the number of nodes.\\n\\n----\\n\\nFor more bit shift operations practice and solution, refer to [1018. Binary Prefix Divisible By 5](https://leetcode.com/problems/binary-prefix-divisible-by-5/discuss/265554/Java-7-liner-left-shift-bitwise-or-and-mod.)",
                "solutionTags": [],
                "code": "```\\nans = ans * 2 + head.val;\\n```\n```java\\n    public int getDecimalValue(ListNode head) {\\n        int ans = 0;\\n        while (head != null) {\\n            ans = (ans << 1) | head.val;\\n            head = head.next;\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        ans = 0\\n        while head:\\n            ans = (ans << 1) | head.val\\n            head = head.next\\n        return ans\\n```\n```python\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        ans = head.val\\n        while head := head.next:\\n            ans = ans << 1 | head.val\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1615821,
                "title": "c-all-approaches-detailed-explanation-bit-manipulation",
                "content": "**Let\\'s lool at how the Binary to Decimal conversion takes place !!**\\n![image](https://assets.leetcode.com/users/images/f263a86a-6eec-4865-9385-e622f72f5a3d_1638844214.7336144.png)\\nAs we can see here that to form the Decimal Number, we just need to multiply the binary digits at each node of Linked List with an appropriate power of 2 ... And this Power of 2 basically increases as we move in the backward direction !!\\n\\n1. **Approach 1 ::**\\nIt\\'s very basic to observe that we don\\'t know by what power of 2 we will be multipying the first Node of the List if we try to iterate in the forward direction , so we would just convert the the Linked_list into a string and then traverse over it in the backward direction... **Multiplying each index by increasing pow(2) and keep adding the result to form the desired Decimal answer...**\\n\\n**Time Complexity :: O(n)** and **Space Complexity :: O(n)**\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string num;\\n        while(head!=NULL){\\n            num+=to_string(head->val);\\n            head=head->next;\\n        }\\n        int res=0,pv=1;\\n        for(int i=num.size()-1;i>=0;i--){\\n            res+=pv*(stoi(num.substr(i,1)));\\n            pv*=2;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n2. **Approach 2 ::**\\nTo **optimize the space** and to make our solution **one-pass** we need to figure out a way to iterate in the forward direction and get the desired result ....\\n![image](https://assets.leetcode.com/users/images/ce2ba119-4af3-49cc-b5f5-7a3e2748c9f9_1638845068.9897215.png)\\nWe are maintaining the answer till each node and at each node we are multiplying the answer by 2 adding the node->val !!\\n\\n**Time Complexity :: O(n)** and **Space Complexity :: O(1)**\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=0;\\n        while(head!=NULL){\\n            res=res*2+head->val;\\n            head=head->next;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n3. **Approach 3 ::**\\nApproach is same actually , it\\'s just we are gonna achieve it via bitwise operators, it is beneficial as they work faster than the arithmatic operators !!\\n\\n**Time Complexity :: O(n)** and **Space Complexity :: O(1)**\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res = 0;\\n        ListNode* iter = head;\\n        while (iter != NULL) {\\n            res <<= 1;\\n            res |= iter->val;\\n            iter = iter->next;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**To visualize it -->**\\nour sum = 0\\nAnd we are gonna do 2 steps --->>>\\n1. sum * 2 = sum (left shift <<)\\n2. sum + 1 or 0 = sum \\nAnd will run a loop over these 2 steps until head becomes NULL.....\\n\\n    For example ---> Binary number --> 10110\\n    \\n* left shift 1 =>  ( 0 * 2 ) =  0\\n* After sum    =>  0 + 1 = 1\\n\\n* left shift 1 =>  ( 1 * 2 ) =  2\\n* After sum    =>  2 + 0 = 2\\n* left shift 1 =>  ( 2 * 2 ) =  4\\n* After sum    =>  4 + 1 = 5\\n* left shift 1 =>  ( 5 * 2 ) =  10\\n* After sum    =>  10 + 1 = 11\\n* left shift 1 =>  ( 11 * 2 ) =  22\\n* After sum    =>  22 + 0 = 22\\n\\n**And that\\'s how we achieve the desired result!!**\\n\\n4. **Approach 4 :: 1-liner**\\nHow can we miss the recursive 1-liner !!\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head, int res = 0) {\\n        return head ? getDecimalValue(head->next, res * 2 + head->val) : res;\\n    }\\n};\\n```\\nNo explanation, 1-liners are for fun ... :)\\n**Thanks for reading it out !!**\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string num;\\n        while(head!=NULL){\\n            num+=to_string(head->val);\\n            head=head->next;\\n        }\\n        int res=0,pv=1;\\n        for(int i=num.size()-1;i>=0;i--){\\n            res+=pv*(stoi(num.substr(i,1)));\\n            pv*=2;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=0;\\n        while(head!=NULL){\\n            res=res*2+head->val;\\n            head=head->next;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res = 0;\\n        ListNode* iter = head;\\n        while (iter != NULL) {\\n            res <<= 1;\\n            res |= iter->val;\\n            iter = iter->next;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head, int res = 0) {\\n        return head ? getDecimalValue(head->next, res * 2 + head->val) : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452970,
                "title": "java-easy-solution-with-explanation-must-read",
                "content": "We initialise an integer variable num to 0. For each node in the linked list, we will left shift num by 1 position to make way for the val in the next node in linked list. This is same as multiplying num by 2, but using the left shift operator makes it easier to visualise how the binary number is being made. For eg. if num in binary is 10, after left shift it would become 100. \\n\\n```\\npublic int getDecimalValue(ListNode head) {\\n\\tint num = 0;                // Initialise num to 0\\n\\twhile(head!=null) {         // Iteratore over the linked list until head is null    \\n\\t\\tnum <<= 1;              // Left shift num by 1 position to make way for next bit\\n\\t\\tnum += head.val;        // Add next bit to num at least significant position\\n\\t\\thead = head.next;       // Update head\\n\\t}\\n\\treturn num;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getDecimalValue(ListNode head) {\\n\\tint num = 0;                // Initialise num to 0\\n\\twhile(head!=null) {         // Iteratore over the linked list until head is null    \\n\\t\\tnum <<= 1;              // Left shift num by 1 position to make way for next bit\\n\\t\\tnum += head.val;        // Add next bit to num at least significant position\\n\\t\\thead = head.next;       // Update head\\n\\t}\\n\\treturn num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451805,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ret = 0;\\n        while(head)\\n        {\\n            ret <<= 1;\\n            ret |= head->val;\\n            head = head->next;\\n        }\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ret = 0;\\n        while(head)\\n        {\\n            ret <<= 1;\\n            ret |= head->val;\\n            head = head->next;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615855,
                "title": "java-two-line-code-100-faster",
                "content": "**Kepoint** \\uD83E\\uDD14- Here In single linked list we can only traverse from start to end , binary last bit is present at tail of linked list .\\n* We will use **Left Shift Operator**\\n##### DONT SEE CODE - JUST READ EXAMPLE \\n**Example:**\\nhead = [1,0,1,1]\\n```\\n\\t              ->    Intialize ans = 0\\n\\t\\t\\t\\t  operation  => ans = ( ans<<1) + head.val\\n\\t\\t\\t\\t  \\n                              1           0            1            1\\n   pointer       \\t\\t\\t  ^\\n\\t\\t\\t\\t\\t\\t\\t  ans = (0<<1) + 1\\n\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t=> ans  =  1*(2^0) \\n-----------------------------------------------------------------------------------\\n\\t\\t\\t\\t-> To add 0 we will left shift ans till now by 1 position\\n                              1           0            1            1\\n     pointer        \\t\\t\\t          ^\\n\\t\\t\\t\\t\\t\\t\\t  ans =  (1<<1)+0\\t= \\t\\t2\\t  \\n\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t   => ans  =  1*(2^1) +  0*(2^1)\\n------------------------------------------------------------------------------------\\n\\t\\t\\t\\t-> Again to add 1 shift ans till now by 1 position\\n                              1           0            1           1\\n\\t         pointer        \\t\\t\\t               ^\\n\\t\\t\\t\\t\\t\\t\\t  ans =  \\t(2<<1)+1 = 4+1=5\\n\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t=> ans  =  1*(2^2) +  0*(2^1)  +  1*(2^0)\\n------------------------------------------------------------------------------------\\n\\t\\t\\t-> Again to add 1 shift ans till now by 1 position\\n                              1           0            1             1\\n\\t\\tpointer         \\t\\t\\t                                 ^  \\n\\t\\t\\t\\t\\t\\t\\t  ans =  \\t(5<<1)+1 = 10+1 =  11\\n\\t\\t\\t\\t\\t\\t\\t  \\t\\t\\t\\t\\t\\t\\t  \\t\\t\\t\\t\\t\\t\\t  \\n               \\t  => ans  =  1*(2^3) +  0*(2^2)  +  1*(2^1) +   1*(2^0)\\t\\t\\t\\t\\t\\t\\t  \\n\\n```\\n\\n---  \\n### Code \\uD83D\\uDCBB\\uD83D\\uDC4D\\uD83C\\uDFFB\\n***\\n\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {     \\n        int ans = 0;\\n        for(ListNode temp =  head;temp!=null;temp=temp.next){\\n            ans =  (ans<<1)+temp.val;\\n        }                \\n        return ans;        \\n    }\\n}\\n```\\n\\n\\n### \\uD83E\\uDD84Upvote if it help You",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t              ->    Intialize ans = 0\\n\\t\\t\\t\\t  operation  => ans = ( ans<<1) + head.val\\n\\t\\t\\t\\t  \\n                              1           0            1            1\\n   pointer       \\t\\t\\t  ^\\n\\t\\t\\t\\t\\t\\t\\t  ans = (0<<1) + 1\\n\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t=> ans  =  1*(2^0) \\n-----------------------------------------------------------------------------------\\n\\t\\t\\t\\t-> To add 0 we will left shift ans till now by 1 position\\n                              1           0            1            1\\n     pointer        \\t\\t\\t          ^\\n\\t\\t\\t\\t\\t\\t\\t  ans =  (1<<1)+0\\t= \\t\\t2\\t  \\n\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t   => ans  =  1*(2^1) +  0*(2^1)\\n------------------------------------------------------------------------------------\\n\\t\\t\\t\\t-> Again to add 1 shift ans till now by 1 position\\n                              1           0            1           1\\n\\t         pointer        \\t\\t\\t               ^\\n\\t\\t\\t\\t\\t\\t\\t  ans =  \\t(2<<1)+1 = 4+1=5\\n\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t=> ans  =  1*(2^2) +  0*(2^1)  +  1*(2^0)\\n------------------------------------------------------------------------------------\\n\\t\\t\\t-> Again to add 1 shift ans till now by 1 position\\n                              1           0            1             1\\n\\t\\tpointer         \\t\\t\\t                                 ^  \\n\\t\\t\\t\\t\\t\\t\\t  ans =  \\t(5<<1)+1 = 10+1 =  11\\n\\t\\t\\t\\t\\t\\t\\t  \\t\\t\\t\\t\\t\\t\\t  \\t\\t\\t\\t\\t\\t\\t  \\n               \\t  => ans  =  1*(2^3) +  0*(2^2)  +  1*(2^1) +   1*(2^0)\\t\\t\\t\\t\\t\\t\\t  \\n\\n```\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {     \\n        int ans = 0;\\n        for(ListNode temp =  head;temp!=null;temp=temp.next){\\n            ans =  (ans<<1)+temp.val;\\n        }                \\n        return ans;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615747,
                "title": "java-4-solutions-bit-manipulation-detailed-explanation",
                "content": "**Intution:** The intution is pretty simple that we have to convert the binary number formed through given linked list in decimal form. For this we have to multiply each digit of binary number with appropriate power of 2 and then keep adding to form a decimal number.\\nFor Example:\\n```\\nhead = 1 -> 1 -> 0 -> 0        \\n```\\nThe binary number formed will be 1100 and to convert it to decimal number we have to do :-\\n1* (2^3) + 1* (2^2) + 0* (2^1) + 0* (2^0) = 1 * 8 + 1 * 4 + 0 * 2 + 0 * 1 = 12\\n\\n**Approach1: Using ArrayList**  [T.C: O(n), S.C: O(n)]\\n**Explanation:** Store all the digits in arraylist and then traverse the list backward and keep adding the element in your answer after multilying it by suitable power of 2.\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n       \\n        int res = 0;\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        while(head!=null){\\n            list.add(head.val);\\n            head = head.next;\\n        }\\n        int p = 0;\\n        for(int i=list.size()-1;i>=0;i--){\\n            int pow = (1<<p);    //  Finding 2 to the power p\\n            res += (pow*list.get(i));\\n            p++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Approach2: Using String** [T.C: O(n), S.C: O(n)] \\n**Explanation:** Strore all the digits in a String and then convert it into decimal.\\n\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        String s =\"\";\\n        while(head!=null){\\n            s=s+Integer.toString(head.val);\\n            head=head.next;\\n        }\\n\\n        return Integer.parseInt(s,2);   // we can pass the radix also in which the number has to be converted\\n    }\\n}\\n```\\n\\n**Approach3: One Pass Solution Using Maths** [T.C: O(n), S.C: O(1)] \\n**Explanation:** To explain binary number..let first understand the decimal number.\\nSo if you have given digits 1,2,3 and you have to make the number then you will do - 1 * 100 + 2 * 10 + 1 = 123. But in starting we don\\'t know whether to multiply the current digit with 10 or 100 or 1000 etc., so what we do is just take the first digit in answer and then if we encounter next digit then multiply the previous answer by 10 and then add the current number.\\nExample:\\n```\\nLets the digits are 1,2,3,4 and let the ans is 0.\\nIteration1 : ans = 1  (keep the first digit as it is or (0*10+1=1))\\nIteration2 : ans * 10  + 2 = 1*10 + 2 = 12\\nIteration3 : ans * 10 + 3 = 12*10 + 3 = 123\\nIteration4 : ans * 10 + 4 = 123*10 + 4 = 1234\\n```\\nSo each time when we encountered a digit, we multiplied the previous ans by 10 and then add the current digit.\\nSimilar is the case with binary conversion. Here we were mutliplying the prev ans by 10 but in binary we have multiply it by 2.\\nFor example :\\n```\\nLets the digits are 1,0,1,1 and let ans is 0\\nIteration1 : ans = 1 (keep the first digit as it is or (0*2+1=1))\\nIteration2 : ans * 2 + 0 = 1*2 + 0 = 2\\nIteration3 : ans * 2 + 1 = 2*2 + 1 = 5\\nIteration4 : ans * 2 + 1 = 5*2 + 1 = 11\\n```\\n\\n ```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int res = 0;\\n        \\n        while(head!=null){\\n            res = res*2 + head.val;\\n            head = head.next;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Approach4: Bit Manipulation**\\n**Explanation:** Logic Exactly same as Approach3...just the arithmetical operations are done using bit manipulation.\\nAs left shift of the number by 1 gives 2 times the number.\\n3<<1 = 6 \\n\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int res = 0;\\n        \\n        while(head!=null){\\n            res = res<<1 | head.val;   // res = res*2 + head.val;\\n            head = head.next;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nThanks for giving it a read!!",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nhead = 1 -> 1 -> 0 -> 0        \\n```\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n       \\n        int res = 0;\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        while(head!=null){\\n            list.add(head.val);\\n            head = head.next;\\n        }\\n        int p = 0;\\n        for(int i=list.size()-1;i>=0;i--){\\n            int pow = (1<<p);    //  Finding 2 to the power p\\n            res += (pow*list.get(i));\\n            p++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        String s =\"\";\\n        while(head!=null){\\n            s=s+Integer.toString(head.val);\\n            head=head.next;\\n        }\\n\\n        return Integer.parseInt(s,2);   // we can pass the radix also in which the number has to be converted\\n    }\\n}\\n```\n```\\nLets the digits are 1,2,3,4 and let the ans is 0.\\nIteration1 : ans = 1  (keep the first digit as it is or (0*10+1=1))\\nIteration2 : ans * 10  + 2 = 1*10 + 2 = 12\\nIteration3 : ans * 10 + 3 = 12*10 + 3 = 123\\nIteration4 : ans * 10 + 4 = 123*10 + 4 = 1234\\n```\n```\\nLets the digits are 1,0,1,1 and let ans is 0\\nIteration1 : ans = 1 (keep the first digit as it is or (0*2+1=1))\\nIteration2 : ans * 2 + 0 = 1*2 + 0 = 2\\nIteration3 : ans * 2 + 1 = 2*2 + 1 = 5\\nIteration4 : ans * 2 + 1 = 5*2 + 1 = 11\\n```\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int res = 0;\\n        \\n        while(head!=null){\\n            res = res*2 + head.val;\\n            head = head.next;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int res = 0;\\n        \\n        while(head!=null){\\n            res = res<<1 | head.val;   // res = res*2 + head.val;\\n            head = head.next;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451811,
                "title": "python3-concise-solution",
                "content": "Algorithm: \\nLoop through the linked list and added value to answer. \\n\\nImplementation: \\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        ans = 0\\n        while head: \\n            ans = 2*ans + head.val \\n            head = head.next \\n        return ans \\n```\\nAnalysis:\\nTime complexity `O(N)`\\nSpace complexity `O(1)`\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        ans = 0\\n        while head: \\n            ans = 2*ans + head.val \\n            head = head.next \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615998,
                "title": "c-python-3-simple-solutions-w-explanation-list-to-string-to-decimal-direct-conversion",
                "content": "We are given a linked-list holding binary representation of number and we need to return its decimal value.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Get values into string & Convert to Decimal)***\\n\\nWe can simply traverse the linked-list and store the binary number into a string. Finally we convert the binary number stored in string to decimal integer and return it.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string s{};\\n        for(; head; head = head -> next) s += head -> val + \\'0\\';\\n        return stoull(s, 0, 2);\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def getDecimalValue(self, head):\\n        s = \"\"\\n        while head:\\n            s += str(head.val)\\n            head = head.next\\n        return int(s, 2)\\n```\\n\\nor we can use manual conversion for it. In linked-list we didn\\'t know what value each node contributed since we didnt knew total number of nodes. However, when we have converted it to string, we can simply traverse from the end to 1st character of string, starting with power of 2: `p=1` and each iteration multiply `p` by 2. If the node is `\\'1\\'`, we will add the value `p` to `ans`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string s;\\n        for(; head; head = head -> next) s.push_back(head -> val+\\'0\\');\\n        int ans = 0;\\n        for(int i = size(s)-1, p = 1; i >= 0; i--, p *= 2)\\n            ans += p * (s[i] == \\'1\\');\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def getDecimalValue(self, head):\\n        s, ans, p = \"\", 0, 1\\n        while head:\\n            s += str(head.val)\\n            head = head.next\\n        for i in range(len(s)-1, -1, -1):\\n            ans += p if s[i] == \\'1\\' else 0\\n            p *= 2\\n        return ans\\n```\\n\\n\\n\\n***Time Complexity :*** <code>O(N)</code>, where `N` is number of nodes in linked list\\n***Space Complexity :*** <code>O(N)</code>, to store string\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive)***\\n\\nWe can do it recursively as well similar to above. We recurse till the last node and add each node\\'s value on the way back up.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int p = 0;\\n    int getDecimalValue(ListNode* head) {\\n        return head ? getDecimalValue(head -> next) + (head -> val << p++) : 0;\\n    }\\n};\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, where `N` is number of nodes in linked list\\n***Space Complexity :*** <code>O(N)</code>, for recursive stack\\n\\n---\\n\\n\\n\\n\\u2714\\uFE0F ***Solution - III (Direct Conversion using Bit-Manipulation)***\\n\\nWe dont need to convert from linked-list to string and then to decimal. For direct conversion from linked-list to decimal, we can use the observation that **addition of each new node will multiply all current node\\'s value by 2.**\\n\\n```python\\nFor eg. \\nLinked-list:   1  ->  0  ->  1\\nNode value:    4      2      1\\nDecimal =      4  +   0  +   1 = 5\\n\\nNow, suppose we found another node with value 1 at end of list\\n\\nlinked-list:   1  ->  0  ->  1  ->  1\\nNode value:    8      4      2      1      (Each of existing 1st three node value got multiplied by 2)\\nDecimal =      8  +   0  +   2  +   1  =  11  =  (4*2 + 0*2 + 1*2) + 1  =  2*prevNum + 1\\n\\nNow, suppose we found another node with value 0 at end of list\\n\\nlinked-list:    1  ->  0  ->  1  ->  1  ->  0\\nNode value:     16     8      4      2      1      \\nDecimal =       16  +  0  +   4  +   2  +   0  =  22  =  (8*2 + 0*2 + 2*2 + 1*2) + 0  =  2*prevNum + 0\\n```\\n\\nThus, we start with `ans = 0` and iterate over linked-list. For each node that we find, we do `ans = ans*2` and if node\\'s value is 1, we add 1 to it. \\n\\nA slightly better way would be to use `<<` operator. `ans << 1` does the same thing as `ans * 2` but can be understood as - we found a new node, so shift all current bits to right and add new bit at the end of `ans`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans = 0;\\n        for(; head; head = head -> next) \\n            ans = (ans << 1) + head -> val;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def getDecimalValue(self, head):\\n        ans = head.val\\n        while head := head.next:\\n            ans = (ans << 1) + head.val\\n        return ans\\n```\\n\\n\\n***Time Complexity :*** <code>O(N)</code>, to traverse the linked-list once.\\n***Space Complexity :*** <code>O(1)</code>, only constant extra space is used\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string s{};\\n        for(; head; head = head -> next) s += head -> val + \\'0\\';\\n        return stoull(s, 0, 2);\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def getDecimalValue(self, head):\\n        s = \"\"\\n        while head:\\n            s += str(head.val)\\n            head = head.next\\n        return int(s, 2)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string s;\\n        for(; head; head = head -> next) s.push_back(head -> val+\\'0\\');\\n        int ans = 0;\\n        for(int i = size(s)-1, p = 1; i >= 0; i--, p *= 2)\\n            ans += p * (s[i] == \\'1\\');\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def getDecimalValue(self, head):\\n        s, ans, p = \"\", 0, 1\\n        while head:\\n            s += str(head.val)\\n            head = head.next\\n        for i in range(len(s)-1, -1, -1):\\n            ans += p if s[i] == \\'1\\' else 0\\n            p *= 2\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int p = 0;\\n    int getDecimalValue(ListNode* head) {\\n        return head ? getDecimalValue(head -> next) + (head -> val << p++) : 0;\\n    }\\n};\\n```\n```python\\nFor eg. \\nLinked-list:   1  ->  0  ->  1\\nNode value:    4      2      1\\nDecimal =      4  +   0  +   1 = 5\\n\\nNow, suppose we found another node with value 1 at end of list\\n\\nlinked-list:   1  ->  0  ->  1  ->  1\\nNode value:    8      4      2      1      (Each of existing 1st three node value got multiplied by 2)\\nDecimal =      8  +   0  +   2  +   1  =  11  =  (4*2 + 0*2 + 1*2) + 1  =  2*prevNum + 1\\n\\nNow, suppose we found another node with value 0 at end of list\\n\\nlinked-list:    1  ->  0  ->  1  ->  1  ->  0\\nNode value:     16     8      4      2      1      \\nDecimal =       16  +  0  +   4  +   2  +   0  =  22  =  (8*2 + 0*2 + 2*2 + 1*2) + 0  =  2*prevNum + 0\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans = 0;\\n        for(; head; head = head -> next) \\n            ans = (ans << 1) + head -> val;\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def getDecimalValue(self, head):\\n        ans = head.val\\n        while head := head.next:\\n            ans = (ans << 1) + head.val\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732045,
                "title": "c-recursive-vs-iterative-approach-both-around-100-time-100-space",
                "content": "I thought this was an excellent training ground to compare the 2 approaches: simple problem, so our hands are free from some complex bits of logic, little to write, pretty straightforward approach.\\n\\nThe recursive one was probably more fun, as it is often the case with straight one-liners; notice that in order for it to work we needed to modify the function signature, adding the accumulator variable `res`, defaulting it to `0` and returning it when `head` is `NULL` - ie: we are done:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head, int res = 0) {\\n        return head ? getDecimalValue(head->next, res * 2 + head->val) : res;\\n    }\\n};\\n```\\n\\nThe iterative one is probably what your compiler would turn a tail recursive approach into anyway; IMHO is slightly less elegant once you expand the logic to work step-by-step, but it might also be more understandable for beginners: I moved the declaration of `res` from the signature of the function to its body, wrapped the whole advancing logic into a `while` loop and finally returned `res`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res = 0;\\n        while (head) {\\n            res = res * 2 + head->val;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head, int res = 0) {\\n        return head ? getDecimalValue(head->next, res * 2 + head->val) : res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res = 0;\\n        while (head) {\\n            res = res * 2 + head->val;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451818,
                "title": "simple-java-code-multiplying-each-value-by-2",
                "content": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num = 0;\\n        while(head != null) {\\n            num = num*2 + head.val;\\n            head = head.next;\\n        }\\n        return num;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num = 0;\\n        while(head != null) {\\n            num = num*2 + head.val;\\n            head = head.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 461356,
                "title": "javascript-easy-to-understand-bit-operator",
                "content": "Since the value in the linked list is binary, we can get the final value easily via bit operator.\\nAnd the only thing we need to do right now is traversal the linked list.\\n\\nHere\\'s the code:\\n\\n```js\\nconst getDecimalValue = head => {\\n  let val = 0;\\n  while (head) {\\n    val = (val << 1) | head.val;\\n    head = head.next;\\n  }\\n  return val;\\n};\\n```\\n\\n----\\n\\nUPDATE: add some explaination for the bit manipulation.\\n\\nFirst, the `<<` operation means to move to left by n bit in the binary representation.\\nSo if the binary representation is `100`, we could make it by `1 << 3` or 3 times to move to left by 1 bit.\\n\\nThen, the `|` operation has almost the same logic as `||` but it\\'s for bit manipulation.\\nBut here in my code, I use it in a tricky way -- to add the `head.val` into `val`. You may take a look at this:\\n\\n```js\\n0 | 0 === 0\\n0 | 1 === 1\\n```\\nSince we move the `val` to left by 1 bit, the last bit is always `0`.\\nWe could imagine that the two numbers are the factor for the add operation. And we could find out that the results just match the results for addition.\\n\\nSo that\\'s all for `val = (val << 1) | head.val`. And here\\'s a sample:\\n\\n```shell\\nlinked list: 1 -> 0 -> 1\\nval: 0\\n\\nhead: 1\\nval = (val << 1) | head.val // val = (0 << 1) | 1 => val = 1\\n\\nhead: 0\\nval = (val << 1) | head.val // val = (1 << 1) | 0  => val = 10\\n\\nhead: 1\\nval = (val << 1) | head.val // val = (10 << 1) | 1  => val = 101\\n\\nhead: null\\ndone\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst getDecimalValue = head => {\\n  let val = 0;\\n  while (head) {\\n    val = (val << 1) | head.val;\\n    head = head.next;\\n  }\\n  return val;\\n};\\n```\n```js\\n0 | 0 === 0\\n0 | 1 === 1\\n```\n```shell\\nlinked list: 1 -> 0 -> 1\\nval: 0\\n\\nhead: 1\\nval = (val << 1) | head.val // val = (0 << 1) | 1 => val = 1\\n\\nhead: 0\\nval = (val << 1) | head.val // val = (1 << 1) | 0  => val = 10\\n\\nhead: 1\\nval = (val << 1) | head.val // val = (10 << 1) | 1  => val = 101\\n\\nhead: null\\ndone\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453677,
                "title": "0-ms-faster-than-100-00-of-c-8-5-mb-less-than-100-00-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int s=0;\\n        while(head!=NULL){\\n            s=s*2+head->val;\\n            head=head->next;\\n        }\\n        return s;\\n    }\\n};\\n```\\nfeel free to comment",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int s=0;\\n        while(head!=NULL){\\n            s=s*2+head->val;\\n            head=head->next;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572227,
                "title": "power-of-two-python-o-n-time-o-1-space",
                "content": "Hi LeetCoders! Here is my very simple, however a little bit tricky solution to this problem.\\n\\n**Explanation:**\\nThe idea is to treat each element in the list as a first one. But what happens with elements that are already traversed? Well. I suggest you first draw the binary \"ruler\".\\n```... - 16 - 8 - 4 - 2 - 1```\\nAnd now answer the question of what would you do if I will ask you to add the next \"mark\" after \"16\" on your ruler? Your answer is the idea of this approach.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        decimal = 0\\n        while head:\\n            decimal = decimal * 2 + head.val\\n            head = head.next\\n        return decimal\\n```\\n\\n**Algorithm complexity:**\\n*Time complexity: O(n).*\\n*Space complexity: O(1).*\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I wish you an enjoyable time on LeetCode. \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```... - 16 - 8 - 4 - 2 - 1```\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        decimal = 0\\n        while head:\\n            decimal = decimal * 2 + head.val\\n            head = head.next\\n        return decimal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918946,
                "title": "python-simple-o-n-solution-explained",
                "content": "What we need to do in this problem is just to understand how binary numbers work. Imagine, that we have number `101100`. Then, it is equal to `1*2^5 + 0*2^4 + 1*2^3 + 1*2^2 + 0*2^1 + 0^2^0`.\\n\\nSo what we need to do is just to iterate over our linked list, multiply current `s` by `2` and add value of new element!\\n\\n**Complexity**: time complexity is `O(n)`, where `n` is length of our linked list and space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def getDecimalValue(self, head):\\n        s = 0\\n        while head:\\n            s = 2*s + head.val\\n            head = head.next\\n        return s\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getDecimalValue(self, head):\\n        s = 0\\n        while head:\\n            s = 2*s + head.val\\n            head = head.next\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452129,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int GetDecimalValue(ListNode head) \\n    {\\n        int num = 0;\\n        while(head != null)\\n        {\\n            num = (num * 2) + head.val;\\n            head = head.next;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int GetDecimalValue(ListNode head) \\n    {\\n        int num = 0;\\n        while(head != null)\\n        {\\n            num = (num * 2) + head.val;\\n            head = head.next;\\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415153,
                "title": "conversion-using-doubling-method-explanation-code",
                "content": "# Explanation\\n## Binary to Decimal Conversion Using Doubling Method\\nAs the name suggests, the process of doubling or multiplying by 2 is done to convert binary to decimal. Let us use the same example for converting the binary number \\n101101\\n to decimal. Observe the following steps given below to understand the binary to decimal conversion using the doubling method.\\n\\nStep 1: Write the binary number and start from the left-most digit. Double the previous number and add the current digit. Since we are starting from the left-most digit and there is no previous digit to the left-most digit, we consider the double of the previous digit as 0. For example in  101101\\n the left-most digit is \\'1\\'. The double of the previous number is 0. Therefore, we get ((0 \\xD7 2) + 1) which is 1.\\nStep 2: Continue the same process for the next digit also. The second digit from the left is 0. Now, double the previous digit and add it with the current digit. Therefore, we get, [(1 \\xD7 2) + 0], which is 2.\\nStep 3: Continue the same step in sequence for all the digits. The sum that is achieved in the last step is the actual decimal value. Therefore, the result of converting the binary number \\n(101101)\\n to a decimal using the doubling method is 45\\n \\n![image](https://assets.leetcode.com/users/images/72004f5a-070f-47da-8e9d-88dc1e0e1682_1629452211.0559297.png)\\n\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num = 0;\\n        while (head != null) {\\n            num = num * 2 + head.val;\\n            head = head.next;    \\n        }\\n        return num;\\n    }\\n}\\n```\\n.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num = 0;\\n        while (head != null) {\\n            num = num * 2 + head.val;\\n            head = head.next;    \\n        }\\n        return num;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717487,
                "title": "0ms-simple-java-solution",
                "content": "\\'\\'\\'\\npublic int getDecimalValue(ListNode head) {\\n        int sum = 0;\\n        while(head!=null){\\n            sum = (2*sum)+head.val;\\n            head = head.next;\\n        }\\n        return sum;\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\'\\'\\'\\npublic int getDecimalValue(ListNode head) {\\n        int sum = 0;\\n        while(head!=null){\\n            sum = (2*sum)+head.val;\\n            head = head.next;\\n        }\\n        return sum;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 452759,
                "title": "javascript-solution",
                "content": "```\\nlet getDecimalValue = function(head) {\\n    let result = 0\\n    while (head) {\\n        result = result * 2 + head.val\\n        head = head.next\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet getDecimalValue = function(head) {\\n    let result = 0\\n    while (head) {\\n        result = result * 2 + head.val\\n        head = head.next\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1506192,
                "title": "c-0-ms-faster-than-100",
                "content": "**C++ :**\\n\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string n;\\n        while(head)\\n        {\\n            n += to_string(head->val);\\n            head = head -> next;\\n        }\\n        return stoi(n, 0, 2);;\\n        \\n    }\\n};\\n```\\n\\n**Like it? please upvote**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string n;\\n        while(head)\\n        {\\n            n += to_string(head->val);\\n            head = head -> next;\\n        }\\n        return stoi(n, 0, 2);;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004470,
                "title": "c-cpp-simple-easy-understanding-solution-0ms-100-faster",
                "content": "Here we simple need to traverse the list from begining and add the number to answer . Each time we are moving 1 step ahead in the list , we need to multiply answer with 2 and then add value of current node.\\n\\nThis is because , each time you move one step ahead in the list , the number of digits increase by 1 , so place value of each digit needs to be multiplied by 2.\\n\\n```\\n int getDecimalValue(ListNode* head) {\\n        int ans=0;\\n        while(head)\\n        {\\n            ans=ans*2 + (head->val);\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int getDecimalValue(ListNode* head) {\\n        int ans=0;\\n        while(head)\\n        {\\n            ans=ans*2 + (head->val);\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1138633,
                "title": "0-ms-c-with-explanation",
                "content": "We have been given a Linked List with nodes whose values represent digits of a binary number, we have to return the decimal equivalent of the same.\\n\\nUsually when we have been asked to convert binary to decimal, we go from right to left and multiply the bits with increasing multiples of `2` starting with `0`. \\nSo for `1011` we would do something like \\n`1 * (2^3) + 0 * (2^2) + 1 * (2^1) + 1 * (2^0) ` which is equal to `8 + 0 + 2 + 1 = 11`\\n\\nBut here in this problem we are traversing from left to right. So the naive solution would be to first traverse the Linked List calculate its lenght and then once again traverse so that we could know powers of `2` beforehand which we have to used to multiply.\\n\\nLooking at the constraints, since the number of nodes would be less than or equal to `30` so even two passes would not be a problem but we can do better.\\n\\nThe second approach would be to start traversing the list like we usually do and take a variable result and intialize it as `0` and then as we traverse the list we multiply the result variable by `2` and then add the next bit (value of node).\\n\\nLet\\'s see that in action, taking the above example.\\n`1 -> 0 ->1 -> 1`\\n`(2 * (2 * ((2 * (2 * 0 + 1 )) + 0) + 1)) + 1`\\n\\nWhich would also give the result as `11`.\\n\\nWe can use bit manipulation to multiply the result by `2` by leftshifting the result by `1`\\n`res << 1`\\n\\nGiven below is the complete code for the same:\\n\\n```\\nint getDecimalValue(ListNode* head) {\\n        int res = 0;\\n        while(head!=NULL) {\\n            res = (res<<1) + head->val;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint getDecimalValue(ListNode* head) {\\n        int res = 0;\\n        while(head!=NULL) {\\n            res = (res<<1) + head->val;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841617,
                "title": "0-ms-faster-than-100-00-with-explaination",
                "content": "```\\nclass Solution {\\n\\n    public int getDecimalValue(ListNode head) {\\n        int ans=0;\\n        while(head!=null){\\n            ans=2*ans+head.val;\\n            head=head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/520851c2-98ad-44dd-9d02-b05ecb0073b5_1599837276.5636714.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int getDecimalValue(ListNode head) {\\n        int ans=0;\\n        while(head!=null){\\n            ans=2*ans+head.val;\\n            head=head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526969,
                "title": "1290-javascript-1-line-recursive-solution",
                "content": "> Runtime: **48 ms**, faster than *95.43%* of JavaScript online submissions\\n> Memory Usage: **33.7 MB**, less than *100.00%* of JavaScript online submissions\\n\\n```javascript\\nconst getDecimalValue = (head, dec = 0) =>\\n  !head ? dec : getDecimalValue(head.next, dec * 2 + head.val);\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```javascript\\nconst getDecimalValue = (head, dec = 0) =>\\n  !head ? dec : getDecimalValue(head.next, dec * 2 + head.val);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491005,
                "title": "java-one-method-recursion-solution-100-than-both-no-helper-method-needed",
                "content": "This method stores the calculated ans always in the next node then recursively call itself until the last node which returns the val.\\n```\\npublic int getDecimalValue(ListNode head) {\\n        if(head.next != null){\\n            head.next.val += (head.val << 1);\\n            return getDecimalValue(head.next);\\n        }\\n        else{\\n            return head.val;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "This method stores the calculated ans always in the next node then recursively call itself until the last node which returns the val.\\n```\\npublic int getDecimalValue(ListNode head) {\\n        if(head.next != null){\\n            head.next.val += (head.val << 1);\\n            return getDecimalValue(head.next);\\n        }\\n        else{\\n            return head.val;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 465119,
                "title": "can-it-get-more-simpler",
                "content": "\\n\\tdef getDecimalValue(self, head: ListNode) -> int:\\n        if not head: return head\\n        number = 0\\n        while(head):\\n            number = number*2 + head.val\\n            head = head.next\\n        return number",
                "solutionTags": [],
                "code": "\\n\\tdef getDecimalValue(self, head: ListNode) -> int:\\n        if not head: return head\\n        number = 0\\n        while(head):\\n            number = number*2 + head.val\\n            head = head.next\\n        return number",
                "codeTag": "Python3"
            },
            {
                "id": 3122105,
                "title": "java-100-4-line-code-explanation",
                "content": "# Approach\\nFirst we have to find out the length of this linkedlist, then conducting a loop till the head pointer come acroos the null value, in the meantime we will convert each node into decimal from using this equation\\n\\n\\n![equation.PNG](https://assets.leetcode.com/users/images/a200eb37-78b6-45aa-9aeb-fb2bb27bbf7d_1675158031.1117506.png)\\n\\n\\n\\n# Code\\n![new100 result.PNG](https://assets.leetcode.com/users/images/987aa2fc-655c-4c4a-8e02-2066ecbcf929_1675158056.9375956.png)\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int size = -1;\\n        int sum = 0;\\n        for(ListNode temp = head; temp != null; temp = temp.next){\\n            size++;\\n        }\\n        ListNode node = head;\\n        while(node != null){\\n            sum += node.val * (Math.pow(2,size--));\\n            node = node.next;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Counting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int size = -1;\\n        int sum = 0;\\n        for(ListNode temp = head; temp != null; temp = temp.next){\\n            size++;\\n        }\\n        ListNode node = head;\\n        while(node != null){\\n            sum += node.val * (Math.pow(2,size--));\\n            node = node.next;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919494,
                "title": "c-3-line-code-snippet-step-by-step-optimization-and-ask-for-help",
                "content": "```\\nStep 1:\\nclass Solution { // Idea: one-pass traverse\\npublic: //Time/Space: O(N); O(1)\\n    int getDecimalValue(ListNode* head) {\\n        int ans = head->val;\\n        while((head=head->next))  ans = ans*2 + head->val;        \\n        return ans;\\n    }\\n};\\n\\n\\nStep 2: speed up with bit manipulation\\nclass Solution { // Idea: one-pass traverse with bit manipulation\\npublic: //Time/Space: O(N); O(1)\\n    int getDecimalValue(ListNode* head) {\\n        int ans = head->val;\\n        while((head=head->next))  ans = ans<<1 | head->val;        \\n        return ans;\\n    }\\n};\\n```\\nAsk for help:\\nNote:  \\nI INTERNTIONALLY use \"head=head->next\" to do 2 things: moving one step ahead and providing bool value to control flow, where 2nd goal is HIGHLIGHTED with redundent but BENIGN () to indicate \\'=\\' is not a typo of \\'==\\'.\\nIf you have more canonical idea to help meet this goal, please let me know. Many thanks.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nStep 1:\\nclass Solution { // Idea: one-pass traverse\\npublic: //Time/Space: O(N); O(1)\\n    int getDecimalValue(ListNode* head) {\\n        int ans = head->val;\\n        while((head=head->next))  ans = ans*2 + head->val;        \\n        return ans;\\n    }\\n};\\n\\n\\nStep 2: speed up with bit manipulation\\nclass Solution { // Idea: one-pass traverse with bit manipulation\\npublic: //Time/Space: O(N); O(1)\\n    int getDecimalValue(ListNode* head) {\\n        int ans = head->val;\\n        while((head=head->next))  ans = ans<<1 | head->val;        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493878,
                "title": "python-easy-solution",
                "content": "```   \\ndef getDecimalValue(self, head: ListNode) -> int:\\n        ans = 0\\n        while head:\\n            ans = ans*2 + head.val\\n            head = head.next\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```   \\ndef getDecimalValue(self, head: ListNode) -> int:\\n        ans = 0\\n        while head:\\n            ans = ans*2 + head.val\\n            head = head.next\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 452112,
                "title": "c-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int num = 0;\\n        while(head) {\\n            num = (num << 1) + head->val;\\n            head = head->next;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int num = 0;\\n        while(head) {\\n            num = (num << 1) + head->val;\\n            head = head->next;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073974,
                "title": "beats-100-most-efficient-solution-c",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int>v;\\n        while(head != NULL){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        reverse(v.begin(),v.end());\\n\\n        int num =0;\\n        for(int i=0;i<v.size();i++){\\n            num += ( v[i] * (1<<i) );\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int>v;\\n        while(head != NULL){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        reverse(v.begin(),v.end());\\n\\n        int num =0;\\n        for(int i=0;i<v.size();i++){\\n            num += ( v[i] * (1<<i) );\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027623,
                "title": "easy-c-soln",
                "content": "R\\n# Code\\n```\\n/**\\n * Definition for singly-linked list->\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int num = head->val;\\n        while (head->next != NULL) {\\n            num = (num << 1) | head->next->val;\\n            head = head->next;    \\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list->\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int num = head->val;\\n        while (head->next != NULL) {\\n            num = (num << 1) | head->next->val;\\n            head = head->next;    \\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831895,
                "title": "very-easy-solution-using-recursion-100-fast",
                "content": "```\\nint c=0;int sum=0;\\n    int getDecimalValue(ListNode* head) {\\n        if(head==NULL)\\n            return 0;\\n       \\n        getDecimalValue(head->next);\\n         c++;\\n        if(head->val==1)\\n        {\\n            sum=sum+pow(2,c);\\n        }\\n        return sum/2;\\n        }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint c=0;int sum=0;\\n    int getDecimalValue(ListNode* head) {\\n        if(head==NULL)\\n            return 0;\\n       \\n        getDecimalValue(head->next);\\n         c++;\\n        if(head->val==1)\\n        {\\n            sum=sum+pow(2,c);\\n        }\\n        return sum/2;\\n        }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 536410,
                "title": "javascript-4-solutions-iteration-vs-recursion-math-vs-binary-with-time-space-analysis",
                "content": "Solution #1 - iteration with math operations\\nTime O(n), Space O(1).\\n```javascript\\nvar getDecimalValue = function(head) {\\n    let res = 0\\n    let node = head\\n    while (node) {\\n        res = res * 2 + node.val\\n        node = node.next\\n    }\\n    return res\\n};\\n```\\n\\n\\nSolution #2 - iteration with binary operations\\nTime O(n), Space O(1).\\n```javascript\\nvar getDecimalValue = function(head) {\\n    let res = 0\\n    let node = head\\n    while (node) {\\n        res = res << 1 | node.val\\n        node = node.next\\n    }\\n    return res\\n};\\n```\\n\\n\\nSolution #3 - recursion with math operations\\nTime O(n), Space O(n).\\n```javascript\\nvar getDecimalValue = (head, prev = 0) => !head\\n\\t? prev\\n\\t: getDecimalValue(head.next, prev * 2 + head.val)\\n};\\n```\\n\\n\\nSolution #4 - recursion with binary operations\\nTime O(n), Space O(n).\\n```javascript\\nvar getDecimalValue = (head, prev = 0) => !head\\n    ? prev\\n    : getDecimalValue(head.next, prev << 1 | head.val);\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar getDecimalValue = function(head) {\\n    let res = 0\\n    let node = head\\n    while (node) {\\n        res = res * 2 + node.val\\n        node = node.next\\n    }\\n    return res\\n};\\n```\n```javascript\\nvar getDecimalValue = function(head) {\\n    let res = 0\\n    let node = head\\n    while (node) {\\n        res = res << 1 | node.val\\n        node = node.next\\n    }\\n    return res\\n};\\n```\n```javascript\\nvar getDecimalValue = (head, prev = 0) => !head\\n\\t? prev\\n\\t: getDecimalValue(head.next, prev * 2 + head.val)\\n};\\n```\n```javascript\\nvar getDecimalValue = (head, prev = 0) => !head\\n    ? prev\\n    : getDecimalValue(head.next, prev << 1 | head.val);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 479116,
                "title": "simple-c-solution",
                "content": "```\\nint getDecimalValue(struct ListNode* head){\\n    int result = 0;\\n    while (head) {\\n        result = result << 1;\\n        result += head->val;\\n        head = head->next;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint getDecimalValue(struct ListNode* head){\\n    int result = 0;\\n    while (head) {\\n        result = result << 1;\\n        result += head->val;\\n        head = head->next;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451923,
                "title": "python-clean-code-in-o-n",
                "content": "Keep moving the bit to the left and adding new value.\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def getDecimalValue(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: int\\n        \"\"\"\\n        rst = 0\\n        while head:\\n            rst <<= 1\\n            rst |= head.val\\n            head = head.next\\n        return rst\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def getDecimalValue(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: int\\n        \"\"\"\\n        rst = 0\\n        while head:\\n            rst <<= 1\\n            rst |= head.val\\n            head = head.next\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616498,
                "title": "python-easy-clear-solution",
                "content": "```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        res = 0\\n        while head:\\n            res = 2*res + head.val\\n            head = head.next\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        res = 0\\n        while head:\\n            res = 2*res + head.val\\n            head = head.next\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 991406,
                "title": "east-clear-solution-0ms-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=0;\\n        while(head!=nullptr){\\n            res=res*2+head->val;\\n            head=head->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=0;\\n        while(head!=nullptr){\\n            res=res*2+head->val;\\n            head=head->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501821,
                "title": "c-c-and-javascript-easy-and-fast-solutions",
                "content": "\\n\\n# Approach:WE have to follow the node and calculate the number.Everytime when we get the next node\\'s value we have to multiplicate the previous sum.\\n<!-- Describe your approach to solving the problem. -->\\n![photo_2023-05-08_22-40-30.jpg](https://assets.leetcode.com/users/images/01308448-89dd-4391-bdc7-827e04af8a4a_1683567783.2580664.jpeg)\\n\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int total=0;\\n        while(head!=NULL){\\n            total=total*2+head->val;\\n            head=head->next;\\n        }\\n        return total;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public int GetDecimalValue(ListNode head) {\\n        int total=0;\\n       while(head is not null){\\n           total=total*2+head.val;\\n           head=head.next;\\n       }\\n        return total;\\n    }\\n}\\n```\\n```javascript []\\n\\nvar getDecimalValue = function(head) {\\n    let total=0;\\n    while(head!=null){\\n        total=total*2+head.val;\\n        head=head.next;\\n    }\\n    return total;\\n};\\n```\\n![Vote.png](https://assets.leetcode.com/users/images/b4db8a3d-bf85-45bb-9b37-568066625a97_1683567735.2331667.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int total=0;\\n        while(head!=NULL){\\n            total=total*2+head->val;\\n            head=head->next;\\n        }\\n        return total;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int GetDecimalValue(ListNode head) {\\n        int total=0;\\n       while(head is not null){\\n           total=total*2+head.val;\\n           head=head.next;\\n       }\\n        return total;\\n    }\\n}\\n```\n```javascript []\\n\\nvar getDecimalValue = function(head) {\\n    let total=0;\\n    while(head!=null){\\n        total=total*2+head.val;\\n        head=head.next;\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616333,
                "title": "c-2-methods-brute-force-bit-manipulation-0ms-easy-to-understand",
                "content": "**Method-1: (Efficient Approach using bit manipulation)**\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int sum = 0;\\n        while(head != NULL){\\n            sum *= 2;\\n            sum += head->val;\\n            head = head->next;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n**Method-2: (Brute Force Approach)**\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int> num;\\n\\t\\t// Store number in a vector by traversing linked list\\n        for(ListNode* temp = head; temp != NULL; temp = temp->next)\\n            num.push_back(temp->val);\\n        \\n        int ans = 0, base = 1;\\n        for(int i = num.size()-1; i>= 0; i--){\\n            if(num[i] == 1)\\n                ans += base;\\n            base *= 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int sum = 0;\\n        while(head != NULL){\\n            sum *= 2;\\n            sum += head->val;\\n            head = head->next;\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int> num;\\n\\t\\t// Store number in a vector by traversing linked list\\n        for(ListNode* temp = head; temp != NULL; temp = temp->next)\\n            num.push_back(temp->val);\\n        \\n        int ans = 0, base = 1;\\n        for(int i = num.size()-1; i>= 0; i--){\\n            if(num[i] == 1)\\n                ans += base;\\n            base *= 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616270,
                "title": "c-c-python-simple-iterative-recursive-solutions",
                "content": "In each iteration, we add the current value - 0 or 1, which means setting the rightmost bit if the value is 1.\\nThen we shift the entire `res` left by one, and recursively or with a while loop do the same for the next node.\\n\\n**Solution I - Iterative:**\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n\\n**C / C++:**\\n```\\nint getDecimalValue(ListNode* head) {\\n\\tint res = 0;\\n\\twhile (head) {\\n\\t\\tres = res<<1;\\n\\t\\tres += head->val;\\n\\t\\thead = head->next;\\n\\t}\\n\\treturn res;\\n}\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        res = 0\\n        while head:\\n            res = res<<1\\n            res += head.val\\n            head = head.next\\n        \\n        return res;\\n```\\n****\\n**Solution II - Recursive:**\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n) for the recursive stack.\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        if (!head)\\n            return res;\\n        res = res<<1;\\n        res += head->val;\\n        return getDecimalValue(head->next);\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```\\n**C:**\\n```\\nint rec(struct ListNode* head, int res) {\\n    if (!head)\\n        return res;\\n    res = res<<1;\\n    res += head->val;\\n    return rec(head->next, res);\\n}\\n\\nint getDecimalValue(struct ListNode* head){\\n    return rec(head, 0);\\n}\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        def rec(head, res):\\n            if not head:\\n                return res\\n            res = res<<1\\n            res+=head.val\\n            return rec(head.next, res)\\n        \\n        return rec(head, 0)\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nint getDecimalValue(ListNode* head) {\\n\\tint res = 0;\\n\\twhile (head) {\\n\\t\\tres = res<<1;\\n\\t\\tres += head->val;\\n\\t\\thead = head->next;\\n\\t}\\n\\treturn res;\\n}\\n```\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        res = 0\\n        while head:\\n            res = res<<1\\n            res += head.val\\n            head = head.next\\n        \\n        return res;\\n```\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        if (!head)\\n            return res;\\n        res = res<<1;\\n        res += head->val;\\n        return getDecimalValue(head->next);\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```\n```\\nint rec(struct ListNode* head, int res) {\\n    if (!head)\\n        return res;\\n    res = res<<1;\\n    res += head->val;\\n    return rec(head->next, res);\\n}\\n\\nint getDecimalValue(struct ListNode* head){\\n    return rec(head, 0);\\n}\\n```\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        def rec(head, res):\\n            if not head:\\n                return res\\n            res = res<<1\\n            res+=head.val\\n            return rec(head.next, res)\\n        \\n        return rec(head, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615736,
                "title": "simple-5-line-solution-python-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        res = 0\\n        while head:\\n            res = res * 2 + head.val\\n            head = head.next\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        res = 0\\n        while head:\\n            res = res * 2 + head.val\\n            head = head.next\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1255696,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        \\n        int num = 0;\\n        while(head){\\n            num = (num << 1)+ head->val;\\n            head = head->next;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        \\n        int num = 0;\\n        while(head){\\n            num = (num << 1)+ head->val;\\n            head = head->next;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218409,
                "title": "c-iterative-and-recursive-solution",
                "content": "##### Iterative Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint getDecimalValue(ListNode* head) {\\n\\t\\t\\tint result = 0;\\n\\t\\t\\twhile(head != NULL){\\n\\t\\t\\t\\tresult = (result << 1) + head -> val;\\n\\t\\t\\t\\thead = head ->next;\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};\\n##### Recursive Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint result = 0;\\n\\t\\tint getDecimalValue(ListNode* head) {\\n\\t\\t\\tif(head == NULL){\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\tresult = (result << 1) + head -> val;\\n\\t\\t\\treturn getDecimalValue(head -> next);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint getDecimalValue(ListNode* head) {\\n\\t\\t\\tint result = 0;\\n\\t\\t\\twhile(head != NULL){\\n\\t\\t\\t\\tresult = (result << 1) + head -> val;\\n\\t\\t\\t\\thead = head ->next;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 919049,
                "title": "rust-0-ms-2-mb",
                "content": "```rust\\npub fn get_decimal_value(head: Option<Box<ListNode>>) -> i32 {\\n\\tlet mut num = 0;\\n\\n\\tlet mut curr = &head;\\n\\twhile let Some(node) = curr {\\n\\t\\tnum <<= 1;\\n\\t\\tnum |= node.val;\\n\\t\\tcurr = &node.next;\\n\\t}\\n\\n\\tnum\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn get_decimal_value(head: Option<Box<ListNode>>) -> i32 {\\n\\tlet mut num = 0;\\n\\n\\tlet mut curr = &head;\\n\\twhile let Some(node) = curr {\\n\\t\\tnum <<= 1;\\n\\t\\tnum |= node.val;\\n\\t\\tcurr = &node.next;\\n\\t}\\n\\n\\tnum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840431,
                "title": "python-3-24-ms-13-9-mb-solution",
                "content": "# Python 3 Solution\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        result = 0\\n        while head:\\n            result = result * 2 + head.val\\n            head = head.next\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        result = 0\\n        while head:\\n            result = result * 2 + head.val\\n            head = head.next\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503418,
                "title": "go",
                "content": "```\\nfunc getDecimalValue(head *ListNode) int {\\n    return func(ret int) int {\\n      for ; head != nil; head = head.Next {\\n         ret = ret * 2 + head.Val\\n      }\\n      return ret\\n    }(0)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc getDecimalValue(head *ListNode) int {\\n    return func(ret int) int {\\n      for ; head != nil; head = head.Next {\\n         ret = ret * 2 + head.Val\\n      }\\n      return ret\\n    }(0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055052,
                "title": "c-100-faster-easy-approach-without-reverse",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findLength(ListNode* &head){\\n        ListNode* temp = head;\\n        int length = 0;\\n        while(temp != NULL){\\n            length++;\\n            temp = temp -> next;\\n        }\\n        return length;\\n    }\\n\\n    \\n    int getDecimalValue(ListNode* head) {\\n        ListNode* temp = head;\\n        int remLength = findLength(head) - 1;\\n        int ans = 0;\\n        while(temp != NULL){\\n            int val = pow( 2, remLength ) * temp -> val;\\n            ans += val;\\n            temp = temp -> next;\\n            remLength--;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please upvote, if you find this solution helpful \\uD83D\\uDE4F \\n#### Thank you in advance :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findLength(ListNode* &head){\\n        ListNode* temp = head;\\n        int length = 0;\\n        while(temp != NULL){\\n            length++;\\n            temp = temp -> next;\\n        }\\n        return length;\\n    }\\n\\n    \\n    int getDecimalValue(ListNode* head) {\\n        ListNode* temp = head;\\n        int remLength = findLength(head) - 1;\\n        int ans = 0;\\n        while(temp != NULL){\\n            int val = pow( 2, remLength ) * temp -> val;\\n            ans += val;\\n            temp = temp -> next;\\n            remLength--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758998,
                "title": "java-runtime-0ms-faster-than-100-memory-usage-less-than-90-7",
                "content": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int result = head.val;\\n\\n        while (head.next != null) {\\n            result = result * 2 + head.next.val;\\n            head = head.next;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c34225b3-afe0-42b3-a531-4460de51e37d_1667114982.152361.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int result = head.val;\\n\\n        while (head.next != null) {\\n            result = result * 2 + head.next.val;\\n            head = head.next;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293731,
                "title": "c-easy-solution-3-lines-of-code-with-explanation",
                "content": "\\n**Approach:**\\n![image](https://assets.leetcode.com/users/images/1feed5ba-d86f-4b66-8821-0d18554b7769_1658039053.084712.png)\\n\\n\\n\\'\\'\\'\\n**Solution:**\\n\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=0;\\n        while(head!=NULL){\\n            res=res*2+head->val;\\n            head=head->next;\\n        }\\n        return res;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Please upvote if you find it helpful!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=0;\\n        while(head!=NULL){\\n            res=res*2+head->val;\\n            head=head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1617229,
                "title": "weird-approach-100-faster-c",
                "content": "```\\nListNode* reverse(ListNode *head) {\\n        ListNode* prev = NULL, *cur = head, *next = NULL;\\n        while(cur) {\\n            next = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        return prev;\\n    }\\n    int getDecimalValue(ListNode* head) {\\n        int num = 0, i = 0;\\n        ListNode *ptr;\\n        ptr = reverse(head);\\n        while(ptr) {\\n            num += pow(2, i++) * ptr->val;\\n            ptr = ptr->next;\\n        }\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* reverse(ListNode *head) {\\n        ListNode* prev = NULL, *cur = head, *next = NULL;\\n        while(cur) {\\n            next = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        return prev;\\n    }\\n    int getDecimalValue(ListNode* head) {\\n        int num = 0, i = 0;\\n        ListNode *ptr;\\n        ptr = reverse(head);\\n        while(ptr) {\\n            num += pow(2, i++) * ptr->val;\\n            ptr = ptr->next;\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369615,
                "title": "c-solution-100-faster",
                "content": "\\n    int getDecimalValue(ListNode* head) {\\n        int i = 0;\\n        while(head != NULL){\\n            i = i*2 + head->val;\\n            head = head->next;\\n        }\\n        return i;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    int getDecimalValue(ListNode* head) {\\n        int i = 0;\\n        while(head != NULL){\\n            i = i*2 + head->val;\\n            head = head->next;\\n        }\\n        return i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1265263,
                "title": "c-100-faster-with-another-vect",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int> v;\\n        int ans=0;\\n        ListNode* temp = head;\\n        \\n        while(temp!=NULL)\\n        {\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        int c =1;\\n        for(int i=v.size()-1;i>=0;i--)\\n        {\\n            ans+=c*v[i];\\n            c*=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int> v;\\n        int ans=0;\\n        ListNode* temp = head;\\n        \\n        while(temp!=NULL)\\n        {\\n            v.push_back(temp->val);\\n            temp=temp->next;\\n        }\\n        int c =1;\\n        for(int i=v.size()-1;i>=0;i--)\\n        {\\n            ans+=c*v[i];\\n            c*=2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984269,
                "title": "simple-java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        var n = 0;\\n        \\n        for (var node = head; node != null; node = node.next) {\\n            n = ((n << 1) | val);\\n        }\\n\\n        return n;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        var n = 0;\\n        \\n        for (var node = head; node != null; node = node.next) {\\n            n = ((n << 1) | val);\\n        }\\n\\n        return n;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907912,
                "title": "c-iterative-recursive-faster-than-100",
                "content": "**Recursive [Runtime: 4 ms]**\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head,int res=0) {\\n       return head ? getDecimalValue(head->next,(res<<1)|head->val) : res;\\n    }\\n};\\n```\\n**Iterative [Runtime: 0 ms, faster than 100.00%]**\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=head->val;\\n        while(head->next!=nullptr){\\n            res=(res<<1)|head->next->val;\\n            head=head->next;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Iterative [Runtime: 0 ms, faster than 100.00%]**\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=0;\\n        while(head!=NULL){\\n            res=res*2+head->val;\\n            head=head->next;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section**.\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head,int res=0) {\\n       return head ? getDecimalValue(head->next,(res<<1)|head->val) : res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=head->val;\\n        while(head->next!=nullptr){\\n            res=(res<<1)|head->next->val;\\n            head=head->next;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=0;\\n        while(head!=NULL){\\n            res=res*2+head->val;\\n            head=head->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689250,
                "title": "java-simple-while",
                "content": "```\\n    public int getDecimalValue(ListNode head) {\\n        int res = 0;\\n        while (head != null) {\\n            res *= 2;\\n            res += head.val;\\n            head = head.next;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getDecimalValue(ListNode head) {\\n        int res = 0;\\n        while (head != null) {\\n            res *= 2;\\n            res += head.val;\\n            head = head.next;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 625906,
                "title": "javascript-solution-faster-than-92-84-less-than-100-00",
                "content": "102 / 102 test cases passed.\\nStatus: Accepted\\nRuntime: 48 ms\\nMemory Usage: 33.9 MB\\n```\\nvar getDecimalValue = function(head) {\\n    var binaryNum = \\'\\';\\n    var node = head;\\n    \\n    while(node) {\\n       binaryNum += node.val;\\n       node = node.next;\\n    }\\n    \\n    return parseInt(binaryNum, 2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getDecimalValue = function(head) {\\n    var binaryNum = \\'\\';\\n    var node = head;\\n    \\n    while(node) {\\n       binaryNum += node.val;\\n       node = node.next;\\n    }\\n    \\n    return parseInt(binaryNum, 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 542501,
                "title": "all-3-possible-solutions-easy-to-understand-faster",
                "content": "```\\n def const_space(self, head):\\n        out = 0\\n        while head:\\n            out = out << 1\\n            out = out | head.val\\n            head = head.next\\n        return out\\n    \\n    \\n    def iterative(self, head):\\n        stack = []\\n        while head:\\n            stack.append(head.val)\\n            head = head.next\\n        i = 0\\n        s = 0\\n        while len(stack):\\n            s += stack.pop()*2**i\\n            i += 1\\n        return s\\n    \\n    \\n    def recursive(self, head):\\n        out = 0\\n        def rec(head):\\n            if head:\\n                power, val = rec(head.next)\\n                val += head.val*2**power\\n                return power + 1, val\\n            return 0, 0\\n        \\n        power, out = rec(head)\\n        return out\\n```\\n\\n**I hope that you\\'ve found them useful.**\\n*In that case, Please upvote. It only motivates me to write more such posts\\uD83D\\uDE03*",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n def const_space(self, head):\\n        out = 0\\n        while head:\\n            out = out << 1\\n            out = out | head.val\\n            head = head.next\\n        return out\\n    \\n    \\n    def iterative(self, head):\\n        stack = []\\n        while head:\\n            stack.append(head.val)\\n            head = head.next\\n        i = 0\\n        s = 0\\n        while len(stack):\\n            s += stack.pop()*2**i\\n            i += 1\\n        return s\\n    \\n    \\n    def recursive(self, head):\\n        out = 0\\n        def rec(head):\\n            if head:\\n                power, val = rec(head.next)\\n                val += head.val*2**power\\n                return power + 1, val\\n            return 0, 0\\n        \\n        power, out = rec(head)\\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 469717,
                "title": "doubling-method-with-explanation-javascript",
                "content": "Explanation: This is called the Doubling Method.\\n\\nThe first thing we need to do is write down the binary number that is given to us.\\nInput: 1 0 1\\nExpected Output: 5\\n\\nStarting from left to right, we will double the previous total and add the current value.\\nThe previous total is set to 0 because we have not started yet. We will double the previous total, 0, and add the current value, 1.\\nCurrent Total: 0\\nCurrent Value: 1\\n(0 x 2) + 1 = 1\\nTotal: 1\\n\\nNext, double the current total and add the next leftmost digit. Our current total is now 1 and the new current value is 0. Double 1 and add 0.\\nCurrent Total: 1\\nCurrent Value: 0\\n(1 x 2) + 0 = 2\\nTotal: 2\\n\\nRepeat the previous steps until we run out of digits.\\nDouble the current total, 2, and add the new current value, 1. We have run out of digits and our current total is 5.  \\nCurrent Total: 2\\nCurrent Value: 1\\n(2 x 2) + 1 = 5\\nTotal: 5\\n\\nInput: Binary 101\\nExpected Output: Decimal 5\\n\\n```\\nvar getDecimalValue = function(head, total = 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t//^Set a default parameter named total with the value of 0\\n  //While there is a head node...\\n  while (head) {\\n      //double the value of total and sum it up with the value of the head node.\\n      total = total * 2 + head.val;\\n      //Set the head node pointer to look at the next node.\\n      head = head.next;\\n  }\\n  //return the total after looking through all the digits.\\n  return total;\\n};\\n\\ngetDecimalValue([1, 0, 1]); //Expected Output: 5\\n```\\n\\nLinkedIn: linkedin.com/in/find-kevin/\\nGitHub: github.com/findkevin",
                "solutionTags": [],
                "code": "```\\nvar getDecimalValue = function(head, total = 0) {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t//^Set a default parameter named total with the value of 0\\n  //While there is a head node...\\n  while (head) {\\n      //double the value of total and sum it up with the value of the head node.\\n      total = total * 2 + head.val;\\n      //Set the head node pointer to look at the next node.\\n      head = head.next;\\n  }\\n  //return the total after looking through all the digits.\\n  return total;\\n};\\n\\ngetDecimalValue([1, 0, 1]); //Expected Output: 5\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451785,
                "title": "two-java-solutions",
                "content": "First :\\n\\n```\\n    public int getDecimalValue(ListNode head) {\\n        int res = 0;\\n        while (head != null) {\\n            res = res * 2 + head.val;\\n            head = head.next;\\n        }\\n        return res;\\n    }\\n```\\n\\nSecond :\\n\\n```\\n    public int getDecimalValue2(ListNode head) {\\n        StringBuilder sb = new StringBuilder();\\n        while (head != null) {\\n            sb.append(head.val);\\n            head = head.next;\\n        }\\n        return Integer.parseInt(sb.toString(), 2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getDecimalValue(ListNode head) {\\n        int res = 0;\\n        while (head != null) {\\n            res = res * 2 + head.val;\\n            head = head.next;\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int getDecimalValue2(ListNode head) {\\n        StringBuilder sb = new StringBuilder();\\n        while (head != null) {\\n            sb.append(head.val);\\n            head = head.next;\\n        }\\n        return Integer.parseInt(sb.toString(), 2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612813,
                "title": "simple-java-solution-for-beginners-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        StringBuilder sb = new StringBuilder();\\n        ListNode temp = head;\\n        while(temp != null) {\\n            sb.append(temp.val);\\n            temp = temp.next;\\n        }\\n        return Integer.parseInt(sb.toString(),2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Math",
                    "String"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        StringBuilder sb = new StringBuilder();\\n        ListNode temp = head;\\n        while(temp != null) {\\n            sb.append(temp.val);\\n            temp = temp.next;\\n        }\\n        return Integer.parseInt(sb.toString(),2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137924,
                "title": "java-2-solutions",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n### Approach 1:\\n\\nLogic: $$2^n + ... + 2^2 + 2^1 + 2^0$$\\n``` java []\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int n = 0;\\n        for (ListNode h = head; h != null; h = h.next) {\\n            n++;\\n        }\\n\\n        int ans = 0;\\n        for (; head != null; head = head.next) {\\n            n--;\\n            if (head.val == 1) {\\n                ans += Math.pow(2, n);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(2n), SC: O(1)\\n```\\n---\\n### Approach 2:\\n``` java []\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans = 0;\\n        while (head != null) {\\n            ans = ans * 2 + head.val;\\n            head = head.next;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Math"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int n = 0;\\n        for (ListNode h = head; h != null; h = h.next) {\\n            n++;\\n        }\\n\\n        int ans = 0;\\n        for (; head != null; head = head.next) {\\n            n--;\\n            if (head.val == 1) {\\n                ans += Math.pow(2, n);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(2n), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans = 0;\\n        while (head != null) {\\n            ans = ans * 2 + head.val;\\n            head = head.next;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998900,
                "title": "simple-solution-with-explanation",
                "content": "We are using a method over there which is called as **Doubling Method** . In this method what we do is double the previous value (initially 0) and add the current value to it.\\nAs the name suggests, the process of doubling or multiplying by 2 is done to convert binary to decimal. Let us use the same example for converting the binary number\\n101101\\nto decimal. Observe the following steps given below to understand the binary to decimal conversion using the doubling method.\\n\\n**Step 1:** Write the binary number and start from the left-most digit. Double the previous number and add the current digit. Since we are starting from the left-most digit and there is no previous digit to the left-most digit, we consider the double of the previous digit as 0. For example in 101101\\nthe left-most digit is \\'1\\'. The double of the previous number is 0. Therefore, we get ((0 \\xD7 2) + 1) which is 1.\\n**Step 2:** Continue the same process for the next digit also. The second digit from the left is 0. Now, double the previous digit and add it with the current digit. Therefore, we get, [(1 \\xD7 2) + 0], which is 2.\\n**Step 3:** Continue the same step in sequence for all the digits. The sum that is achieved in the last step is the actual decimal value. Therefore, the result of converting the binary number\\n(101101)\\nto a decimal using the doubling method is 45\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int bin = 0;\\n        while(head!=null){\\n            bin = bin*2 + head.val;\\n            head=head.next;\\n        }\\n        return bin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int bin = 0;\\n        while(head!=null){\\n            bin = bin*2 + head.val;\\n            head=head.next;\\n        }\\n        return bin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815211,
                "title": "python-faster-than-99-easy",
                "content": "![image](https://assets.leetcode.com/users/images/0aa7b997-d3f5-4f60-8c59-2601455a3a7f_1668462558.7367764.png)\\n\\n```\\nclass Solution(object):\\n    def getDecimalValue(self, head):\\n        s=\"\"\\n        while head:\\n            s+=str(head.val)\\n            head=head.next\\n        return int(s,2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getDecimalValue(self, head):\\n        s=\"\"\\n        while head:\\n            s+=str(head.val)\\n            head=head.next\\n        return int(s,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811581,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\n\\n    public int getDecimalValue(ListNode head) {\\n        int num = head.val;\\n        while (head.next != null) {\\n            num = num * 2 + head.next.val;\\n            head = head.next;\\n        }\\n        return num;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\n    public int getDecimalValue(ListNode head) {\\n        int num = head.val;\\n        while (head.next != null) {\\n            num = num * 2 + head.next.val;\\n            head = head.next;\\n        }\\n        return num;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2714440,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        ans=0\\n        while(head):\\n           # ans=ans*2 +head.val\\n            ans=ans<<1 | head.val\\n            head=head.next\\n        return ans\\n```\\n**Explanation**\\nWe can simply use \"ans=ans*2+head.val\"\\nbut the time taken by shift operator is less than multiplication.\\nshift operation is 10x faster than dividing or multiplying the regular way.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        ans=0\\n        while(head):\\n           # ans=ans*2 +head.val\\n            ans=ans<<1 | head.val\\n            head=head.next\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470276,
                "title": "most-efficient-python-solution-no-extra-strings-or-reversing",
                "content": "**If U like the code and if you are a python lover do upvote thank you**\\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        curr = head \\n        res = 0\\n        while curr:\\n            res = res * 2\\n            res += curr.val \\n            curr = curr.next \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        curr = head \\n        res = 0\\n        while curr:\\n            res = res * 2\\n            res += curr.val \\n            curr = curr.next \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364157,
                "title": "c-100-faster-recursive-solution-0ms",
                "content": "```\\nint helper(ListNode*head,int &count)\\n    { //base case\\n        if(head->next==NULL)\\n        {\\n            return head->val;\\n        }\\n        int k=helper(head->next,count);\\n        //increasing count by 2 evertime\\n        count*=2;\\n        k+=head->val*count;\\n        return k;\\n    }\\n    int getDecimalValue(ListNode* head) {\\n        int count=1;\\n        return helper(head,count); \\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint helper(ListNode*head,int &count)\\n    { //base case\\n        if(head->next==NULL)\\n        {\\n            return head->val;\\n        }\\n        int k=helper(head->next,count);\\n        //increasing count by 2 evertime\\n        count*=2;\\n        k+=head->val*count;\\n        return k;\\n    }\\n    int getDecimalValue(ListNode* head) {\\n        int count=1;\\n        return helper(head,count); \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1616742,
                "title": "0ms-c-solution",
                "content": "# Approach 1\\n```\\nint getDecimalValue(ListNode* head) {\\n\\n        int count=-1;\\n        ListNode* temp=head;\\n        while(temp!=NULL){\\n            count++;\\n            temp=temp->next;\\n            \\n        }\\n        temp=head;\\n        int ans=0;\\n        while(count>=0){\\n            ans+=temp->val*pow(2,count);\\n            count--;\\n            \\n            temp=temp->next;\\n            \\n        }\\n        return ans;\\n}\\n```\\n#   Approach 2\\n```\\nint getDecimalValue(ListNode* head) {\\n      \\n        int sum = 0;\\n        ListNode* temp=head;\\n        while(temp!=NULL){\\n            sum=(sum)*2+temp->val;\\n            temp=temp->next;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint getDecimalValue(ListNode* head) {\\n\\n        int count=-1;\\n        ListNode* temp=head;\\n        while(temp!=NULL){\\n            count++;\\n            temp=temp->next;\\n            \\n        }\\n        temp=head;\\n        int ans=0;\\n        while(count>=0){\\n            ans+=temp->val*pow(2,count);\\n            count--;\\n            \\n            temp=temp->next;\\n            \\n        }\\n        return ans;\\n}\\n```\n```\\nint getDecimalValue(ListNode* head) {\\n      \\n        int sum = 0;\\n        ListNode* temp=head;\\n        while(temp!=NULL){\\n            sum=(sum)*2+temp->val;\\n            temp=temp->next;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1616587,
                "title": "python-87-faster",
                "content": "```\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        val = []\\n        while head:\\n            val.append(head.val)\\n            head = head.next\\n        return int(\\'\\'.join(map(str,val)),2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        val = []\\n        while head:\\n            val.append(head.val)\\n            head = head.next\\n        return int(\\'\\'.join(map(str,val)),2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1616436,
                "title": "two-easy-solutions-o-1-space-o-n-time",
                "content": "The most straightforward solution is to collect all the bits into a single string and then use the built-in Convert.ToInt32 function to convert the binary number represented as string to an int.\\n\\n```\\npublic class Solution\\n{\\n    public int GetDecimalValue(ListNode head)\\n    {\\n        StringBuilder sb = new(30);\\n        \\n        while (head is not null)\\n        {\\n            sb.Append(head.val);\\n            head = head.next;\\n        }\\n        \\n        return Convert.ToInt32(sb.ToString(), 2);\\n    }\\n}\\n```\\n\\nThe above solution has however quite an overhead because of converting ints to/from strings. A more elegant approach is to treat each list element as a power of two. We could count the number of nodes n and then start our calculation with 2^n for the highest bit, halving it on each node until we reach the lowest bit. Or we can inline that calculation of powers by multiplying the intermediate result by two on each list node. Sorry for \"over-shortening\" it:\\n\\n```\\npublic class Solution\\n{\\n    public int GetDecimalValue(ListNode h)\\n    {\\n        int n = 0;\\n        while (h != null) (n, h) = (n + n + h.val, h.next);\\n        return n;\\n    }\\n}\\n```\\n\\nThe multiplication by 2 can also be implemented as a bit shift (n << 1) but this operation is allegedly slower in C# than the multiplication.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int GetDecimalValue(ListNode head)\\n    {\\n        StringBuilder sb = new(30);\\n        \\n        while (head is not null)\\n        {\\n            sb.Append(head.val);\\n            head = head.next;\\n        }\\n        \\n        return Convert.ToInt32(sb.ToString(), 2);\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int GetDecimalValue(ListNode h)\\n    {\\n        int n = 0;\\n        while (h != null) (n, h) = (n + n + h.val, h.next);\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590820,
                "title": "c-two-approaches-easy-solution",
                "content": "**APPROACH 1:**\\nTraverse the Linked List to find it\\'s size and then calculate it\\'s integer value in the second traversal.\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        ListNode *temp = head;\\n        int count=0;\\n        while(temp)\\n        {\\n            count++;\\n            temp=temp->next;\\n        }\\n        temp=head;\\n        int ans=0;\\n        while(temp && count)\\n        {\\n            if(temp->val==1){\\n                ans+= pow(2,count-1);\\n                count--;\\n            }\\n            else if(temp->val==0) count--;\\n            temp=temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nRuntime: 4 ms\\nMemory Usage: 8.4 MB\\n\\n**APPROACH 2:**\\nconsider every node as the last node. if the next node is present, increase the value of previous powers by 1 (that is to multiply the existing answer by 2).\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        ListNode *temp= head;\\n        int ans=0;\\n        while(temp)\\n        {\\n            ans = 2*ans + temp->val;\\n            temp=temp->next;\\n\\t\\t   // DRY  RUN FOR 1->0->1\\n            // 2*0+1 =1\\n            // 1*2+0  =2\\n            // 2*2 + 1 =5\\n        }\\n        return ans;\\n    }\\n};\\n```\\nRuntime: 3 ms\\nMemory Usage: 8.2 MB\\n\\n*FEEL FREE TO ASK ANYTHING IN THE COMMENTS BELOW!!*\\n**PLZ DO UPVOTE IF YOU LIKE MY SOLUTION :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        ListNode *temp = head;\\n        int count=0;\\n        while(temp)\\n        {\\n            count++;\\n            temp=temp->next;\\n        }\\n        temp=head;\\n        int ans=0;\\n        while(temp && count)\\n        {\\n            if(temp->val==1){\\n                ans+= pow(2,count-1);\\n                count--;\\n            }\\n            else if(temp->val==0) count--;\\n            temp=temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        ListNode *temp= head;\\n        int ans=0;\\n        while(temp)\\n        {\\n            ans = 2*ans + temp->val;\\n            temp=temp->next;\\n\\t\\t   // DRY  RUN FOR 1->0->1\\n            // 2*0+1 =1\\n            // 1*2+0  =2\\n            // 2*2 + 1 =5\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516004,
                "title": "simple-c-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans = 0 ; \\n        ListNode *temp = head;\\n        while(temp!=NULL){\\n            ans*=2;\\n            ans = ans+temp->val ;\\n            temp = temp->next;\\n        }\\n        return ans;      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans = 0 ; \\n        ListNode *temp = head;\\n        while(temp!=NULL){\\n            ans*=2;\\n            ans = ans+temp->val ;\\n            temp = temp->next;\\n        }\\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386933,
                "title": "python3-simple-string-concatenation-99",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        \\n        tmp = \\'\\'\\n        curr = head\\n        while curr:\\n            tmp += str(curr.val)\\n            curr = curr.next\\n        return int(tmp,2)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        \\n        tmp = \\'\\'\\n        curr = head\\n        while curr:\\n            tmp += str(curr.val)\\n            curr = curr.next\\n        return int(tmp,2)",
                "codeTag": "Java"
            },
            {
                "id": 1053756,
                "title": "java-0ms-beats-100-space-80-easy-solution",
                "content": "```\\n public int getDecimalValue(ListNode head) {\\n        StringBuilder s=new StringBuilder();\\n        while(head!=null){\\n            s.append(head.val);\\n            head=head.next;\\n        }\\n        return Integer.parseInt(s.toString(),2);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int getDecimalValue(ListNode head) {\\n        StringBuilder s=new StringBuilder();\\n        while(head!=null){\\n            s.append(head.val);\\n            head=head.next;\\n        }\\n        return Integer.parseInt(s.toString(),2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748036,
                "title": "python-24-ms",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        b=\"\"\\n        while head!=None:\\n            b+=str(head.val)\\n            head=head.next\\n        return int(b,2)\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        b=\"\"\\n        while head!=None:\\n            b+=str(head.val)\\n            head=head.next\\n        return int(b,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707425,
                "title": "0-ms-simple-go-solution",
                "content": "```\\nfunc getDecimalValue(head *ListNode) (decimal int) {\\n    \\n    for head != nil {\\n        decimal = (decimal*2 ) + head.Val\\n        head = head.Next\\n    }\\n    \\n    return\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getDecimalValue(head *ListNode) (decimal int) {\\n    \\n    for head != nil {\\n        decimal = (decimal*2 ) + head.Val\\n        head = head.Next\\n    }\\n    \\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691292,
                "title": "python-easy-28-ms-using-int-number-base-2",
                "content": "*Feel free to ask a doubt related to the solution. Kindly upvote if the solution helped you. : ) *\\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        binaryNumberString = \"\"\\n        while head:\\n            binaryNumberString += str(head.val)\\n            head = head.next\\n        return int(binaryNumberString,2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        binaryNumberString = \"\"\\n        while head:\\n            binaryNumberString += str(head.val)\\n            head = head.next\\n        return int(binaryNumberString,2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571997,
                "title": "java-simple-recursive-solution-runtime-memory-100",
                "content": "but not recommended\\n```\\n\\nclass Solution {\\n    int i=0;\\n    public int getDecimalValue(ListNode head) {\\n        \\n        if(head==null) return 0;\\n        return getDecimalValue(head.next) + head.val * (int)Math.pow(2,i++);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int i=0;\\n    public int getDecimalValue(ListNode head) {\\n        \\n        if(head==null) return 0;\\n        return getDecimalValue(head.next) + head.val * (int)Math.pow(2,i++);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522114,
                "title": "my-swift-solution",
                "content": "My Swift solution\\n```\\nclass Solution {\\n    func getDecimalValue(_ head: ListNode?) -> Int {\\n        var result: Int = 0\\n        var curNode: ListNode? = head\\n        while curNode != nil {\\n            result = (result << 1) | curNode!.val\\n            curNode = curNode!.next\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getDecimalValue(_ head: ListNode?) -> Int {\\n        var result: Int = 0\\n        var curNode: ListNode? = head\\n        while curNode != nil {\\n            result = (result << 1) | curNode!.val\\n            curNode = curNode!.next\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479574,
                "title": "binary-operations-solution",
                "content": "```\\nfunc getDecimalValue(head *ListNode) int {\\n\\tvar out int\\t\\n\\tfor head != nil {\\n\\t\\tout <<= 1\\n\\t\\tout |= head.Val\\n\\t\\thead = head.Next\\n\\t}\\n\\treturn out\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getDecimalValue(head *ListNode) int {\\n\\tvar out int\\t\\n\\tfor head != nil {\\n\\t\\tout <<= 1\\n\\t\\tout |= head.Val\\n\\t\\thead = head.Next\\n\\t}\\n\\treturn out\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 460618,
                "title": "rust-o-n",
                "content": "Like others, use binary operators: `<<` and `|`.\\n\\n\\n```\\nimpl Solution {\\n    pub fn get_decimal_value(mut head: Option<Box<ListNode>>) -> i32 {\\n        let mut res = 0;\\n        while head.is_some() {\\n            res = (res << 1) | head.to_owned().unwrap().val;\\n            head = head.unwrap().next;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n#### one more thing...\\n\\nI\\'m confused a lot about the `res * 2 ` answer before.\\n\\nIt seems I just figured it out:\\n\\n+ `res * 2` actually means `res << 1`\\n+ and `+ head.val` just means `| head.val`",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn get_decimal_value(mut head: Option<Box<ListNode>>) -> i32 {\\n        let mut res = 0;\\n        while head.is_some() {\\n            res = (res << 1) | head.to_owned().unwrap().val;\\n            head = head.unwrap().next;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454789,
                "title": "rust-0ms-2-4mb",
                "content": "bit\\n0 ms 2.4 MB\\n```\\nimpl Solution {\\n    pub fn get_decimal_value(head: Option<Box<ListNode>>) -> i32 {        \\n        let mut next = head;\\n        let mut val = 0;\\n        while let Some(node) = next {\\n            val = val << 1 | node.val;\\n            next = node.next;\\n        }\\n        val\\n    }\\n}\\n```\\n\\n0ms 2.5MB string to i32\\n```\\npub fn get_decimal_value(head: Option<Box<ListNode>>) -> i32 {\\n        let mut next = head;\\n        let mut bin_arr = Vec::new();\\n        while let Some(node) = next {\\n            bin_arr.push(node.val.to_string());\\n            next = node.next;\\n        }\\n        i32::from_str_radix(&bin_arr.join(\"\"), 2).unwrap()\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn get_decimal_value(head: Option<Box<ListNode>>) -> i32 {        \\n        let mut next = head;\\n        let mut val = 0;\\n        while let Some(node) = next {\\n            val = val << 1 | node.val;\\n            next = node.next;\\n        }\\n        val\\n    }\\n}\\n```\n```\\npub fn get_decimal_value(head: Option<Box<ListNode>>) -> i32 {\\n        let mut next = head;\\n        let mut bin_arr = Vec::new();\\n        while let Some(node) = next {\\n            bin_arr.push(node.val.to_string());\\n            next = node.next;\\n        }\\n        i32::from_str_radix(&bin_arr.join(\"\"), 2).unwrap()\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007462,
                "title": "java-1000-beats-0-n-easy-stringbuilder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        StringBuilder sb = new StringBuilder();\\n        ListNode curr = head;\\n        while(curr!=null){\\n            sb.append(curr.val);\\n            curr = curr.next;\\n        }\\n        return Integer.parseInt(sb.toString(), 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "String"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        StringBuilder sb = new StringBuilder();\\n        ListNode curr = head;\\n        while(curr!=null){\\n            sb.append(curr.val);\\n            curr = curr.next;\\n        }\\n        return Integer.parseInt(sb.toString(), 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846754,
                "title": "c-easiest-and-cleanest-2-line-solution-that-beats-100-of-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans=0;\\n        ListNode* temp=head;\\n        while(temp!=nullptr){\\n            ans*=2;\\n            ans+=(temp->val); // ans+=(temp->val)*1;\\n            temp=temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans=0;\\n        ListNode* temp=head;\\n        while(temp!=nullptr){\\n            ans*=2;\\n            ans+=(temp->val); // ans+=(temp->val)*1;\\n            temp=temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471096,
                "title": "100-better-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n            /*Please upvote if found solution helpful\\uD83D\\uDE04*/\\n\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int>temp;\\n        while(head!=NULL){\\n            temp.push_back(head->val);\\n            head=head->next;\\n        }\\n\\n        int decimal=0;\\n        int i=0;\\n        //binary to decimal conversion\\n        int length=temp.size();\\n        for(int i=0;i<length;i++){\\n            if(temp[length-i-1] == 1)\\n            decimal+=pow(2,i);\\n        }\\n\\n        return decimal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n            /*Please upvote if found solution helpful\\uD83D\\uDE04*/\\n\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int>temp;\\n        while(head!=NULL){\\n            temp.push_back(head->val);\\n            head=head->next;\\n        }\\n\\n        int decimal=0;\\n        int i=0;\\n        //binary to decimal conversion\\n        int length=temp.size();\\n        for(int i=0;i<length;i++){\\n            if(temp[length-i-1] == 1)\\n            decimal+=pow(2,i);\\n        }\\n\\n        return decimal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444975,
                "title": "0ms-5-line-code-100-faster-simple-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n\\n        int len = 0;\\n        int sum = 0;\\n        ListNode curr = head;\\n        while(curr!=null){\\n            len++;\\n            curr = curr.next;\\n        }\\n        len--;\\n        curr=head;\\n        while(curr!=null){\\n            sum += curr.val * Math.pow(2, len--);\\n            curr = curr.next;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n\\n        int len = 0;\\n        int sum = 0;\\n        ListNode curr = head;\\n        while(curr!=null){\\n            len++;\\n            curr = curr.next;\\n        }\\n        len--;\\n        curr=head;\\n        while(curr!=null){\\n            sum += curr.val * Math.pow(2, len--);\\n            curr = curr.next;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407981,
                "title": "typescript-javascript-o-n",
                "content": "Time: O(n)\\nSpace: O(1)\\n# Code\\n```\\nfunction getDecimalValue(head: ListNode | null): number {\\nlet cur = head; \\nlet dec= 0; \\nwhile(cur){\\n    dec +=cur.val;\\n    dec*=2;\\n    cur = cur.next \\n}\\n\\nreturn dec/2;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Linked List"
                ],
                "code": "```\\nfunction getDecimalValue(head: ListNode | null): number {\\nlet cur = head; \\nlet dec= 0; \\nwhile(cur){\\n    dec +=cur.val;\\n    dec*=2;\\n    cur = cur.next \\n}\\n\\nreturn dec/2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2770966,
                "title": "easy-100-faster-0ms",
                "content": "```\\nint getDecimalValue(ListNode* head) \\n    {\\n        int sum = 0;\\n\\t\\twhile (head != nullptr)\\n\\t\\t{\\n\\t\\t\\tsum <<= 1;\\n\\t\\t\\tsum += head->val;\\n\\t\\t\\thead = head->next;\\n\\t\\t}\\n\\t\\treturn sum;        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint getDecimalValue(ListNode* head) \\n    {\\n        int sum = 0;\\n\\t\\twhile (head != nullptr)\\n\\t\\t{\\n\\t\\t\\tsum <<= 1;\\n\\t\\t\\tsum += head->val;\\n\\t\\t\\thead = head->next;\\n\\t\\t}\\n\\t\\treturn sum;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2742649,
                "title": "c-linked-list-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string s=\"\";\\n        while(head!=NULL){\\n            s+=to_string(head->val);\\n            head=head->next;\\n        }\\n\\n        return stoi(s, 0, 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string s=\"\";\\n        while(head!=NULL){\\n            s+=to_string(head->val);\\n            head=head->next;\\n        }\\n\\n        return stoi(s, 0, 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719093,
                "title": "easy-solution-c-more-easy",
                "content": "```\\nListNode* tmp =head;\\n        int ans =0;\\n        while(tmp!=NULL){\\n        \\n        ans = ans*2;\\n            ans =ans+tmp->val;\\n            tmp =tmp->next;\\n            \\n        }\\n        return ans;\\n        \\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* tmp =head;\\n        int ans =0;\\n        while(tmp!=NULL){\\n        \\n        ans = ans*2;\\n            ans =ans+tmp->val;\\n            tmp =tmp->next;\\n            \\n        }\\n        return ans;\\n        \\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711459,
                "title": "java-easy-100-faster",
                "content": "/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans=0,temp=0,sz=0;\\n        ListNode head1=head;\\n        while(head!=null)\\n        {\\n          sz++;\\n            \\n            head=head.next;\\n        }\\n         while(head1!=null)\\n        {\\n             temp=head1.val;\\n             if(temp==1)\\n          ans+=Math.pow(2,sz-1);\\n            \\n            head1=head1.next;\\n             sz--;\\n        }\\n      \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans=0,temp=0,sz=0;\\n        ListNode head1=head;\\n        while(head!=null)\\n        {\\n          sz++;\\n            \\n            head=head.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2630592,
                "title": "java-recursive-solution",
                "content": "**Solution 1**\\n\\n```\\nclass Solution \\n{\\n    int ans = 0 ;\\n    public int getDecimalValue(ListNode head) \\n    {   \\n        if( head == null )\\n        {\\n            return ans ;\\n        }        \\n        ans = ans << 1 | head.val ;\\n        return getDecimalValue(head.next) ;\\n    }\\n}\\n```\\n\\n**Solution 2**\\n\\n```\\nclass Solution \\n{\\n    int size , sum = 0 ;\\n    public int getDecimalValue(ListNode head) \\n    {   \\n        int length = 0 ;        \\n        return helper( head , length ) ;\\n    }\\n    public int helper( ListNode head , int length )\\n    {\\n        if( head == null )\\n        {\\n            size = length ;\\n            return 0 ;\\n        }\\n        int bit = head.val ;\\n        helper( head.next , length + 1 ) ;\\n        sum += bit <<  size - ( length + 1 ) ;          \\n        return sum ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\n    int ans = 0 ;\\n    public int getDecimalValue(ListNode head) \\n    {   \\n        if( head == null )\\n        {\\n            return ans ;\\n        }        \\n        ans = ans << 1 | head.val ;\\n        return getDecimalValue(head.next) ;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    int size , sum = 0 ;\\n    public int getDecimalValue(ListNode head) \\n    {   \\n        int length = 0 ;        \\n        return helper( head , length ) ;\\n    }\\n    public int helper( ListNode head , int length )\\n    {\\n        if( head == null )\\n        {\\n            size = length ;\\n            return 0 ;\\n        }\\n        int bit = head.val ;\\n        helper( head.next , length + 1 ) ;\\n        sum += bit <<  size - ( length + 1 ) ;          \\n        return sum ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574042,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n       \\n        int result = head->val;\\n        while(head -> next){\\n            result = result*2 + head->next->val;\\n            head = head -> next;\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n       \\n        int result = head->val;\\n        while(head -> next){\\n            result = result*2 + head->next->val;\\n            head = head -> next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2517127,
                "title": "simple-cpp-solution",
                "content": "class Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=0;\\n        while(head!=NULL){\\n            res=res*2+head->val;\\n            head=head->next;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n\\n\\n// IF YOU LIKE MY SOLUTION PLZ UPVOTE!!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int res=0;\\n        while(head!=NULL){\\n            res=res*2+head->val;\\n            head=head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2233747,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ret = 0;\\n\\n        while(head!=null){\\n            ret =ret*2 + head.val;\\n            head = head.next;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ret = 0;\\n\\n        while(head!=null){\\n            ret =ret*2 + head.val;\\n            head = head.next;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047207,
                "title": "java-easy-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        \\n        String str = \"\";\\n        \\n        ListNode temp = head;\\n        \\n        while(temp != null)\\n        {\\n            str = str + temp.val;\\n            temp = temp.next;\\n        }\\n        \\n        return Integer.parseInt(str, 2);\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public int getDecimalValue(ListNode head) {\\n        \\n        String str = \"\";\\n        \\n        ListNode temp = head;\\n        \\n        while(temp != null)\\n        {\\n            str = str + temp.val;\\n            temp = temp.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1997330,
                "title": "javascript-using-parseint-to-convert-to-integer",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {number}\\n */\\nvar getDecimalValue = function(head) {\\n    \\n    let binary = \\'\\';\\n    \\n    while(head) {\\n        binary += head.val;\\n        head = head.next;\\n    }\\n    \\n    return parseInt(binary, 2);\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {number}\\n */\\nvar getDecimalValue = function(head) {\\n    \\n    let binary = \\'\\';\\n    \\n    while(head) {\\n        binary += head.val;\\n        head = head.next;\\n    }\\n    \\n    return parseInt(binary, 2);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1616846,
                "title": "very-easy-o-n-approach",
                "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n            //1->0->1->1\\n    int i=getCount(head);\\n    int sum=0;\\n    ListNode* curr=head;\\n    while(curr!=nullptr)\\n    {\\n        //cout<<curr->data<<\" \";\\n        sum+=(curr->val)*pow(2,i-1);\\n        //cout<<sum<<\" \";\\n        curr=curr->next;\\n        i--;\\n    }\\n    return sum;\\n    }\\n    int getCount(ListNode *head)\\n{\\n    int count = 0;\\n    ListNode *current = head;\\n    while (current != NULL)\\n    {\\n        count++;\\n        current = current->next;\\n    }\\n    return count;\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n            //1->0->1->1\\n    int i=getCount(head);\\n    int sum=0;\\n    ListNode* curr=head;\\n    while(curr!=nullptr)\\n    {\\n        //cout<<curr->data<<\" \";\\n        sum+=(curr->val)*pow(2,i-1);\\n        //cout<<sum<<\" \";\\n        curr=curr->next;\\n        i--;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1616504,
                "title": "c-bit-operation",
                "content": "Approach 1: bit operation\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans = head->val;\\n        //while((head=head->next))  ans = (ans<<1) + head->val;  // ok\\n        while((head=head->next))  ans = ans<<1 | head->val;  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans = head->val;\\n        //while((head=head->next))  ans = (ans<<1) + head->val;  // ok\\n        while((head=head->next))  ans = ans<<1 | head->val;  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616493,
                "title": "c-easy-clear-solution-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int sum = 0;\\n        while (head) {\\n            sum = 2*sum + head->val;\\n            head = head->next;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int sum = 0;\\n        while (head) {\\n            sum = 2*sum + head->val;\\n            head = head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1616491,
                "title": "java-easy-clear-solution-0-ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int sum = 0;\\n        while (head != null) {\\n            sum = 2*sum + head.val;\\n            head = head.next;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int sum = 0;\\n        while (head != null) {\\n            sum = 2*sum + head.val;\\n            head = head.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1616208,
                "title": "c-full-solution-with-explanation-dry-run-faster-than-100",
                "content": "EXPLANATION-\\n\\n Ok, for a sec just forget about the linked list,\\n     suppose if i give you a binary number for e.g take 101101\\n     and ask you to find the decimal number of this binary number then, \\n     what will you do?\\n     oviously your answer is bro, **simple math**\\n     and how?\\n     so, suppose number is 101101 than,\\n     then starting from backwards we will go like this \\n\\t \\n\\t(101101)\\u2082\\n\\t(1 \\xD7 2\\u2075) + (0 \\xD7 2\\u2074) + (1 \\xD7 2\\xB3) + (1 \\xD7 2\\xB2) + (0 \\xD7 2\\xB9) + (1 \\xD7 2\\u2070)\\n\\t(1 * 32) + (0 * 16) + (1 * 8)  + (1 * 4)  + (0 * 2)  + (1 * 1) \\n\\t(32) + (0) + (8) + (4) + (0) + (1)\\n\\t(45)\\u2081\\u2080\\n\\t\\n\\tso if a binary number is given in the form of Linked list then we simply starts from backwards\\n\\tof the list as same in the form of number, but, How we will traverse a linked list from backwards,nothin,\\n\\twe reverse the linked list and then starts our usual mathematics calculation and traversal\\n\\t\\n\\tso whole program will run around it, for more explanation i have added comments in the code,\\n\\t\\nNow, time for code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Convert Binary Number in a Linked List to Integer.\\n//Memory Usage: 8.4 MB, less than 16.65% of C++ online submissions for Convert Binary Number in a Linked List to Integer.\\n\\nclass Solution {\\npublic:\\n    // function used to reverse the linked list\\n    ListNode* reverse(ListNode* head)\\n    {\\n        // we use three pointers to reverse the whole linked list,\\n        // it is typical method to reverse the linked list\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* nextptr;\\n        while(curr != NULL)\\n        {\\n            nextptr = curr -> next;\\n            curr -> next = prev;\\n            \\n            prev = curr;\\n            curr = nextptr;\\n            \\n        }\\n        return prev;\\n    }\\n    \\n    int getDecimalValue(ListNode* head) {\\n        head = reverse(head); // by now, we get our reversed linked list\\n        \\n        // it is used to denote the power, like na 2\\u2070, 2\\xB9, 2\\xB2, so the value of power variable is 0,1 and 2 respectively.\\n        int power = 0; \\n        \\n        int val = 0; //final decimal value we got,(basically it is the answer)\\n        ListNode* temp = head; // we make a node temp, and store head in it\\n        \\n        while(temp != NULL) //condition while temp not reached to the last node\\n        {\\n            // it is coefficient, like see, if this is written (1 \\xD7 2\\u2070) then in this case our bin is 1\\n            int bin = temp -> val; \\n            \\n            val = val + (bin * pow(2,power)); // using formula\\n            power = power + 1; // increment power\\n            temp = temp -> next; // and now we move temp ahead\\n        }\\n        return val; // yeah !!, we got our answer\\n    }\\n};\\n\\n// if u like this please give me a upvote\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Convert Binary Number in a Linked List to Integer.\\n//Memory Usage: 8.4 MB, less than 16.65% of C++ online submissions for Convert Binary Number in a Linked List to Integer.\\n\\nclass Solution {\\npublic:\\n    // function used to reverse the linked list\\n    ListNode* reverse(ListNode* head)\\n    {\\n        // we use three pointers to reverse the whole linked list,\\n        // it is typical method to reverse the linked list\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        ListNode* nextptr;\\n        while(curr != NULL)\\n        {\\n            nextptr = curr -> next;\\n            curr -> next = prev;\\n            \\n            prev = curr;\\n            curr = nextptr;\\n            \\n        }\\n        return prev;\\n    }\\n    \\n    int getDecimalValue(ListNode* head) {\\n        head = reverse(head); // by now, we get our reversed linked list\\n        \\n        // it is used to denote the power, like na 2\\u2070, 2\\xB9, 2\\xB2, so the value of power variable is 0,1 and 2 respectively.\\n        int power = 0; \\n        \\n        int val = 0; //final decimal value we got,(basically it is the answer)\\n        ListNode* temp = head; // we make a node temp, and store head in it\\n        \\n        while(temp != NULL) //condition while temp not reached to the last node\\n        {\\n            // it is coefficient, like see, if this is written (1 \\xD7 2\\u2070) then in this case our bin is 1\\n            int bin = temp -> val; \\n            \\n            val = val + (bin * pow(2,power)); // using formula\\n            power = power + 1; // increment power\\n            temp = temp -> next; // and now we move temp ahead\\n        }\\n        return val; // yeah !!, we got our answer\\n    }\\n};\\n\\n// if u like this please give me a upvote\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615734,
                "title": "c-1290-convert-binary-number-in-a-linked-list-to-integer",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans = 0;\\n        for (ListNode *node = head; node; node = node->next) \\n            ans = 2*ans + node->val; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans = 0;\\n        for (ListNode *node = head; node; node = node->next) \\n            ans = 2*ans + node->val; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529723,
                "title": "faster-than-100-of-java-solutions",
                "content": "class Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int i =0; int arr [] = new int[30];\\n        while(head != null){\\n            arr[i++] = head.val;\\n            head = head.next;\\n        }\\n        int z =-1; int sum =0;\\n        for(int j  = i-1 ; j>= 0 ; j--){\\n            z++;\\n            if(arr[j] != 0){\\n                sum += Math.pow(2,z);\\n            }\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int i =0; int arr [] = new int[30];\\n        while(head != null){\\n            arr[i++] = head.val;\\n            head = head.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1434320,
                "title": "java-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head)\\n    {\\n        if(head == null)\\n            return 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(head != null)\\n        {\\n            sb.append(head.val);\\n            head = head.next;\\n        }\\n        return Integer.parseInt(sb.toString(), 2);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head)\\n    {\\n        if(head == null)\\n            return 0;\\n        StringBuilder sb = new StringBuilder();\\n        while(head != null)\\n        {\\n            sb.append(head.val);\\n            head = head.next;\\n        }\\n        return Integer.parseInt(sb.toString(), 2);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389184,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn get_decimal_value(head: Option<Box<ListNode>>) -> i32 {\\n        let mut cur_node = &head;\\n        let mut v = Vec::new();\\n        while let Some(node) = cur_node {\\n            v.push(node.val);\\n            cur_node = &node.next;\\n        }\\n\\n        v.iter()\\n            .rev()\\n            .enumerate()\\n            .fold(0, |acc, (ind, val)| acc + *val * (1 << ind))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_decimal_value(head: Option<Box<ListNode>>) -> i32 {\\n        let mut cur_node = &head;\\n        let mut v = Vec::new();\\n        while let Some(node) = cur_node {\\n            v.push(node.val);\\n            cur_node = &node.next;\\n        }\\n\\n        v.iter()\\n            .rev()\\n            .enumerate()\\n            .fold(0, |acc, (ind, val)| acc + *val * (1 << ind))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1328620,
                "title": "easy-c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int binaryToDecimal(string n){\\n    string num = n;\\n    int dec_value = 0;\\n    int base = 1;\\n    int len = num.length();\\n    \\n    for (int i = len - 1; i >= 0; i--) {\\n        if (num[i] == \\'1\\')\\n            dec_value += base;\\n        base = base * 2;\\n    }\\n    return dec_value;\\n}\\n    int getDecimalValue(ListNode* head) {\\n        string s=\"\";       \\n        while(head!=NULL){\\n            ListNode *temp=head;\\n            s+=to_string(head->val);\\n            head =head->next;\\n        }\\n        return binaryToDecimal(s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int binaryToDecimal(string n){\\n    string num = n;\\n    int dec_value = 0;\\n    int base = 1;\\n    int len = num.length();\\n    \\n    for (int i = len - 1; i >= 0; i--) {\\n        if (num[i] == \\'1\\')\\n            dec_value += base;\\n        base = base * 2;\\n    }\\n    return dec_value;\\n}\\n    int getDecimalValue(ListNode* head) {\\n        string s=\"\";       \\n        while(head!=NULL){\\n            ListNode *temp=head;\\n            s+=to_string(head->val);\\n            head =head->next;\\n        }\\n        return binaryToDecimal(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148656,
                "title": "simple-compact-js-faster-than-93",
                "content": "the approach is simple  \\n 1. get the decimal array from traversal of the string .\\n 2. reverse the array\\n 3. add the digits of the binary multiplied to the power of their index\\n\\n```\\nconst getDecimalArr = head => {\\n    let a = []\\n    while(head) {\\n        a.push(head.val)\\n        head = head.next;\\n    }\\n   return a;\\n}\\nconst getDecimalValue = (head) => getDecimalArr(head).reverse().reduce((a,e,i)=> a = a+( 2**i*(e)), 0)\\n```",
                "solutionTags": [],
                "code": "```\\nconst getDecimalArr = head => {\\n    let a = []\\n    while(head) {\\n        a.push(head.val)\\n        head = head.next;\\n    }\\n   return a;\\n}\\nconst getDecimalValue = (head) => getDecimalArr(head).reverse().reduce((a,e,i)=> a = a+( 2**i*(e)), 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1071025,
                "title": "0ms-in-c-with-bitwise-operations",
                "content": "```\\n    int getDecimalValue(ListNode* head) {\\n        int res = 0;\\n        while(head) {\\n            res = (res<<1) | head->val;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int getDecimalValue(ListNode* head) {\\n        int res = 0;\\n        while(head) {\\n            res = (res<<1) | head->val;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 982537,
                "title": "utility-method-to-convert-array-to-linked-list",
                "content": "public  ListNode convertArrayToList(int[] input){\\n\\t\\t\\tListNode head = null;\\n\\t\\t\\tListNode ln = null;\\n\\t\\t\\t//for(int i=1; i<=input.length; i++) {\\n\\t\\t\\tfor(int value : input) {\\n\\t\\t\\t\\tif(head==null) {\\n\\t\\t\\t\\t\\thead = new ListNode(input[0]);\\n\\t\\t\\t\\t\\tln = head;\\n\\t\\t\\t\\t }else {\\n\\t\\t\\t\\t\\t ln.next = new ListNode(value);\\n\\t\\t\\t\\t\\t ln = ln.next;\\n\\t\\t\\t\\t }\\n\\t\\t\\t}\\n\\t\\t\\treturn head;\\n\\t\\t}",
                "solutionTags": [],
                "code": "public  ListNode convertArrayToList(int[] input){\\n\\t\\t\\tListNode head = null;\\n\\t\\t\\tListNode ln = null;\\n\\t\\t\\t//for(int i=1; i<=input.length; i++) {\\n\\t\\t\\tfor(int value : input) {\\n\\t\\t\\t\\tif(head==null) {\\n\\t\\t\\t\\t\\thead = new ListNode(input[0]);\\n\\t\\t\\t\\t\\tln = head;\\n\\t\\t\\t\\t }else {\\n\\t\\t\\t\\t\\t ln.next = new ListNode(value);\\n\\t\\t\\t\\t\\t ln = ln.next;\\n\\t\\t\\t\\t }\\n\\t\\t\\t}\\n\\t\\t\\treturn head;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 931293,
                "title": "python3-o-n-exactly-with-one-transform",
                "content": "**like it? please, vote!**\\n*dont like? please, commit suggestions for optimization*\\n\\n\\t\\tdef getDecimalValue(self, head: ListNode) -> int:\\n\\t\\t\\tdec = 0  \\n\\t\\t\\twhile (head.next != None):\\n\\t\\t\\t\\tdec *= 2\\n\\t\\t\\t\\tif head.val == 1:\\n\\t\\t\\t\\t\\tdec += 2\\n\\t\\t\\t\\thead = head.next\\n\\n\\t\\t\\tif head.val == 1:\\n\\t\\t\\t\\tdec += 1\\n\\n        return dec",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "**like it? please, vote!**\\n*dont like? please, commit suggestions for optimization*\\n\\n\\t\\tdef getDecimalValue(self, head: ListNode) -> int:\\n\\t\\t\\tdec = 0  \\n\\t\\t\\twhile (head.next != None):\\n\\t\\t\\t\\tdec *= 2\\n\\t\\t\\t\\tif head.val == 1:\\n\\t\\t\\t\\t\\tdec += 2\\n\\t\\t\\t\\thead = head.next\\n\\n\\t\\t\\tif head.val == 1:\\n\\t\\t\\t\\tdec += 1\\n\\n        return dec",
                "codeTag": "Python3"
            },
            {
                "id": 919062,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) \\n    {\\n        string str=\"\";\\n        while(head!=nullptr)\\n        {\\n            string temp=to_string(head->val);\\n            str+=temp;\\n            head=head->next;\\n        }\\n        int ans=0,c=str.size()-1;\\n        for(auto x:str)\\n        {\\n            if(x==\\'1\\')\\n                ans+=pow(2,c);\\n            c--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) \\n    {\\n        string str=\"\";\\n        while(head!=nullptr)\\n        {\\n            string temp=to_string(head->val);\\n            str+=temp;\\n            head=head->next;\\n        }\\n        int ans=0,c=str.size()-1;\\n        for(auto x:str)\\n        {\\n            if(x==\\'1\\')\\n                ans+=pow(2,c);\\n            c--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918917,
                "title": "rust-stream-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn get_decimal_value(head: Option<Box<ListNode>>) -> i32 {\\n        std::iter::successors(head.as_ref(), |v| v.next.as_ref())\\n            .map(|v| v.val)\\n            .fold(0, |a, b| a * 2 + b)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn get_decimal_value(head: Option<Box<ListNode>>) -> i32 {\\n        std::iter::successors(head.as_ref(), |v| v.next.as_ref())\\n            .map(|v| v.val)\\n            .fold(0, |a, b| a * 2 + b)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 918905,
                "title": "c-c-python-super-simple-short-and-clean-recursive-solutions",
                "content": "**C++ :**\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        if (!head)\\n            return res;\\n        res = res<<1;\\n        res += head->val;\\n        return getDecimalValue(head->next);\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```\\n**C :**\\n```\\nint rec(struct ListNode* head, int res) {\\n    if (!head)\\n        return res;\\n    res = res<<1;\\n    res += head->val;\\n    return rec(head->next, res);\\n}\\n\\nint getDecimalValue(struct ListNode* head){\\n    return rec(head, 0);\\n}\\n```\\n**Python :**\\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        def rec(head, res):\\n            if not head:\\n                return res\\n            res = res<<1\\n            res+=head.val\\n            return rec(head.next, res)\\n        \\n        return rec(head, 0)\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        if (!head)\\n            return res;\\n        res = res<<1;\\n        res += head->val;\\n        return getDecimalValue(head->next);\\n    }\\n    \\nprivate:\\n    int res = 0;\\n};\\n```\n```\\nint rec(struct ListNode* head, int res) {\\n    if (!head)\\n        return res;\\n    res = res<<1;\\n    res += head->val;\\n    return rec(head->next, res);\\n}\\n\\nint getDecimalValue(struct ListNode* head){\\n    return rec(head, 0);\\n}\\n```\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        def rec(head, res):\\n            if not head:\\n                return res\\n            res = res<<1\\n            res+=head.val\\n            return rec(head.next, res)\\n        \\n        return rec(head, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850809,
                "title": "c-speed-mem-o-n-o-1-simple-video",
                "content": "https://www.youtube.com/watch?v=1qxuXnS7EvQ&feature=youtu.be\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        \\n        int out= head->val;\\n        \\n        while(head->next != NULL){\\n            out=out<<1;\\n            head=head->next;\\n            if(head->val)\\n                out++;   \\n        }\\n        \\n        \\n        return out;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        \\n        int out= head->val;\\n        \\n        while(head->next != NULL){\\n            out=out<<1;\\n            head=head->next;\\n            if(head->val)\\n                out++;   \\n        }\\n        \\n        \\n        return out;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800281,
                "title": "easy-python-two-solutions",
                "content": "----------------------------------------------Solution: 1---------------------------------------------------------------\\n\\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        x = 0\\n        while head is not None:\\n            x *= 2\\n            x += head.val\\n            head = head.next\\n        return x \\n```\\n\\n----------------------------------------------Solution: 2---------------------------------------------------------------\\n```\\nclass Solution(object):\\n    def getDecimalValue(self, head: ListNode) -> int:\\n\\n\\t\\titr = head\\n        llstr = \\'\\'\\n        while itr:\\n            llstr += str(itr.val)\\n            itr = itr.next\\n\\n\\t\\treturn int(llstr, 2)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        x = 0\\n        while head is not None:\\n            x *= 2\\n            x += head.val\\n            head = head.next\\n        return x \\n```\n```\\nclass Solution(object):\\n    def getDecimalValue(self, head: ListNode) -> int:\\n\\n\\t\\titr = head\\n        llstr = \\'\\'\\n        while itr:\\n            llstr += str(itr.val)\\n            itr = itr.next\\n\\n\\t\\treturn int(llstr, 2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680296,
                "title": "java-solution-100-using-bitwise-operator",
                "content": "\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans = head.val;\\n        while(head.next != null) {\\n            head = head.next;\\n            ans = (ans << 1) | head.val;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans = head.val;\\n        while(head.next != null) {\\n            head = head.next;\\n            ans = (ans << 1) | head.val;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541833,
                "title": "python3-simple-16ms-11-9mb-faster-and-smaller-o-n-complexity",
                "content": "class Solution(object):\\n    def getDecimalValue(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: int\\n        \"\"\"\\n        return self.get_value(head, 0)\\n\\n    def get_value(self, head, s):\\n        if head.next is not None:\\n            return self.get_value(head.next, 2 * s + head.val)\\n        return 2 * s + head.val",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution(object):\\n    def getDecimalValue(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: int\\n        \"\"\"\\n        return self.get_value(head, 0)\\n\\n    def get_value(self, head, s):\\n        if head.next is not None:\\n            return self.get_value(head.next, 2 * s + head.val)\\n        return 2 * s + head.val",
                "codeTag": "Java"
            },
            {
                "id": 537838,
                "title": "elegant-bit-manipulation-0-ms-c-solution-faster-than-100-and-better-memory-than-100",
                "content": "Bitshifts are fast, so they are one optimal way of solving this problem.\\n\\nA simple solution would look like this:\\n```\\nint getDecimalValue(ListNode* head) {\\n\\tint value = 0;\\n\\tListNode* temp = head;\\n\\twhile (temp != NULL) {\\n\\t\\tvalue <<= 1;\\n\\t\\tif (temp->val == 1) {\\n\\t\\t\\t++value;\\n\\t\\t}\\n\\t\\ttemp = temp->next;\\n\\t}\\n\\tdelete temp;\\n\\treturn value;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint getDecimalValue(ListNode* head) {\\n\\tint value = 0;\\n\\tListNode* temp = head;\\n\\twhile (temp != NULL) {\\n\\t\\tvalue <<= 1;\\n\\t\\tif (temp->val == 1) {\\n\\t\\t\\t++value;\\n\\t\\t}\\n\\t\\ttemp = temp->next;\\n\\t}\\n\\tdelete temp;\\n\\treturn value;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 496926,
                "title": "my-c-sumbmission-with-less-100-00",
                "content": "```\\n    int sum=0;\\n    struct ListNode* temp;\\n    temp=head;\\n    while(temp!=NULL)\\n    {\\n        sum=sum*2+temp->val;\\n        temp=temp->next;\\n    }\\n\\treturn sum;\\n```",
                "solutionTags": [],
                "code": "```\\n    int sum=0;\\n    struct ListNode* temp;\\n    temp=head;\\n    while(temp!=NULL)\\n    {\\n        sum=sum*2+temp->val;\\n        temp=temp->next;\\n    }\\n\\treturn sum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 483095,
                "title": "java-easy-to-understand-100-beat-o-n-solution-o-1-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        \\n        int sum = 0;    \\n        while(head != null){\\n            sum = sum * 2;    \\n            sum = sum + head.val;\\n            head = head.next;\\n        }\\n    \\n        return sum;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        \\n        int sum = 0;    \\n        while(head != null){\\n            sum = sum * 2;    \\n            sum = sum + head.val;\\n            head = head.next;\\n        }\\n    \\n        return sum;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 466773,
                "title": "python-string-to-int",
                "content": "```class Solution(object):\\n    def getDecimalValue(self, head):\\n        ans = \"\"\\n        while head:\\n            ans = ans+str(head.val)\\n            head = head.next\\n        print(ans)\\n        \\n        return int(ans,2)```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Solution(object):\\n    def getDecimalValue(self, head):\\n        ans = \"\"\\n        while head:\\n            ans = ans+str(head.val)\\n            head = head.next\\n        print(ans)\\n        \\n        return int(ans,2)```",
                "codeTag": "Java"
            },
            {
                "id": 464957,
                "title": "c-faster-than-86-5-o-n-with-comments",
                "content": "```\\npublic int DoGetDecimalValue(ListNode head)\\n        {\\n            /* Basically:\\n                Given a linked list of binary numbers, combine it into a binary number and return that.\\n                Problem Constraints: \\n                    The linked list ranges from 1 --> 30 elements.\\n                    val is 0 or 1\\n                    \\n                    The head element is the farthest left bit in the binary number.\\n                    Wow - that makes it even easier.   \\n            */\\n\\n            /* Brute force:\\n                left shift the current number\\n                Set lowest bit to the value from the linked list\\n                continue until the end\\n                            \\n              Complexity: O(n)\\n              Space: O(1)\\n            */\\n\\n            if (head == null)\\n                return 0;\\n\\n            int result = 0;\\n\\n            ListNode curr = head;\\n            while (curr != null)\\n            {\\n                result = result << 1;\\n                result |= curr.val;\\n\\n                curr = curr.next;\\n            }\\n\\n            return result;\\n        }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\npublic int DoGetDecimalValue(ListNode head)\\n        {\\n            /* Basically:\\n                Given a linked list of binary numbers, combine it into a binary number and return that.\\n                Problem Constraints: \\n                    The linked list ranges from 1 --> 30 elements.\\n                    val is 0 or 1\\n                    \\n                    The head element is the farthest left bit in the binary number.\\n                    Wow - that makes it even easier.   \\n            */\\n\\n            /* Brute force:\\n                left shift the current number\\n                Set lowest bit to the value from the linked list\\n                continue until the end\\n                            \\n              Complexity: O(n)\\n              Space: O(1)\\n            */\\n\\n            if (head == null)\\n                return 0;\\n\\n            int result = 0;\\n\\n            ListNode curr = head;\\n            while (curr != null)\\n            {\\n                result = result << 1;\\n                result |= curr.val;\\n\\n                curr = curr.next;\\n            }\\n\\n            return result;\\n        }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 456661,
                "title": "c-bitshift-with-detailed-explanation",
                "content": "*From Geeksforgeeks:*\\nThe << (left shift) in C or C++ takes two numbers, left shifts the bits of the first operand, the second operand decides the number of places to shift.\\n\\nFor example, if we have an int and it is initalized to 4, it looks like this in binary\\n000.........0000000100\\n\\nIf we do a left shift of 1, it\\'ll look like this\\n000.........0000001000 \\ngiving us a value of 8. \\n\\nSo we initalize a variable to be 0 so all the bits are set to 0. \\nThen when we loop through linked list, we bitshift by 1. \\nFrom there we either add 0 or 1 to the binary value. \\n\\nBy doing this, we can work backwards. \\nIf our length of the list is 3, \\nwe needed to calculate 2^2 + 2^1 + 2^0 . By bitshifting left, we can start from 2^2.\\n\\n```\\n    int getDecimalValue(ListNode* head) {\\n        int out = 0;\\n        while(head){\\n            out <<= 1;\\n            out += head->val;\\n            head = head->next;\\n        }\\n        return out;\\n    }",
                "solutionTags": [],
                "code": "*From Geeksforgeeks:*\\nThe << (left shift) in C or C++ takes two numbers, left shifts the bits of the first operand, the second operand decides the number of places to shift.\\n\\nFor example, if we have an int and it is initalized to 4, it looks like this in binary\\n000.........0000000100\\n\\nIf we do a left shift of 1, it\\'ll look like this\\n000.........0000001000 \\ngiving us a value of 8. \\n\\nSo we initalize a variable to be 0 so all the bits are set to 0. \\nThen when we loop through linked list, we bitshift by 1. \\nFrom there we either add 0 or 1 to the binary value. \\n\\nBy doing this, we can work backwards. \\nIf our length of the list is 3, \\nwe needed to calculate 2^2 + 2^1 + 2^0 . By bitshifting left, we can start from 2^2.\\n\\n```\\n    int getDecimalValue(ListNode* head) {\\n        int out = 0;\\n        while(head){\\n            out <<= 1;\\n            out += head->val;\\n            head = head->next;\\n        }\\n        return out;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 455069,
                "title": "javascript-94-speed-100-mem",
                "content": "```\\nvar getDecimalValue = function(head) {\\n    // create the binary string \\n    let binary = \\'\\';\\n    while(head) {\\n        binary += head.val;\\n        head = head.next;\\n    }\\n    return parseInt(binary, 2);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getDecimalValue = function(head) {\\n    // create the binary string \\n    let binary = \\'\\';\\n    while(head) {\\n        binary += head.val;\\n        head = head.next;\\n    }\\n    return parseInt(binary, 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454225,
                "title": "a-few-solutions",
                "content": "Generate the answer `ans` one bit at a time while traversing the linked list.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun getDecimalValue(head: ListNode?): Int {\\n        var ans = 0\\n        var cur = head\\n        while (cur != null) {\\n            ans = ans shl 1\\n            ans += cur.`val`\\n            cur = cur.next\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet getDecimalValue = (head, ans = 0) => {\\n    while (head) {\\n        ans <<= 1;\\n        ans += head.val;\\n        head = head.next;\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode, ans = 0) -> int:\\n        while head:\\n            ans <<= 1\\n            ans += head.val\\n            head = head.next\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head, int ans = 0) {\\n        while (head) {\\n            ans <<= 1;\\n            ans += head->val;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getDecimalValue(head: ListNode?): Int {\\n        var ans = 0\\n        var cur = head\\n        while (cur != null) {\\n            ans = ans shl 1\\n            ans += cur.`val`\\n            cur = cur.next\\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nlet getDecimalValue = (head, ans = 0) => {\\n    while (head) {\\n        ans <<= 1;\\n        ans += head.val;\\n        head = head.next;\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode, ans = 0) -> int:\\n        while head:\\n            ans <<= 1\\n            ans += head.val\\n            head = head.next\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head, int ans = 0) {\\n        while (head) {\\n            ans <<= 1;\\n            ans += head->val;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454064,
                "title": "explained-c-recursive-solution-100-memory",
                "content": "Recurse to the tail of the list.\\n\\nOn the way back up, return a tuple: ```(nextValueToMultiply, accumulatedValue)```\\n\\n<< 1 is a binary left shift, \\n\\n```\\npublic int GetDecimalValue(ListNode head)\\n{\\n\\tif (head == null) return 0;\\n\\n\\t(int nextMult, int accumulatedValue) GetInternal(ListNode current)\\n\\t{\\n\\t\\tif(current.next == null)\\n\\t\\t{\\n\\t\\t\\treturn (1 << 1, current.val);\\n\\t\\t}\\n\\n\\t\\tvar (nextMult, accumulatedValue) = GetInternal(current.next);\\n\\n\\t\\treturn (nextMult << 1, accumulatedValue + current.val * nextMult);\\n\\t}\\n\\n\\treturn GetInternal(head).accumulatedValue;\\n}\\n```",
                "solutionTags": [
                    "Linked List",
                    "Recursion"
                ],
                "code": "```(nextValueToMultiply, accumulatedValue)```\n```\\npublic int GetDecimalValue(ListNode head)\\n{\\n\\tif (head == null) return 0;\\n\\n\\t(int nextMult, int accumulatedValue) GetInternal(ListNode current)\\n\\t{\\n\\t\\tif(current.next == null)\\n\\t\\t{\\n\\t\\t\\treturn (1 << 1, current.val);\\n\\t\\t}\\n\\n\\t\\tvar (nextMult, accumulatedValue) = GetInternal(current.next);\\n\\n\\t\\treturn (nextMult << 1, accumulatedValue + current.val * nextMult);\\n\\t}\\n\\n\\treturn GetInternal(head).accumulatedValue;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 453381,
                "title": "php-solution",
                "content": "Seems filthy but it works\\n\\n```php\\nclass Solution {\\n\\n    /**\\n     * @param ListNode $head\\n     * @return Integer\\n     */\\n    function getDecimalValue($head) {\\n        $bin = \\'\\';\\n        while ($head->next != NULL) {\\n            $bin .= strval($head->val);\\n            $head = $head->next;\\n        }\\n        $bin .= strval($head->val);\\n        return bindec($bin);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```php\\nclass Solution {\\n\\n    /**\\n     * @param ListNode $head\\n     * @return Integer\\n     */\\n    function getDecimalValue($head) {\\n        $bin = \\'\\';\\n        while ($head->next != NULL) {\\n            $bin .= strval($head->val);\\n            $head = $head->next;\\n        }\\n        $bin .= strval($head->val);\\n        return bindec($bin);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453212,
                "title": "swift-easy-solution",
                "content": "```Swift\\n    func getDecimalValue(_ head: ListNode?) -> Int {\\n        var ans = 0\\n        var node: ListNode? = head\\n        while node != nil {\\n            ans = ans * 2 + node!.val\\n            node = node?.next\\n        }\\n        return ans\\n    }\\n```",
                "solutionTags": [],
                "code": "```Swift\\n    func getDecimalValue(_ head: ListNode?) -> Int {\\n        var ans = 0\\n        var node: ListNode? = head\\n        while node != nil {\\n            ans = ans * 2 + node!.val\\n            node = node?.next\\n        }\\n        return ans\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 452575,
                "title": "java-recursive-solution-time-memory-o-n-beats-100",
                "content": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        return getDecimalValue(head, 0);\\n    }\\n    \\n     public int getDecimalValue(ListNode head, int num) {\\n        if (head==null)return num;\\n         else return getDecimalValue(head.next, num*2+head.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        return getDecimalValue(head, 0);\\n    }\\n    \\n     public int getDecimalValue(ListNode head, int num) {\\n        if (head==null)return num;\\n         else return getDecimalValue(head.next, num*2+head.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059771,
                "title": "you-are-not-gonna-fail-again-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n\\n        ListNode* list=head;\\n        int count = 0, res = 0;\\n\\n        while(list) {\\n            count++;\\n            list = list->next;\\n        }\\n\\n\\n        for(int i=count-1; i>=0; i--) {\\n            res = res + (head->val)*pow(2,i);\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n\\n        ListNode* list=head;\\n        int count = 0, res = 0;\\n\\n        while(list) {\\n            count++;\\n            list = list->next;\\n        }\\n\\n\\n        for(int i=count-1; i>=0; i--) {\\n            res = res + (head->val)*pow(2,i);\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018117,
                "title": "an-impressive-and-straightforward-solution-for-the-interviewer-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans=0;\\n        while(head!=null){\\n            ans=(ans<<1)+head.val;\\n            head=head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans=0;\\n        while(head!=null){\\n            ans=(ans<<1)+head.val;\\n            head=head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877352,
                "title": "java-easy-2-line-code-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used basic concept of linklist ans binary to decimal conversation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans=0;\\n        while(head!=null){\\n            //ans=ans*2;\\n            ans=2*ans+head.val;\\n            head=head.next;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans=0;\\n        while(head!=null){\\n            //ans=ans*2;\\n            ans=2*ans+head.val;\\n            head=head.next;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872328,
                "title": "easy-c-solution-beats-100-of-the-people-in-time",
                "content": "# Intuition\\nFirst thought the general approach of traversing the list and counting the elements and then calculating the value bu for efficient code thought of reversing the list and then doing the same\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMade a function to reverse the list the used the left shift operator to find the power of 2 for tha particular position. 1<<x = 2^x\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **$$O(N log N)$$** or **$$O(N)$$** depending upon tthe compexity of power of 2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **$$O(N)$$**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n ListNode* reverseList(ListNode* head) {\\n        if(head==nullptr || head->next==nullptr)\\n        return head;\\n        ListNode* n=new ListNode(head->val);\\n        head=head->next;\\n        while(head!=nullptr)\\n        {\\n            ListNode* newnode=new ListNode(head->val,n);\\n            n=newnode;\\n            head=head->next;\\n        }\\n        return n;\\n    }\\n    int getDecimalValue(ListNode* head) {\\n        head=reverseList(head);\\n        int p=0;\\n        int n=0;\\n        while(head!=nullptr)\\n        {\\n            if(head->val==1)\\n            {\\n                n+=(1<<p);\\n            }\\n            p++;\\n            head=head->next;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n ListNode* reverseList(ListNode* head) {\\n        if(head==nullptr || head->next==nullptr)\\n        return head;\\n        ListNode* n=new ListNode(head->val);\\n        head=head->next;\\n        while(head!=nullptr)\\n        {\\n            ListNode* newnode=new ListNode(head->val,n);\\n            n=newnode;\\n            head=head->next;\\n        }\\n        return n;\\n    }\\n    int getDecimalValue(ListNode* head) {\\n        head=reverseList(head);\\n        int p=0;\\n        int n=0;\\n        while(head!=nullptr)\\n        {\\n            if(head->val==1)\\n            {\\n                n+=(1<<p);\\n            }\\n            p++;\\n            head=head->next;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758271,
                "title": "easy-to-understand-clear-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int> v;\\n        while(head!=NULL){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        reverse(v.begin(),v.end());\\n        int n = v.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=pow(2,i)*v[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Math"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int> v;\\n        while(head!=NULL){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        reverse(v.begin(),v.end());\\n        int n = v.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=pow(2,i)*v[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656429,
                "title": "easy-solution-ll-binary-to-decimal-hehe",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n- where n=length of linked list;\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int binaryToDecimal(string n)\\n{\\n    string num = n;\\n    int dec_value = 0;\\n \\n    // Initializing base value to 1, i.e 2^0\\n    int base = 1;\\n \\n    int len = num.length();\\n    for (int i = len - 1; i >= 0; i--) {\\n        if (num[i] == \\'1\\')\\n            dec_value += base;\\n        base = base * 2;\\n    }\\n \\n    return dec_value;\\n}\\n    int getDecimalValue(ListNode* head) {\\n        string s=\"\";\\n        ListNode* temp=head;\\n        while(temp!=NULL)\\n        {\\n            s=s+to_string(temp->val);\\n            temp=temp->next;\\n        }\\n        int k=binaryToDecimal(s);\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int binaryToDecimal(string n)\\n{\\n    string num = n;\\n    int dec_value = 0;\\n \\n    // Initializing base value to 1, i.e 2^0\\n    int base = 1;\\n \\n    int len = num.length();\\n    for (int i = len - 1; i >= 0; i--) {\\n        if (num[i] == \\'1\\')\\n            dec_value += base;\\n        base = base * 2;\\n    }\\n \\n    return dec_value;\\n}\\n    int getDecimalValue(ListNode* head) {\\n        string s=\"\";\\n        ListNode* temp=head;\\n        while(temp!=NULL)\\n        {\\n            s=s+to_string(temp->val);\\n            temp=temp->next;\\n        }\\n        int k=binaryToDecimal(s);\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499719,
                "title": "most-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans=0;\\n        while(head!=null){\\n            ans=ans*2;\\n            ans=ans+head.val;\\n            head=head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int ans=0;\\n        while(head!=null){\\n            ans=ans*2;\\n            ans=ans+head.val;\\n            head=head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418768,
                "title": "easy-java-solution-beats-100-beginner-friendly-code",
                "content": "# Approach\\n- Creating new ArrayList and appending all node values into Array in an ordered fashion\\n- Converting Array of Bits into Integer with simple Mathematical formula\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(kn)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        \\n        // new ArrayList to record all the ordered LL values\\n        \\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n\\n        if (head == null){\\n            return 0;\\n        }else if(head != null){\\n            while(head != null){\\n                arr.add(head.val);\\n                head = head.next;\\n            }     \\n        }\\n\\n\\n        int length = arr.size();\\n        double sum = 0;\\n\\n        // Simple mathematical interpretation for convertion from Binary to Integer\\n        \\n        for(int i=0;i<arr.size();i++){\\n            length--;\\n            sum = sum + Math.pow(2,length)*arr.get(i);\\n        }\\n\\n\\n        return (int)sum;\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/5b78b39d-1376-46da-96d6-40bca706d81b_1681544296.237132.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        \\n        // new ArrayList to record all the ordered LL values\\n        \\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n\\n        if (head == null){\\n            return 0;\\n        }else if(head != null){\\n            while(head != null){\\n                arr.add(head.val);\\n                head = head.next;\\n            }     \\n        }\\n\\n\\n        int length = arr.size();\\n        double sum = 0;\\n\\n        // Simple mathematical interpretation for convertion from Binary to Integer\\n        \\n        for(int i=0;i<arr.size();i++){\\n            length--;\\n            sum = sum + Math.pow(2,length)*arr.get(i);\\n        }\\n\\n\\n        return (int)sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370887,
                "title": "easy-c-solution-with-explanation",
                "content": "# Intuition\\ntaking a sum variable initially 0 so while traversing the linked line we add value and in next iteration we multiply sum by 2 and add current node value\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor example taking 101\\nwe can get solution by ((0+1)*2+0)*2+1\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int k=0;\\n        while(head){\\n            k=k*2+head->val;\\n            head=head->next;\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int k=0;\\n        while(head){\\n            k=k*2+head->val;\\n            head=head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3353663,
                "title": "easy-c-sol",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int> v;\\n        while(head!=NULL){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        reverse(v.begin(),v.end());\\n        int n = v.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=pow(2,i)*v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int> v;\\n        while(head!=NULL){\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        reverse(v.begin(),v.end());\\n        int n = v.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=pow(2,i)*v[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122687,
                "title": "easy-4line-code",
                "content": "\\n   class Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans=0;\\n        while(head) {\\n            ans = (ans << 1) | head->val;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int ans=0;\\n        while(head) {\\n            ans = (ans << 1) | head->val;\\n            head = head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3104486,
                "title": "day-10-programming-skills-i-1st-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int decimal=0;\\n        while(head!=NULL)\\n        {\\n            decimal=decimal*2+head->val;\\n            head=head->next;\\n\\n        }\\n        return decimal;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int decimal=0;\\n        while(head!=NULL)\\n        {\\n            decimal=decimal*2+head->val;\\n            head=head->next;\\n\\n        }\\n        return decimal;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998898,
                "title": "simple-solution-with-explanation",
                "content": "We are using a method over there which is called as **Doubling Method** . In this method what we do is double the previous value (initially 0) and add the current value to it.\\nAs the name suggests, the process of doubling or multiplying by 2 is done to convert binary to decimal. Let us use the same example for converting the binary number\\n101101\\nto decimal. Observe the following steps given below to understand the binary to decimal conversion using the doubling method.\\n\\n**Step 1:** Write the binary number and start from the left-most digit. Double the previous number and add the current digit. Since we are starting from the left-most digit and there is no previous digit to the left-most digit, we consider the double of the previous digit as 0. For example in 101101\\nthe left-most digit is \\'1\\'. The double of the previous number is 0. Therefore, we get ((0 \\xD7 2) + 1) which is 1.\\n**Step 2:** Continue the same process for the next digit also. The second digit from the left is 0. Now, double the previous digit and add it with the current digit. Therefore, we get, [(1 \\xD7 2) + 0], which is 2.\\n**Step 3:** Continue the same step in sequence for all the digits. The sum that is achieved in the last step is the actual decimal value. Therefore, the result of converting the binary number\\n(101101)\\nto a decimal using the doubling method is 45\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int bin = 0;\\n        while(head!=null){\\n            bin = bin*2 + head.val;\\n            head=head.next;\\n        }\\n        return bin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int bin = 0;\\n        while(head!=null){\\n            bin = bin*2 + head.val;\\n            head=head.next;\\n        }\\n        return bin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954036,
                "title": "simple-bit-manipulation-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc getDecimalValue(head *ListNode) int {\\n    var res int\\n    for head != nil {\\n        res = (res << 1) | head.Val\\n        head = head.Next\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getDecimalValue(head *ListNode) int {\\n    var res int\\n    for head != nil {\\n        res = (res << 1) | head.Val\\n        head = head.Next\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2952497,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int> v;\\n        while(head) {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        reverse(v.begin(), v.end());\\n        int ans = 0;\\n        for(int i=0; i<v.size(); i++) {\\n            if(v[i]) ans += pow(2, i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        vector<int> v;\\n        while(head) {\\n            v.push_back(head->val);\\n            head = head->next;\\n        }\\n        reverse(v.begin(), v.end());\\n        int ans = 0;\\n        for(int i=0; i<v.size(); i++) {\\n            if(v[i]) ans += pow(2, i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949759,
                "title": "c-0ms-runtime-100-fast-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string num=\"\";\\n        while(head){\\n            num+=to_string(head->val);\\n            head=head->next;\\n        }\\n        reverse(num.begin(), num.end());\\n        //cout<<num<<endl;\\n        int i=0, ans=0;\\n        while(i<num.size()){\\n            if(num[i]==\\'1\\'){\\n                ans+=pow(2, i);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        string num=\"\";\\n        while(head){\\n            num+=to_string(head->val);\\n            head=head->next;\\n        }\\n        reverse(num.begin(), num.end());\\n        //cout<<num<<endl;\\n        int i=0, ans=0;\\n        while(i<num.size()){\\n            if(num[i]==\\'1\\'){\\n                ans+=pow(2, i);\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2929269,
                "title": "easy-and-short-understandable-c",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int sum=0;\\n        while(head!=NULL){\\n            sum=sum*2+head->val;\\n            head=head->next;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        int sum=0;\\n        while(head!=NULL){\\n            sum=sum*2+head->val;\\n            head=head->next;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2858551,
                "title": "c-easy-to-understand-2-binary-conversion",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        \\n        int ans = 0;\\n\\n        while(head!=NULL)\\n        {\\n            ans = ans * 2 + head->val;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n        \\n        int ans = 0;\\n\\n        while(head!=NULL)\\n        {\\n            ans = ans * 2 + head->val;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1831226,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 1565915,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 1745585,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 1569836,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 1568644,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 1734612,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 2051528,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 2050347,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 2023625,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 2013880,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 1831226,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 1565915,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 1745585,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 1569836,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 1568644,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 1734612,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 2051528,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 2050347,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 2023625,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            },
            {
                "id": 2013880,
                "content": [
                    {
                        "username": "user7924KL",
                        "content": "Don\\'t post solutions here nobheads!"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Binary Representation\n\n  \n**Approach 2:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Charizard04",
                        "content": "One approach can be by first calculating the number of nodes in the linkedlist then traversing each node and multiplying the value of that node with the power of 2^number of nodes -1, while decreasing the count subsequently."
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "This would be two-pass as where the doubling method is only one-pass."
                    },
                    {
                        "username": "rkatipally",
                        "content": "\\tint sum = 0;\\n\\twhile (head != null) {\\n\\t\\tsum = sum * 2 + head.val;\\n\\t\\thead = head.next;\\n\\t}\\n\\treturn sum;"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "harijey",
                        "content": "![image](https://assets.leetcode.com/users/images/7630fc21-71b4-472c-ab2e-756de5d11972_1630808188.9123309.jpeg)\\n\\n\\nnum<<1 shall be substituted with num *2, however num<<1 is faster than the later."
                    },
                    {
                        "username": "leetcode_ka_raja",
                        "content": "while(head){\\n            int bit=head->val;\\n            res=res<<1 | bit;\\n            head=head->next;\\n        }"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2728EASIEST C++ FAANG\\u2763 OPTIMISED CLEAN CODE \\uD83D\\uDCA5 | Beginner friendly Soln.\\nhttps://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/solutions/2244394/easiest-c-faang-optimised-clean-code-beginner-friendly-soln/"
                    },
                    {
                        "username": "Yash2k04",
                        "content": "hey folks,\n\n(JAVA)-https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/description/\n\nI tried to solve this problem by using Stack concept.\nAs we first traverse the list and push all the node values in stack until its not reaches to null , then we pop all the value from the stack one by one and multiple with power of 2 increment at each loop .\n\nBcoz we multiply binary value with power  of 2^0 , then 2^1 and so on......from the last  and stack also first give last value and then second last value and so on....\n\n"
                    },
                    {
                        "username": "user5859A",
                        "content": " `your inline code...your inline code...`\\nint sum = 0;\\nwhile(head!=NULL){\\nsum = sum * 2 + head->val;\\nhead = head->next;\\n}\\nreturn sum;\\n\\n\\n\\nwith 100% beats."
                    },
                    {
                        "username": "emmanuellmhango",
                        "content": "Guys, maybe am just a dumbhead,  but isnt it just concatenating the list to a string and then parse it to radix=2 a simpler version? :(("
                    },
                    {
                        "username": "khushimattu",
                        "content": "I dont get where I am going wrong\\n```\\nclass Solution {\\n    public int getDecimalValue(ListNode head) {\\n        int num=0;\\n        while(head!=null){\\n            num=10*num+head.val;\\n            head=head.next;\\n        }\\n        \\n        int power=0;\\n        int ans=0;\\n        while(num>0){\\n            ans+=((num%10)*Math.pow(2,power));\\n            power++;\\n            num=num/10;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "I\\'m I the only one who gets incorrect results when submitting via golang? "
                    }
                ]
            }
        ]
    },
    {
        "title": "Sequential Digits",
        "question_content": "<p>An&nbsp;integer has <em>sequential digits</em> if and only if each digit in the number is one more than the previous digit.</p>\n\n<p>Return a <strong>sorted</strong> list of all the integers&nbsp;in the range <code>[low, high]</code>&nbsp;inclusive that have sequential digits.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> low = 100, high = 300\n<strong>Output:</strong> [123,234]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> low = 1000, high = 13000\n<strong>Output:</strong> [1234,2345,3456,4567,5678,6789,12345]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>10 &lt;= low &lt;= high &lt;= 10^9</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 451851,
                "title": "java-just-a-joke",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int[] allNums = {12,23,34,45,56,67,78,89,\\n                         123,234,345,456,567,678,789,\\n                         1234,2345,3456,4567,5678,6789,\\n                         12345,23456,34567,45678,56789,\\n                         123456,234567,345678,456789,\\n                         1234567,2345678,3456789,\\n                         12345678,23456789,\\n                         123456789};\\n        List<Integer> res = new ArrayList<>();\\n        int n = allNums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (allNums[i] < low) continue;\\n            if (allNums[i] > high) break;\\n            res.add(allNums[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int[] allNums = {12,23,34,45,56,67,78,89,\\n                         123,234,345,456,567,678,789,\\n                         1234,2345,3456,4567,5678,6789,\\n                         12345,23456,34567,45678,56789,\\n                         123456,234567,345678,456789,\\n                         1234567,2345678,3456789,\\n                         12345678,23456789,\\n                         123456789};\\n        List<Integer> res = new ArrayList<>();\\n        int n = allNums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (allNums[i] < low) continue;\\n            if (allNums[i] > high) break;\\n            res.add(allNums[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451862,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int l, int h) {\\n        queue<int> q;\\n        for(int i = 1; i <= 9; i++) {\\n            q.push(i);\\n        }\\n        vector<int> ret;\\n        while(!q.empty()) {\\n            int f = q.front();\\n            q.pop();\\n            if(f <= h && f >= l) {\\n                ret.push_back(f);\\n            }\\n            if(f > h)\\n                break;\\n            int num = f % 10;\\n            if(num < 9) {\\n                q.push(f * 10 + (num + 1));\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int l, int h) {\\n        queue<int> q;\\n        for(int i = 1; i <= 9; i++) {\\n            q.push(i);\\n        }\\n        vector<int> ret;\\n        while(!q.empty()) {\\n            int f = q.front();\\n            q.pop();\\n            if(f <= h && f >= l) {\\n                ret.push_back(f);\\n            }\\n            if(f > h)\\n                break;\\n            int num = f % 10;\\n            if(num < 9) {\\n                q.push(f * 10 + (num + 1));\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853592,
                "title": "python-solution-using-queue-explained",
                "content": "Let us create queue, where we put numbers `1,2,3,4,5,6,7,8,9` at the beginning. Then on each step we are going to extract number and put this number with added to the end incremented last digit: so we have on the next step:\\n\\n`2,3,4,5,6,7,8,9,12`\\n`3,4,5,6,7,8,9,12,23`\\n...\\n`12,23,34,45,56,67,78,89`\\n`23,34,45,56,67,78,89,123`,\\n...\\n\\nOn each, when we extract number from the beginning we check if it is in our range and if it is, we put it into our `out` list. Then we add new candidate to the end of our queue. In this way we make sure, that we generate elements in increasing order.\\n\\n**Complexity**:  There will be `9+8+...+ 1` numbers with sqeuential digits at all and for each of them we need to check it at most once (though in practice we wil finish earlier), so time complexity is `O(45) = O(1)`. Space complexity is also `O(45) = O(1)`.\\n\\n```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711942,
                "title": "c-dfs-with-diagram-basic-0-ms",
                "content": "Let\\'s understand by taking test cases\\n\\n***Test case 1:***\\n![image](https://assets.leetcode.com/users/images/9eb4ab8c-1674-4403-9917-284c547956cb_1642917824.8432016.png)\\n\\n \\n***Test Case 2:***\\n![image](https://assets.leetcode.com/users/images/c9605ef9-6df5-40cb-8abf-ae30b785083a_1642917851.4629235.png)\\n\\n\\n***Lets see the code:***\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    \\n    void dfs(int low, int high, int i, int num){\\n        \\n        if (num >= low and num <= high)\\n            ans.push_back(num);\\n        // case 2: [1000, 13000] if i=10 and num is 6789, then we should stop\\n        if (num > high or i>9) \\n            return;\\n        dfs(low, high, i+1, num*10 + i);\\n    }\\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n        for(int i=1; i<=9; i++)\\n            dfs(low, high, i, 0);\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n***Time Complexity:*** O(1)\\n***Space Complexity:*** O(1)\\n\\n***Explanation for Time Complexity:***\\nIn the for loop, \\nFirst we take i = 1, we get num as 1, 12, 123, ..., 123456789 in worst case. (9 steps)\\ni = 2, we get num as 2, 23, 234, ...., 23456789 in worst case (8 steps)\\nlike wise for i=9, we get num as only 9.\\nTherefore in worst case, we will get (9+8+7+...+1) = 9*10/2 = 45 steps which is constant!\\n\\nSorting in the worst case can take 45log45 which is constant. Hence, O(1).\\n\\nSo, we can say that time complexity is : O(1) \\n\\n\\n\\nPlease Upvote If you liked it \\u263A\\uFE0F!! It keeps me motivated to post solutions like these.\\nIf there are any suggestions / questions / mistakes in my post, comment below.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    \\n    void dfs(int low, int high, int i, int num){\\n        \\n        if (num >= low and num <= high)\\n            ans.push_back(num);\\n        // case 2: [1000, 13000] if i=10 and num is 6789, then we should stop\\n        if (num > high or i>9) \\n            return;\\n        dfs(low, high, i+1, num*10 + i);\\n    }\\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n        for(int i=1; i<=9; i++)\\n            dfs(low, high, i, 0);\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451849,
                "title": "java-python-3-simple-codes",
                "content": "**Note: java code need not to care int overflow, since the biggest valid number is `123456789`, and after that the `next == 10`, which will be filtered out by `while` loop.** -- credit to **@henry0422**.\\n```java\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int digit = 1; digit < 9; ++digit) {\\n            int next = digit, n = next;\\n            while (n <= high && next < 10) {\\n                if (n >= low) {\\n                    res.add(n);\\n                }\\n                n = n * 10 + ++next;\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;        \\n    }\\n```\\n```python\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        ans = []\\n        for digit in range(1, 9):\\n            num = next = digit\\n            while num <= high and next < 10:\\n                if num >= low:\\n                    ans.append(num)\\n                next += 1\\n                num = num * 10 + next\\n        return sorted(ans)\\n```\\nUse Generator:\\n```python\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        def gen(digit):\\n            num = next = digit\\n            while num <= high and next < 10:\\n                if num >= low:\\n                    yield num\\n                next += 1   \\n                num = num * 10 + next\\n            \\n        return sorted([num for digit in range(1, 9) for num in gen(digit)])\\n```",
                "solutionTags": [],
                "code": "```java\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int digit = 1; digit < 9; ++digit) {\\n            int next = digit, n = next;\\n            while (n <= high && next < 10) {\\n                if (n >= low) {\\n                    res.add(n);\\n                }\\n                n = n * 10 + ++next;\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;        \\n    }\\n```\n```python\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        ans = []\\n        for digit in range(1, 9):\\n            num = next = digit\\n            while num <= high and next < 10:\\n                if num >= low:\\n                    ans.append(num)\\n                next += 1\\n                num = num * 10 + next\\n        return sorted(ans)\\n```\n```python\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        def gen(digit):\\n            num = next = digit\\n            while num <= high and next < 10:\\n                if num >= low:\\n                    yield num\\n                next += 1   \\n                num = num * 10 + next\\n            \\n        return sorted([num for digit in range(1, 9) for num in gen(digit)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1712332,
                "title": "java-c-python-very-easy-to-easy-explanation",
                "content": "First let\\'s understand very basic thing what is **Sequential Digit**. By the term sequence you get an idea in a continous series & of what digit. Like **[1,2] [1,2,3] [1,2,3,4,5]** and so on.. till **10^9** as given in the constrains. \\nOr by `leetcode` defination :- **if and only if each digit in the number is one more than the previous digit.** \\n```\\nNow, let\\'s understand this problem by taking an example :- low = 1000, high = 12000 \\nwhere low is the minimum of sequential digits we have and high is up to what you can have. \\nSince our lower limit is 1000 the sequence has to be of 4 digit. \\nSo, we can choose it from the range 1,2,3,4,5,6,7,8,9 \\nSo, what possible sequential digits we could have is lying in our range from 1000 to 12000 is :- [1234,2345,3456,4567,5678,6789]\\n```\\n![image](https://assets.leetcode.com/users/images/00307d32-ef0f-4192-8cea-1ca0713eb0cf_1642914439.3001685.png)\\n\\nSo, how we will do is we will keep **shifting** the **window**. \\nLet\\'s take **nl i.e. no. of digit in lower bond which is 4**\\nAnd **nh i.e. no. of digit in higher bond which is 5**\\n\\n`As we are only concern about 4 & 5 digit. `\\n* So, we will pick first all the **4 digit** **1,2,3,4** and check is it in **low & high range or not**\\n* Next we pick **2,3,4,5** as its also in the range\\n* Then **3,4,5,6** it\\'s in the range\\n* Now **4,5,6,7**it\\'s in the range\\n* then **5,6,7,8** in the range\\n* finally **6,7,8,9** as after that we cannot write any **4** digit number because in the next we will have **7,8,9,10**. But **10 is 2 digit, not 1 digit**\\n\\nSo **4 digits no. are done**. Next we will focus on **5 digit no.** So, **1st 5 digit no smaller will be 1,2,3,4,5** but this no is not in our range as our high is **till 12000**. *But let say we have high as 13000 range, then we can easily have 1,2,3,4,5*\\n\\n**We stop and return our answer.**\\n\\n>What idea we get is we have a string of \"1,2,3,4,5,6,7,8,9\" and from this string we have to get sub-string like 1,2,3,4. It\\'s just like converting no. to string -> string to no.\\n\\n*I hope you got it.* **Let\\'s code it up :**\\n\\n*code each line explained :* `Similar for C++, Java, Python` **{Only Syntax Difference}** approach same\\n\\n* Step - 1\\n```\\n{\\n        // creating variable\\n        string digits = \"123456789\"; // from this string we have to pick substring\\n        vector<int> res; // return our final result\\n        int nl = to_string(low).length(); // no. of digit in lower bond\\n        int nh = to_string(high).length(); // no. of digit in higher bond\\n```\\n* Step - 2\\n```\\n// creating the window size\\n        for(int i = nl; i <= nh; i++){ // i is the outer window and then we will have inner loop for substring and it will be shifting\\n            for(int j = 0; j < 10 - i; j++){ // starting point as we start from 1st digit lets say 1234 and go up till 10 - i\\n                // why till 10 - i because let say length is 3. We are looking for 3 digit no so in start it will pick 123\\n                // and shift it 234 till 789. \\n                // So our starting point will be from 0 to 6. What is this 6 is nothing but 10 - 4, but we have strictly 10 - i\\n                // it will go till 10 - 3. So, it will go till 6 only not 7\\n                int num = stoi(digits.substr(j, i)); // we took the substring and convert it to variable[starting point, length]\\n                if(num >= low && num <= high) res.push_back(num); // adding to our result variable\\n            }\\n        }\\n```\\n* Final Step\\n```\\nreturn res;\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        String digits = \"123456789\";\\n        List<Integer> res = new ArrayList<>();\\n        int nl = String.valueOf(low).length();\\n        int nh = String.valueOf(high).length();\\n        \\n        for(int i = nl; i <= nh; i++){\\n            for(int j = 0; j < 10 - i; j++){\\n                int num = Integer.parseInt(digits.substring(j, j + i));\\n                if(num >= low && num <= high) res.add(num);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        string digits = \"123456789\";\\n        vector<int> res;\\n        int nl = to_string(low).length();\\n        int nh = to_string(high).length();\\n        \\n        for(int i = nl; i <= nh; i++){\\n            for(int j = 0; j < 10 - i; j++){\\n                int num = stoi(digits.substr(j, i));\\n                if(num >= low && num <= high) res.push_back(num);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        digits = \"123456789\"\\n        res = []\\n        nl = len(str(low))\\n        nh = len(str(high))\\n        \\n        for i in range(nl, nh + 1):\\n            for j in range(0, 10 - i):\\n                num = int(digits[j: j + i])\\n                if num >= low and num <= high: res.append(num)\\n        return res;\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(1), because low & high are in range of **10^2 <= l,h <= 10^9** and it is constant\\n\\n* **Space Complexity :-** BigO(1) as space we are just using the list that we want to return. So, if you dont count that space it it will be constant then",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nNow, let\\'s understand this problem by taking an example :- low = 1000, high = 12000 \\nwhere low is the minimum of sequential digits we have and high is up to what you can have. \\nSince our lower limit is 1000 the sequence has to be of 4 digit. \\nSo, we can choose it from the range 1,2,3,4,5,6,7,8,9 \\nSo, what possible sequential digits we could have is lying in our range from 1000 to 12000 is :- [1234,2345,3456,4567,5678,6789]\\n```\n```\\n{\\n        // creating variable\\n        string digits = \"123456789\"; // from this string we have to pick substring\\n        vector<int> res; // return our final result\\n        int nl = to_string(low).length(); // no. of digit in lower bond\\n        int nh = to_string(high).length(); // no. of digit in higher bond\\n```\n```\\n// creating the window size\\n        for(int i = nl; i <= nh; i++){ // i is the outer window and then we will have inner loop for substring and it will be shifting\\n            for(int j = 0; j < 10 - i; j++){ // starting point as we start from 1st digit lets say 1234 and go up till 10 - i\\n                // why till 10 - i because let say length is 3. We are looking for 3 digit no so in start it will pick 123\\n                // and shift it 234 till 789. \\n                // So our starting point will be from 0 to 6. What is this 6 is nothing but 10 - 4, but we have strictly 10 - i\\n                // it will go till 10 - 3. So, it will go till 6 only not 7\\n                int num = stoi(digits.substr(j, i)); // we took the substring and convert it to variable[starting point, length]\\n                if(num >= low && num <= high) res.push_back(num); // adding to our result variable\\n            }\\n        }\\n```\n```\\nreturn res;\\n```\n```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        String digits = \"123456789\";\\n        List<Integer> res = new ArrayList<>();\\n        int nl = String.valueOf(low).length();\\n        int nh = String.valueOf(high).length();\\n        \\n        for(int i = nl; i <= nh; i++){\\n            for(int j = 0; j < 10 - i; j++){\\n                int num = Integer.parseInt(digits.substring(j, j + i));\\n                if(num >= low && num <= high) res.add(num);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        string digits = \"123456789\";\\n        vector<int> res;\\n        int nl = to_string(low).length();\\n        int nh = to_string(high).length();\\n        \\n        for(int i = nl; i <= nh; i++){\\n            for(int j = 0; j < 10 - i; j++){\\n                int num = stoi(digits.substr(j, i));\\n                if(num >= low && num <= high) res.push_back(num);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        digits = \"123456789\"\\n        res = []\\n        nl = len(str(low))\\n        nh = len(str(high))\\n        \\n        for i in range(nl, nh + 1):\\n            for j in range(0, 10 - i):\\n                num = int(digits[j: j + i])\\n                if num >= low and num <= high: res.append(num)\\n        return res;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854519,
                "title": "c-python-bfs-simulation-illustration-step-by-step",
                "content": "Approach 1: BFS\\nTime/Space Complexity: O(1); O(1). \\nWhy?  Here is the anlysis [1]:\\nLet\\'s assume sampel_string=\"123456789\"\\nThere are 36 integers with the sequential digits. Here is how we calculate it.\\nStarting from 9 digits in the sample_string, one could construct \\n9 - 2 + 1 = 8 integers of length 2, \\n9 - 3 + 1 = 7 integers of length 3, \\nand so on and so forth. \\nIn total, it would make 8 + 7 + ... + 1 = 36 integers.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int l, int h) {                \\n        queue<int> q{{1,2,3,4,5,6,7,8,9}}; //9 can be removed\\n        vector<int> ans;\\n        while(!q.empty()) {\\n            int cur = q.front();    q.pop();\\n            if(cur > h) break; // reach upperbound. Done\\n            if(cur >= l && cur <= h) ans.push_back(cur);\\n            int num = cur % 10; // Ready for hoisting operation           \\n            int next = cur * 10 + (num + 1);\\n            if(num < 9) q.push(next);// 1234->12345\\n        }\\n        return ans;\\n    }\\n};\\n/* Silumation illustration on example 1 step-by-step\\nq={1,2,3,4,5,6,7,8,9},        ans={}, 1->12\\nq={2,3,4,5,6,7,8,9, 12},      ans={}, 2->23\\nq={3,4,5,6,7,8,9, 12, 23},    ans={}, 3->34\\nq={4,5,6,7,8,9, 12, 23,34},   ans={}\\n...\\nq={9,12,23,34,45,56,67,78,89},ans={}\\n...\\nq={12,23,34,45,56,67,78,89},  ans={}\\n...\\nq={23,34,45,56,67,78,89,123}, ans={123}\\nq={34,45,56,67,78,89,123,234},ans={123,234}\\nq={45,56,67,78,89,123,234,345},ans={123,234}, 345 > high=400, BREAK\\n*/\\n```\\n\\n\\nApproach 2: sliding window\\nTime/Space complexity: O(1); O(1)\\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        ans = []\\n        nums = \\'123456789\\'\\n        n = len(nums)       \\n        for win_len in range(len(str(low)), len(str(high))+1):\\n            for i in range(n):                                \\n                if i+win_len > n: break\\n                num = int(nums[i:i+win_len])\\n                if num >= low and num <= high: ans.append(num)\\n        return ans\\n```\\nRef:\\nhttps://leetcode.com/problems/sequential-digits/discuss/451862/C%2B%2B-BFS",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int l, int h) {                \\n        queue<int> q{{1,2,3,4,5,6,7,8,9}}; //9 can be removed\\n        vector<int> ans;\\n        while(!q.empty()) {\\n            int cur = q.front();    q.pop();\\n            if(cur > h) break; // reach upperbound. Done\\n            if(cur >= l && cur <= h) ans.push_back(cur);\\n            int num = cur % 10; // Ready for hoisting operation           \\n            int next = cur * 10 + (num + 1);\\n            if(num < 9) q.push(next);// 1234->12345\\n        }\\n        return ans;\\n    }\\n};\\n/* Silumation illustration on example 1 step-by-step\\nq={1,2,3,4,5,6,7,8,9},        ans={}, 1->12\\nq={2,3,4,5,6,7,8,9, 12},      ans={}, 2->23\\nq={3,4,5,6,7,8,9, 12, 23},    ans={}, 3->34\\nq={4,5,6,7,8,9, 12, 23,34},   ans={}\\n...\\nq={9,12,23,34,45,56,67,78,89},ans={}\\n...\\nq={12,23,34,45,56,67,78,89},  ans={}\\n...\\nq={23,34,45,56,67,78,89,123}, ans={123}\\nq={34,45,56,67,78,89,123,234},ans={123,234}\\nq={45,56,67,78,89,123,234,345},ans={123,234}, 345 > high=400, BREAK\\n*/\\n```\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        ans = []\\n        nums = \\'123456789\\'\\n        n = len(nums)       \\n        for win_len in range(len(str(low)), len(str(high))+1):\\n            for i in range(n):                                \\n                if i+win_len > n: break\\n                num = int(nums[i:i+win_len])\\n                if num >= low and num <= high: ans.append(num)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711510,
                "title": "c-0ms-solution-simplest-approach-in-o-1",
                "content": "**Approach :**\\n**Intution 1** : At first I thought, i should try checking every element between low and high , then check.\\nBut after seeing the constraints, I found it would not be the right solution. Constraints ae very high, so its approach would be very simpler that it seems.\\n\\n**Intution 2**: All the elements would contain only 1 to 9 numbers. Then I thought instead of searching I would create the nos in sequential order and then will check the bounds. Then, my friends this approach worked.\\n\\nTime Complexity : O(1)\\nSpace Complexity : O(n) , where n is no. of sequential digits between the bound.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> result;\\n        int num = 0;\\n        for(int i = 1; i<10 ; i++)\\n        {\\n            num = i;\\n            for(int j = i+1;j<10;j++)\\n            {\\n                num = num*10 + j;\\n                if(num >= low && num <= high)\\n                {\\n                    result.push_back(num);\\n                }\\n            }\\n        }\\n        sort(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> result;\\n        int num = 0;\\n        for(int i = 1; i<10 ; i++)\\n        {\\n            num = i;\\n            for(int j = i+1;j<10;j++)\\n            {\\n                num = num*10 + j;\\n                if(num >= low && num <= high)\\n                {\\n                    result.push_back(num);\\n                }\\n            }\\n        }\\n        sort(result.begin(), result.end());\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453429,
                "title": "java-concise-short-bfs",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> ans = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        if(low <= 0 && high >= 0) ans.add(0);\\n        for(int i = 1; i < 10; i++) q.add(i);\\n        while(q.size() > 0){\\n            int curr = q.remove();\\n            if(curr >= low && curr <= high) ans.add(curr);\\n            int onesDigit = curr % 10;\\n            if(onesDigit < 9 && curr * 10 + onesDigit + 1 <= high) q.add(curr * 10 + onesDigit + 1);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> ans = new ArrayList<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        if(low <= 0 && high >= 0) ans.add(0);\\n        for(int i = 1; i < 10; i++) q.add(i);\\n        while(q.size() > 0){\\n            int curr = q.remove();\\n            if(curr >= low && curr <= high) ans.add(curr);\\n            int onesDigit = curr % 10;\\n            if(onesDigit < 9 && curr * 10 + onesDigit + 1 <= high) q.add(curr * 10 + onesDigit + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 853558,
                "title": "python-super-super-easy-simplest-question-100-faster",
                "content": "```\\n#(please upvote if you like the solution)\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        s=\\'123456789\\'\\n        ans=[]\\n        for i in range(len(s)):\\n            for j in range(i+1,len(s)):\\n                st=int(s[i:j+1])\\n                if(st>=low and st<=high):\\n                    ans.append(st)\\n        ans.sort()            \\n        return ans       \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#(please upvote if you like the solution)\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        s=\\'123456789\\'\\n        ans=[]\\n        for i in range(len(s)):\\n            for j in range(i+1,len(s)):\\n                st=int(s[i:j+1])\\n                if(st>=low and st<=high):\\n                    ans.append(st)\\n        ans.sort()            \\n        return ans       \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 854481,
                "title": "just-a-10-lines-of-c-code-explaination-100-efficient",
                "content": "```\\nExplaination:\\n\\ni==1 :  \\n            j==1  sum=1  , j==2 sum=12, j==3 sum=123 .......\\ni==2  :\\n            j==2  sum=2  ,j==3 sum=23 ,j==4 sum=234 .......\\ni==3  :\\n            j==3  sum=3  ,j==4 sum=34 ,j==5 sum=345 .......\\t\\t\\nAnd so on upto i==9....\\n\\nAnd then check if the above sum is between low -high  or not\\nif it is between then store it in vector and then at last sort this vector .\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        vector<int> ans;\\n        int sum;\\n        for(int i=1;i<=9;i++)\\n        {\\n            sum=0;\\n            for(int j=i;j<=9;j++)\\n            {\\n               sum=sum*10+j;   \\n                if(sum>=low&&sum<=high)\\n                {\\n                    ans.push_back(sum);\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n\\nPlease do upvote it !! if you find useful.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        vector<int> ans;\\n        int sum;\\n        for(int i=1;i<=9;i++)\\n        {\\n            sum=0;\\n            for(int j=i;j<=9;j++)\\n            {\\n               sum=sum*10+j;   \\n                if(sum>=low&&sum<=high)\\n                {\\n                    ans.push_back(sum);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 853545,
                "title": "java-0ms-beats-100-try-this-for-fun-using-substring-of-123456789",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        String s = \"123456789\";\\n        List<Integer> ans = new ArrayList();\\n        for(int i = 2; i < 10; ++i) {\\n            for(int j = 0; i + j < 10; ++j) {\\n                int t = Integer.parseInt(s.substring(j, i + j));\\n                // System.out.println(t);\\n                if(t >= low) {\\n                    if(t <= high) {\\n                        ans.add(t);\\n                    } else {\\n                        return ans;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nI was planning to use [12,23,34,45,.......,123456789]. But i was too lazy to print those thing out. So I decided to use the substring.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        String s = \"123456789\";\\n        List<Integer> ans = new ArrayList();\\n        for(int i = 2; i < 10; ++i) {\\n            for(int j = 0; i + j < 10; ++j) {\\n                int t = Integer.parseInt(s.substring(j, i + j));\\n                // System.out.println(t);\\n                if(t >= low) {\\n                    if(t <= high) {\\n                        ans.add(t);\\n                    } else {\\n                        return ans;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710951,
                "title": "java-just-generate-them-all-0ms",
                "content": "We can generate all the numbers from 2 digits to 3 digits to 4 digits ...\\n- `t` means the number of times we are going to loop this layer (i.e. 12, 23, .., 89 -> `t = 8`, 123, 234, ..., 789 -> `t = 7`). Decrement `t` by 1 each loop.\\n- `inc` is the distance between 2 valid numbers and is always 11 or 111 or 1111 depending on num of digits. Set `inc` to `10 * inc + 1` each loop.\\n- `start` marks the starting point of each digit: 1, 12, 123, e.g. 1 + 11(inc) = 12, 12 + 111(inc) = 123. Set `start` to `10 * start + 10 - t` each loop.\\n- `cur` is our current number.\\n```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int start = 1, cur = 1, inc = 11, t = 8;\\n        List<Integer> ans = new ArrayList<>();\\n        while(cur <= high){\\n            for (int i = 0; i < t; i++){\\n                cur += inc;\\n                if (cur >= low && cur <= high) ans.add(cur);\\n            }\\n            inc = 10 * inc + 1;\\n            start = 10 * start + 10 - t;\\n            cur = start;\\n            t--;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int start = 1, cur = 1, inc = 11, t = 8;\\n        List<Integer> ans = new ArrayList<>();\\n        while(cur <= high){\\n            for (int i = 0; i < t; i++){\\n                cur += inc;\\n                if (cur >= low && cur <= high) ans.add(cur);\\n            }\\n            inc = 10 * inc + 1;\\n            start = 10 * start + 10 - t;\\n            cur = start;\\n            t--;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710992,
                "title": "python3-log10-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe main observation here is that all numbers in the result can be formed from the simple tuple `(1, 2, 3, 4, 5, 6, 7, 8, 9)` using a sliding window. What windows we should use? The range of window widths can be derived from the input `low` and `high`. Since the resulting numbers should be in the range `[low, high]`, the minimum window width should be equal to the number of digits in the `low` and the maximum to the number of digits in the `high`. The formula for the number of digits in the positive integer is `floor(log10(n))+1`. \\n\\nSo our algorithm iterates over all possible window widths and, for every window, slides it over the digits `(1, 2, ...)` forming numbers for the result. Every number must be checked for occurrence in the interval `[low, high]`. For example, if we have `low=199` and `high=200` the algorithm will form numbers like `123, 234, 345, 456, 567, 678, 789` which are all out of the range.\\n\\nTime: **O(log10(N))** - scan\\nSpace: **O(1)** - nothing stored\\n\\nRuntime: 32 ms, faster than **62.30%** of Python3 online submissions for Sequential Digits.\\nMemory Usage: 14.2 MB, less than **80.16%** of Python3 online submissions for Sequential Digits.\\n\\n```\\ndef sequentialDigits(self, low: int, high: int) -> List[int]:\\n\\tres = list()\\n\\n\\tfor window in range(floor(log10(low)) + 1, floor(log10(high)) + 2):\\n\\t\\tfor start in range(10 - window):\\n\\t\\t\\tnumber = 0\\n\\t\\t\\tfor i in range(start, start + window):\\n\\t\\t\\t\\tnumber = number * 10 + i + 1\\n\\n\\t\\t\\tif low <= number <= high: \\n\\t\\t\\t\\tres.append(number)\\n\\n\\treturn res\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\ndef sequentialDigits(self, low: int, high: int) -> List[int]:\\n\\tres = list()\\n\\n\\tfor window in range(floor(log10(low)) + 1, floor(log10(high)) + 2):\\n\\t\\tfor start in range(10 - window):\\n\\t\\t\\tnumber = 0\\n\\t\\t\\tfor i in range(start, start + window):\\n\\t\\t\\t\\tnumber = number * 10 + i + 1\\n\\n\\t\\t\\tif low <= number <= high: \\n\\t\\t\\t\\tres.append(number)\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1710937,
                "title": "bfs-solution-in-python-time-o-1-space-o-1",
                "content": "start from 1 ~ 9, and then increase by multiplying by 10 and adding last_num + 1. (last_num = num % 10)\\n\\nIn this solution, you don\\'t even need to sort at the end.\\n\\n**Time: O(1)**, since you need to check at most `81` values. `(Start num: 1 ~ 9) * (At most 9 digits) = 81`\\n**Space: O(1)**, since you store at most `9` numbers in the queue.\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        queue = deque(range(1, 10))\\n        res = []\\n        while queue:\\n            u = queue.popleft()\\n            if low <= u <= high:\\n                res.append(u)\\n            elif high < u:\\n                continue\\n                \\n            last_num = u % 10\\n            if last_num != 9:\\n                queue.append(u * 10 + last_num + 1)\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        queue = deque(range(1, 10))\\n        res = []\\n        while queue:\\n            u = queue.popleft()\\n            if low <= u <= high:\\n                res.append(u)\\n            elif high < u:\\n                continue\\n                \\n            last_num = u % 10\\n            if last_num != 9:\\n                queue.append(u * 10 + last_num + 1)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713794,
                "title": "c-0ms-100-fast-very-easy-bfs-approach-intuitive-without-sorting",
                "content": "**Intuition :** We will only check for the possible numbers. In order to maintain the ascending order of the numbers we will will check the numbers with lesser number of digits first and then we will proceed for next level with higher number of digits. while pushing numbers for next level we will follow the same order of queue which will help to maintain the lexicographical order in same level.\\n\\n**Approach :** We will iterate through all the values with same number of digits at one level and push them into result if it is in range and we will append the number after the last digit to end , to be checked on next level.\\nwe will break the loop whenever we reach digit 9 because no digit can be placed after that.\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        vector<int> res;\\n\\n        queue<int> q;\\n        \\n\\t\\t//push initial numbers in lexicographical order\\n        for(int i = 1; i <= 9; i++)\\n        {\\n            q.push(i);\\n        }\\n        \\n\\t\\t// loop till any valid number isn\\'t left\\n        while(!q.empty())\\n        {\\n            int num = q.front();\\n            q.pop();\\n            \\n            int last = num % 10;\\n            int next = (num * 10) + (last + 1);\\n            \\n            if(num >= low) // high value is checked while pushing into queue\\n            {\\n                res.push_back(num);\\n            }\\n            \\n            if(last != 9 && next <= high) // checking last != 9 as it may lead next number as 10 \\n            {\\n                q.push(next);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```\\n\\nPlease upvote if you liked the approach.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        vector<int> res;\\n\\n        queue<int> q;\\n        \\n\\t\\t//push initial numbers in lexicographical order\\n        for(int i = 1; i <= 9; i++)\\n        {\\n            q.push(i);\\n        }\\n        \\n\\t\\t// loop till any valid number isn\\'t left\\n        while(!q.empty())\\n        {\\n            int num = q.front();\\n            q.pop();\\n            \\n            int last = num % 10;\\n            int next = (num * 10) + (last + 1);\\n            \\n            if(num >= low) // high value is checked while pushing into queue\\n            {\\n                res.push_back(num);\\n            }\\n            \\n            if(last != 9 && next <= high) // checking last != 9 as it may lead next number as 10 \\n            {\\n                q.push(next);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455268,
                "title": "python3-simple-20-ms",
                "content": "```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        answer=[]\\n        for i in range(1,10):\\n            number=i\\n            next=i\\n            while(number<=high and next<10):\\n                if number>=low:\\n                    answer.append(number)\\n                next=next+1\\n                number=number*10+next\\n        return sorted(answer)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        answer=[]\\n        for i in range(1,10):\\n            number=i\\n            next=i\\n            while(number<=high and next<10):\\n                if number>=low:\\n                    answer.append(number)\\n                next=next+1\\n                number=number*10+next\\n        return sorted(answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711053,
                "title": "c-100-fast-easy-solution-explained-o-1-philosophy",
                "content": "**Welcome to abivilion\\'s solution. Kindly upvote for more support !**\\n\\n## ***Philosophy***\\n\\n```\\n    Sliding Window Technique\\n\\n    1. In this question I have two limits lower and upper .And both of the limit should be considered according to the digit each have\\n\\n    For eg;\\n    100 -> 3 digit\\n    300 -> 3 digit\\n\\n    2. Then, I think which type of digit can come in each index, that is 1-9.\\n\\n    3. Thats range is constant so create an array filled with 1-9 digit. And traverse according to lower limit digit & according to the upper limit digit treating NO.OF DIGITS as a window which will Traversed throughout the array.\\n\\n    4. Keep inserting all number in the sliding window of lower/upper in the SEPERATE vec and IF any number is greater than or smaller than GIVEN LIMTIS. break the loop.\\n\\n    5. return vec\\n\\n```\\n\\n\\n**SOLUTION**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n  \\nvector<int> res;        \\nstring dig =\"123456789\";\\n\\nint lowst=to_string(low).size(); // preparing for window size\\nint upst=to_string(high).size();\\n\\n        \\nfor(int i=lowst;i<=upst;i++) // loop on size\\n{ \\n\\nfor(int j=0;j<10-i;j++)\\n{\\nint num =stoi(dig.substr(j,i));\\n\\nif(num>=low && num<=high) res.push_back(num);\\n\\n}\\n}\\n\\n\\nreturn res;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    Sliding Window Technique\\n\\n    1. In this question I have two limits lower and upper .And both of the limit should be considered according to the digit each have\\n\\n    For eg;\\n    100 -> 3 digit\\n    300 -> 3 digit\\n\\n    2. Then, I think which type of digit can come in each index, that is 1-9.\\n\\n    3. Thats range is constant so create an array filled with 1-9 digit. And traverse according to lower limit digit & according to the upper limit digit treating NO.OF DIGITS as a window which will Traversed throughout the array.\\n\\n    4. Keep inserting all number in the sliding window of lower/upper in the SEPERATE vec and IF any number is greater than or smaller than GIVEN LIMTIS. break the loop.\\n\\n    5. return vec\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n  \\nvector<int> res;        \\nstring dig =\"123456789\";\\n\\nint lowst=to_string(low).size(); // preparing for window size\\nint upst=to_string(high).size();\\n\\n        \\nfor(int i=lowst;i<=upst;i++) // loop on size\\n{ \\n\\nfor(int j=0;j<10-i;j++)\\n{\\nint num =stoi(dig.substr(j,i));\\n\\nif(num>=low && num<=high) res.push_back(num);\\n\\n}\\n}\\n\\n\\nreturn res;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853884,
                "title": "sequential-digits-c-two-solutions-o-1-time-and-space",
                "content": "There is only a certain amount of such numbers. Note in the description says that they are 2 digit numbers at least.\\nThe maximum number to have all sequential digits is with nine digits - ```123456789```\\nTherefore, both solutions have time and space complexity of: ```O(1)```\\n\\n<b>Solution 1</b>\\n```\\nclass Solution {\\nprivate:\\n    vector<int> seqDigits = {\\n        12, 23, 34, 45, 56, 67, 78, 89,\\n        123, 234, 345, 456, 567, 678, 789,\\n        1234, 2345, 3456, 4567, 5678, 6789,\\n        12345, 23456, 34567, 45678, 56789,\\n        123456, 234567, 345678, 456789,\\n        1234567, 2345678, 3456789,\\n        12345678, 23456789,\\n        123456789\\n    };\\n\\n    \\npublic:\\n\\tvector<int> sequentialDigits(int low, int high) {\\n\\t\\tvector<int> seqDigitsInRange;\\n        for (int n : seqDigits) { // Just check which numbers from the list fit the given range\\n            if (n > high)\\n                break;\\n\\n            if (n >= low)\\n                seqDigitsInRange.push_back(n);\\n        }\\n        return seqDigitsInRange;\\n\\t}\\n};\\n```\\n<b>Solution 2</b>\\n```\\nclass Solution { // Time and Space: O(1)\\npublic:\\n\\tvector<int> sequentialDigits(int low, int high) {\\n\\t\\tvector<int> seqDigitsInRange;\\n        \\n        // Create all numbers with sequential digits and compare if they fit the given range\\n        for (int i = 1; i < 9; i++) { // Runs 8 times\\n            int number = i;\\n            for (int j = i + 1; j < 10; j++) { // Runs maximum 8 times\\n                number = number * 10 + j;\\n                if (number >= low && number <= high)\\n                    seqDigitsInRange.push_back(number);\\n            }\\n        }\\n        sort(seqDigitsInRange.begin(), seqDigitsInRange.end()); // Result is required to be sorted\\n        return seqDigitsInRange;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```123456789```\n```O(1)```\n```\\nclass Solution {\\nprivate:\\n    vector<int> seqDigits = {\\n        12, 23, 34, 45, 56, 67, 78, 89,\\n        123, 234, 345, 456, 567, 678, 789,\\n        1234, 2345, 3456, 4567, 5678, 6789,\\n        12345, 23456, 34567, 45678, 56789,\\n        123456, 234567, 345678, 456789,\\n        1234567, 2345678, 3456789,\\n        12345678, 23456789,\\n        123456789\\n    };\\n\\n    \\npublic:\\n\\tvector<int> sequentialDigits(int low, int high) {\\n\\t\\tvector<int> seqDigitsInRange;\\n        for (int n : seqDigits) { // Just check which numbers from the list fit the given range\\n            if (n > high)\\n                break;\\n\\n            if (n >= low)\\n                seqDigitsInRange.push_back(n);\\n        }\\n        return seqDigitsInRange;\\n\\t}\\n};\\n```\n```\\nclass Solution { // Time and Space: O(1)\\npublic:\\n\\tvector<int> sequentialDigits(int low, int high) {\\n\\t\\tvector<int> seqDigitsInRange;\\n        \\n        // Create all numbers with sequential digits and compare if they fit the given range\\n        for (int i = 1; i < 9; i++) { // Runs 8 times\\n            int number = i;\\n            for (int j = i + 1; j < 10; j++) { // Runs maximum 8 times\\n                number = number * 10 + j;\\n                if (number >= low && number <= high)\\n                    seqDigitsInRange.push_back(number);\\n            }\\n        }\\n        sort(seqDigitsInRange.begin(), seqDigitsInRange.end()); // Result is required to be sorted\\n        return seqDigitsInRange;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679827,
                "title": "faster-than-100-of-c-submissions-have-a-look",
                "content": "```\\nclass Solution {\\n    set<int> ans;\\n    \\n    void backtrack(int low,int high,int idx)\\n    {\\n       if(idx>9) return;\\n        \\n       long long res=0;\\n        \\n        for(int i=idx;i<=9;i++)\\n        {\\n            res=res*10+i;\\n            if(res>=low&&res<=high)\\n            ans.insert(res);\\n        }\\n        \\n        backtrack(low,high,idx+1);\\n    }\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        backtrack(low,high,0);\\n        vector<int> res;\\n        \\n        for(auto it=ans.begin();it!=ans.end();it++)\\n            res.push_back(*it);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    set<int> ans;\\n    \\n    void backtrack(int low,int high,int idx)\\n    {\\n       if(idx>9) return;\\n        \\n       long long res=0;\\n        \\n        for(int i=idx;i<=9;i++)\\n        {\\n            res=res*10+i;\\n            if(res>=low&&res<=high)\\n            ans.insert(res);\\n        }\\n        \\n        backtrack(low,high,idx+1);\\n    }\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        backtrack(low,high,0);\\n        vector<int> res;\\n        \\n        for(auto it=ans.begin();it!=ans.end();it++)\\n            res.push_back(*it);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773807,
                "title": "c-soln-xd",
                "content": "\\n```\\nvector<int> sequentialDigits(int low, int high) \\n    {\\n        vector<int>ans;\\n        vector<int>all = {12, 23, 34, 45, 56, 67, 78, 89,\\n                          123, 234, 345, 456, 567, 678, 789,\\n                          1234, 2345, 3456, 4567, 5678, 6789,\\n                          12345, 23456, 34567, 45678, 56789,\\n                          123456, 234567, 345678, 456789,\\n                          1234567, 2345678, 3456789,\\n                          12345678, 23456789,\\n                          123456789};\\n        for(auto &p : all)\\n        {\\n            if(low <= p && p <= high)\\n                ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> sequentialDigits(int low, int high) \\n    {\\n        vector<int>ans;\\n        vector<int>all = {12, 23, 34, 45, 56, 67, 78, 89,\\n                          123, 234, 345, 456, 567, 678, 789,\\n                          1234, 2345, 3456, 4567, 5678, 6789,\\n                          12345, 23456, 34567, 45678, 56789,\\n                          123456, 234567, 345678, 456789,\\n                          1234567, 2345678, 3456789,\\n                          12345678, 23456789,\\n                          123456789};\\n        for(auto &p : all)\\n        {\\n            if(low <= p && p <= high)\\n                ans.push_back(p);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 853837,
                "title": "java-generating-all-valid-numbers-in-order-o-1-space-no-sorting-0ms",
                "content": "I see that many people have to sort the result in the end. **But it is not needed**. You can simply generate all valid numbers in order.\\n\\nIf you look at provided test cases, you can notice that two consecutive valid numbers always have the similar difference. The difference contains only ones (1).\\nFor instance:\\n*23 - 12 = 11\\n34 -23 = 11\\n...\\n234 - 123 = 111\\n345 - 234 = 111\\n...\\n45678 - 34567 = 11111*\\n\\nThe only exception to this rule is when the number of digits changes: like 89 and 123. But you can see that in this case the first valid number that contains 3 digits (123) is equal to the first valid number that contains 2 digits (12) with appended sequential digit (3). So we can handle this case separately.\\n\\n**The solution is simple**:\\n1. Maintain the ```base``` , ```delta``` (that represent the first valid number containing N digits and a delta containing N ones respectively) and the current number ```n``` initially set to ```base```. \\n2. On each iteration add ```delta``` to the current number. If the number of digits changes, change  the ```base``` and ```delta``` and repeat. \\n\\n```\\npublic List<Integer> sequentialDigits(int low, int high) {\\n    List<Integer> result = new ArrayList<>();\\n    int base = 0, delta = 0;\\n    int n = base;\\n    while (n <= high) {\\n        if (n >= low) {\\n            result.add(n);   \\n        }\\n        n += delta;\\n        if (n % 10 == 0) { // number of digits changed\\n            base = base * 10 + (base % 10 + 1);\\n            delta = delta * 10 + 1;\\n            n = base;\\n        }\\n    }\\n\\n    return result;\\n}\\n```\\n\\nP.S. You can optimize this solution a bit by finding the first valid number that is bigger or equal to ```low``` before the main loop starts (just count the number of digits in ```low``` in the loop and simultaneously change ```base``` and ```delta```). But in this case the code is a bit longer and may be harder to read.\\n**Upvote** if you like the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```base```\n```delta```\n```n```\n```base```\n```delta```\n```base```\n```delta```\n```\\npublic List<Integer> sequentialDigits(int low, int high) {\\n    List<Integer> result = new ArrayList<>();\\n    int base = 0, delta = 0;\\n    int n = base;\\n    while (n <= high) {\\n        if (n >= low) {\\n            result.add(n);   \\n        }\\n        n += delta;\\n        if (n % 10 == 0) { // number of digits changed\\n            base = base * 10 + (base % 10 + 1);\\n            delta = delta * 10 + 1;\\n            n = base;\\n        }\\n    }\\n\\n    return result;\\n}\\n```\n```low```\n```low```\n```base```\n```delta```",
                "codeTag": "Unknown"
            },
            {
                "id": 853662,
                "title": "backtracking-cpp-0-ms",
                "content": "I have seen multiple solutions, lemme just add one more. :) \\nWe can just generate all possible candidates using backtracking and add the ones which are in range of low <= num <= high.\\n\\n```\\nclass Solution {\\npublic:\\n    void backtrack(vector<int> &v, int low, int high, int num) {\\n\\t\\tint exp = log10(num), highestDigit = num / pow(10, exp); // if num = 23456 we want the highestDigit i.e 2 \\n        if (num % 10 < 9) {\\n            num = num * 10 + (num % 10) + 1;\\n            if (num >= low && num <= high)\\n                v.push_back(num);\\n            backtrack(v, low, high, num);\\n        }\\n        else if (highestDigit < 9) { // if the last digit is 9 for example 1234569, then we can proceed to 23456789\\n            backtrack(v, low, high, highestDigit + 1);\\n        }\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> v;\\n        backtrack(v, low, high, 1);\\n        sort(begin(v), end(v));\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(vector<int> &v, int low, int high, int num) {\\n\\t\\tint exp = log10(num), highestDigit = num / pow(10, exp); // if num = 23456 we want the highestDigit i.e 2 \\n        if (num % 10 < 9) {\\n            num = num * 10 + (num % 10) + 1;\\n            if (num >= low && num <= high)\\n                v.push_back(num);\\n            backtrack(v, low, high, num);\\n        }\\n        else if (highestDigit < 9) { // if the last digit is 9 for example 1234569, then we can proceed to 23456789\\n            backtrack(v, low, high, highestDigit + 1);\\n        }\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> v;\\n        backtrack(v, low, high, 1);\\n        sort(begin(v), end(v));\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712222,
                "title": "c-0-ms-solution-easy-solution-with-simple-approach",
                "content": "**My approach :**\\n\\n1. Initially we **generate all the sequences** using the custom `generate()` function\\n2. Then we **push all the numbers** into `ans` vector which **lies in between `low` and `high` values**\\n\\n**Explanation :**\\n\\t\\tThe sequence for 2 digit numbers is --> 12 , 23 , 34, 45 , 56, 67, 78, 89\\n\\n\\t\\twhich can be seen as  12 + 11 = 23\\n\\t\\t\\t\\t\\t\\t\\t  23 + 11 = 34\\n\\t\\t\\t\\t\\t\\t\\t  34 + 11 = 45\\n\\t\\t\\t\\t\\t\\t\\t  .....\\n\\t\\tsimilarly for 3 digit numbers, base value = 123 and increment = 111\\n\\t\\t\\t\\t  for 4 digit numbers, base value = 1234 and increment = 1111\\n\\t\\tand so on..\\n\\t\\n**Condition to stop :**\\nThe last number in any digit sequence will contain the last digit as 9\\ne.g : 89, 789, 6789.... 123456789\\n\\nso on adding 1 with 9 will give us 0. This will be our termination condition for our loop\\ni.e., we loop it  till **`number%10 != 0`**\\n\\t\\t\\n**C++ solution :**\\n```\\nclass Solution {\\npublic:\\n\\t// generating the sequence\\n    void generate(int start, int inc,vector<int>& sequence){\\n        while(start%10!=0){\\n            sequence.push_back(start);\\n            start += inc;\\n        }\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n\\t\\t// starts indicates the initial values of the digits\\n\\t\\t// increments indicates the corresponding increment values for the start values of respective digits\\n        vector<int> starts = {12,123,1234,12345,123456,1234567,12345678};\\n        vector<int> increments = {11,111,1111,11111,111111,1111111,11111111};\\n\\t\\t\\n\\t\\t// we will store the sequence in the sequence vector\\n        vector<int> sequence;\\n\\t\\t\\n        for(int i = 0; i < increments.size(); i++){\\n            generate(starts[i],increments[i],sequence);\\n        }\\n\\t\\t\\n        vector<int> ans;\\n        for(int i = 0; i < sequence.size(); i++){\\n            if(sequence[i]>= low and sequence[i]<=high)\\n                ans.push_back(sequence[i]);\\n        }\\n\\t\\t\\n\\t\\t// The  start vector contains upto 8 digits only\\n\\t\\t// so we are checking for the 9 digit also and only 123456789 satisfies the sequence\\n        if(123456789<=high and 123456789>=low)\\n            ans.push_back(123456789);\\n\\t\\t\\t\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote if you like it ; )**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// generating the sequence\\n    void generate(int start, int inc,vector<int>& sequence){\\n        while(start%10!=0){\\n            sequence.push_back(start);\\n            start += inc;\\n        }\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n\\t\\t// starts indicates the initial values of the digits\\n\\t\\t// increments indicates the corresponding increment values for the start values of respective digits\\n        vector<int> starts = {12,123,1234,12345,123456,1234567,12345678};\\n        vector<int> increments = {11,111,1111,11111,111111,1111111,11111111};\\n\\t\\t\\n\\t\\t// we will store the sequence in the sequence vector\\n        vector<int> sequence;\\n\\t\\t\\n        for(int i = 0; i < increments.size(); i++){\\n            generate(starts[i],increments[i],sequence);\\n        }\\n\\t\\t\\n        vector<int> ans;\\n        for(int i = 0; i < sequence.size(); i++){\\n            if(sequence[i]>= low and sequence[i]<=high)\\n                ans.push_back(sequence[i]);\\n        }\\n\\t\\t\\n\\t\\t// The  start vector contains upto 8 digits only\\n\\t\\t// so we are checking for the 9 digit also and only 123456789 satisfies the sequence\\n        if(123456789<=high and 123456789>=low)\\n            ans.push_back(123456789);\\n\\t\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710955,
                "title": "0-ms-java-100-faster-easy-explaination-with-comments",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) { // Idea is to generate every valid number in the given range and adding it in the list\\n        List<Integer> list =  new ArrayList<>();\\n        int number = 12;  // Initial smallest valid number\\n        int nextdigit=3;   // next digit of the valid number eg 123\\n        while(number<90){\\n            int counter = number;  // counter number for computation\\n            int counterdigit = nextdigit;\\n            while(counter <= high && counterdigit < 11){\\n                if(counter >= low) list.add(counter);\\n                counter = counter*10 + counterdigit;\\n                counterdigit++;\\n            }\\n            number+=11;  // every valid number will start with 12,23,34,45 and so on, the difference is always 11.\\n            nextdigit++;\\n        }\\n        Collections.sort(list);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) { // Idea is to generate every valid number in the given range and adding it in the list\\n        List<Integer> list =  new ArrayList<>();\\n        int number = 12;  // Initial smallest valid number\\n        int nextdigit=3;   // next digit of the valid number eg 123\\n        while(number<90){\\n            int counter = number;  // counter number for computation\\n            int counterdigit = nextdigit;\\n            while(counter <= high && counterdigit < 11){\\n                if(counter >= low) list.add(counter);\\n                counter = counter*10 + counterdigit;\\n                counterdigit++;\\n            }\\n            number+=11;  // every valid number will start with 12,23,34,45 and so on, the difference is always 11.\\n            nextdigit++;\\n        }\\n        Collections.sort(list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672159,
                "title": "simple-strings-solution-beats-100-time",
                "content": "Step 1 create a dictionary of longest consecutive no.\\nstep 2 generate all substrings of length of low to high\\nstep 3 store it in a set so that data is sorted by deafult and redundant entries don\\'t come.\\nstep 4 filter as per requirment that no should be low<= no. in ans <= high\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high)\\n    {\\n        int start_len,end_len; // to have length of low and high integers\\n        string s=\"123456789\";  // ultimate dictionary\\n        start_len=to_string(low).length();\\n        end_len=to_string(high).length();\\n        int i,j;\\n        set<int> temp; //to get sorted data\\n        for(i=0;i<=s.length()-start_len;i++)  // outer loop manages the start index of substring\\n        {\\n            for(j=start_len;j<=end_len;j++) // inner loop manages the substring length from l to e;\\n            {\\n                temp.insert(stoi(s.substr(i,j)));  // convert direct so total T.C = O((9-start_len)*(end_len-start_len))\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        for(auto x : temp)\\n        {\\n            if(x>=low && x<=high)  //standard check condition\\n            {\\n                ans.push_back(x);\\n            }\\n            else if(ans.size()>0)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high)\\n    {\\n        int start_len,end_len; // to have length of low and high integers\\n        string s=\"123456789\";  // ultimate dictionary\\n        start_len=to_string(low).length();\\n        end_len=to_string(high).length();\\n        int i,j;\\n        set<int> temp; //to get sorted data\\n        for(i=0;i<=s.length()-start_len;i++)  // outer loop manages the start index of substring\\n        {\\n            for(j=start_len;j<=end_len;j++) // inner loop manages the substring length from l to e;\\n            {\\n                temp.insert(stoi(s.substr(i,j)));  // convert direct so total T.C = O((9-start_len)*(end_len-start_len))\\n            }\\n            \\n        }\\n        vector<int> ans;\\n        for(auto x : temp)\\n        {\\n            if(x>=low && x<=high)  //standard check condition\\n            {\\n                ans.push_back(x);\\n            }\\n            else if(ans.size()>0)\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491677,
                "title": "javascript-sliding-window",
                "content": "```\\nvar sequentialDigits = function(low, high) {\\n    const digits = \\'123456789\\';\\n    const ans = [];\\n    \\n    const minLen = low.toString().length;\\n    const maxLen = high.toString().length;\\n    \\n    for (let windowSize = minLen; windowSize <= maxLen; ++windowSize) {\\n        for (let i = 0; i + windowSize <= digits.length; ++i) {\\n            const num = parseInt(digits.substring(i, i + windowSize));\\n            \\n            if (num >= low && num <= high) {\\n                ans.push(num);\\n            }\\n        }\\n    }\\n    \\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar sequentialDigits = function(low, high) {\\n    const digits = \\'123456789\\';\\n    const ans = [];\\n    \\n    const minLen = low.toString().length;\\n    const maxLen = high.toString().length;\\n    \\n    for (let windowSize = minLen; windowSize <= maxLen; ++windowSize) {\\n        for (let i = 0; i + windowSize <= digits.length; ++i) {\\n            const num = parseInt(digits.substring(i, i + windowSize));\\n            \\n            if (num >= low && num <= high) {\\n                ans.push(num);\\n            }\\n        }\\n    }\\n    \\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454893,
                "title": "javascript-easy-to-understand-3-solutions",
                "content": "### SOLUTION 1\\n\\nAt first, we try to solve it via a straightforward way.\\n\\nSo, I guess we need a function to get a sequential digit. I use start number and length as the arguments for this function. And here\\'s the code:\\n\\n```js\\nconst makeNum = (start, len) => {\\n  let val = start;\\n  while (--len) {\\n    val = val * 10 + ++start;\\n  }\\n  return val;\\n};\\n```\\n\\nAfter we have this function, we need to find out all possible start number and length.\\n\\nAccording to the constraints of the description, the range of `low` and `high` is `[10, 10^9]` which means the range of length is `[2, 9]`.\\n\\nThen for the start number, at least it should be in `[1, 9]`. But we could make it more accurate because the max start number for length `len` should be `10 - len` which means the range is `[1, 10 - len]`.\\n\\nAt this moment, I think we could get the code easily such as:\\n\\n```js\\nconst sequentialDigits = (low, high) => {\\n  const ret = [];\\n  for (let len = 2; len <= 9; ++len) {\\n    for (let pre = 1; pre <= 10 - len; ++pre) {\\n      const val = makeNum(pre, len);\\n      val <= high && val >= low && ret.push(val);\\n    }\\n  }\\n  return ret;\\n};\\n```\\n\\nThis strategy would work right now. But could we optimize the loop a little? Maybe make the outer loop more precise.\\n\\nActually, we could get the length of `low` and `high` which means we don\\'t need to check all number length less than `low` and more than `high`. So, here\\'s the code:\\n\\n```js\\nconst sequentialDigits = (low, high) => {\\n  let lowLen = highLen = 0;\\n  for (let curLow = low; curLow > 0; ++lowLen) {\\n    curLow = curLow / 10 << 0;\\n  }\\n  for (let curHigh = high; curHigh > 0; ++highLen) {\\n    curHigh = curHigh / 10 << 0;\\n  }\\n\\n  const ret = [];\\n  for (let len = lowLen; len <= highLen; ++len) {\\n    for (let pre = 1; pre <= 10 - len; ++pre) {\\n      const val = makeNum(pre, len);\\n      val <= high && val >= low && ret.push(val);\\n    }\\n  }\\n  return ret;\\n};\\n```\\n\\n### SOLUTION 2\\n\\nThe core logic of  this strategy is similar to solution 1. But we don\\'t need a function to generate the target number everty time. Instead, we save the possible prefix in a queue for further using. This will save time in generate number, but use more extra space.\\n\\nSince the possible numbers are in a queue and we loop it round by round, so it\\'s more like a BFS strategy.\\n\\n```js\\nconst sequentialDigits = (low, high) => {\\n  const queue = [1, 2, 3, 4, 5, 6, 7, 8, 9];\\n  const ret = [];\\n  for (let idx = 0; idx < queue.length; ++idx) {\\n    const cur = queue[idx];\\n    const last = cur % 10;\\n    if (last === 9) continue;\\n    const next = cur * 10 + last + 1;\\n    if (next > high) continue;\\n    next >= low && ret.push(next);\\n    queue.push(next);\\n  }\\n  return ret;\\n};\\n```\\n\\n### SOLUTION 3\\n\\nI must say I got this strategy from [this post](https://leetcode.com/problems/sequential-digits/discuss/451851/Java-Just-a-joke) and in Chinese we call it \"\\u6253\\u8868\\u6CD5\". This means we enumerate all possible numbers according to the constraints at first, and then check them with the input arguments.\\n\\nThis strategy is very suits the problems whose logic may not simple but the count of answer is small.\\n\\n```js\\nconst NUMS = [\\n  12,23,34,45,56,67,78,89,\\n  123,234,345,456,567,678,789,\\n  1234,2345,3456,4567,5678,6789,\\n  12345,23456,34567,45678,56789,\\n  123456,234567,345678,456789,\\n  1234567,2345678,3456789,\\n  12345678,23456789,\\n  123456789\\n];\\nconst sequentialDigits = (low, high) => {\\n  const ret = [];\\n  for (let i = 0; i < NUMS.length; ++i) {\\n    if (NUMS[i] > high) break;\\n    NUMS[i] >= low && ret.push(NUMS[i]);\\n  }\\n  return ret;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst makeNum = (start, len) => {\\n  let val = start;\\n  while (--len) {\\n    val = val * 10 + ++start;\\n  }\\n  return val;\\n};\\n```\n```js\\nconst sequentialDigits = (low, high) => {\\n  const ret = [];\\n  for (let len = 2; len <= 9; ++len) {\\n    for (let pre = 1; pre <= 10 - len; ++pre) {\\n      const val = makeNum(pre, len);\\n      val <= high && val >= low && ret.push(val);\\n    }\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst sequentialDigits = (low, high) => {\\n  let lowLen = highLen = 0;\\n  for (let curLow = low; curLow > 0; ++lowLen) {\\n    curLow = curLow / 10 << 0;\\n  }\\n  for (let curHigh = high; curHigh > 0; ++highLen) {\\n    curHigh = curHigh / 10 << 0;\\n  }\\n\\n  const ret = [];\\n  for (let len = lowLen; len <= highLen; ++len) {\\n    for (let pre = 1; pre <= 10 - len; ++pre) {\\n      const val = makeNum(pre, len);\\n      val <= high && val >= low && ret.push(val);\\n    }\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst sequentialDigits = (low, high) => {\\n  const queue = [1, 2, 3, 4, 5, 6, 7, 8, 9];\\n  const ret = [];\\n  for (let idx = 0; idx < queue.length; ++idx) {\\n    const cur = queue[idx];\\n    const last = cur % 10;\\n    if (last === 9) continue;\\n    const next = cur * 10 + last + 1;\\n    if (next > high) continue;\\n    next >= low && ret.push(next);\\n    queue.push(next);\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst NUMS = [\\n  12,23,34,45,56,67,78,89,\\n  123,234,345,456,567,678,789,\\n  1234,2345,3456,4567,5678,6789,\\n  12345,23456,34567,45678,56789,\\n  123456,234567,345678,456789,\\n  1234567,2345678,3456789,\\n  12345678,23456789,\\n  123456789\\n];\\nconst sequentialDigits = (low, high) => {\\n  const ret = [];\\n  for (let i = 0; i < NUMS.length; ++i) {\\n    if (NUMS[i] > high) break;\\n    NUMS[i] >= low && ret.push(NUMS[i]);\\n  }\\n  return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 879654,
                "title": "java-100-speed-0ms-99-91-memory-explained-very-simple",
                "content": "So the logic for the program that I went with was damn easy.\\nSteps:\\n1. You declare the int :123456789. Now as you can see, this int already has all the permuations of sequential numbers possible, i.e, you can extract any part of the number and it would be sequential.\\n2. You loop from the length of the lower limit to length of the upper limit.\\n3. You take out the parts of the required lengths from the number and check if its in the range.\\nThe code is given below:\\n```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high)\\n    {\\n        List<Integer> list=new ArrayList<>();    //declaring a list to store all sequential numbers. \\n        \\n        int s=123456789, len=length(s);    //assuming the mentioned int to be s, and its length to be len\\n        \\n        int lowlen=length(low), highlen=length(high);    //lengths of low and high\\n        \\n        outer:\\n        for(int x=lowlen; x<=highlen; x++)\\n        {\\n            for(int y=0; y<len-x+1; y++)\\n            {\\n                int a=s/(int)Math.pow(10,len-x-y);\\n                a%=(int)Math.pow(10,x);    //this is the final int we want to check if its in the range\\n                if(a>high)\\n                    continue outer;    //to avoid extra iterations\\n                if(a<=high && a>=low)\\n\\t\\t\\t\\t\\tlist.add(a);    //adding the number to the list if its in the range\\n            }\\n        }\\n        return list;    //returning the list\\n    }\\n    int length(int x)    //function to find out the length of the passed int\\n    {\\n        return (int)(Math.log10(x) + 1);\\n        \\n    }\\n}\\n```\\nHope you liked the solution.\\nThank You,\\nDhruvesh Surolia",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high)\\n    {\\n        List<Integer> list=new ArrayList<>();    //declaring a list to store all sequential numbers. \\n        \\n        int s=123456789, len=length(s);    //assuming the mentioned int to be s, and its length to be len\\n        \\n        int lowlen=length(low), highlen=length(high);    //lengths of low and high\\n        \\n        outer:\\n        for(int x=lowlen; x<=highlen; x++)\\n        {\\n            for(int y=0; y<len-x+1; y++)\\n            {\\n                int a=s/(int)Math.pow(10,len-x-y);\\n                a%=(int)Math.pow(10,x);    //this is the final int we want to check if its in the range\\n                if(a>high)\\n                    continue outer;    //to avoid extra iterations\\n                if(a<=high && a>=low)\\n\\t\\t\\t\\t\\tlist.add(a);    //adding the number to the list if its in the range\\n            }\\n        }\\n        return list;    //returning the list\\n    }\\n    int length(int x)    //function to find out the length of the passed int\\n    {\\n        return (int)(Math.log10(x) + 1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853605,
                "title": "c-pure-math-and-loops-no-dp-no-sorting-no-extra-memory",
                "content": "One can note that the next sequential number of the same length can be obtained by adding a sequence of ```1```s to the previous number:\\n```\\n23 = 12 + 11\\n34 = 23 + 11\\n45678 = 34567 + 11111\\n```\\n\\nAnd another fun fact is that the smallest sequential number of the next length can also be obtained by adding a sequence of ```1```s:\\n```\\n123 = 12 + 111\\n1234 = 123 + 1111\\n12345 = 1234 + 11111\\n```\\n\\nSo, the task can be solved in two nested loops:\\n- the outer loop will iterate through the length of the number, producing the smallest sequential number of the given length (12, 123, 1234, 12345, ...)\\n- the inner loop will iterate through all sequential numbers of the given length by adding ```1```s to the smallest candidate.\\nThis way the candidates are already generated in ascending order, so no explicit sorting is required.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> sequentialDigits(int low, int high)\\n    {\\n        vector<int>     result;\\n        int     cand = 1;\\n        int     diff = 1;\\n        for (int len = 2; len < 10; ++len)\\n        {\\n            diff = diff*10 + 1;      // It will be: 11, then 111, then 1111, ...\\n            cand += diff;            // It will be: 12, then 123, then 1234, ...\\n        //  The line above can also be: \"cand = cand*10 + len;\"\\n            int probe = cand;\\n            for (int rest = len; rest < 10; ++rest, probe += diff)\\n            {\\n                if ((probe >= low) && (probe <= high))\\n                    result.push_back(probe);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```1```\n```\\n23 = 12 + 11\\n34 = 23 + 11\\n45678 = 34567 + 11111\\n```\n```1```\n```\\n123 = 12 + 111\\n1234 = 123 + 1111\\n12345 = 1234 + 11111\\n```\n```1```\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> sequentialDigits(int low, int high)\\n    {\\n        vector<int>     result;\\n        int     cand = 1;\\n        int     diff = 1;\\n        for (int len = 2; len < 10; ++len)\\n        {\\n            diff = diff*10 + 1;      // It will be: 11, then 111, then 1111, ...\\n            cand += diff;            // It will be: 12, then 123, then 1234, ...\\n        //  The line above can also be: \"cand = cand*10 + len;\"\\n            int probe = cand;\\n            for (int rest = len; rest < 10; ++rest, probe += diff)\\n            {\\n                if ((probe >= low) && (probe <= high))\\n                    result.push_back(probe);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1115748,
                "title": "c-backtracking-0-ms-easy-solution",
                "content": "**backtracking solution;\\n0 ms Runtime**\\n```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> sequentialDigits(int low, int high) {\\n        for(int i=1;i<10;i++)\\n        dfs(low,high,0,i);\\n        sort(res.begin(),res.end());\\n        return res;\\n    }\\n    void dfs(int low,int high,int tmp,int ind){\\n        if(tmp>=low && tmp<=high){\\n            res.push_back(tmp);\\n        }\\n        if(ind==10 || tmp>=high)\\n            return;\\n        dfs(low,high,tmp*10+ind,ind+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> sequentialDigits(int low, int high) {\\n        for(int i=1;i<10;i++)\\n        dfs(low,high,0,i);\\n        sort(res.begin(),res.end());\\n        return res;\\n    }\\n    void dfs(int low,int high,int tmp,int ind){\\n        if(tmp>=low && tmp<=high){\\n            res.push_back(tmp);\\n        }\\n        if(ind==10 || tmp>=high)\\n            return;\\n        dfs(low,high,tmp*10+ind,ind+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451935,
                "title": "c-0ms-o-1-more-concise-take-on-pre-calculated-11-lines",
                "content": "1.) Generate sequential numbers in an ordered set.\\n2.) Find the upper bound from the low number within the set (next sequential).\\n3.) Find the lower bound from the high number within the set (previous sequential).\\n4.) Return a new vector specifying the first and last iterators from the set.\\n\\nNote: We +/- 1 digit to low and high incase one is already a sequential number.\\n\\n```\\nvector<int> sequentialDigits(int low, int high) {\\n\\tset <int> sequential;\\n    int i=1, j=1, seq=0;\\n    while(i<10) {\\n        seq = seq * 10 + j;\\n        sequential.insert(seq);\\n        if(j==9) { i++; seq=0; j=i;continue;}\\n        j++;\\n    }        \\n    auto firstIter = upper_bound(sequential.begin(), sequential.end(),low-1);\\n    auto lastIter = lower_bound(sequential.begin(), sequential.end(), high+1);\\n    return vector(firstIter, lastIter);\\n}\\n```\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> sequentialDigits(int low, int high) {\\n\\tset <int> sequential;\\n    int i=1, j=1, seq=0;\\n    while(i<10) {\\n        seq = seq * 10 + j;\\n        sequential.insert(seq);\\n        if(j==9) { i++; seq=0; j=i;continue;}\\n        j++;\\n    }        \\n    auto firstIter = upper_bound(sequential.begin(), sequential.end(),low-1);\\n    auto lastIter = lower_bound(sequential.begin(), sequential.end(), high+1);\\n    return vector(firstIter, lastIter);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451890,
                "title": "at-most-36-such-numbers-just-do-brute-force",
                "content": "Spent quite some time thinking about recursion and other ways to generate such numbers. \\nFinally figured out there are at most 36 such numbers. Just brute force!\\n\\n```\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int[] seq = {\\n            12, 23, 34, 45, 56, 67, 78, 89,\\n            123, 234, 345, 456, 567, 678, 789,\\n            1234, 2345, 3456, 4567, 5678, 6789,\\n            12345, 23456, 34567, 45678, 56789,\\n            123456, 234567, 345678, 456789,\\n            1234567, 2345678, 3456789,\\n            12345678, 23456789,\\n            123456789\\n        };\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for (int s : seq) {\\n            if (low <= s && s <= high)\\n                ans.add(s);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int[] seq = {\\n            12, 23, 34, 45, 56, 67, 78, 89,\\n            123, 234, 345, 456, 567, 678, 789,\\n            1234, 2345, 3456, 4567, 5678, 6789,\\n            12345, 23456, 34567, 45678, 56789,\\n            123456, 234567, 345678, 456789,\\n            1234567, 2345678, 3456789,\\n            12345678, 23456789,\\n            123456789\\n        };\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for (int s : seq) {\\n            if (low <= s && s <= high)\\n                ans.add(s);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3062155,
                "title": "java-c-100-solution-sequential-digits",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$ \\n`Loop always start at 1 and eleminate after 9 for all values`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```Java []\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n    void solve(int l,int h,int i,int num)\\n    {\\n        if(num>=l && num <=h)\\n            ans.add(num);\\n        if(num>=h || i>9)\\n            return;\\n        solve(l,h,i+1,num*10+i);\\n    }\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        for(int i=1;i<10;i++)\\n            solve(low,high,i,0);\\n        Collections.sort(ans);\\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void solve(int l,int h,int i,int num)\\n    {\\n        if(num>=l && num <=h)\\n            ans.push_back(num);\\n        if(num>=h || i>9)\\n            return;\\n        solve(l,h,i+1,num*10+i);\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        for(int i=1;i<10;i++)\\n            solve(low,high,i,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion",
                    "Enumeration"
                ],
                "code": "```Java []\\nclass Solution {\\n    List<Integer> ans = new ArrayList<>();\\n    void solve(int l,int h,int i,int num)\\n    {\\n        if(num>=l && num <=h)\\n            ans.add(num);\\n        if(num>=h || i>9)\\n            return;\\n        solve(l,h,i+1,num*10+i);\\n    }\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        for(int i=1;i<10;i++)\\n            solve(low,high,i,0);\\n        Collections.sort(ans);\\n        return ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void solve(int l,int h,int i,int num)\\n    {\\n        if(num>=l && num <=h)\\n            ans.push_back(num);\\n        if(num>=h || i>9)\\n            return;\\n        solve(l,h,i+1,num*10+i);\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        for(int i=1;i<10;i++)\\n            solve(low,high,i,0);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734382,
                "title": "python3-o-1-time-easiest",
                "content": "O(9*9)=O(36) -> O(1)\\n\\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        digits=\"123456789\"\\n        a=[]\\n        for i in range(len(digits)):\\n            for j in range(i+1,len(digits)):\\n                num=int(digits[i:j+1])\\n                if num>=low and num<=high:\\n                    a.append(num)\\n        a.sort()\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        digits=\"123456789\"\\n        a=[]\\n        for i in range(len(digits)):\\n            for j in range(i+1,len(digits)):\\n                num=int(digits[i:j+1])\\n                if num>=low and num<=high:\\n                    a.append(num)\\n        a.sort()\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713664,
                "title": "detailed-explanation-with-examples-using-pen-and-paper-sliding-window-recursion",
                "content": "**Explanation**\\n\\n![image](https://assets.leetcode.com/users/images/9b6430db-81ff-4b9d-ac55-f730ecc023f8_1642960078.7585375.jpeg)\\n\\n\\n**JAVA CODE**\\n\\n1. Sliding Window\\n```\\nclass Solution {\\n   \\n    public List<Integer> sequentialDigits(int low, int high) {\\n        String seqNum = \"123456789\";\\n         List<Integer> list = new ArrayList<>();\\n\\n        int minWindow = String.valueOf(low).length();\\n        int maxWindow = String.valueOf(high).length();\\n        for(;minWindow <= maxWindow; minWindow++){\\n            for(int j = 0; j + minWindow <= 9; j++){\\n                String str = seqNum.substring(j, j + minWindow);\\n                int num = Integer.parseInt(str);\\n                if(num > high) break;\\n                if(low <= num && high >= num){\\n                    list.add(num);\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n\\n}\\n```\\n2. Recursion\\n```\\nclass Solution {\\n    List<Integer> list;\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        list = new ArrayList<>();\\n        //check combination from using 1 - 9\\n        combinations(low, high);\\n        Collections.sort(list);\\n        return list;\\n    }\\n    private void combinations(int low, int high){\\n        for(int i = 1; i <= 9; i++){\\n            int num = i; \\n            // so the digit is minimum two digits : 10 <= low <= high <= 10^9\\n            for(int j = i + 1;j <= 9; j++){\\n                num = num * 10 + j; //two digit number\\n                if(num > high) break; // high is the threhold because after this the num will be a higher value\\n                if(low <= num && high >= num){\\n                    list.add(num);\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n\\n<br>\\n<br>\\n\\nString yourReaction;\\nif(\"understood\".equals(yourReaction) || \"liked it\".equals(yourReaction))\\nSystem.out.println(\"Please upvote!\")\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n   \\n    public List<Integer> sequentialDigits(int low, int high) {\\n        String seqNum = \"123456789\";\\n         List<Integer> list = new ArrayList<>();\\n\\n        int minWindow = String.valueOf(low).length();\\n        int maxWindow = String.valueOf(high).length();\\n        for(;minWindow <= maxWindow; minWindow++){\\n            for(int j = 0; j + minWindow <= 9; j++){\\n                String str = seqNum.substring(j, j + minWindow);\\n                int num = Integer.parseInt(str);\\n                if(num > high) break;\\n                if(low <= num && high >= num){\\n                    list.add(num);\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n\\n}\\n```\n```\\nclass Solution {\\n    List<Integer> list;\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        list = new ArrayList<>();\\n        //check combination from using 1 - 9\\n        combinations(low, high);\\n        Collections.sort(list);\\n        return list;\\n    }\\n    private void combinations(int low, int high){\\n        for(int i = 1; i <= 9; i++){\\n            int num = i; \\n            // so the digit is minimum two digits : 10 <= low <= high <= 10^9\\n            for(int j = i + 1;j <= 9; j++){\\n                num = num * 10 + j; //two digit number\\n                if(num > high) break; // high is the threhold because after this the num will be a higher value\\n                if(low <= num && high >= num){\\n                    list.add(num);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712402,
                "title": "c-super-simple-and-short-solution-0-ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        string digits = \"123456789\";\\n        \\n        for(int i=0; i<digits.size(); i++) {\\n            \\n            for(int j=i; j<digits.size(); j++) {\\n                \\n                int n = stoi(digits.substr(i, j-i+1));\\n                \\n                if ((n >= low) && (n <= high))\\n                    ans.push_back(n);\\n            }\\n        }\\n        \\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        string digits = \"123456789\";\\n        \\n        for(int i=0; i<digits.size(); i++) {\\n            \\n            for(int j=i; j<digits.size(); j++) {\\n                \\n                int n = stoi(digits.substr(i, j-i+1));\\n                \\n                if ((n >= low) && (n <= high))\\n                    ans.push_back(n);\\n            }\\n        }\\n        \\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711044,
                "title": "c-80ms-look-up-from-array",
                "content": "There aren\\'t enough of these to calculate them, just type them in an array and return the portion of the array the caller asks for.\\n\\n```\\n    public IList<int> SequentialDigits(int low, int high) {\\n        \\n        var seq = new int[] {//1,2,3,4,5,6,7,8,9,\\n                             12,23,34,45,56,67,78,89,\\n                             123,234,345,456,567,678,789,\\n                             1234,2345,3456,4567,5678,6789,\\n                             12345,23456,34567,45678,56789,\\n                             123456,234567,345678,456789,\\n                             1234567,2345678,3456789,\\n                             12345678,23456789,123456789};\\n        \\n        return seq.Where(x => (x >= low) && (x <= high)).ToArray();\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public IList<int> SequentialDigits(int low, int high) {\\n        \\n        var seq = new int[] {//1,2,3,4,5,6,7,8,9,\\n                             12,23,34,45,56,67,78,89,\\n                             123,234,345,456,567,678,789,\\n                             1234,2345,3456,4567,5678,6789,\\n                             12345,23456,34567,45678,56789,\\n                             123456,234567,345678,456789,\\n                             1234567,2345678,3456789,\\n                             12345678,23456789,123456789};\\n        \\n        return seq.Where(x => (x >= low) && (x <= high)).ToArray();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1357999,
                "title": "cpp-concise-solution-0ms-string-method",
                "content": "we will define a string equal to \"123456789\", then we will check our substring lies within low and high if yes we will push it in vector. before returning it, we will sort as per the requirements.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) \\n    {\\n        vector<int> ans;\\n        \\n        string numberString = \"123456789\";\\n        string lowString = to_string(low), highString = to_string(high);\\n        \\n        long long int num = 0;\\n        \\n        for(int i = lowString.length(); i <= highString.length(); i++)\\n        {\\n            for(int j = 0; j <= 9 - i; j++)\\n            {\\n                string temp = numberString.substr(j,i);\\n    \\n                num = stol(temp);\\n            \\n                \\n                if(num >= low && num <= high){\\n                    ans.push_back(num);\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) \\n    {\\n        vector<int> ans;\\n        \\n        string numberString = \"123456789\";\\n        string lowString = to_string(low), highString = to_string(high);\\n        \\n        long long int num = 0;\\n        \\n        for(int i = lowString.length(); i <= highString.length(); i++)\\n        {\\n            for(int j = 0; j <= 9 - i; j++)\\n            {\\n                string temp = numberString.substr(j,i);\\n    \\n                num = stol(temp);\\n            \\n                \\n                if(num >= low && num <= high){\\n                    ans.push_back(num);\\n                }\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205694,
                "title": "c-backtracking-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int l , h , num; \\n    vector <int> v;\\n    \\n    void backtrack(int n)\\n    {\\n        if(n > 9)\\n            return; \\n        num = num*10 + n;\\n        if(num >= l && num <= h)\\n        {\\n            v.push_back(num); \\n        }\\n        if(num > h)\\n            return; \\n        backtrack(n+1);  \\n    }\\n    \\n    vector<int> sequentialDigits(int lo, int hi) \\n    {\\n        l = lo , h = hi; \\n        for(int i=1;i<9;i++)\\n        {\\n            num = i; \\n            backtrack(i+1); \\n        }\\n        sort(v.begin() , v.end()); \\n        return v; \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int l , h , num; \\n    vector <int> v;\\n    \\n    void backtrack(int n)\\n    {\\n        if(n > 9)\\n            return; \\n        num = num*10 + n;\\n        if(num >= l && num <= h)\\n        {\\n            v.push_back(num); \\n        }\\n        if(num > h)\\n            return; \\n        backtrack(n+1);  \\n    }\\n    \\n    vector<int> sequentialDigits(int lo, int hi) \\n    {\\n        l = lo , h = hi; \\n        for(int i=1;i<9;i++)\\n        {\\n            num = i; \\n            backtrack(i+1); \\n        }\\n        sort(v.begin() , v.end()); \\n        return v; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854472,
                "title": "python3-easy-very-fast-and-intuitive-solution",
                "content": "```\\nstore = \\'123456789\\'\\nans = []\\nstart = len(str(low))\\nend = len(str(high))\\n\\nwhile start <= end:\\n\\tfor i in range(len(store) - start + 1):\\n\\t\\tcurr = int(store[i:i+start])\\n\\t\\tif low <= curr <= high:\\n\\t\\t\\tans.append(curr)\\n\\n\\tstart += 1\\nreturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nstore = \\'123456789\\'\\nans = []\\nstart = len(str(low))\\nend = len(str(high))\\n\\nwhile start <= end:\\n\\tfor i in range(len(store) - start + 1):\\n\\t\\tcurr = int(store[i:i+start])\\n\\t\\tif low <= curr <= high:\\n\\t\\t\\tans.append(curr)\\n\\n\\tstart += 1\\nreturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 853653,
                "title": "faster-than-100-00-o-n-2-easy-understanding",
                "content": "```\\n// TC : O(N^2)\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        int num;\\n        vector<int> vec;\\n        for(int i=1;i<=9;i++){\\n            num=i;\\n            for(int j=i+1;j<=9;j++){\\n                num=num*10+j;\\n                if(num>=low && num<=high){\\n                    vec.push_back(num);\\n                }else if(num>high){\\n                    break;\\n                }\\n            }\\n        }\\n        sort(vec.begin(),vec.end());\\n        return vec;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// TC : O(N^2)\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        int num;\\n        vector<int> vec;\\n        for(int i=1;i<=9;i++){\\n            num=i;\\n            for(int j=i+1;j<=9;j++){\\n                num=num*10+j;\\n                if(num>=low && num<=high){\\n                    vec.push_back(num);\\n                }else if(num>high){\\n                    break;\\n                }\\n            }\\n        }\\n        sort(vec.begin(),vec.end());\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780490,
                "title": "slide-to-theeft-chacha-this-time-c",
                "content": "```\\n    public IList<int> SequentialDigits(int low, int high) {\\n        \\n        List<int> lst = new List<int>();\\n        \\n        var sw = \"123456789\";\\n        \\n        var s = sw.Length;\\n        var n = low.ToString().Length;\\n        var m = high.ToString().Length;\\n\\n        for(int i = n; i <= m; i++){\\n            for(int j = 0; j + i <= s; j++){\\n                \\n                \\n                int x = (j + i) - j;\\n                int y = int.Parse(sw.Substring(j, x));\\n                \\n                if(y >= low && y <= high){\\n                    lst.Add(y);\\n                }\\n            }\\n        }\\n        return lst;\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n    public IList<int> SequentialDigits(int low, int high) {\\n        \\n        List<int> lst = new List<int>();\\n        \\n        var sw = \"123456789\";\\n        \\n        var s = sw.Length;\\n        var n = low.ToString().Length;\\n        var m = high.ToString().Length;\\n\\n        for(int i = n; i <= m; i++){\\n            for(int j = 0; j + i <= s; j++){\\n                \\n                \\n                int x = (j + i) - j;\\n                int y = int.Parse(sw.Substring(j, x));\\n                \\n                if(y >= low && y <= high){\\n                    lst.Add(y);\\n                }\\n            }\\n        }\\n        return lst;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 709644,
                "title": "java-simple-brute-force-runs-in-0ms",
                "content": "Generate all possible values and filter values that are not in range\\n\\n```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        String digits = \"123456789\";\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for (int length = 1; length <= 9; length++) {\\n            for (int i = 0; i + length <= digits.length(); i++) {\\n                String substring = digits.substring(i, i + length);\\n                int value = Integer.parseInt(substring);\\n                \\n                if (value >= low && value <= high) {\\n                    result.add(value);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        String digits = \"123456789\";\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for (int length = 1; length <= 9; length++) {\\n            for (int i = 0; i + length <= digits.length(); i++) {\\n                String substring = digits.substring(i, i + length);\\n                int value = Integer.parseInt(substring);\\n                \\n                if (value >= low && value <= high) {\\n                    result.add(value);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692477,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        queue<int>q;\\n        for (int i = 1; i <= 9; i++)\\n            q.push(i);\\n        \\n        vector<int>res;\\n        \\n        while (!q.empty()) {\\n            int f = q.front();\\n            q.pop();\\n            if (f >= low && f <= high)\\n                res.push_back(f);\\n            \\n            if (f > high)\\n                break;\\n            int d = f%10;\\n            if (d < 9)\\n                q.push(f*10 + d+1);\\n        }\\n        a\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        queue<int>q;\\n        for (int i = 1; i <= 9; i++)\\n            q.push(i);\\n        \\n        vector<int>res;\\n        \\n        while (!q.empty()) {\\n            int f = q.front();\\n            q.pop();\\n            if (f >= low && f <= high)\\n                res.push_back(f);\\n            \\n            if (f > high)\\n                break;\\n            int d = f%10;\\n            if (d < 9)\\n                q.push(f*10 + d+1);\\n        }\\n        a\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689838,
                "title": "java-simple-while-loops",
                "content": "pitfalls:\\n1, overflow \\n2, result need to be sorted;\\nref: https://leetcode.com/problems/sequential-digits/discuss/451849/JavaPython-3-Simple-codes.\\n```\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            int d = i, n = d;\\n            while (n <= high && d++ <= 9) {\\n                if (n >= low) res.add(n);\\n                int next = n * 10 + d;\\n                if (next <= n) break; //overflow;\\n                n = next;\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            int d = i, n = d;\\n            while (n <= high && d++ <= 9) {\\n                if (n >= low) res.add(n);\\n                int next = n * 10 + d;\\n                if (next <= n) break; //overflow;\\n                n = next;\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 616433,
                "title": "c-simplest-100-space-100-time",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<int>res;\\n    void generate(int low,int high,int num,int j)\\n    {\\n        if(num>high)\\n            return;\\n        if(num>=low&&num<=high)\\n           res.push_back(num);\\n        for(int i=j;i<=9;i++)\\n        {\\n            if(num!=0&&num%10!=(i-1))\\n                return;\\n            generate(low,high,num*10+i,i+1);\\n        }\\n    }\\n    vector<int> sequentialDigits(int low, int high) \\n    {\\n        res.clear();\\n        generate(low,high,0,1); \\n        sort(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int>res;\\n    void generate(int low,int high,int num,int j)\\n    {\\n        if(num>high)\\n            return;\\n        if(num>=low&&num<=high)\\n           res.push_back(num);\\n        for(int i=j;i<=9;i++)\\n        {\\n            if(num!=0&&num%10!=(i-1))\\n                return;\\n            generate(low,high,num*10+i,i+1);\\n        }\\n    }\\n    vector<int> sequentialDigits(int low, int high) \\n    {\\n        res.clear();\\n        generate(low,high,0,1); \\n        sort(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591750,
                "title": "generating-all-the-numbers-in-range",
                "content": "```\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 1; i < 9; ++i) {\\n            buildNumbers(i, i, res, low, high);\\n        }\\n        res.sort(Integer::compareTo);\\n        return res;\\n    }\\n    \\n    public void buildNumbers(int num, int lastDig, List<Integer> res, int low, int high) {\\n        if (num >= low && num <= high) {\\n            res.add(num);\\n        }\\n        if (lastDig == 9) return;\\n        int nextDig = lastDig + 1;\\n        if (num * 10 + nextDig <= high) {\\n            buildNumbers(num * 10 + nextDig, nextDig, res, low, high);\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 1; i < 9; ++i) {\\n            buildNumbers(i, i, res, low, high);\\n        }\\n        res.sort(Integer::compareTo);\\n        return res;\\n    }\\n    \\n    public void buildNumbers(int num, int lastDig, List<Integer> res, int low, int high) {\\n        if (num >= low && num <= high) {\\n            res.add(num);\\n        }\\n        if (lastDig == 9) return;\\n        int nextDig = lastDig + 1;\\n        if (num * 10 + nextDig <= high) {\\n            buildNumbers(num * 10 + nextDig, nextDig, res, low, high);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1718850,
                "title": "simple-c-solution-using-string-functions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        //since our any number can be made from these digits only so \\n        //we use this string to create our number\\n        string digits = \"123456789\";\\n        vector<int>res;\\n        //now we want to calculate how many digits are in the number \\n        //so we use to string method to calculate the number of digits.\\n        int n1 = to_string(low).length();\\n        int n2 = to_string(high).length();\\n        \\n        //now our sequencial number should lie in low and high so\\n        //we loop from n1 and n2 i.e. number having n1 digits in it\\n        //till number having n2 digits in it..\\n        for(int i=n1;i<=n2;i++){\\n            //here lets say our value of n1 is 3 so we have to at 7 \\n            //for that purpose we use 10-i\\n            for(int j=0;j<10-i;j++){\\n                //now we have to make number from string so firstly\\n                //we take substring from i to j and then convert it\\n                //to int by using stoi function and push it in output..\\n                int val = stoi(digits.substr(j,i));\\n                if(val>=low && val<=high){\\n                    res.push_back(val);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you like the solution please upvote it as it motivates me to create such post.\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        //since our any number can be made from these digits only so \\n        //we use this string to create our number\\n        string digits = \"123456789\";\\n        vector<int>res;\\n        //now we want to calculate how many digits are in the number \\n        //so we use to string method to calculate the number of digits.\\n        int n1 = to_string(low).length();\\n        int n2 = to_string(high).length();\\n        \\n        //now our sequencial number should lie in low and high so\\n        //we loop from n1 and n2 i.e. number having n1 digits in it\\n        //till number having n2 digits in it..\\n        for(int i=n1;i<=n2;i++){\\n            //here lets say our value of n1 is 3 so we have to at 7 \\n            //for that purpose we use 10-i\\n            for(int j=0;j<10-i;j++){\\n                //now we have to make number from string so firstly\\n                //we take substring from i to j and then convert it\\n                //to int by using stoi function and push it in output..\\n                int val = stoi(digits.substr(j,i));\\n                if(val>=low && val<=high){\\n                    res.push_back(val);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713579,
                "title": "trying-to-reach-at-the-top",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int[] allNums = {12,23,34,45,56,67,78,89,\\n                         123,234,345,456,567,678,789,\\n                         1234,2345,3456,4567,5678,6789,\\n                         12345,23456,34567,45678,56789,\\n                         123456,234567,345678,456789,\\n                         1234567,2345678,3456789,\\n                         12345678,23456789,\\n                         123456789};\\n        List<Integer> res = new ArrayList<>();\\n        int n = allNums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (allNums[i] < low) continue;\\n            if (allNums[i] > high) break;\\n            res.add(allNums[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int[] allNums = {12,23,34,45,56,67,78,89,\\n                         123,234,345,456,567,678,789,\\n                         1234,2345,3456,4567,5678,6789,\\n                         12345,23456,34567,45678,56789,\\n                         123456,234567,345678,456789,\\n                         1234567,2345678,3456789,\\n                         12345678,23456789,\\n                         123456789};\\n        List<Integer> res = new ArrayList<>();\\n        int n = allNums.length;\\n        for (int i = 0; i < n; i++) {\\n            if (allNums[i] < low) continue;\\n            if (allNums[i] > high) break;\\n            res.add(allNums[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713379,
                "title": "python-3-20ms-faster-than-95-generating-all-sequential-digits-within-range",
                "content": "***Generating All Sequential Digits with help of of Array \"a\" and thus appending the required ones in Array \"ans\" which are within the range low and high :-***\\n\\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        l=len(str(low))\\n        h=len(str(high))\\n        ans=[]\\n        a=[12,23,34,45,56,67,78,89]\\n        t=0\\n        while l<=h:\\n            for i in a:\\n                for j in range(0,l-2):\\n                    t=i%10\\n                    if i==9:\\n                        break\\n                    i=int(str(i)+str(t+1))\\n                if i%10==0:\\n                    break\\n                if i>=low and i<=high:\\n                    ans.append(i)\\n            l+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        l=len(str(low))\\n        h=len(str(high))\\n        ans=[]\\n        a=[12,23,34,45,56,67,78,89]\\n        t=0\\n        while l<=h:\\n            for i in a:\\n                for j in range(0,l-2):\\n                    t=i%10\\n                    if i==9:\\n                        break\\n                    i=int(str(i)+str(t+1))\\n                if i%10==0:\\n                    break\\n                if i>=low and i<=high:\\n                    ans.append(i)\\n            l+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713348,
                "title": "best-simple-java-solution-100-tc-o-1",
                "content": "```class Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n      \\n\\t\\tint[] allPossibleNumbers = {12,23,34,45,56,67,78,89,\\n\\t\\t\\t\\t\\t\\t123,234,345,456,567,678,789,\\n\\t\\t\\t\\t\\t\\t1234,2345,3456,4567,5678,6789,\\n\\t\\t\\t\\t\\t\\t12345,23456,34567,45678,56789,\\n\\t\\t\\t\\t\\t\\t123456,234567,345678,456789,\\n\\t\\t\\t\\t\\t\\t1234567,2345678,3456789,\\n\\t\\t\\t\\t\\t\\t12345678,23456789,\\n\\t\\t\\t\\t\\t\\t123456789};\\n\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\tint n = allPossibleNumbers.length;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif ( low <=allPossibleNumbers[i] && allPossibleNumbers[i] <= high)   ans.add(allPossibleNumbers[i]);\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```class Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n      \\n\\t\\tint[] allPossibleNumbers = {12,23,34,45,56,67,78,89,\\n\\t\\t\\t\\t\\t\\t123,234,345,456,567,678,789,\\n\\t\\t\\t\\t\\t\\t1234,2345,3456,4567,5678,6789,\\n\\t\\t\\t\\t\\t\\t12345,23456,34567,45678,56789,\\n\\t\\t\\t\\t\\t\\t123456,234567,345678,456789,\\n\\t\\t\\t\\t\\t\\t1234567,2345678,3456789,\\n\\t\\t\\t\\t\\t\\t12345678,23456789,\\n\\t\\t\\t\\t\\t\\t123456789};\\n\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\tint n = allPossibleNumbers.length;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif ( low <=allPossibleNumbers[i] && allPossibleNumbers[i] <= high)   ans.add(allPossibleNumbers[i]);\\n\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713128,
                "title": "fast-than-100-solutions-c-0ms",
                "content": "## Sequential Digits\\n* first calculate minimum no of digits for the starting value\\n`int digit = log(low)/log(10)+1;`\\n* get lowest value for the calculated digit. For e.g. if digit = 4 lowest value = 1234\\n```\\n\\t for(i=1; i<=digit && i<=9; i++)\\n            n=n*10+i;\\n```\\n* get the next value by getting the modulus and adding the next digit.\\n* for eg: `n%=100; n=n*10+5;` will give next value 2345\\n* when reaching the greatest value for digit. for e.g. 6789 then add a digit to the starting value i.e. `1234*10+5 = 12345` and continue increasing the value and adding digits till `n<=high `.\\n\\n### Complete Code in C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        int digit = log(low)/log(10)+1;\\n        int n=0,i=0;\\n        for(i=1; i<=digit && i<=9; i++)\\n        {\\n            n=n*10+i;\\n        }\\n        vector<int>A;\\n        int x = pow(10,digit-1);\\n        int m=n, j=i;\\n        while(m<=high && j<=10)\\n        {\\n            while(n<=high && i<=10)\\n            {\\n               \\n                if(n>=low && n<=high)\\n                    A.push_back(n);\\n                n%=x;\\n                n=n*10+i;\\n                i++;\\n\\n            }\\n            n=m*10+j;\\n            m=n;\\n            j++;\\n            i=j;\\n            x*=10;\\n        }\\n        return A;\\n    }\\n};\\n```\\n\\n##### Upvote and support :-)",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n\\t for(i=1; i<=digit && i<=9; i++)\\n            n=n*10+i;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        int digit = log(low)/log(10)+1;\\n        int n=0,i=0;\\n        for(i=1; i<=digit && i<=9; i++)\\n        {\\n            n=n*10+i;\\n        }\\n        vector<int>A;\\n        int x = pow(10,digit-1);\\n        int m=n, j=i;\\n        while(m<=high && j<=10)\\n        {\\n            while(n<=high && i<=10)\\n            {\\n               \\n                if(n>=low && n<=high)\\n                    A.push_back(n);\\n                n%=x;\\n                n=n*10+i;\\n                i++;\\n\\n            }\\n            n=m*10+j;\\n            m=n;\\n            j++;\\n            i=j;\\n            x*=10;\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712925,
                "title": "c-100-simple-solution",
                "content": "\\nThis solution uses 2 for loops to generate sequential digits and then after checking all conditions we sort ans vector to match output and return it. (if you have any suggetions on it , please reply  : )    )\\n\\n\\n\\'\\'\\'\\' class Solution {\\npublic:\\n    \\n    int convertToInt(int a[],int i,int j){\\n        int ans = 0;\\n        \\n        for(int k = i;k<=j;k++){\\n            ans *= 10;\\n            ans += a[k];\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        \\n        int v[9] = {1,2,3,4,5,6,7,8,9};\\n        \\n        for(int i = 0;i<9;i++){\\n            for(int j = i;j<9;j++){\\n                int k = convertToInt(v,i,j);\\n                if(k <= high && k >= low){\\n                    ans.push_back(k);\\n                }\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n}; \\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int convertToInt(int a[],int i,int j){\\n        int ans = 0;\\n        \\n        for(int k = i;k<=j;k++){\\n            ans *= 10;\\n            ans += a[k];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1712340,
                "title": "best-and-easiest-c-solution",
                "content": "```\\nvector<int> sequentialDigits(int low, int high) {\\n        int nl = to_string(high).length(); //count of digits in low\\n        int nh = to_string(high).length(); //count of digits in high\\n        vector<int> ans;\\n        string digits = \"123456789\";\\n        for(int i=nl;i<=nh;i++){ \\n            for(int j=0;j<=9-i;j++){\\n                int num = stoi(digits.substr(j,i)); // form all possible number from the string digits\\n                if(num >= low && num <= high){ // check if the number formed lies within range\\n                    ans.push_back(num);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t//PLEASE UPVOTE IF YOU LIKE MY SOLUTION, THANKYOU.\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvector<int> sequentialDigits(int low, int high) {\\n        int nl = to_string(high).length(); //count of digits in low\\n        int nh = to_string(high).length(); //count of digits in high\\n        vector<int> ans;\\n        string digits = \"123456789\";\\n        for(int i=nl;i<=nh;i++){ \\n            for(int j=0;j<=9-i;j++){\\n                int num = stoi(digits.substr(j,i)); // form all possible number from the string digits\\n                if(num >= low && num <= high){ // check if the number formed lies within range\\n                    ans.push_back(num);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t//PLEASE UPVOTE IF YOU LIKE MY SOLUTION, THANKYOU.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1712094,
                "title": "very-easy-unique-solution-in-o-1",
                "content": "List down all numbers with sequential digits in a vector init (They are just 36 within given constaints) so Choose only those numbers are in given range\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int>seq = {12,23,34,45,56,67,78,89,123,234,345,456,567,678,789,1234,2345,3456,4567,5678,6789,12345,23456,34567,45678,56789,123456,234567,345678,456789,1234567,2345678,3456789,12345678,23456789,123456789};\\n        vector<int>ans;\\n        for(int i=0;i<seq.size();i++){\\n            if(seq[i]>=low&&seq[i]<=high){\\n                ans.push_back(seq[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n**if u understand then upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int>seq = {12,23,34,45,56,67,78,89,123,234,345,456,567,678,789,1234,2345,3456,4567,5678,6789,12345,23456,34567,45678,56789,123456,234567,345678,456789,1234567,2345678,3456789,12345678,23456789,123456789}",
                "codeTag": "Java"
            },
            {
                "id": 1711412,
                "title": "c-0ms-faster-than-100-easy-to-understand-solution-with-explaination",
                "content": "For each digit in [1, 9], generate the sequentials, and push them into the answer array if they meet the conditions i.e they are in range[low, high].\\nFinally return the sorted array\\n\\n```\\nclass Solution {\\npublic:\\n    // utility to generate next sequential number: 1 -> 12 -> 123...\\n    int nextSequential(int n) {\\n        int digit = n%10;\\n        return n*10 + digit+1;\\n    }\\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        \\n        // For each digit 1..9, push the valid sequential number into the answer array\\n        for(int i = 1; i < 9; i++) {\\n            int cur = i;\\n            while(cur <= high) {\\n                \\n                if(cur >= low && cur <= high) {\\n                    ans.push_back(cur);\\n                }\\n                \\n                // if unit place digit is 9 => no further sequential numbers possible\\n                // for current digit\\n                if(cur%10 == 9) break;\\n                \\n                cur = nextSequential(cur);\\n            }\\n        }\\n        \\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // utility to generate next sequential number: 1 -> 12 -> 123...\\n    int nextSequential(int n) {\\n        int digit = n%10;\\n        return n*10 + digit+1;\\n    }\\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        \\n        // For each digit 1..9, push the valid sequential number into the answer array\\n        for(int i = 1; i < 9; i++) {\\n            int cur = i;\\n            while(cur <= high) {\\n                \\n                if(cur >= low && cur <= high) {\\n                    ans.push_back(cur);\\n                }\\n                \\n                // if unit place digit is 9 => no further sequential numbers possible\\n                // for current digit\\n                if(cur%10 == 9) break;\\n                \\n                cur = nextSequential(cur);\\n            }\\n        }\\n        \\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711093,
                "title": "sequential-digits",
                "content": "class Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int l = Integer.toString(low).length();\\n        int h = Integer.toString(high).length();\\n        List<Integer> arr = new ArrayList<Integer>();\\n        for(int i=l;i<=h;i++){\\n            int count = 1, j = i;\\n            while(j<=9){\\n                int number = 0;\\n                for(int k=count;k<=j;k++)\\n                    number = number*10+k;\\n                if(number>high)\\n                    return arr;\\n                count++;\\n                j++;\\n                if(number<low)\\n                    continue;\\n                arr.add(number);\\n            }\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int l = Integer.toString(low).length();\\n        int h = Integer.toString(high).length();\\n        List<Integer> arr = new ArrayList<Integer>();\\n        for(int i=l;i<=h;i++){\\n            int count = 1, j = i;\\n            while(j<=9){\\n                int number = 0;\\n                for(int k=count;k<=j;k++)\\n                    number = number*10+k;\\n                if(number>high)\\n                    return arr;\\n                count++;\\n                j++;\\n                if(number<low)\\n                    continue;\\n                arr.add(number);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 860443,
                "title": "c-super-simple-and-short-solution-0-ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        string digits = \"123456789\";\\n        \\n        for(int i=0; i<digits.size(); i++) {\\n            \\n            for(int j=i; j<digits.size(); j++) {\\n                \\n                int n = stoi(digits.substr(i, j-i+1));\\n                \\n                if ((n >= low) && (n <= high))\\n                    ans.push_back(n);\\n            }\\n        }\\n        \\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        string digits = \"123456789\";\\n        \\n        for(int i=0; i<digits.size(); i++) {\\n            \\n            for(int j=i; j<digits.size(); j++) {\\n                \\n                int n = stoi(digits.substr(i, j-i+1));\\n                \\n                if ((n >= low) && (n <= high))\\n                    ans.push_back(n);\\n            }\\n        }\\n        \\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854576,
                "title": "c-sliding-window-and-bfs",
                "content": "**Solution 1: Sliding Window**\\n```\\npublic class Solution {\\n    public IList<int> SequentialDigits(int low, int high) {\\n        \\n        List<int> res = new List<int>();\\n        \\n        int len1 = low.ToString().Length;\\n        int len2 = high.ToString().Length;\\n        string str = \"123456789\";\\n        \\n        for(int len = len1; len <= len2; len++)\\n        {\\n            for(int i = 0; i <= 9 - len; i++)\\n            {\\n                int num = Convert.ToInt32(str.Substring(i, len));\\n                \\n                if(num >= low && num <= high)\\n                    res.Add(num);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Solution 2: BFS**\\n```\\npublic class Solution {\\n    public IList<int> SequentialDigits(int low, int high) {\\n        \\n        List<int> res = new List<int>();\\n        \\n        Queue<int> queue = new Queue<int>();\\n        for(int i = 1; i <= 9; i++)\\n            queue.Enqueue(i);\\n        \\n        while(queue.Count > 0)\\n        {\\n            int curr = queue.Dequeue();\\n            \\n            if(curr >= low && curr <= high)\\n                res.Add(curr);\\n            \\n            int lastDigit = curr % 10 + 1;\\n            \\n            if(lastDigit > 1 && lastDigit <= 9)\\n            {\\n                int num = curr * 10 + lastDigit;          \\n                queue.Enqueue(num);\\n            }            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nhttps://www.youtube.com/watch?v=JgQ6684VyiY",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> SequentialDigits(int low, int high) {\\n        \\n        List<int> res = new List<int>();\\n        \\n        int len1 = low.ToString().Length;\\n        int len2 = high.ToString().Length;\\n        string str = \"123456789\";\\n        \\n        for(int len = len1; len <= len2; len++)\\n        {\\n            for(int i = 0; i <= 9 - len; i++)\\n            {\\n                int num = Convert.ToInt32(str.Substring(i, len));\\n                \\n                if(num >= low && num <= high)\\n                    res.Add(num);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<int> SequentialDigits(int low, int high) {\\n        \\n        List<int> res = new List<int>();\\n        \\n        Queue<int> queue = new Queue<int>();\\n        for(int i = 1; i <= 9; i++)\\n            queue.Enqueue(i);\\n        \\n        while(queue.Count > 0)\\n        {\\n            int curr = queue.Dequeue();\\n            \\n            if(curr >= low && curr <= high)\\n                res.Add(curr);\\n            \\n            int lastDigit = curr % 10 + 1;\\n            \\n            if(lastDigit > 1 && lastDigit <= 9)\\n            {\\n                int num = curr * 10 + lastDigit;          \\n                queue.Enqueue(num);\\n            }            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854406,
                "title": "java-recursive-explained-beats-100",
                "content": "In case we\\'ll be generating required numbers it\\'s gonna be faster than a brute force check (count all numbers from low to high and check for every one if it fits the condition).\\nAlgorithm that generates numbers is pretty simple - take last added digit, multiple current number by 10 and add digit + 1. Do this until digit + 1 <= 9 and generated number is smaller than a high limit. \\nWe have to hard stop in case generated number is higher than a high because all next numbers will be only greater. However it\\'s not the same for the lower case - if number is less than a low we still can proceed because next number will be greater than a previous one.\\n\\nThis algorithm leads to a recursive solution below.\\n\\n```\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList();\\n        for (int i = 1; i <= 9; i++) {\\n            helper(0, i, low, high, res);\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n    \\n    void helper(int cur, int digit, int low, int high, List<Integer> res) {    \\n        cur = cur * 10 + digit;\\n        if (cur > high)\\n            return;\\n        \\n        if (cur >= low) {\\n            res.add(cur);\\n        }\\n        \\n        if (digit + 1 <= 9)\\n            helper(cur, digit + 1, low, high, res);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList();\\n        for (int i = 1; i <= 9; i++) {\\n            helper(0, i, low, high, res);\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n    \\n    void helper(int cur, int digit, int low, int high, List<Integer> res) {    \\n        cur = cur * 10 + digit;\\n        if (cur > high)\\n            return;\\n        \\n        if (cur >= low) {\\n            res.add(cur);\\n        }\\n        \\n        if (digit + 1 <= 9)\\n            helper(cur, digit + 1, low, high, res);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 853522,
                "title": "python-3-backtracking-dfs-explanation",
                "content": "### Explanation\\n- Intuition here is that the current digit depends on previous digit, possible number doesn\\'t have a specific length, such a relation can be described with **backtracking**\\n- Begin with `1 to 9` inclusive, using backtracking to generating possible result\\n- `digit`: next digit that is about to append to the integer\\n- `cur`: current value \\n- `if digit <= 10 and low <= cur <= high`: meaning number is ended with a digit from 1 to 9 inclusive, and current value is between `low` and `high`, since we are only generating possible sequential numbers, digits in `cur` should be in a increasing order\\n- `if cur < low`: ignore and continue see if we can find a possible answer\\n- otherwise stop\\n### Implementation\\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        ans = []\\n        def dfs(cur, digit):\\n            if digit <= 10 and low <= cur <= high: ans.append(cur) # add number satisfy the condition\\n            elif cur < low: pass                                   # continue check larger values\\n            else: return                                           # stop condition\\n            cur = cur * 10 + digit                                 # generating number with sequential digits\\n            dfs(cur, digit+1)                                      # backtracking\\n        for i in range(1, 10): dfs(0, i)                           # start with each digit from 1 to 9, inclusive\\n        return sorted(ans)                                         # sort the result and return\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        ans = []\\n        def dfs(cur, digit):\\n            if digit <= 10 and low <= cur <= high: ans.append(cur) # add number satisfy the condition\\n            elif cur < low: pass                                   # continue check larger values\\n            else: return                                           # stop condition\\n            cur = cur * 10 + digit                                 # generating number with sequential digits\\n            dfs(cur, digit+1)                                      # backtracking\\n        for i in range(1, 10): dfs(0, i)                           # start with each digit from 1 to 9, inclusive\\n        return sorted(ans)                                         # sort the result and return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845013,
                "title": "java-solution-0ms",
                "content": "```\\n/* My thought process\\nHere we need to create certain numbers with in a range of values. So creating numbers with some constarints all comes under backtracking problem. So we need to find this as a backtracking problem and then we are good to go.\\n\\nSo what is our goal here: To create sequential digits if and only if each digit in the number is one more than the previous digit.\\n\\nWhat is our constraints: The numbers must be in a specific range\\n\\nSo we need to take numbers from 1 to 9 and check whther the number satisifes the contraints or not. If yes, then we just add it to our resulting list and consider the number for the next digit by using recursion: Note We can consider the next digit by doing number * 10 + value. \\n\\nThis is the whole problem and we need to sort the result as its specifiedd in the question.\\n\\n*/\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i=1; i<=9; i++) {\\n            helper(result, low, high, 0, i);\\n        }\\n        Collections.sort(result);\\n        return result;\\n    }\\n    public void helper(List<Integer> result, int low, int high, int value, int i) {\\n        if (value > high)\\n            return;\\n        if (value >= low)\\n            result.add(value);\\n        if (i > 9)\\n            return;\\n        helper(result, low, high, value*10+i, i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n/* My thought process\\nHere we need to create certain numbers with in a range of values. So creating numbers with some constarints all comes under backtracking problem. So we need to find this as a backtracking problem and then we are good to go.\\n\\nSo what is our goal here: To create sequential digits if and only if each digit in the number is one more than the previous digit.\\n\\nWhat is our constraints: The numbers must be in a specific range\\n\\nSo we need to take numbers from 1 to 9 and check whther the number satisifes the contraints or not. If yes, then we just add it to our resulting list and consider the number for the next digit by using recursion: Note We can consider the next digit by doing number * 10 + value. \\n\\nThis is the whole problem and we need to sort the result as its specifiedd in the question.\\n\\n*/\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> result = new ArrayList<>();\\n        for (int i=1; i<=9; i++) {\\n            helper(result, low, high, 0, i);\\n        }\\n        Collections.sort(result);\\n        return result;\\n    }\\n    public void helper(List<Integer> result, int low, int high, int value, int i) {\\n        if (value > high)\\n            return;\\n        if (value >= low)\\n            result.add(value);\\n        if (i > 9)\\n            return;\\n        helper(result, low, high, value*10+i, i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753972,
                "title": "java-solution-recursion",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            helper(i + \"\", low, high, ans);\\n        }\\n        Collections.sort(ans);\\n        return ans;\\n    }\\n    \\n    public void helper(String temp, int low, int high, List<Integer> list) {\\n        int num = Integer.parseInt(temp);\\n        int next = Integer.parseInt(temp.substring(temp.length() - 1)) + 1;\\n        if (num > high) {\\n            return;\\n        }\\n        if (num >= low && num <= high) {\\n            list.add(num);\\n        } \\n        if (next < 10) {\\n            helper(temp + next, low, high, list);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            helper(i + \"\", low, high, ans);\\n        }\\n        Collections.sort(ans);\\n        return ans;\\n    }\\n    \\n    public void helper(String temp, int low, int high, List<Integer> list) {\\n        int num = Integer.parseInt(temp);\\n        int next = Integer.parseInt(temp.substring(temp.length() - 1)) + 1;\\n        if (num > high) {\\n            return;\\n        }\\n        if (num >= low && num <= high) {\\n            list.add(num);\\n        } \\n        if (next < 10) {\\n            helper(temp + next, low, high, list);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452351,
                "title": "python3-faster-than-100-less-memory-than-100",
                "content": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        num = []\\n        for x in range(1,9):\\n            while x <= high:\\n                r = x % 10\\n                \\n                if r == 0:\\n                    break\\n                    \\n                if x >= low:\\n                    num.append(x)\\n                    \\n                x = (x * 10) + r + 1\\n                \\n                \\n        return sorted(num)\\n\\t\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        num = []\\n        for x in range(1,9):\\n            while x <= high:\\n                r = x % 10\\n                \\n                if r == 0:\\n                    break\\n                    \\n                if x >= low:\\n                    num.append(x)\\n                    \\n                x = (x * 10) + r + 1\\n                \\n                \\n        return sorted(num)\\n\\t\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 451873,
                "title": "c-0ms-precalculated-o-1",
                "content": "```\\nvector<int> sequentialDigits(int low, int high) {\\n\\tvector <int> s;\\n\\tfor(int i = 1; i < 10; ++i){\\n\\t\\tint val = 0;\\n\\t\\tfor(int j = i; j < 10; ++j){\\n\\t\\t\\tval = val * 10 + j;\\n\\t\\t\\ts.push_back(val);\\n\\t\\t}\\n\\t}\\n\\tsort(s.begin(),s.end());\\n\\tvector <int> result;\\n\\tfor(int i = 0; i < s.size(); ++i){\\n\\t\\tif(s[i] > high)\\n\\t\\t\\tbreak;\\n\\t\\tif(s[i] >= low)\\n\\t\\t\\tresult.push_back(s[i]);\\n\\t}\\n\\treturn result;\\n}\\n```\\nApproach :\\n- Generate all sequential numbers start with i (i = 1,2, ... , 9)\\n- Iterate through the sorted list and add only those numbers which are greater than low\\n- Prune when the number > high",
                "solutionTags": [],
                "code": "```\\nvector<int> sequentialDigits(int low, int high) {\\n\\tvector <int> s;\\n\\tfor(int i = 1; i < 10; ++i){\\n\\t\\tint val = 0;\\n\\t\\tfor(int j = i; j < 10; ++j){\\n\\t\\t\\tval = val * 10 + j;\\n\\t\\t\\ts.push_back(val);\\n\\t\\t}\\n\\t}\\n\\tsort(s.begin(),s.end());\\n\\tvector <int> result;\\n\\tfor(int i = 0; i < s.size(); ++i){\\n\\t\\tif(s[i] > high)\\n\\t\\t\\tbreak;\\n\\t\\tif(s[i] >= low)\\n\\t\\t\\tresult.push_back(s[i]);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3413613,
                "title": "easy-c-solution-4-ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int>lst;\\n        for(int i=1;i<10;i++){\\n            string s;\\n            s+=to_string(i);\\n            for(int j=i+1;j<10;j++){\\n                s+=to_string(j);\\n                lst.push_back(stoi(s));\\n            }\\n        }\\n        vector<int>final;\\n        for(auto i:lst){\\n            if(i>=low && i<=high) final.push_back(i);\\n        }\\n        sort(final.begin(),final.end());\\n        return final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int>lst;\\n        for(int i=1;i<10;i++){\\n            string s;\\n            s+=to_string(i);\\n            for(int j=i+1;j<10;j++){\\n                s+=to_string(j);\\n                lst.push_back(stoi(s));\\n            }\\n        }\\n        vector<int>final;\\n        for(auto i:lst){\\n            if(i>=low && i<=high) final.push_back(i);\\n        }\\n        sort(final.begin(),final.end());\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076081,
                "title": "recursive-interative-beats-100-c",
                "content": "# Iterative Code\\n```\\nclass Solution {\\npublic:\\nvector<int> sequentialDigits(int low, int high)\\n{\\n    int num;\\n    vector<int> ans;\\n    for (int i = 1; i <= 9; ++i)\\n    {\\n        num = i;\\n        for (int j = i + 1; j <= 9; ++j)\\n        {\\n            num = (num * 10) + j;\\n            if (num >= low and num <= high)\\n            {\\n                ans.push_back(num);\\n            }\\n            else if (num > high)\\n            {\\n                break;\\n            }\\n        }\\n    }\\n    sort(ans.begin(), ans.end());\\n    return ans;\\n}\\n};\\n```\\n\\n# Recursive Code\\n```\\nclass Solution {\\npublic:\\nvoid digitFormation(int num, int idx, vector<int> &arr, int &low, int &high)\\n{\\n    if (num >= low and num <= high)\\n    {\\n        arr.push_back(num);\\n    }\\n    else if (num > high)\\n    {\\n        return;\\n    }\\n    num = (num * 10) + idx;\\n    if (idx <= 9)\\n        digitFormation(num, idx + 1, arr, low, high);\\n    return;\\n}\\n\\nvector<int> sequentialDigits(int low, int high)\\n{\\n    vector<int> arr;\\n    for (int i = 1; i <= 9; ++i)\\n        digitFormation(i, i + 1, arr, low, high);\\n    return arr;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> sequentialDigits(int low, int high)\\n{\\n    int num;\\n    vector<int> ans;\\n    for (int i = 1; i <= 9; ++i)\\n    {\\n        num = i;\\n        for (int j = i + 1; j <= 9; ++j)\\n        {\\n            num = (num * 10) + j;\\n            if (num >= low and num <= high)\\n            {\\n                ans.push_back(num);\\n            }\\n            else if (num > high)\\n            {\\n                break;\\n            }\\n        }\\n    }\\n    sort(ans.begin(), ans.end());\\n    return ans;\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\nvoid digitFormation(int num, int idx, vector<int> &arr, int &low, int &high)\\n{\\n    if (num >= low and num <= high)\\n    {\\n        arr.push_back(num);\\n    }\\n    else if (num > high)\\n    {\\n        return;\\n    }\\n    num = (num * 10) + idx;\\n    if (idx <= 9)\\n        digitFormation(num, idx + 1, arr, low, high);\\n    return;\\n}\\n\\nvector<int> sequentialDigits(int low, int high)\\n{\\n    vector<int> arr;\\n    for (int i = 1; i <= 9; ++i)\\n        digitFormation(i, i + 1, arr, low, high);\\n    return arr;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521124,
                "title": "for-beginners",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList<>();\\n        List<String> temp = new ArrayList<>();\\n        String t = \"\";\\n        t += 123456789;\\n        for(int i = 0; i < t.length(); i++){\\n            for(int j = i + 1; j < t.length(); j++){\\n                String te = t.substring(i, j + 1);\\n                int n = 0;\\n                if(!te.equals(\"\")) n = Integer.parseInt(te);\\n                if(n >= low && n <= high) res.add(n);\\n            }\\n        }\\n        Collections.sort(res);\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList<>();\\n        List<String> temp = new ArrayList<>();\\n        String t = \"\";\\n        t += 123456789;\\n        for(int i = 0; i < t.length(); i++){\\n            for(int j = i + 1; j < t.length(); j++){\\n                String te = t.substring(i, j + 1);\\n                int n = 0;\\n                if(!te.equals(\"\")) n = Integer.parseInt(te);\\n                if(n >= low && n <= high) res.add(n);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2124936,
                "title": "i-don-t-know-what-this-method-is-called-c-0ms-solution",
                "content": "class Solution {\\npublic:\\n    \\n\\tint prev_small(int digit) {     // to calculate smallest value for a given digit.\\n        int number=1;\\n        int previous_smaller=0;\\n        for(;number<=digit;number++) previous_smaller= previous_smaller*10+number;\\n        return previous_smaller;\\n    }\\n    \\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        int digit = log10(low)+1;\\n        int res=prev_small(digit);\\n        \\n        while(res<low) {              // to make our res greater or equal to low\\n            int last_digit = res%10;\\n            if(last_digit==9) {      // if last digit is 9 then we should increase digit count\\n                digit++;\\n                res = prev_small(digit);\\n                continue;\\n            }\\n            int power = pow(10,digit-1);\\n            res = (res - (res/power)*power)*10 + last_digit+1;\\n        }\\n        \\n        \\n        while(res<=high) {\\n            \\n            ans.push_back(res);\\n            int last_digit = res%10;\\n            if(last_digit==9) {\\n                digit++;\\n                res = prev_small(digit);\\n                continue;\\n            }\\n            int power = pow(10,digit-1);\\n            res = (res - (res/power)*power)*10 + last_digit+1;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tint prev_small(int digit) {     // to calculate smallest value for a given digit.\\n        int number=1;\\n        int previous_smaller=0;\\n        for(;number<=digit;number++) previous_smaller= previous_smaller*10+number;\\n        return previous_smaller;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1723738,
                "title": "faster-than-100-java-solution-using-string-functions",
                "content": "```\\n#**Please please upvote if you liked the solution\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) \\n    {\\n        String digits=\"123456789\";\\n        List<Integer> result=new ArrayList<>();\\n        int nl=String.valueOf(low).length();\\n        int nh=String.valueOf(high).length();\\n        for(int i=nl;i<=nh;i++)\\n        {\\n            for(int j=0;j<10-i;j++)\\n            {\\n                int num=Integer.parseInt(digits.substring(j,j+i));\\n                if(num>=low && num<=high)\\n                {\\n                    result.add(num);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public List<Integer> sequentialDigits(int low, int high) \\n    {\\n        String digits=\"123456789\";\\n        List<Integer> result=new ArrayList<>();\\n        int nl=String.valueOf(low).length();\\n        int nh=String.valueOf(high).length();\\n        for(int i=nl;i<=nh;i++)\\n        {\\n            for(int j=0;j<10-i;j++)\\n            {\\n                int num=Integer.parseInt(digits.substring(j,j+i));\\n                if(num>=low && num<=high)\\n                {\\n                    result.add(num);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1719033,
                "title": "faster-100-o-1-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int>ans;\\n        int k = 0;\\n        int digit = 2;\\n        int m = 1;\\n            for(long int i =10 ; i<= 1000000000 ; i=i*10){\\n                int k = k*10 + digit;\\n                digit++;\\n                long int p = i+k;\\n                m = m*10+1;\\n                while(p%10 != 9){\\n                    if(p>=low && p<=high) ans.push_back(p);\\n                    p+=m;\\n                }\\n                    if(p>=low && p<=high) ans.push_back(p);\\n            }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int>ans;\\n        int k = 0;\\n        int digit = 2;\\n        int m = 1;\\n            for(long int i =10 ; i<= 1000000000 ; i=i*10){\\n                int k = k*10 + digit;\\n                digit++;\\n                long int p = i+k;\\n                m = m*10+1;\\n                while(p%10 != 9){\\n                    if(p>=low && p<=high) ans.push_back(p);\\n                    p+=m;\\n                }\\n                    if(p>=low && p<=high) ans.push_back(p);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1715565,
                "title": "python-simple-python-solution-using-string-subarray",
                "content": "# It is useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef sequentialDigits(self, low: int, high: int) -> List[int]:\\n\\n\\t\\t\\tans=[]\\n\\t\\t\\ts=\\'123456789\\'\\n\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tj=2\\n\\t\\t\\t\\twhile j<10:\\n\\t\\t\\t\\t\\tif int(s[i:i+j]) not in ans:\\n\\t\\t\\t\\t\\t\\tif int(s[i:i+j]) in range(low,high+1):\\n\\t\\t\\t\\t\\t\\t\\tans.append(int(s[i:i+j]))\\n\\t\\t\\t\\t\\tj=j+1\\n\\n\\t\\t\\tans.sort()\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# It is useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef sequentialDigits(self, low: int, high: int) -> List[int]:\\n\\n\\t\\t\\tans=[]\\n\\t\\t\\ts=\\'123456789\\'\\n\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tj=2\\n\\t\\t\\t\\twhile j<10:\\n\\t\\t\\t\\t\\tif int(s[i:i+j]) not in ans:\\n\\t\\t\\t\\t\\t\\tif int(s[i:i+j]) in range(low,high+1):\\n\\t\\t\\t\\t\\t\\t\\tans.append(int(s[i:i+j]))\\n\\t\\t\\t\\t\\tj=j+1\\n\\n\\t\\t\\tans.sort()\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 1714627,
                "title": "100-faster-o-1-time-and-space-complexity-clever-c",
                "content": "class Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> nums = {12,23,34,45,56,67,78,89,\\n                       123,234,345,456,567,678,789,\\n                       1234,2345,3456,4567,5678,6789,\\n                       12345,23456,34567,45678,56789,\\n                       123456,234567,345678,456789,\\n                       1234567,2345678,3456789,\\n                       12345678,23456789,\\n                       123456789};\\n        vector<int> ans;\\n        for(int it : nums)\\n        {\\n            if(it>high) break;\\n            if(it>=low && it<=high)\\n                ans.push_back(it);\\n            else continue;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> nums = {12,23,34,45,56,67,78,89,\\n                       123,234,345,456,567,678,789,\\n                       1234,2345,3456,4567,5678,6789,\\n                       12345,23456,34567,45678,56789,\\n                       123456,234567,345678,456789,\\n                       1234567,2345678,3456789,\\n                       12345678,23456789,\\n                       123456789}",
                "codeTag": "Java"
            },
            {
                "id": 1713567,
                "title": "sequential-digits-c-solution-0ms-o-1-faster-than-100",
                "content": "vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        int l=low,h=high,l_count=0,h_count=0;\\n        while(l>0){       // Counting digits of lower range\\n            l/=10;\\n            l_count++;\\n        }\\n        while(h>0){      // Counting digits of higher range\\n            h/=10;\\n            h_count++;\\n        }\\n        int num=l_count;\\n        while(num<=h_count){           // loops run from l_count till h_count\\n            for(int i=1;i<=10-num;i++){\\n                int temp=0;\\n                for(int j=1,k=i;j<=num;j++){\\n                    temp=temp*10+k;         \\n                    k++;\\n                 }\\n                if(temp>=low and temp<=high)     ans.push_back(temp);\\n\\t\\t\\t\\telse if(temp>high)    return ans;\\n            }\\n            num++;\\n         }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        int l=low,h=high,l_count=0,h_count=0;\\n        while(l>0){       // Counting digits of lower range\\n            l/=10;\\n            l_count++;\\n        }\\n        while(h>0){      // Counting digits of higher range\\n            h/=10;\\n            h_count++;\\n        }\\n        int num=l_count;\\n        while(num<=h_count){           // loops run from l_count till h_count\\n            for(int i=1;i<=10-num;i++){\\n                int temp=0;\\n                for(int j=1,k=i;j<=num;j++){\\n                    temp=temp*10+k;         \\n                    k++;\\n                 }\\n                if(temp>=low and temp<=high)     ans.push_back(temp);\\n\\t\\t\\t\\telse if(temp>high)    return ans;\\n            }\\n            num++;\\n         }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1713342,
                "title": "c-0-ms-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n         vector<int> allnumbers ={12,23,34,45,56,67,78,89,123,234,345,456,567,678,789,1234,2345,3456,4567,5678,6789,12345,23456,34567,45678,56789,123456,234567,345678,456789,1234567,2345678,3456789,12345678,23456789,123456789};\\n        \\n        int start = lower_bound(allnumbers.begin() , allnumbers.end() , low) - allnumbers.begin();\\n        int end = upper_bound(allnumbers.begin() , allnumbers.end() , high) - allnumbers.begin();\\n        \\n        vector<int> res;\\n        \\n        for(int i = start ; i< end; i++){\\n            res.push_back(allnumbers[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n         vector<int> allnumbers ={12,23,34,45,56,67,78,89,123,234,345,456,567,678,789,1234,2345,3456,4567,5678,6789,12345,23456,34567,45678,56789,123456,234567,345678,456789,1234567,2345678,3456789,12345678,23456789,123456789};\\n        \\n        int start = lower_bound(allnumbers.begin() , allnumbers.end() , low) - allnumbers.begin();\\n        int end = upper_bound(allnumbers.begin() , allnumbers.end() , high) - allnumbers.begin();\\n        \\n        vector<int> res;\\n        \\n        for(int i = start ; i< end; i++){\\n            res.push_back(allnumbers[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713255,
                "title": "java-fastest-0ms-easiest-with-comments",
                "content": "```\\nclass Solution {\\n\\t//creating them class members bcz they will never get changed for an input\\n    int low=0;\\n    int high=0;\\n    public List<Integer> sequentialDigits(int low, int high) {\\n\\t\\t//initializing all variables\\n        List<Integer> list=new ArrayList<>();\\n        this.high=high;\\n        this.low=low;\\n\\t\\t\\n\\t\\t//all of posible values will start from 1 to 9\\n        for(int i=1;i<=9;i++){\\n\\t\\t\\t//calling our helper fxn to get all possible values starting with our given digit\\n            dfs(i,list);\\n        }\\n\\t\\t//sorting all found values as required in ques\\n        Collections.sort(list);\\n        return list;\\n    }\\n\\t\\n\\t//helper fxn to get all possible values associated with one started digit\\n    public void dfs(int num,List<Integer> list){\\n\\t\\t//getting last digit from our no. and adding 1(to maintain sequential order)\\n        int add=(num%10)+1;\\n\\t\\t//special case to be noted: \\n\\t\\t//when we have 9 as last digit\\n\\t\\t//then our \"add\" will have 10 and sequential order will break so ignoring that case\\n        if(add!=10){\\n\\t\\t\\t//adding our sequence to our no.\\n            num=(num*10)+add;\\n\\t\\t\\t//if less than high then always try to check further\\n            if(num<=high){\\n\\t\\t\\t\\t//if less than low i.e. num is in the range so add to list\\n                if(num>=low){\\n                    list.add(num);\\n                }\\n\\t\\t\\t\\t//calling furhter to get more values less than high \\n                dfs(num,list);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\t//creating them class members bcz they will never get changed for an input\\n    int low=0;\\n    int high=0;\\n    public List<Integer> sequentialDigits(int low, int high) {\\n\\t\\t//initializing all variables\\n        List<Integer> list=new ArrayList<>();\\n        this.high=high;\\n        this.low=low;\\n\\t\\t\\n\\t\\t//all of posible values will start from 1 to 9\\n        for(int i=1;i<=9;i++){\\n\\t\\t\\t//calling our helper fxn to get all possible values starting with our given digit\\n            dfs(i,list);\\n        }\\n\\t\\t//sorting all found values as required in ques\\n        Collections.sort(list);\\n        return list;\\n    }\\n\\t\\n\\t//helper fxn to get all possible values associated with one started digit\\n    public void dfs(int num,List<Integer> list){\\n\\t\\t//getting last digit from our no. and adding 1(to maintain sequential order)\\n        int add=(num%10)+1;\\n\\t\\t//special case to be noted: \\n\\t\\t//when we have 9 as last digit\\n\\t\\t//then our \"add\" will have 10 and sequential order will break so ignoring that case\\n        if(add!=10){\\n\\t\\t\\t//adding our sequence to our no.\\n            num=(num*10)+add;\\n\\t\\t\\t//if less than high then always try to check further\\n            if(num<=high){\\n\\t\\t\\t\\t//if less than low i.e. num is in the range so add to list\\n                if(num>=low){\\n                    list.add(num);\\n                }\\n\\t\\t\\t\\t//calling furhter to get more values less than high \\n                dfs(num,list);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713098,
                "title": "python3-simplest-and-fastest-solution-in-o-1-with-explanation",
                "content": "This excercise asks for numbers with digits in ascending order that differ exactly by 1, between 10 and 10^9. We can observe that this is a finite sequence with exactly 36 numbers... so we can simply list them all.\\n\\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        \\n        # https://oeis.org/A138141\\n        nums = (12, 23, 34, 45, 56, 67, 78, 89, 123, 234, 345, 456, 567, 678, 789, 1234, 2345, 3456, 4567, 5678, 6789, 12345, 23456, 34567, 45678, 56789, 123456, 234567, 345678, 456789, 1234567, 2345678, 3456789, 12345678, 23456789, 123456789)\\n        \\n        return filter(lambda n: low <= n <= high, nums)\\n```\\n\\nComplexity: O(1) for both time and space.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        \\n        # https://oeis.org/A138141\\n        nums = (12, 23, 34, 45, 56, 67, 78, 89, 123, 234, 345, 456, 567, 678, 789, 1234, 2345, 3456, 4567, 5678, 6789, 12345, 23456, 34567, 45678, 56789, 123456, 234567, 345678, 456789, 1234567, 2345678, 3456789, 12345678, 23456789, 123456789)\\n        \\n        return filter(lambda n: low <= n <= high, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712769,
                "title": "c-0ms-solution-easiest-approach-time-complexity-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> dp;\\n\\n        for(int i=1;i<9;i++){\\n            dp.push_back(i);\\n        }\\n        \\n        int counter = 2;\\n        int count = counter;\\n        \\n        vector<int> ans;\\n        while(count<=9){\\n            int i = 0;\\n            while(counter<=9){\\n              int num = dp[i] * 10 + counter;\\n              dp[i] = num;\\n              \\n              if(dp[i]>=low && dp[i]<=high)\\n                 ans.push_back(dp[i]);\\n              \\n              counter++;\\n              i++;  \\n            }\\n            count++;\\n            counter = count;\\n       }\\n            \\n       \\n       return ans; \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> dp;\\n\\n        for(int i=1;i<9;i++){\\n            dp.push_back(i);\\n        }\\n        \\n        int counter = 2;\\n        int count = counter;\\n        \\n        vector<int> ans;\\n        while(count<=9){\\n            int i = 0;\\n            while(counter<=9){\\n              int num = dp[i] * 10 + counter;\\n              dp[i] = num;\\n              \\n              if(dp[i]>=low && dp[i]<=high)\\n                 ans.push_back(dp[i]);\\n              \\n              counter++;\\n              i++;  \\n            }\\n            count++;\\n            counter = count;\\n       }\\n            \\n       \\n       return ans; \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712731,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions-java-solution-using-string",
                "content": "so i used the String builder and Integer wrapper class to handle the situation, the steps i followed \\n1.iterate i from 1 to 9 digits\\n2.  create a StringBuilder buffer for each i and append the digit i as the starting digit\\n3.  iterate for the j starting from i+1 to 9 and append the digit j to the Stringbuilder buffer\\n4.  check if the Integer value of the String builder is >=low and <=high\\n5.  if yes than add the `Integer.valueOf ` Stringbuilder to the list\\n6.  if the `Integer.valueOf(Stringbuilder.toString)` is >high break out of the outer loop and start with incremented value of i from step 1\\n\\n\\n```\\npublic static List<Integer> sequentialDigits(int low, int high) {\\n\\n\\t\\tList<Integer> results = new ArrayList<Integer>();\\n\\n\\t\\tfor(int i=1;i<=9;i++) {\\n\\n\\t\\t\\t//Simply create a StringBuilder and append the starting digit i\\n\\t\\t\\tStringBuilder sb= new StringBuilder(); \\n\\t\\t\\tsb.append(i);\\n\\n\\t\\t\\t//now iterate for the digits greater than i till 9 and append it to the Sb\\n\\t\\t\\tfor(int j=i+1;j<=9;j++) {\\n\\n\\n\\t\\t\\t\\tsb.append(j); //append the digit j to the existing string builder\\n\\n\\t\\t\\t\\tint potential=Integer.valueOf(sb.toString());\\n\\n\\t\\t\\t\\t//check if the potnetial number meets the criteria low<potential>high, if yes add the number to the list\\n\\n\\t\\t\\t\\tif(potential>=low && potential<=high) {\\n\\t\\t\\t\\t\\tresults.add(potential);\\t\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//check if the potential is greater than the high break out of the inner loop and start with the different i as starting digit\\n\\t\\t\\t\\tif(potential>high) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tCollections.sort(results);\\n\\t\\treturn results;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "so i used the String builder and Integer wrapper class to handle the situation, the steps i followed \\n1.iterate i from 1 to 9 digits\\n2.  create a StringBuilder buffer for each i and append the digit i as the starting digit\\n3.  iterate for the j starting from i+1 to 9 and append the digit j to the Stringbuilder buffer\\n4.  check if the Integer value of the String builder is >=low and <=high\\n5.  if yes than add the `Integer.valueOf ` Stringbuilder to the list\\n6.  if the `Integer.valueOf(Stringbuilder.toString)` is >high break out of the outer loop and start with incremented value of i from step 1\\n\\n\\n```\\npublic static List<Integer> sequentialDigits(int low, int high) {\\n\\n\\t\\tList<Integer> results = new ArrayList<Integer>();\\n\\n\\t\\tfor(int i=1;i<=9;i++) {\\n\\n\\t\\t\\t//Simply create a StringBuilder and append the starting digit i\\n\\t\\t\\tStringBuilder sb= new StringBuilder(); \\n\\t\\t\\tsb.append(i);\\n\\n\\t\\t\\t//now iterate for the digits greater than i till 9 and append it to the Sb\\n\\t\\t\\tfor(int j=i+1;j<=9;j++) {\\n\\n\\n\\t\\t\\t\\tsb.append(j); //append the digit j to the existing string builder\\n\\n\\t\\t\\t\\tint potential=Integer.valueOf(sb.toString());\\n\\n\\t\\t\\t\\t//check if the potnetial number meets the criteria low<potential>high, if yes add the number to the list\\n\\n\\t\\t\\t\\tif(potential>=low && potential<=high) {\\n\\t\\t\\t\\t\\tresults.add(potential);\\t\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//check if the potential is greater than the high break out of the inner loop and start with the different i as starting digit\\n\\t\\t\\t\\tif(potential>high) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tCollections.sort(results);\\n\\t\\treturn results;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1712589,
                "title": "python-recursive-explained-21-ms",
                "content": "Recursive explanation for the given problem:\\n\\nWe know that the first digit in an N-digit number is always non-zero i.e., lies in the range of 1 to 9 (inclusive). Keeping this condition in mind, we can implement a recursive function, which takes the following input parameters: \\n1. The number currently to be checked for satisfying the given conditions.\\n2. Which digit in that number is currently being looked at.\\n3. Lower bound of the range (given in the problem).\\n4. Upper bound of the range (given in the problem).\\n\\nWe check if the current number to be checked is in the permissible range or not i.e., **low<=current number<=high**. If so, this is one of the numbers we are looking for and hence add it to a list. Else, if the current number>high or current digit>=9, we can stop the recursion as either the current number and any other number after it, would be out of the permissible range or we have come to the end of the generated numbers. Otherwise, we go for a recursive call giving **((current number)x10+(current digit+1))**, **current digit+1**, **low** and **high** as parameters.\\nWhy so?\\n\\nTake example-1:\\nInput: low = 100, high = 300\\nOutput: [123,234]\\n\\nFirst we go with numbers starting with 1 and its the first digit as well.\\n1>=100 and 1<=300 False. Therefore, no appending to the list.\\n1>300 or 1>=9 False. Therefore, we need to continue recursion.\\nParameters for next recursion: \\n**((1x10+(1+1)), 1+1, low, high)=(12,2,low,high)**\\n\\n12>=100 and 12<=300 False. Therefore no appending to the list.\\n12>300 or 2>=9 False. Therefore, we need to continue recursion.\\n\\nParameters for next recursion: \\n**((12x10+(2+1)), 2+1, low, high)=(123,3,low,high)**\\n\\n123>=100 and 123<=300 True. \\u2705 This is one of the numbers we are looking for. Therefore append it to the list. Now continuing recursion for the digit 1 would be useless as 123>100. Therefore, we can stop the recursion here, and try all of these with 2 till 9.\\n\\n```\\nclass Solution(object):\\n    def sequentialDigits(self, low, high):\\n        \"\"\"\\n        :type low: int\\n        :type high: int\\n        :rtype: List[int]\\n        \"\"\"\\n        reqdNumbers=[]\\n        def generateNumbers(currentNum,currentDigit,low,high):\\n            if currentNum>=low and currentNum<=high:\\n                reqdNumbers.append(currentNum)\\n            if currentNum>high or currentDigit>=9:\\n                return\\n            generateNumbers((currentNum*10+(currentDigit+1)),currentDigit+1,low,high)\\n            \\n        for i in range(1,10):\\n            generateNumbers(i,i,low,high)\\n        reqdNumbers.sort()\\n        return reqdNumbers\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def sequentialDigits(self, low, high):\\n        \"\"\"\\n        :type low: int\\n        :type high: int\\n        :rtype: List[int]\\n        \"\"\"\\n        reqdNumbers=[]\\n        def generateNumbers(currentNum,currentDigit,low,high):\\n            if currentNum>=low and currentNum<=high:\\n                reqdNumbers.append(currentNum)\\n            if currentNum>high or currentDigit>=9:\\n                return\\n            generateNumbers((currentNum*10+(currentDigit+1)),currentDigit+1,low,high)\\n            \\n        for i in range(1,10):\\n            generateNumbers(i,i,low,high)\\n        reqdNumbers.sort()\\n        return reqdNumbers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712573,
                "title": "python-96-faster-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/68976c93-32b9-4112-840f-92293833a619_1642931696.4003627.png)\\n\\n```\\nd = {\\n    2: [8, 12, 23, 34, 45, 56, 67, 78, 89],\\n    3: [7, 123, 234, 345, 456, 567, 678, 789],\\n    4: [6, 1234, 2345, 3456, 4567, 5678, 6789],\\n    5: [5, 12345, 23456, 34567, 45678, 56789],\\n    6: [4, 123456, 234567, 345678, 456789],\\n    7: [3, 1234567, 2345678, 3456789],\\n    8: [2, 12345678, 23456789],\\n    9: [1, 123456789]\\n}\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        res = []\\n        l, h = str(low), str(high)\\n        \\n        k, lb = (len(l), int(l[0])) if d[len(l)][0] >= int(l[0]) else (len(l) + 1, 1)\\n        \\n        while True:\\n            if k > 9: return res\\n            for i in range(lb, len(d[k])):\\n                if low <= d[k][i] <= high: res.append(d[k][i])\\n                elif d[k][i] > high: break\\n            else:\\n                k, lb = k + 1, 1\\n                continue\\n            return res\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nd = {\\n    2: [8, 12, 23, 34, 45, 56, 67, 78, 89],\\n    3: [7, 123, 234, 345, 456, 567, 678, 789],\\n    4: [6, 1234, 2345, 3456, 4567, 5678, 6789],\\n    5: [5, 12345, 23456, 34567, 45678, 56789],\\n    6: [4, 123456, 234567, 345678, 456789],\\n    7: [3, 1234567, 2345678, 3456789],\\n    8: [2, 12345678, 23456789],\\n    9: [1, 123456789]\\n}\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        res = []\\n        l, h = str(low), str(high)\\n        \\n        k, lb = (len(l), int(l[0])) if d[len(l)][0] >= int(l[0]) else (len(l) + 1, 1)\\n        \\n        while True:\\n            if k > 9: return res\\n            for i in range(lb, len(d[k])):\\n                if low <= d[k][i] <= high: res.append(d[k][i])\\n                elif d[k][i] > high: break\\n            else:\\n                k, lb = k + 1, 1\\n                continue\\n            return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712503,
                "title": "c-100-beginner-friendly-basic-calculations",
                "content": "Basically this problem could be solved by some calculations at some specific points in the iteration.\\nWe need to calculate the first possible number by calculating the digits.\\nIf, low is 101, we will calculate the digits,i.e. 3 and require 3-1 = 2.\\nStart number could be 123 ,\\nWe need to multiply the  num (num X 10) plus the num%10+1.\\n1 =>1X10 +2 (12)  => 12X10+3(123).\\nNow, the number formed is 123 and if we clearly see we can figure out ther relation, 123 + 111 = 234\\n234+111 = 345.\\nSo we can use 23 from 123 and 23X10+(123%10+1) = 234.\\nWhen the num%10==9,  789 So, we cannot make the number 890+(9+1), we can increment the C(digits count) and make another initial number i.e. 1234.\\nThe loop goes till the number formed everytime is less than high.\\n\\nIf the thought-process was clear do Upvote. Thanks!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int calculateDigits(int n){\\n        int c=0;\\n        while(n){\\n            n/=10;\\n            c+=1;\\n        }\\n        return c-1;\\n    }\\n    \\n    int initialDigits(int c){\\n        int num = 1;\\n        while(c--){\\n            num = num*10+num%10+1;\\n        }\\n        return num;\\n    }\\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n        int c = calculateDigits(low);\\n        int start = initialDigits(c);\\n        cout<<c;\\n        vector<int> v;\\n        while(start<=high){\\n            // cout<<start<<\" \";\\n           if(start>=low)\\n               v.push_back(start);\\n            int k = pow(10,c);\\n            if(start%10==9){\\n                c++;\\n                start = initialDigits(c);   \\n            }\\n            else\\n                start = (start%k)*10+start%10+1;\\n            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int calculateDigits(int n){\\n        int c=0;\\n        while(n){\\n            n/=10;\\n            c+=1;\\n        }\\n        return c-1;\\n    }\\n    \\n    int initialDigits(int c){\\n        int num = 1;\\n        while(c--){\\n            num = num*10+num%10+1;\\n        }\\n        return num;\\n    }\\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n        int c = calculateDigits(low);\\n        int start = initialDigits(c);\\n        cout<<c;\\n        vector<int> v;\\n        while(start<=high){\\n            // cout<<start<<\" \";\\n           if(start>=low)\\n               v.push_back(start);\\n            int k = pow(10,c);\\n            if(start%10==9){\\n                c++;\\n                start = initialDigits(c);   \\n            }\\n            else\\n                start = (start%k)*10+start%10+1;\\n            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1712421,
                "title": "c-0ms-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> sq;\\n        for(int i = 1; i < 10; i++) {\\n            long ans = i;\\n            sq.push_back(ans);\\n            for(int j = i + 1; j < 10; j++)\\n                ans = ans * 10 + j, sq.push_back(ans);\\n        }\\n        vector<int> v;\\n        for(auto it: sq)\\n            if(it>= low && it <= high)\\n                v.push_back(it);\\n        sort(v.begin(), v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> sq;\\n        for(int i = 1; i < 10; i++) {\\n            long ans = i;\\n            sq.push_back(ans);\\n            for(int j = i + 1; j < 10; j++)\\n                ans = ans * 10 + j, sq.push_back(ans);\\n        }\\n        vector<int> v;\\n        for(auto it: sq)\\n            if(it>= low && it <= high)\\n                v.push_back(it);\\n        sort(v.begin(), v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712125,
                "title": "c-easy-to-understand-0ms-beats-100",
                "content": "**Logic for code**\\nThere are only limited possiblities.\\n12 123 1234 12345 123456 1234567 12345678 123456789\\n23 234 2345 23456 234567 2345678 23456789\\n34 345 3456 34567 345678 3456789\\n45 456 4567 45678 456789\\n56 567 5678 56789\\n67 678 6789\\n78 789\\n89\\n\\nSo we will check every number mentioned above which are in [low,high] and pushback them in answer vector.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        for(int i=1;i<=9;i++)\\n        {\\n            int j = i;\\n            while(j<=high)\\n            {\\n                if(j>=low)\\n                    ans.push_back(j);\\n                if(j%10==9)\\n                    break;\\n                j = (j*10)+(j%10+1);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        for(int i=1;i<=9;i++)\\n        {\\n            int j = i;\\n            while(j<=high)\\n            {\\n                if(j>=low)\\n                    ans.push_back(j);\\n                if(j%10==9)\\n                    break;\\n                j = (j*10)+(j%10+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1711982,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions-for-sequential-digits",
                "content": "\\n```\\nvector<int> sequentialDigits(int low, int high) {\\n        string l=\"\",h=\"\";\\n        vector<int> ans;\\n        int temp,i,j,k,remain;\\n        temp=low;\\n        int s1=0,s2=0;\\n        while(temp>0)\\n        {\\n            s1++;\\n            temp=temp/10;\\n        }\\n        temp=high;\\n        while(temp>0)\\n        {\\n            s2++;\\n            temp=temp/10;\\n        }\\n        string dig=\"\";\\n        int sizedig=0;\\n        int flag=0;\\n        for(j=s1;j<=s2 && flag==0;j++)\\n        {\\n            dig=\"\";\\n            sizedig=0;\\n            for(i=1;i<=9;i++)\\n            {\\n                if(sizedig==j-1)\\n                {\\n                    dig+=i+\\'0\\';\\n                    if(stoi(dig)<=high && stoi(dig)>=low )\\n                    {\\n                        ans.push_back(stoi(dig));\\n                    }\\n                    else if(stoi(dig)>high)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    dig.erase(dig.begin());\\n                }\\n                else\\n                {\\n                    dig+=i+\\'0\\';\\n                    sizedig++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n\\n\\nComplexity : O((digit of H)*9)=O(digit of H)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nvector<int> sequentialDigits(int low, int high) {\\n        string l=\"\",h=\"\";\\n        vector<int> ans;\\n        int temp,i,j,k,remain;\\n        temp=low;\\n        int s1=0,s2=0;\\n        while(temp>0)\\n        {\\n            s1++;\\n            temp=temp/10;\\n        }\\n        temp=high;\\n        while(temp>0)\\n        {\\n            s2++;\\n            temp=temp/10;\\n        }\\n        string dig=\"\";\\n        int sizedig=0;\\n        int flag=0;\\n        for(j=s1;j<=s2 && flag==0;j++)\\n        {\\n            dig=\"\";\\n            sizedig=0;\\n            for(i=1;i<=9;i++)\\n            {\\n                if(sizedig==j-1)\\n                {\\n                    dig+=i+\\'0\\';\\n                    if(stoi(dig)<=high && stoi(dig)>=low )\\n                    {\\n                        ans.push_back(stoi(dig));\\n                    }\\n                    else if(stoi(dig)>high)\\n                    {\\n                        flag=1;\\n                        break;\\n                    }\\n                    dig.erase(dig.begin());\\n                }\\n                else\\n                {\\n                    dig+=i+\\'0\\';\\n                    sizedig++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711871,
                "title": "arithmetic-progression-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        for(int i=1;i<10;i++){\\n            int no = i;\\n            for(int j=i+1;j<10;j++){\\n                no = no *10 + j;\\n                if(no >= low and no <= high){\\n                    ans.push_back(no);\\n                }\\n            }\\n        }\\n        sort(begin(ans),end(ans));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        for(int i=1;i<10;i++){\\n            int no = i;\\n            for(int j=i+1;j<10;j++){\\n                no = no *10 + j;\\n                if(no >= low and no <= high){\\n                    ans.push_back(no);\\n                }\\n            }\\n        }\\n        sort(begin(ans),end(ans));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711824,
                "title": "go-bfs-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\n```\\nfunc sequentialDigits(low int, high int) []int {\\n\\tvar q []int\\n\\tfor i := 1; i <= 9; i++ {\\n\\t\\tq = append(q, i)\\n\\t}\\n\\n\\tvar ret []int\\n\\tfor len(q) > 0 {\\n\\t\\tn := q[0]\\n\\t\\tq = q[1:]\\n\\t\\tif n <= high && n >= low {\\n\\t\\t\\tret = append(ret, n)\\n\\t\\t}\\n\\n\\t\\tif n > high {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tnum := n % 10\\n\\t\\tif num < 9 {\\n\\t\\t\\tq = append(q, n*10+(num+1))\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc sequentialDigits(low int, high int) []int {\\n\\tvar q []int\\n\\tfor i := 1; i <= 9; i++ {\\n\\t\\tq = append(q, i)\\n\\t}\\n\\n\\tvar ret []int\\n\\tfor len(q) > 0 {\\n\\t\\tn := q[0]\\n\\t\\tq = q[1:]\\n\\t\\tif n <= high && n >= low {\\n\\t\\t\\tret = append(ret, n)\\n\\t\\t}\\n\\n\\t\\tif n > high {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tnum := n % 10\\n\\t\\tif num < 9 {\\n\\t\\t\\tq = append(q, n*10+(num+1))\\n\\t\\t}\\n\\t}\\n\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711812,
                "title": "python-simple-approach-recursion-dp-dfs-backtracking-easy-to-understand",
                "content": "**Approach:** All elements would contains only 1 to 9 number and only unique number. So, just create the numbers in the given constrain and check the bound. Then sort the list and return it. \\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        ans=[]\\n        for i in range(1,10):\\n            temp=i\\n            for j in range(i+1,10):\\n                temp=10*temp+j\\n                if temp in range(low,high+1):\\n                    ans.append(temp)\\n        ans.sort()\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        ans=[]\\n        for i in range(1,10):\\n            temp=i\\n            for j in range(i+1,10):\\n                temp=10*temp+j\\n                if temp in range(low,high+1):\\n                    ans.append(temp)\\n        ans.sort()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292501,
                "title": "c-two-simple-solutions",
                "content": "**1.Using BFS:**\\n```\\nvector<int> sequentialDigits(int low, int high) {\\n\\tqueue<int> q;\\n\\tfor (int i = 1; i <= 9; i++)\\n\\t\\tq.push(i);\\n\\tvector<int> res;\\n\\twhile (!q.empty()) {\\n\\t\\tint cur = q.front(); q.pop();\\n\\t\\tif (cur >= low && cur <= high)\\n\\t\\t\\tres.push_back(cur);\\n\\t\\tint next = cur * 10 + cur % 10 + 1;\\n\\t\\tif (next % 10 && next <= high)\\n\\t\\t\\tq.push(next);\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n**2. Storing all the possible values in a vector and comparing:**\\n```\\nvector<int> sequentialDigits(int low, int high) {\\n\\tvector<int> nums = {12, 23, 34, 45, 56, 67, 78, 89,\\n\\t                    123, 234, 345, 456, 567, 678, 789,\\n\\t                    1234, 2345, 3456, 4567, 5678, 6789,\\n\\t                    12345, 23456, 34567, 45678, 56789,\\n\\t                    123456, 234567, 345678, 456789,\\n\\t                    1234567, 2345678, 3456789,\\n\\t                    12345678, 23456789,\\n\\t                    123456789\\n\\t                   };\\n\\tvector<int> res;\\n\\tfor (auto& i : nums)\\n\\t\\tif (i >= low && i <= high)\\n\\t\\t\\tres.push_back(i);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nvector<int> sequentialDigits(int low, int high) {\\n\\tqueue<int> q;\\n\\tfor (int i = 1; i <= 9; i++)\\n\\t\\tq.push(i);\\n\\tvector<int> res;\\n\\twhile (!q.empty()) {\\n\\t\\tint cur = q.front(); q.pop();\\n\\t\\tif (cur >= low && cur <= high)\\n\\t\\t\\tres.push_back(cur);\\n\\t\\tint next = cur * 10 + cur % 10 + 1;\\n\\t\\tif (next % 10 && next <= high)\\n\\t\\t\\tq.push(next);\\n\\t}\\n\\treturn res;\\n}\\n```\n```\\nvector<int> sequentialDigits(int low, int high) {\\n\\tvector<int> nums = {12, 23, 34, 45, 56, 67, 78, 89,\\n\\t                    123, 234, 345, 456, 567, 678, 789,\\n\\t                    1234, 2345, 3456, 4567, 5678, 6789,\\n\\t                    12345, 23456, 34567, 45678, 56789,\\n\\t                    123456, 234567, 345678, 456789,\\n\\t                    1234567, 2345678, 3456789,\\n\\t                    12345678, 23456789,\\n\\t                    123456789\\n\\t                   };\\n\\tvector<int> res;\\n\\tfor (auto& i : nums)\\n\\t\\tif (i >= low && i <= high)\\n\\t\\t\\tres.push_back(i);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1286658,
                "title": "js-very-simple-iteration-solution",
                "content": "The minimum number that is valid is 12 and the maximum is 123456789. Every valid number is a substring of the string \\'123456789\\'. We slice out valid numbers from the string, convert it to Integer and check for the >= low and <= high condition before adding it to our result array.\\n```\\nvar sequentialDigits = function (low, high) {\\n  let result = [];\\n  let base = \\'123456789\\';\\n  for(let i = 2; i <= 9; i++){\\n    for(let j = 0; j <= 9-i; j++){\\n      let num = Number(base.slice(j, j+i));\\n      if(num >= low && num <= high) result.push(num);\\n    }\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nvar sequentialDigits = function (low, high) {\\n  let result = [];\\n  let base = \\'123456789\\';\\n  for(let i = 2; i <= 9; i++){\\n    for(let j = 0; j <= 9-i; j++){\\n      let num = Number(base.slice(j, j+i));\\n      if(num >= low && num <= high) result.push(num);\\n    }\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 926405,
                "title": "java-100-very-short-solution-quick-generation-using-only-math-no-queues-or-parsing",
                "content": "0ms 100% faster Solution\\nDoes NOT use queues, backtracking, or any String parsing.\\n\\nI dont usually post, but I did not find any similar solutions to mine despite my solution being deviously simple. So here it is, with a detailed explaination. \\n\\nApproach: \\n- Generate all digits up to \\'high\\', and while doing so only store only the values above \\'low\\'.\\n- For generation, we use some math wizard-ry instead of parsing or using queues or backtracking. \\n\\nHow do we generate the numbers?\\n- Algorithmically, we add 1 to every digit in our number, to do this we start off by adding 11 to our starting number; 1. Starting at 1, we add 11 to make 12, add 11, makes 23 and so on until we get 89. At 89 something unique happens, adding 11 results in 100, which is divisible by 10. all sequential digit numbers dont divide by 10 so this makes (number % 10) a very good condition to find out when we should add our next digit and start generating again. This is guaranteed to happen everytime the last sequential digit is a 9 (789 + 111 = 900, 6789 +1111 = 7900, etc..)\\n- When this condition triggers, we add another \\'1\\' to our additive, which in this case is 11 by doing :  11 * 10 + 1 =  111\\nThis variable is known as our \\'additive\\' since we keep adding it once every loop. we can use it to fix the number before adding the new digit.\\n- We \\'fix\\' our number using the formula : number = number + (number of digits * additive) + 1\\n(Note: in my code the number of current digits is represented by \\'multiplier\\')\\n- Our loop continues to generate numbers in this fashion until we pass the \\'high\\' value and stops right there.\\n\\n>Here is a sample run:\\n>\\n> 1     +11\\n12   +11\\n23   +11\\n...\\n89   +11\\n100   \\n\\ntrigger special condition:    100 + 11 * 2 + 1 = 123\\nupdate additive       11 -> 11 * 10 + 1 -> 111\\n>123 + 111\\n234 + 111\\n...\\n789 + 111\\n900   \\n\\ntrigger special condition:    900 + 111 * 3 + 1 = 1234\\nupdate additive       11 -> 11 * 10 + 1 -> 111\\n>1234   +1111\\n2345   +1111\\nand so on...\\n\\n``` \\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        int number = 1;\\n        int additive = 11;\\n        int multiplier = 2;\\n        \\n        while(number <= high){\\n            \\n            number += additive;\\n            \\n            if(number % 10 == 0){\\n                number = number + multiplier*additive + 1;\\n                additive = additive*10 + 1;\\n                multiplier += 1;\\n            }\\n            \\n            if(low <= number && number <= high)\\n                res.add(number);   \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        int number = 1;\\n        int additive = 11;\\n        int multiplier = 2;\\n        \\n        while(number <= high){\\n            \\n            number += additive;\\n            \\n            if(number % 10 == 0){\\n                number = number + multiplier*additive + 1;\\n                additive = additive*10 + 1;\\n                multiplier += 1;\\n            }\\n            \\n            if(low <= number && number <= high)\\n                res.add(number);   \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867330,
                "title": "python-by-simple-iteration-w-comment",
                "content": "Python by simple iteration\\n\\n---\\n\\n**Implementation** by iteration:\\n\\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        \\n        result = []\\n        \\n        # scan all possible first digit\\n        for first_digit in range(1, 10):\\n            \\n            cur_num = first_digit\\n            \\n            # growing based on first digit\\n            for next_digit in range(first_digit + 1, 10):\\n                \\n\\t\\t\\t\\t# growing with sequential digit\\n                cur_num = cur_num * 10 + next_digit\\n                \\n                if low <= cur_num <= high:\\n                    # check current number is in range or not\\n                    result.append(cur_num)\\n                    \\n        return sorted(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        \\n        result = []\\n        \\n        # scan all possible first digit\\n        for first_digit in range(1, 10):\\n            \\n            cur_num = first_digit\\n            \\n            # growing based on first digit\\n            for next_digit in range(first_digit + 1, 10):\\n                \\n\\t\\t\\t\\t# growing with sequential digit\\n                cur_num = cur_num * 10 + next_digit\\n                \\n                if low <= cur_num <= high:\\n                    # check current number is in range or not\\n                    result.append(cur_num)\\n                    \\n        return sorted(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856650,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @return {number[]}\\n */\\nvar sequentialDigits = function(low, high) {\\n    \\n    let ll = low.toString().length,\\n        hh = high.toString().length,\\n        str = \"123456789\",\\n        result = [];\\n      \\n    for (let i=ll; i<=hh;i++){\\n        for (let j=0;j<10-i;j++){\\n            console.log(\"hello\")\\n            let num = parseInt(str.substring(j, j + i));\\n            if (num >= low && num <= high){\\n                result.push(num);\\n                \\n            }\\n            \\n        }\\n        \\n    }\\n    return result;\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @return {number[]}\\n */\\nvar sequentialDigits = function(low, high) {\\n    \\n    let ll = low.toString().length,\\n        hh = high.toString().length,\\n        str = \"123456789\",\\n        result = [];\\n      \\n    for (let i=ll; i<=hh;i++){\\n        for (let j=0;j<10-i;j++){\\n            console.log(\"hello\")\\n            let num = parseInt(str.substring(j, j + i));\\n            if (num >= low && num <= high){\\n                result.push(num);\\n                \\n            }\\n            \\n        }\\n        \\n    }\\n    return result;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855420,
                "title": "python-1-liner-without-sorting-24ms",
                "content": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        return [n for s in range(9) for i in range(9-s) if low<=(n:=int(\\'123456789\\'[i:i+s+1]))<=high]\\n```\\ns - length of number in string representation;\\ni - index of first digit\\n\\nNote: it is possible to remove 3 white-spaces.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        return [n for s in range(9) for i in range(9-s) if low<=(n:=int(\\'123456789\\'[i:i+s+1]))<=high]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854665,
                "title": "c-vector-based-solution-explained-100-time-55-space",
                "content": "In order to work on this kind of problems where you need to compare numbers on a digit-by-digit basis, one of the most common approach is to work with strings; I don\\'t like it and usually it is much more efficient to convert them into array/vectors of digits, which is what I did with `numToVec`; since I also needed to return proper numbers after my work, I also created the specular helper function `vecToNum`.\\n\\nThey seem rather straightfoward to me, but if something is not clear, feel free to ask :)\\n\\nIn my main function I will use my first helper so that I will have 2 vectors:\\n* `nextV`, our starting point and representing the parameter `low`, digit by digit;\\n* `res` that will store our sub-results as we go.\\n\\nBefore I also had `topV`, specularly representing `high` as a vector; in my earlier version of the code I was working more on its digits, while now I basically just check its length, so I moved that info to `highLen`, one of the 2 `int`s I declare, together with `nextV`.\\n\\nI will have then a while loop running as long as `nextV.size() <= highLen` (no point in checking numbers with more digits than `high`, since they would be of course out of range).\\n\\nI would then move on to modify `nextV` so that each digit in it is strictly greater than the previou one by `1`, so, if for example `low` was `2000`, `nextV` will be now `{2, 3, 4, 5}`.\\n\\nIf the last digit ends up above `9`, we break out of the inner loop.\\n\\nAfter that, time to compute `nextN` (no point in comparing vectors as I planned to do with `topV`, since what we need to return is indeed a series of numbers), using our other helper. In our previous example, `nextN` would be `2345`.\\n\\nNotice that I am also checking if `nextN >= low`, since, if for example `low == 2500`, then the value of `2345` would be out of range; other than that, we need it also to have `nextV <= high`. If both conditions are met, `nextV` goes straight into `res`.\\n\\nTo optimise a bit more, we might also opt to quit when `nextN > high`: this time not just from the inner loop, but from the whole functioon, returning `res`.\\n\\nIf we are still in the inner loop, we increase the first digit (`nextV[0]`) by one and move again.\\n\\nWhen we exit the inner loop, we move on increasing the digits in `nextV` and resetting its first digit to `1`.\\n\\nRinse and repeat until the outer loop is done and, if you did not return before, you can now return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // turning numbers into vectors...\\n    vector<int> numToVec(int n) {\\n        vector<int> res;\\n        while (n) {\\n            res.push_back(n % 10);\\n            n /= 10;\\n        }\\n        reverse(begin(res), end(res));\\n        return res;\\n    }\\n    // ... and turning vectors into numbers\\n    int vecToNum(vector<int> v) {\\n        int res = 0;\\n        for (int n: v) res = res * 10 + n;\\n        return res;\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> nextV = numToVec(low), res;\\n        int nextN, highLen = numToVec(high).size();\\n        while (nextV.size() <= highLen) {\\n            do {\\n                for (int i = 1; i < nextV.size(); i++) nextV[i] = nextV[i - 1] + 1;\\n                // exit condition\\n                if (nextV.back() > 9) break;\\n                // adding to res if nextV is in the low-high range\\n                nextN = vecToNum(nextV);\\n                if (nextN >= low && nextN <= high) res.push_back(nextN);\\n                // further exit condition\\n                if (nextN > high) return res;\\n                // preparing for the next run!\\n                nextV[0]++;\\n            } while (true);\\n            // preparing nextV for the next round, adding one digit and resetting the first to 1\\n            nextV.push_back(0);\\n            nextV[0] = 1;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nI am certain an alternative take using an array of `9` elements (the maximum you will have for this problem) and one index to keep track of how many cells we can use would consume less memory, but I felt somehow lazy/bored by the problem and decided not too code it. Not for now, at least.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // turning numbers into vectors...\\n    vector<int> numToVec(int n) {\\n        vector<int> res;\\n        while (n) {\\n            res.push_back(n % 10);\\n            n /= 10;\\n        }\\n        reverse(begin(res), end(res));\\n        return res;\\n    }\\n    // ... and turning vectors into numbers\\n    int vecToNum(vector<int> v) {\\n        int res = 0;\\n        for (int n: v) res = res * 10 + n;\\n        return res;\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> nextV = numToVec(low), res;\\n        int nextN, highLen = numToVec(high).size();\\n        while (nextV.size() <= highLen) {\\n            do {\\n                for (int i = 1; i < nextV.size(); i++) nextV[i] = nextV[i - 1] + 1;\\n                // exit condition\\n                if (nextV.back() > 9) break;\\n                // adding to res if nextV is in the low-high range\\n                nextN = vecToNum(nextV);\\n                if (nextN >= low && nextN <= high) res.push_back(nextN);\\n                // further exit condition\\n                if (nextN > high) return res;\\n                // preparing for the next run!\\n                nextV[0]++;\\n            } while (true);\\n            // preparing nextV for the next round, adding one digit and resetting the first to 1\\n            nextV.push_back(0);\\n            nextV[0] = 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854614,
                "title": "c-o-1-very-easy-beats-99-8-0-ms",
                "content": "**Note: stoi() function is used to convert a string to integer**\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        int i,j;\\n        vector<int>v;\\n        string s=\"\";\\n        for(i=1;i<=9;i++)\\n        {\\n            s=to_string(i);\\n            for(j=i+1;j<=9;j++)\\n            {\\n                s+=to_string(j);\\n                if(stoi(s)>=low and stoi(s)<=high)\\n                    v.push_back(stoi(s));\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        int i,j;\\n        vector<int>v;\\n        string s=\"\";\\n        for(i=1;i<=9;i++)\\n        {\\n            s=to_string(i);\\n            for(j=i+1;j<=9;j++)\\n            {\\n                s+=to_string(j);\\n                if(stoi(s)>=low and stoi(s)<=high)\\n                    v.push_back(stoi(s));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 854531,
                "title": "php-solution-using-123456789-and-substring",
                "content": "```\\nfunction sequentialDigits($low, $high) {\\n        $nums = [];\\n        $s = \\'123456789\\';\\n        \\n        for($digits = strlen($low); $digits <= strlen($high); $digits++)\\n            for($start = 0; ($start+$digits) <= 9; $start++) {\\n                $num = (int)substr($s, $start, $digits);\\n                if($num > $high) return $nums;\\n                if($num >= $low) $nums[] = $num;\\n            }\\n        \\n        return $nums;\\n    }\\n```\\n\\t\\nRuntime: 8 ms, faster than 100.00% of PHP online submissions for Sequential Digits. \\nMemory Usage: 14.9 MB, less than 100.00% of PHP online submissions for Sequential Digits.\\n\\nif you like solution, upvote please!",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction sequentialDigits($low, $high) {\\n        $nums = [];\\n        $s = \\'123456789\\';\\n        \\n        for($digits = strlen($low); $digits <= strlen($high); $digits++)\\n            for($start = 0; ($start+$digits) <= 9; $start++) {\\n                $num = (int)substr($s, $start, $digits);\\n                if($num > $high) return $nums;\\n                if($num >= $low) $nums[] = $num;\\n            }\\n        \\n        return $nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 853863,
                "title": "c-faster-than-100-simple-solution-with-explanation",
                "content": "This code is divide into **two part**:\\n\\n1. generate index list from initail array.for example,if **low** = 10 and **high** = 1000.The digit will sort likes that **12** -> 23 -> 34 ... ->89 -> **123** -> 234 ... -> 789 .So we choose the start element(ex:12,123...) form initial array.\\n\\n2. Then we use a for loop to run all element from index list.and add **carr[ i ]** to **initial[ index[ i ] ]** of start number.for example.12+11 = 23, 23+11=34......78+11 = 8**9**.loop will break when the **first** digits reach 9.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {     \\n        int initial[9] = {1,12,123,1234,12345,123456,1234567,12345678,123456789};\\n        int carry[9] ={1,11,111,1111,11111,111111,1111111,11111111,111111111};\\n        vector<int> index;\\n        vector<int> result;\\n        \\n        if(low >= 123456789) return result;\\n        \\n        //generate actice initial element to index\\n        for(int i=0;i<9;i++){\\n            if(initial[i] >=low && initial[i] <= high){\\n                index.push_back(i);\\n            }else{\\n                // if number is bigger than low but smaller than low * carry[i] \\n                int temp = initial[i];\\n                while(temp <= high){\\n                    temp += carry[i];\\n                    if(temp >= low && temp <= high){\\n                        result.push_back(temp);                   \\n                    }            \\n                    if(temp%10==9){\\n                        break;\\n                    }\\n                }\\n            }    \\n        }\\n        \\n        //generate all list\\n        for(int i=0;i<index.size();i++){           \\n            int temp = initial[index[i]];\\n            while(temp <= high){               \\n                result.push_back(temp);\\n                \\n                 if(temp%10 == 9){\\n                    break;\\n                }\\n                temp+= carry[index[i]];\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {     \\n        int initial[9] = {1,12,123,1234,12345,123456,1234567,12345678,123456789};\\n        int carry[9] ={1,11,111,1111,11111,111111,1111111,11111111,111111111};\\n        vector<int> index;\\n        vector<int> result;\\n        \\n        if(low >= 123456789) return result;\\n        \\n        //generate actice initial element to index\\n        for(int i=0;i<9;i++){\\n            if(initial[i] >=low && initial[i] <= high){\\n                index.push_back(i);\\n            }else{\\n                // if number is bigger than low but smaller than low * carry[i] \\n                int temp = initial[i];\\n                while(temp <= high){\\n                    temp += carry[i];\\n                    if(temp >= low && temp <= high){\\n                        result.push_back(temp);                   \\n                    }            \\n                    if(temp%10==9){\\n                        break;\\n                    }\\n                }\\n            }    \\n        }\\n        \\n        //generate all list\\n        for(int i=0;i<index.size();i++){           \\n            int temp = initial[index[i]];\\n            while(temp <= high){               \\n                result.push_back(temp);\\n                \\n                 if(temp%10 == 9){\\n                    break;\\n                }\\n                temp+= carry[index[i]];\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853850,
                "title": "python-in-3-lines",
                "content": "```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        s = \\'123456789\\'\\n        all_possible = [int(s[i:j]) for i, j in combinations(range(len(s) + 1), 2)]\\n        return sorted(x for x in all_possible if low <= x <= high)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        s = \\'123456789\\'\\n        all_possible = [int(s[i:j]) for i, j in combinations(range(len(s) + 1), 2)]\\n        return sorted(x for x in all_possible if low <= x <= high)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 853848,
                "title": "very-simple-java-solution-beating-100-java-solutions",
                "content": "```\\nclass Solution {\\n\\tint[] num= {12, 23, 34, 45, 56, 67, 78, 89, 123, 234, 345, 456, 567, 678, 789, 1234, 2345, 3456, 4567, 5678, 6789, 12345, 23456, 34567, 45678, 56789, 123456, 234567, 345678, 456789, 1234567, 2345678, 3456789, 12345678, 23456789, 123456789}; \\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> numbers=new ArrayList<Integer>();\\n        for(int i=0;i<num.length;i++) {\\n        \\tif(num[i]>=low && num[i]<=high) \\n        \\t\\tnumbers.add(num[i]);\\n        }\\n        return numbers;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\tint[] num= {12, 23, 34, 45, 56, 67, 78, 89, 123, 234, 345, 456, 567, 678, 789, 1234, 2345, 3456, 4567, 5678, 6789, 12345, 23456, 34567, 45678, 56789, 123456, 234567, 345678, 456789, 1234567, 2345678, 3456789, 12345678, 23456789, 123456789}",
                "codeTag": "Java"
            },
            {
                "id": 853792,
                "title": "c-linq-one-liner",
                "content": "```csharp\\npublic IList<int> SequentialDigits(int low, int high) =>\\n\\t(from numberOfDigits in Enumerable.Range((int)Math.Log10(low) + 1, (int)Math.Log10(high) - (int)Math.Log10(low) + 1)\\n\\t from startingDigit in Enumerable.Range(1, 10 - numberOfDigits)\\n\\t select Enumerable.Range(startingDigit, numberOfDigits).Aggregate((p, n) => p * 10 + n) into number\\n\\t where low <= number && number <= high\\n\\t select number).ToArray();\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic IList<int> SequentialDigits(int low, int high) =>\\n\\t(from numberOfDigits in Enumerable.Range((int)Math.Log10(low) + 1, (int)Math.Log10(high) - (int)Math.Log10(low) + 1)\\n\\t from startingDigit in Enumerable.Range(1, 10 - numberOfDigits)\\n\\t select Enumerable.Range(startingDigit, numberOfDigits).Aggregate((p, n) => p * 10 + n) into number\\n\\t where low <= number && number <= high\\n\\t select number).ToArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 853707,
                "title": "c-solution-too-easy-fast-to-be-ignored",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> n{12,23,34,45,56,67,78,89,\\n\\t\\t\\t\\t  123,234,345,456,567,678,789,\\n\\t\\t\\t\\t  1234,2345,3456,4567,5678,6789,\\n\\t\\t\\t\\t  12345,23456,34567,45678,56789,\\n                  123456,234567,345678,456789,\\n\\t\\t\\t\\t  1234567,2345678,3456789,\\n\\t\\t\\t\\t  12345678,23456789,\\n                  123456789};\\n\\t\\t\\t\\t  \\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> res;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>high)\\n                break;\\n            if(n[i]>=low)\\n                res.push_back(n[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n* Upvote if you like this solution.\\n* Open for discussion.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> n{12,23,34,45,56,67,78,89,\\n\\t\\t\\t\\t  123,234,345,456,567,678,789,\\n\\t\\t\\t\\t  1234,2345,3456,4567,5678,6789,\\n\\t\\t\\t\\t  12345,23456,34567,45678,56789,\\n                  123456,234567,345678,456789,\\n\\t\\t\\t\\t  1234567,2345678,3456789,\\n\\t\\t\\t\\t  12345678,23456789,\\n                  123456789};\\n\\t\\t\\t\\t  \\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> res;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]>high)\\n                break;\\n            if(n[i]>=low)\\n                res.push_back(n[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853629,
                "title": "simple-solution-with-explanation-java-c-100-faster-in-time",
                "content": "The idea is to generate all numbers with sequential digits and check if they are in the given range. So start with \\'1,2,3...9\\' as most singificant digit and try to generate all possible number by appending a digit one more than previous digit. An example will help in understanding:\\n```\\n\\tlet\\'s say: low = 100, high = 300\\n\\tstart = 1\\n\\t\\tnum = start\\n\\t\\tpreviousDgit = start\\n\\t\\tcheck if num=1 is in range of (low,high). No, so don\\'t add to answer set.\\n\\t\\ttry : num*10 + (previousDgit + 1) = 1*10 + (1+1) = 12\\n\\t\\t\\t  check if num=12 is in range of (low,high). No, so don\\'t add to answer set\\n\\t\\t\\t  update previousDgit = previousDgit+1\\n\\t\\ttry : num*10 + (previousDgit + 1) = 12*10 + (2+1) = 123\\n\\t\\t\\t  check if num=123 is in range of (low,high). Yes, so add to answer set.\\n\\t\\t\\t  update previousDgit = previousDgit+1\\n\\t\\ttry: num*10 + (previousDgit + 1) = 123*10 + (3+1) = 1234\\n\\t\\t\\t check if num=1234 is in range of (low,high). No, so don\\'t add to answer set. Notice, num>high, so break the loop.\\n\\tagain, start = 2\\n\\t\\tnum = start\\n\\t\\tpreviousDgit = start\\n\\t\\tcheck if num=2 is in range of (low,high). No, so don\\'t add to answer set.\\n\\t\\ttry : num*10 + (previousDgit + 1) = 2*10 + (2+1) = 23\\n\\t\\t\\t  check if num=23 is in range of (low,high). No, so don\\'t add to answer set\\n\\t\\t\\t  update previousDgit = previousDgit+1\\n\\t\\ttry : num*10 + (previousDgit + 1) = 23*10 + (3+1) = 234\\n\\t\\t\\t  check if num=234 is in range of (low,high). Yes, so add to answer set.\\n\\t\\t\\t  update previousDgit = previousDgit+1\\n\\t\\ttry: num*10 + (previousDgit + 1) = 234*10 + (4+1) = 2345\\n\\t\\t\\t check if num=2345 is in range of (low,high). No, so don\\'t add to answer set. Notice, num>high, so break the loop.\\n```\\nsimilarly you can dry run other cases.\\n```\\nNote: when previous digit is 9, you can\\'t add anymore digit to num. \\nso, when previous digit is 9, break the loop.\\n```\\n\\t\\n\\nFollowing is Java implementation\\n```\\t\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        ArrayList<Integer> ans = new ArrayList<Integer>();\\n        for(int start = 1;start<=9;start++){\\n            int num = start, previousDigit = start;\\n            while(num<=high){\\n                if(num>=low)\\n                    ans.add(num);\\n                if(previousDigit == 9)\\n                    break;\\n                previousDigit++;\\n                num = num*10+previousDigit;\\n            }\\n        }\\n        Collections.sort(ans);\\n        return ans;\\n    }\\n}\\n```\\nFollowing is C++ implementation\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        for(int start=1;start<=9;start++){\\n            int num = start, prev = start;\\n            while(num<=high){\\n                if(num>=low)  \\n\\t\\t\\t\\t\\tans.push_back(num);\\n                if(prev == 9) \\n\\t\\t\\t\\t\\tbreak;\\n                prev++;\\n\\t\\t\\t\\tnum = num*10+prev;\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\tlet\\'s say: low = 100, high = 300\\n\\tstart = 1\\n\\t\\tnum = start\\n\\t\\tpreviousDgit = start\\n\\t\\tcheck if num=1 is in range of (low,high). No, so don\\'t add to answer set.\\n\\t\\ttry : num*10 + (previousDgit + 1) = 1*10 + (1+1) = 12\\n\\t\\t\\t  check if num=12 is in range of (low,high). No, so don\\'t add to answer set\\n\\t\\t\\t  update previousDgit = previousDgit+1\\n\\t\\ttry : num*10 + (previousDgit + 1) = 12*10 + (2+1) = 123\\n\\t\\t\\t  check if num=123 is in range of (low,high). Yes, so add to answer set.\\n\\t\\t\\t  update previousDgit = previousDgit+1\\n\\t\\ttry: num*10 + (previousDgit + 1) = 123*10 + (3+1) = 1234\\n\\t\\t\\t check if num=1234 is in range of (low,high). No, so don\\'t add to answer set. Notice, num>high, so break the loop.\\n\\tagain, start = 2\\n\\t\\tnum = start\\n\\t\\tpreviousDgit = start\\n\\t\\tcheck if num=2 is in range of (low,high). No, so don\\'t add to answer set.\\n\\t\\ttry : num*10 + (previousDgit + 1) = 2*10 + (2+1) = 23\\n\\t\\t\\t  check if num=23 is in range of (low,high). No, so don\\'t add to answer set\\n\\t\\t\\t  update previousDgit = previousDgit+1\\n\\t\\ttry : num*10 + (previousDgit + 1) = 23*10 + (3+1) = 234\\n\\t\\t\\t  check if num=234 is in range of (low,high). Yes, so add to answer set.\\n\\t\\t\\t  update previousDgit = previousDgit+1\\n\\t\\ttry: num*10 + (previousDgit + 1) = 234*10 + (4+1) = 2345\\n\\t\\t\\t check if num=2345 is in range of (low,high). No, so don\\'t add to answer set. Notice, num>high, so break the loop.\\n```\n```\\nNote: when previous digit is 9, you can\\'t add anymore digit to num. \\nso, when previous digit is 9, break the loop.\\n```\n```\\t\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        ArrayList<Integer> ans = new ArrayList<Integer>();\\n        for(int start = 1;start<=9;start++){\\n            int num = start, previousDigit = start;\\n            while(num<=high){\\n                if(num>=low)\\n                    ans.add(num);\\n                if(previousDigit == 9)\\n                    break;\\n                previousDigit++;\\n                num = num*10+previousDigit;\\n            }\\n        }\\n        Collections.sort(ans);\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        for(int start=1;start<=9;start++){\\n            int num = start, prev = start;\\n            while(num<=high){\\n                if(num>=low)  \\n\\t\\t\\t\\t\\tans.push_back(num);\\n                if(prev == 9) \\n\\t\\t\\t\\t\\tbreak;\\n                prev++;\\n\\t\\t\\t\\tnum = num*10+prev;\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649732,
                "title": "java-beats-100-time-and-memory-simple-loops-solution",
                "content": "```\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int begln = len(low);\\n        int endln = len(high);\\n        List<Integer> res = new ArrayList<>();\\n        for(int l = begln;l <= endln;l++){\\n            for(int i = 1; i <= 9 - l + 1;i++){\\n                int num = 0;\\n                for(int d = i, c = 1; c <= l; c++, d++){\\n                    num = num*10 + d;\\n                }\\n                if(num >= low && num <= high){\\n                    res.add(num);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public int len(int x){\\n        int l = 0;\\n        while(x != 0){\\n            l++;\\n            x/=10;\\n        }\\n        return l;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int begln = len(low);\\n        int endln = len(high);\\n        List<Integer> res = new ArrayList<>();\\n        for(int l = begln;l <= endln;l++){\\n            for(int i = 1; i <= 9 - l + 1;i++){\\n                int num = 0;\\n                for(int d = i, c = 1; c <= l; c++, d++){\\n                    num = num*10 + d;\\n                }\\n                if(num >= low && num <= high){\\n                    res.add(num);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    public int len(int x){\\n        int l = 0;\\n        while(x != 0){\\n            l++;\\n            x/=10;\\n        }\\n        return l;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 649178,
                "title": "100-space-100-time-c-using-substring-function",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        string s=\"123456789\";\\n        \\n        int l=9;\\n        vector<int>sol;\\n        for(int len=1;len<=9;len++)\\n        {\\n            for(int i=0;i<9;i++)\\n            {\\n                if(i+len>l)continue;\\n                string r=s.substr(i,len);\\n                if(stoi(r)<=high&&stoi(r)>=low)\\n                    sol.push_back(stoi(r));\\n            }\\n        }\\n        return sol;\\n                                                     \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        string s=\"123456789\";\\n        \\n        int l=9;\\n        vector<int>sol;\\n        for(int len=1;len<=9;len++)\\n        {\\n            for(int i=0;i<9;i++)\\n            {\\n                if(i+len>l)continue;\\n                string r=s.substr(i,len);\\n                if(stoi(r)<=high&&stoi(r)>=low)\\n                    sol.push_back(stoi(r));\\n            }\\n        }\\n        return sol;\\n                                                     \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628682,
                "title": "java-0ms-beats-100-in-both-time-and-space-with-detailed-explanation",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> ans=new ArrayList<>();\\n\\t\\t//get number of digits in low\\n        int ds=getDigit(low);\\n\\t\\t//get the last valid number of the corresponding digit\\n        int ls=getLast(ds);\\n\\t\\t//if the last valid number if less than low for example low=90 here ls=89 \\n        if(low>ls){\\n\\t\\t/* hence increase the number of digit as for low=90 the \\n\\t\\tfirst element that will come in the answer will be 123*/\\n            ds++;\\n\\t\\t\\t//now get the last valid number of the number of digit\\n            ls=getLast(ds);\\n        }\\n\\t\\t//get the first element of the number of digit\\n        int fs=getFirst(ds);\\n\\t\\t/*calculating the number which ill be added inorder to get the next valid number\\n\\t\\tfor 2 digit :  11\\n\\t\\t3 digit : 111 */\\n        int dd=ds;\\n        int add=0;\\n        while(dd!=0){\\n            add=add*10+1;\\n            dd--;\\n        }\\n\\t\\t//taking fs to the value which will surely be added\\n        while(fs<low)   fs=fs+add;\\n\\t\\t\\n\\t\\t\\n        while(fs<=high){\\n            /*for every number of digits we will run loop \\n\\t\\t\\tfor digit 2 loop will run from 12-89\\n\\t\\t\\tfor digit 3 123-789*/\\n            while(fs<=ls){\\n                if(fs>high)\\n                    return ans;\\n                ans.add(fs);\\n                fs=fs+add;\\n            }\\n            if(fs>high)\\n                return ans;\\n\\t\\t\\t//since d digit answer has been added now increment the digut and get new first and last \\n            ds++;\\n\\t\\t\\t//get the new add 11->111 111->1111\\n            add=add*10+1;\\n            fs=getFirst(ds);\\n            ls=getLast(ds);\\n        }\\n        \\n        return ans;\\n    }\\n\\t//returns number of digits in the number\\n    public int getDigit(int n){\\n        int ans=0;\\n        while(n!=0){\\n            ans++;\\n            n=n/10;\\n        }\\n        return ans;\\n    }\\n    /*returns the first sequential number of the required number of digit\\n\\t2 digit-> 12\\n\\t3 digit-> 123\\n\\t4 digit-> 1234\\n\\t*/\\n    public int getFirst(int d){\\n        int dd=1;\\n        int ans=0;\\n        while(d!=0){\\n            ans=ans*10+dd;\\n            dd++;\\n            d--;\\n        }\\n        return ans;\\n    }\\n    /*returns the last sequential number of the required number of digit\\n\\t2 digit-> 89\\n\\t3 digit-> 789\\n\\t4 digit-> 6789\\n\\t*/\\n    public int getLast(int d){\\n        int dd=10-d;\\n        int ans=0;\\n        while(d!=0){\\n            ans=ans*10+dd;\\n            dd++;\\n            d--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> ans=new ArrayList<>();\\n\\t\\t//get number of digits in low\\n        int ds=getDigit(low);\\n\\t\\t//get the last valid number of the corresponding digit\\n        int ls=getLast(ds);\\n\\t\\t//if the last valid number if less than low for example low=90 here ls=89 \\n        if(low>ls){\\n\\t\\t/* hence increase the number of digit as for low=90 the \\n\\t\\tfirst element that will come in the answer will be 123*/\\n            ds++;\\n\\t\\t\\t//now get the last valid number of the number of digit\\n            ls=getLast(ds);\\n        }\\n\\t\\t//get the first element of the number of digit\\n        int fs=getFirst(ds);\\n\\t\\t/*calculating the number which ill be added inorder to get the next valid number\\n\\t\\tfor 2 digit :  11\\n\\t\\t3 digit : 111 */\\n        int dd=ds;\\n        int add=0;\\n        while(dd!=0){\\n            add=add*10+1;\\n            dd--;\\n        }\\n\\t\\t//taking fs to the value which will surely be added\\n        while(fs<low)   fs=fs+add;\\n\\t\\t\\n\\t\\t\\n        while(fs<=high){\\n            /*for every number of digits we will run loop \\n\\t\\t\\tfor digit 2 loop will run from 12-89\\n\\t\\t\\tfor digit 3 123-789*/\\n            while(fs<=ls){\\n                if(fs>high)\\n                    return ans;\\n                ans.add(fs);\\n                fs=fs+add;\\n            }\\n            if(fs>high)\\n                return ans;\\n\\t\\t\\t//since d digit answer has been added now increment the digut and get new first and last \\n            ds++;\\n\\t\\t\\t//get the new add 11->111 111->1111\\n            add=add*10+1;\\n            fs=getFirst(ds);\\n            ls=getLast(ds);\\n        }\\n        \\n        return ans;\\n    }\\n\\t//returns number of digits in the number\\n    public int getDigit(int n){\\n        int ans=0;\\n        while(n!=0){\\n            ans++;\\n            n=n/10;\\n        }\\n        return ans;\\n    }\\n    /*returns the first sequential number of the required number of digit\\n\\t2 digit-> 12\\n\\t3 digit-> 123\\n\\t4 digit-> 1234\\n\\t*/\\n    public int getFirst(int d){\\n        int dd=1;\\n        int ans=0;\\n        while(d!=0){\\n            ans=ans*10+dd;\\n            dd++;\\n            d--;\\n        }\\n        return ans;\\n    }\\n    /*returns the last sequential number of the required number of digit\\n\\t2 digit-> 89\\n\\t3 digit-> 789\\n\\t4 digit-> 6789\\n\\t*/\\n    public int getLast(int d){\\n        int dd=10-d;\\n        int ans=0;\\n        while(d!=0){\\n            ans=ans*10+dd;\\n            dd++;\\n            d--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583292,
                "title": "c-short-backtracking-solution-100",
                "content": "```class Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector < int> ans;\\n        for(int i=1;i < = 9;i++)\\n        {\\n            btrack(ans,low,high,0,i);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    void btrack(vector< int >& ans,int l,int h,int sol,int n)\\n    {\\n        if(sol>h)return;\\n        if(sol>=l)ans.push_back(sol);\\n        if(n>9)return;\\n        btrack(ans,l,h,sol*10+n,n+1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector < int> ans;\\n        for(int i=1;i < = 9;i++)\\n        {\\n            btrack(ans,low,high,0,i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 550300,
                "title": "java-recursion-100-memory-100-speed",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        \\n        List<Integer> mr = new ArrayList<>();\\n        \\n\\t\\tfor (int i = 1; i <= 9; i++) {\\n\\t\\t\\tdigits(low, high, 0, i, mr);\\n\\t\\t}\\n        \\n        Collections.sort(mr);//sorting\\n        \\n\\t\\treturn mr;\\n\\t}\\n\\tprivate void digits(int low, int high, int ans, int n, List<Integer> mr) {\\n\\t\\t\\n\\t\\tif(ans > high) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(ans >= low) {\\n\\t\\t\\tmr.add(ans);\\n\\t\\t}\\n\\t\\tif(n > 9) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdigits(low, high, ans * 10 + n, n + 1, mr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        \\n        List<Integer> mr = new ArrayList<>();\\n        \\n\\t\\tfor (int i = 1; i <= 9; i++) {\\n\\t\\t\\tdigits(low, high, 0, i, mr);\\n\\t\\t}\\n        \\n        Collections.sort(mr);//sorting\\n        \\n\\t\\treturn mr;\\n\\t}\\n\\tprivate void digits(int low, int high, int ans, int n, List<Integer> mr) {\\n\\t\\t\\n\\t\\tif(ans > high) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(ans >= low) {\\n\\t\\t\\tmr.add(ans);\\n\\t\\t}\\n\\t\\tif(n > 9) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdigits(low, high, ans * 10 + n, n + 1, mr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540625,
                "title": "easy-to-understand-beats-100-of-c-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int n=0;\\n    vector<int>res;\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        long long int low1=low; \\n        \\n        while(low1<high)\\n        {\\n            for(int i=1;i<=9;i++)\\n                produce(low1,high,i);\\n            low1*=10;\\n        }\\n        \\n        sort(res.begin(),res.end());\\n        return res;\\n        \\n    }\\n    \\n    void produce(int low,int high,int d)\\n    {\\n        if(n>high)\\n        {\\n            n=0;\\n            return;\\n        }\\n        \\n        if(n>=low&&n<=high)\\n        {\\n            res.push_back(n);\\n            n=0;\\n            return;\\n        }\\n        \\n        if(d<=9)\\n        {\\n            n=n*10+d;\\n            produce(low,high,d+1);\\n            n=0;\\n         }\\n        \\n        return;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int n=0;\\n    vector<int>res;\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        long long int low1=low; \\n        \\n        while(low1<high)\\n        {\\n            for(int i=1;i<=9;i++)\\n                produce(low1,high,i);\\n            low1*=10;\\n        }\\n        \\n        sort(res.begin(),res.end());\\n        return res;\\n        \\n    }\\n    \\n    void produce(int low,int high,int d)\\n    {\\n        if(n>high)\\n        {\\n            n=0;\\n            return;\\n        }\\n        \\n        if(n>=low&&n<=high)\\n        {\\n            res.push_back(n);\\n            n=0;\\n            return;\\n        }\\n        \\n        if(d<=9)\\n        {\\n            n=n*10+d;\\n            produce(low,high,d+1);\\n            n=0;\\n         }\\n        \\n        return;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503845,
                "title": "python-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        \\n        s = \"123456789\"\\n        res = []\\n        \\n        for k in range(1, len(s) + 1):\\n            for i in range(len(s) - k + 1):\\n                x = int(s[i:i+k]) \\n                if x >= low and x <= high:\\n                    res.append(x)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        \\n        s = \"123456789\"\\n        res = []\\n        \\n        for k in range(1, len(s) + 1):\\n            for i in range(len(s) - k + 1):\\n                x = int(s[i:i+k]) \\n                if x >= low and x <= high:\\n                    res.append(x)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454542,
                "title": "java-beat-100-of-the-java-submissions",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int arr[]= new int []{ 12,23,34,45,56,67,78,89,\\n                               123,234,345,456,567,678,789,\\n                               1234,2345,3456,4567,5678,6789,\\n                               12345,23456,34567,45678,56789,\\n                               123456,234567,345678,456789,\\n                               1234567,2345678,3456789,\\n                               12345678,23456789,\\n                               123456789\\n                               };\\n        List<Integer> myList = new ArrayList<Integer>();\\n        int i=0;\\n        while(i<arr.length){\\n            myList.add(arr[i]);\\n            i++;\\n        }\\n        List<Integer> seq = new ArrayList<Integer>();\\n        for(Integer num : myList){\\n            if(num>=low && num<=high){\\n                seq.add(num);\\n            }\\n        }\\n        return seq;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int arr[]= new int []{ 12,23,34,45,56,67,78,89,\\n                               123,234,345,456,567,678,789,\\n                               1234,2345,3456,4567,5678,6789,\\n                               12345,23456,34567,45678,56789,\\n                               123456,234567,345678,456789,\\n                               1234567,2345678,3456789,\\n                               12345678,23456789,\\n                               123456789\\n                               };\\n        List<Integer> myList = new ArrayList<Integer>();\\n        int i=0;\\n        while(i<arr.length){\\n            myList.add(arr[i]);\\n            i++;\\n        }\\n        List<Integer> seq = new ArrayList<Integer>();\\n        for(Integer num : myList){\\n            if(num>=low && num<=high){\\n                seq.add(num);\\n            }\\n        }\\n        return seq;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452304,
                "title": "java-backtracking",
                "content": "```\\npublic List<Integer> sequentialDigits(int low, int high) {\\n        int lowDigitCount = (int)Math.floor(Math.log10(low) + 1);   // Number of digits in low\\n        int highDigitCount =  (int)Math.floor(Math.log10(high) + 1); // Number of digits in high\\n        List<Integer> result = new ArrayList<>();\\n        for(int i=lowDigitCount;i<=highDigitCount;i++) {\\n            util(new StringBuilder(),result,1,i,0,low,high);\\n        }\\n        return result;\\n    }\\n\\n    private void util(StringBuilder sb, List<Integer> list, int start, int count, int index,int low,int high) {\\n        if(index==count) {\\n            Integer x = Integer.parseInt(sb.toString());\\n            if(x>=low && x<=high) {\\n                list.add(x);\\n            }\\n            return;\\n        }\\n        if(start>9) {\\n            return;\\n        }\\n        if(index==0) {\\n            for(int i=start;i<9;i++) {\\n                sb.append(i);\\n                util(sb,list,i+1,count,index+1,low,high);\\n                sb.deleteCharAt(index);\\n            }\\n        } else {\\n            sb.append(start);\\n            util(sb,list,start+1,count,index+1,low,high);\\n            sb.deleteCharAt(index);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> sequentialDigits(int low, int high) {\\n        int lowDigitCount = (int)Math.floor(Math.log10(low) + 1);   // Number of digits in low\\n        int highDigitCount =  (int)Math.floor(Math.log10(high) + 1); // Number of digits in high\\n        List<Integer> result = new ArrayList<>();\\n        for(int i=lowDigitCount;i<=highDigitCount;i++) {\\n            util(new StringBuilder(),result,1,i,0,low,high);\\n        }\\n        return result;\\n    }\\n\\n    private void util(StringBuilder sb, List<Integer> list, int start, int count, int index,int low,int high) {\\n        if(index==count) {\\n            Integer x = Integer.parseInt(sb.toString());\\n            if(x>=low && x<=high) {\\n                list.add(x);\\n            }\\n            return;\\n        }\\n        if(start>9) {\\n            return;\\n        }\\n        if(index==0) {\\n            for(int i=start;i<9;i++) {\\n                sb.append(i);\\n                util(sb,list,i+1,count,index+1,low,high);\\n                sb.deleteCharAt(index);\\n            }\\n        } else {\\n            sb.append(start);\\n            util(sb,list,start+1,count,index+1,low,high);\\n            sb.deleteCharAt(index);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 451987,
                "title": "java-conceptual-easiest",
                "content": "\\tclass Solution {\\n\\t\\tList<Integer> ans= new ArrayList<>();\\n\\t\\tpublic List<Integer> sequentialDigits(int low, int high) {\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=1;i<9;i++){\\n\\t\\t\\t\\tfn(low,high,i,i+1);\\n\\t\\t\\t}\\n\\t\\t\\tCollections.sort(ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tpublic void fn(int low,int high,int s,int m){\\n\\t\\t\\tif(s>=low&&s<=high){\\n\\t\\t\\t\\tif(!ans.contains(s)){\\n\\t\\t\\t\\t\\tans.add(s);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(m>=10||s>high){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\ts=s*10+m;\\n\\t\\t\\t\\tfn(low,high,s,m+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tList<Integer> ans= new ArrayList<>();\\n\\t\\tpublic List<Integer> sequentialDigits(int low, int high) {\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=1;i<9;i++){\\n\\t\\t\\t\\tfn(low,high,i,i+1);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 451941,
                "title": "java-0ms-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList();\\n        int[][] dp = new int[9][9];\\n        dp[0][0] = 1;\\n        dp[1][0] = 12;\\n        dp[2][0] = 123;\\n        dp[3][0] = 1234;\\n        dp[4][0] = 12345;\\n        dp[5][0] = 123456;\\n        dp[6][0] = 1234567;\\n        dp[7][0] = 12345678;\\n        dp[8][0] = 123456789;\\n        for(int i = 0; i < 9; i++){\\n            int num = 1;\\n            for(int k = 0; k < i; k++){\\n                num *=10;\\n                num +=1;\\n            }\\n            for(int j = 1; j < 9-i; j++){\\n                dp[i][j] = dp[i][j-1] + num;\\n            }\\n        }\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9-i; j++){\\n                if(dp[i][j] >= low && dp[i][j]  <= high){\\n                    res.add(dp[i][j] );\\n                }\\n                if(dp[i][j] > high){\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList();\\n        int[][] dp = new int[9][9];\\n        dp[0][0] = 1;\\n        dp[1][0] = 12;\\n        dp[2][0] = 123;\\n        dp[3][0] = 1234;\\n        dp[4][0] = 12345;\\n        dp[5][0] = 123456;\\n        dp[6][0] = 1234567;\\n        dp[7][0] = 12345678;\\n        dp[8][0] = 123456789;\\n        for(int i = 0; i < 9; i++){\\n            int num = 1;\\n            for(int k = 0; k < i; k++){\\n                num *=10;\\n                num +=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 451844,
                "title": "java-simple-java-solution",
                "content": "```\\nList<Integer> list = new ArrayList();\\n    int lowVal;\\n    int highVal;\\n\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        lowVal = low;\\n        highVal = high;\\n        int val = low , startI = 0, countL = 0, countH =0;\\n        while(val > 0) {\\n            startI = val%10;\\n            val = val/10;\\n            countL++;\\n        }\\n        \\n        val = high;\\n        while(val > 0) {\\n            val = val/10;\\n            countH++;\\n        }\\n        \\n        for(int l =countL; l<=countH; l++) {\\n            for(int i= 1; i<=9; i++) {\\n                find(l, 0, i);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    void find(int len, int val, int startI) {\\n        for(int i= startI; i<=9 && len>0; i++) {\\n            val = val*10 + i;\\n            len--;\\n            \\n        }\\n        if(len <= 0 && val >= lowVal && val <= highVal) {\\n            list.add(val);\\n        }\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\nList<Integer> list = new ArrayList();\\n    int lowVal;\\n    int highVal;\\n\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        lowVal = low;\\n        highVal = high;\\n        int val = low , startI = 0, countL = 0, countH =0;\\n        while(val > 0) {\\n            startI = val%10;\\n            val = val/10;\\n            countL++;\\n        }\\n        \\n        val = high;\\n        while(val > 0) {\\n            val = val/10;\\n            countH++;\\n        }\\n        \\n        for(int l =countL; l<=countH; l++) {\\n            for(int i= 1; i<=9; i++) {\\n                find(l, 0, i);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    void find(int len, int val, int startI) {\\n        for(int i= startI; i<=9 && len>0; i++) {\\n            val = val*10 + i;\\n            len--;\\n            \\n        }\\n        if(len <= 0 && val >= lowVal && val <= highVal) {\\n            list.add(val);\\n        }\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3913239,
                "title": "simple-brute-force-approach",
                "content": "# Intuition\\nThe constraints make us think that thi sproblem should be solved with the help of converting the low and high to stirngs.\\n\\n# Approach\\nCalculate the length of low and high and then run a loop from lowest length to greatest length.\\nfor each length there can be only certain possibilites \\nFor ex.- For length 5 there can be\\n[12345,23456,34567,45678,56789]\\nhere we can see the last number starts from 5 that is 11-len(of that iteration.)\\nfor each start we then make the number by by incrementing the last digit by one till the length is reached and then check if it lies between the range of low and high. \\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:easy\\n\\n# Code\\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        l = len(str(low))\\n        h = len(str(high))\\n        ans = []\\n        for i in range(l,h+1):\\n            for j in range(1,11-i):\\n                t = str(j)\\n                for k in range(i-1):\\n                    t+=str(int(t[-1])+1)\\n                if int(t)<=high and int(t)>=low:\\n                    ans.append(int(t))\\n        ans.sort()\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        l = len(str(low))\\n        h = len(str(high))\\n        ans = []\\n        for i in range(l,h+1):\\n            for j in range(1,11-i):\\n                t = str(j)\\n                for k in range(i-1):\\n                    t+=str(int(t[-1])+1)\\n                if int(t)<=high and int(t)>=low:\\n                    ans.append(int(t))\\n        ans.sort()\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532551,
                "title": "beats-100-easiest",
                "content": "# Intuition\\n![image.png](https://assets.leetcode.com/users/images/b414b9f9-2e92-4ec8-b679-f12d3e06c114_1684286977.789904.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void helper(int curr,int low,  int high, int cd, int hd){\\n        if(cd > hd || curr > high){\\n            return ;\\n        }\\n                // cout << curr << endl;\\n\\n        // if(cd == hd){\\n            if(curr <= high && curr >= low){\\n                ans.push_back(curr);\\n            }\\n            // return;\\n        // }\\n\\n        int last = curr%10;\\n        if(last == 9){\\n            return;\\n        }\\n        curr = curr*10 + (last+1);\\n        helper(curr,low, high, cd+1,hd);\\n    }\\n\\n    vector<int> sequentialDigits(int low, int high) {\\n        int dl = 0, dh = 0, n = low , m = high;\\n        while(n > 0){\\n            n /= 10;\\n            dl++;\\n        }\\n        while(m > 0){\\n            m /= 10;\\n            dh++;\\n        }\\n\\n        // cout << dl << \" \" << dh << endl;\\n\\n        for(int i=1;i<9;i++){\\n            helper(i, low, high , 0,dh);\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void helper(int curr,int low,  int high, int cd, int hd){\\n        if(cd > hd || curr > high){\\n            return ;\\n        }\\n                // cout << curr << endl;\\n\\n        // if(cd == hd){\\n            if(curr <= high && curr >= low){\\n                ans.push_back(curr);\\n            }\\n            // return;\\n        // }\\n\\n        int last = curr%10;\\n        if(last == 9){\\n            return;\\n        }\\n        curr = curr*10 + (last+1);\\n        helper(curr,low, high, cd+1,hd);\\n    }\\n\\n    vector<int> sequentialDigits(int low, int high) {\\n        int dl = 0, dh = 0, n = low , m = high;\\n        while(n > 0){\\n            n /= 10;\\n            dl++;\\n        }\\n        while(m > 0){\\n            m /= 10;\\n            dh++;\\n        }\\n\\n        // cout << dl << \" \" << dh << endl;\\n\\n        for(int i=1;i<9;i++){\\n            helper(i, low, high , 0,dh);\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3310604,
                "title": "very-simple-solution-using-recursion-easy-to-understand-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple approach using recursion\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void find( vector<int> &res, int num, int high, int low, int pd){\\n        if(num>=low && num<=high){\\n            res.push_back(num);\\n        }\\n        if(num<=high && pd<9){\\n            pd = pd+1;\\n            num = num*10 + pd;\\n            find( res, num, high, low, pd);\\n        }\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> res;\\n        for(int i=0; i<9; i++)\\n            find(res, 0, high, low, i);\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void find( vector<int> &res, int num, int high, int low, int pd){\\n        if(num>=low && num<=high){\\n            res.push_back(num);\\n        }\\n        if(num<=high && pd<9){\\n            pd = pd+1;\\n            num = num*10 + pd;\\n            find( res, num, high, low, pd);\\n        }\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> res;\\n        for(int i=0; i<9; i++)\\n            find(res, 0, high, low, i);\\n        sort(res.begin(), res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307017,
                "title": "easy-to-solve-by-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896963,
                "title": "cpp-must-see-enumeration",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\t//we will generate all the digits \\n\\t//we will try to make the seq digits starting from the every num\\n\\t//we will try to fix every digit\\n\\tvector<int>ans;\\n    set<int>st;\\n    vector<int> sequentialDigits(int low, int high) \\n\\t{\\n        for(int i=0;i<=9;i++)\\n        {\\n    \\t   int num = i;\\n    \\t   fun(num,low,high);\\n\\t\\t}\\n\\t\\tfor(auto val : st)\\n        {\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n    void fun(int num,int &low,int &high)\\n    {\\n    \\tint prv = num % 10;\\n    \\t\\n    \\tif(num > high or prv == 9)\\n    \\treturn;\\n    \\t\\n    \\tnum = (num * 10) + (prv+1);\\n    \\t\\n    \\tif(num >= low and num<=high)\\n\\t\\t{\\n\\t\\t    st.insert(num);\\n\\t    }     \\n        \\n        fun(num,low,high);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t//we will generate all the digits \\n\\t//we will try to make the seq digits starting from the every num\\n\\t//we will try to fix every digit\\n\\tvector<int>ans;\\n    set<int>st;\\n    vector<int> sequentialDigits(int low, int high) \\n\\t{\\n        for(int i=0;i<=9;i++)\\n        {\\n    \\t   int num = i;\\n    \\t   fun(num,low,high);\\n\\t\\t}\\n\\t\\tfor(auto val : st)\\n        {\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n    void fun(int num,int &low,int &high)\\n    {\\n    \\tint prv = num % 10;\\n    \\t\\n    \\tif(num > high or prv == 9)\\n    \\treturn;\\n    \\t\\n    \\tnum = (num * 10) + (prv+1);\\n    \\t\\n    \\tif(num >= low and num<=high)\\n\\t\\t{\\n\\t\\t    st.insert(num);\\n\\t    }     \\n        \\n        fun(num,low,high);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554212,
                "title": "c-using-stoi-o-1-time-and-o-1-space",
                "content": "Just create all the possible options. All the numbers that can be placed in the range will be a substring of the string `\"123456789\"`. \\nSort in the end as it is a requirement in the question. \\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) \\n    {\\n        string s = \"123456789\";\\n        vector<int> ans;\\n        for (int i=0; i<9; ++i)\\n        {\\n            for (int j=1; j<=9-i; ++j)\\n            {\\n                string cur = s.substr(i, j);\\n                int val = stoi(cur);\\n                if (val >= low && val <= high)\\n                    ans.push_back(val);\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) \\n    {\\n        string s = \"123456789\";\\n        vector<int> ans;\\n        for (int i=0; i<9; ++i)\\n        {\\n            for (int j=1; j<=9-i; ++j)\\n            {\\n                string cur = s.substr(i, j);\\n                int val = stoi(cur);\\n                if (val >= low && val <= high)\\n                    ans.push_back(val);\\n            }\\n        }\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537824,
                "title": "o-1-solution-c-100-time",
                "content": "Since we have a very contrained solution, writing out the options and then iterating is kind of the best hack to solve the problem.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> values {12,23,34,45,56,67,78,89,\\n                            123,234,345,456,567,678,789,\\n                            1234,2345,3456,4567,5678,6789,\\n                            12345,23456,34567,45678,56789,\\n                            123456,234567,345678,456789,\\n                            1234567,2345678,3456789,\\n                            12345678, 23456789,\\n                            123456789\\n                           };\\n        vector<int> ans;\\n        int i=0;\\n        while(i<values.size() && low > values[i]){\\n            i++;\\n        }\\n        while(i<values.size() && values[i]<=high){\\n            ans.push_back(values[i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> values {12,23,34,45,56,67,78,89,\\n                            123,234,345,456,567,678,789,\\n                            1234,2345,3456,4567,5678,6789,\\n                            12345,23456,34567,45678,56789,\\n                            123456,234567,345678,456789,\\n                            1234567,2345678,3456789,\\n                            12345678, 23456789,\\n                            123456789\\n                           }",
                "codeTag": "Java"
            },
            {
                "id": 2530039,
                "title": "simple-solution-in-javascript",
                "content": "```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @return {number[]}\\n */\\nvar sequentialDigits = function(low, high) {\\n  let res = [];\\n  for (let i = 1; i <= 9; i++) {\\n    dfs(low, high, i, 0, res);\\n  }\\n  return res.sort((a, b) => a - b)\\n};\\n\\nfunction dfs(low, high, i, num, res) {\\n  if (num >= low && num <= high) {\\n    res.push(num);\\n  }\\n  \\n  if (num > high || i > 9) {\\n    return;\\n  }\\n  \\n  dfs(low, high, i + 1, num * 10 + i, res);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} low\\n * @param {number} high\\n * @return {number[]}\\n */\\nvar sequentialDigits = function(low, high) {\\n  let res = [];\\n  for (let i = 1; i <= 9; i++) {\\n    dfs(low, high, i, 0, res);\\n  }\\n  return res.sort((a, b) => a - b)\\n};\\n\\nfunction dfs(low, high, i, num, res) {\\n  if (num >= low && num <= high) {\\n    res.push(num);\\n  }\\n  \\n  if (num > high || i > 9) {\\n    return;\\n  }\\n  \\n  dfs(low, high, i + 1, num * 10 + i, res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2364151,
                "title": "c-solution-beats-100-finding-feasible-answer-sliding-window",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> sequentialDigits(int low, int high) \\n    {\\n        string temp = \"123456789\";\\n        \\n        int start=0, end=0, temp1=low, temp2=high;\\n        while(temp1)\\n        {\\n            start++;\\n            temp1/=10;\\n        }\\n        \\n        while(temp2)\\n        {\\n            end++;\\n            temp2/=10;\\n        }\\n        \\n        vector<int> ans;\\n        for(int substring_len=start; substring_len<=end; ++substring_len)\\n        {\\n            for(int i=0; i<=9-substring_len; ++i)\\n            {\\n                string subans = temp.substr(i, substring_len);\\n                int num = stoi(subans);\\n                \\n                if(low<=num and num<=high)\\n                    ans.push_back(num);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> sequentialDigits(int low, int high) \\n    {\\n        string temp = \"123456789\";\\n        \\n        int start=0, end=0, temp1=low, temp2=high;\\n        while(temp1)\\n        {\\n            start++;\\n            temp1/=10;\\n        }\\n        \\n        while(temp2)\\n        {\\n            end++;\\n            temp2/=10;\\n        }\\n        \\n        vector<int> ans;\\n        for(int substring_len=start; substring_len<=end; ++substring_len)\\n        {\\n            for(int i=0; i<=9-substring_len; ++i)\\n            {\\n                string subans = temp.substr(i, substring_len);\\n                int num = stoi(subans);\\n                \\n                if(low<=num and num<=high)\\n                    ans.push_back(num);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362131,
                "title": "simple-bfs-over-digits",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        queue<int> q;\\n        for(int i = 1; i < 10; i++) q.push(i);\\n        \\n        vector<int> ans;\\n        \\n        while(!q.empty()){\\n                \\n            int num = q.front();\\n            q.pop();\\n            if(num >= low && num <= high)   ans.push_back(num);\\n\\n            if(num % 10 < 9){\\n                int rem = num % 10;      \\n                q.push(num*10 + rem + 1);\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nDon\\'t forget to like:)",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        queue<int> q;\\n        for(int i = 1; i < 10; i++) q.push(i);\\n        \\n        vector<int> ans;\\n        \\n        while(!q.empty()){\\n                \\n            int num = q.front();\\n            q.pop();\\n            if(num >= low && num <= high)   ans.push_back(num);\\n\\n            if(num % 10 < 9){\\n                int rem = num % 10;      \\n                q.push(num*10 + rem + 1);\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343629,
                "title": "sliding-window",
                "content": "```\\npublic List<Integer> sequentialDigits(int low, int high) {\\n        String sample = \"123456789\";\\n        int n = 10;\\n        List<Integer> nums = new ArrayList<>();\\n        \\n        int lowLen = String.valueOf(low).length();\\n        int highLen = String.valueOf(high).length();\\n        \\n        for (int length = lowLen; length < highLen + 1; length++) {\\n            for (int start = 0; start < n - length; start++) {\\n                int num = Integer.parseInt(sample.substring(start, start + length));\\n                if (num >= low && num <= high) {\\n                    nums.add(num);\\n                }            \\n            }\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> sequentialDigits(int low, int high) {\\n        String sample = \"123456789\";\\n        int n = 10;\\n        List<Integer> nums = new ArrayList<>();\\n        \\n        int lowLen = String.valueOf(low).length();\\n        int highLen = String.valueOf(high).length();\\n        \\n        for (int length = lowLen; length < highLen + 1; length++) {\\n            for (int start = 0; start < n - length; start++) {\\n                int num = Integer.parseInt(sample.substring(start, start + length));\\n                if (num >= low && num <= high) {\\n                    nums.add(num);\\n                }            \\n            }\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2277609,
                "title": "sequential-digits-java-easy-recursion-sliding-window-2-methods",
                "content": "```\\n//--------------Method 1------------\\n\\nclass Solution {\\n    List<Integer> ls;\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        ls=new ArrayList<>();\\n        \\n        String lows=low+\"\";\\n        String highs=high+\"\";\\n        \\n        for(int i=1;i<=9;i++){\\n            makeNum(low,lows.length(),high,highs.length(),\"\",i);\\n        }\\n        \\n        Collections.sort(ls);\\n        return ls;\\n    }\\n    \\n    public void makeNum(int start, int startLen, int high, int highLen, String str, int nextD){\\n        int num=str.equals(\"\")?-1:Integer.parseInt(str);\\n\\n        if(num>high){\\n            return;\\n        }\\n        \\n        if(str.length()>=startLen && str.length()<=highLen){\\n            if(num>=start && num<=high){\\n                ls.add(num);\\n            }\\n        }\\n        \\n        if(nextD>=10){\\n            return;\\n        }\\n        \\n     \\n        makeNum(start,startLen,high,highLen,str+nextD,nextD+1);\\n        \\n    }\\n}\\n\\n//---------------Method 2-------------------\\n\\nclass Solution{\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> ans=new ArrayList<>();\\n        String digits=\"123456789\";\\n        \\n        String lows=low+\"\";\\n        int end=lows.length();\\n        \\n        int start=0;\\n        int prev=end;\\n        boolean flag=true;\\n        \\n        while(flag && start<=8){\\n            if(start+end>9){\\n                flag=false;\\n            }\\n            for(int i=start;i+end<=9 && flag;i++){\\n                String sub=digits.substring(i,i+end);\\n                int num=Integer.parseInt(sub);\\n                if(num<low){\\n                    continue;\\n                }else if(num>high){\\n                    flag=false;\\n                    break;\\n                }else{\\n                    ans.add(num);\\n                }\\n            }\\n            \\n            if(flag){\\n                start=0;\\n                end++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Sliding Window"
                ],
                "code": "```\\n//--------------Method 1------------\\n\\nclass Solution {\\n    List<Integer> ls;\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        ls=new ArrayList<>();\\n        \\n        String lows=low+\"\";\\n        String highs=high+\"\";\\n        \\n        for(int i=1;i<=9;i++){\\n            makeNum(low,lows.length(),high,highs.length(),\"\",i);\\n        }\\n        \\n        Collections.sort(ls);\\n        return ls;\\n    }\\n    \\n    public void makeNum(int start, int startLen, int high, int highLen, String str, int nextD){\\n        int num=str.equals(\"\")?-1:Integer.parseInt(str);\\n\\n        if(num>high){\\n            return;\\n        }\\n        \\n        if(str.length()>=startLen && str.length()<=highLen){\\n            if(num>=start && num<=high){\\n                ls.add(num);\\n            }\\n        }\\n        \\n        if(nextD>=10){\\n            return;\\n        }\\n        \\n     \\n        makeNum(start,startLen,high,highLen,str+nextD,nextD+1);\\n        \\n    }\\n}\\n\\n//---------------Method 2-------------------\\n\\nclass Solution{\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> ans=new ArrayList<>();\\n        String digits=\"123456789\";\\n        \\n        String lows=low+\"\";\\n        int end=lows.length();\\n        \\n        int start=0;\\n        int prev=end;\\n        boolean flag=true;\\n        \\n        while(flag && start<=8){\\n            if(start+end>9){\\n                flag=false;\\n            }\\n            for(int i=start;i+end<=9 && flag;i++){\\n                String sub=digits.substring(i,i+end);\\n                int num=Integer.parseInt(sub);\\n                if(num<low){\\n                    continue;\\n                }else if(num>high){\\n                    flag=false;\\n                    break;\\n                }else{\\n                    ans.add(num);\\n                }\\n            }\\n            \\n            if(flag){\\n                start=0;\\n                end++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258885,
                "title": "java-solution-using-sliding-window-faster-than-100",
                "content": "I know it can be written in a nicer and cleaner way. But this is all I can think of rn.\\n```java\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int[] nums = new int[]{1,2,3,4,5,6,7,8,9};\\n        int num = 0;\\n        int start = 0; \\n        int end = 0;\\n        int temp = low;\\n        List<Integer> ans = new ArrayList<>();\\n        while (temp>0) {\\n            end++;\\n            temp/=10;\\n        }\\n        int count = 0;\\n        int prev = end;\\n        while (num<high) {\\n            num = 0;\\n            if (end>nums.length) {\\n                start = 0;\\n                count++;\\n                end = prev+count;\\n            }\\n            if (end>nums.length)\\n                break;\\n            for (int i = start; i<end; i++) {\\n                num = num*10+nums[i];\\n            }\\n            if (num>=low && num<=high)\\n                ans.add(num);\\n            start++;\\n            end++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```java\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        int[] nums = new int[]{1,2,3,4,5,6,7,8,9};\\n        int num = 0;\\n        int start = 0; \\n        int end = 0;\\n        int temp = low;\\n        List<Integer> ans = new ArrayList<>();\\n        while (temp>0) {\\n            end++;\\n            temp/=10;\\n        }\\n        int count = 0;\\n        int prev = end;\\n        while (num<high) {\\n            num = 0;\\n            if (end>nums.length) {\\n                start = 0;\\n                count++;\\n                end = prev+count;\\n            }\\n            if (end>nums.length)\\n                break;\\n            for (int i = start; i<end; i++) {\\n                num = num*10+nums[i];\\n            }\\n            if (num>=low && num<=high)\\n                ans.add(num);\\n            start++;\\n            end++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188281,
                "title": "easiest-c",
                "content": "Using sliding window:-\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        string base=\"123456789\";\\n        for(int win=1;win<=9;win++){\\n            for(int i=0;i+win-1<=8;i++){\\n                int no=stoi(base.substr(i,win));\\n                if(no>=low && no<=high){\\n                    ans.push_back(no);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease ***upvote*** if you like the solution",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        string base=\"123456789\";\\n        for(int win=1;win<=9;win++){\\n            for(int i=0;i+win-1<=8;i++){\\n                int no=stoi(base.substr(i,win));\\n                if(no>=low && no<=high){\\n                    ans.push_back(no);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167320,
                "title": "c-dfs-beats-100",
                "content": "![image](https://assets.leetcode.com/users/images/bedae46a-dcb2-4dd9-b698-439833fe1a79_1655581666.399104.png)\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i, int& low, int&high, int num, vector<int>&ans){\\n        if(num>=low and num<=high) ans.push_back(num);\\n        if(num>high or i>=9) return;\\n        dfs(i+1, low, high, num*10+i+1, ans);\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        for(int i=1; i<=9; i++) dfs(i, low, high, i, ans);\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\nThanks",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, int& low, int&high, int num, vector<int>&ans){\\n        if(num>=low and num<=high) ans.push_back(num);\\n        if(num>high or i>=9) return;\\n        dfs(i+1, low, high, num*10+i+1, ans);\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        for(int i=1; i<=9; i++) dfs(i, low, high, i, ans);\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120061,
                "title": "c-short-and-simple-100-faster-sol-with-explanation",
                "content": "**Approach** : \\n1. Find the no of digits in low and high (log10(num) + 1).\\n2. Generate all possible numbers for the given no. of digits from low_d to high_d and push if it is between [low,high].\\n3. For each given digits starting num will be different. To get next number add` ((pow(10,digits+1)-1)/9)` . Find the max num that can be obtained with the given no. of digits. If next number is within limits then push.\\n\\n\\n```\\n  vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        long long int temp=0,st=0,add=0,max; \\n        int    low_d= log10(low)+1,    high_d=log10(high)+1;     // no. of digits in high and low\\n        \\n        for(int i=low_d;i<=high_d;i++){\\n            st=0,add=0,max=0;\\n\\t\\t\\t\\n            for(int j=1;j<=i;j++){\\n                st=st*10+j;            //find starting number\\n                add=add*10+1;         // find number to be added to get the next number\\n                max=max*10+(10-i+j-1);   // find max number possible for given digits\\n            }\\n            temp=st;                    // start with starting number of given digits\\n            while(temp<=high&&temp<=max){  // check if it is within constraints \\n                if(temp>=low)\\n                ans.push_back(temp);\\n                temp+=add;     //generate next number \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n  vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        long long int temp=0,st=0,add=0,max; \\n        int    low_d= log10(low)+1,    high_d=log10(high)+1;     // no. of digits in high and low\\n        \\n        for(int i=low_d;i<=high_d;i++){\\n            st=0,add=0,max=0;\\n\\t\\t\\t\\n            for(int j=1;j<=i;j++){\\n                st=st*10+j;            //find starting number\\n                add=add*10+1;         // find number to be added to get the next number\\n                max=max*10+(10-i+j-1);   // find max number possible for given digits\\n            }\\n            temp=st;                    // start with starting number of given digits\\n            while(temp<=high&&temp<=max){  // check if it is within constraints \\n                if(temp>=low)\\n                ans.push_back(temp);\\n                temp+=add;     //generate next number \\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2108378,
                "title": "o-1-time-complexity-easy-approach-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int check[10][2] = {{-1, -1}, {-1, -1}, {12, 89}, {123, 789}, {1234, 6789},\\n                              {12345, 56789}, {123456, 456789}, {1234567, 3456789}, \\n                              {12345678, 23456789}, {123456789, 123456789}\\n    };\\n    \\n    int makeOnes(int n){\\n        int num = 0;\\n        while(n--){\\n            num += 1;\\n            num *= 10;\\n        }\\n        return num/10;\\n    }\\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n        string small = to_string(low);\\n        string large = to_string(high);\\n        int s = small.size();\\n        int l = large.size();\\n        \\n        vector<int> ans;\\n        int val = low;\\n        low = check[s][0];\\n        int num = makeOnes(s);\\n        \\n        while(low <= high){\\n            \\n            if(low < val) {\\n                low += num;\\n                continue;\\n            }\\n            \\n            if(low > check[s][1]){\\n                // cout<<low<<\" \";\\n                s++;\\n                if(s > 9) break;\\n                low = check[s][0];\\n                num = makeOnes(s);\\n            }\\n            else{\\n                ans.push_back(low);\\n                low += num;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### Please Upvote if you like this...\\uD83D\\uDE03\\n\\nTell me the time complexity of this solution :  My ans is O(logn). Yours ?",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check[10][2] = {{-1, -1}, {-1, -1}, {12, 89}, {123, 789}, {1234, 6789},\\n                              {12345, 56789}, {123456, 456789}, {1234567, 3456789}, \\n                              {12345678, 23456789}, {123456789, 123456789}\\n    };\\n    \\n    int makeOnes(int n){\\n        int num = 0;\\n        while(n--){\\n            num += 1;\\n            num *= 10;\\n        }\\n        return num/10;\\n    }\\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n        string small = to_string(low);\\n        string large = to_string(high);\\n        int s = small.size();\\n        int l = large.size();\\n        \\n        vector<int> ans;\\n        int val = low;\\n        low = check[s][0];\\n        int num = makeOnes(s);\\n        \\n        while(low <= high){\\n            \\n            if(low < val) {\\n                low += num;\\n                continue;\\n            }\\n            \\n            if(low > check[s][1]){\\n                // cout<<low<<\" \";\\n                s++;\\n                if(s > 9) break;\\n                low = check[s][0];\\n                num = makeOnes(s);\\n            }\\n            else{\\n                ans.push_back(low);\\n                low += num;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2108213,
                "title": "python-simple-sliding-window",
                "content": "```python\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        s = \"123456789\"\\n        # moivng window lengh == min_len\\n        min_len = len(str(low))\\n        max_len = len(str(high))\\n        res = []\\n        while min_len <= max_len:\\n            for i in range(0, len(s) - min_len + 1):\\n                n = int(s[i : i + min_len])\\n                if low <= n <= high:\\n                    res.append(n)\\n            min_len += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        s = \"123456789\"\\n        # moivng window lengh == min_len\\n        min_len = len(str(low))\\n        max_len = len(str(high))\\n        res = []\\n        while min_len <= max_len:\\n            for i in range(0, len(s) - min_len + 1):\\n                n = int(s[i : i + min_len])\\n                if low <= n <= high:\\n                    res.append(n)\\n            min_len += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979524,
                "title": "recursion-java",
                "content": "```\\nclass Solution {\\n    public void comb(int start,int num,int low,int high,ArrayList<Integer> res)\\n    {\\n        if(num > high || start > 10)\\n            return;\\n        if(num >= low && num<=high)\\n        {\\n            res.add(num);\\n            \\n        }\\n        comb(start+1,num*10 + start,low,high,res);\\n        \\n    }\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        \\n        ArrayList<Integer> res = new ArrayList<>();\\n        for(int i=1;i<=9;i++)\\n        {\\n            comb(i,0,low,high,res);\\n        }\\n        \\n        Collections.sort(res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void comb(int start,int num,int low,int high,ArrayList<Integer> res)\\n    {\\n        if(num > high || start > 10)\\n            return;\\n        if(num >= low && num<=high)\\n        {\\n            res.add(num);\\n            \\n        }\\n        comb(start+1,num*10 + start,low,high,res);\\n        \\n    }\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        \\n        ArrayList<Integer> res = new ArrayList<>();\\n        for(int i=1;i<=9;i++)\\n        {\\n            comb(i,0,low,high,res);\\n        }\\n        \\n        Collections.sort(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950254,
                "title": "pre-calculate-o-1",
                "content": "Trick - Read the constraints. Since we have limited numbers that satisfy the condition within given constraints, we can pre-calculate and store it.\\n\\n```\\n// TC : O(1) since pre-calculates and iteration is over fixed length\\n// SC : O(1) since max space is definitely <= cache.length\\npublic List<Integer> sequentialDigits(int low, int high) {\\n\\tList<Integer> ls = new ArrayList<>();\\n\\n\\tint[] cache = new int[] {12,23,34,45,56,67,78,89,123,234,345,456,567,678,789,1234,2345,3456,4567,5678,6789,12345,23456,34567,45678,56789,123456,234567,\\n\\t345678,456789,1234567,2345678,3456789,12345678,23456789,123456789};\\n\\n\\tfor (int candidate : cache) {\\n\\t\\tif (low <= candidate && candidate <= high) {\\n\\t\\t\\tls.add(candidate);\\n\\t\\t}\\n\\t}\\n\\n\\treturn ls;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// TC : O(1) since pre-calculates and iteration is over fixed length\\n// SC : O(1) since max space is definitely <= cache.length\\npublic List<Integer> sequentialDigits(int low, int high) {\\n\\tList<Integer> ls = new ArrayList<>();\\n\\n\\tint[] cache = new int[] {12,23,34,45,56,67,78,89,123,234,345,456,567,678,789,1234,2345,3456,4567,5678,6789,12345,23456,34567,45678,56789,123456,234567,\\n\\t345678,456789,1234567,2345678,3456789,12345678,23456789,123456789};\\n\\n\\tfor (int candidate : cache) {\\n\\t\\tif (low <= candidate && candidate <= high) {\\n\\t\\t\\tls.add(candidate);\\n\\t\\t}\\n\\t}\\n\\n\\treturn ls;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1904160,
                "title": "easy-constant-time",
                "content": "vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        \\n        for(int i=1;i<=8;i++)\\n        {\\n            int x=i,y=i;\\n            while(y<9 &&x<high)\\n            {\\n                x*=10;\\n                y++;\\n                x+=y;\\n                //cout<<x<<endl;\\n                if(x>=low && x<=high)\\n                    ans.push_back(x);\\n                \\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        \\n        for(int i=1;i<=8;i++)\\n        {\\n            int x=i,y=i;\\n            while(y<9 &&x<high)\\n            {\\n                x*=10;\\n                y++;\\n                x+=y;\\n                //cout<<x<<endl;\\n                if(x>=low && x<=high)\\n                    ans.push_back(x);\\n                \\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1724018,
                "title": "0-ms-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int>res;\\n        int i=low;\\n        int t=0;\\n        while(i){\\n            t++;\\n            i=i/10;\\n        }\\n        int increment=1;\\n        i=1;\\n        for(int j=0;j<t-1;j++){\\n            i=(i*10+((i%10)+1));\\n            increment=increment*10+1;\\n        }\\n        int last=i;\\n        while(i<low){\\n            if(i%10==9){\\n                i=last*10+((last%10)+1);\\n                last=i;\\n                increment=increment*10+1;\\n            }else{\\n                i+=increment;    \\n            }\\n        }\\n       while(i<=high){\\n           res.push_back(i);\\n           if(i%10==9){\\n                i=last*10+((last%10)+1);\\n                last=i;\\n                increment=increment*10+1;\\n            }else{\\n                i+=increment;    \\n            }\\n       }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int>res;\\n        int i=low;\\n        int t=0;\\n        while(i){\\n            t++;\\n            i=i/10;\\n        }\\n        int increment=1;\\n        i=1;\\n        for(int j=0;j<t-1;j++){\\n            i=(i*10+((i%10)+1));\\n            increment=increment*10+1;\\n        }\\n        int last=i;\\n        while(i<low){\\n            if(i%10==9){\\n                i=last*10+((last%10)+1);\\n                last=i;\\n                increment=increment*10+1;\\n            }else{\\n                i+=increment;    \\n            }\\n        }\\n       while(i<=high){\\n           res.push_back(i);\\n           if(i%10==9){\\n                i=last*10+((last%10)+1);\\n                last=i;\\n                increment=increment*10+1;\\n            }else{\\n                i+=increment;    \\n            }\\n       }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718489,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(int low, int high, int i, int num){\\n        if(num>=low && num<=high) ans.push_back(num);\\n        if(num>high || i>9) return;\\n        dfs(low, high, i+1, num*10+i);\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        for(int i=1;i<=9;i++) dfs(low, high, i, 0);\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void dfs(int low, int high, int i, int num){\\n        if(num>=low && num<=high) ans.push_back(num);\\n        if(num>high || i>9) return;\\n        dfs(low, high, i+1, num*10+i);\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        for(int i=1;i<=9;i++) dfs(low, high, i, 0);\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716946,
                "title": "c-using-string-100-fast-takes-less-than-90-56-memory",
                "content": "```c++\\nclass Solution {\\npublic:\\n\\t//function that returns the number of digits in an integer\\n    int countDigits(int low) {\\n        int digits = 0;\\n        while(low) {\\n            low /= 10;\\n            digits++;\\n        }\\n        return digits;\\n    }\\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n\\t\\t//this is the maximum number of which all the other sequences are substrings of\\n\\t\\t//we\\'ll be taking substrings from this number, converting the substring to int\\n\\t\\t//and adding the number to the vector\\n        string n = \"123456789\";\\n\\t\\t//vector that\\'s to be returned\\n        vector<int> answerSet;\\n\\t\\t//get the current substring length\\n\\t\\t//substring length should be between low and high inclusive\\n\\t\\t//we\\'ll be initialising this with the number of digits in low (our starting point)\\n        int currSubString = countDigits(low);\\n        \\n\\t\\t//taking long to avoid integer overflow\\n        for(long int i = 10; i <= high; i*=10){\\n\\t\\t\\t//inner loop to traverse the string (containing the max. number) and extract the substrings from it\\n            for(int j = 0; j < 10; j++) {\\n\\t\\t\\t\\t//checking if the combined length of offset and substring length is less than 10\\n                if(currSubString + j < 10) {\\n\\t\\t\\t\\t\\t//checking if the substring integer value is within low and high. if true, add it to vector\\n                    if(stoi(n.substr(j, currSubString)) <= high && stoi(n.substr(j, currSubString)) >= low) {\\n                        answerSet.push_back(stoi(n.substr(j, currSubString)));\\n                    }\\n                }\\n            }\\n\\t\\t\\t//after each pass, increasing the substring length by 1.\\n\\t\\t\\t//example, 123,234,...,1234\\n            currSubString++;\\n        }\\n        \\n        return answerSet;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n\\t//function that returns the number of digits in an integer\\n    int countDigits(int low) {\\n        int digits = 0;\\n        while(low) {\\n            low /= 10;\\n            digits++;\\n        }\\n        return digits;\\n    }\\n    \\n    vector<int> sequentialDigits(int low, int high) {\\n\\t\\t//this is the maximum number of which all the other sequences are substrings of\\n\\t\\t//we\\'ll be taking substrings from this number, converting the substring to int\\n\\t\\t//and adding the number to the vector\\n        string n = \"123456789\";\\n\\t\\t//vector that\\'s to be returned\\n        vector<int> answerSet;\\n\\t\\t//get the current substring length\\n\\t\\t//substring length should be between low and high inclusive\\n\\t\\t//we\\'ll be initialising this with the number of digits in low (our starting point)\\n        int currSubString = countDigits(low);\\n        \\n\\t\\t//taking long to avoid integer overflow\\n        for(long int i = 10; i <= high; i*=10){\\n\\t\\t\\t//inner loop to traverse the string (containing the max. number) and extract the substrings from it\\n            for(int j = 0; j < 10; j++) {\\n\\t\\t\\t\\t//checking if the combined length of offset and substring length is less than 10\\n                if(currSubString + j < 10) {\\n\\t\\t\\t\\t\\t//checking if the substring integer value is within low and high. if true, add it to vector\\n                    if(stoi(n.substr(j, currSubString)) <= high && stoi(n.substr(j, currSubString)) >= low) {\\n                        answerSet.push_back(stoi(n.substr(j, currSubString)));\\n                    }\\n                }\\n            }\\n\\t\\t\\t//after each pass, increasing the substring length by 1.\\n\\t\\t\\t//example, 123,234,...,1234\\n            currSubString++;\\n        }\\n        \\n        return answerSet;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716063,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int sti(string &s){\\n        stringstream ss(s);\\n        int num = 0;\\n        ss>>num;\\n        return num;\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        string s = \"123456789\";\\n        vector<int>ans;\\n        for(int i=0; i<s.size();i++){\\n            string temp = \"\";\\n            for(int j = i;j<s.size();j++){\\n                temp.push_back(s[j]);\\n                int num = sti(temp);\\n                if(num >= low && num <= high)\\n                ans.push_back(num);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sti(string &s){\\n        stringstream ss(s);\\n        int num = 0;\\n        ss>>num;\\n        return num;\\n    }\\n    vector<int> sequentialDigits(int low, int high) {\\n        string s = \"123456789\";\\n        vector<int>ans;\\n        for(int i=0; i<s.size();i++){\\n            string temp = \"\";\\n            for(int j = i;j<s.size();j++){\\n                temp.push_back(s[j]);\\n                int num = sti(temp);\\n                if(num >= low && num <= high)\\n                ans.push_back(num);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714032,
                "title": "java-0ms-using-stringbuilder",
                "content": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList<>();\\n        int len = String.valueOf(low).length(),i=1;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(i=1;i<=len;i++) sb.append(i);\\n        \\n        while(true){\\n            int num = Integer.parseInt(sb.toString());\\n            if(num >= low && num <= high) res.add(num);\\n            if(num > high) break;\\n            \\n\\t\\t\\t// if last digit is 9 then we increment size of num  Eg. 6789 to 12345\\n            if(i > 9){     \\n               sb.setLength(0);   // clear sb\\n                ++len;               \\n                if(len > 9) break;   // since max sequential no. possible is 123456789\\n               for(i=1;i<=len;i++) sb.append(i);  \\n            }\\n            else{   \\n            sb.delete(0,1);\\n            sb.append(i++);   \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> sequentialDigits(int low, int high) {\\n        List<Integer> res = new ArrayList<>();\\n        int len = String.valueOf(low).length(),i=1;\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(i=1;i<=len;i++) sb.append(i);\\n        \\n        while(true){\\n            int num = Integer.parseInt(sb.toString());\\n            if(num >= low && num <= high) res.add(num);\\n            if(num > high) break;\\n            \\n\\t\\t\\t// if last digit is 9 then we increment size of num  Eg. 6789 to 12345\\n            if(i > 9){     \\n               sb.setLength(0);   // clear sb\\n                ++len;               \\n                if(len > 9) break;   // since max sequential no. possible is 123456789\\n               for(i=1;i<=len;i++) sb.append(i);  \\n            }\\n            else{   \\n            sb.delete(0,1);\\n            sb.append(i++);   \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713948,
                "title": "python-self-explanatory-o-1-easy-code-without-sorting-or-queue",
                "content": "Since the length of the string is limited, it\\'s an O(1) solution.\\n\\nIntuition: check all possible strings from length 2 to 9, whenever it exceeds high break the loop.\\nEg. 12, 23, 34, ......123, 234, ..... 123456789\\n\\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        string = \"123456789\"\\n        \\n        ans = []\\n        \\n        for i in range(1, 10):\\n            for j in range(8):\\n                temp = int(string[j: j+i], 10)\\n                \\n                if(j+i>9 or temp>high): \\n                    break\\n                    \\n                if(low<=temp<=high):\\n                    ans.append(temp)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        string = \"123456789\"\\n        \\n        ans = []\\n        \\n        for i in range(1, 10):\\n            for j in range(8):\\n                temp = int(string[j: j+i], 10)\\n                \\n                if(j+i>9 or temp>high): \\n                    break\\n                    \\n                if(low<=temp<=high):\\n                    ans.append(temp)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713918,
                "title": "c-easy-to-understand-beginners-friendly-strings-used",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        string s=\"123456789\";\\n        int l=low;\\n        int h=high;\\n        int lcount=0,hcount=0;\\n        \\n                    \\n        while(l>0)\\n        {\\n            l=l/10;\\n            lcount++;\\n        }\\n        while(h>0)\\n        {\\n            h=h/10;\\n            hcount++;\\n        }\\n        \\n        \\n        \\n        for(int i=lcount ; i<=hcount ; i++)\\n        {\\n            for(int j=0;j<=9;j++)\\n            {\\n                if((i+j)<=9)\\n                {\\n                    string ss = s.substr(j,i);\\n                    int value = stoi(ss);\\n                    if(value>=low && value<=high)\\n                    {\\n                        ans.push_back(value);\\n                    }\\n                    \\n                }\\n            }       \\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> ans;\\n        string s=\"123456789\";\\n        int l=low;\\n        int h=high;\\n        int lcount=0,hcount=0;\\n        \\n                    \\n        while(l>0)\\n        {\\n            l=l/10;\\n            lcount++;\\n        }\\n        while(h>0)\\n        {\\n            h=h/10;\\n            hcount++;\\n        }\\n        \\n        \\n        \\n        for(int i=lcount ; i<=hcount ; i++)\\n        {\\n            for(int j=0;j<=9;j++)\\n            {\\n                if((i+j)<=9)\\n                {\\n                    string ss = s.substr(j,i);\\n                    int value = stoi(ss);\\n                    if(value>=low && value<=high)\\n                    {\\n                        ans.push_back(value);\\n                    }\\n                    \\n                }\\n            }       \\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713680,
                "title": "sequential-digits-python-solution",
                "content": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        n1=len(str(low))\\n        n2=len(str(high))\\n        \\n        ans =[]\\n        for i in range(n1,n2+1):\\n            l=[z for z in range(1,i+1)]          \\n            \\n            for j in range(9-i+1):\\n                s=int(\"\".join(map(str,l)))\\n                if(s >=low and s<=high):\\n                    ans.append(s)\\n                l=[z+1 for z in l]\\n                \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        n1=len(str(low))\\n        n2=len(str(high))\\n        \\n        ans =[]\\n        for i in range(n1,n2+1):\\n            l=[z for z in range(1,i+1)]          \\n            \\n            for j in range(9-i+1):\\n                s=int(\"\".join(map(str,l)))\\n                if(s >=low and s<=high):\\n                    ans.append(s)\\n                l=[z+1 for z in l]\\n                \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713679,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        \\n        low_length = len(str(low))\\n        high_length = len(str(high))\\n        output = []\\n        for i in range(low_length,high_length+1):\\n            for j in range(1,9-i+2):\\n                \\n                num = [0] * i\\n                for k in range(i):\\n                    num[k] = j + k\\n                num = int(\"\".join(map(str,num)))\\n                \\n                if num >= low and num <=high:\\n                    output.append(num)\\n        \\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        \\n        low_length = len(str(low))\\n        high_length = len(str(high))\\n        output = []\\n        for i in range(low_length,high_length+1):\\n            for j in range(1,9-i+2):\\n                \\n                num = [0] * i\\n                for k in range(i):\\n                    num[k] = j + k\\n                num = int(\"\".join(map(str,num)))\\n                \\n                if num >= low and num <=high:\\n                    output.append(num)\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713674,
                "title": "c-ez-code-better-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int>ans;\\n        int x=(to_string(low)).length();\\n        int y=(to_string(high)).length();\\n        while(x<=y)\\n        {\\n            for(int i=1;i<=9-x+1;i++)\\n            {\\n                int tmp=0;\\n                for(int j=i;j<=i+x-1;j++)\\n                    tmp=tmp*10+j;\\n                if(tmp>=low)\\n                {\\n                    if(tmp<=high)ans.push_back(tmp);\\n                    else break;\\n                }\\n            }\\n            ++x;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int>ans;\\n        int x=(to_string(low)).length();\\n        int y=(to_string(high)).length();\\n        while(x<=y)\\n        {\\n            for(int i=1;i<=9-x+1;i++)\\n            {\\n                int tmp=0;\\n                for(int j=i;j<=i+x-1;j++)\\n                    tmp=tmp*10+j;\\n                if(tmp>=low)\\n                {\\n                    if(tmp<=high)ans.push_back(tmp);\\n                    else break;\\n                }\\n            }\\n            ++x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713630,
                "title": "c-bfs-dfs-simple-one-3-methods",
                "content": "\\'\\'\\'\\n//Method - 2. BFS\\n    //Time Complexity = O(1) \\n\\t//Space Complexity = O(1)\\n   \\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        vector<int> ans;\\n        queue<int> q {{1,2,3,4,5,6,7,8,9}};\\n        \\n        while(!q.empty())\\n        {\\n            int curr=q.front();     q.pop();\\n            if(curr>high) \\n                break;        //reached upperlimit\\n            if(curr>=low && curr<=high)\\n                ans.push_back(curr);\\n            \\n            int num = curr%10;\\n            int next = curr*10 + (num+1);\\n            \\n            if(num<9)        //if curr=89, num=9, next=890+9+1=900 - test case failed at this condition, i.e. to avoid getting 900, etc.\\n                q.push(next);           //1234 -> 12345, if curr=1234, next=12345 pushed to queue\\n        }\\n        return ans;        \\n    }\\n\\t\\'\\'\\'\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t//Method - 1. DFS \\n\\t//Time Complexity- O(nlogn) \\n\\t//Space Complexity = O(n)\\n\\t\\n\\t\\'\\'\\'\\n    vector<int> ans;\\n    vector<int> sequentialDigits(int low, int high) {\\n        for(int i=1;i<=9;i++)\\n        {\\n            dfs(low,high,i,0);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    void dfs(int low,int high,int i,int num)\\n    {\\n        //lies in range\\n        if(num>=low && num<=high)\\n            ans.push_back(num);\\n        \\n        //to avoid 78910 , after 789\\n        if(i>9)         \\n            return;\\n        \\n        dfs(low, high, i+1, num*10 + i);\\n    }\\n\\t\\'\\'\\'\\n\\t\\n\\t\\n\\n\\t//Method - Just for fun\\n\\t\\n\\t\\'\\'\\'\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> a={12,23,34,45,56,67,78,89,\\n                        123,234,345,456,567,678,789,\\n                        1234,2345,3456,4567,5678,6789,\\n                        12345,23456,34567,45678,56789,\\n                        123456,234567,345678,456789,\\n                        1234567,2345678,3456789,\\n                        12345678,23456789,\\n                        123456789};\\n\\t\\t\\t\\t\\t\\t\\n        vector<int> ans;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]>=low && a[i]<=high)\\n                ans.push_back(a[i]);\\n        }\\n        return ans;\\n    }\\n\\t\\'\\'\\'\\n\\t\\n\\t\\n\\t//Ref - Leetcode Discussion Section",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Enumeration"
                ],
                "code": "\\'\\'\\'\\n//Method - 2. BFS\\n    //Time Complexity = O(1) \\n\\t//Space Complexity = O(1)\\n   \\n    vector<int> sequentialDigits(int low, int high) {\\n        \\n        vector<int> ans;\\n        queue<int> q {{1,2,3,4,5,6,7,8,9}};\\n        \\n        while(!q.empty())\\n        {\\n            int curr=q.front();     q.pop();\\n            if(curr>high) \\n                break;        //reached upperlimit\\n            if(curr>=low && curr<=high)\\n                ans.push_back(curr);\\n            \\n            int num = curr%10;\\n            int next = curr*10 + (num+1);\\n            \\n            if(num<9)        //if curr=89, num=9, next=890+9+1=900 - test case failed at this condition, i.e. to avoid getting 900, etc.\\n                q.push(next);           //1234 -> 12345, if curr=1234, next=12345 pushed to queue\\n        }\\n        return ans;        \\n    }\\n\\t\\'\\'\\'\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t//Method - 1. DFS \\n\\t//Time Complexity- O(nlogn) \\n\\t//Space Complexity = O(n)\\n\\t\\n\\t\\'\\'\\'\\n    vector<int> ans;\\n    vector<int> sequentialDigits(int low, int high) {\\n        for(int i=1;i<=9;i++)\\n        {\\n            dfs(low,high,i,0);\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n    \\n    void dfs(int low,int high,int i,int num)\\n    {\\n        //lies in range\\n        if(num>=low && num<=high)\\n            ans.push_back(num);\\n        \\n        //to avoid 78910 , after 789\\n        if(i>9)         \\n            return;\\n        \\n        dfs(low, high, i+1, num*10 + i);\\n    }\\n\\t\\'\\'\\'\\n\\t\\n\\t\\n\\n\\t//Method - Just for fun\\n\\t\\n\\t\\'\\'\\'\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> a={12,23,34,45,56,67,78,89,\\n                        123,234,345,456,567,678,789,\\n                        1234,2345,3456,4567,5678,6789,\\n                        12345,23456,34567,45678,56789,\\n                        123456,234567,345678,456789,\\n                        1234567,2345678,3456789,\\n                        12345678,23456789,\\n                        123456789};\\n\\t\\t\\t\\t\\t\\t\\n        vector<int> ans;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]>=low && a[i]<=high)\\n                ans.push_back(a[i]);\\n        }\\n        return ans;\\n    }\\n\\t\\'\\'\\'\\n\\t\\n\\t\\n\\t//Ref - Leetcode Discussion Section",
                "codeTag": "Unknown"
            },
            {
                "id": 1713626,
                "title": "sequential-digit-cpp-o-1-runtime-beats-100-solution",
                "content": "Given the range of low and  high : 10 <= low <= high <= 10^9\\nStore all the sequential numbers in number array\\nnumber{12,23,34,45,56,67,78,89,123,234,345,456,567,678,789,1234,2345,3456,4567,5678,6789,12345,23456,34567,45678,56789,123456,234567,345678,456789,1234567,2345678,3456789,12345678,23456789,123456789}\\n itterate number array, If number[i] is in range of low and high then push that value in result vector. After interating over number array, return result vector.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> res;\\n        vector<int> numbers{12,23,34,45,56,67,78,89,123,234,345,456,567,678,789,1234,2345,3456,4567,5678,6789,12345,23456,34567,45678,56789,123456,234567,345678,456789,1234567,2345678,3456789,12345678,23456789,123456789};\\n        for(int i: numbers)\\n        {\\n            if(i>= low and i<= high)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> res;\\n        vector<int> numbers{12,23,34,45,56,67,78,89,123,234,345,456,567,678,789,1234,2345,3456,4567,5678,6789,12345,23456,34567,45678,56789,123456,234567,345678,456789,1234567,2345678,3456789,12345678,23456789,123456789};\\n        for(int i: numbers)\\n        {\\n            if(i>= low and i<= high)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713533,
                "title": "faster-than-100-of-c-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> nums, sol;\\n        for (int len = 2; len <= 9; ++len) { // Length of sequence numbers ranges from 2 to 9.\\n            for (int st = 1; st <= 8; ++st) { // No sequence number can start with nine they start with any number in the range [1, 8].\\n                if (st + len - 1 > 9) break; // For example no sequence number that starts with 8 can have a length of more than 2.\\n                int num = 0;\\n                for (int i = st; i < st + len; ++i) {\\n                    num *= 10; num += i; // Generate all sequence numbers.\\n                }\\n                nums.push_back(num); // Generated array is sorted.\\n            }\\n        }\\n        int st = lower_bound(nums.begin(), nums.end(), low) - nums.begin(); // Binary Search on first element in the solution.\\n        for (int i = st; i < nums.size(); ++i) {\\n            if (nums[i] > high) break; // Exit the loop if the high range is violated.\\n            sol.push_back(nums[i]);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sequentialDigits(int low, int high) {\\n        vector<int> nums, sol;\\n        for (int len = 2; len <= 9; ++len) { // Length of sequence numbers ranges from 2 to 9.\\n            for (int st = 1; st <= 8; ++st) { // No sequence number can start with nine they start with any number in the range [1, 8].\\n                if (st + len - 1 > 9) break; // For example no sequence number that starts with 8 can have a length of more than 2.\\n                int num = 0;\\n                for (int i = st; i < st + len; ++i) {\\n                    num *= 10; num += i; // Generate all sequence numbers.\\n                }\\n                nums.push_back(num); // Generated array is sorted.\\n            }\\n        }\\n        int st = lower_bound(nums.begin(), nums.end(), low) - nums.begin(); // Binary Search on first element in the solution.\\n        for (int i = st; i < nums.size(); ++i) {\\n            if (nums[i] > high) break; // Exit the loop if the high range is violated.\\n            sol.push_back(nums[i]);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565809,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sequential-digits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sliding Window\n\n  \n**Approach 2:** Precomputation \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/09/sequential-digits.html"
                    },
                    {
                        "username": "Msey",
                        "content": "easiest way O(1) is to iterate all combinations:\n`            12,\n            23,\n            34,\n            45,\n            56,\n            67,\n            78,\n            89,\n            123,\n            234,\n            345,\n            456,\n            567,\n            678,\n            789,\n            1234,\n            2345,\n            3456,\n            4567,\n            5678,\n            6789,\n            12345,\n            23456,\n            34567,\n            45678,\n            56789,\n            123456,\n            234567,\n            345678,\n            456789,\n            1234567,\n            2345678,\n            3456789,\n            12345678,\n            23456789,\n            123456789`\n\nand add them if they are in range [low, high]\n\nmy one-liner as example that beats 100% https://leetcode.com/problems/sequential-digits/solutions/3647481/c-one-liner-beats-100/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-***\\n\\n- Initialize an empty list to store the integers with sequential digits.\\n- Iterate through all digits from 1 to 9 as the first digit of a potential integer.\\n- Recursively generate all possible integers with sequential digits starting from the current digit, adding one digit at a time.\\n- For each generated integer, check if it falls within the given range of [low, high]. If so, add it to the list.\\n- If the generated integer is greater than the upper bound high or has more than 9 digits, stop recursion.\\n- Sort the list of integers with sequential digits in ascending order.\\n- Return the sorted list as the final result.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Code Link:-\nhttps://leetcode.com/problems/sequential-digits/solutions/3310270/backtracking-and-string-manipulation-solution/"
                    },
                    {
                        "username": "_shubham10",
                        "content": "Declare a string = \"123456789\" and think of sliding window."
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "Should be easy (imho)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here are some tips that can help you:\n1.Generate a valid number of the low's size for example if the size is 4 then the valid number 1234 and start from this variable.\n1.If the number have 0 at its last then it is not a valid number for example:-12345678910.\n2.Every time you hit a number that is having a number 0 at its last then generate a new valid number from 1 to size+1.For example if you get a number 7890 then generate a new valid number of size+1 i.e 12345.\n3.If the number is not having a number 0 at its end then it is definitely a valid number now add 1 to all the integer of the digit.\nCode link:-https://leetcode.com/problems/sequential-digits/solutions/3531823/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1570175,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sequential-digits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sliding Window\n\n  \n**Approach 2:** Precomputation \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/09/sequential-digits.html"
                    },
                    {
                        "username": "Msey",
                        "content": "easiest way O(1) is to iterate all combinations:\n`            12,\n            23,\n            34,\n            45,\n            56,\n            67,\n            78,\n            89,\n            123,\n            234,\n            345,\n            456,\n            567,\n            678,\n            789,\n            1234,\n            2345,\n            3456,\n            4567,\n            5678,\n            6789,\n            12345,\n            23456,\n            34567,\n            45678,\n            56789,\n            123456,\n            234567,\n            345678,\n            456789,\n            1234567,\n            2345678,\n            3456789,\n            12345678,\n            23456789,\n            123456789`\n\nand add them if they are in range [low, high]\n\nmy one-liner as example that beats 100% https://leetcode.com/problems/sequential-digits/solutions/3647481/c-one-liner-beats-100/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-***\\n\\n- Initialize an empty list to store the integers with sequential digits.\\n- Iterate through all digits from 1 to 9 as the first digit of a potential integer.\\n- Recursively generate all possible integers with sequential digits starting from the current digit, adding one digit at a time.\\n- For each generated integer, check if it falls within the given range of [low, high]. If so, add it to the list.\\n- If the generated integer is greater than the upper bound high or has more than 9 digits, stop recursion.\\n- Sort the list of integers with sequential digits in ascending order.\\n- Return the sorted list as the final result.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Code Link:-\nhttps://leetcode.com/problems/sequential-digits/solutions/3310270/backtracking-and-string-manipulation-solution/"
                    },
                    {
                        "username": "_shubham10",
                        "content": "Declare a string = \"123456789\" and think of sliding window."
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "Should be easy (imho)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here are some tips that can help you:\n1.Generate a valid number of the low's size for example if the size is 4 then the valid number 1234 and start from this variable.\n1.If the number have 0 at its last then it is not a valid number for example:-12345678910.\n2.Every time you hit a number that is having a number 0 at its last then generate a new valid number from 1 to size+1.For example if you get a number 7890 then generate a new valid number of size+1 i.e 12345.\n3.If the number is not having a number 0 at its end then it is definitely a valid number now add 1 to all the integer of the digit.\nCode link:-https://leetcode.com/problems/sequential-digits/solutions/3531823/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1932872,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sequential-digits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sliding Window\n\n  \n**Approach 2:** Precomputation \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/09/sequential-digits.html"
                    },
                    {
                        "username": "Msey",
                        "content": "easiest way O(1) is to iterate all combinations:\n`            12,\n            23,\n            34,\n            45,\n            56,\n            67,\n            78,\n            89,\n            123,\n            234,\n            345,\n            456,\n            567,\n            678,\n            789,\n            1234,\n            2345,\n            3456,\n            4567,\n            5678,\n            6789,\n            12345,\n            23456,\n            34567,\n            45678,\n            56789,\n            123456,\n            234567,\n            345678,\n            456789,\n            1234567,\n            2345678,\n            3456789,\n            12345678,\n            23456789,\n            123456789`\n\nand add them if they are in range [low, high]\n\nmy one-liner as example that beats 100% https://leetcode.com/problems/sequential-digits/solutions/3647481/c-one-liner-beats-100/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-***\\n\\n- Initialize an empty list to store the integers with sequential digits.\\n- Iterate through all digits from 1 to 9 as the first digit of a potential integer.\\n- Recursively generate all possible integers with sequential digits starting from the current digit, adding one digit at a time.\\n- For each generated integer, check if it falls within the given range of [low, high]. If so, add it to the list.\\n- If the generated integer is greater than the upper bound high or has more than 9 digits, stop recursion.\\n- Sort the list of integers with sequential digits in ascending order.\\n- Return the sorted list as the final result.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Code Link:-\nhttps://leetcode.com/problems/sequential-digits/solutions/3310270/backtracking-and-string-manipulation-solution/"
                    },
                    {
                        "username": "_shubham10",
                        "content": "Declare a string = \"123456789\" and think of sliding window."
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "Should be easy (imho)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here are some tips that can help you:\n1.Generate a valid number of the low's size for example if the size is 4 then the valid number 1234 and start from this variable.\n1.If the number have 0 at its last then it is not a valid number for example:-12345678910.\n2.Every time you hit a number that is having a number 0 at its last then generate a new valid number from 1 to size+1.For example if you get a number 7890 then generate a new valid number of size+1 i.e 12345.\n3.If the number is not having a number 0 at its end then it is definitely a valid number now add 1 to all the integer of the digit.\nCode link:-https://leetcode.com/problems/sequential-digits/solutions/3531823/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1835706,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sequential-digits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sliding Window\n\n  \n**Approach 2:** Precomputation \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/09/sequential-digits.html"
                    },
                    {
                        "username": "Msey",
                        "content": "easiest way O(1) is to iterate all combinations:\n`            12,\n            23,\n            34,\n            45,\n            56,\n            67,\n            78,\n            89,\n            123,\n            234,\n            345,\n            456,\n            567,\n            678,\n            789,\n            1234,\n            2345,\n            3456,\n            4567,\n            5678,\n            6789,\n            12345,\n            23456,\n            34567,\n            45678,\n            56789,\n            123456,\n            234567,\n            345678,\n            456789,\n            1234567,\n            2345678,\n            3456789,\n            12345678,\n            23456789,\n            123456789`\n\nand add them if they are in range [low, high]\n\nmy one-liner as example that beats 100% https://leetcode.com/problems/sequential-digits/solutions/3647481/c-one-liner-beats-100/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-***\\n\\n- Initialize an empty list to store the integers with sequential digits.\\n- Iterate through all digits from 1 to 9 as the first digit of a potential integer.\\n- Recursively generate all possible integers with sequential digits starting from the current digit, adding one digit at a time.\\n- For each generated integer, check if it falls within the given range of [low, high]. If so, add it to the list.\\n- If the generated integer is greater than the upper bound high or has more than 9 digits, stop recursion.\\n- Sort the list of integers with sequential digits in ascending order.\\n- Return the sorted list as the final result.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Code Link:-\nhttps://leetcode.com/problems/sequential-digits/solutions/3310270/backtracking-and-string-manipulation-solution/"
                    },
                    {
                        "username": "_shubham10",
                        "content": "Declare a string = \"123456789\" and think of sliding window."
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "Should be easy (imho)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here are some tips that can help you:\n1.Generate a valid number of the low's size for example if the size is 4 then the valid number 1234 and start from this variable.\n1.If the number have 0 at its last then it is not a valid number for example:-12345678910.\n2.Every time you hit a number that is having a number 0 at its last then generate a new valid number from 1 to size+1.For example if you get a number 7890 then generate a new valid number of size+1 i.e 12345.\n3.If the number is not having a number 0 at its end then it is definitely a valid number now add 1 to all the integer of the digit.\nCode link:-https://leetcode.com/problems/sequential-digits/solutions/3531823/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 2041369,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sequential-digits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sliding Window\n\n  \n**Approach 2:** Precomputation \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/09/sequential-digits.html"
                    },
                    {
                        "username": "Msey",
                        "content": "easiest way O(1) is to iterate all combinations:\n`            12,\n            23,\n            34,\n            45,\n            56,\n            67,\n            78,\n            89,\n            123,\n            234,\n            345,\n            456,\n            567,\n            678,\n            789,\n            1234,\n            2345,\n            3456,\n            4567,\n            5678,\n            6789,\n            12345,\n            23456,\n            34567,\n            45678,\n            56789,\n            123456,\n            234567,\n            345678,\n            456789,\n            1234567,\n            2345678,\n            3456789,\n            12345678,\n            23456789,\n            123456789`\n\nand add them if they are in range [low, high]\n\nmy one-liner as example that beats 100% https://leetcode.com/problems/sequential-digits/solutions/3647481/c-one-liner-beats-100/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-***\\n\\n- Initialize an empty list to store the integers with sequential digits.\\n- Iterate through all digits from 1 to 9 as the first digit of a potential integer.\\n- Recursively generate all possible integers with sequential digits starting from the current digit, adding one digit at a time.\\n- For each generated integer, check if it falls within the given range of [low, high]. If so, add it to the list.\\n- If the generated integer is greater than the upper bound high or has more than 9 digits, stop recursion.\\n- Sort the list of integers with sequential digits in ascending order.\\n- Return the sorted list as the final result.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Code Link:-\nhttps://leetcode.com/problems/sequential-digits/solutions/3310270/backtracking-and-string-manipulation-solution/"
                    },
                    {
                        "username": "_shubham10",
                        "content": "Declare a string = \"123456789\" and think of sliding window."
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "Should be easy (imho)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here are some tips that can help you:\n1.Generate a valid number of the low's size for example if the size is 4 then the valid number 1234 and start from this variable.\n1.If the number have 0 at its last then it is not a valid number for example:-12345678910.\n2.Every time you hit a number that is having a number 0 at its last then generate a new valid number from 1 to size+1.For example if you get a number 7890 then generate a new valid number of size+1 i.e 12345.\n3.If the number is not having a number 0 at its end then it is definitely a valid number now add 1 to all the integer of the digit.\nCode link:-https://leetcode.com/problems/sequential-digits/solutions/3531823/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1973066,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sequential-digits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sliding Window\n\n  \n**Approach 2:** Precomputation \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/09/sequential-digits.html"
                    },
                    {
                        "username": "Msey",
                        "content": "easiest way O(1) is to iterate all combinations:\n`            12,\n            23,\n            34,\n            45,\n            56,\n            67,\n            78,\n            89,\n            123,\n            234,\n            345,\n            456,\n            567,\n            678,\n            789,\n            1234,\n            2345,\n            3456,\n            4567,\n            5678,\n            6789,\n            12345,\n            23456,\n            34567,\n            45678,\n            56789,\n            123456,\n            234567,\n            345678,\n            456789,\n            1234567,\n            2345678,\n            3456789,\n            12345678,\n            23456789,\n            123456789`\n\nand add them if they are in range [low, high]\n\nmy one-liner as example that beats 100% https://leetcode.com/problems/sequential-digits/solutions/3647481/c-one-liner-beats-100/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-***\\n\\n- Initialize an empty list to store the integers with sequential digits.\\n- Iterate through all digits from 1 to 9 as the first digit of a potential integer.\\n- Recursively generate all possible integers with sequential digits starting from the current digit, adding one digit at a time.\\n- For each generated integer, check if it falls within the given range of [low, high]. If so, add it to the list.\\n- If the generated integer is greater than the upper bound high or has more than 9 digits, stop recursion.\\n- Sort the list of integers with sequential digits in ascending order.\\n- Return the sorted list as the final result.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Code Link:-\nhttps://leetcode.com/problems/sequential-digits/solutions/3310270/backtracking-and-string-manipulation-solution/"
                    },
                    {
                        "username": "_shubham10",
                        "content": "Declare a string = \"123456789\" and think of sliding window."
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "Should be easy (imho)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here are some tips that can help you:\n1.Generate a valid number of the low's size for example if the size is 4 then the valid number 1234 and start from this variable.\n1.If the number have 0 at its last then it is not a valid number for example:-12345678910.\n2.Every time you hit a number that is having a number 0 at its last then generate a new valid number from 1 to size+1.For example if you get a number 7890 then generate a new valid number of size+1 i.e 12345.\n3.If the number is not having a number 0 at its end then it is definitely a valid number now add 1 to all the integer of the digit.\nCode link:-https://leetcode.com/problems/sequential-digits/solutions/3531823/easy-java-solution/"
                    }
                ]
            },
            {
                "id": 1896208,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/sequential-digits/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Sliding Window\n\n  \n**Approach 2:** Precomputation \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/09/sequential-digits.html"
                    },
                    {
                        "username": "Msey",
                        "content": "easiest way O(1) is to iterate all combinations:\n`            12,\n            23,\n            34,\n            45,\n            56,\n            67,\n            78,\n            89,\n            123,\n            234,\n            345,\n            456,\n            567,\n            678,\n            789,\n            1234,\n            2345,\n            3456,\n            4567,\n            5678,\n            6789,\n            12345,\n            23456,\n            34567,\n            45678,\n            56789,\n            123456,\n            234567,\n            345678,\n            456789,\n            1234567,\n            2345678,\n            3456789,\n            12345678,\n            23456789,\n            123456789`\n\nand add them if they are in range [low, high]\n\nmy one-liner as example that beats 100% https://leetcode.com/problems/sequential-digits/solutions/3647481/c-one-liner-beats-100/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-***\\n\\n- Initialize an empty list to store the integers with sequential digits.\\n- Iterate through all digits from 1 to 9 as the first digit of a potential integer.\\n- Recursively generate all possible integers with sequential digits starting from the current digit, adding one digit at a time.\\n- For each generated integer, check if it falls within the given range of [low, high]. If so, add it to the list.\\n- If the generated integer is greater than the upper bound high or has more than 9 digits, stop recursion.\\n- Sort the list of integers with sequential digits in ascending order.\\n- Return the sorted list as the final result.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Code Link:-\nhttps://leetcode.com/problems/sequential-digits/solutions/3310270/backtracking-and-string-manipulation-solution/"
                    },
                    {
                        "username": "_shubham10",
                        "content": "Declare a string = \"123456789\" and think of sliding window."
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "Should be easy (imho)"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Here are some tips that can help you:\n1.Generate a valid number of the low's size for example if the size is 4 then the valid number 1234 and start from this variable.\n1.If the number have 0 at its last then it is not a valid number for example:-12345678910.\n2.Every time you hit a number that is having a number 0 at its last then generate a new valid number from 1 to size+1.For example if you get a number 7890 then generate a new valid number of size+1 i.e 12345.\n3.If the number is not having a number 0 at its end then it is definitely a valid number now add 1 to all the integer of the digit.\nCode link:-https://leetcode.com/problems/sequential-digits/solutions/3531823/easy-java-solution/"
                    }
                ]
            }
        ]
    }
]