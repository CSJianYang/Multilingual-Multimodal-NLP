[
    {
        "title": "Most Stones Removed with Same Row or Column",
        "question_content": "On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.\nA stone can be removed if it shares either the same row or the same column as another stone that has not been removed.\nGiven an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.\n&nbsp;\nExample 1:\n\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\nOutput: 5\nExplanation: One way to remove 5 stones is as follows:\n1. Remove stone [2,2] because it shares the same row as [2,1].\n2. Remove stone [2,1] because it shares the same column as [0,1].\n3. Remove stone [1,2] because it shares the same row as [1,0].\n4. Remove stone [1,0] because it shares the same column as [0,0].\n5. Remove stone [0,1] because it shares the same row as [0,0].\nStone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.\n\nExample 2:\n\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\nOutput: 3\nExplanation: One way to make 3 moves is as follows:\n1. Remove stone [2,2] because it shares the same row as [2,0].\n2. Remove stone [2,0] because it shares the same column as [0,0].\n3. Remove stone [0,2] because it shares the same row as [0,0].\nStones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.\n\nExample 3:\n\nInput: stones = [[0,0]]\nOutput: 0\nExplanation: [0,0] is the only stone on the plane, so you cannot remove it.\n\n&nbsp;\nConstraints:\n\n\t1 <= stones.length <= 1000\n\t0 <= xi, yi <= 104\n\tNo two stones are at the same coordinate point.",
        "solutions": [
            {
                "id": 197668,
                "title": "count-the-number-of-islands-o-n",
                "content": "I said it\\'s a hard problem, LC rated it as medium.\\n\\n## **Problem:**\\nwe can remove a stone if and only if,\\nthere is another stone in the same column OR row.\\nWe try to remove as many as stones as possible.\\n<br>\\n\\n## **One sentence to solve:**\\nConnected stones can be reduced to 1 stone,\\nthe maximum stones can be removed = stones number - islands number.\\nso just count the number of \"islands\".\\n<br>\\n\\n## **1. Connected stones**\\nTwo stones are connected if they are in the same row or same col.\\nConnected stones will build a connected graph.\\nIt\\'s obvious that in one connected graph,\\nwe can\\'t remove all stones.\\n\\nWe have to have one stone left.\\nAn intuition is that, in the best strategy, we can remove until 1 stone.\\n\\nI guess you may reach this step when solving the problem.\\nBut the important question is, how?\\n<br>\\n\\n## **2. A failed strategy**\\nTry to remove the least degree stone\\nLike a tree, we try to remove leaves first.\\nSome new leaf generated.\\nWe continue this process until the root node left.\\n\\n\\nHowever, there can be no leaf.\\nWhen you try to remove the least in-degree stone,\\nit won\\'t work on this \"8\" like graph:\\n[[1, 1, 0, 0, 0],\\n [1, 1, 0, 0, 0],\\n [0, 1, 1, 0, 0],\\n [0, 0, 1, 1, 1],\\n [0, 0, 0, 1, 1]]\\n\\nThe stone in the center has least degree = 2.\\nBut if you remove this stone first,\\nthe whole connected stones split into 2 parts,\\nand you will finish with 2 stones left.\\n<br>\\n\\n## **3. A good strategy**\\n\\nIn fact, the proof is really straightforward.\\nYou probably apply a `DFS`, from one stone to next connected stone.\\nYou can remove stones in reversed order.\\nIn this way, all stones can be removed but the stone that you start your DFS.\\n\\nOne more step of explanation:\\nIn the view of DFS, a graph is explored in the structure of a tree.\\nAs we discussed previously,\\na tree can be removed in topological order,\\nfrom leaves to root.\\n<br>\\n\\n## **4. Count the number of islands**\\nWe call a connected graph as an island.\\nOne island must have at least one stone left.\\nThe maximum stones can be removed = stones number - islands number\\n\\nThe whole problem is transferred to:\\nWhat is the number of islands?\\n\\nYou can show all your skills on a DFS implementation,\\nand solve this problem as a normal one.\\n<br>\\n\\n## **5. Unify index**\\n\\nStruggle between rows and cols?\\nYou may duplicate your codes when you try to the same thing on rows and cols.\\nIn fact, no logical difference between col index and rows index.\\n\\nAn easy trick is that, add 10000 to col index.\\nSo we use 0 ~ 9999 for row index and 10000 ~ 19999 for col.\\n<br>\\n\\n## **6. Search on the index, not the points**\\nWhen we search on points,\\nwe alternately change our view on a row and on a col.\\n\\nWe think:\\na row index, connect two stones on this row\\na col index, connect two stones on this col.\\n\\nIn another view\\uFF1A\\nA stone, connect a row index and col.\\n\\nHave this idea in mind, the solution can be much simpler.\\nThe number of islands of *points*,\\nis the same as the number of islands of *indexes*.\\n<br>\\n\\n## **7. Union-Find**\\n\\nI use union find to solve this problem.\\nAs I mentioned, the elements are not the points, but the indexes.\\n1. for each point, union two indexes.\\n2. return points number - union number\\n\\nCopy a template of union-find,\\nwrite 2 lines above,\\nyou can solve this problem in several minutes.\\n<br>\\n\\n## **Complexity**\\nunion and find functions have worst case `O(N)`, amortize `O(1)`\\nThe whole union-find solution with path compression,\\nhas `O(N)` Time, `O(N)` Space\\n\\nIf you have any doubts on time complexity,\\nplease refer to [wikipedia](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) first.\\n<br>\\n\\n**C++:**\\n```\\n    int removeStones(vector<vector<int>>& stones) {\\n        for (int i = 0; i < stones.size(); ++i)\\n            uni(stones[i][0], ~stones[i][1]);\\n        return stones.size() - islands;\\n    }\\n\\n    unordered_map<int, int> f;\\n    int islands = 0;\\n\\n    int find(int x) {\\n        if (!f.count(x)) f[x] = x, islands++;\\n        if (x != f[x]) f[x] = find(f[x]);\\n        return f[x];\\n    }\\n\\n    void uni(int x, int y) {\\n        x = find(x), y = find(y);\\n        if (x != y) f[x] = y, islands--;\\n    }\\n```\\n\\n**Java:**\\n```\\n    Map<Integer, Integer> f = new HashMap<>();\\n    int islands = 0;\\n\\n    public int removeStones(int[][] stones) {\\n        for (int i = 0; i < stones.length; ++i)\\n            union(stones[i][0], ~stones[i][1]);\\n        return stones.length - islands;\\n    }\\n\\n    public int find(int x) {\\n        if (f.putIfAbsent(x, x) == null)\\n            islands++;\\n        if (x != f.get(x))\\n            f.put(x, find(f.get(x)));\\n        return f.get(x);\\n    }\\n\\n    public void union(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x != y) {\\n            f.put(x, y);\\n            islands--;\\n        }\\n    }\\n```\\n\\n**Python:**\\n```\\n    def removeStones(self, points):\\n        UF = {}\\n        def find(x):\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        def union(x, y):\\n            UF.setdefault(x, x)\\n            UF.setdefault(y, y)\\n            UF[find(x)] = find(y)\\n\\n        for i, j in points:\\n            union(i, ~j)\\n        return len(points) - len({find(x) for x in UF})\\n```\\n**Python, shorter version**\\nsuggested by @HeII0W0rId\\n```py\\n    def removeStones(self, points):\\n        uf = {}\\n        def find(x):\\n            if x != uf.setdefault(x, x):\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        for i, j in points:\\n            uf[find(i)] = find(~j)\\n        return len(points) - len({find(x) for x in uf})\\n```\\n<br>\\n\\n## **Update About Union Find Complexity**\\nI have 3 main reasons\\xA0that always insist `O(N)`, on all my union find solutions.\\n\\n1. The most important, union find is really a common knowledge for algorithm.\\nUsing both\\xA0path\\xA0compression,\\xA0splitting, or\\xA0halving\\xA0and\\xA0union by\\xA0rank\\xA0or\\xA0size\\xA0ensures\\nthat the\\xA0amortized\\xA0time per operation is only\\xA0O(1).\\nSo it\\'s fair enough to apply this conclusion.\\n\\n2. \\xA0It\\'s really not my job to discuss how union find works or the definition of big O.\\nI bet everyone can find better resource than my post on this part.\\nYou can see the core of my solution is to transform the problem as a union find problem.\\nThe essence is the thinking process behind.\\nPeople can have their own template and solve this problem with 2-3 more lines.\\nBut not all the people get the point.\\xA0\\xA0\\n\\n3. I personally\\xA0manually\\xA0write this version of union find every time.\\nIt is really not worth a long template.\\nThe version with path compression can well handle all cases on leetcode.\\nWhat\\u2018s the benefit here to add more lines?\\xA0\\n\\n4. In this problem, there is `N` union operation, at most `2 * sqrt(N)` node.\\nWhen `N` get bigger, the most operation of union operation is amortize `O(1)`.\\n\\n5. I knew there were three good resourse of union find:\\n    * [top down analusis of path compression](http://www.cs.tau.ac.il/~michas/ufind.pdf)\\n    * [wiki](https://en.wikipedia.org/wiki/Disjoint-set_data_structure#cite_note-Cormen2009-10)\\n    * [stackexchange](https://cs.stackexchange.com/questions/50294/why-is-the-path-compression-no-rank-for-disjoint-sets-o-log-n-amortized-fo)\\n\\n    But they most likely give a upper bound time complexity of union find,\\n    not a supreme.\\n    If anyone has a clear example of union find operation sequence,\\n    to make it larger than O(N), I am so glad to know it.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    int removeStones(vector<vector<int>>& stones) {\\n        for (int i = 0; i < stones.size(); ++i)\\n            uni(stones[i][0], ~stones[i][1]);\\n        return stones.size() - islands;\\n    }\\n\\n    unordered_map<int, int> f;\\n    int islands = 0;\\n\\n    int find(int x) {\\n        if (!f.count(x)) f[x] = x, islands++;\\n        if (x != f[x]) f[x] = find(f[x]);\\n        return f[x];\\n    }\\n\\n    void uni(int x, int y) {\\n        x = find(x), y = find(y);\\n        if (x != y) f[x] = y, islands--;\\n    }\\n```\n```\\n    Map<Integer, Integer> f = new HashMap<>();\\n    int islands = 0;\\n\\n    public int removeStones(int[][] stones) {\\n        for (int i = 0; i < stones.length; ++i)\\n            union(stones[i][0], ~stones[i][1]);\\n        return stones.length - islands;\\n    }\\n\\n    public int find(int x) {\\n        if (f.putIfAbsent(x, x) == null)\\n            islands++;\\n        if (x != f.get(x))\\n            f.put(x, find(f.get(x)));\\n        return f.get(x);\\n    }\\n\\n    public void union(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x != y) {\\n            f.put(x, y);\\n            islands--;\\n        }\\n    }\\n```\n```\\n    def removeStones(self, points):\\n        UF = {}\\n        def find(x):\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        def union(x, y):\\n            UF.setdefault(x, x)\\n            UF.setdefault(y, y)\\n            UF[find(x)] = find(y)\\n\\n        for i, j in points:\\n            union(i, ~j)\\n        return len(points) - len({find(x) for x in UF})\\n```\n```py\\n    def removeStones(self, points):\\n        uf = {}\\n        def find(x):\\n            if x != uf.setdefault(x, x):\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        for i, j in points:\\n            uf[find(i)] = find(~j)\\n        return len(points) - len({find(x) for x in uf})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 209369,
                "title": "java-recursive-dfs-short-and-easy-to-understand",
                "content": "Time : O(N^2), N = # of stones\\nSpace: O(N)\\n```\\nclass Solution {\\n    // Ans = # of stones \\u2013 # of islands\\n    public int removeStones(int[][] stones) {\\n        Set<int[]> visited = new HashSet();\\n        int numOfIslands = 0;\\n        for (int[] s1:stones){\\n            if (!visited.contains(s1)){\\n               dfs(s1, visited, stones); \\n               numOfIslands++;\\n            }\\n        }\\n        return stones.length - numOfIslands;\\n    }\\n    \\n    private void dfs(int[] s1, Set<int[]> visited, int[][] stones){\\n        visited.add(s1);\\n        for (int[] s2: stones){\\n            if (!visited.contains(s2)){\\n\\t\\t\\t\\t// stone with same row or column. group them into island\\n                if (s1[0] == s2[0] || s1[1] == s2[1])\\n                    dfs(s2, visited, stones);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Ans = # of stones \\u2013 # of islands\\n    public int removeStones(int[][] stones) {\\n        Set<int[]> visited = new HashSet();\\n        int numOfIslands = 0;\\n        for (int[] s1:stones){\\n            if (!visited.contains(s1)){\\n               dfs(s1, visited, stones); \\n               numOfIslands++;\\n            }\\n        }\\n        return stones.length - numOfIslands;\\n    }\\n    \\n    private void dfs(int[] s1, Set<int[]> visited, int[][] stones){\\n        visited.add(s1);\\n        for (int[] s2: stones){\\n            if (!visited.contains(s2)){\\n\\t\\t\\t\\t// stone with same row or column. group them into island\\n                if (s1[0] == s2[0] || s1[1] == s2[1])\\n                    dfs(s2, visited, stones);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198141,
                "title": "python-concise-dfs",
                "content": "* If you got the idea, question is basically asking for number of islands\\n* The key point is here, we define an island as number of points that are connected by row or column. Every point does not have to be next to each other.\\n* Rest is donkey work.\\n```\\nclass Solution:\\n    def removeStones(self, stones):\\n        def dfs(i, j):\\n            points.discard((i, j))\\n            for y in rows[i]:\\n                if (i, y) in points:\\n                    dfs(i, y)\\n            for x in cols[j]:\\n                if (x, j) in points:\\n                    dfs(x, j)\\n        points, island, rows, cols = {(i, j) for i, j in stones}, 0, collections.defaultdict(list), collections.defaultdict(list)\\n        for i, j in stones:\\n            rows[i].append(j)\\n            cols[j].append(i)\\n        for i, j in stones:\\n            if (i, j) in points:\\n                dfs(i, j)\\n                island += 1\\n        return len(stones) - island\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones):\\n        def dfs(i, j):\\n            points.discard((i, j))\\n            for y in rows[i]:\\n                if (i, y) in points:\\n                    dfs(i, y)\\n            for x in cols[j]:\\n                if (x, j) in points:\\n                    dfs(x, j)\\n        points, island, rows, cols = {(i, j) for i, j in stones}, 0, collections.defaultdict(list), collections.defaultdict(list)\\n        for i, j in stones:\\n            rows[i].append(j)\\n            cols[j].append(i)\\n        for i, j in stones:\\n            if (i, j) in points:\\n                dfs(i, j)\\n                island += 1\\n        return len(stones) - island\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197693,
                "title": "java-union-find",
                "content": "1. If stone `a` and stone `b` are in the same column/row, we connect them as a component\\n2. One component can be removed to one stone left at least.\\n3. The largest possible number of moves we can make = Total stones count - count of stones left = Total stones count - count of components.\\n\\n```\\nclass Solution {\\n    int count = 0;\\n    public int removeStones(int[][] stones) {\\n        Map<String, String> parent = new HashMap<>();\\n        count = stones.length;\\n        // init Union Find\\n        for (int[] stone : stones) {\\n            String s = stone[0] + \" \" + stone[1];\\n            parent.put(s, s);\\n        }\\n        for (int[] s1 : stones) {\\n            String ss1 = s1[0] + \" \" + s1[1];\\n            for (int[] s2 : stones) {\\n                if (s1[0] == s2[0] || s1[1] == s2[1]) { // in the same column or row\\n                    String ss2 = s2[0] + \" \" + s2[1];\\n                    union(parent, ss1, ss2);\\n                }\\n            }\\n        }\\n        return stones.length - count;\\n    }\\n    private void union(Map<String, String> parent, String s1, String s2) {\\n        String r1 = find(parent, s1), r2 = find(parent, s2);\\n        if (r1.equals(r2)) {\\n            return;\\n        }\\n        parent.put(r1, r2);\\n        count--;\\n    }\\n    private String find(Map<String, String> parent, String s) {\\n        if (!parent.get(s).equals(s)) {\\n            parent.put(s, find(parent, parent.get(s)));\\n        }\\n        return parent.get(s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int removeStones(int[][] stones) {\\n        Map<String, String> parent = new HashMap<>();\\n        count = stones.length;\\n        // init Union Find\\n        for (int[] stone : stones) {\\n            String s = stone[0] + \" \" + stone[1];\\n            parent.put(s, s);\\n        }\\n        for (int[] s1 : stones) {\\n            String ss1 = s1[0] + \" \" + s1[1];\\n            for (int[] s2 : stones) {\\n                if (s1[0] == s2[0] || s1[1] == s2[1]) { // in the same column or row\\n                    String ss2 = s2[0] + \" \" + s2[1];\\n                    union(parent, ss1, ss2);\\n                }\\n            }\\n        }\\n        return stones.length - count;\\n    }\\n    private void union(Map<String, String> parent, String s1, String s2) {\\n        String r1 = find(parent, s1), r2 = find(parent, s2);\\n        if (r1.equals(r2)) {\\n            return;\\n        }\\n        parent.put(r1, r2);\\n        count--;\\n    }\\n    private String find(Map<String, String> parent, String s) {\\n        if (!parent.get(s).equals(s)) {\\n            parent.put(s, find(parent, parent.get(s)));\\n        }\\n        return parent.get(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787296,
                "title": "c-dfs-solution-18-lines-so-simple-explanations",
                "content": "Steps:\\n\\tConsider indexes of each stone as an ID number.\\n\\tVisit each ID if it hasn\\'t been visited.(Note that we can go from stone A to stone B if and only if A and B have common row or column)\\n\\tNumber of visited stones is the answer.\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&stones,int index,vector<bool>&visited,int&n){\\n        visited[index]=true;\\n        int result=0;\\n        for(int i=0;i<n;i++)\\n            if(!visited[i]&&(stones[i][0]==stones[index][0]||stones[i][1]==stones[index][1]))\\n                result +=(dfs(stones,i,visited,n) + 1);\\n        return result;\\n    }\\n    int removeStones(vector<vector<int>>&stones) {\\n        int n = stones.size();\\n        vector<bool>visited(n,0);\\n        int result=0;\\n        for(int i=0;i<n;i++){\\n            if(visited[i]){continue;}\\n            result+=dfs(stones,i,visited,n);\\n        }\\n        return result;\\n    }\\n};\\n```\\nThank you, Please thumbs up.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>&stones,int index,vector<bool>&visited,int&n){\\n        visited[index]=true;\\n        int result=0;\\n        for(int i=0;i<n;i++)\\n            if(!visited[i]&&(stones[i][0]==stones[index][0]||stones[i][1]==stones[index][1]))\\n                result +=(dfs(stones,i,visited,n) + 1);\\n        return result;\\n    }\\n    int removeStones(vector<vector<int>>&stones) {\\n        int n = stones.size();\\n        vector<bool>visited(n,0);\\n        int result=0;\\n        for(int i=0;i<n;i++){\\n            if(visited[i]){continue;}\\n            result+=dfs(stones,i,visited,n);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812641,
                "title": "python3-dfs-bfs-union-find-explained",
                "content": "**BFS**\\n```python\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        ### construct graph\\n        ### Uing two hash map to store the neighbors on the x-axis and y-axis \\n        graphX = defaultdict(list)\\n        graphY = defaultdict(list)\\n        for x,y in stones:\\n            graphX[x].append(y)\\n            graphY[y].append(x)\\n        \\n        ### For each stone, if we haven\\'t seen it before, use a BFS to find all stones connects to it\\n        ### For each connected component, there will always be 1 stone that can not be removed\\n        ### so once we know the number of connected component, \\n        ### we can subtract it from totoal number of stones to find the number of removed stones\\n        connectedComponent = 0\\n        ### each stone should only be visited once.\\n        visited = set()\\n        for x,y in stones:\\n            ### if the current stone has not been visited, do a BFS from it.\\n            if (x,y) not in visited:\\n                q = deque([(x,y)])\\n                while q:\\n                    xo,yo = q.popleft()\\n                    ### check to see if the current stone has been visited, \\n                    ### if not, get its neighbors\\n                    if (xo,yo) not in visited:\\n                        visited.add((xo,yo))\\n                        ### since we used two hash map to store the neighbors,\\n                        ### we need to get all the neighbors fron the current stone.\\n                        for neiY in graphX[xo]:\\n                            q.append((xo,neiY))\\n                        for neiX in graphY[yo]:\\n                            q.append((neiX,yo))\\n                ### we find another connected component\\n                connectedComponent += 1\\n        \\n        return len(stones)-connectedComponent\\n```\\n\\n**DFS**\\n```python\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n\\n        graphX = defaultdict(list)\\n        graphY = defaultdict(list)\\n        for x,y in stones:\\n            graphX[x].append(y)\\n            graphY[y].append(x)\\n        \\n        def dfs(xo,yo):\\n            nonlocal visited\\n            if (xo,yo) not in visited:\\n                visited.add((xo,yo))\\n                for neiY in graphX[xo]:\\n                    dfs(xo,neiY)\\n                for neiX in graphY[yo]:\\n                    dfs(neiX,yo)\\n        \\n        connectedComponent = 0\\n        visited = set()\\n        for x,y in stones:\\n            if (x,y) not in visited:\\n                dfs(x,y)\\n                connectedComponent += 1\\n        \\n        return len(stones)-connectedComponent\\n```\\n\\n**Union-find** from [lee215](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)) with detailed comments and explanations.\\n```python\\nclass Solution:\\n    def removeStones(self, stones):\\n        \\n        ### UF is a hash map where you can find the root of a group of elements giving an element.\\n        ### A key in UF is a element, UF[x] is x\\'s parent.\\n        ### If UF[x] == x meaning x is the root of its group.\\n        UF = {}\\n        \\n        ### Given an element, find the root of the group to which this element belongs.\\n        def find(x):\\n            \\n            ### If x == UF[x], meaning x is the root of this group.\\n            ### If x != UF[x], we use the find function again on x\\'s parent UF[x] \\n            ### until we find the root and set it as the parent (value) of x in UF.\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        ### Given two elements x and y, we know that x and y should be in the same group, \\n        ### this means the group that contains x and the group that contains y \\n        ### should be merged together if they are currently separate groups.\\n        ### So we first find the root of x and the root of y using the find function.\\n        ### We then set the root of y (rootY) as the root of the root of x (rootX).\\n        def union(x, y):\\n            \\n            ### this may be the first time we see x or y, so set itself as the root.\\n            if x not in UF:\\n                UF[x] = x\\n            if y not in UF:\\n                UF[y] = y\\n            rootX = find(x)\\n            rootY = find(y)\\n            # set the root of y (rootY) as the root of the root of x (rootX)\\n            UF[rootX] = rootY\\n        \\n        ### The main reason we can use the union-find algorithm here is that we treat the x and y of each stone as a single element!\\n        ### DO NOT think of a stone as (x,y); instead, think about one stone as two elements, x and y!\\n        ### Now, a stone means two elements, x and y, that are CONNECTED.\\n        ### Since x and y can be the same, but 0 <= x, y <= 10^4, we can add 10^4 to every y \\n        ### to distinguish x and y and treat them as different elements.\\n        ### We can go to every pair of x and y (a stone), we know that x and y should be in \\n        ### the same group, so we union them.\\n        maxX = 10**4+1\\n        for x,y in stones:\\n            union(x,y+maxX)\\n        \\n        ### Finally, we go through each element in UF and find their root, count how many \\n        ### connected components (unique roots) are there and subtract it from the total \\n        ### number of stones.\\n        return len(stones) - len({find(n) for n in UF})\\n```\\n\\n**Other good Union-Find problems:**\\n[Graph Connectivity With Threshold](https://leetcode.com/problems/graph-connectivity-with-threshold/)\\n[Remove Max Number of Edges to Keep Graph Fully Traversable](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/)\\n[Checking Existence of Edge Length Limited Paths](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/)\\n[Divide Nodes Into the Maximum Number of Groups](https://leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups/)\\n[Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/)\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        ### construct graph\\n        ### Uing two hash map to store the neighbors on the x-axis and y-axis \\n        graphX = defaultdict(list)\\n        graphY = defaultdict(list)\\n        for x,y in stones:\\n            graphX[x].append(y)\\n            graphY[y].append(x)\\n        \\n        ### For each stone, if we haven\\'t seen it before, use a BFS to find all stones connects to it\\n        ### For each connected component, there will always be 1 stone that can not be removed\\n        ### so once we know the number of connected component, \\n        ### we can subtract it from totoal number of stones to find the number of removed stones\\n        connectedComponent = 0\\n        ### each stone should only be visited once.\\n        visited = set()\\n        for x,y in stones:\\n            ### if the current stone has not been visited, do a BFS from it.\\n            if (x,y) not in visited:\\n                q = deque([(x,y)])\\n                while q:\\n                    xo,yo = q.popleft()\\n                    ### check to see if the current stone has been visited, \\n                    ### if not, get its neighbors\\n                    if (xo,yo) not in visited:\\n                        visited.add((xo,yo))\\n                        ### since we used two hash map to store the neighbors,\\n                        ### we need to get all the neighbors fron the current stone.\\n                        for neiY in graphX[xo]:\\n                            q.append((xo,neiY))\\n                        for neiX in graphY[yo]:\\n                            q.append((neiX,yo))\\n                ### we find another connected component\\n                connectedComponent += 1\\n        \\n        return len(stones)-connectedComponent\\n```\n```python\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n\\n        graphX = defaultdict(list)\\n        graphY = defaultdict(list)\\n        for x,y in stones:\\n            graphX[x].append(y)\\n            graphY[y].append(x)\\n        \\n        def dfs(xo,yo):\\n            nonlocal visited\\n            if (xo,yo) not in visited:\\n                visited.add((xo,yo))\\n                for neiY in graphX[xo]:\\n                    dfs(xo,neiY)\\n                for neiX in graphY[yo]:\\n                    dfs(neiX,yo)\\n        \\n        connectedComponent = 0\\n        visited = set()\\n        for x,y in stones:\\n            if (x,y) not in visited:\\n                dfs(x,y)\\n                connectedComponent += 1\\n        \\n        return len(stones)-connectedComponent\\n```\n```python\\nclass Solution:\\n    def removeStones(self, stones):\\n        \\n        ### UF is a hash map where you can find the root of a group of elements giving an element.\\n        ### A key in UF is a element, UF[x] is x\\'s parent.\\n        ### If UF[x] == x meaning x is the root of its group.\\n        UF = {}\\n        \\n        ### Given an element, find the root of the group to which this element belongs.\\n        def find(x):\\n            \\n            ### If x == UF[x], meaning x is the root of this group.\\n            ### If x != UF[x], we use the find function again on x\\'s parent UF[x] \\n            ### until we find the root and set it as the parent (value) of x in UF.\\n            if x != UF[x]:\\n                UF[x] = find(UF[x])\\n            return UF[x]\\n        \\n        ### Given two elements x and y, we know that x and y should be in the same group, \\n        ### this means the group that contains x and the group that contains y \\n        ### should be merged together if they are currently separate groups.\\n        ### So we first find the root of x and the root of y using the find function.\\n        ### We then set the root of y (rootY) as the root of the root of x (rootX).\\n        def union(x, y):\\n            \\n            ### this may be the first time we see x or y, so set itself as the root.\\n            if x not in UF:\\n                UF[x] = x\\n            if y not in UF:\\n                UF[y] = y\\n            rootX = find(x)\\n            rootY = find(y)\\n            # set the root of y (rootY) as the root of the root of x (rootX)\\n            UF[rootX] = rootY\\n        \\n        ### The main reason we can use the union-find algorithm here is that we treat the x and y of each stone as a single element!\\n        ### DO NOT think of a stone as (x,y); instead, think about one stone as two elements, x and y!\\n        ### Now, a stone means two elements, x and y, that are CONNECTED.\\n        ### Since x and y can be the same, but 0 <= x, y <= 10^4, we can add 10^4 to every y \\n        ### to distinguish x and y and treat them as different elements.\\n        ### We can go to every pair of x and y (a stone), we know that x and y should be in \\n        ### the same group, so we union them.\\n        maxX = 10**4+1\\n        for x,y in stones:\\n            union(x,y+maxX)\\n        \\n        ### Finally, we go through each element in UF and find their root, count how many \\n        ### connected components (unique roots) are there and subtract it from the total \\n        ### number of stones.\\n        return len(stones) - len({find(n) for n in UF})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197851,
                "title": "c-dfs",
                "content": "The idea here is that we can remove all stones from the group of connected stones except the last one. Therefore, the result is the total number of stones minus the number of groups. It was tempting to solve this problem using union-find, but I wanted to play it safe and went with DFS. Afterwards, I checked the runtime of the union-find based solution, and it was the same as for DFS (20 ms).\\n\\nI am using hashmaps of vectors to quickly access all occupied columns for each row, and all occupied rows for each column. Then I use DFS to group all rows connected by columns, counting the number of stones in that group.\\n```\\nint dfs(unordered_map<int, vector<int>> &rows, unordered_map<int, vector<int>> &cols, unordered_set<int> &v_rows, int row) {\\n  auto res = 0;\\n  if (v_rows.insert(row).second) {\\n    res += rows[row].size();\\n    for (auto c : rows[row])\\n      for (auto r : cols[c]) res += dfs(rows, cols, v_rows, r);\\n  }\\n  return res;\\n}\\nint removeStones(vector<vector<int>>& stones) {\\n  unordered_map<int, vector<int>> rows, cols;\\n  unordered_set<int> v_rows;\\n  auto res = 0;\\n  for (auto s : stones) rows[s[0]].push_back(s[1]), cols[s[1]].push_back(s[0]);\\n  for (auto r : rows) res += max(0, dfs(rows, cols, v_rows, r.first) - 1);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint dfs(unordered_map<int, vector<int>> &rows, unordered_map<int, vector<int>> &cols, unordered_set<int> &v_rows, int row) {\\n  auto res = 0;\\n  if (v_rows.insert(row).second) {\\n    res += rows[row].size();\\n    for (auto c : rows[row])\\n      for (auto r : cols[c]) res += dfs(rows, cols, v_rows, r);\\n  }\\n  return res;\\n}\\nint removeStones(vector<vector<int>>& stones) {\\n  unordered_map<int, vector<int>> rows, cols;\\n  unordered_set<int> v_rows;\\n  auto res = 0;\\n  for (auto s : stones) rows[s[0]].push_back(s[1]), cols[s[1]].push_back(s[0]);\\n  for (auto r : rows) res += max(0, dfs(rows, cols, v_rows, r.first) - 1);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 393127,
                "title": "review-of-two-popular-approaches-disjoint-sets-and-dfs-including-optimizations-java-centric",
                "content": "*If you like this post please give it a vote, it will encourage me to post similar reviews for other problems ^_^*\\n\\nI found this problem interesting because some of the solutions used an algorithm and data structure that I did not know, the Disjoint Sets Data Structure.\\n\\nIf the disjoint set algorithm is new to you I highly recommend watching this video: https://www.youtube.com/watch?v=wU6udHRIkcc\\n\\nAlso interesting is that both the Depth First Search or Disjoint Sets solutions can be improved using the same optimization, using Sets to track node neighbours.\\n\\nTo solve the problem the basic idea is to notice that to make a valid move, we need a stone to be connected to at least one other stone. Also notice that stones that are connected to each other form a connected graph (or set). For each connected graph the largest number of moves possible is to remove the stones one by one, and we will be left with the last stone in the graph, which cannot be removed (because it is not connected to any other stone). All we need to do is count how many separate (unique) connected graphs exist.\\n\\nIf we can do that we get that answer =  Sum(number of stones in each graph - 1).\\n\\nWhich is also equivalent to answer = Sum(number of stones in each graph) - (number of graphs * 1) or answer = total number of stones - number of graphs.\\n\\n## Na\\xEFve Disjoint Set Union Solution\\nhttps://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/199168/standard-union-find-solution\\n\\nThis video may also help (thought there are small errors in the implementation): https://www.youtube.com/watch?v=y-rfZ_ToHv8&t=14s\\n\\nTime comlexity: `O(n^2)`\\nSpace complexity:  `O(n)`\\n\\nThe idea is to first make each stone a disjoint set, then everytime we find a neighbour we union the two sets. The implementation is relatively simple. However because of the two for loops, the time complexity is `O(n^2)`\\n\\n## Improved DSU\\nhttps://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197973/Java-Union-Find-finding-number-of-connected-components/202775\\n\\nSee comment by @Big_News for an improvement\\n\\nTime comlexity: `O(n)`\\nSpace complexity:  `O(n)`\\n\\nThe improved DSU solution creates a map of all the nodes with a certain X coordinate and a second map with all the nodes with a specific X coordinate. This allows us to quickly join all of a node\\'s neighbour into a set. This improves the na\\xEFve DSU implementation from `O(n^2)` to `O(n)`\\n\\nTwo more small improvements can be done.\\n\\nThe first is improving find() by using `collapsing find`. This will make find() constant time:\\n\\n```\\npublic int find(int x) {\\n\\tif (parents[x] != x) {\\n\\t\\tparents[x] = find(parents[x]);\\n\\t}\\n\\treturn parents[x];\\n}\\n```\\n\\nThe second is to use `Weighted Union `, where when union two sets, we make the smaller set a child of the larger set.\\n\\n```\\npublic void union(int x, int y) {\\n\\tint rootX = find(x);\\n\\tint rootY = find(y);\\n\\tif (rootX == rootY) return;\\n\\tif (counts[rootX] > counts[rootY]) {\\n\\t\\tparents[rootY] = rootX;\\n\\t\\tcounts[rootX] += counts[rootY];\\n\\t} else {\\n\\t\\tparents[rootX] = rootY;\\n\\t\\tcounts[rootY] += counts[rootX];\\n\\t}\\n\\tcount--;\\n}\\n```\\n\\n**Note**: From my `Java` submission results the optmized DSU solutions is the fastest solution at 10 ms, probably because it uses `int[]` instead of the `Map` objects in the DFS solutions below.\\n\\n## Na\\xEFve DFS solution\\nTime comlexity: `O(n^2)`\\nSpace complexity:  `O(n)`\\n\\nThis solution is a simple and easy to understand implementation, and inspired by: https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/209369/Java-recursive-DFS-Short-and-easy-to-understand\\n\\nHowever it is **not** a real ```DFS``` since for each node, the solution just vists *all* the other nodes, not just it\\'s neighbors. This is why it has an `O(n^2)` complexity.\\n\\n## Real DFS solution\\nTime comlexity: `O(n)`\\nSpace complexity:  `O(n)`\\n\\nThis solution is a real `DFS` implementation because it only visits each nodes connected neighbour: https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/239162/DFS-Time-O(N)-Space-O(N)-ConciseandandReadable\\n\\nThe improvement upon the na\\xEFve solution above, is the same as the improvement for the DSU solution. First creates a map to record all the nodes with the same X coordinate, and create another map of all the nodes with a same Y coordinate. We can then use these maps to find each node\\'s neighbour in constant time. This means we can do a real `DFS`.\\n\\nWhile this solution is `O(n)` because of the overhead of the Map objects it is slower than the DSU solution that uses simple arrays instead of Maps.\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\npublic int find(int x) {\\n\\tif (parents[x] != x) {\\n\\t\\tparents[x] = find(parents[x]);\\n\\t}\\n\\treturn parents[x];\\n}\\n```\n```\\npublic void union(int x, int y) {\\n\\tint rootX = find(x);\\n\\tint rootY = find(y);\\n\\tif (rootX == rootY) return;\\n\\tif (counts[rootX] > counts[rootY]) {\\n\\t\\tparents[rootY] = rootX;\\n\\t\\tcounts[rootX] += counts[rootY];\\n\\t} else {\\n\\t\\tparents[rootX] = rootY;\\n\\t\\tcounts[rootY] += counts[rootX];\\n\\t}\\n\\tcount--;\\n}\\n```\n```DFS```",
                "codeTag": "Unknown"
            },
            {
                "id": 217790,
                "title": "c-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        const int n = stones.size();\\n        vroot = vector<int>(n);\\n        for(int i=0;i<n;i++) vroot[i] = i;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                    connect(i,j);\\n            }\\n        }\\n        int cnt = 0;\\n        for(int i=0;i<n;i++) \\n            if(vroot[i] == i) cnt++;\\n        return n - cnt;\\n    }\\n    \\n    int getRoot(int i){\\n        if(vroot[i] != i){\\n            vroot[i] = getRoot(vroot[i]);\\n        }\\n        return vroot[i];\\n    }\\n    \\n    void connect(int i, int j){\\n        vroot[getRoot(i)] = getRoot(j); \\n    }\\n    \\n    vector<int> vroot;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        const int n = stones.size();\\n        vroot = vector<int>(n);\\n        for(int i=0;i<n;i++) vroot[i] = i;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                    connect(i,j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 199168,
                "title": "standard-union-find-solution",
                "content": "\\n```java\\nclass Solution {\\n    class UnionFind {\\n        int[] parent;\\n        int[] rank;\\n        int count;\\n\\n        public UnionFind(int n) { // for problem 200\\n            parent = new int[n];\\n            rank = new int[n];\\n            count = n;\\n            for (int i = 0; i < n; ++i) {\\n                parent[i] = i;\\n                rank[i] = 0;\\n            }\\n        }\\n\\n        public int find(int x) { // path compression\\n            // only the rank of the root matters, used in union op.\\n            if (parent[x] != x)\\n                parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        public void union(int x, int y) { // union with rank\\n            int rootx = find(x);\\n            int rooty = find(y);\\n            if (rootx != rooty) {\\n                if (rank[rootx] > rank[rooty]) {\\n                    parent[rooty] = rootx;\\n                } else {\\n                    parent[rootx] = rooty;\\n                    if (rootx == rooty)\\n                        rank[rooty] += 1;\\n                }\\n                count--;\\n            }\\n        }\\n\\n        public int getCount() {\\n            return count;\\n        }\\n    }\\n\\n    public int removeStones(int[][] stones) {\\n        // if any two points are on the same column or row, they are connected as a\\n        // edge.\\n        // find connected component, and remove all but one.\\n        // count the number of disjoint components.\\n        int n = stones.length;\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (isConnected(stones[i], stones[j]))\\n                    uf.union(i, j);\\n            }\\n        }\\n        return n - uf.getCount();\\n\\n    }\\n\\n    private boolean isConnected(int[] p1, int[] p2){\\n        return p1[0] == p2[0] || p1[1] == p2[1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    class UnionFind {\\n        int[] parent;\\n        int[] rank;\\n        int count;\\n\\n        public UnionFind(int n) { // for problem 200\\n            parent = new int[n];\\n            rank = new int[n];\\n            count = n;\\n            for (int i = 0; i < n; ++i) {\\n                parent[i] = i;\\n                rank[i] = 0;\\n            }\\n        }\\n\\n        public int find(int x) { // path compression\\n            // only the rank of the root matters, used in union op.\\n            if (parent[x] != x)\\n                parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        public void union(int x, int y) { // union with rank\\n            int rootx = find(x);\\n            int rooty = find(y);\\n            if (rootx != rooty) {\\n                if (rank[rootx] > rank[rooty]) {\\n                    parent[rooty] = rootx;\\n                } else {\\n                    parent[rootx] = rooty;\\n                    if (rootx == rooty)\\n                        rank[rooty] += 1;\\n                }\\n                count--;\\n            }\\n        }\\n\\n        public int getCount() {\\n            return count;\\n        }\\n    }\\n\\n    public int removeStones(int[][] stones) {\\n        // if any two points are on the same column or row, they are connected as a\\n        // edge.\\n        // find connected component, and remove all but one.\\n        // count the number of disjoint components.\\n        int n = stones.length;\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (isConnected(stones[i], stones[j]))\\n                    uf.union(i, j);\\n            }\\n        }\\n        return n - uf.getCount();\\n\\n    }\\n\\n    private boolean isConnected(int[] p1, int[] p2){\\n        return p1[0] == p2[0] || p1[1] == p2[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812465,
                "title": "it-s-literally-a-graph-dfs-and-union-find",
                "content": "[Leetcode](https://leetcode.com/) [947. Most Stones Removed with Same Row or Column](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/).\\n\\n# Intuition\\n\\nWe can find that this is a **graph theory** problem with analysis.\\n\\nImagine the stone on the 2D coordinate plane as the vertex of the **graph**, If the x-coord or the y-coord of two stones are the same, there is an edge between them.\\n\\nThis can be show as follows:\\n\\n![947.png](https://assets.leetcode.com/users/images/7fed588d-b4d4-4054-bd54-107992309ced_1668388259.5949304.png)\\n\\nAccording to the rule that stones can be removed, we should remove those points that are in the same row or column with other points as late as possible. That is, the more points in the same row or column with point A, the later point A should be removed. In this way, we can delete as many points as possible through point A.\\n\\nIt can be found that all vertices in a connected graph can be deleted to only one vertex.\\n\\n![947 2.png](https://assets.leetcode.com/users/images/bcb48b5e-7c72-4083-8630-570cf8201e57_1668388321.9239075.png)\\n\\nSince these vertices are in a connected graph, all vertices of the connected graph can be traversed by DFS or BFS. \\n\\nTherefore: the maximum number of stones that can be removed = the number of all stones - the number of connected components.\\n\\n# DFS\\n\\n```java\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        int n = stones.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int[] u = stones[i];\\n            for (int j = 0; j < n; j++) {\\n                if (i == j) {\\n                    continue;\\n                }\\n\\n                int[] v = stones[j];\\n                if (u[0] == v[0] || u[1] == v[1]) {\\n                    graph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        boolean[] visited = new boolean[n];\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n\\n            dfs(graph, visited, i);\\n            ans++;\\n        }\\n\\n        return n - ans;\\n    }\\n\\n    private static void dfs(List<Integer>[] graph, boolean[] visited, int start) {\\n\\n        visited[start] = true;\\n\\n        List<Integer> neighbors = graph[start];\\n        for (int x : neighbors) {\\n            if (visited[x]) {\\n                continue;\\n            }\\n\\n            dfs(graph, visited, x);\\n        }\\n    }\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^2)$.\\n- **Space Complexity**: $O(n)$.\\n\\n\\n# Union Find\\n\\n```java\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        if (stones == null || stones.length <= 1) {\\n            return 0;\\n        }\\n\\n        int n = stones.length;\\n\\n        UnionFind uf = new UnionFind();\\n        for (int[] edge : stones) {\\n            uf.union(edge[0] + 10001, edge[1]);\\n        }\\n\\n        return n - uf.getCount();\\n    }\\n\\n    class UnionFind {\\n        Map<Integer, Integer> parents;\\n        int count;\\n\\n        public UnionFind() {\\n            parents = new HashMap<>();\\n            count = 0;\\n        }\\n\\n        public int getCount() {\\n            return count;\\n        }\\n\\n        public int find(int x) {\\n            if (!parents.containsKey(x)) {\\n                parents.put(x, x);\\n                count++;\\n            }\\n\\n            if (x != parents.get(x)) {\\n                parents.put(x, find(parents.get(x)));\\n            }\\n\\n            return parents.get(x);\\n        }\\n\\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX == rootY) {\\n                return;\\n            }\\n\\n            parents.put(rootX, rootY);\\n            count--;\\n        }\\n    }\\n}\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(nlogn)$.\\n- **Space Complexity**: $O(n)$.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```java\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        int n = stones.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            int[] u = stones[i];\\n            for (int j = 0; j < n; j++) {\\n                if (i == j) {\\n                    continue;\\n                }\\n\\n                int[] v = stones[j];\\n                if (u[0] == v[0] || u[1] == v[1]) {\\n                    graph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        boolean[] visited = new boolean[n];\\n        int ans = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i]) {\\n                continue;\\n            }\\n\\n            dfs(graph, visited, i);\\n            ans++;\\n        }\\n\\n        return n - ans;\\n    }\\n\\n    private static void dfs(List<Integer>[] graph, boolean[] visited, int start) {\\n\\n        visited[start] = true;\\n\\n        List<Integer> neighbors = graph[start];\\n        for (int x : neighbors) {\\n            if (visited[x]) {\\n                continue;\\n            }\\n\\n            dfs(graph, visited, x);\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        if (stones == null || stones.length <= 1) {\\n            return 0;\\n        }\\n\\n        int n = stones.length;\\n\\n        UnionFind uf = new UnionFind();\\n        for (int[] edge : stones) {\\n            uf.union(edge[0] + 10001, edge[1]);\\n        }\\n\\n        return n - uf.getCount();\\n    }\\n\\n    class UnionFind {\\n        Map<Integer, Integer> parents;\\n        int count;\\n\\n        public UnionFind() {\\n            parents = new HashMap<>();\\n            count = 0;\\n        }\\n\\n        public int getCount() {\\n            return count;\\n        }\\n\\n        public int find(int x) {\\n            if (!parents.containsKey(x)) {\\n                parents.put(x, x);\\n                count++;\\n            }\\n\\n            if (x != parents.get(x)) {\\n                parents.put(x, find(parents.get(x)));\\n            }\\n\\n            return parents.get(x);\\n        }\\n\\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX == rootY) {\\n                return;\\n            }\\n\\n            parents.put(rootX, rootY);\\n            count--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330512,
                "title": "c-concise-union-find-with-two-maps",
                "content": "- Imagine each stone has an ID corresponding to its index in the input array.\\n- Map each occupied row to a vector of all stone IDs in that row. Repeat for columns.\\n- Union each stone ID with all other stone IDs in the same row or in the same column.\\n- Each connected group can have all but one stone removed. Thus, we count the number of unique groups and subtract this from the total number of stones to get our answer.\\n```\\nvector<int> parent;\\n\\nint removeStones(vector<vector<int>>& stones) {\\n\\tunordered_map<int, vector<int>> rowmap, colmap;\\n\\tfor(int i = 0; i < stones.size(); i++) {\\n\\t\\trowmap[stones[i][0]].push_back(i);\\n\\t\\tcolmap[stones[i][1]].push_back(i);\\n\\t}\\n\\n\\tfor(int i = 0; i < stones.size(); i++) parent.push_back(i);\\n\\tfor(int i = 0; i < stones.size(); i++) {\\n\\t\\tfor(int j : rowmap[stones[i][0]]) unite(i, j);\\n\\t\\tfor(int j : colmap[stones[i][1]]) unite(i, j);\\n\\t}\\n\\n\\tunordered_set<int> unique;\\n\\tfor(int n : parent) unique.insert(find(n));\\n\\treturn stones.size() - unique.size();\\n}\\n\\nint find(int n) { return parent[n] == n ? n : parent[n] = find(parent[n]); }\\n\\nvoid unite(int a, int b) { parent[find(a)] = find(b); }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nvector<int> parent;\\n\\nint removeStones(vector<vector<int>>& stones) {\\n\\tunordered_map<int, vector<int>> rowmap, colmap;\\n\\tfor(int i = 0; i < stones.size(); i++) {\\n\\t\\trowmap[stones[i][0]].push_back(i);\\n\\t\\tcolmap[stones[i][1]].push_back(i);\\n\\t}\\n\\n\\tfor(int i = 0; i < stones.size(); i++) parent.push_back(i);\\n\\tfor(int i = 0; i < stones.size(); i++) {\\n\\t\\tfor(int j : rowmap[stones[i][0]]) unite(i, j);\\n\\t\\tfor(int j : colmap[stones[i][1]]) unite(i, j);\\n\\t}\\n\\n\\tunordered_set<int> unique;\\n\\tfor(int n : parent) unique.insert(find(n));\\n\\treturn stones.size() - unique.size();\\n}\\n\\nint find(int n) { return parent[n] == n ? n : parent[n] = find(parent[n]); }\\n\\nvoid unite(int a, int b) { parent[find(a)] = find(b); }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812633,
                "title": "python-c-rust-count-connected-components-with-dfs-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Depth First Search* approach to explore and count the number of connected components. Time complexity is linear: **O(n)**. Space complexity is linear: **O(n)**.\\n\\n**Comment.** A group of stones, where each stone is either a row-neighbour (has the same row) or a column-neighbour (has the same column) of another stone in the group, forms what is called a *connected component* of a graph. Removing stones according to the recipe in the problem is basically wiping out each connected component except for one stone. Thus, the number of remaining stones would be equal to the number of connected components that could be counted using, e.g., DFS (used here) or union find.\\n\\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        \\n        rows, cols = defaultdict(list), defaultdict(list)       # [1] all stones within the same row\\n        for s, (r, c) in enumerate(stones):                     #     and within the same column\\n            rows[r].append(s)                                   #     belong to the same connected\\n            cols[c].append(s)                                   #     component; let\\'s store this data\\n        \\n        seen, n = set(), len(stones)\\n        \\n        def dfs(s):                                             # [2] this function is used to explore a\\n            if s in seen : return 0                             #     connected component of each stone by\\n            seen.add(s)                                         #     making recursive calls to adjacent\\n            r, c = stones[s]                                    #     stones; it returns 1/0 depending on\\n            for ss in chain(rows[r], cols[c]): dfs(ss)          #     whether the component was already \\n            return 1                                            #     explored, thus, allowing to count them\\n                \\n        c = sum(dfs(s) for s in range(n))                       # [3] count the number of connected components\\n\\n        return n - c                                            # [4] in each component, 1 stone will remain\\n```\\n\\nI also provide this solution in other languages. In Rust, using DFS with lots of data that should be captured from outside of the *dfs* function is a mess. Thus, I rewritten it to use BFS instead.\\n\\n<iframe src=\"https://leetcode.com/playground/ho2fuNRP/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        \\n        rows, cols = defaultdict(list), defaultdict(list)       # [1] all stones within the same row\\n        for s, (r, c) in enumerate(stones):                     #     and within the same column\\n            rows[r].append(s)                                   #     belong to the same connected\\n            cols[c].append(s)                                   #     component; let\\'s store this data\\n        \\n        seen, n = set(), len(stones)\\n        \\n        def dfs(s):                                             # [2] this function is used to explore a\\n            if s in seen : return 0                             #     connected component of each stone by\\n            seen.add(s)                                         #     making recursive calls to adjacent\\n            r, c = stones[s]                                    #     stones; it returns 1/0 depending on\\n            for ss in chain(rows[r], cols[c]): dfs(ss)          #     whether the component was already \\n            return 1                                            #     explored, thus, allowing to count them\\n                \\n        c = sum(dfs(s) for s in range(n))                       # [3] count the number of connected components\\n\\n        return n - c                                            # [4] in each component, 1 stone will remain\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689443,
                "title": "for-beginners-count-number-of-connected-graphs-o-n-94-faster",
                "content": "## IDEA :\\n\\n*If you see the whole description with focus you will find that we have to find total number of distinguish connected points. So, We move this problem to a graph domain. When two stones row or column is same, we can say the they are connected.*\\n\\nAfter construcing the graph, we get a collection of one or more connected graphs In graph\\'s terminology, this is called **strongly connected component.**\\n\\nNow, for every stronly connected component, one stone will remain, all others inside that component can be removed (because from that remaining stone, we can move to other stones in that component and remove them).\\n\\n**So, Our answer should be = Number ot stones - Number of strongly connected component**\\n\\n### Algorightm\\n\\n\\tPrepare the graph\\n\\tFrom every stone\\n\\t\\ta. If not visitied, run dfs to remove connected nodes.\\n\\t\\tb. After removing a node, track that to avoid infinite loop\\n\\t\\tc. When a strongly connected component is fully traversed, subtract 1 to track that remaining stone\\n\\tDo this until all stones are traversed \\n\\n### Implementation :\\n\\'\\'\\'\\n\\t\\t\\n\\t\\tclass Solution:\\n\\t\\t\\tdef removeStones(self, stones: List[List[int]]) -> int:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tdef remove_point(a,b):                           # Function to remove connected points from the ongoing graph. \\n\\t\\t\\t\\t\\tpoints.discard((a,b))\\n\\t\\t\\t\\t\\tfor y in x_dic[a]:\\n\\t\\t\\t\\t\\t\\tif (a,y) in points:\\n\\t\\t\\t\\t\\t\\t\\tremove_point(a,y)\\n\\n\\t\\t\\t\\t\\tfor x in y_dic[b]:\\n\\t\\t\\t\\t\\t\\tif (x,b) in points:\\n\\t\\t\\t\\t\\t\\t\\tremove_point(x,b)\\n\\n\\t\\t\\t\\tx_dic = defaultdict(list)\\n\\t\\t\\t\\ty_dic = defaultdict(list)\\n\\t\\t\\t\\tpoints= {(i,j) for i,j in stones}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor i,j in stones:                                # Construction of graph by x_coordinates and y_coordinates.\\n\\t\\t\\t\\t\\tx_dic[i].append(j)\\n\\t\\t\\t\\t\\ty_dic[j].append(i)\\n\\n\\t\\t\\t\\tcnt = 0\\n\\t\\t\\t\\tfor a,b in stones:                                # counting of distinct connected graph.\\n\\t\\t\\t\\t\\tif (a,b) in points:\\n\\t\\t\\t\\t\\t\\tremove_point(a,b)\\n\\t\\t\\t\\t\\t\\tcnt+=1\\n\\n\\t\\t\\t\\treturn len(stones)-cnt\\n\\t\\t\\t\\t\\n### **Thanks and Upvote if you like the Idea !!\\uD83E\\uDD17**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n\\t\\t\\tdef removeStones(self, stones: List[List[int]]) -> int:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tdef remove_point(a,b):                           # Function to remove connected points from the ongoing graph. \\n\\t\\t\\t\\t\\tpoints.discard((a,b))\\n\\t\\t\\t\\t\\tfor y in x_dic[a]:\\n\\t\\t\\t\\t\\t\\tif (a,y) in points:\\n\\t\\t\\t\\t\\t\\t\\tremove_point(a,y)\\n\\n\\t\\t\\t\\t\\tfor x in y_dic[b]:\\n\\t\\t\\t\\t\\t\\tif (x,b) in points:\\n\\t\\t\\t\\t\\t\\t\\tremove_point(x,b)\\n\\n\\t\\t\\t\\tx_dic = defaultdict(list)\\n\\t\\t\\t\\ty_dic = defaultdict(list)\\n\\t\\t\\t\\tpoints= {(i,j) for i,j in stones}",
                "codeTag": "Java"
            },
            {
                "id": 2812579,
                "title": "c-dsu-dfs-easy-to-understand",
                "content": "##### DSU SOLUTION ==>\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&pos1, vector<int>&pos2)\\n    {\\n        if (pos1[0] == pos2[0]) return true;\\n        if (pos1[1] == pos2[1]) return true;\\n        return false;\\n    }\\n    int findParent(vector<int>&parent, int node)\\n    {\\n        while(parent[node] != node) { node = parent[node]; }\\n        return node;\\n    }\\n    void merge(vector<int>&parent, int& componentCount, int node1, int node2)\\n    {\\n        int parent1 = findParent(parent, node1);\\n        int parent2 = findParent(parent, node2);\\n        if (parent1 != parent2) \\n        {\\n            componentCount--; //whenever we merge two components, totalComponentCount decrease by 1\\n            parent[parent1] = parent2; //or parent[parent2] = parent1 would also work :)\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones)\\n    {\\n        int n = stones.size();\\n        vector<int>parent(n);\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n        //==============================================\\n        int componentCount = n; //assuming \"n\" independent components at start\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i; j < n; j++)\\n            {\\n                if (isValid(stones[i], stones[j]))\\n                    merge(parent, componentCount, i, j);\\n            }\\n        }\\n        //===============================================\\n        return (n - componentCount); \\n    }\\n};\\n```\\n\\n\\n#### DFS SOLUTION ==>\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&pos1, vector<int>&pos2)\\n    {\\n        if (pos1[0] == pos2[0]) return true;\\n        if (pos1[1] == pos2[1]) return true;\\n        return false;\\n    }\\n    void dfs(vector<vector<int>>&stones, vector<bool>&visited, int currIdx)\\n    {\\n        visited[currIdx] = true;\\n        for (int i = 0; i < stones.size(); i++)\\n        {\\n            if (visited[i]) continue;\\n            if (isValid(stones[i], stones[currIdx]))  dfs(stones, visited, i);\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones)\\n    {\\n        int n = stones.size();\\n        vector<bool>visited(n, false);\\n        int componentCount = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (visited[i]) continue;\\n            dfs(stones, visited, i);\\n            componentCount++;\\n        }\\n        return (n - componentCount); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&pos1, vector<int>&pos2)\\n    {\\n        if (pos1[0] == pos2[0]) return true;\\n        if (pos1[1] == pos2[1]) return true;\\n        return false;\\n    }\\n    int findParent(vector<int>&parent, int node)\\n    {\\n        while(parent[node] != node) { node = parent[node]; }\\n        return node;\\n    }\\n    void merge(vector<int>&parent, int& componentCount, int node1, int node2)\\n    {\\n        int parent1 = findParent(parent, node1);\\n        int parent2 = findParent(parent, node2);\\n        if (parent1 != parent2) \\n        {\\n            componentCount--; //whenever we merge two components, totalComponentCount decrease by 1\\n            parent[parent1] = parent2; //or parent[parent2] = parent1 would also work :)\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones)\\n    {\\n        int n = stones.size();\\n        vector<int>parent(n);\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n        //==============================================\\n        int componentCount = n; //assuming \"n\" independent components at start\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i; j < n; j++)\\n            {\\n                if (isValid(stones[i], stones[j]))\\n                    merge(parent, componentCount, i, j);\\n            }\\n        }\\n        //===============================================\\n        return (n - componentCount); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&pos1, vector<int>&pos2)\\n    {\\n        if (pos1[0] == pos2[0]) return true;\\n        if (pos1[1] == pos2[1]) return true;\\n        return false;\\n    }\\n    void dfs(vector<vector<int>>&stones, vector<bool>&visited, int currIdx)\\n    {\\n        visited[currIdx] = true;\\n        for (int i = 0; i < stones.size(); i++)\\n        {\\n            if (visited[i]) continue;\\n            if (isValid(stones[i], stones[currIdx]))  dfs(stones, visited, i);\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones)\\n    {\\n        int n = stones.size();\\n        vector<bool>visited(n, false);\\n        int componentCount = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (visited[i]) continue;\\n            dfs(stones, visited, i);\\n            componentCount++;\\n        }\\n        return (n - componentCount); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197874,
                "title": "java-dfs-solution",
                "content": "\\n```\\n    public int removeStones(int[][] stones) {\\n        Map<Integer, Set<Integer>> rSet = new HashMap<>(), cSet = new HashMap<>();\\n        for(int[] e : stones) {\\n            int r = e[0], c = e[1];\\n            rSet.putIfAbsent(r, new HashSet<>());\\n            cSet.putIfAbsent(c, new HashSet<>());\\n            rSet.get(r).add(c);\\n            cSet.get(c).add(r);\\n        }\\n        \\n        int count = 0;\\n        Set<String> v = new HashSet<>();\\n        for(int[] e : stones) {\\n            String key = e[0]+\",\"+e[1];\\n            if(!v.contains(key)) {\\n                count++;\\n                v.add(key);\\n                dfs(e[0], e[1], rSet, cSet, v);\\n            }\\n        }\\n        return stones.length - count;\\n    }\\n    \\n    void dfs(int r, int c, Map<Integer, Set<Integer>> rSet, Map<Integer, Set<Integer>> cSet, Set<String> v) {\\n        for(int y : rSet.get(r)) {\\n            String key = r+\",\"+y;\\n            if(!v.contains(key)) {\\n                v.add(key);\\n                dfs(r, y, rSet, cSet, v);\\n            }\\n        }\\n        \\n        for(int x : cSet.get(c)) {\\n            String key = x+\",\"+c;\\n            if(!v.contains(key)) {\\n                v.add(key);\\n                dfs(x, c, rSet, cSet, v);\\n            }\\n        }        \\n    }\\n```\\n\\n\\nUnion & Find\\n```\\n    public int removeStones(int[][] stones) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] root = new int[stones.length];\\n        for(int i = 0; i < root.length; i++) root[i] = i;\\n        \\n        int idx = 0, union_count = 0;\\n        for(int[] e : stones) {\\n            int r = e[0], c = e[1] + 10000;\\n            Integer rgid = map.get(r), cgid = map.get(c);\\n            \\n            if(rgid != null && cgid != null) {\\n                int rid = findParent(root, rgid);\\n                int cid = findParent(root, cgid);\\n                if(rid != cid) {\\n                    union_count++;\\n                    root[rid] = cid;\\n                }\\n            } else if(rgid != null) {\\n                int rid = findParent(root, rgid);\\n                map.put(c, rid);\\n            } else if(cgid != null) {\\n                int cid = findParent(root, cgid);\\n                map.put(r, cid);\\n            } else {\\n                map.put(r, idx);\\n                map.put(c, idx);\\n                idx++;\\n            }\\n        }\\n        return stones.length- idx + union_count;\\n    }\\n    \\n    int findParent(int root[], int idx) {\\n        while(root[idx] != idx) {\\n            root[idx] = root[root[idx]];\\n            idx = root[idx];\\n        }\\n        return idx;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int removeStones(int[][] stones) {\\n        Map<Integer, Set<Integer>> rSet = new HashMap<>(), cSet = new HashMap<>();\\n        for(int[] e : stones) {\\n            int r = e[0], c = e[1];\\n            rSet.putIfAbsent(r, new HashSet<>());\\n            cSet.putIfAbsent(c, new HashSet<>());\\n            rSet.get(r).add(c);\\n            cSet.get(c).add(r);\\n        }\\n        \\n        int count = 0;\\n        Set<String> v = new HashSet<>();\\n        for(int[] e : stones) {\\n            String key = e[0]+\",\"+e[1];\\n            if(!v.contains(key)) {\\n                count++;\\n                v.add(key);\\n                dfs(e[0], e[1], rSet, cSet, v);\\n            }\\n        }\\n        return stones.length - count;\\n    }\\n    \\n    void dfs(int r, int c, Map<Integer, Set<Integer>> rSet, Map<Integer, Set<Integer>> cSet, Set<String> v) {\\n        for(int y : rSet.get(r)) {\\n            String key = r+\",\"+y;\\n            if(!v.contains(key)) {\\n                v.add(key);\\n                dfs(r, y, rSet, cSet, v);\\n            }\\n        }\\n        \\n        for(int x : cSet.get(c)) {\\n            String key = x+\",\"+c;\\n            if(!v.contains(key)) {\\n                v.add(key);\\n                dfs(x, c, rSet, cSet, v);\\n            }\\n        }        \\n    }\\n```\n```\\n    public int removeStones(int[][] stones) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] root = new int[stones.length];\\n        for(int i = 0; i < root.length; i++) root[i] = i;\\n        \\n        int idx = 0, union_count = 0;\\n        for(int[] e : stones) {\\n            int r = e[0], c = e[1] + 10000;\\n            Integer rgid = map.get(r), cgid = map.get(c);\\n            \\n            if(rgid != null && cgid != null) {\\n                int rid = findParent(root, rgid);\\n                int cid = findParent(root, cgid);\\n                if(rid != cid) {\\n                    union_count++;\\n                    root[rid] = cid;\\n                }\\n            } else if(rgid != null) {\\n                int rid = findParent(root, rgid);\\n                map.put(c, rid);\\n            } else if(cgid != null) {\\n                int cid = findParent(root, cgid);\\n                map.put(r, cid);\\n            } else {\\n                map.put(r, idx);\\n                map.put(c, idx);\\n                idx++;\\n            }\\n        }\\n        return stones.length- idx + union_count;\\n    }\\n    \\n    int findParent(int root[], int idx) {\\n        while(root[idx] != idx) {\\n            root[idx] = root[root[idx]];\\n            idx = root[idx];\\n        }\\n        return idx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197756,
                "title": "python-dfs-solution-with-picture-explain-the-idea-with-extra-chinese-explanation",
                "content": "you can get Chinese explanation [here](https://buptwc.com/2018/11/25/Leetcode-947-Most-Stones-Removed-with-Same-Row-or-Column/)\\n\\n__explanation:__\\nwe look at this case, obviously we can remove all stones except `stone A`(the red one)\\n![image](https://assets.leetcode.com/users/2017111303/image_1543120874.png)\\n\\nhow about this case, we also can remove all stones except `stone A`, the order of removal is shown in the figure by numbers.\\n![image](https://assets.leetcode.com/users/2017111303/image_1543121160.png)\\n\\nso, we have come to a conclusion, for a `connected graph`, the number of stones we can remove is `len(graph)-1`\\nwe can use dfs to find all `connected graph`.\\n```python\\nclass Solution(object):\\n    def removeStones(self, stones):\\n        stones = list(map(tuple, stones))\\n        s = set(stones)\\n        d = collections.defaultdict(list)\\n        for i,j in s:\\n            d[i].append(j)\\n            d[j].append(i)\\n        \\n        def dfs(i,j):\\n            for y in d[i]: # find all points in x=i\\n                if (i,y) not in s: continue\\n                s.remove((i,y))\\n                dfs(i,y)\\n            for x in d[j]: # find all points in y=j\\n                if (x,j) not in s: continue\\n                s.remove((x,j))\\n                dfs(x,j)\\n        \\n        n = len(s)\\n        res = 0\\n        for i,j in stones:\\n            if (i,j) not in s: continue\\n            s.remove((i,j))\\n            dfs(i,j)\\n            res += n - len(s) - 1 # n-len(s) represent the length of graph, e.g. the number of element removed through dfs\\n            n = len(s)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def removeStones(self, stones):\\n        stones = list(map(tuple, stones))\\n        s = set(stones)\\n        d = collections.defaultdict(list)\\n        for i,j in s:\\n            d[i].append(j)\\n            d[j].append(i)\\n        \\n        def dfs(i,j):\\n            for y in d[i]: # find all points in x=i\\n                if (i,y) not in s: continue\\n                s.remove((i,y))\\n                dfs(i,y)\\n            for x in d[j]: # find all points in y=j\\n                if (x,j) not in s: continue\\n                s.remove((x,j))\\n                dfs(x,j)\\n        \\n        n = len(s)\\n        res = 0\\n        for i,j in stones:\\n            if (i,j) not in s: continue\\n            s.remove((i,j))\\n            dfs(i,j)\\n            res += n - len(s) - 1 # n-len(s) represent the length of graph, e.g. the number of element removed through dfs\\n            n = len(s)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812924,
                "title": "java-easy-simple-to-understand-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n \\n        HashSet<Pair <Integer,Integer>> visited = new HashSet<>(); \\n        int ans = stones.length;\\n        for(int i=0;i<stones.length;i++){\\n            if(!visited.contains(new Pair <Integer,Integer> (stones[i][0],stones[i][1]))){\\n                dfs(stones,visited,stones[i][0],stones[i][1]);\\n                ans--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void dfs(int[][] stones,HashSet<Pair <Integer,Integer>> visited,int i,int j){\\n        visited.add(new Pair<Integer,Integer>(i,j));\\n        for(int k=0;k<stones.length;k++){\\n            if(!visited.contains(new Pair <Integer,Integer> (stones[k][0],stones[k][1]))){\\n                if(i==stones[k][0] || j==stones[k][1])\\n                    dfs(stones,visited,stones[k][0],stones[k][1]);\\n            }\\n        }\\n    }\\n    \\n}\\n```\\n*Upvote if you like!!!*",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n \\n        HashSet<Pair <Integer,Integer>> visited = new HashSet<>(); \\n        int ans = stones.length;\\n        for(int i=0;i<stones.length;i++){\\n            if(!visited.contains(new Pair <Integer,Integer> (stones[i][0],stones[i][1]))){\\n                dfs(stones,visited,stones[i][0],stones[i][1]);\\n                ans--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void dfs(int[][] stones,HashSet<Pair <Integer,Integer>> visited,int i,int j){\\n        visited.add(new Pair<Integer,Integer>(i,j));\\n        for(int k=0;k<stones.length;k++){\\n            if(!visited.contains(new Pair <Integer,Integer> (stones[k][0],stones[k][1]))){\\n                if(i==stones[k][0] || j==stones[k][1])\\n                    dfs(stones,visited,stones[k][0],stones[k][1]);\\n            }\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812583,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/7Qva4yWn/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nIn case you don\\'t have DSU template. You can do it as follows.\\n\\n<iframe src=\"https://leetcode.com/playground/iVp4zrNT/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/7Qva4yWn/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\nIn case you don\\'t have DSU template. You can do it as follows.\\n\\n<iframe src=\"https://leetcode.com/playground/iVp4zrNT/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1392476,
                "title": "c-solution-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;         \\n    \\n    int findParent(int node){                   \\n        if(node==parent[node]) return node;\\n        return parent[node] = findParent(parent[node]);\\n    }\\n    \\n    bool join(int x, int y){\\n        x = findParent(x);\\n        y = findParent(y);\\n        \\n        if(x==y) return false;\\n        \\n        parent[y]=x;\\n        return true;\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        parent.resize(n);\\n        \\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        \\n        int count=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(stones[i][0]==stones[j][0] || stones[i][1]==stones[j][1]){\\n                    if(join(i,j)) count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;         \\n    \\n    int findParent(int node){                   \\n        if(node==parent[node]) return node;\\n        return parent[node] = findParent(parent[node]);\\n    }\\n    \\n    bool join(int x, int y){\\n        x = findParent(x);\\n        y = findParent(y);\\n        \\n        if(x==y) return false;\\n        \\n        parent[y]=x;\\n        return true;\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        parent.resize(n);\\n        \\n        for(int i=0; i<n; i++){\\n            parent[i] = i;\\n        }\\n        \\n        int count=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(stones[i][0]==stones[j][0] || stones[i][1]==stones[j][1]){\\n                    if(join(i,j)) count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294209,
                "title": "javascript-union-find-easy-to-understand",
                "content": "The parent map works in such a way such that at the end of the algorithim, each `i` where `parentMap[i] === i` indicates a distinct subset since everything else is rooted to another stone\\'s subset.\\n\\nThe number of stones we **can\\'t** remove is equal to the number of subsets we can create. This is because within a subset, every stone can depend on another stone in the subset until you get to the last one which has no other stone to rely on.\\n\\nThus the total number we can remove equals the total number of stones, minus the one\\'s we can\\'t remove.\\n\\nThis took me a while \\uD83D\\uDE44gl hf\\n\\n```\\n/**\\n * @param {number[][]} stones\\n * @return {number}\\n */\\nvar removeStones = function(stones) {\\n\\n    let subsetCount = stones.length;\\n    const parentMap = [];\\n    \\n    // Initialize the parent map to give each stone it\\'s own set\\n    for (let i = 0; i < stones.length; i++) {\\n        parentMap[i] = i;\\n    }\\n    \\n    for (let thisStonesIdx = 1; thisStonesIdx < stones.length; thisStonesIdx++) {           \\n        const thisStone = stones[thisStonesIdx];\\n        \\n        for (let thatStonesIdx = 0; thatStonesIdx < thisStonesIdx; thatStonesIdx++) {\\n            const thatStone = stones[thatStonesIdx];\\n            \\n            // Not in the same row or column, skip ahead\\n            if (thisStone[0] !== thatStone[0] && thisStone[1] !== thatStone[1]) continue;\\n            \\n            // If this stone isn\\'t already part of an existing subset\\n            if (parentMap[thisStonesIdx] === thisStonesIdx) {\\n                // Add it to that one\\'s subset\\n                parentMap[thisStonesIdx] = thatStonesIdx;\\n                subsetCount -= 1;\\n            } else {\\n                // Find this stone\\'s root\\n                let currentThisStonesParentIndex = parentMap[thisStonesIdx];\\n                while (parentMap[currentThisStonesParentIndex] !== currentThisStonesParentIndex) {\\n                    currentThisStonesParentIndex = parentMap[currentThisStonesParentIndex];\\n                }\\n                \\n                // Find that stone\\'s root\\n                let currentThatStonesParentIndex = parentMap[thatStonesIdx];\\n                while (parentMap[currentThatStonesParentIndex] !== currentThatStonesParentIndex) {\\n                    currentThatStonesParentIndex = parentMap[currentThatStonesParentIndex];\\n                }\\n\\n                // If they\\'re not in the same subset, merge them\\n                if (currentThisStonesParentIndex != currentThatStonesParentIndex) {\\n                    parentMap[currentThisStonesParentIndex] = currentThatStonesParentIndex;  \\n                    subsetCount -= 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return stones.length - subsetCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\n/**\\n * @param {number[][]} stones\\n * @return {number}\\n */\\nvar removeStones = function(stones) {\\n\\n    let subsetCount = stones.length;\\n    const parentMap = [];\\n    \\n    // Initialize the parent map to give each stone it\\'s own set\\n    for (let i = 0; i < stones.length; i++) {\\n        parentMap[i] = i;\\n    }\\n    \\n    for (let thisStonesIdx = 1; thisStonesIdx < stones.length; thisStonesIdx++) {           \\n        const thisStone = stones[thisStonesIdx];\\n        \\n        for (let thatStonesIdx = 0; thatStonesIdx < thisStonesIdx; thatStonesIdx++) {\\n            const thatStone = stones[thatStonesIdx];\\n            \\n            // Not in the same row or column, skip ahead\\n            if (thisStone[0] !== thatStone[0] && thisStone[1] !== thatStone[1]) continue;\\n            \\n            // If this stone isn\\'t already part of an existing subset\\n            if (parentMap[thisStonesIdx] === thisStonesIdx) {\\n                // Add it to that one\\'s subset\\n                parentMap[thisStonesIdx] = thatStonesIdx;\\n                subsetCount -= 1;\\n            } else {\\n                // Find this stone\\'s root\\n                let currentThisStonesParentIndex = parentMap[thisStonesIdx];\\n                while (parentMap[currentThisStonesParentIndex] !== currentThisStonesParentIndex) {\\n                    currentThisStonesParentIndex = parentMap[currentThisStonesParentIndex];\\n                }\\n                \\n                // Find that stone\\'s root\\n                let currentThatStonesParentIndex = parentMap[thatStonesIdx];\\n                while (parentMap[currentThatStonesParentIndex] !== currentThatStonesParentIndex) {\\n                    currentThatStonesParentIndex = parentMap[currentThatStonesParentIndex];\\n                }\\n\\n                // If they\\'re not in the same subset, merge them\\n                if (currentThisStonesParentIndex != currentThatStonesParentIndex) {\\n                    parentMap[currentThisStonesParentIndex] = currentThatStonesParentIndex;  \\n                    subsetCount -= 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return stones.length - subsetCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 239162,
                "title": "dfs-time-o-n-space-o-n-concise-readable",
                "content": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        if (stones.length ==0 || stones[0].length ==0) return 0;\\n        Map<Integer, List<int[]>> mapX = new HashMap<>();\\n        Map<Integer, List<int[]>> mapY = new HashMap<>();\\n        \\n        // building map of all stone on same row/col\\n        for(int[] stone : stones) {\\n            List<int[]> xList = mapX.getOrDefault(stone[0], new ArrayList<>());\\n            xList.add(stone);\\n            mapX.put(stone[0], xList);\\n            \\n            List<int[]> yList = mapY.getOrDefault(stone[1], new ArrayList<>());\\n            yList.add(stone);\\n            mapY.put(stone[1], yList);\\n        }\\n        \\n        Set<int[]> visited = new HashSet<>();\\n        \\n        int numComp = 0;\\n        for(int[] stone : stones) {\\n            if(!visited.contains(stone)) {\\n                numComp++;\\n                dfs(mapX,mapY, stone, visited);\\n            }\\n        }\\n        return stones.length - numComp;\\n    }\\n    \\n    private void dfs(Map<Integer, List<int[]>> mapX,\\n                     Map<Integer, List<int[]>> mapY,\\n                     int[] stone,\\n                     Set<int[]> visited) {\\n        visited.add(stone);\\n        for(int[] s : mapX.get(stone[0])) \\n            if(!visited.contains(s)) dfs(mapX, mapY, s, visited);\\n        \\n        for(int[] s : mapY.get(stone[1])) \\n            if(!visited.contains(s)) dfs(mapX, mapY, s, visited);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        if (stones.length ==0 || stones[0].length ==0) return 0;\\n        Map<Integer, List<int[]>> mapX = new HashMap<>();\\n        Map<Integer, List<int[]>> mapY = new HashMap<>();\\n        \\n        // building map of all stone on same row/col\\n        for(int[] stone : stones) {\\n            List<int[]> xList = mapX.getOrDefault(stone[0], new ArrayList<>());\\n            xList.add(stone);\\n            mapX.put(stone[0], xList);\\n            \\n            List<int[]> yList = mapY.getOrDefault(stone[1], new ArrayList<>());\\n            yList.add(stone);\\n            mapY.put(stone[1], yList);\\n        }\\n        \\n        Set<int[]> visited = new HashSet<>();\\n        \\n        int numComp = 0;\\n        for(int[] stone : stones) {\\n            if(!visited.contains(stone)) {\\n                numComp++;\\n                dfs(mapX,mapY, stone, visited);\\n            }\\n        }\\n        return stones.length - numComp;\\n    }\\n    \\n    private void dfs(Map<Integer, List<int[]>> mapX,\\n                     Map<Integer, List<int[]>> mapY,\\n                     int[] stone,\\n                     Set<int[]> visited) {\\n        visited.add(stone);\\n        for(int[] s : mapX.get(stone[0])) \\n            if(!visited.contains(s)) dfs(mapX, mapY, s, visited);\\n        \\n        for(int[] s : mapY.get(stone[1])) \\n            if(!visited.contains(s)) dfs(mapX, mapY, s, visited);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812891,
                "title": "simple-dfs-approach",
                "content": "# Intuition\\nBasic DFS when you see you have to find the connected components\\n\\n# Approach\\nMark Every Node (the point from where you are traversing to every pooint you are traversing in depth) visited from the point i till you could reach the end. Do this for every unvisited node , Increase the count of connected part.\\n\\n# Complexity\\n- Time complexity: O(V + E) ~ V is vertices & E is edges\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) ~ for visited vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(vector<int>& p1 , vector<int>& p2){\\n        if(p1[0] == p2[0]) return true;\\n        if(p1[1] == p2[1]) return true;\\n        return false;\\n    }\\n    void dfs(vector<vector<int>>& stones , vector<bool>& visited , int i){\\n        visited[i] = true;\\n        for(int j = 0 ; j < stones.size() ; j++){\\n            if(valid(stones[i] , stones[j]) && !visited[j]) {\\n                dfs(stones , visited , j);\\n            }\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        vector<bool> visited(n , false);\\n        int count = 0;\\n        for(int i = 0; i < n ;i++){\\n            if(!visited[i]){\\n                dfs(stones , visited , i);\\n                count++;\\n            }\\n        }\\n\\n        return n - count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(vector<int>& p1 , vector<int>& p2){\\n        if(p1[0] == p2[0]) return true;\\n        if(p1[1] == p2[1]) return true;\\n        return false;\\n    }\\n    void dfs(vector<vector<int>>& stones , vector<bool>& visited , int i){\\n        visited[i] = true;\\n        for(int j = 0 ; j < stones.size() ; j++){\\n            if(valid(stones[i] , stones[j]) && !visited[j]) {\\n                dfs(stones , visited , j);\\n            }\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        vector<bool> visited(n , false);\\n        int count = 0;\\n        for(int i = 0; i < n ;i++){\\n            if(!visited[i]){\\n                dfs(stones , visited , i);\\n                count++;\\n            }\\n        }\\n\\n        return n - count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593884,
                "title": "c-union-find-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    int find(int x){\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void unionDSU(int a, int b){\\n        int x=find(a), y=find(b);\\n        if(x==y) return;\\n        if(rank[x] > rank[y]) parent[y]=x;\\n        else if(rank[y] > rank[x]) parent[x]=y;\\n        else{\\n            parent[x]=y;\\n            rank[y]++;\\n        }\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        parent.resize(n);\\n        for(int i=0; i<n; ++i) parent[i]=i;\\n        rank.resize(n,1);\\n        \\n        for(int i=0; i<n-1; ++i){\\n            for(int j=i+1; j<n; ++j){\\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) unionDSU(i,j);\\n            }\\n        }\\n        \\n        int cnt=0;\\n        for(int i=0; i<n; ++i) if(parent[i]==i) cnt++;\\n        return n-cnt;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    int find(int x){\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void unionDSU(int a, int b){\\n        int x=find(a), y=find(b);\\n        if(x==y) return;\\n        if(rank[x] > rank[y]) parent[y]=x;\\n        else if(rank[y] > rank[x]) parent[x]=y;\\n        else{\\n            parent[x]=y;\\n            rank[y]++;\\n        }\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        parent.resize(n);\\n        for(int i=0; i<n; ++i) parent[i]=i;\\n        rank.resize(n,1);\\n        \\n        for(int i=0; i<n-1; ++i){\\n            for(int j=i+1; j<n; ++j){\\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) unionDSU(i,j);\\n            }\\n        }\\n        \\n        int cnt=0;\\n        for(int i=0; i<n; ++i) if(parent[i]==i) cnt++;\\n        return n-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425657,
                "title": "c-dfs-solution",
                "content": "Runtime: 32 ms, faster than 96.41% of C++ online submissions for Most Stones Removed with Same Row or Column.\\nMemory Usage: 20 MB, less than 33.21% of C++ online submissions for Most Stones Removed with Same Row or Column.\\n\\n\\nThe solution of the problem is => Total nodes - Number of connected compoenents\\nWe can easily count the number of connected components using DFS where cords with same row or col has\\nedge between them. So we first store the index of same row or col in same list. Then run DFS from each\\nunvisited nodes and count the number of connected components.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // store same row or col cords index in Rowlist and Collist\\n    unordered_map<int,vector<int>>Rowlist;\\n    unordered_map<int,vector<int>>Collist;\\n    \\n    void dfs (int index, vector<bool>&visited, vector<vector<int>>&stones)\\n    {\\n        visited[index] = true;\\n        \\n        for(int i=0;i<Rowlist[stones[index][0]].size();i++)\\n        {\\n            if(visited[Rowlist[stones[index][0]][i]])continue;\\n            dfs(Rowlist[stones[index][0]][i],visited,stones);\\n        }\\n\\n        for(int i=0;i<Collist[stones[index][1]].size();i++)\\n        {\\n            if(visited[Collist[stones[index][1]][i]])continue;\\n            dfs(Collist[stones[index][1]][i],visited,stones);\\n        }\\n        \\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        // total stones\\n        int n = stones.size();\\n        \\n        // visited stones track\\n        vector<bool>visited(n,false);\\n\\n        // store same row or col cords index in Rowlist and Collist \\n        for(int i=0;i<n;i++)\\n        {\\n            Rowlist[stones[i][0]].push_back(i);\\n            Collist[stones[i][1]].push_back(i);\\n        }\\n        \\n        // count the connected components \\n        int c = 0;\\n        \\n        // loop through stones and call DFS for unvisited stones \\n        // and count number of connected components\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i])continue;\\n            dfs(i,visited,stones);\\n            c++;\\n        }\\n        \\n        // total stones - no of connected components\\n        return n-c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // store same row or col cords index in Rowlist and Collist\\n    unordered_map<int,vector<int>>Rowlist;\\n    unordered_map<int,vector<int>>Collist;\\n    \\n    void dfs (int index, vector<bool>&visited, vector<vector<int>>&stones)\\n    {\\n        visited[index] = true;\\n        \\n        for(int i=0;i<Rowlist[stones[index][0]].size();i++)\\n        {\\n            if(visited[Rowlist[stones[index][0]][i]])continue;\\n            dfs(Rowlist[stones[index][0]][i],visited,stones);\\n        }\\n\\n        for(int i=0;i<Collist[stones[index][1]].size();i++)\\n        {\\n            if(visited[Collist[stones[index][1]][i]])continue;\\n            dfs(Collist[stones[index][1]][i],visited,stones);\\n        }\\n        \\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        // total stones\\n        int n = stones.size();\\n        \\n        // visited stones track\\n        vector<bool>visited(n,false);\\n\\n        // store same row or col cords index in Rowlist and Collist \\n        for(int i=0;i<n;i++)\\n        {\\n            Rowlist[stones[i][0]].push_back(i);\\n            Collist[stones[i][1]].push_back(i);\\n        }\\n        \\n        // count the connected components \\n        int c = 0;\\n        \\n        // loop through stones and call DFS for unvisited stones \\n        // and count number of connected components\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i])continue;\\n            dfs(i,visited,stones);\\n            c++;\\n        }\\n        \\n        // total stones - no of connected components\\n        return n-c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920955,
                "title": "c-dfs-solution",
                "content": "A very helpful article to read : https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> vis;\\n    \\n    void dfs(int idx, vector<vector<int>> &stones){\\n        vis[idx] = true;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(vis[i]) continue;\\n            if(stones[idx][0] == stones[i][0] || stones[idx][1] == stones[i][1])\\n                dfs(i, stones);\\n        }\\n        return;\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        n = stones.size();\\n        \\n        vis.resize(n, 0);\\n        \\n        int val = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(vis[i]) continue;\\n            val++;\\n            dfs(i, stones);\\n        }\\n        \\n        return n - val;\\n    }\\n};\\n```\\n\\nPS : The editorial explanation is a disater. Hope this helps !!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> vis;\\n    \\n    void dfs(int idx, vector<vector<int>> &stones){\\n        vis[idx] = true;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(vis[i]) continue;\\n            if(stones[idx][0] == stones[i][0] || stones[idx][1] == stones[i][1])\\n                dfs(i, stones);\\n        }\\n        return;\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        n = stones.size();\\n        \\n        vis.resize(n, 0);\\n        \\n        int val = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(vis[i]) continue;\\n            val++;\\n            dfs(i, stones);\\n        }\\n        \\n        return n - val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813018,
                "title": "beautiful-dfs-solution-explained-line-by-line-python",
                "content": "```\\ndef removeStones(self, stones: List[List[int]]) -> int:\\n\\t# helper method to remove the island of stones connected to a stone at (i,j)\\n\\tdef removeIsland(i,j):\\n\\t\\tinIsland = [] # stones in the same island\\n\\t\\tind = 0 # index to traverse stones\\n\\t\\twhile ind < len(stones):\\n\\t\\t\\tx,y = stones[ind] # this stone\\n\\t\\t\\tif x == i or y == j: # if it is in the same row or col\\n\\t\\t\\t\\tinIsland.append(stones.pop(ind)) # it is in the island \\u2013\\u2013 pop from stones and add to inIsland\\n\\t\\t\\telse: # otherwise\\n\\t\\t\\t\\tind += 1 # move to the next index in stones\\n\\t\\tfor stone in inIsland: # for all the stones connected to this one\\n\\t\\t\\tremoveIsland(*stone) # recursively remove the rest of the island which connects to the stone\\n\\tans = len(stones) # we start off assuming that we can remove every stone\\n\\twhile stones: # while there are stones left to remove\\n\\t\\tremoveIsland(*stones.pop()) # remove the island connected to the last stone\\n\\t\\tans -= 1 # one stone from this island must remain\\n\\treturn ans\\n```\\nThe main idea behind this solution is that we can figure out the number of stones which we cannot remove by considering the number of \"islands.\" An \"island\" is a group of connected rocks which share some direct or indirect link by being in the same row or column as each other or by being in the same row or column with another rock that is in the same row or column as another one. For example, `[0,1], [0,2]` is an island since the stones share a row, and `[0,1],[0,2],[1,2],[1,3],[0,4],[3,1]` is an island. We can remove all the stones in an island except for one, since the last one will not share a row or column with any other stone. Therefore, the total number of stones we can remove is the total number of stones in our array minus the number of unique islands. To find the number of unique islands we can use a depth-first-search helper method, `removeIsland(i,j)`, to remove all the stones in the island containing the stone `[i,j]`. Every time we need to call `removeIsland` is one stone which we cannot remove1\\n\\nBy the way, the `*` operator just unpacks an iterable. For example, calling `removeIsland(*stone)` is the same as calling `removeIsland(stone[0], stone[1])`. Using the `*` is just a little neater, but provides no functional difference.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef removeStones(self, stones: List[List[int]]) -> int:\\n\\t# helper method to remove the island of stones connected to a stone at (i,j)\\n\\tdef removeIsland(i,j):\\n\\t\\tinIsland = [] # stones in the same island\\n\\t\\tind = 0 # index to traverse stones\\n\\t\\twhile ind < len(stones):\\n\\t\\t\\tx,y = stones[ind] # this stone\\n\\t\\t\\tif x == i or y == j: # if it is in the same row or col\\n\\t\\t\\t\\tinIsland.append(stones.pop(ind)) # it is in the island \\u2013\\u2013 pop from stones and add to inIsland\\n\\t\\t\\telse: # otherwise\\n\\t\\t\\t\\tind += 1 # move to the next index in stones\\n\\t\\tfor stone in inIsland: # for all the stones connected to this one\\n\\t\\t\\tremoveIsland(*stone) # recursively remove the rest of the island which connects to the stone\\n\\tans = len(stones) # we start off assuming that we can remove every stone\\n\\twhile stones: # while there are stones left to remove\\n\\t\\tremoveIsland(*stones.pop()) # remove the island connected to the last stone\\n\\t\\tans -= 1 # one stone from this island must remain\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1587104,
                "title": "java-simple-dfs-85-speed-o-n-with-explanation",
                "content": "This is the best solution that I came up with for now. \\n\\nAfter thinking on it for a bit, I realize the answer is merely `number of stones - number of group of stones`, so we do a simple DFS to determine the number of group and that\\'s all. Be mindful that as we go from 0 to N-1 stones, some newly added stones may actually decrease the number of group as in the case of `[[0,1],[1,0],[1,1]]`, where you have 2 groups up until `[[0,1],[1,0]]` but end up only having 1 group in the end.  With that in mind, it is just a simple DFS, similar to many other medium leetcode problems that ask you to count the number of island.\\n\\n```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        boolean[] visited = new boolean[stones.length];\\n        HashMap<Integer, List<Integer>> row = new HashMap<>();\\n        HashMap<Integer, List<Integer>> col = new HashMap<>();\\n        for (int i = 0; i < stones.length; i++){\\n            row.computeIfAbsent(stones[i][0], o -> new ArrayList<>()).add(i); // so we can find other stones based on row\\n            col.computeIfAbsent(stones[i][1], o -> new ArrayList<>()).add(i); // so we can find other stones based on col\\n        }\\n\\n        int numOfIsland = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            if (!visited[i]){\\n                removeIsland(visited, stones, i, row, col);\\n                numOfIsland++;\\n            }\\n\\n        return stones.length - numOfIsland;\\n    }\\n\\n    private void removeIsland(boolean[] visited, int[][] stones, int idx,\\n            Map<Integer, List<Integer>> row, Map<Integer, List<Integer>> col){\\n        if (visited[idx]) return; // base case\\n\\n        visited[idx] = true; // mark as visited.\\n        int r = stones[idx][0];\\n        int c = stones[idx][1];\\n        for (int index : row.get(r)) // not null because the current stone is in it\\n            removeIsland(visited, stones, index, row, col); // visit all the stones on this row\\n\\n        for (int index : col.get(c))\\n            removeIsland(visited, stones, index, row, col); // visit all the stones on this col\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        boolean[] visited = new boolean[stones.length];\\n        HashMap<Integer, List<Integer>> row = new HashMap<>();\\n        HashMap<Integer, List<Integer>> col = new HashMap<>();\\n        for (int i = 0; i < stones.length; i++){\\n            row.computeIfAbsent(stones[i][0], o -> new ArrayList<>()).add(i); // so we can find other stones based on row\\n            col.computeIfAbsent(stones[i][1], o -> new ArrayList<>()).add(i); // so we can find other stones based on col\\n        }\\n\\n        int numOfIsland = 0;\\n        for (int i = 0; i < stones.length; i++)\\n            if (!visited[i]){\\n                removeIsland(visited, stones, i, row, col);\\n                numOfIsland++;\\n            }\\n\\n        return stones.length - numOfIsland;\\n    }\\n\\n    private void removeIsland(boolean[] visited, int[][] stones, int idx,\\n            Map<Integer, List<Integer>> row, Map<Integer, List<Integer>> col){\\n        if (visited[idx]) return; // base case\\n\\n        visited[idx] = true; // mark as visited.\\n        int r = stones[idx][0];\\n        int c = stones[idx][1];\\n        for (int index : row.get(r)) // not null because the current stone is in it\\n            removeIsland(visited, stones, index, row, col); // visit all the stones on this row\\n\\n        for (int index : col.get(c))\\n            removeIsland(visited, stones, index, row, col); // visit all the stones on this col\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631608,
                "title": "c-union-find-o-n-2",
                "content": "**Intuition:**\\nIf 2 stones are in the same column/row, we connect them as a component (please go through union find approach)\\nAt end we calculate number of components by checking the parent array.\\nThe largest possible number of moves  = Total count of stones - number of components.\\n\\n```\\nclass Solution {\\n    vector<int>parent;\\n    int find(int x) {\\n        return parent[x] == x ? x : find(parent[x]);\\n    }\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        if (stones.empty()) return 0;\\n        \\n        int m = stones.size();\\n        \\n        parent.resize(m, 0);\\n        for (int i = 0; i < m; i++)\\n            parent[i] = i;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\\n                    int x = find(i);\\n                    int y = find(j);\\n                    if (x != y)\\n                        parent[y] = x;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            if (parent[i] == i)\\n                ans++;\\n        }\\n        \\n        return m-ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int>parent;\\n    int find(int x) {\\n        return parent[x] == x ? x : find(parent[x]);\\n    }\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        if (stones.empty()) return 0;\\n        \\n        int m = stones.size();\\n        \\n        parent.resize(m, 0);\\n        for (int i = 0; i < m; i++)\\n            parent[i] = i;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < i; j++) {\\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\\n                    int x = find(i);\\n                    int y = find(j);\\n                    if (x != y)\\n                        parent[y] = x;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < m; i++) {\\n            if (parent[i] == i)\\n                ans++;\\n        }\\n        \\n        return m-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462383,
                "title": "c-simple-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    set <int> vis;\\n    int f(vector<vector<int>>& stones, int x, int y, int idx) {\\n        vis.insert(idx);\\n        \\n        int ans = 0;\\n        \\n        // check cols && rows\\n        \\n        for(int i=0;i<stones.size();i++) {\\n            if(stones[i][0] == x && vis.find(i) == vis.end()) \\n                ans += 1 + f(stones, x, stones[i][1], i);\\n        }\\n        \\n        for(int i=0;i<stones.size();i++) {\\n            if(stones[i][1] == y && vis.find(i) == vis.end())\\n                ans += 1 + f(stones, stones[i][0], y, i);\\n        }\\n        \\n        return ans;\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int ans = 0;\\n        \\n        for(int i=0;i<stones.size();i++) {\\n            if(vis.find(i) == vis.end()) {\\n                int x = stones[i][0], y = stones[i][1];\\n                ans += f(stones, x, y, i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set <int> vis;\\n    int f(vector<vector<int>>& stones, int x, int y, int idx) {\\n        vis.insert(idx);\\n        \\n        int ans = 0;\\n        \\n        // check cols && rows\\n        \\n        for(int i=0;i<stones.size();i++) {\\n            if(stones[i][0] == x && vis.find(i) == vis.end()) \\n                ans += 1 + f(stones, x, stones[i][1], i);\\n        }\\n        \\n        for(int i=0;i<stones.size();i++) {\\n            if(stones[i][1] == y && vis.find(i) == vis.end())\\n                ans += 1 + f(stones, stones[i][0], y, i);\\n        }\\n        \\n        return ans;\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int ans = 0;\\n        \\n        for(int i=0;i<stones.size();i++) {\\n            if(vis.find(i) == vis.end()) {\\n                int x = stones[i][0], y = stones[i][1];\\n                ans += f(stones, x, y, i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280508,
                "title": "javascript-dfs-solution-with-explanation-to-follow-through",
                "content": "Feedback more than welcomed! Scroll to the bottom for the solution. \\nI\\'m typing this out for extra practice. Explaination:  For this solution, we\\'ll rely on the graph data structure. Typically a graph data instantiation pattern looks like this\\n```\\nvar Graph = function(){\\n\\tthis.storage = {} ;\\n\\tthis.size = 0; \\n}\\n```\\n\\nThere are various ways to define edges within your graph. I will be using an object to hold the relationships (you could alternatively use arrays) and use booleans to set to true between two nodes. For example: \\n\\nNode1 has an edge with node2 and node3. \\n```{node1:{ node2: true, node3: true}} ```\\n\\nUsing the prompts first example, \\n```stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]```\\n\\nif an element has a matching row (0th index) or columns (1st index), then an edge exists. \\nI\\'ll be using the element\\'s index values to represent the nodes. The final data structure would look as follows: \\n\\n```\\n{\\n0: { 1: true, 2: true }, \\n1: { 0: true, 4: true }, \\n2: { 0: true, 3: true }, \\n3: { 2: true, 5: true }, \\n4: { 1: true, 5: true }, \\n5: { 3: true, 4: true }\\n}\\n```\\n\\nSteps for this solution; \\n1. create the graph data structure object within our removeStones function\\n2. Use DFS traversal to travel the graph for each node if it hasn\\'t been visited yet\\n3. count the number of connections\\n\\n```\\nvar removeStones = function(stones) {\\n\\t/* here we create the graph data structure. \\n\\tUsing a loop within a loop, \\n\\twe compare each index with all subsequent indexes. \\n\\tHowever, we use \\'continue\\' to skip the loop from comparing to itself, \\n\\thence the line if(i===j){continue} */\\n\\t\\n\\tvar storage = {}; \\n\\t/* here we populate our storage with the nodes*/\\n\\tfor (var i stones) { \\n\\t\\tstorage[i] = {}; \\n\\t}\\n\\t\\n\\t/*next we establish the edges among nodes */\\n\\tfor (var i in stones) { \\n\\t\\tfor (var j in stones){\\n\\t\\t\\tif( i === j ) {continue} \\n\\t\\t\\t/* if an element has a matching row with another element\\'s row\\n\\t\\t\\tor if an element has a matching column with another element\\'s column */\\n\\t\\t\\tif(stones[i][0] === stones[j][0] || stones[i][1]===stones[j][1]){\\n\\t\\t\\t\\n\\t\\t\\t/*we create an edge relationship between the two*/\\n\\t\\t\\tstorage[i][j] = true; \\n\\t\\t\\tstorage[j][i] = true; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\t//we need to mark which nodes we visit when traversing \\n\\tvar visited = {} \\n\\tfor (var i in stones) { \\n\\t\\t//setting all nodes to false since we haven\\'t traversed yet\\n\\t\\tvisited[i] = false; \\n\\t}\\n\\tvar count = 0; //here we count the connections\\n\\t//here I create my dfs traverse helper function\\n\\tvar dfs = function(node, visited){\\n\\t\\tvisited[node] = true; \\n\\t\\tvar edge = storage[node] //grabbing all edges for the node \\n\\t\\tfor (var e in edges) { \\n\\t\\t\\tif(!visited[e]){ //if we haven\\'t visited a node, we perform traversing on it\\n\\t\\t\\tcount++\\n\\t\\t\\tdfs(e, visited) \\n\\t\\t\\t}\\n\\t\\t}\\n\\tfor (var node in storage){\\n\\t\\tdfs(node) \\n\\t}\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Graph = function(){\\n\\tthis.storage = {} ;\\n\\tthis.size = 0; \\n}\\n```\n```{node1:{ node2: true, node3: true}} ```\n```stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]```\n```\\n{\\n0: { 1: true, 2: true }, \\n1: { 0: true, 4: true }, \\n2: { 0: true, 3: true }, \\n3: { 2: true, 5: true }, \\n4: { 1: true, 5: true }, \\n5: { 3: true, 4: true }\\n}\\n```\n```\\nvar removeStones = function(stones) {\\n\\t/* here we create the graph data structure. \\n\\tUsing a loop within a loop, \\n\\twe compare each index with all subsequent indexes. \\n\\tHowever, we use \\'continue\\' to skip the loop from comparing to itself, \\n\\thence the line if(i===j){continue} */\\n\\t\\n\\tvar storage = {}; \\n\\t/* here we populate our storage with the nodes*/\\n\\tfor (var i stones) { \\n\\t\\tstorage[i] = {}; \\n\\t}\\n\\t\\n\\t/*next we establish the edges among nodes */\\n\\tfor (var i in stones) { \\n\\t\\tfor (var j in stones){\\n\\t\\t\\tif( i === j ) {continue} \\n\\t\\t\\t/* if an element has a matching row with another element\\'s row\\n\\t\\t\\tor if an element has a matching column with another element\\'s column */\\n\\t\\t\\tif(stones[i][0] === stones[j][0] || stones[i][1]===stones[j][1]){\\n\\t\\t\\t\\n\\t\\t\\t/*we create an edge relationship between the two*/\\n\\t\\t\\tstorage[i][j] = true; \\n\\t\\t\\tstorage[j][i] = true; \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\t//we need to mark which nodes we visit when traversing \\n\\tvar visited = {} \\n\\tfor (var i in stones) { \\n\\t\\t//setting all nodes to false since we haven\\'t traversed yet\\n\\t\\tvisited[i] = false; \\n\\t}\\n\\tvar count = 0; //here we count the connections\\n\\t//here I create my dfs traverse helper function\\n\\tvar dfs = function(node, visited){\\n\\t\\tvisited[node] = true; \\n\\t\\tvar edge = storage[node] //grabbing all edges for the node \\n\\t\\tfor (var e in edges) { \\n\\t\\t\\tif(!visited[e]){ //if we haven\\'t visited a node, we perform traversing on it\\n\\t\\t\\tcount++\\n\\t\\t\\tdfs(e, visited) \\n\\t\\t\\t}\\n\\t\\t}\\n\\tfor (var node in storage){\\n\\t\\tdfs(node) \\n\\t}\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246407,
                "title": "python3-simple-union-find-97",
                "content": "```python\\nclass Solution(object):\\n    def removeStones(self, stones):\\n        X, Y = {}, {}\\n        uf = [i for i in range(len(stones))]\\n        \\n        def find(x):\\n            if x != uf[x]:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        \\n        for i, coord in enumerate(stones):\\n            x, y = coord\\n            if x not in X:\\n                X[x] = i\\n            if y not in Y:\\n                Y[y] = i\\n            uf[find(Y[y])] = uf[find(X[x])] = find(i)\\n            \\n        return len(stones) - len(set([find(i) for i in range(len(stones))]))\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```python\\nclass Solution(object):\\n    def removeStones(self, stones):\\n        X, Y = {}, {}\\n        uf = [i for i in range(len(stones))]\\n        \\n        def find(x):\\n            if x != uf[x]:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        \\n        for i, coord in enumerate(stones):\\n            x, y = coord\\n            if x not in X:\\n                X[x] = i\\n            if y not in Y:\\n                Y[y] = i\\n            uf[find(Y[y])] = uf[find(X[x])] = find(i)\\n            \\n        return len(stones) - len(set([find(i) for i in range(len(stones))]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197973,
                "title": "java-union-find-finding-number-of-connected-components",
                "content": "Count how many stones are connected, if stone1 and stone2 shares a column or a row, then they are connected.\\nIn each group of connected components, we should be able to keep one stone, all others can be removed.\\n\\n```\\nclass Solution {\\n    \\n    private static class UnionFind {\\n        int[] parent;\\n        int count;\\n        public UnionFind(int N) {\\n            parent = new int[N];\\n            for (int i = 0; i < N; i++) {\\n                parent[i] = i;\\n            }\\n            count = N;\\n        }\\n        public void union(int i, int j) {\\n            int parent1 = find(i);\\n            int parent2 = find(j);\\n            if (parent1 != parent2) {\\n                parent[parent2] = parent1;\\n                count--;\\n            }\\n        }\\n        private int find(int i) {\\n            while (parent[i] != i) {\\n                i = parent[parent[i]];\\n            }\\n            return i;\\n        }\\n    }\\n    \\n    public int removeStones(int[][] stones) {\\n        Map<Integer, List<Integer>> rowMap = new HashMap<>();\\n        Map<Integer, List<Integer>> colMap = new HashMap<>();\\n        UnionFind uf = new UnionFind(stones.length);\\n        for (int i = 0; i < stones.length; i++) {\\n            int row = stones[i][0];\\n            int col = stones[i][1];\\n            rowMap.putIfAbsent(row, new ArrayList<>());\\n            colMap.putIfAbsent(col, new ArrayList<>());\\n            rowMap.get(row).add(i);\\n            colMap.get(col).add(i);\\n        }\\n        for (int key : rowMap.keySet()) {\\n            List<Integer> ls = rowMap.get(key);\\n            int parent = ls.get(0);\\n            for (int i = 1; i < ls.size(); i++) {\\n                uf.union(parent, ls.get(i));\\n            }\\n        }\\n        for (int key : colMap.keySet()) {\\n            List<Integer> ls = colMap.get(key);\\n            int parent = ls.get(0);\\n            for (int i = 1; i < ls.size(); i++) {\\n                uf.union(parent, ls.get(i));\\n            }\\n        }\\n        return stones.length - uf.count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static class UnionFind {\\n        int[] parent;\\n        int count;\\n        public UnionFind(int N) {\\n            parent = new int[N];\\n            for (int i = 0; i < N; i++) {\\n                parent[i] = i;\\n            }\\n            count = N;\\n        }\\n        public void union(int i, int j) {\\n            int parent1 = find(i);\\n            int parent2 = find(j);\\n            if (parent1 != parent2) {\\n                parent[parent2] = parent1;\\n                count--;\\n            }\\n        }\\n        private int find(int i) {\\n            while (parent[i] != i) {\\n                i = parent[parent[i]];\\n            }\\n            return i;\\n        }\\n    }\\n    \\n    public int removeStones(int[][] stones) {\\n        Map<Integer, List<Integer>> rowMap = new HashMap<>();\\n        Map<Integer, List<Integer>> colMap = new HashMap<>();\\n        UnionFind uf = new UnionFind(stones.length);\\n        for (int i = 0; i < stones.length; i++) {\\n            int row = stones[i][0];\\n            int col = stones[i][1];\\n            rowMap.putIfAbsent(row, new ArrayList<>());\\n            colMap.putIfAbsent(col, new ArrayList<>());\\n            rowMap.get(row).add(i);\\n            colMap.get(col).add(i);\\n        }\\n        for (int key : rowMap.keySet()) {\\n            List<Integer> ls = rowMap.get(key);\\n            int parent = ls.get(0);\\n            for (int i = 1; i < ls.size(); i++) {\\n                uf.union(parent, ls.get(i));\\n            }\\n        }\\n        for (int key : colMap.keySet()) {\\n            List<Integer> ls = colMap.get(key);\\n            int parent = ls.get(0);\\n            for (int i = 1; i < ls.size(); i++) {\\n                uf.union(parent, ls.get(i));\\n            }\\n        }\\n        return stones.length - uf.count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748315,
                "title": "c-two-approaches-dsu-dfs-traversal-unordered-map-easy-solution-concise-solution",
                "content": "**Approach 1: (DSU - Union By Size) \\u2705**\\n```\\nclass DisjointSet{\\n    vector<int> rank,parent,size;\\npublic:\\n    DisjointSet(int n){\\n        rank.resize(n+1,0);\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i=0;i<=n;i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node){\\n        if(node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u,int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]){\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u,int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n       int n = stones.size();\\n        int maxRow = 0;\\n        int maxCol = 0;\\n        for(auto it: stones){\\n            maxRow = max(maxRow, it[0]);\\n            maxCol = max(maxCol, it[1]);\\n        }\\n        DisjointSet ds(maxRow + maxCol +1);\\n        unordered_map<int,int> stoneNodes;\\n        for(auto it: stones){\\n            int nodeRow = it[0];\\n            int nodeCol = it[1]+ maxRow + 1;\\n            ds.unionBySize(nodeRow,nodeCol);\\n            stoneNodes[nodeRow] = 1;\\n            stoneNodes[nodeCol] = 1;\\n        }\\n        int cnt = 0;\\n        for(auto it: stoneNodes){\\n            if(ds.findUPar(it.first) == it.first){\\n                cnt++;\\n            }\\n        }\\n        return n - cnt;\\n    }\\n};\\n```\\n\\n**Approach 2: (DFS traversal - No of components) \\u2705**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> vis;\\n    //Same as no of ISalands and can be aslo done with union find algorithm (DSU)\\n    void dfs(int idx,vector<vector<int>> &stones){\\n        vis[idx] = true;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) continue;\\n            if(stones[idx][0] == stones[i][0] || stones[idx][1] == stones[i][1]){\\n                dfs(i,stones);\\n            }\\n        }\\n        return;\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        n = stones.size();\\n        vis.resize(n,0);\\n        int val = 0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) continue;\\n            val++;\\n            dfs(i,stones);\\n        }\\n        return n - val;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet{\\n    vector<int> rank,parent,size;\\npublic:\\n    DisjointSet(int n){\\n        rank.resize(n+1,0);\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i=0;i<=n;i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node){\\n        if(node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u,int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]){\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u,int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n       int n = stones.size();\\n        int maxRow = 0;\\n        int maxCol = 0;\\n        for(auto it: stones){\\n            maxRow = max(maxRow, it[0]);\\n            maxCol = max(maxCol, it[1]);\\n        }\\n        DisjointSet ds(maxRow + maxCol +1);\\n        unordered_map<int,int> stoneNodes;\\n        for(auto it: stones){\\n            int nodeRow = it[0];\\n            int nodeCol = it[1]+ maxRow + 1;\\n            ds.unionBySize(nodeRow,nodeCol);\\n            stoneNodes[nodeRow] = 1;\\n            stoneNodes[nodeCol] = 1;\\n        }\\n        int cnt = 0;\\n        for(auto it: stoneNodes){\\n            if(ds.findUPar(it.first) == it.first){\\n                cnt++;\\n            }\\n        }\\n        return n - cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> vis;\\n    //Same as no of ISalands and can be aslo done with union find algorithm (DSU)\\n    void dfs(int idx,vector<vector<int>> &stones){\\n        vis[idx] = true;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) continue;\\n            if(stones[idx][0] == stones[i][0] || stones[idx][1] == stones[i][1]){\\n                dfs(i,stones);\\n            }\\n        }\\n        return;\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        n = stones.size();\\n        vis.resize(n,0);\\n        int val = 0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) continue;\\n            val++;\\n            dfs(i,stones);\\n        }\\n        return n - val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995332,
                "title": "javascript-simple-dfs-solution-w-comments-dfs",
                "content": "```\\n/**\\n * *Time: O(N + M)\\n * *Space: O(N)\\n */\\n// Runtime: 282 ms, faster than 20.17% of JavaScript online submissions for Most Stones Removed with Same Row or Column.\\n// Memory Usage: 49.5 MB, less than 57.98% of JavaScript online submissions for Most Stones Removed with Same Row or Column.\\n\\n// find the number of valid stones\\n// if valid, traverse stones and look for same row and col then remove those stones\\nconst removeStones = stones => {\\n\\tconst visited = new Set();\\n\\tlet valid = 0;\\n\\n  // find and remove stones that have same row and col\\n\\tconst traverse = (row, col) => {\\n\\t\\tconst key = `${row}-${col}`;\\n\\n\\t\\tif (visited.has(key)) return;\\n\\n\\t\\tvisited.add(key); // mark visited\\n\\t\\tfor (const [x, y] of stones) {\\n\\t\\t\\t// if row or col is same, should be removed\\n\\t\\t\\tif (row === x || col === y) traverse(x, y);\\n\\t\\t}\\n\\t};\\n\\n\\tfor (const [x, y] of stones) {\\n\\t\\tconst key = `${x}-${y}`;\\n\\n\\t\\tif (visited.has(key)) continue;\\n\\n\\t\\ttraverse(x, y);\\n\\t\\tvalid++;\\n\\t}\\n\\n  // subtract number of valid nodes from total number of stones\\n\\treturn stones.length - valid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * *Time: O(N + M)\\n * *Space: O(N)\\n */\\n// Runtime: 282 ms, faster than 20.17% of JavaScript online submissions for Most Stones Removed with Same Row or Column.\\n// Memory Usage: 49.5 MB, less than 57.98% of JavaScript online submissions for Most Stones Removed with Same Row or Column.\\n\\n// find the number of valid stones\\n// if valid, traverse stones and look for same row and col then remove those stones\\nconst removeStones = stones => {\\n\\tconst visited = new Set();\\n\\tlet valid = 0;\\n\\n  // find and remove stones that have same row and col\\n\\tconst traverse = (row, col) => {\\n\\t\\tconst key = `${row}-${col}`;\\n\\n\\t\\tif (visited.has(key)) return;\\n\\n\\t\\tvisited.add(key); // mark visited\\n\\t\\tfor (const [x, y] of stones) {\\n\\t\\t\\t// if row or col is same, should be removed\\n\\t\\t\\tif (row === x || col === y) traverse(x, y);\\n\\t\\t}\\n\\t};\\n\\n\\tfor (const [x, y] of stones) {\\n\\t\\tconst key = `${x}-${y}`;\\n\\n\\t\\tif (visited.has(key)) continue;\\n\\n\\t\\ttraverse(x, y);\\n\\t\\tvalid++;\\n\\t}\\n\\n  // subtract number of valid nodes from total number of stones\\n\\treturn stones.length - valid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1536478,
                "title": "dfs-c-beginner-friendly",
                "content": "```\\n    map<int, vector<pair<int, int>>> rows, cols;\\n    map<int, map<int, int>> mp;\\n    \\n    int removeStones(vector<vector<int>>& g) {\\n\\n        for(auto n : g) {\\n            \\n            int i = n[0]; int j = n[1];\\n            rows[i].push_back({i, j});\\n            cols[j].push_back({i, j});\\n            mp[i][j] = 1;\\n        }\\n        \\n        int n = 0;\\n        \\n        for(auto e : g) \\n            if(mp[e[0]][e[1]]) dfs(e[0], e[1]), n++;\\n        \\n        return g.size() - n;\\n    }\\n    \\n    void dfs(int i, int j) {\\n        \\n        if(mp[i][j] == 0) return;\\n        mp[i][j] = 0;\\n        \\n        for(auto n : rows[i]) dfs(n.first, n.second);\\n        for(auto n : cols[j]) dfs(n.first, n.second);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    map<int, vector<pair<int, int>>> rows, cols;\\n    map<int, map<int, int>> mp;\\n    \\n    int removeStones(vector<vector<int>>& g) {\\n\\n        for(auto n : g) {\\n            \\n            int i = n[0]; int j = n[1];\\n            rows[i].push_back({i, j});\\n            cols[j].push_back({i, j});\\n            mp[i][j] = 1;\\n        }\\n        \\n        int n = 0;\\n        \\n        for(auto e : g) \\n            if(mp[e[0]][e[1]]) dfs(e[0], e[1]), n++;\\n        \\n        return g.size() - n;\\n    }\\n    \\n    void dfs(int i, int j) {\\n        \\n        if(mp[i][j] == 0) return;\\n        mp[i][j] = 0;\\n        \\n        for(auto n : rows[i]) dfs(n.first, n.second);\\n        for(auto n : cols[j]) dfs(n.first, n.second);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 496258,
                "title": "forget-about-union-find-count-the-number-of-islands-python-o-n",
                "content": "As pointed out by solution, the main insight is to convert the problem to \\'count the number of islands\\'.\\n\\nHowever, most answers, including the Solution and he highest voted one, use Union Find.\\nThis bring us two inconvenience:\\n**1. you need a template\\n2. The time complexity is a little hard to prove.**\\n\\nHere we give a much more concise solution which avoids union find (though under the hood it is borrowing the idea)\\n\\n**We want to build a graph of all points.**\\n\\nThe brute force is to connect the point to every point it \"should\" connect: Iterating the list, for each point, look back and see if traversed points are on the same row/column. Doing this is undesirable O(N^2).\\n\\nSince we only care about the connected component here, we can build the graph in a different way. we only connect every point to a \\'representative\\' point on that row/column. And how do we find the representative point? Very easy. When iterating the list, the first time you encounter a point on that row/column, appoint it as the representative of that row/column.\\n\\nThe graph buiding is O(N), and we end up with a graph of same connected component as brute-force.\\n\\nThe DFS of \"count the number of islands\" is also easy-to-prove O(N).\\n**So the overall Time Complexity is O(N)**\\n**Space complecity is also O(N), where N is the number of points**\\n\\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        row_repres = {}\\n        col_repres = {}\\n        graph = {}\\n        for x, y in stones:\\n            if x not in row_repres:\\n                row_repres[x] = (x,y)\\n            if y not in col_repres:\\n                col_repres[y] = (x,y)\\n            graph[(x,y)] = []\\n            if row_repres[x] != (x,y):\\n                graph[row_repres[x]].append((x,y))\\n                graph[(x,y)].append(row_repres[x])\\n            if col_repres[y] != (x,y):\\n                graph[col_repres[y]].append((x,y))\\n                graph[(x,y)].append(col_repres[y])\\n        \\n        def dfs(x,y,visited):\\n            visited.add((x,y))\\n            for nb_x, nb_y in graph[(x,y)]:\\n                if (nb_x, nb_y) not in visited:\\n                    dfs(nb_x, nb_y,visited)\\n        \\n        num_islands = 0\\n        visited = set()\\n        for x, y in stones:\\n            if (x, y) not in visited:\\n                dfs(x,y,visited)\\n                num_islands += 1\\n        \\n        return len(stones) - num_islands\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        row_repres = {}\\n        col_repres = {}\\n        graph = {}\\n        for x, y in stones:\\n            if x not in row_repres:\\n                row_repres[x] = (x,y)\\n            if y not in col_repres:\\n                col_repres[y] = (x,y)\\n            graph[(x,y)] = []\\n            if row_repres[x] != (x,y):\\n                graph[row_repres[x]].append((x,y))\\n                graph[(x,y)].append(row_repres[x])\\n            if col_repres[y] != (x,y):\\n                graph[col_repres[y]].append((x,y))\\n                graph[(x,y)].append(col_repres[y])\\n        \\n        def dfs(x,y,visited):\\n            visited.add((x,y))\\n            for nb_x, nb_y in graph[(x,y)]:\\n                if (nb_x, nb_y) not in visited:\\n                    dfs(nb_x, nb_y,visited)\\n        \\n        num_islands = 0\\n        visited = set()\\n        for x, y in stones:\\n            if (x, y) not in visited:\\n                dfs(x,y,visited)\\n                num_islands += 1\\n        \\n        return len(stones) - num_islands\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440044,
                "title": "c-dfs-solution",
                "content": "Runtime: 264 ms, faster than 5.52% of C++ online submissions for Most Stones Removed with Same Row or Column.\\nMemory Usage: 13.4 MB, less than 100.00% of C++ online submissions for Most Stones Removed with Same Row or Column.\\n\\n```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        int res = 0;\\n        int n = stones.size();\\n        vector<bool> visited(n, false);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(!visited[i])\\n                res += dfs(stones, visited, i) - 1;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int dfs(vector<vector<int>>& stones, vector<bool>& visited, int curr)\\n    {\\n        if(visited[curr]) return 0;\\n        int ret = 1;\\n        visited[curr] = true;\\n        \\n        for(int i=0; i<stones.size(); i++)\\n        {\\n            if(!visited[i] && (stones[i][0] == stones[curr][0] || stones[curr][1] == stones[i][1]))\\n                ret += dfs(stones, visited, i);\\n        }\\n        return ret;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        int res = 0;\\n        int n = stones.size();\\n        vector<bool> visited(n, false);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(!visited[i])\\n                res += dfs(stones, visited, i) - 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2813025,
                "title": "remove-same-row-and-col-no-dfs-union-find-basic-programming-approach",
                "content": "Hi All,\\n\\nI could see many approaches like union find and dfs which are much helping, but I am writing this for people who just started and finding it difficult to understand those concepts right away..\\n\\nI just utilized basic queue and boolean array inorder to achieve this solution(may look little amature, but this is beginner friendly soultion):\\n\\nSteps:\\n1. Just come up with 2 queues for row and column and one boolean array for flag,\\n2. Maintain 2 set\\'s of visited row\\'s and coln\\'s so that you don\\'t go in a infinete loop of visiting same row/columns again again (add rows and columns once its visited in this set)\\n3. Take first element in the given array, see for matching column or row in the entire array and add it to their respective queues and mark the flag as true if satisfied\\n4. Once you went throught the entire list once, go to the queue\\'s row and column\\n5. Check for the matching row or column respectively and mark the flag as true\\n6. At last, see how many flags are marked as true and give the result..\\n\\nHere is the code, Happy learning... Kindly upvote if it helps :)\\n\\n```\\n\\tpublic int removeStones(int[][] stones) {\\n        int res=0;\\n        boolean[] flag = new boolean[stones.length];\\n        Queue<Integer> col = new LinkedList();\\n        Queue<Integer> row = new LinkedList();\\n        HashSet<Integer> visitedrow = new HashSet();\\n        HashSet<Integer> visitedcol = new HashSet();\\n        for(int i=0; i<stones.length; i++){\\n        \\tif(flag[i]==true)\\n        \\t\\tcontinue;\\n        int a=stones[i][0];\\n        int b=stones[i][1];\\n        visitedrow.add(a);\\n        visitedcol.add(b);\\n        for(int j=i+1; j<stones.length; j++){\\n        \\tif(stones[j][0]==a){\\n        \\t\\tflag[j]=true;\\n        \\t\\tif(!visitedcol.contains(stones[j][1]))\\n        \\t\\t\\tcol.add(stones[j][1]);\\n        \\t\\tcontinue;\\n        \\t}\\n        \\tif(stones[j][1]==b){\\n        \\t\\tflag[j]=true;\\n        \\t\\tif(!visitedrow.contains(stones[j][0]))\\n        \\t\\t\\trow.add(stones[j][0]);\\n        \\t\\tcontinue;\\n        \\t}\\n        }\\n        while(!row.isEmpty() || !col.isEmpty()){\\n        while(!row.isEmpty()){\\n        \\ta=row.poll();\\n        \\tvisitedrow.add(a);\\n        \\tfor(int j=i+1; j<stones.length; j++){\\n        \\t\\tif(flag[j]==true)\\n            \\t\\tcontinue;\\n        \\t\\tif(stones[j][0]==a){\\n            \\t\\tflag[j]=true;\\n            \\t\\tif(!visitedcol.contains(stones[j][1]))\\n            \\t\\t\\tcol.add(stones[j][1]);\\n            \\t\\tcontinue;\\n            \\t}\\n        \\t}\\n        }\\n        while(!col.isEmpty()){\\n        \\tb=col.poll();\\n            visitedcol.add(b);\\n        \\tfor(int j=i+1; j<stones.length; j++){\\n        \\t\\tif(flag[j]==true)\\n            \\t\\tcontinue;\\n        \\t\\tif(stones[j][1]==b){\\n            \\t\\tflag[j]=true;\\n            \\t\\tif(!visitedrow.contains(stones[j][0]))\\n            \\t\\t\\trow.add(stones[j][0]);\\n            \\t\\tcontinue;\\n            \\t}\\n        \\t}\\n        }\\n        }\\n        }\\n        for(int i=0; i<stones.length; i++){\\n        \\tif(flag[i]==true)\\n        \\t\\tres++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "Hi All,\\n\\nI could see many approaches like union find and dfs which are much helping, but I am writing this for people who just started and finding it difficult to understand those concepts right away..\\n\\nI just utilized basic queue and boolean array inorder to achieve this solution(may look little amature, but this is beginner friendly soultion):\\n\\nSteps:\\n1. Just come up with 2 queues for row and column and one boolean array for flag,\\n2. Maintain 2 set\\'s of visited row\\'s and coln\\'s so that you don\\'t go in a infinete loop of visiting same row/columns again again (add rows and columns once its visited in this set)\\n3. Take first element in the given array, see for matching column or row in the entire array and add it to their respective queues and mark the flag as true if satisfied\\n4. Once you went throught the entire list once, go to the queue\\'s row and column\\n5. Check for the matching row or column respectively and mark the flag as true\\n6. At last, see how many flags are marked as true and give the result..\\n\\nHere is the code, Happy learning... Kindly upvote if it helps :)\\n\\n```\\n\\tpublic int removeStones(int[][] stones) {\\n        int res=0;\\n        boolean[] flag = new boolean[stones.length];\\n        Queue<Integer> col = new LinkedList();\\n        Queue<Integer> row = new LinkedList();\\n        HashSet<Integer> visitedrow = new HashSet();\\n        HashSet<Integer> visitedcol = new HashSet();\\n        for(int i=0; i<stones.length; i++){\\n        \\tif(flag[i]==true)\\n        \\t\\tcontinue;\\n        int a=stones[i][0];\\n        int b=stones[i][1];\\n        visitedrow.add(a);\\n        visitedcol.add(b);\\n        for(int j=i+1; j<stones.length; j++){\\n        \\tif(stones[j][0]==a){\\n        \\t\\tflag[j]=true;\\n        \\t\\tif(!visitedcol.contains(stones[j][1]))\\n        \\t\\t\\tcol.add(stones[j][1]);\\n        \\t\\tcontinue;\\n        \\t}\\n        \\tif(stones[j][1]==b){\\n        \\t\\tflag[j]=true;\\n        \\t\\tif(!visitedrow.contains(stones[j][0]))\\n        \\t\\t\\trow.add(stones[j][0]);\\n        \\t\\tcontinue;\\n        \\t}\\n        }\\n        while(!row.isEmpty() || !col.isEmpty()){\\n        while(!row.isEmpty()){\\n        \\ta=row.poll();\\n        \\tvisitedrow.add(a);\\n        \\tfor(int j=i+1; j<stones.length; j++){\\n        \\t\\tif(flag[j]==true)\\n            \\t\\tcontinue;\\n        \\t\\tif(stones[j][0]==a){\\n            \\t\\tflag[j]=true;\\n            \\t\\tif(!visitedcol.contains(stones[j][1]))\\n            \\t\\t\\tcol.add(stones[j][1]);\\n            \\t\\tcontinue;\\n            \\t}\\n        \\t}\\n        }\\n        while(!col.isEmpty()){\\n        \\tb=col.poll();\\n            visitedcol.add(b);\\n        \\tfor(int j=i+1; j<stones.length; j++){\\n        \\t\\tif(flag[j]==true)\\n            \\t\\tcontinue;\\n        \\t\\tif(stones[j][1]==b){\\n            \\t\\tflag[j]=true;\\n            \\t\\tif(!visitedrow.contains(stones[j][0]))\\n            \\t\\t\\trow.add(stones[j][0]);\\n            \\t\\tcontinue;\\n            \\t}\\n        \\t}\\n        }\\n        }\\n        }\\n        for(int i=0; i<stones.length; i++){\\n        \\tif(flag[i]==true)\\n        \\t\\tres++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2812932,
                "title": "c-easy-understanding-dfs-approach-video-solution",
                "content": "**C++ Clear Explaination DFS Approach easy -understandable ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/kEwUvJrt8Wo\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool checkSameGroup(vector<int>&stone1 ,vector<int>&stone2){\\n        if(stone1[0] == stone2[0] || stone1[1] == stone2[1]) return true;\\n        return false;\\n    }\\n\\n    void  dfs(vector<int>&visited,vector<vector<int>>& stones,int index){\\n\\n        // make it visited.\\n        visited[index] =1;\\n\\n        // traversal.\\n        for(int i=0;i<stones.size();i++){\\n            // if not visited and are in same group ,call dfs\\n            if(!visited[i] && checkSameGroup(stones[index],stones[i])){\\n                dfs(visited,stones,i);\\n            }\\n        }\\n\\n    }\\n\\n    int removeStones(vector<vector<int>>& stones) {\\n    //if two stones shares the same row or the same column, they are in same group and we want  just one stone to remove all other stone in a group .\\n     // hence question is count the connected component in a graph.\\n     // use dfs.\\n     //  Hence our answer will be total count - the number of the connected components\\n\\n        int n = stones.size();\\n        vector<int>visited(n,0);\\n        int components =0;\\n        for(int i=0;i<n;i++){\\n\\n            if(!visited[i]){\\n                components++;\\n                dfs(visited,stones,i);\\n            }\\n        }\\n\\n        return n-components;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool checkSameGroup(vector<int>&stone1 ,vector<int>&stone2){\\n        if(stone1[0] == stone2[0] || stone1[1] == stone2[1]) return true;\\n        return false;\\n    }\\n\\n    void  dfs(vector<int>&visited,vector<vector<int>>& stones,int index){\\n\\n        // make it visited.\\n        visited[index] =1;\\n\\n        // traversal.\\n        for(int i=0;i<stones.size();i++){\\n            // if not visited and are in same group ,call dfs\\n            if(!visited[i] && checkSameGroup(stones[index],stones[i])){\\n                dfs(visited,stones,i);\\n            }\\n        }\\n\\n    }\\n\\n    int removeStones(vector<vector<int>>& stones) {\\n    //if two stones shares the same row or the same column, they are in same group and we want  just one stone to remove all other stone in a group .\\n     // hence question is count the connected component in a graph.\\n     // use dfs.\\n     //  Hence our answer will be total count - the number of the connected components\\n\\n        int n = stones.size();\\n        vector<int>visited(n,0);\\n        int components =0;\\n        for(int i=0;i<n;i++){\\n\\n            if(!visited[i]){\\n                components++;\\n                dfs(visited,stones,i);\\n            }\\n        }\\n\\n        return n-components;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151855,
                "title": "python-solution-using-union-find",
                "content": "```\\nclass Solution(object):\\n\\n    def union(self, x, y):\\n        parent_x = self.find(x)\\n        parent_y = self.find(y)\\n        if parent_x != parent_y:\\n            self.p[parent_y] = parent_x \\n            self.count-=1\\n            \\n\\n    def find(self, x):\\n        while self.p[x] != x:\\n            x = self.p[x]\\n        return self.p[x]\\n\\n    def removeStones(self, stones):\\n        self.p = range(len(stones))\\n        self.count = len(stones)\\n        for i in range(1, len(stones)):\\n            for j in range(i):\\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\\n                    self.union(i, j)\\n        return len(stones) - self.count\\n            \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution(object):\\n\\n    def union(self, x, y):\\n        parent_x = self.find(x)\\n        parent_y = self.find(y)\\n        if parent_x != parent_y:\\n            self.p[parent_y] = parent_x \\n            self.count-=1\\n            \\n\\n    def find(self, x):\\n        while self.p[x] != x:\\n            x = self.p[x]\\n        return self.p[x]\\n\\n    def removeStones(self, stones):\\n        self.p = range(len(stones))\\n        self.count = len(stones)\\n        for i in range(1, len(stones)):\\n            for j in range(i):\\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\\n                    self.union(i, j)\\n        return len(stones) - self.count\\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 252872,
                "title": "union-find",
                "content": "> Why are there different number of stones removed?\\nBecause of the different order of removal. We target to find the one gives more moves.\\n\\n> If we take a stone as a node, two nodes are connected if they `share the column or row`.\\n> In this way, the graph is divided into several connected components.\\n> For each connected component, we can remove at most (componnet.size - 1) nodes.\\n\\n> To build connected components and maintain size of each component, we can take advantage of `Union Find`.\\n****\\n```\\n    public int removeStones(int[][] stones) {\\n        UF uf = new UF(stones.length);\\n        \\n        for (int i = 0; i < stones.length; i++) {\\n            for (int j = i + 1; j < stones.length; j++) {\\n                if (stones[i][0] == stones[j][0]\\n                    || stones[i][1] == stones[j][1]) {\\n                    // stones[i] and stones[j] are connected\\n                    uf.union(i, j);\\n                }\\n            }\\n        }\\n        \\n        int maxMove = 0;\\n        for (int i = 0; i < stones.length; i++) {\\n            if (uf.size[i] > 1) {\\n                // for connected component with more than one nodes\\n                maxMove += uf.size[i] - 1;\\n            }\\n        }\\n        return maxMove;\\n    }\\n    \\n    class UF {\\n        private int[] parent;\\n        int[] size;\\n        \\n        public UF(int n) {\\n            parent = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        private int find(int x) {\\n            if (parent[x] == x) {\\n                return x;\\n            }\\n            \\n            return parent[x] = find(parent[x]); // compresskon\\n        }\\n        \\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n                size[rootX] = 0; // to avoid duplicate calculation\\n            }\\n        }\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int removeStones(int[][] stones) {\\n        UF uf = new UF(stones.length);\\n        \\n        for (int i = 0; i < stones.length; i++) {\\n            for (int j = i + 1; j < stones.length; j++) {\\n                if (stones[i][0] == stones[j][0]\\n                    || stones[i][1] == stones[j][1]) {\\n                    // stones[i] and stones[j] are connected\\n                    uf.union(i, j);\\n                }\\n            }\\n        }\\n        \\n        int maxMove = 0;\\n        for (int i = 0; i < stones.length; i++) {\\n            if (uf.size[i] > 1) {\\n                // for connected component with more than one nodes\\n                maxMove += uf.size[i] - 1;\\n            }\\n        }\\n        return maxMove;\\n    }\\n    \\n    class UF {\\n        private int[] parent;\\n        int[] size;\\n        \\n        public UF(int n) {\\n            parent = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        private int find(int x) {\\n            if (parent[x] == x) {\\n                return x;\\n            }\\n            \\n            return parent[x] = find(parent[x]); // compresskon\\n        }\\n        \\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                parent[rootX] = rootY;\\n                size[rootY] += size[rootX];\\n                size[rootX] = 0; // to avoid duplicate calculation\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456593,
                "title": "connected-components-c-bfs",
                "content": "Consider each stone as a node . So now there is an edge between two nodes if either column or row values are equal. \\nAfter creating the graph we can see that  the graph can be deduced in  connected components each component  is a bunch of stones  sharing the given property \\nSo all we need to do is to **remove all except one from the connected component** (bunch of stones ) .\\nTherefore the answer will be : \\nfor every connected component  : **ans += sizeof(connected component)-1**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solver(vector<int>adj[] ,vector<bool>&vis, int i){\\n        vis[i]=true ; \\n        queue<int> q; \\n        q.push(i); \\n        int ans =1 ; \\n        while(!q.empty()){\\n            int v = q.front();\\n            q.pop(); \\n            for(int u : adj[v]){\\n                if(!vis[u]){\\n                    vis[u]=true ; \\n                    ans ++; \\n                    q.push(u);\\n                }\\n\\n            }\\n            \\n        }\\n        return ans ;\\n    }\\n    int removeStones(vector<vector<int>>& v) {\\n        int n = v.size() ;\\n        vector<int>adj[n]; \\n        \\n        for(int i =0 ; i< n ; i++){\\n            for(int j=i+1 ; j<n ; j++){\\n                if(v[i][0]==v[j][0] or v[i][1]==v[j][1]){\\n                    adj[i].push_back(j); \\n                    adj[j].push_back(i); \\n                }\\n            }\\n        }\\n        \\n        vector<bool>vis(n,false);\\n        int ans =0 ;\\n        for(int i =0 ; i< n ; i++){\\n            if(!vis[i]){\\n                // cout<<i<<\" \";\\n                // cout<<solver(adj,vis,i);\\n                int t= solver(adj, vis , i); \\n                cout<<t<<\" \";\\n                if(t>0){\\n                    ans=ans+t; \\n                    ans--;\\n                }\\n            }\\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solver(vector<int>adj[] ,vector<bool>&vis, int i){\\n        vis[i]=true ; \\n        queue<int> q; \\n        q.push(i); \\n        int ans =1 ; \\n        while(!q.empty()){\\n            int v = q.front();\\n            q.pop(); \\n            for(int u : adj[v]){\\n                if(!vis[u]){\\n                    vis[u]=true ; \\n                    ans ++; \\n                    q.push(u);\\n                }\\n\\n            }\\n            \\n        }\\n        return ans ;\\n    }\\n    int removeStones(vector<vector<int>>& v) {\\n        int n = v.size() ;\\n        vector<int>adj[n]; \\n        \\n        for(int i =0 ; i< n ; i++){\\n            for(int j=i+1 ; j<n ; j++){\\n                if(v[i][0]==v[j][0] or v[i][1]==v[j][1]){\\n                    adj[i].push_back(j); \\n                    adj[j].push_back(i); \\n                }\\n            }\\n        }\\n        \\n        vector<bool>vis(n,false);\\n        int ans =0 ;\\n        for(int i =0 ; i< n ; i++){\\n            if(!vis[i]){\\n                // cout<<i<<\" \";\\n                // cout<<solver(adj,vis,i);\\n                int t= solver(adj, vis , i); \\n                cout<<t<<\" \";\\n                if(t>0){\\n                    ans=ans+t; \\n                    ans--;\\n                }\\n            }\\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1258480,
                "title": "java-standard-union-find-template-with-arrays-quicker-and-easier-than-other-uf-submissions",
                "content": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        UnionFind uf = new UnionFind(stones);\\n        \\n\\t\\t// check all the elements with each other and try to union them if they have same column or row \\n        for(int i = 0; i < stones.length; i++){\\n            for(int j = 0; j < stones.length; j++){\\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) { // in the same column or row\\n                    // union based on index \\n\\t\\t\\t\\t\\tuf.union(i, j);\\n                }\\n            }\\n        }\\n        \\n\\t\\t// take the total number of nodes subtracted by the number of islands \\n        return stones.length - uf.getCount();\\n    }\\n    \\n    class UnionFind {\\n        int count; // # of connected components (or islands) \\n        int[] parent;\\n        int[] rank;\\n\\t\\t\\n\\t\\t// set each node to be it\\'s own parent \\n        public UnionFind(int[][] stones) { \\n\\t\\t\\tcount = 0;\\n\\t\\t\\tint m = stones.length;\\n\\t\\t\\tparent = new int[m];\\n\\t\\t\\trank = new int[m];\\n\\t\\t\\tfor (int i = 0; i < m; ++i) {\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\trank[i] = 1;\\n\\t\\t\\t}\\n        }\\n\\n\\t\\t// find with path compression \\n\\t\\tpublic int find(int i) { \\n\\t\\t\\tif (parent[i] != i) {\\n\\t\\t\\t\\tparent[i] = find(parent[i]);\\n\\t\\t\\t}\\n            \\n\\t\\t\\treturn parent[i];\\n        }\\n\\n        public void union(int x, int y) { // union with rank\\n          int rootx = find(x);\\n          int rooty = find(y);\\n          if (rootx != rooty) {\\n              if (rank[rootx] > rank[rooty]) {\\n                  parent[rooty] = rootx;\\n              } else if (rank[rootx] < rank[rooty])  {\\n                  parent[rootx] = rooty;\\n              } else {\\n                  parent[rooty] = rootx; \\n                  rank[rootx] += 1;\\n              }\\n              count--;\\n          }\\n        }\\n\\n        public int getCount() {\\n          return count;\\n        }\\n  }   \\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        UnionFind uf = new UnionFind(stones);\\n        \\n\\t\\t// check all the elements with each other and try to union them if they have same column or row \\n        for(int i = 0; i < stones.length; i++){\\n            for(int j = 0; j < stones.length; j++){\\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) { // in the same column or row\\n                    // union based on index \\n\\t\\t\\t\\t\\tuf.union(i, j);\\n                }\\n            }\\n        }\\n        \\n\\t\\t// take the total number of nodes subtracted by the number of islands \\n        return stones.length - uf.getCount();\\n    }\\n    \\n    class UnionFind {\\n        int count; // # of connected components (or islands) \\n        int[] parent;\\n        int[] rank;\\n\\t\\t\\n\\t\\t// set each node to be it\\'s own parent \\n        public UnionFind(int[][] stones) { \\n\\t\\t\\tcount = 0;\\n\\t\\t\\tint m = stones.length;\\n\\t\\t\\tparent = new int[m];\\n\\t\\t\\trank = new int[m];\\n\\t\\t\\tfor (int i = 0; i < m; ++i) {\\n\\t\\t\\t\\tparent[i] = i;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\trank[i] = 1;\\n\\t\\t\\t}\\n        }\\n\\n\\t\\t// find with path compression \\n\\t\\tpublic int find(int i) { \\n\\t\\t\\tif (parent[i] != i) {\\n\\t\\t\\t\\tparent[i] = find(parent[i]);\\n\\t\\t\\t}\\n            \\n\\t\\t\\treturn parent[i];\\n        }\\n\\n        public void union(int x, int y) { // union with rank\\n          int rootx = find(x);\\n          int rooty = find(y);\\n          if (rootx != rooty) {\\n              if (rank[rootx] > rank[rooty]) {\\n                  parent[rooty] = rootx;\\n              } else if (rank[rootx] < rank[rooty])  {\\n                  parent[rootx] = rooty;\\n              } else {\\n                  parent[rooty] = rootx; \\n                  rank[rootx] += 1;\\n              }\\n              count--;\\n          }\\n        }\\n\\n        public int getCount() {\\n          return count;\\n        }\\n  }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950254,
                "title": "stones-are-edges-not-points-hand-made-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/e691ccfd-ea41-4aed-a0f7-295d0d335a7d_1606437061.509753.png)\\n![image](https://assets.leetcode.com/users/images/6b72e16e-81aa-4302-8049-43a2bb9561e0_1606436934.4372423.png)\\n![image](https://assets.leetcode.com/users/images/caf4dd9c-88bc-4e19-8c40-837d0a2cfb20_1606436947.9613636.png)\\n![image](https://assets.leetcode.com/users/images/a09019e9-cac0-4cc6-9275-39379cc1ca24_1606436960.959316.png)\\n\\n\\n```python\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:            \\n        def get_root (i, parents):\\n          while (parents[i] > -1):\\n            i = parents[i]\\n          return i\\n        \\n        def union (root1, root2, parents):\\n          if parents[root1] > parents[root2]:\\n            root1, root2 = root2, root1\\n          parents[root1] += parents[root2]\\n          parents[root2] = root1\\n        \\n        parents = {}\\n        for x, y in stones:\\n          parents[x] = -1\\n          parents[y + 10000] = -1\\n        \\n        for x, y in stones:\\n          x_root = get_root(x, parents)\\n          y_root = get_root(y + 10000, parents)\\n          if (x_root != y_root):\\n            union(x_root, y_root, parents)\\n        \\n        number_of_roots = 0\\n               \\n        for i in parents.values():\\n          if i < 0:\\n            number_of_roots += 1       \\n          \\n        return len(stones) - number_of_roots\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:            \\n        def get_root (i, parents):\\n          while (parents[i] > -1):\\n            i = parents[i]\\n          return i\\n        \\n        def union (root1, root2, parents):\\n          if parents[root1] > parents[root2]:\\n            root1, root2 = root2, root1\\n          parents[root1] += parents[root2]\\n          parents[root2] = root1\\n        \\n        parents = {}\\n        for x, y in stones:\\n          parents[x] = -1\\n          parents[y + 10000] = -1\\n        \\n        for x, y in stones:\\n          x_root = get_root(x, parents)\\n          y_root = get_root(y + 10000, parents)\\n          if (x_root != y_root):\\n            union(x_root, y_root, parents)\\n        \\n        number_of_roots = 0\\n               \\n        for i in parents.values():\\n          if i < 0:\\n            number_of_roots += 1       \\n          \\n        return len(stones) - number_of_roots\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814551,
                "title": "c-doesn-t-this-looks-familiar-hint-count-the-islands",
                "content": "# Thought Process:\\nImagine the index ```i``` of each stone in ```stones``` as vertex and each vertex consist of a value i.e. ```coordinates```. Now there exists an edge between 2 vertices if the values of vertex (coordinates) have same value for **row or column**.\\n\\nIf you got this ! 60% problem is solved !!\\n\\nAll you need to do is to perform **DFS** and find the clusters (*same as islands*) formed by these vertices.\\n\\nThe final result would be **total number of stones-total number of clusters**. Since each cluster will have one stone that is not removed.\\n\\n```\\n#define vb vector<bool>\\n#define vi vector<int> \\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    void helper (vvi &stones, int vertex, vb &visited){\\n        if (visited[vertex]) return;\\n        \\n        visited[vertex] = 1;\\n\\t\\t\\n        for (int i = 0; i < stones.size(); i++){\\n            if (i != vertex && (stones[vertex][0] == stones[i][0] || stones[vertex][1] == stones[i][1])){\\n                helper (stones, i, visited);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size(), count = 0;        \\n        vb visited (n, 0);\\n        \\n        for (int i = 0; i < n; i++){\\n            if (visited[i] == 0) count++, helper (stones,i,visited);\\n        }\\n        \\n        return n-count;\\n    }\\n};\\n```\\n\\n# Complexities\\n**TC:** O(N^2)\\n**SC:** O(N)\\n\\n*Do upvote if you were thinking of same logic !!*",
                "solutionTags": [
                    "C"
                ],
                "code": "```i```\n```stones```\n```coordinates```\n```\\n#define vb vector<bool>\\n#define vi vector<int> \\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    void helper (vvi &stones, int vertex, vb &visited){\\n        if (visited[vertex]) return;\\n        \\n        visited[vertex] = 1;\\n\\t\\t\\n        for (int i = 0; i < stones.size(); i++){\\n            if (i != vertex && (stones[vertex][0] == stones[i][0] || stones[vertex][1] == stones[i][1])){\\n                helper (stones, i, visited);\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size(), count = 0;        \\n        vb visited (n, 0);\\n        \\n        for (int i = 0; i < n; i++){\\n            if (visited[i] == 0) count++, helper (stones,i,visited);\\n        }\\n        \\n        return n-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812808,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n      Set<int[]> visited=new HashSet<>();\\n      int numOfIslands=0;\\n      for(int[] s1:stones){\\n          if(!visited.contains(s1)){\\n              dfs(s1,visited,stones);\\n              numOfIslands++;\\n          }\\n      }\\n     return stones.length-numOfIslands;   \\n    }\\n    private void dfs(int[] s1, Set<int[]> visited, int[][] stones){\\n     visited.add(s1);\\n     for(int[] s2:stones){\\n         if(!visited.contains(s2)){\\n             if(s1[0]==s2[0] || s1[1]==s2[1]){\\n               dfs(s2, visited, stones);  \\n             }\\n         }\\n     }\\n    }       \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n      Set<int[]> visited=new HashSet<>();\\n      int numOfIslands=0;\\n      for(int[] s1:stones){\\n          if(!visited.contains(s1)){\\n              dfs(s1,visited,stones);\\n              numOfIslands++;\\n          }\\n      }\\n     return stones.length-numOfIslands;   \\n    }\\n    private void dfs(int[] s1, Set<int[]> visited, int[][] stones){\\n     visited.add(s1);\\n     for(int[] s2:stones){\\n         if(!visited.contains(s2)){\\n             if(s1[0]==s2[0] || s1[1]==s2[1]){\\n               dfs(s2, visited, stones);  \\n             }\\n         }\\n     }\\n    }       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812564,
                "title": "c-n-2-dfs",
                "content": "```\\npublic class Solution {\\n    public int RemoveStones(int[][] stones) {\\n        int components = 0;\\n        HashSet<int[]> visited = new();\\n        foreach(int[] stone in stones){\\n            if(!visited.Contains(stone)){\\n                dfs(stone, stones, visited);\\n                components++;\\n            }\\n        }\\n        return stones.Length-components;\\n    }\\n\\n    private void dfs(int[] stone, int[][] stones, HashSet<int[]> visited){\\n        visited.Add(stone);\\n        foreach(int[] next in stones){\\n            if(!visited.Contains(next))\\n                if(stone[0] == next[0] || stone[1] == next[1])\\n                    dfs(next, stones, visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveStones(int[][] stones) {\\n        int components = 0;\\n        HashSet<int[]> visited = new();\\n        foreach(int[] stone in stones){\\n            if(!visited.Contains(stone)){\\n                dfs(stone, stones, visited);\\n                components++;\\n            }\\n        }\\n        return stones.Length-components;\\n    }\\n\\n    private void dfs(int[] stone, int[][] stones, HashSet<int[]> visited){\\n        visited.Add(stone);\\n        foreach(int[] next in stones){\\n            if(!visited.Contains(next))\\n                if(stone[0] == next[0] || stone[1] == next[1])\\n                    dfs(next, stones, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019097,
                "title": "count-the-number-of-connected-graphs-o-n",
                "content": "We move the problem to a graph domain. When two stones row or column is same, we can say the they are adjacent.\\nSo, after construcing the graph, we get a collection of one or more [connected graphs](https://mathworld.wolfram.com/ConnectedGraph.html#:~:text=A%20connected%20graph%20is%20graph,is%20said%20to%20be%20disconnected.) In graph\\'s terminology, this is called **strongly connected component**.\\n\\nNow, for every stronly connected component, one stone will remain, all others inside that component can be removed (because from that remaining stone, we can move to other stones in that component and remove them).\\n\\nSo, Our answer should be = Number ot stones - Number of strongly connected component\\n\\n**Algorightm**\\n1. Prepare the graph\\n2. From every stone\\n\\ta. If not visitied, run dfs/bfs to remove connected nodes.\\n\\tb. After removing a node, track that to avoid infinite loop\\n\\tc. When a strongly connected component is fully traversed, subtract 1 to track that *remaining stone*\\n3. Do this until all stones are traversed.\\n\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> rowNodes, colNodes;\\n    unordered_set<string> seen;\\n    int removed = 0;\\n    string getKey(int i, int j) {\\n        return to_string(i) + \"*\" + to_string(j);\\n    }\\n    void removeStones(int row, int col) {\\n        string key = getKey(row, col);\\n        \\n        if (seen.find(key) != seen.end()) {\\n            return;\\n        }\\n        \\n        removed++;\\n        seen.insert(key);\\n        \\n        vector<int> rows = rowNodes[row];\\n        vector<int> cols = colNodes[col];\\n\\n        rowNodes[row] = {};\\n        colNodes[col] = {};\\n\\n        for(int val: rows) {\\n            removeStones(row, val);\\n        }\\n\\n        for(int val: cols) {\\n            removeStones(val, col);\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        for(vector<int> stone: stones) {\\n            int row = stone[0], col = stone[1];\\n            \\n            rowNodes[row].push_back(col);\\n            colNodes[col].push_back(row);\\n        }\\n        \\n        for(vector<int> stone: stones) {\\n            int row = stone[0], col = stone[1];\\n            \\n            string key = getKey(row, col);\\n            if (seen.find(key) == seen.end()) {\\n                removeStones(row, col);\\n                removed--;\\n            }\\n        }\\n        \\n        return removed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> rowNodes, colNodes;\\n    unordered_set<string> seen;\\n    int removed = 0;\\n    string getKey(int i, int j) {\\n        return to_string(i) + \"*\" + to_string(j);\\n    }\\n    void removeStones(int row, int col) {\\n        string key = getKey(row, col);\\n        \\n        if (seen.find(key) != seen.end()) {\\n            return;\\n        }\\n        \\n        removed++;\\n        seen.insert(key);\\n        \\n        vector<int> rows = rowNodes[row];\\n        vector<int> cols = colNodes[col];\\n\\n        rowNodes[row] = {};\\n        colNodes[col] = {};\\n\\n        for(int val: rows) {\\n            removeStones(row, val);\\n        }\\n\\n        for(int val: cols) {\\n            removeStones(val, col);\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        for(vector<int> stone: stones) {\\n            int row = stone[0], col = stone[1];\\n            \\n            rowNodes[row].push_back(col);\\n            colNodes[col].push_back(row);\\n        }\\n        \\n        for(vector<int> stone: stones) {\\n            int row = stone[0], col = stone[1];\\n            \\n            string key = getKey(row, col);\\n            if (seen.find(key) == seen.end()) {\\n                removeStones(row, col);\\n                removed--;\\n            }\\n        }\\n        \\n        return removed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504135,
                "title": "python-dfs-and-union-find",
                "content": "# DFS\\n```python\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        graph = collections.defaultdict(list)\\n        for i in range(len(stones)):\\n            for j in range(i):\\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\\n                    graph[i].append(j)\\n                    graph[j].append(i)\\n        visited = set()\\n        self.count = 0\\n        def dfs(graph,v):\\n            visited.add(v)\\n            for i in graph[v]:\\n                if i not in visited:\\n                    self.count += 1\\n                    dfs(graph,i)\\n        for i in range(len(stones)):\\n            if i not in visited:\\n                dfs(graph,i)\\n        return self.count\\n```\\n# Union-Find\\n```python\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        self.cc = len(stones)\\n        def find(parent,i):\\n            if parent[i] == i:\\n                return i\\n            parent[i] = find(parent,parent[i])\\n            return parent[i]\\n        \\n        def union(rank,parent,x,y):\\n            a = find(parent,x)\\n            b = find(parent,y)\\n            if a == b: return \\n            if rank[a] > rank[b]:\\n                parent[b] = a\\n                rank[a] += rank[b]\\n            else:\\n                parent[a] = b\\n                rank[b] += rank[a]\\n            self.cc -= 1\\n        parent = [i for i in range(len(stones) + 1)]\\n        rank = [0] * (len(stones) + 1)\\n        for i in range(len(stones)):\\n            for j in range(i+1,len(stones)):\\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\\n                    union(rank,parent,i,j)\\n        return len(stones) - self.cc\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        graph = collections.defaultdict(list)\\n        for i in range(len(stones)):\\n            for j in range(i):\\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\\n                    graph[i].append(j)\\n                    graph[j].append(i)\\n        visited = set()\\n        self.count = 0\\n        def dfs(graph,v):\\n            visited.add(v)\\n            for i in graph[v]:\\n                if i not in visited:\\n                    self.count += 1\\n                    dfs(graph,i)\\n        for i in range(len(stones)):\\n            if i not in visited:\\n                dfs(graph,i)\\n        return self.count\\n```\n```python\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        self.cc = len(stones)\\n        def find(parent,i):\\n            if parent[i] == i:\\n                return i\\n            parent[i] = find(parent,parent[i])\\n            return parent[i]\\n        \\n        def union(rank,parent,x,y):\\n            a = find(parent,x)\\n            b = find(parent,y)\\n            if a == b: return \\n            if rank[a] > rank[b]:\\n                parent[b] = a\\n                rank[a] += rank[b]\\n            else:\\n                parent[a] = b\\n                rank[b] += rank[a]\\n            self.cc -= 1\\n        parent = [i for i in range(len(stones) + 1)]\\n        rank = [0] * (len(stones) + 1)\\n        for i in range(len(stones)):\\n            for j in range(i+1,len(stones)):\\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\\n                    union(rank,parent,i,j)\\n        return len(stones) - self.cc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 370777,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    // Ans = # of stones \\u2013 # of islands\\n    public int removeStones(int[][] stones) {\\n        HashSet<int[]> visited = new HashSet();\\n        int numOfIslands = 0;\\n        for (int[] s1:stones){\\n            if (!visited.contains(s1)){\\n               dfs(s1, visited, stones); \\n               numOfIslands++;\\n            }\\n        }\\n        return stones.length - numOfIslands;\\n    }\\n    \\n    private void dfs(int[] s1, Set<int[]> visited, int[][] stones){\\n        visited.add(s1);\\n        for (int[] s2: stones){\\n            if (!visited.contains(s2)){\\n\\t\\t\\t\\t// stone with same row or column. group them into island\\n                if (s1[0] == s2[0] || s1[1] == s2[1])\\n                    dfs(s2, visited, stones);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Ans = # of stones \\u2013 # of islands\\n    public int removeStones(int[][] stones) {\\n        HashSet<int[]> visited = new HashSet();\\n        int numOfIslands = 0;\\n        for (int[] s1:stones){\\n            if (!visited.contains(s1)){\\n               dfs(s1, visited, stones); \\n               numOfIslands++;\\n            }\\n        }\\n        return stones.length - numOfIslands;\\n    }\\n    \\n    private void dfs(int[] s1, Set<int[]> visited, int[][] stones){\\n        visited.add(s1);\\n        for (int[] s2: stones){\\n            if (!visited.contains(s2)){\\n\\t\\t\\t\\t// stone with same row or column. group them into island\\n                if (s1[0] == s2[0] || s1[1] == s2[1])\\n                    dfs(s2, visited, stones);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198189,
                "title": "python-sort-easy-union-find",
                "content": "```\\nclass Solution:\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def find(x):\\n            if x != parents[x]:\\n                parents[x] = find(parents[x])\\n            return parents[x]\\n        def union(x, y):\\n            parents[find(x)] = find(y)\\n        parents = list(range(20001))\\n        for i, j in stones:\\n            union(i, j + 10000)\\n        return len(stones) - len(set(find(x) for x, y in stones))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        def find(x):\\n            if x != parents[x]:\\n                parents[x] = find(parents[x])\\n            return parents[x]\\n        def union(x, y):\\n            parents[find(x)] = find(y)\\n        parents = list(range(20001))\\n        for i, j in stones:\\n            union(i, j + 10000)\\n        return len(stones) - len(set(find(x) for x, y in stones))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813470,
                "title": "java-dfs-solution-simple-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        int count=0;\\n        Set<int[]> visited=new HashSet<>();\\n        for(int i=0;i<stones.length;i++){\\n           if(!visited.contains(stones[i])){\\n                visited.add(stones[i]);\\n                removeStonesUtil(visited,stones,i);\\n                count++;\\n           }         \\n        }\\n        return stones.length-count;\\n    }\\n    public void removeStonesUtil(Set<int[]> visited,int stones[][],int idx){\\n        visited.add(stones[idx]);\\n        for(int i=0;i<stones.length;i++){\\n           if(!visited.contains(stones[i])){\\n               if(stones[idx][0]==stones[i][0] || stones[idx][1]==stones[i][1]){\\n                   removeStonesUtil(visited,stones,i);\\n               }   \\n           }         \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        int count=0;\\n        Set<int[]> visited=new HashSet<>();\\n        for(int i=0;i<stones.length;i++){\\n           if(!visited.contains(stones[i])){\\n                visited.add(stones[i]);\\n                removeStonesUtil(visited,stones,i);\\n                count++;\\n           }         \\n        }\\n        return stones.length-count;\\n    }\\n    public void removeStonesUtil(Set<int[]> visited,int stones[][],int idx){\\n        visited.add(stones[idx]);\\n        for(int i=0;i<stones.length;i++){\\n           if(!visited.contains(stones[i])){\\n               if(stones[idx][0]==stones[i][0] || stones[idx][1]==stones[i][1]){\\n                   removeStonesUtil(visited,stones,i);\\n               }   \\n           }         \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812710,
                "title": "simple-c-solution-dfs-o-n-2",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    void dfs(vector<vector<int>>&st,vector<bool>&visted,int ind){\\n        visted[ind] = true;\\n        for(int i=0;i<n;i++){\\n            // not visited and one of the x or y match\\n            if(!visted[i] and (st[ind][0] == st[i][0] || st[ind][1] == st[i][1])) dfs(st,visted,i);\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        n = stones.size();\\n        vector<bool>visted(n,false);\\n        int cnt = n;      // total stone\\n\\n        for(int i=0;i<n;i++){\\n            if(visted[i]) continue;\\n\\n            cnt--;               \\n            dfs(stones,visted,i);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    void dfs(vector<vector<int>>&st,vector<bool>&visted,int ind){\\n        visted[ind] = true;\\n        for(int i=0;i<n;i++){\\n            // not visited and one of the x or y match\\n            if(!visted[i] and (st[ind][0] == st[i][0] || st[ind][1] == st[i][1])) dfs(st,visted,i);\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        n = stones.size();\\n        vector<bool>visted(n,false);\\n        int cnt = n;      // total stone\\n\\n        for(int i=0;i<n;i++){\\n            if(visted[i]) continue;\\n\\n            cnt--;               \\n            dfs(stones,visted,i);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1872426,
                "title": "java-union-find-tc-o-n-2logn",
                "content": "\\n    class Solution {\\n     public int removeStones(int[][] stones) {\\n        int n=stones.length;\\n        int rank[]=new int[n];\\n        int parent[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            rank[i]=1;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(stones[i][0]==stones[j][0] || stones[i][1]==stones[j][1]){\\n                    union(i,j,parent,rank);\\n                }\\n            }\\n        }\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(parent[i]==i)c++;\\n        }\\n        return n-c;\\n    }\\n    public void union(int u,int v,int parent[],int rank[]){\\n        u=findPar(u,parent);\\n        v=findPar(v,parent);\\n        if(u!=v){\\n            if(rank[u]<rank[v]){\\n                parent[u]=v;\\n            }\\n            else if(rank[v]<rank[u]){\\n                parent[v]=u;\\n            }\\n            else{\\n                parent[u]=v;\\n                rank[u]++;\\n            }\\n        }\\n    }\\n    public int findPar(int node,int parent[]){\\n        if(node==parent[node]){\\n            return node;\\n        }\\n        return parent[node]=findPar(parent[node],parent);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph"
                ],
                "code": "class Solution {\\n     public int removeStones(int[][] stones) {\\n        int n=stones.length;\\n        int rank[]=new int[n];\\n        int parent[]=new int[n];\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            rank[i]=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1584937,
                "title": "c-simple-dsu-solution",
                "content": "```class Solution {\\npublic:\\n    int find(int a , vector<int> &par){//PATH COMPRESSIOMN\\n        if(par[a] < 0) return a ;\\n        return par[a] = find(par[a] , par) ;\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n      int n = stones.size() ;\\n      vector<int> par(n , -1) , ran(n , 1) ;\\n      for(int i = 0 ; i < n - 1 ; i++){\\n          for(int j = i + 1 ; j < n ; j++){\\n             //CHECKING IF THERE IS A CONNECTION BETWEEN TWO STONES (MEANS CHECKING THAT IF ANY ROW OR COLUMN MATCH BETWEEN TWO STONES) \\n             if((stones[i][0] == stones[j][0]) || (stones[i][1] == stones[j][1])){//(IF IT IS TRUE THEN WE APPLY DSU FOR CONNECT TWO STONES BY THEIR ID)\\n                 int a = find(i , par) ;\\n                 int b = find(j , par) ;\\n                 if(a == b) continue ;\\n                 else{\\n                     if(ran[a] < ran[b]) swap(a , b) ;//UNION BY RANK\\n                     par[b] = a ;\\n                     ran[a] += ran[b] ;\\n                 }\\n             }       \\n          } \\n       }\\n        int cnt = 0 ;\\n       for(int i = 0 ; i < n ; i++){\\n           if(par[i] == -1) cnt++ ;\\n       }\\n        return n - cnt ;//FINARY WE RETURN ANS(TOTAL NO OF STONES - NO OF CONNECTED COMPONENT)\\n    }\\n };```\\n",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```class Solution {\\npublic:\\n    int find(int a , vector<int> &par){//PATH COMPRESSIOMN\\n        if(par[a] < 0) return a ;\\n        return par[a] = find(par[a] , par) ;\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n      int n = stones.size() ;\\n      vector<int> par(n , -1) , ran(n , 1) ;\\n      for(int i = 0 ; i < n - 1 ; i++){\\n          for(int j = i + 1 ; j < n ; j++){\\n             //CHECKING IF THERE IS A CONNECTION BETWEEN TWO STONES (MEANS CHECKING THAT IF ANY ROW OR COLUMN MATCH BETWEEN TWO STONES) \\n             if((stones[i][0] == stones[j][0]) || (stones[i][1] == stones[j][1])){//(IF IT IS TRUE THEN WE APPLY DSU FOR CONNECT TWO STONES BY THEIR ID)\\n                 int a = find(i , par) ;\\n                 int b = find(j , par) ;\\n                 if(a == b) continue ;\\n                 else{\\n                     if(ran[a] < ran[b]) swap(a , b) ;//UNION BY RANK\\n                     par[b] = a ;\\n                     ran[a] += ran[b] ;\\n                 }\\n             }       \\n          } \\n       }\\n        int cnt = 0 ;\\n       for(int i = 0 ; i < n ; i++){\\n           if(par[i] == -1) cnt++ ;\\n       }\\n        return n - cnt ;//FINARY WE RETURN ANS(TOTAL NO OF STONES - NO OF CONNECTED COMPONENT)\\n    }\\n };```",
                "codeTag": "Java"
            },
            {
                "id": 1283145,
                "title": "cpp-connected-components-union-find-with-detail-explaination",
                "content": "for the rows and the columns, lets consider a parent array, where row numbers are from 0 to 9999 and column numbers are after that : from 10000 to 20000\\nThus, we connect the nodes with same column or row. \\n\\n1,0 points 2,0 are connected to each other because they have same column. and now a new point 1,2 comes into play, this point will also be remotely connected to 2,0 through 1,0. If we want to delete maximum number of points in this case : that will be by doing \\n2,0 then 1,2 (or 2,0 then 1,0 or 1,2 then 1,0 or 1,2 then 2,0) \\nthus the number of nodes in this connected component are = 3\\nand we delete 3-1 = 2 nodes  -> which is the maximum value of nodes that can be deleted.\\n\\nso the total number of nodes that can be deleted will be :\\n-> sum(number of nodes in each component - 1)\\n-> sum(number of nodes in each component) - number of components\\n-> number of total nodes - number of components\\n\\n\\n\\n```\\n// 947. Most Stones Removed with Same Row or Column\\nclass Solution {\\npublic:\\n    \\n    int finddsu(int x, vector<int>& parent){\\n        if(parent[x]!=x)\\n          parent[x]=finddsu(parent[x],parent);\\n        return parent[x];\\n    }\\n    void uniondsu(int a, int b, vector<int>& parent, vector<int>& rank){\\n        a = finddsu(a,parent);\\n        b = finddsu(b,parent);\\n        if(rank[a]<rank[b]){\\n            uniondsu(b,a,parent,rank);\\n            return;\\n        }\\n        if(rank[a]==rank[b]) rank[a]++;\\n        parent[b] = a;\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int res=0;\\n        int n = stones.size();\\n        vector<int> parent(20001,0);\\n        vector<int> rank(20001,0);\\n        for(int i=0; i<parent.size(); i++) parent[i] = i;\\n        for(auto s:stones) uniondsu(s[0],s[1]+10000,parent,rank);\\n        set<int> components;\\n        for(auto s:stones){\\n            int p = finddsu(s[0],parent);\\n            components.insert(p);\\n        }\\n        return n-components.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\n// 947. Most Stones Removed with Same Row or Column\\nclass Solution {\\npublic:\\n    \\n    int finddsu(int x, vector<int>& parent){\\n        if(parent[x]!=x)\\n          parent[x]=finddsu(parent[x],parent);\\n        return parent[x];\\n    }\\n    void uniondsu(int a, int b, vector<int>& parent, vector<int>& rank){\\n        a = finddsu(a,parent);\\n        b = finddsu(b,parent);\\n        if(rank[a]<rank[b]){\\n            uniondsu(b,a,parent,rank);\\n            return;\\n        }\\n        if(rank[a]==rank[b]) rank[a]++;\\n        parent[b] = a;\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int res=0;\\n        int n = stones.size();\\n        vector<int> parent(20001,0);\\n        vector<int> rank(20001,0);\\n        for(int i=0; i<parent.size(); i++) parent[i] = i;\\n        for(auto s:stones) uniondsu(s[0],s[1]+10000,parent,rank);\\n        set<int> components;\\n        for(auto s:stones){\\n            int p = finddsu(s[0],parent);\\n            components.insert(p);\\n        }\\n        return n-components.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089321,
                "title": "o-n-iterative-solution-using-stack-python",
                "content": "The problem is simplied as: how many disjoint-set are in the coordination\\nThere are several ways to solve this question and I\\'d like to share my simple iterative DFS(stack based) one.\\n\\nFirst of all, we can create groups using x and y coordination and store their index in dictionary\\nFor example, \\n```\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\n=====\\n1 0 1 \\n0 1 0 \\n1 0 1\\n=====\\n\\ngroupByX = {\\n  0: [0, 1],\\n  1: [2],\\n  2: [3, 4],\\n}\\n\\ngroupByY = {\\n  0: [0, 3],\\n  1: [2],\\n  2: [1, 4]\\n}\\n```\\n\\nThen start iterating `stones` from the index `0` and perform DFS search (BFS would also work) using Stack. Mark the index in `visted` to avoid duplicated process. You can find the neighbor index using  `groupByX` and `groupByY`.\\n\\nFinally, the answer is **total stones - the number of disjoint set**\\nAnd the complexity of this algorithm is **O(n)** in both Time and Space.\\n\\n```\\nfrom collections import defaultdict\\n        \\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        n = len(stones)\\n        groupByX = defaultdict(list)\\n        groupByY = defaultdict(list)\\n        \\n        for i in range(len(stones)):\\n            x, y = stones[i]\\n            groupByX[x].append(i)\\n            groupByY[y].append(i)\\n            \\n        \\n        disjointSet = 0\\n        visited = set()\\n        \\n        for i in range(len(stones)):\\n            if i in visited: continue\\n            stack = [i]\\n            disjointSet += 1\\n            \\n            while stack:\\n                current = stack.pop()\\n                visited.add(current)\\n                x, y = stones[current]\\n                \\n                for next_i in groupByX[x]:\\n                    if next_i in visited: continue\\n                    stack.append(next_i)\\n                    \\n                for next_i in groupByY[y]:\\n                    if next_i in visited: continue\\n                    stack.append(next_i)\\n                \\n        return n - disjointSet\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\n=====\\n1 0 1 \\n0 1 0 \\n1 0 1\\n=====\\n\\ngroupByX = {\\n  0: [0, 1],\\n  1: [2],\\n  2: [3, 4],\\n}\\n\\ngroupByY = {\\n  0: [0, 3],\\n  1: [2],\\n  2: [1, 4]\\n}\\n```\n```\\nfrom collections import defaultdict\\n        \\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        n = len(stones)\\n        groupByX = defaultdict(list)\\n        groupByY = defaultdict(list)\\n        \\n        for i in range(len(stones)):\\n            x, y = stones[i]\\n            groupByX[x].append(i)\\n            groupByY[y].append(i)\\n            \\n        \\n        disjointSet = 0\\n        visited = set()\\n        \\n        for i in range(len(stones)):\\n            if i in visited: continue\\n            stack = [i]\\n            disjointSet += 1\\n            \\n            while stack:\\n                current = stack.pop()\\n                visited.add(current)\\n                x, y = stones[current]\\n                \\n                for next_i in groupByX[x]:\\n                    if next_i in visited: continue\\n                    stack.append(next_i)\\n                    \\n                for next_i in groupByY[y]:\\n                    if next_i in visited: continue\\n                    stack.append(next_i)\\n                \\n        return n - disjointSet\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414826,
                "title": "clean-javascript-union-find-solution",
                "content": "```\\nconst removeStones = (stones) => {\\n  const parents = {};\\n  let n = 0;\\n\\n  const find = (u) => {\\n    if (parents[u] == null) {\\n      n++;\\n      parents[u] = u;\\n    }\\n    else if (parents[u] !== u) parents[u] = find(parents[u]); // path compression\\n    return parents[u];\\n  };\\n\\n  const union = (u, v) => {\\n    const p1 = find(u);\\n    const p2 = find(v);\\n    if (p1 !== p2) {\\n      parents[p1] = p2;\\n      n--;\\n    }\\n  };\\n\\n  for (const [u, v] of stones) {\\n    union(u, ~v);\\n  }\\n\\n  return stones.length - n;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nconst removeStones = (stones) => {\\n  const parents = {};\\n  let n = 0;\\n\\n  const find = (u) => {\\n    if (parents[u] == null) {\\n      n++;\\n      parents[u] = u;\\n    }\\n    else if (parents[u] !== u) parents[u] = find(parents[u]); // path compression\\n    return parents[u];\\n  };\\n\\n  const union = (u, v) => {\\n    const p1 = find(u);\\n    const p2 = find(v);\\n    if (p1 !== p2) {\\n      parents[p1] = p2;\\n      n--;\\n    }\\n  };\\n\\n  for (const [u, v] of stones) {\\n    union(u, ~v);\\n  }\\n\\n  return stones.length - n;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3034875,
                "title": "c-fast-and-intuitive-solution",
                "content": "# Intuition\\nCreate a graph and count total connected components.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate a graph by taking common x and y coordinates. then use DFS to traverse and count total number of connected components.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<unordered_set<int>> &gr, int s, vector<bool> &vis, int &ans)\\n    {\\n        if(vis[s]) return;\\n        vis[s] = true;\\n        ans++;\\n\\n        for(int e:gr[s])\\n        {\\n            if(!vis[e])\\n            {\\n                // cout<<s<<\" \"<<e<<endl;\\n                dfs(gr, e, vis, ans);\\n            }\\n        }\\n    }\\n\\n    int removeStones(vector<vector<int>>& stones) {\\n        int ans = 0;\\n        int n = stones.size();\\n        vector<bool> vis(n, false);\\n\\n        vector<unordered_set<int>> gr(n);\\n        unordered_map<int, unordered_set<int>> x, y;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            x[stones[i][0]].insert(i);\\n            y[stones[i][1]].insert(i);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            auto v = stones[i];\\n            for(int a:x[v[0]])\\n            if(a!=i)\\n            gr[i].insert(a);\\n\\n            for(int a:y[v[1]])\\n            if(a!=i)\\n            gr[i].insert(a);\\n        }\\n\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     cout<<i<<\" nodes \";\\n        //     for(auto a:gr[i]) cout<<a<<\" \";\\n        //     cout<<endl;\\n        // }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(gr, i, vis, ans);\\n                ans--;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<unordered_set<int>> &gr, int s, vector<bool> &vis, int &ans)\\n    {\\n        if(vis[s]) return;\\n        vis[s] = true;\\n        ans++;\\n\\n        for(int e:gr[s])\\n        {\\n            if(!vis[e])\\n            {\\n                // cout<<s<<\" \"<<e<<endl;\\n                dfs(gr, e, vis, ans);\\n            }\\n        }\\n    }\\n\\n    int removeStones(vector<vector<int>>& stones) {\\n        int ans = 0;\\n        int n = stones.size();\\n        vector<bool> vis(n, false);\\n\\n        vector<unordered_set<int>> gr(n);\\n        unordered_map<int, unordered_set<int>> x, y;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            x[stones[i][0]].insert(i);\\n            y[stones[i][1]].insert(i);\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            auto v = stones[i];\\n            for(int a:x[v[0]])\\n            if(a!=i)\\n            gr[i].insert(a);\\n\\n            for(int a:y[v[1]])\\n            if(a!=i)\\n            gr[i].insert(a);\\n        }\\n\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     cout<<i<<\" nodes \";\\n        //     for(auto a:gr[i]) cout<<a<<\" \";\\n        //     cout<<endl;\\n        // }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(gr, i, vis, ans);\\n                ans--;\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2815113,
                "title": "python3-easy-bfs-o-n-apply-bfs-on-each-components-explained",
                "content": "**Basically if we visited a point through a same row point then destroy its all connection from all other points exist in the same row ; do similarly for column \\nThis concept reduce the time complexity of the code from O(n^2) to O(n**) \\n\\n**if You like the solution :)  Upvote the solution !!** \\n**\\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        row_dict = defaultdict(list)\\n        col_dict = defaultdict(list)\\n        \\n        for a,b in stones:\\n            row_dict[a].append(b)\\n            col_dict[b].append(a)\\n        \\n        visited = set()\\n\\n        ans = 0\\n        que = deque()\\n        for a,b in stones:\\n            if (a,b) not in visited:\\n                #BFS start here for each connected component\\n                que.append((a,b))\\n                \\n                while que:\\n                    x,y = que.popleft()\\n                    if (x,y) in visited:\\n                        continue\\n                        \\n                    visited.add((x,y))\\n                    ans+=1\\n                    for e in row_dict[x]:  #append all points which are in same line as (x,y)\\n                        if e!=y:\\n                            que.append((x,e))\\n                                            \\n                    for e in col_dict[y]:  #append all points which are in same column as (x,y)\\n                        if e!=x:\\n                            que.append((e,y))\\n                            \\n                            \\n                    # here are two line which make code time complexity O(n^2) to O(n) :-\\n                    # if any point covers its entire row and column points, then again no need to cover these points again.\\n                    \\n                    row_dict[x].clear()\\n                    col_dict[y].clear()\\n                \\n                # each component can not destroy it self completely , there is only one point always exist , so\\n                ans -=1    \\n            \\n        return ans\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "**Basically if we visited a point through a same row point then destroy its all connection from all other points exist in the same row ; do similarly for column \\nThis concept reduce the time complexity of the code from O(n^2) to O(n**) \\n\\n**if You like the solution :)  Upvote the solution !!** \\n**\\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        row_dict = defaultdict(list)\\n        col_dict = defaultdict(list)\\n        \\n        for a,b in stones:\\n            row_dict[a].append(b)\\n            col_dict[b].append(a)\\n        \\n        visited = set()\\n\\n        ans = 0\\n        que = deque()\\n        for a,b in stones:\\n            if (a,b) not in visited:\\n                #BFS start here for each connected component\\n                que.append((a,b))\\n                \\n                while que:\\n                    x,y = que.popleft()\\n                    if (x,y) in visited:\\n                        continue\\n                        \\n                    visited.add((x,y))\\n                    ans+=1\\n                    for e in row_dict[x]:  #append all points which are in same line as (x,y)\\n                        if e!=y:\\n                            que.append((x,e))\\n                                            \\n                    for e in col_dict[y]:  #append all points which are in same column as (x,y)\\n                        if e!=x:\\n                            que.append((e,y))\\n                            \\n                            \\n                    # here are two line which make code time complexity O(n^2) to O(n) :-\\n                    # if any point covers its entire row and column points, then again no need to cover these points again.\\n                    \\n                    row_dict[x].clear()\\n                    col_dict[y].clear()\\n                \\n                # each component can not destroy it self completely , there is only one point always exist , so\\n                ans -=1    \\n            \\n        return ans\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2812724,
                "title": "beginnger-friendly-simple-dfs-c-clean",
                "content": "```\\n//YouTube Link : https://www.youtube.com/watch?v=ZsGTpXm966E\\nclass Solution {\\npublic:\\n    int n ;\\n    void dfs(vector<vector<int>>& stones, int index, vector<bool>& visited) {\\n        visited[index] = true;\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(!visited[i] &&\\n               ((stones[i][0] == stones[index][0]) || (stones[i][1] == stones[index][1]))) {\\n                dfs(stones, i, visited);\\n            }\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        n = stones.size();\\n        vector<bool> visited(n, false);\\n        \\n        int count = 0;\\n        for(int i = 0; i<n; i++) {\\n            if(visited[i])\\n                continue;\\n            dfs(stones, i, visited);\\n            count++;\\n        }\\n        \\n        return n - count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n//YouTube Link : https://www.youtube.com/watch?v=ZsGTpXm966E\\nclass Solution {\\npublic:\\n    int n ;\\n    void dfs(vector<vector<int>>& stones, int index, vector<bool>& visited) {\\n        visited[index] = true;\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(!visited[i] &&\\n               ((stones[i][0] == stones[index][0]) || (stones[i][1] == stones[index][1]))) {\\n                dfs(stones, i, visited);\\n            }\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        n = stones.size();\\n        vector<bool> visited(n, false);\\n        \\n        int count = 0;\\n        for(int i = 0; i<n; i++) {\\n            if(visited[i])\\n                continue;\\n            dfs(stones, i, visited);\\n            count++;\\n        }\\n        \\n        return n - count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488227,
                "title": "python-3-clean-union-find",
                "content": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        n = len(stones)\\n        rank = [1] * n\\n        parent = [i for i in range(n)]\\n        \\n        def union(i, j):\\n            i, j = find(i), find(j)\\n            if i == j:\\n                return 0\\n            if rank[i] < rank[j]:\\n                i, j = j, i\\n            rank[i] += rank[j]\\n            parent[j] = parent[i]\\n            return 1\\n        \\n        def find(i):\\n            while i != parent[i]:\\n                parent[i] = i = parent[parent[i]]\\n            return i\\n        \\n        rows, cols = {}, {}\\n        removed = 0\\n        for i, (row, col) in enumerate(stones):\\n            if row in rows:\\n                removed += union(i, rows[row])\\n            else:\\n                rows[row] = i\\n            if col in cols:\\n                removed += union(i, cols[col])\\n            else:\\n                cols[col] = i\\n        \\n        return removed",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "class Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        n = len(stones)\\n        rank = [1] * n\\n        parent = [i for i in range(n)]\\n        \\n        def union(i, j):\\n            i, j = find(i), find(j)\\n            if i == j:\\n                return 0\\n            if rank[i] < rank[j]:\\n                i, j = j, i\\n            rank[i] += rank[j]\\n            parent[j] = parent[i]\\n            return 1\\n        \\n        def find(i):\\n            while i != parent[i]:\\n                parent[i] = i = parent[parent[i]]\\n            return i\\n        \\n        rows, cols = {}",
                "codeTag": "Java"
            },
            {
                "id": 2442267,
                "title": "simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    \\n   void dfs(int i,vector<vector<int>>&stones,vector<int>&vis){\\n        \\n        vis[i]=1;\\n\\n        for(int j=0;j<stones.size();j++){\\n            if(!vis[j] && (stones[i][0]==stones[j][0] || stones[i][1]==stones[j][1])){\\n                ans++;\\n                dfs(j,stones,vis);\\n            }   \\n        }\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        vector<int>vis(stones.size());\\n        \\n        for(int i=0;i<stones.size();i++){\\n            if(!vis[i]){\\n                dfs(i,stones,vis);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    \\n   void dfs(int i,vector<vector<int>>&stones,vector<int>&vis){\\n        \\n        vis[i]=1;\\n\\n        for(int j=0;j<stones.size();j++){\\n            if(!vis[j] && (stones[i][0]==stones[j][0] || stones[i][1]==stones[j][1])){\\n                ans++;\\n                dfs(j,stones,vis);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2353095,
                "title": "very-easy-and-simple-to-understand-c-solution-two-approach",
                "content": "<b> UP Vote if you like the solution \\n# Approach 1: Create a Graph first and then evaluate no. of island - 700ms\\n```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        //create the graph \\n        vector<vector<int>> g(stones.size());\\n        for(int i = 0; i < stones.size(); ++i){\\n            for(int j = 0; j < stones.size(); ++j){\\n                if(i != j){\\n                    if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]){ g[i].push_back(j); }\\n                }\\n            }\\n        }\\n        \\n        //now traverse the graph to count number of disconnected components\\n        vector<int> vis(stones.size(), -1);\\n        queue<int> q;\\n        int count = 0;\\n        for(int i = 0; i< stones.size(); ++i){\\n            if(vis[i] == -1){\\n                q.push(i);\\n                vis[i] = 1;\\n                count++;\\n                while(!q.empty()){\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto j: g[node]){\\n                        if(vis[j] == -1){\\n                            vis[j] = 1;\\n                            q.push(j);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return stones.size() - count;\\n    }\\n};\\n```\\n\\n# Approach 2: No need to create graph, directly traverse  - 600 ms\\n```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        //now traverse the graph to count number of disconnected components\\n        vector<int> vis(stones.size(), -1);\\n        queue<int> q;\\n        int count = 0;\\n        for(int i = 0; i< stones.size(); ++i){\\n            if(vis[i] == -1){\\n                q.push(i);\\n                vis[i] = 1;\\n                count++;\\n                while(!q.empty()){\\n                    int node = q.front();\\n                    q.pop();\\n                    for(int j = 0; j < stones.size(); ++j){\\n                        if(stones[node][0] == stones[j][0] || stones[node][1]== stones[j][1]){\\n                            if(vis[j] == -1){\\n                                vis[j] = 1;\\n                                q.push(j);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return stones.size() - count;\\n    }\\n};\\n```\\n\\n# Approach 3: Optimisation of approach 2 by removing stones  - 250ms\\n```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        //Remove the nodes which are visited and keep on checking each node untill all nodes are removed\\n        int n = stones.size();\\n        queue<vector<int>> q;\\n        int count = 0;\\n        while(stones.size() > 0){\\n            q.push(stones.back());\\n            stones.pop_back();\\n            count++;\\n            while(!q.empty()){\\n                vector<int> node = q.front(); \\n                q.pop();\\n                int j = 0; \\n                while(j < stones.size()){\\n                    if(node[0] == stones[j][0] || node[1]== stones[j][1]){\\n                        q.push(stones[j]);\\n                        stones[j] = stones.back();\\n                        stones.pop_back();\\n                    }else j++;\\n                }\\n            }\\n        }\\n        return  n - count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        //create the graph \\n        vector<vector<int>> g(stones.size());\\n        for(int i = 0; i < stones.size(); ++i){\\n            for(int j = 0; j < stones.size(); ++j){\\n                if(i != j){\\n                    if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]){ g[i].push_back(j); }\\n                }\\n            }\\n        }\\n        \\n        //now traverse the graph to count number of disconnected components\\n        vector<int> vis(stones.size(), -1);\\n        queue<int> q;\\n        int count = 0;\\n        for(int i = 0; i< stones.size(); ++i){\\n            if(vis[i] == -1){\\n                q.push(i);\\n                vis[i] = 1;\\n                count++;\\n                while(!q.empty()){\\n                    int node = q.front();\\n                    q.pop();\\n                    for(auto j: g[node]){\\n                        if(vis[j] == -1){\\n                            vis[j] = 1;\\n                            q.push(j);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return stones.size() - count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        //now traverse the graph to count number of disconnected components\\n        vector<int> vis(stones.size(), -1);\\n        queue<int> q;\\n        int count = 0;\\n        for(int i = 0; i< stones.size(); ++i){\\n            if(vis[i] == -1){\\n                q.push(i);\\n                vis[i] = 1;\\n                count++;\\n                while(!q.empty()){\\n                    int node = q.front();\\n                    q.pop();\\n                    for(int j = 0; j < stones.size(); ++j){\\n                        if(stones[node][0] == stones[j][0] || stones[node][1]== stones[j][1]){\\n                            if(vis[j] == -1){\\n                                vis[j] = 1;\\n                                q.push(j);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return stones.size() - count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        //Remove the nodes which are visited and keep on checking each node untill all nodes are removed\\n        int n = stones.size();\\n        queue<vector<int>> q;\\n        int count = 0;\\n        while(stones.size() > 0){\\n            q.push(stones.back());\\n            stones.pop_back();\\n            count++;\\n            while(!q.empty()){\\n                vector<int> node = q.front(); \\n                q.pop();\\n                int j = 0; \\n                while(j < stones.size()){\\n                    if(node[0] == stones[j][0] || node[1]== stones[j][1]){\\n                        q.push(stones[j]);\\n                        stones[j] = stones.back();\\n                        stones.pop_back();\\n                    }else j++;\\n                }\\n            }\\n        }\\n        return  n - count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076584,
                "title": "c-using-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>adj[], vector<int>&v)\\n    {\\n        v[node]=1;\\n        for(auto it:adj[node])\\n        {\\n            if(!v[it])\\n               dfs(it,adj,v);\\n                \\n        }\\n    \\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        vector<int>adj[stones.size()];\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            \\n            for(int j=i+1;j<stones.size();j++)\\n            {\\n                if(stones[i][0]==stones[j][0] || stones[i][1]==stones[j][1])\\n                {\\n                    adj[i].push_back(j);\\n                adj[j].push_back(i);\\n                }\\n                \\n            }\\n            \\n        }\\n        vector<int>visit(stones.size(),0);\\n        int count=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            if(!visit[i])\\n            {\\n                dfs(i,adj,visit);\\n                count++;\\n                \\n            }\\n            \\n            \\n        }\\n        return stones.size()-count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>adj[], vector<int>&v)\\n    {\\n        v[node]=1;\\n        for(auto it:adj[node])\\n        {\\n            if(!v[it])\\n               dfs(it,adj,v);\\n                \\n        }\\n    \\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        vector<int>adj[stones.size()];\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            \\n            for(int j=i+1;j<stones.size();j++)\\n            {\\n                if(stones[i][0]==stones[j][0] || stones[i][1]==stones[j][1])\\n                {\\n                    adj[i].push_back(j);\\n                adj[j].push_back(i);\\n                }\\n                \\n            }\\n            \\n        }\\n        vector<int>visit(stones.size(),0);\\n        int count=0;\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            if(!visit[i])\\n            {\\n                dfs(i,adj,visit);\\n                count++;\\n                \\n            }\\n            \\n            \\n        }\\n        return stones.size()-count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015136,
                "title": "python-dfs-with-adjacency-matrix-with-good-explanation-of-problem-solution",
                "content": "## Summary:\\n**What is the problem?**\\nWe need to remove the maximum number of stones in a 2D grid (Matrix). We can only remove a stone if there is another stone either in the same row or same column.\\n\\nFor instance: If we remove a stone (0,0), there must be a stone (0, i) or (i, 0) in the matrix.\\nWe have to keep in mind that once we remove a stone from the grid, while evaluating other future coordinates we cannot consider the removed stone in the grid.\\n\\n**How to solve?**\\nConsider the grid as a collection of connected graphs. Each stone is a node, while the neighbor nodes would be the nodes in the same row or same column.\\n\\n* **Create an adjacency matrix:** For each stone, find the neighbors by looking for other stones in the same row or same column.\\n* **Do a DFS:** We do a dfs from any given stone, that has not been visited yet, and hence find all the connected stones in that graph. **This would simplify this problem into finding the number of islands.**\\n* **Reiterate on DFS until all stones are visited** The number of reiteration would give us the number of islands\\n* Return len(stones) - num_islands\\n\\n**Why do we calculate number of islands?**\\nAn island means all the stones are connected in the subgraph, which means we can remove all the stones in that sub-graph except 1. So the stones that we cannot remove in all the sub-graphs is equal to the island count. \\nHence the final number of stones removed:\\n`total_stones - stones_cannot_be_removed == len(stones) - number_of_islands `\\n\\n**Complexity:**\\nTime complexity:\\n* We did create an adjacency matrix and a DFS search. In DFS Search we read one node only once, hence O(N) where N is the number of nodes (stones), while creating the adjacency matrix would take max up to O(N^2).  \\n* Space Complexity: We occupy O(M.N) where M is the number of edges and N is the number of nodes(stones) in adjacency matrix. We also occupy O(N) for DFS stack. Therefore O(M.N) is the space complexity.\\n```\\ndef removeStones(self, stones):\\n        adj_list = defaultdict(list)\\n        # We create an adjacency list\\n        # Assume a stone (0,0) and then all the other stones (i1, j1), (i2, j2), etc. are either in the same row or same column\\n        # We create a connected graph from (0,0) to (i1, j1) and (i2, j2)\\n        # Consider the following input: [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\n        # Hence the adjacency matrix for input will look like\\n        # (0, 0): [(0, 1), (1, 0)], \\n        # (0, 1): [(0, 0), (2, 1)], \\n        # (1, 0): [(0, 0), (1, 2)], \\n        # (1, 2): [(1, 0), (2, 2)], \\n        # (2, 1): [(0, 1), (2, 2)], \\n        # (2, 2): [(1, 2), (2, 1)]\\n        \\n        for i, j in stones:\\n            for k,m in stones:\\n                # We do not want a mapping formed to the stone itself (like 0,0 -> 0,0) \\n                # hence the following check\\n                if i == k and j == m: \\n                    continue\\n                # if same row or same column add to mapping\\n                if i == k or j == m:\\n                    adj_list[(i,j)].append((k, m))\\n                    \\n        visited = []\\n        \\n        # Create a DFS traversal: Make sure the node is not retraversed, hence keeping `visited` list\\n        def dfs(i, j):\\n            visited.append((i, j))\\n            \\n            # Call DFS for all adjacent neighbors not being visited\\n            for k, m in adj_list[(i, j)]:\\n                if (k, m) not in visited:\\n                    dfs(k, m)\\n        \\n        island = 0\\n        # Find number of islands by calling dfs again and again on not visited nodes\\n        for i, j in stones:\\n            if (i, j) not in visited:\\n                dfs(i, j)\\n                island += 1\\n        # Since there will only be 1 stone not removed in a connected island       \\n        return len(stones) - island\\n```",
                "solutionTags": [],
                "code": "```\\ndef removeStones(self, stones):\\n        adj_list = defaultdict(list)\\n        # We create an adjacency list\\n        # Assume a stone (0,0) and then all the other stones (i1, j1), (i2, j2), etc. are either in the same row or same column\\n        # We create a connected graph from (0,0) to (i1, j1) and (i2, j2)\\n        # Consider the following input: [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\n        # Hence the adjacency matrix for input will look like\\n        # (0, 0): [(0, 1), (1, 0)], \\n        # (0, 1): [(0, 0), (2, 1)], \\n        # (1, 0): [(0, 0), (1, 2)], \\n        # (1, 2): [(1, 0), (2, 2)], \\n        # (2, 1): [(0, 1), (2, 2)], \\n        # (2, 2): [(1, 2), (2, 1)]\\n        \\n        for i, j in stones:\\n            for k,m in stones:\\n                # We do not want a mapping formed to the stone itself (like 0,0 -> 0,0) \\n                # hence the following check\\n                if i == k and j == m: \\n                    continue\\n                # if same row or same column add to mapping\\n                if i == k or j == m:\\n                    adj_list[(i,j)].append((k, m))\\n                    \\n        visited = []\\n        \\n        # Create a DFS traversal: Make sure the node is not retraversed, hence keeping `visited` list\\n        def dfs(i, j):\\n            visited.append((i, j))\\n            \\n            # Call DFS for all adjacent neighbors not being visited\\n            for k, m in adj_list[(i, j)]:\\n                if (k, m) not in visited:\\n                    dfs(k, m)\\n        \\n        island = 0\\n        # Find number of islands by calling dfs again and again on not visited nodes\\n        for i, j in stones:\\n            if (i, j) not in visited:\\n                dfs(i, j)\\n                island += 1\\n        # Since there will only be 1 stone not removed in a connected island       \\n        return len(stones) - island\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1984011,
                "title": "c-easy-dfs-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(int z, vector<vector<int>>& edges, vector<int>& visited){\\n        \\n        if(visited[z]) return 0;\\n        visited[z] = 1;\\n        int ret = 1;\\n        for(int i : edges[z]){\\n            ret += dfs(i,edges,visited);\\n        }\\n        return ret;\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        vector<int> visited(n,0);\\n        \\n        int ans = 0;\\n        \\n        vector<vector<int>> edges(n, vector<int>());\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]){\\n                    edges[i].push_back(j);\\n                    edges[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                int sz = dfs(i, edges, visited);\\n                ans += sz - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dfs(int z, vector<vector<int>>& edges, vector<int>& visited){\\n        \\n        if(visited[z]) return 0;\\n        visited[z] = 1;\\n        int ret = 1;\\n        for(int i : edges[z]){\\n            ret += dfs(i,edges,visited);\\n        }\\n        return ret;\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        vector<int> visited(n,0);\\n        \\n        int ans = 0;\\n        \\n        vector<vector<int>> edges(n, vector<int>());\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]){\\n                    edges[i].push_back(j);\\n                    edges[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                int sz = dfs(i, edges, visited);\\n                ans += sz - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900212,
                "title": "python-sol-well-explained-faster-than-97-approach-explained-dfs",
                "content": "\\n# SUCCESS\\nRuntime: 148 ms, faster than 97.26% of Python3 online submissions for Most Stones Removed with Same Row or Column.\\nMemory Usage: 16.4 MB, less than 18.86% of Python3 online submissions for Most Stones Removed with Same Row or Column\\n\\n# EXPLANATION\\n```\\nIf we start from a point(x,y) how many points are we going to remove ?\\nmay be from (x,y) we can remove (x,z) and from (x,z) we can remove (y,z) and from (y,z)\\nwe can remove (y,x) ........\\n\\nSo if a is removing b and b is removing c and c is removing d ... they are forming a group \\nspecifically an island .\\n\\nSo to get the island from (x,y) or having (x,y) we do DFS\\nNow let the size of island be 10\\nwhich means 9 of the stones can be removed \\n\\nUse dictionary as adjacent ( store all stones with row 1 , 2,  .... and all stones with col 1 ,2 ..... )\\n\\n\\n```\\n\\n# CODE\\n\\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        n = len(stones)\\n        visited = [False]*n\\n        rows = defaultdict(list)\\n        cols = defaultdict(list)\\n        ans = 0\\n        for i,point in enumerate(stones):\\n            rows[point[0]].append(i)\\n            cols[point[1]].append(i)\\n        \\n        def dfs(node):\\n            visited[node] = True\\n            count = 1\\n            for x in rows[stones[node][0]]:\\n                if visited[x] == False:\\n                    count += dfs(x)\\n            for x in cols[stones[node][1]]:\\n                if visited[x] == False:\\n                    count += dfs(x)\\n            return count\\n            \\n        for i in range(n):\\n            if visited[i] == False:\\n                size = dfs(i)\\n                ans += size-1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nIf we start from a point(x,y) how many points are we going to remove ?\\nmay be from (x,y) we can remove (x,z) and from (x,z) we can remove (y,z) and from (y,z)\\nwe can remove (y,x) ........\\n\\nSo if a is removing b and b is removing c and c is removing d ... they are forming a group \\nspecifically an island .\\n\\nSo to get the island from (x,y) or having (x,y) we do DFS\\nNow let the size of island be 10\\nwhich means 9 of the stones can be removed \\n\\nUse dictionary as adjacent ( store all stones with row 1 , 2,  .... and all stones with col 1 ,2 ..... )\\n\\n\\n```\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        n = len(stones)\\n        visited = [False]*n\\n        rows = defaultdict(list)\\n        cols = defaultdict(list)\\n        ans = 0\\n        for i,point in enumerate(stones):\\n            rows[point[0]].append(i)\\n            cols[point[1]].append(i)\\n        \\n        def dfs(node):\\n            visited[node] = True\\n            count = 1\\n            for x in rows[stones[node][0]]:\\n                if visited[x] == False:\\n                    count += dfs(x)\\n            for x in cols[stones[node][1]]:\\n                if visited[x] == False:\\n                    count += dfs(x)\\n            return count\\n            \\n        for i in range(n):\\n            if visited[i] == False:\\n                size = dfs(i)\\n                ans += size-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432071,
                "title": "javascript-dfs-with-explanation",
                "content": "Another way to see this problem is \\'what is the minimum number of stones we can have remaining?\\'. To solve this, one must first realise that for any number of stones in a set, as long as they are connected to one other stone in the set by row or by col, they can be removed till only one stone is remaining.\\n\\nHence we can find the number of remaining stones by finding the number of disjointed sets. From there, the maximum number of stones we can remove will be = total num of stones - remaining stones.\\n\\nIn my solution, first I get a mapping of all stones in each row and col. Then, for each new unvisited stone in the arr, do a dfs to mark all connected stones in the same row and same col as visited. In this way, every new unvisited stone in the arr will be a new disjoint set, hence we increment the remaining stones value by 1 when we reach a new unvisited stone.\\n\\n```\\nvar removeStones = function(stones) {\\n    const rows = new Map();\\n    const cols = new Map();\\n    for (const [r, c] of stones) {\\n        rows.set(r, (rows.get(r) || new Set()).add(c));\\n        cols.set(c, (cols.get(c) || new Set()).add(r));\\n    }\\n    \\n    const visited = new Set();\\n    const visit = (i, j) => {        \\n        const key = `${i}-${j}`;\\n        if (visited.has(key)) return;\\n        visited.add(key);\\n        const adjRow = rows.get(i);\\n        for (const col of adjRow) {\\n            visit(i, col);\\n        }\\n        const adjCol = cols.get(j);\\n        for (const row of adjCol) {\\n            visit(row, j);\\n        }\\n    }\\n    \\n    let remainingStones = 0;\\n    for (const [r, c] of stones) {\\n        const key = `${r}-${c}`;\\n        if (visited.has(key)) continue;        \\n        visit(r,c);\\n        remainingStones++;        \\n    }\\n    return stones.length - remainingStones;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar removeStones = function(stones) {\\n    const rows = new Map();\\n    const cols = new Map();\\n    for (const [r, c] of stones) {\\n        rows.set(r, (rows.get(r) || new Set()).add(c));\\n        cols.set(c, (cols.get(c) || new Set()).add(r));\\n    }\\n    \\n    const visited = new Set();\\n    const visit = (i, j) => {        \\n        const key = `${i}-${j}`;\\n        if (visited.has(key)) return;\\n        visited.add(key);\\n        const adjRow = rows.get(i);\\n        for (const col of adjRow) {\\n            visit(i, col);\\n        }\\n        const adjCol = cols.get(j);\\n        for (const row of adjCol) {\\n            visit(row, j);\\n        }\\n    }\\n    \\n    let remainingStones = 0;\\n    for (const [r, c] of stones) {\\n        const key = `${r}-${c}`;\\n        if (visited.has(key)) continue;        \\n        visit(r,c);\\n        remainingStones++;        \\n    }\\n    return stones.length - remainingStones;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351797,
                "title": "c-dfs-number-of-island",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, vector<vector<int>> &stones, vector<int> &vis){\\n        int j,u=stones[i][0], v=stones[i][1];\\n        vis[i]=1;\\n        for(j=0;j<stones.size();j++){\\n            if(vis[j]==0 && (stones[j][0]==u || stones[j][1]==v)){\\n                dfs(j,stones,vis);\\n            }\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int i,n=stones.size(),grp=0;\\n        vector<int> vis(n,0);\\n        for(i=0;i<n;i++){\\n            if(vis[i]==0){\\n                grp++;\\n                dfs(i,stones,vis);\\n            }\\n        }\\n        return n-grp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, vector<vector<int>> &stones, vector<int> &vis){\\n        int j,u=stones[i][0], v=stones[i][1];\\n        vis[i]=1;\\n        for(j=0;j<stones.size();j++){\\n            if(vis[j]==0 && (stones[j][0]==u || stones[j][1]==v)){\\n                dfs(j,stones,vis);\\n            }\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int i,n=stones.size(),grp=0;\\n        vector<int> vis(n,0);\\n        for(i=0;i<n;i++){\\n            if(vis[i]==0){\\n                grp++;\\n                dfs(i,stones,vis);\\n            }\\n        }\\n        return n-grp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314800,
                "title": "python-union-find-path-compression-o-n-reason-behind-using-this",
                "content": "\\nThis is a union find problem because if we remove a stone it is equivalent to \\nsaying that we\\'re merging it. Then the merges where the parent is not self, will be equal to\\nthe max number removed. This is because, the self parents signify they haven\\'t\\nbeen removed.\\n\\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        parent = [i for i in range(len(stones))]\\n        \\n        def find(x):\\n            if x == parent[x]:\\n                return x\\n            \\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        \\n        def union(x, y):\\n            parent_x = find(x)\\n            parent_y = find(y)\\n            \\n            if parent_x == parent_y:\\n                return\\n            \\n            if parent_x < parent_y:\\n                parent[parent_y] = parent_x\\n            else:\\n                parent[parent_x] = parent_y\\n                \\n            return\\n        \\n        def is_connected(stone1, stone2):\\n            if stone1[0] == stone2[0]:\\n                return True\\n            if stone1[1] == stone2[1]:\\n                return True\\n            return False\\n        \\n        for i, stone1 in enumerate(stones):\\n            for j, stone2 in enumerate(stones[i+1:], start=i+1):\\n                if is_connected(stone1, stone2):\\n                    union(i, j)\\n                    \\n        total_cnt = 0\\n        for i in range(len(parent)):\\n            if parent[i] != i:\\n                total_cnt += 1\\n        \"\"\"\\n        This is a union find problem because if we remove a stone it is equivalent to \\n        saying that we\\'re merging it. Then the merges where the parent is not self, will be equal to\\n        the max number removed. This is because, the self parents signify they haven\\'t\\n        been removed\\n        \"\"\"\\n        # print(stones)\\n        # print(parent)\\n        return total_cnt\\n",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "\\nThis is a union find problem because if we remove a stone it is equivalent to \\nsaying that we\\'re merging it. Then the merges where the parent is not self, will be equal to\\nthe max number removed. This is because, the self parents signify they haven\\'t\\nbeen removed.\\n\\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        parent = [i for i in range(len(stones))]\\n        \\n        def find(x):\\n            if x == parent[x]:\\n                return x\\n            \\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        \\n        def union(x, y):\\n            parent_x = find(x)\\n            parent_y = find(y)\\n            \\n            if parent_x == parent_y:\\n                return\\n            \\n            if parent_x < parent_y:\\n                parent[parent_y] = parent_x\\n            else:\\n                parent[parent_x] = parent_y\\n                \\n            return\\n        \\n        def is_connected(stone1, stone2):\\n            if stone1[0] == stone2[0]:\\n                return True\\n            if stone1[1] == stone2[1]:\\n                return True\\n            return False\\n        \\n        for i, stone1 in enumerate(stones):\\n            for j, stone2 in enumerate(stones[i+1:], start=i+1):\\n                if is_connected(stone1, stone2):\\n                    union(i, j)\\n                    \\n        total_cnt = 0\\n        for i in range(len(parent)):\\n            if parent[i] != i:\\n                total_cnt += 1\\n        \"\"\"\\n        This is a union find problem because if we remove a stone it is equivalent to \\n        saying that we\\'re merging it. Then the merges where the parent is not self, will be equal to\\n        the max number removed. This is because, the self parents signify they haven\\'t\\n        been removed\\n        \"\"\"\\n        # print(stones)\\n        # print(parent)\\n        return total_cnt\\n",
                "codeTag": "Java"
            },
            {
                "id": 1212796,
                "title": "simple-dfs-in-java",
                "content": "```\\nclass Solution {\\n    Map<Integer, List<int[]>> rowMap;\\n    Map<Integer, List<int[]>> colMap;\\n    int m = 0;\\n    int n = 0;\\n    \\n    private void init(int[][] stones) {\\n        \\n        // get dimensions\\n        for (int[] stone : stones) {\\n            m = Math.max(m, stone[0]);\\n            n = Math.max(n, stone[1]);\\n        }\\n\\n        rowMap = initMap(m);\\n        colMap = initMap(n);\\n    }\\n    \\n    public int removeStones(int[][] stones) {\\n        init(stones);\\n        \\n        for (int[] stone : stones) {\\n            rowMap.get(stone[0]).add(stone);\\n            colMap.get(stone[1]).add(stone);\\n        }\\n        \\n        Set<String> seen = new HashSet<>();\\n        int numGroups = 0;\\n        \\n        for (int[] stone : stones) {\\n            if (!seen.contains(buildString(stone[0], stone[1]))) {\\n                dfs(stones, stone, seen);\\n                numGroups++;\\n            }\\n        }\\n        \\n        return stones.length - numGroups;\\n    }\\n    \\n    private void dfs(int[][] stones, int[] curr, Set<String> seen) {\\n        if (seen.contains(buildString(curr[0], curr[1]))) return;\\n        \\n        seen.add(buildString(curr[0], curr[1]));\\n        \\n        for (int[] neighbor : rowMap.get(curr[0])) {\\n            dfs(stones, neighbor, seen);\\n        }\\n        \\n        for (int[] neighbor : colMap.get(curr[1])) {\\n            dfs(stones, neighbor, seen);\\n        }\\n        \\n        return;\\n    }\\n    \\n    private Map<Integer, List<int[]>> initMap(int size) {\\n        Map<Integer, List<int[]>> map = new HashMap<>();\\n        \\n        for (int i = 0; i <= size; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        \\n        return map;\\n    }\\n    \\n    private String buildString(int x, int y) {\\n        return x + \",\" + y;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer, List<int[]>> rowMap;\\n    Map<Integer, List<int[]>> colMap;\\n    int m = 0;\\n    int n = 0;\\n    \\n    private void init(int[][] stones) {\\n        \\n        // get dimensions\\n        for (int[] stone : stones) {\\n            m = Math.max(m, stone[0]);\\n            n = Math.max(n, stone[1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1141291,
                "title": "go-union-find-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n```\\nfunc removeStones(stones [][]int) int {\\n\\tn := len(stones)\\n\\tparent := make([]int, n)\\n\\tfor i:= 0; i < n; i++ {\\n\\t\\tparent[i] = i\\n\\t}\\n\\t\\n\\tfor i:= 0; i < n; i++ {\\n\\t\\tfor j := i+1; j < n; j++ {\\n\\t\\t\\ts1, s2 := stones[i], stones[j]\\n\\t\\t\\tif s1[0] == s2[0] || s1[1] == s2[1] {\\n\\t\\t\\t\\tpi, pj := find(parent, i), find(parent, j)\\n\\t\\t\\t\\tparent[pj] = pi\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tres := 0\\n\\tfor i := 0 ; i < n; i++ {\\n\\t\\tif parent[i] == i {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn n - res\\n }\\n \\n func find(parent []int, idx int) int {\\n \\ti := idx\\n \\tfor parent[i] != i {\\n \\t\\ti = parent[i]\\n\\t}\\n\\tparent[idx] = i\\n\\treturn i\\n }\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeStones(stones [][]int) int {\\n\\tn := len(stones)\\n\\tparent := make([]int, n)\\n\\tfor i:= 0; i < n; i++ {\\n\\t\\tparent[i] = i\\n\\t}\\n\\t\\n\\tfor i:= 0; i < n; i++ {\\n\\t\\tfor j := i+1; j < n; j++ {\\n\\t\\t\\ts1, s2 := stones[i], stones[j]\\n\\t\\t\\tif s1[0] == s2[0] || s1[1] == s2[1] {\\n\\t\\t\\t\\tpi, pj := find(parent, i), find(parent, j)\\n\\t\\t\\t\\tparent[pj] = pi\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\tres := 0\\n\\tfor i := 0 ; i < n; i++ {\\n\\t\\tif parent[i] == i {\\n\\t\\t\\tres++\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn n - res\\n }\\n \\n func find(parent []int, idx int) int {\\n \\ti := idx\\n \\tfor parent[i] != i {\\n \\t\\ti = parent[i]\\n\\t}\\n\\tparent[idx] = i\\n\\treturn i\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762169,
                "title": "c-union-find-beat-99-62",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> row;\\n    vector<int> col;\\n    vector<int> fa;\\npublic:\\n    int find(int x){\\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\\n    }\\n    void Union(int p, int q){\\n        int fp = find(p);\\n        int fq = find(q);\\n        if(fp != fq){\\n            fa[fp] = fq;\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int ans = 0;\\n        int n = stones.size();\\n        fa.resize(n);\\n        row.resize(10000,-1);\\n        col.resize(10000,-1);\\n        for(int i = 0; i < n; i++){\\n            int x = stones[i][0];\\n            int y = stones[i][1];\\n            fa[i] = i;\\n            if(row[x] != -1){\\n                Union(row[x],i);\\n            }\\n            if(col[y] != -1){\\n                Union(col[y],i);\\n            }\\n            row[x] = i;\\n            col[y] = i;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(i == find(i)){\\n                ans++;\\n            }\\n        }\\n        ans = n - ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> row;\\n    vector<int> col;\\n    vector<int> fa;\\npublic:\\n    int find(int x){\\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\\n    }\\n    void Union(int p, int q){\\n        int fp = find(p);\\n        int fq = find(q);\\n        if(fp != fq){\\n            fa[fp] = fq;\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int ans = 0;\\n        int n = stones.size();\\n        fa.resize(n);\\n        row.resize(10000,-1);\\n        col.resize(10000,-1);\\n        for(int i = 0; i < n; i++){\\n            int x = stones[i][0];\\n            int y = stones[i][1];\\n            fa[i] = i;\\n            if(row[x] != -1){\\n                Union(row[x],i);\\n            }\\n            if(col[y] != -1){\\n                Union(col[y],i);\\n            }\\n            row[x] = i;\\n            col[y] = i;\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(i == find(i)){\\n                ans++;\\n            }\\n        }\\n        ans = n - ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814956,
                "title": "c-dfs-graph-o-n-2-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> src,map<vector<int>,list<vector<int>>> &mp,map<vector<int>,bool> &visited)\\n    {\\n        visited[src]=true;\\n        \\n        for(vector<int> nbr: mp[src])\\n        {\\n            if(!visited[nbr])\\n            {\\n                dfs(nbr,mp,visited);\\n            }\\n        }\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        map<vector<int>,list<vector<int>>> mp;\\n        \\n        //create a graph with nodes in same rows or same columns connected to each other \\n        for(int i=0;i<stones.size();i++)\\n        {\\n            for(int j=i+1;j<stones.size();j++)\\n            {\\n                if(stones[i][0]==stones[j][0])\\n                {\\n                    mp[stones[i]].push_back(stones[j]);\\n                    mp[stones[j]].push_back(stones[i]);\\n                }\\n                else if(stones[i][1]==stones[j][1])\\n                {\\n                    mp[stones[i]].push_back(stones[j]);\\n                    mp[stones[j]].push_back(stones[i]);\\n                }\\n            }\\n        }\\n        \\n        map<vector<int>,bool> visited;\\n        \\n        //finding number of connected components in the graph\\n        int components=0;\\n        for(vector<int> v: stones)\\n        {\\n            if(!visited[v])\\n            {\\n                dfs(v,mp,visited);\\n                components++;\\n            }\\n        }\\n        \\n        return stones.size()-components;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<int> src,map<vector<int>,list<vector<int>>> &mp,map<vector<int>,bool> &visited)\\n    {\\n        visited[src]=true;\\n        \\n        for(vector<int> nbr: mp[src])\\n        {\\n            if(!visited[nbr])\\n            {\\n                dfs(nbr,mp,visited);\\n            }\\n        }\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        map<vector<int>,list<vector<int>>> mp;\\n        \\n        //create a graph with nodes in same rows or same columns connected to each other \\n        for(int i=0;i<stones.size();i++)\\n        {\\n            for(int j=i+1;j<stones.size();j++)\\n            {\\n                if(stones[i][0]==stones[j][0])\\n                {\\n                    mp[stones[i]].push_back(stones[j]);\\n                    mp[stones[j]].push_back(stones[i]);\\n                }\\n                else if(stones[i][1]==stones[j][1])\\n                {\\n                    mp[stones[i]].push_back(stones[j]);\\n                    mp[stones[j]].push_back(stones[i]);\\n                }\\n            }\\n        }\\n        \\n        map<vector<int>,bool> visited;\\n        \\n        //finding number of connected components in the graph\\n        int components=0;\\n        for(vector<int> v: stones)\\n        {\\n            if(!visited[v])\\n            {\\n                dfs(v,mp,visited);\\n                components++;\\n            }\\n        }\\n        \\n        return stones.size()-components;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814110,
                "title": "c-o-n-union-find-explained",
                "content": "This is DSU implementation\\n```\\nstruct DSU{\\n    //total elements and current total disjoint sets (components)\\n    int n, com;\\n    vector<int> rank, par;\\n    DSU(int n) : n(n), com(n){\\n        rank.resize(n, 1);\\n        par.resize(n);\\n        for(int i = 0; i < n; ++i) par[i] = i;\\n    }\\n    \\n    int find(int u){\\n        return u == par[u] ? u : par[u] = find(par[u]);\\n    }\\n    \\n    bool connect(int u, int v){\\n        u = find(u);\\n        v = find(v);\\n        if(u == v) return false;\\n        if(rank[u] > rank[v]){\\n            par[v] = u;\\n        } else if(rank[u] < rank[v]){\\n            par[u] = v;\\n        } else {\\n            par[u] = v;\\n            ++rank[v];\\n        }\\n        --com;\\n        return true;\\n    }\\n    \\n};\\n```\\nLet start the solution!\\n```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        \\n        // For each row, we store all Ys of points having the same Xs\\n        unordered_map<int, vector<int>> rows;\\n        \\n        // for compressing coordinate\\n        unordered_map<int, int> y_i;\\n        \\n        for(auto& coor : stones){\\n            // Pushing into vector\\n            rows[coor[0]].push_back(coor[1]);\\n            \\n            // Check if we have labeled the Y\\'s\\n            // We don\\'t need the correct order, we just need to assign distinct values for different Ys\\n            if(y_i.find(coor[1]) == y_i.end())\\n                y_i[coor[1]] = y_i.size();\\n        }\\n        \\n\\t\\t\\n\\t\\t\\n        // We init Disjoint set union\\n        // The elements in the set are the columns\\n        DSU dsu(y_i.size());\\n        \\n        // Iterating all row\\n        for(auto& [row, ys] : rows){\\n            //we connect all the point\\n            \\n            //presentative elements\\n            int elem = y_i[ys[0]];\\n            for(auto& y : ys){\\n                // We connect all columns have stored Ys on that row\\n                dsu.connect(elem, y_i[y]);\\n            }\\n        }\\n        \\n        // Eventually, we have the total disjoint set is the total element we cannot merge (number of stones we cannot remove)\\n        // So we can find the number of removed stones by take n - the number of stones left.        \\n        return n - dsu.com;\\n        \\n    }\\n};\\n```\\n\\nWe note that we only iterate though all the point in constant time.\\nAnd due to the operations of unordered map, the time complexity of this solution is **O(N)**\\n\\nWithout loss of generality, the solution is still correct when we swap all columns and rows.\\n\\nI hope this post can help you explore more ways of thinking.\\nPlease upvote if this helps.\\n\\nI will update the figures for visualization soon.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nstruct DSU{\\n    //total elements and current total disjoint sets (components)\\n    int n, com;\\n    vector<int> rank, par;\\n    DSU(int n) : n(n), com(n){\\n        rank.resize(n, 1);\\n        par.resize(n);\\n        for(int i = 0; i < n; ++i) par[i] = i;\\n    }\\n    \\n    int find(int u){\\n        return u == par[u] ? u : par[u] = find(par[u]);\\n    }\\n    \\n    bool connect(int u, int v){\\n        u = find(u);\\n        v = find(v);\\n        if(u == v) return false;\\n        if(rank[u] > rank[v]){\\n            par[v] = u;\\n        } else if(rank[u] < rank[v]){\\n            par[u] = v;\\n        } else {\\n            par[u] = v;\\n            ++rank[v];\\n        }\\n        --com;\\n        return true;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        \\n        // For each row, we store all Ys of points having the same Xs\\n        unordered_map<int, vector<int>> rows;\\n        \\n        // for compressing coordinate\\n        unordered_map<int, int> y_i;\\n        \\n        for(auto& coor : stones){\\n            // Pushing into vector\\n            rows[coor[0]].push_back(coor[1]);\\n            \\n            // Check if we have labeled the Y\\'s\\n            // We don\\'t need the correct order, we just need to assign distinct values for different Ys\\n            if(y_i.find(coor[1]) == y_i.end())\\n                y_i[coor[1]] = y_i.size();\\n        }\\n        \\n\\t\\t\\n\\t\\t\\n        // We init Disjoint set union\\n        // The elements in the set are the columns\\n        DSU dsu(y_i.size());\\n        \\n        // Iterating all row\\n        for(auto& [row, ys] : rows){\\n            //we connect all the point\\n            \\n            //presentative elements\\n            int elem = y_i[ys[0]];\\n            for(auto& y : ys){\\n                // We connect all columns have stored Ys on that row\\n                dsu.connect(elem, y_i[y]);\\n            }\\n        }\\n        \\n        // Eventually, we have the total disjoint set is the total element we cannot merge (number of stones we cannot remove)\\n        // So we can find the number of removed stones by take n - the number of stones left.        \\n        return n - dsu.com;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814044,
                "title": "easy-to-understand-dfs-solution",
                "content": "Intuition and Approach :\\n    We can observe that stones which have same row or column are part of \\n    a graph and most optimum answer for each connected component of graph \\n    would be Total number of stones - 1 (the stone which will be our starting one) ;\\n    ans = summation of (Total stones - 1) ;\\n    ans = total number of islands - total number of CC \\n    ans = n - cc_count  . \\n\\tEach vertex of graph will be stone not index , note that \\n\\twe will just use indexes to connect stones with each other .\\n    Now our main work would be to build the graph and run dfs or use union find\\n    just to calculate total connected components .\\n\\t\\n\\t`// Implementation : \\n    void dfs(int src , vector<int>graph[] , vector<int>&vis){\\n        vis[src] = true ;\\n        \\n        for(auto &it : graph[src]){\\n            if(!vis[it]){\\n                dfs(it,graph,vis) ;\\n            }\\n        }\\n        \\n    } \\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n           int n = stones.size() ;\\n           \\n           vector<int> graph[n] ;   \\n           vector<int> vis(n,0) ;\\n        \\n        for(int i=0 ; i<n ; ++i){\\n            for(int j=i+1 ; j<n ; ++j){\\n                if(stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]){\\n                    graph[i].push_back(j) ;\\n                    graph[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        \\n        int cc = 0 ;\\n        for(int i=0 ; i<n ; ++i){\\n            if(!vis[i]){\\n                dfs(i,graph,vis) ;\\n                cc++;\\n            }\\n        }\\n        \\n        return (n - cc) ;\\n        \\n    }`",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "Intuition and Approach :\\n    We can observe that stones which have same row or column are part of \\n    a graph and most optimum answer for each connected component of graph \\n    would be Total number of stones - 1 (the stone which will be our starting one) ;\\n    ans = summation of (Total stones - 1) ;\\n    ans = total number of islands - total number of CC \\n    ans = n - cc_count  . \\n\\tEach vertex of graph will be stone not index , note that \\n\\twe will just use indexes to connect stones with each other .\\n    Now our main work would be to build the graph and run dfs or use union find\\n    just to calculate total connected components .\\n\\t\\n\\t`// Implementation : \\n    void dfs(int src , vector<int>graph[] , vector<int>&vis){\\n        vis[src] = true ;\\n        \\n        for(auto &it : graph[src]){\\n            if(!vis[it]){\\n                dfs(it,graph,vis) ;\\n            }\\n        }\\n        \\n    } \\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n           int n = stones.size() ;\\n           \\n           vector<int> graph[n] ;   \\n           vector<int> vis(n,0) ;\\n        \\n        for(int i=0 ; i<n ; ++i){\\n            for(int j=i+1 ; j<n ; ++j){\\n                if(stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]){\\n                    graph[i].push_back(j) ;\\n                    graph[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        \\n        int cc = 0 ;\\n        for(int i=0 ; i<n ; ++i){\\n            if(!vis[i]){\\n                dfs(i,graph,vis) ;\\n                cc++;\\n            }\\n        }\\n        \\n        return (n - cc) ;\\n        \\n    }`",
                "codeTag": "Unknown"
            },
            {
                "id": 2814024,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        Set<int[]> visited=new HashSet<>();\\n        int connectedStones = 0;\\n        for(int[] currentStones: stones) {\\n          if(!visited.contains(currentStones)) {\\n              dfs(currentStones, visited, stones);\\n              connectedStones++;\\n          }\\n        }\\n        return stones.length - connectedStones;   \\n    }\\n    \\n    private void dfs(int[] currentStones, Set<int[]> visited, int[][] stones) {\\n        visited.add(currentStones);\\n        for(int[] stoneArray: stones) {\\n            if(!visited.contains(stoneArray)) {\\n                if(currentStones[0] == stoneArray[0] || currentStones[1] == stoneArray[1]) {\\n                    dfs(stoneArray, visited, stones);  \\n                }\\n            }\\n        }\\n    }      \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        Set<int[]> visited=new HashSet<>();\\n        int connectedStones = 0;\\n        for(int[] currentStones: stones) {\\n          if(!visited.contains(currentStones)) {\\n              dfs(currentStones, visited, stones);\\n              connectedStones++;\\n          }\\n        }\\n        return stones.length - connectedStones;   \\n    }\\n    \\n    private void dfs(int[] currentStones, Set<int[]> visited, int[][] stones) {\\n        visited.add(currentStones);\\n        for(int[] stoneArray: stones) {\\n            if(!visited.contains(stoneArray)) {\\n                if(currentStones[0] == stoneArray[0] || currentStones[1] == stoneArray[1]) {\\n                    dfs(stoneArray, visited, stones);  \\n                }\\n            }\\n        }\\n    }      \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813784,
                "title": "cpp-graph-based-approach",
                "content": "\\n# Code with approach in comment\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> adj[], vector<int> &vis){\\n        vis[node]=1;\\n        for(auto &e:adj[node]){\\n            if(!vis[e]) dfs(e,adj,vis);\\n        }\\n    }\\n\\n    int removeStones(vector<vector<int>>& v) {\\n\\n        //my approach : make graph connecting points having same row or column\\n        //if count= no of components , then \\'count\\' points will be left\\n        //so ans = total - count ie n-count here\\n\\n        int n=v.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(v[i][0]==v[j][0] || v[i][1]==v[j][1]){\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n\\n        int count=0;\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                dfs(i,adj,vis);\\n                count++;\\n            }\\n        }\\n\\n        return n-count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> adj[], vector<int> &vis){\\n        vis[node]=1;\\n        for(auto &e:adj[node]){\\n            if(!vis[e]) dfs(e,adj,vis);\\n        }\\n    }\\n\\n    int removeStones(vector<vector<int>>& v) {\\n\\n        //my approach : make graph connecting points having same row or column\\n        //if count= no of components , then \\'count\\' points will be left\\n        //so ans = total - count ie n-count here\\n\\n        int n=v.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(v[i][0]==v[j][0] || v[i][1]==v[j][1]){\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n\\n        int count=0;\\n        vector<int> vis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                dfs(i,adj,vis);\\n                count++;\\n            }\\n        }\\n\\n        return n-count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813647,
                "title": "single-dfs-number-of-islands-easy-readable",
                "content": "``` \\n     int n;\\n    vector<int>adj[1001];\\n    int vis[1001];\\n   void dfs(int x)\\n   {\\n       if(vis[x]){return;}\\n       vis[x]=1;\\n           for(int k:adj[x])\\n           {\\n               if(!vis[k])\\n               {\\n                   dfs(k);\\n               }\\n           }\\n   }\\n    int removeStones(vector<vector<int>>& s) \\n    {\\n        n=s.size();\\n        int ans=0;\\n      for(int i=0;i<n;i++)\\n      {\\n          int x=s[i][0]; int y=s[i][1];\\n         for(int j=i+1;j<n;j++)\\n         {\\n            int nx=s[j][0]; int ny=s[j][1];\\n            if(nx==x || ny==y)\\n            {\\n                adj[i].push_back(j);\\n                adj[j].push_back(i);\\n            }\\n         }\\n      }\\n       for(int i=0;i<n;i++)\\n       {\\n           if(!vis[i])\\n           {\\n               ans++;\\n               dfs(i);\\n           }\\n       }\\n        return n-ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "``` \\n     int n;\\n    vector<int>adj[1001];\\n    int vis[1001];\\n   void dfs(int x)\\n   {\\n       if(vis[x]){return;}\\n       vis[x]=1;\\n           for(int k:adj[x])\\n           {\\n               if(!vis[k])\\n               {\\n                   dfs(k);\\n               }\\n           }\\n   }\\n    int removeStones(vector<vector<int>>& s) \\n    {\\n        n=s.size();\\n        int ans=0;\\n      for(int i=0;i<n;i++)\\n      {\\n          int x=s[i][0]; int y=s[i][1];\\n         for(int j=i+1;j<n;j++)\\n         {\\n            int nx=s[j][0]; int ny=s[j][1];\\n            if(nx==x || ny==y)\\n            {\\n                adj[i].push_back(j);\\n                adj[j].push_back(i);\\n            }\\n         }\\n      }\\n       for(int i=0;i<n;i++)\\n       {\\n           if(!vis[i])\\n           {\\n               ans++;\\n               dfs(i);\\n           }\\n       }\\n        return n-ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2813376,
                "title": "simple-dfs-solution-in-python",
                "content": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        \\n        dx = defaultdict(set)\\n        dy = defaultdict(set)\\n        \\n        for x,y in stones:\\n            dx[x].add((x, y))\\n            dy[y].add((x, y))\\n            \\n        visited = set()\\n        \\n        def dfs(x, y):\\n            visited.add((x, y))\\n            child = (dx[x].union(dy[y]) - visited)\\n            for p, q in child:\\n                dfs(p, q)\\n        \\n        cc = 0\\n        for x,y in stones:\\n            if(not (x,y) in visited):\\n                dfs(x, y)\\n                cc+=1\\n        \\n        return len(stones)-cc\\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        \\n        dx = defaultdict(set)\\n        dy = defaultdict(set)\\n        \\n        for x,y in stones:\\n            dx[x].add((x, y))\\n            dy[y].add((x, y))\\n            \\n        visited = set()\\n        \\n        def dfs(x, y):\\n            visited.add((x, y))\\n            child = (dx[x].union(dy[y]) - visited)\\n            for p, q in child:\\n                dfs(p, q)\\n        \\n        cc = 0\\n        for x,y in stones:\\n            if(not (x,y) in visited):\\n                dfs(x, y)\\n                cc+=1\\n        \\n        return len(stones)-cc\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812406,
                "title": "daily-leetcoding-challenge-november-day-14",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2425038,
                "title": "java-very-easy-union-find-dfs-count-islands",
                "content": "**Approach1: DFS**\\n\\n```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        List<Integer>[] graph = new ArrayList[stones.length];\\n        for (int i = 0; i < stones.length; i++)\\n            for (int j = i + 1; j < stones.length; j++) {\\n                int[] stone1 = stones[i];\\n                int[] stone2 = stones[j];\\n                if (stone1[0] == stone2[0] || stone1[1] == stone2[1]) {\\n                    if (graph[i] == null) graph[i] = new ArrayList<>();\\n                    if (graph[j] == null) graph[j] = new ArrayList<>();\\n                    graph[i].add(j);\\n                    graph[j].add(i);\\n                }\\n            }\\n\\n        int islands = 0;\\n        boolean[] visited = new boolean[stones.length];\\n        for (int i = 0; i < stones.length; i++) {\\n            islands += dfs(i, graph, visited);\\n        }\\n        return stones.length - islands;\\n    }\\n\\n    private int dfs(int i, List<Integer>[] graph, boolean[] visited) {\\n        if (visited[i]) return 0;\\n        visited[i] = true;\\n        if (graph[i] != null) {\\n            for (int n : graph[i])\\n                dfs(n, graph, visited);\\n        }\\n        return 1;\\n    }\\n}\\n```\\n\\n\\n**Approach2: Union Find**\\n\\n```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        int islands = stones.length;\\n        UnionFind unionFind = new UnionFind(stones.length);\\n        for (int i = 0; i < stones.length; i++) {\\n            for (int j = i + 1; j < stones.length; j++) {\\n                int[] stone1 = stones[i];\\n                int[] stone2 = stones[j];\\n                if (stone1[0] == stone2[0] || stone1[1] == stone2[1]) {\\n                    if (unionFind.union(i, j)) islands--;\\n                }\\n            }\\n        }\\n        return stones.length - islands;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parent;\\n    int[] rank;\\n\\n    public UnionFind(int size) {\\n        parent = new int[size];\\n        rank = new int[size];\\n        for (int i = 0; i < size; i++)\\n            parent[i] = i;\\n    }\\n\\n    private int find(int node) {\\n        if (parent[node] != node) parent[node] = find(parent[node]);\\n        return parent[node];\\n    }\\n\\n    public boolean union(int node1, int node2) {\\n        int node1Parent = find(node1);\\n        int node2Parent = find(node2);\\n        if (node1Parent == node2Parent) return false;\\n        if (rank[node1Parent] > rank[node2Parent]) parent[node2Parent] = node1Parent;\\n        else if (rank[node1Parent] < rank[node2Parent]) parent[node1Parent] = node2Parent;\\n        else {\\n            parent[node2Parent] = node1Parent;\\n            rank[node1Parent] += 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        List<Integer>[] graph = new ArrayList[stones.length];\\n        for (int i = 0; i < stones.length; i++)\\n            for (int j = i + 1; j < stones.length; j++) {\\n                int[] stone1 = stones[i];\\n                int[] stone2 = stones[j];\\n                if (stone1[0] == stone2[0] || stone1[1] == stone2[1]) {\\n                    if (graph[i] == null) graph[i] = new ArrayList<>();\\n                    if (graph[j] == null) graph[j] = new ArrayList<>();\\n                    graph[i].add(j);\\n                    graph[j].add(i);\\n                }\\n            }\\n\\n        int islands = 0;\\n        boolean[] visited = new boolean[stones.length];\\n        for (int i = 0; i < stones.length; i++) {\\n            islands += dfs(i, graph, visited);\\n        }\\n        return stones.length - islands;\\n    }\\n\\n    private int dfs(int i, List<Integer>[] graph, boolean[] visited) {\\n        if (visited[i]) return 0;\\n        visited[i] = true;\\n        if (graph[i] != null) {\\n            for (int n : graph[i])\\n                dfs(n, graph, visited);\\n        }\\n        return 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        int islands = stones.length;\\n        UnionFind unionFind = new UnionFind(stones.length);\\n        for (int i = 0; i < stones.length; i++) {\\n            for (int j = i + 1; j < stones.length; j++) {\\n                int[] stone1 = stones[i];\\n                int[] stone2 = stones[j];\\n                if (stone1[0] == stone2[0] || stone1[1] == stone2[1]) {\\n                    if (unionFind.union(i, j)) islands--;\\n                }\\n            }\\n        }\\n        return stones.length - islands;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parent;\\n    int[] rank;\\n\\n    public UnionFind(int size) {\\n        parent = new int[size];\\n        rank = new int[size];\\n        for (int i = 0; i < size; i++)\\n            parent[i] = i;\\n    }\\n\\n    private int find(int node) {\\n        if (parent[node] != node) parent[node] = find(parent[node]);\\n        return parent[node];\\n    }\\n\\n    public boolean union(int node1, int node2) {\\n        int node1Parent = find(node1);\\n        int node2Parent = find(node2);\\n        if (node1Parent == node2Parent) return false;\\n        if (rank[node1Parent] > rank[node2Parent]) parent[node2Parent] = node1Parent;\\n        else if (rank[node1Parent] < rank[node2Parent]) parent[node1Parent] = node2Parent;\\n        else {\\n            parent[node2Parent] = node1Parent;\\n            rank[node1Parent] += 1;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164087,
                "title": "c-easy-to-understand-dsu-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int node,vector<int> &parent)\\n    {\\n        if(node==parent[node])\\n        return node;\\n        return parent[node]=find(parent[node],parent);\\n    }\\n    void Union(int x,int y,vector<int> &parent,vector<int> &rank)\\n    {\\n        x=find(x,parent);\\n        y=find(y,parent);\\n        if(x==y)\\n        return;\\n        if(rank[x]<rank[y])\\n        {\\n            parent[x]=y;\\n        }\\n        else if(rank[y]<rank[x])\\n        {\\n            parent[y]=x;\\n        }\\n        else\\n        {\\n            parent[y]=x;\\n            rank[x]++;\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n=stones.size();\\n        vector<int> parent(n),rank(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(stones[i][0]==stones[j][0]||stones[i][1]==stones[j][1])\\n                {\\n                    int x=find(i,parent);\\n                    int y=find(j,parent);\\n                    if(x!=y)\\n                    Union(x,y,parent,rank);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<find(i,parent)<<endl;\\n        }\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[parent[i]]++;\\n        }\\n        return n-mp.size();\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int node,vector<int> &parent)\\n    {\\n        if(node==parent[node])\\n        return node;\\n        return parent[node]=find(parent[node],parent);\\n    }\\n    void Union(int x,int y,vector<int> &parent,vector<int> &rank)\\n    {\\n        x=find(x,parent);\\n        y=find(y,parent);\\n        if(x==y)\\n        return;\\n        if(rank[x]<rank[y])\\n        {\\n            parent[x]=y;\\n        }\\n        else if(rank[y]<rank[x])\\n        {\\n            parent[y]=x;\\n        }\\n        else\\n        {\\n            parent[y]=x;\\n            rank[x]++;\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n=stones.size();\\n        vector<int> parent(n),rank(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                if(stones[i][0]==stones[j][0]||stones[i][1]==stones[j][1])\\n                {\\n                    int x=find(i,parent);\\n                    int y=find(j,parent);\\n                    if(x!=y)\\n                    Union(x,y,parent,rank);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            cout<<find(i,parent)<<endl;\\n        }\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[parent[i]]++;\\n        }\\n        return n-mp.size();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2108084,
                "title": "c-union-find-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/\\n    \\n    TC: O(n^2 * logn), n^2 for creating the graph and each Union Find op takes O(logn)\\n    SC: O(n)\\n    \\n    If you plot the coordinates on a graph, it is pretty clear that in order to remove most\\n    no. of stones, we need first find the stones which are on the same row or col on the graph.\\n    For two stones, if they share either a col or row, it will make an edge. This way we create \\n    the graph with all the edges.\\n    Then for a connected component, we can remove all the nodes except for one and that will be\\n    the answer for that component.\\n*/\\nclass Solution {\\nprivate:\\n    \\n    class Unionfind {\\n    public:\\n        vector<int> root, size;\\n        \\n        Unionfind(int n) {\\n            root.resize(n);\\n            for(int i = 0; i < n; i++)\\n                root[i] = i;\\n            \\n            size.resize(n, 1);\\n        }\\n        \\n        int getRoot(int a) {\\n            while(a != root[a]) {\\n                root[a] = root[root[a]];\\n                a = root[a];\\n            }\\n            return a;\\n        }\\n        \\n        bool find(int a, int b) {\\n            return getRoot(a) == getRoot(b);\\n        }\\n        \\n        void Union(int a, int b) {\\n            int root_a = getRoot(a);\\n            int root_b = getRoot(b);\\n            \\n            if(root_a != root_b) {\\n                if(size[root_a] > size[root_a]) {\\n                    size[root_a] += size[root_b];\\n                    root[root_b] = root_a;\\n                }\\n                else {\\n                    size[root_b] += size[root_a];\\n                    root[root_a] = root_b;\\n                }\\n            }\\n        }\\n    };\\n    \\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        Unionfind uf(stones.size());\\n        \\n        // create the graph\\n        for(int src = 0; src < stones.size(); src++)\\n            for(int dst = src + 1; dst < stones.size(); dst++) \\n                // If any of the points have a common row or col, they can form an edge\\n                if(stones[src][0] == stones[dst][0] || stones[src][1] == stones[dst][1]) {\\n                    uf.Union(src, dst);\\n                }\\n        \\n        int removable = 0;\\n        // For all the connected components, all except one node can be removed from them\\n        for(int i = 0; i < uf.root.size(); i++)\\n            // For the current component, leave 1 node and remove rest\\n            if(uf.root[i] == i)\\n                removable += uf.size[i] - 1;\\n        return removable;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/\\n    \\n    TC: O(n^2 * logn), n^2 for creating the graph and each Union Find op takes O(logn)\\n    SC: O(n)\\n    \\n    If you plot the coordinates on a graph, it is pretty clear that in order to remove most\\n    no. of stones, we need first find the stones which are on the same row or col on the graph.\\n    For two stones, if they share either a col or row, it will make an edge. This way we create \\n    the graph with all the edges.\\n    Then for a connected component, we can remove all the nodes except for one and that will be\\n    the answer for that component.\\n*/\\nclass Solution {\\nprivate:\\n    \\n    class Unionfind {\\n    public:\\n        vector<int> root, size;\\n        \\n        Unionfind(int n) {\\n            root.resize(n);\\n            for(int i = 0; i < n; i++)\\n                root[i] = i;\\n            \\n            size.resize(n, 1);\\n        }\\n        \\n        int getRoot(int a) {\\n            while(a != root[a]) {\\n                root[a] = root[root[a]];\\n                a = root[a];\\n            }\\n            return a;\\n        }\\n        \\n        bool find(int a, int b) {\\n            return getRoot(a) == getRoot(b);\\n        }\\n        \\n        void Union(int a, int b) {\\n            int root_a = getRoot(a);\\n            int root_b = getRoot(b);\\n            \\n            if(root_a != root_b) {\\n                if(size[root_a] > size[root_a]) {\\n                    size[root_a] += size[root_b];\\n                    root[root_b] = root_a;\\n                }\\n                else {\\n                    size[root_b] += size[root_a];\\n                    root[root_a] = root_b;\\n                }\\n            }\\n        }\\n    };\\n    \\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        Unionfind uf(stones.size());\\n        \\n        // create the graph\\n        for(int src = 0; src < stones.size(); src++)\\n            for(int dst = src + 1; dst < stones.size(); dst++) \\n                // If any of the points have a common row or col, they can form an edge\\n                if(stones[src][0] == stones[dst][0] || stones[src][1] == stones[dst][1]) {\\n                    uf.Union(src, dst);\\n                }\\n        \\n        int removable = 0;\\n        // For all the connected components, all except one node can be removed from them\\n        for(int i = 0; i < uf.root.size(); i++)\\n            // For the current component, leave 1 node and remove rest\\n            if(uf.root[i] == i)\\n                removable += uf.size[i] - 1;\\n        return removable;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935861,
                "title": "c-explained-code-union-find",
                "content": "**Please do upvote if you liked my efforts :)**\\n\\n```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) \\n    {\\n        int ans = 0;\\n        par.resize(1001);\\n        for(int i=0; i<stones.size(); i++)\\n            par[i] = i;\\n        \\n        for(int i=0; i<stones.size()-1; i++)\\n        {\\n            for(int j=i+1; j<stones.size(); j++)\\n                if(stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1])  // If x or y coordinate of two stones coincide\\n                {\\n                    if(!uniun(i, j)) ++ans;   // We only increment the counter, when the two stones haven\\'t been unioned before\\n                }                             // Once a stone is unioned before, that means that particular stone has been removed and hence cannot be used again\\n        }\\n        \\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<int> par;\\n    \\n    int find(int x)\\n    {\\n        if(x != par[x]) par[x] = find(par[x]);\\n        return par[x];\\n    }\\n    \\n    bool uniun(int x, int y)\\n    {\\n        int pary = find(y);\\n        int parx = find(x);\\n        \\n        if(pary == parx)\\n            return true;                 // We return true when the stone has same parent, hence stoned is removed already\\n        par[pary] = parx;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) \\n    {\\n        int ans = 0;\\n        par.resize(1001);\\n        for(int i=0; i<stones.size(); i++)\\n            par[i] = i;\\n        \\n        for(int i=0; i<stones.size()-1; i++)\\n        {\\n            for(int j=i+1; j<stones.size(); j++)\\n                if(stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1])  // If x or y coordinate of two stones coincide\\n                {\\n                    if(!uniun(i, j)) ++ans;   // We only increment the counter, when the two stones haven\\'t been unioned before\\n                }                             // Once a stone is unioned before, that means that particular stone has been removed and hence cannot be used again\\n        }\\n        \\n        return ans;\\n    }\\n    \\nprivate:\\n    vector<int> par;\\n    \\n    int find(int x)\\n    {\\n        if(x != par[x]) par[x] = find(par[x]);\\n        return par[x];\\n    }\\n    \\n    bool uniun(int x, int y)\\n    {\\n        int pary = find(y);\\n        int parx = find(x);\\n        \\n        if(pary == parx)\\n            return true;                 // We return true when the stone has same parent, hence stoned is removed already\\n        par[pary] = parx;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1657120,
                "title": "union-find-using-coordinate-as-node",
                "content": "```\\nclass UnionFind{\\n    Map<String, String> root;\\n    Map<String, Integer> rank;\\n    int groups;\\n    UnionFind(int[][] stones) {\\n        root = new HashMap<>();\\n        rank = new HashMap<>();\\n        for(int a[]: stones) {\\n            groups++;\\n            String val = a[0]+\" \"+a[1];\\n            root.put(val, val);\\n            rank.put(val, 0);\\n        }\\n    }\\n    \\n    String find(String key) {\\n        if(root.get(key).equals(key)) {\\n            return key;\\n        }\\n        root.put(key, find(root.get(key)));\\n        return root.get(key);\\n    }\\n    \\n    void union(int[] a, int[] b) {\\n        String aKey = a[0] + \" \" + a[1];\\n        String bKey = b[0] + \" \" + b[1];\\n        String aRoot = find(aKey);\\n        String bRoot = find(bKey);\\n        if(!aRoot.equals(bRoot)) {\\n            int aRank = rank.get(aRoot);\\n            int bRank = rank.get(bRoot);\\n            if(aRank < bRank) {\\n                //make a\\'s root to b\\'s root\\n                root.put(aRoot, bRoot);   \\n            }\\n            else if(aRank > bRank) {\\n                root.put(bRoot, aRoot);      \\n            }\\n            else {\\n                root.put(bRoot, aRoot);\\n                rank.put(aRoot, aRank+1);\\n            }\\n            groups--;\\n        }\\n    }\\n    \\n    int getGroups() {\\n        return groups;\\n    }\\n}\\n\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        Map<Integer, List<int[]>> xAdj = new HashMap<>();\\n        Map<Integer, List<int[]>> yAdj = new HashMap<>();\\n        UnionFind uf = new UnionFind(stones);\\n        for(int i=0; i<stones.length; ++i) {\\n            int x = stones[i][0];\\n            int y = stones[i][1];\\n            List<int[]> xList = xAdj.getOrDefault(x, new ArrayList<int[]>());\\n            List<int[]> yList = yAdj.getOrDefault(y, new ArrayList<int[]>());\\n            xList.add(stones[i]);\\n            yList.add(stones[i]);\\n            xAdj.put(x, xList);\\n            yAdj.put(y, yList);\\n        }\\n        for(Map.Entry<Integer, List<int[]>> entry: xAdj.entrySet()) {\\n            List<int[]> list = entry.getValue();\\n            for(int i=1; i<list.size(); ++i) {\\n                uf.union(list.get(i-1), list.get(i));\\n            }\\n        }        \\n        for(Map.Entry<Integer, List<int[]>> entry: yAdj.entrySet()) {\\n            List<int[]> list = entry.getValue();\\n            for(int i=1; i<list.size(); ++i) {\\n                uf.union(list.get(i-1), list.get(i));\\n            }\\n        }\\n        \\n        return stones.length - uf.getGroups();\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind{\\n    Map<String, String> root;\\n    Map<String, Integer> rank;\\n    int groups;\\n    UnionFind(int[][] stones) {\\n        root = new HashMap<>();\\n        rank = new HashMap<>();\\n        for(int a[]: stones) {\\n            groups++;\\n            String val = a[0]+\" \"+a[1];\\n            root.put(val, val);\\n            rank.put(val, 0);\\n        }\\n    }\\n    \\n    String find(String key) {\\n        if(root.get(key).equals(key)) {\\n            return key;\\n        }\\n        root.put(key, find(root.get(key)));\\n        return root.get(key);\\n    }\\n    \\n    void union(int[] a, int[] b) {\\n        String aKey = a[0] + \" \" + a[1];\\n        String bKey = b[0] + \" \" + b[1];\\n        String aRoot = find(aKey);\\n        String bRoot = find(bKey);\\n        if(!aRoot.equals(bRoot)) {\\n            int aRank = rank.get(aRoot);\\n            int bRank = rank.get(bRoot);\\n            if(aRank < bRank) {\\n                //make a\\'s root to b\\'s root\\n                root.put(aRoot, bRoot);   \\n            }\\n            else if(aRank > bRank) {\\n                root.put(bRoot, aRoot);      \\n            }\\n            else {\\n                root.put(bRoot, aRoot);\\n                rank.put(aRoot, aRank+1);\\n            }\\n            groups--;\\n        }\\n    }\\n    \\n    int getGroups() {\\n        return groups;\\n    }\\n}\\n\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        Map<Integer, List<int[]>> xAdj = new HashMap<>();\\n        Map<Integer, List<int[]>> yAdj = new HashMap<>();\\n        UnionFind uf = new UnionFind(stones);\\n        for(int i=0; i<stones.length; ++i) {\\n            int x = stones[i][0];\\n            int y = stones[i][1];\\n            List<int[]> xList = xAdj.getOrDefault(x, new ArrayList<int[]>());\\n            List<int[]> yList = yAdj.getOrDefault(y, new ArrayList<int[]>());\\n            xList.add(stones[i]);\\n            yList.add(stones[i]);\\n            xAdj.put(x, xList);\\n            yAdj.put(y, yList);\\n        }\\n        for(Map.Entry<Integer, List<int[]>> entry: xAdj.entrySet()) {\\n            List<int[]> list = entry.getValue();\\n            for(int i=1; i<list.size(); ++i) {\\n                uf.union(list.get(i-1), list.get(i));\\n            }\\n        }        \\n        for(Map.Entry<Integer, List<int[]>> entry: yAdj.entrySet()) {\\n            List<int[]> list = entry.getValue();\\n            for(int i=1; i<list.size(); ++i) {\\n                uf.union(list.get(i-1), list.get(i));\\n            }\\n        }\\n        \\n        return stones.length - uf.getGroups();\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610499,
                "title": "weeb-does-python-union-find",
                "content": "\\t\\n\\tclass UnionFind:\\n\\t\\tdef __init__(self, n):\\n\\t\\t\\tself.root = list(range(n))\\n\\n\\t\\tdef union(self, x, y):\\n\\t\\t\\tself.root[self.find(x)] = self.find(y)\\n\\n\\t\\tdef find(self, x):\\n\\t\\t\\tif x != self.root[x]:\\n\\t\\t\\t\\tself.root[x] = self.find(self.root[x])\\n\\t\\t\\treturn self.root[x]\\n\\n\\t\\tdef num_components(self):\\n\\t\\t\\tx = set([])\\n\\t\\t\\tfor i in range(len(self.root)):\\n\\t\\t\\t\\tx.add(self.find(i))\\n\\t\\t\\treturn len(x)\\n\\n\\tclass Solution:\\n\\t\\tdef removeStones(self, stones: List[List[int]]) -> int:\\n\\t\\t\\tuf = UnionFind(len(stones))\\n\\n\\t\\t\\tcol_prev = {}\\n\\t\\t\\trow_prev = {}\\n\\t\\t\\tfor i, (x, y) in enumerate(stones):\\n\\t\\t\\t\\tif x in row_prev:\\n\\t\\t\\t\\t\\tuf.union(i, row_prev[x])\\n\\t\\t\\t\\tif y in col_prev:\\n\\t\\t\\t\\t\\tuf.union(i, col_prev[y])\\n\\t\\t\\t\\trow_prev[x] = i\\n\\t\\t\\t\\tcol_prev[y] = i\\n\\n\\t\\t\\treturn len(stones) - uf.num_components()\\n\\nAlright, its time to watch some anime leetcoders\\nTake a break, check out **\\u306B\\u3083\\u3093\\u3053\\u3044\\uFF01Nyan Koi!**\\n\\n# Episodes: 12\\n# Genres: Comedy, Romance\\n# Theme: Harem\\n\\nA very interesting anime so go watch it\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "class Solution:\\n\\t\\tdef removeStones(self, stones: List[List[int]]) -> int:\\n\\t\\t\\tuf = UnionFind(len(stones))\\n\\n\\t\\t\\tcol_prev = {}",
                "codeTag": "Java"
            },
            {
                "id": 1578584,
                "title": "python-dfs",
                "content": "time complexity is O(N) (you go through each element twice, once when building visited, col_stones and row_stones and once during dfs ) and space complexity O(N) (each of visited, col_stones, row_stones takes up O(N))\\n\\n```\\nclass Solution:\\n    \\n    visited = {}\\n    col_stones = collections.defaultdict(list)\\n    row_stones = collections.defaultdict(list)\\n    count = 0\\n    \\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        \\n        \\n        for s in stones:\\n            self.visited[(s[0], s[1])] = False\\n            self.col_stones[s[0]].append(s)\\n            self.row_stones[s[1]].append(s)\\n        \\n        \\n        for s in stones:\\n            if not self.visited[(s[0], s[1])]:\\n                self.dfs(s)\\n        return self.count\\n    \\n    def dfs(self,st):\\n        self.visited[(st[0], st[1])] = True\\n        for c in self.col_stones[st[0]]:\\n            if not self.visited[c[0], c[1]]:\\n                self.dfs(c)\\n                self.count += 1\\n        for r in self.row_stones[st[1]]:\\n            if not self.visited[r[0], r[1]]:\\n                self.dfs(r)\\n                self.count += 1",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    \\n    visited = {}",
                "codeTag": "Java"
            },
            {
                "id": 1514459,
                "title": "java-union-find-o-n",
                "content": "Simple Java Union Find solution using path compression and rank, taking inspiration from Lee\\'s post - https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)\\n\\n```\\nclass Solution {\\n    class UnionFind {\\n        HashMap<Integer,Integer> rank;\\n        HashMap<Integer,Integer> parent;\\n        int numConnectedComponents;\\n        \\n        UnionFind(){\\n            rank = new HashMap<>();\\n            parent = new HashMap<>();\\n        }\\n        \\n        public int find(int vertex){\\n            if(!parent.containsKey(vertex)){\\n                parent.put(vertex, vertex);\\n                numConnectedComponents++;\\n            }\\n            else{\\n                if(parent.get(vertex)==vertex) return vertex;\\n                parent.put(vertex, find(parent.get(vertex)));                \\n            }\\n            return parent.get(vertex);\\n        }\\n        \\n        public void union(int u, int v){\\n            int parentU = find(u);\\n            int parentV = find(v);\\n            if(parentU!=parentV){\\n                numConnectedComponents--;\\n                if(!rank.containsKey(parentU)) rank.put(parentU, 1);\\n                if(!rank.containsKey(parentV)) rank.put(parentV, 1);\\n                if(rank.get(parentU)<rank.get(parentV)){\\n                    parent.put(parentU, parentV);\\n                }\\n                else if(rank.get(parentV)<rank.get(parentU)){\\n                    parent.put(parentV, parentU);\\n                }\\n                else {\\n                    parent.put(parentV, parentU);\\n                    rank.put(parentU, parent.get(parentU)+1); \\n                }\\n            }\\n        }\\n    }\\n    \\n    public int removeStones(int[][] stones) {\\n        UnionFind uf = new UnionFind();\\n        for(int i=0;i<stones.length;i++){\\n            uf.union(stones[i][0],stones[i][1]+10000);\\n        }\\n        return stones.length - uf.numConnectedComponents;\\n    }  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class UnionFind {\\n        HashMap<Integer,Integer> rank;\\n        HashMap<Integer,Integer> parent;\\n        int numConnectedComponents;\\n        \\n        UnionFind(){\\n            rank = new HashMap<>();\\n            parent = new HashMap<>();\\n        }\\n        \\n        public int find(int vertex){\\n            if(!parent.containsKey(vertex)){\\n                parent.put(vertex, vertex);\\n                numConnectedComponents++;\\n            }\\n            else{\\n                if(parent.get(vertex)==vertex) return vertex;\\n                parent.put(vertex, find(parent.get(vertex)));                \\n            }\\n            return parent.get(vertex);\\n        }\\n        \\n        public void union(int u, int v){\\n            int parentU = find(u);\\n            int parentV = find(v);\\n            if(parentU!=parentV){\\n                numConnectedComponents--;\\n                if(!rank.containsKey(parentU)) rank.put(parentU, 1);\\n                if(!rank.containsKey(parentV)) rank.put(parentV, 1);\\n                if(rank.get(parentU)<rank.get(parentV)){\\n                    parent.put(parentU, parentV);\\n                }\\n                else if(rank.get(parentV)<rank.get(parentU)){\\n                    parent.put(parentV, parentU);\\n                }\\n                else {\\n                    parent.put(parentV, parentU);\\n                    rank.put(parentU, parent.get(parentU)+1); \\n                }\\n            }\\n        }\\n    }\\n    \\n    public int removeStones(int[][] stones) {\\n        UnionFind uf = new UnionFind();\\n        for(int i=0;i<stones.length;i++){\\n            uf.union(stones[i][0],stones[i][1]+10000);\\n        }\\n        return stones.length - uf.numConnectedComponents;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356036,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int count = 0;\\n    void DFS(int currentStone, vector<vector<int>> &stones, vector<int> &visited) {\\n        \\n        visited[currentStone] = 1;\\n        \\n        int row = stones[currentStone][0];\\n        int col = stones[currentStone][1];\\n        \\n        for (int j = 0;j<stones.size();j++) {\\n            if (!visited[j] && (stones[j][0] == row || stones[j][1] == col)) {\\n                DFS(j, stones, visited);\\n            }\\n        }        \\n    }\\n    \\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        int group = 0;\\n        vector<int> visited(stones.size(), 0);\\n        for (int i = 0;i<stones.size();i++) {\\n            if (!visited[i]) {\\n                group++;\\n                DFS(i, stones, visited);\\n            }\\n        }\\n        return stones.size() - group;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count = 0;\\n    void DFS(int currentStone, vector<vector<int>> &stones, vector<int> &visited) {\\n        \\n        visited[currentStone] = 1;\\n        \\n        int row = stones[currentStone][0];\\n        int col = stones[currentStone][1];\\n        \\n        for (int j = 0;j<stones.size();j++) {\\n            if (!visited[j] && (stones[j][0] == row || stones[j][1] == col)) {\\n                DFS(j, stones, visited);\\n            }\\n        }        \\n    }\\n    \\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        int group = 0;\\n        vector<int> visited(stones.size(), 0);\\n        for (int i = 0;i<stones.size();i++) {\\n            if (!visited[i]) {\\n                group++;\\n                DFS(i, stones, visited);\\n            }\\n        }\\n        return stones.size() - group;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290992,
                "title": "c-union-find-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Find root of x\\n    int find(vector<int>& parent, int x){\\n        if(parent[x] != -1){\\n            parent[x] = find(parent, parent[x]);\\n            return parent[x];\\n        }\\n        \\n        return x;        \\n    }\\n    \\n    // Union merge\\n    void union_merge(vector<int>& parent, vector<int>& rank, int x, int y){\\n        if(rank[x] > rank[y]) {\\n            parent[y] = x;\\n        }else if(rank[x] < rank[y]){\\n            parent[x] = y;\\n        }else{\\n            parent[y] = x;\\n            rank[x]++;\\n        }\\n    }\\n    \\n\\t// Main function\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        \\n        vector<int> parent(20002, -1); // x [0-10000] , y [10001 - 20001]\\n        vector<int> rank(20002, 0);\\n        \\n        for(auto s : stones){\\n            int x = s[0];\\n            int y = s[1] + 10001;\\n            x = find(parent, x); // Find root of x\\n            y = find(parent, y); // Find root of y\\n            \\n            // Merge 2 sets if root(x) != root(y)\\n            if(x != y){\\n                union_merge(parent, rank, x, y);\\n            }                        \\n        }\\n        \\n        unordered_set<int> set; // Unique set of subsets\\' roots\\n        for(auto s : stones){\\n            int x = s[0];\\n            x = find(parent, x);\\n            \\n            set.insert(x); // To check number of subsets (different roots)\\n        }\\n        \\n        return n - set.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Find root of x\\n    int find(vector<int>& parent, int x){\\n        if(parent[x] != -1){\\n            parent[x] = find(parent, parent[x]);\\n            return parent[x];\\n        }\\n        \\n        return x;        \\n    }\\n    \\n    // Union merge\\n    void union_merge(vector<int>& parent, vector<int>& rank, int x, int y){\\n        if(rank[x] > rank[y]) {\\n            parent[y] = x;\\n        }else if(rank[x] < rank[y]){\\n            parent[x] = y;\\n        }else{\\n            parent[y] = x;\\n            rank[x]++;\\n        }\\n    }\\n    \\n\\t// Main function\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        \\n        vector<int> parent(20002, -1); // x [0-10000] , y [10001 - 20001]\\n        vector<int> rank(20002, 0);\\n        \\n        for(auto s : stones){\\n            int x = s[0];\\n            int y = s[1] + 10001;\\n            x = find(parent, x); // Find root of x\\n            y = find(parent, y); // Find root of y\\n            \\n            // Merge 2 sets if root(x) != root(y)\\n            if(x != y){\\n                union_merge(parent, rank, x, y);\\n            }                        \\n        }\\n        \\n        unordered_set<int> set; // Unique set of subsets\\' roots\\n        for(auto s : stones){\\n            int x = s[0];\\n            x = find(parent, x);\\n            \\n            set.insert(x); // To check number of subsets (different roots)\\n        }\\n        \\n        return n - set.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058763,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int groups = 0, size = stones.size();\\n        vector<bool> visited(size, false);\\n        \\n        for (int i = 0; i < stones.size(); ++i)\\n        {\\n            if (!visited[i])\\n            {\\n                ++groups;\\n                dfs(stones, i, visited);\\n            }\\n        }\\n        \\n        return size - groups;\\n    }\\n    \\nprivate:\\n    void dfs(vector<vector<int>>& stones, int pos, vector<bool>& visited)\\n    {\\n        int x = stones[pos][0], y = stones[pos][1];\\n        visited[pos] = true;\\n        for (int i = 0; i < stones.size(); ++i)\\n        {\\n            if ((stones[i][0] == x || stones[i][1] == y) && !visited[i])\\n            {\\n                dfs(stones, i, visited);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int groups = 0, size = stones.size();\\n        vector<bool> visited(size, false);\\n        \\n        for (int i = 0; i < stones.size(); ++i)\\n        {\\n            if (!visited[i])\\n            {\\n                ++groups;\\n                dfs(stones, i, visited);\\n            }\\n        }\\n        \\n        return size - groups;\\n    }\\n    \\nprivate:\\n    void dfs(vector<vector<int>>& stones, int pos, vector<bool>& visited)\\n    {\\n        int x = stones[pos][0], y = stones[pos][1];\\n        visited[pos] = true;\\n        for (int i = 0; i < stones.size(); ++i)\\n        {\\n            if ((stones[i][0] == x || stones[i][1] == y) && !visited[i])\\n            {\\n                dfs(stones, i, visited);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849271,
                "title": "c-union-by-rank-and-path-compression",
                "content": "Sharing my C++ solution with Union and Path Compression. Please do suggest any modifications.\\n```\\nclass DSU{\\npublic:\\n    int parent[20001];\\n    int rank[20001];\\n    DSU()\\n    {\\n        for(int i=0; i<=20000; i++)\\n        {\\n            parent[i]=i;\\n            rank[i]=0;\\n         }\\n    }\\n    int find(int x)\\n    {\\n        if(parent[x]!=x)\\n          parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    bool _union(int x, int y)\\n    {\\n        int xp = find(x);\\n        int yp = find(y);\\n        if(rank[xp]<rank[yp])\\n            parent[xp]=yp;\\n        else if(rank[yp]<rank[xp])\\n            parent[yp]=xp;\\n        else\\n        {\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }   \\n     }\\n     \\n};\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        DSU dsu;\\n        for(vector<int> stone: stones)\\n        {\\n            dsu._union(stone[0],stone[1]+10000);\\n        }\\n        unordered_map<int,int> mp;\\n        for(vector<int> stone: stones)\\n            mp[dsu.find(stone[0])]=1;\\n        return n-mp.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass DSU{\\npublic:\\n    int parent[20001];\\n    int rank[20001];\\n    DSU()\\n    {\\n        for(int i=0; i<=20000; i++)\\n        {\\n            parent[i]=i;\\n            rank[i]=0;\\n         }\\n    }\\n    int find(int x)\\n    {\\n        if(parent[x]!=x)\\n          parent[x]=find(parent[x]);\\n        return parent[x];\\n    }\\n    bool _union(int x, int y)\\n    {\\n        int xp = find(x);\\n        int yp = find(y);\\n        if(rank[xp]<rank[yp])\\n            parent[xp]=yp;\\n        else if(rank[yp]<rank[xp])\\n            parent[yp]=xp;\\n        else\\n        {\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }   \\n     }\\n     \\n};\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        DSU dsu;\\n        for(vector<int> stone: stones)\\n        {\\n            dsu._union(stone[0],stone[1]+10000);\\n        }\\n        unordered_map<int,int> mp;\\n        for(vector<int> stone: stones)\\n            mp[dsu.find(stone[0])]=1;\\n        return n-mp.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702935,
                "title": "python-3-dfs-solution-recursive",
                "content": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        def dfs(node):\\n            nonlocal moves\\n            visited.add(node)\\n            for next_node in graph[node]:\\n                if next_node not in visited:\\n                    moves += 1\\n                    dfs(next_node)\\n        graph , moves , visited = defaultdict(list) , 0 , set()\\n        for i in range(len(stones)):\\n            for j in range(i):\\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\\n                    graph[i].append(j)\\n                    graph[j].append(i)\\n        for node in range(len(stones)):\\n            if node not in visited:\\n                dfs(node)\\n        return moves\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        def dfs(node):\\n            nonlocal moves\\n            visited.add(node)\\n            for next_node in graph[node]:\\n                if next_node not in visited:\\n                    moves += 1\\n                    dfs(next_node)\\n        graph , moves , visited = defaultdict(list) , 0 , set()\\n        for i in range(len(stones)):\\n            for j in range(i):\\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\\n                    graph[i].append(j)\\n                    graph[j].append(i)\\n        for node in range(len(stones)):\\n            if node not in visited:\\n                dfs(node)\\n        return moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677899,
                "title": "java-union-find",
                "content": "This question is similar to LC 323. Inspired by [this solution](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/discuss/77574/Easiest-2ms-Java-Solution) from LC 323, we have union find solution for this question.\\n\\n```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        int n = stones.length;\\n        if(n == 0) return 0;\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i = 0; i < n; i++) graph.put(i, new ArrayList<Integer>());\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                if(stones[j][0] == stones[i][0] || stones[j][1] == stones[i][1]) {\\n                    graph.get(i).add(j);\\n                }\\n            }\\n        }\\n        int[] roots = new int[n];\\n        int num = n;\\n        for(int i = 0; i < n; i++) roots[i] = i;\\n        for(int i = 0; i < n; i++) {\\n            for(int j : graph.get(i)) {\\n                int root_i = find(roots, i);\\n                int root_j = find(roots, j);\\n                if(root_i != root_j) {\\n                    roots[root_i] = root_j;\\n                    num--;\\n                }\\n            }\\n        }\\n        return n - num;\\n    }\\n    \\n    private int find(int[] roots, int i) {\\n        int j = i;\\n        while(roots[i] != i) i = roots[i];\\n        roots[j] = i;\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        int n = stones.length;\\n        if(n == 0) return 0;\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i = 0; i < n; i++) graph.put(i, new ArrayList<Integer>());\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i + 1; j < n; j++) {\\n                if(stones[j][0] == stones[i][0] || stones[j][1] == stones[i][1]) {\\n                    graph.get(i).add(j);\\n                }\\n            }\\n        }\\n        int[] roots = new int[n];\\n        int num = n;\\n        for(int i = 0; i < n; i++) roots[i] = i;\\n        for(int i = 0; i < n; i++) {\\n            for(int j : graph.get(i)) {\\n                int root_i = find(roots, i);\\n                int root_j = find(roots, j);\\n                if(root_i != root_j) {\\n                    roots[root_i] = root_j;\\n                    num--;\\n                }\\n            }\\n        }\\n        return n - num;\\n    }\\n    \\n    private int find(int[] roots, int i) {\\n        int j = i;\\n        while(roots[i] != i) i = roots[i];\\n        roots[j] = i;\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561079,
                "title": "c-easy-to-understand-solution-well-commented",
                "content": "Basic idea is to find connected stones via column and link. Lets say n stones are connected with each other, we can remove maximum of n-1 stones according to statement in the question.\\nWe will find all such connected stones and our answer will be incremented by n-1.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int numOfConnectedStones(vector<vector<int>>& stones,unordered_map<int,vector<int>>& row,unordered_map<int,vector<int>>& col,\\n                             vector<bool>& isStoneVisited, int n,int idx){\\n        int ans=0;\\n        isStoneVisited[idx]=true;\\n        ans++;\\n        int r=stones[idx][0],c=stones[idx][1]; //Row and column of that stone\\n        //Now I will see how many stones have that same row and call function on them\\n        for(int i=0;i<row[r].size();i++){\\n            if(!isStoneVisited[row[r][i]]){\\n                ans+=numOfConnectedStones(stones,row,col,isStoneVisited,n,row[r][i]);\\n            }\\n        }\\n        //Now I will see how many stones have that same row and call function on them\\n        for(int i=0;i<col[c].size();i++){\\n            if(!isStoneVisited[col[c][i]]){\\n                ans+=numOfConnectedStones(stones,row,col,isStoneVisited,n,col[c][i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        //It seems like that we can solve this question with dfs\\n        //But our adjMatrix will be of size 10^4*10^4 that can work\\n        //I will try to find connected components via map\\n        int n=stones.size();\\n        vector<bool> isStoneVisited(n,0);\\n        unordered_map<int,vector<int>> row;  //Will contain info about which row is in which index\\n        unordered_map<int,vector<int>> col;  //Will contain info about which col is in which index\\n        for(int i=0;i<n;i++){\\n            row[stones[i][0]].push_back(i);\\n            col[stones[i][1]].push_back(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(!isStoneVisited[i]){ //That stone is not visited yet\\n                int num=numOfConnectedStones(stones,row,col,isStoneVisited,n,i);\\n                ans+=(num-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numOfConnectedStones(vector<vector<int>>& stones,unordered_map<int,vector<int>>& row,unordered_map<int,vector<int>>& col,\\n                             vector<bool>& isStoneVisited, int n,int idx){\\n        int ans=0;\\n        isStoneVisited[idx]=true;\\n        ans++;\\n        int r=stones[idx][0],c=stones[idx][1]; //Row and column of that stone\\n        //Now I will see how many stones have that same row and call function on them\\n        for(int i=0;i<row[r].size();i++){\\n            if(!isStoneVisited[row[r][i]]){\\n                ans+=numOfConnectedStones(stones,row,col,isStoneVisited,n,row[r][i]);\\n            }\\n        }\\n        //Now I will see how many stones have that same row and call function on them\\n        for(int i=0;i<col[c].size();i++){\\n            if(!isStoneVisited[col[c][i]]){\\n                ans+=numOfConnectedStones(stones,row,col,isStoneVisited,n,col[c][i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        //It seems like that we can solve this question with dfs\\n        //But our adjMatrix will be of size 10^4*10^4 that can work\\n        //I will try to find connected components via map\\n        int n=stones.size();\\n        vector<bool> isStoneVisited(n,0);\\n        unordered_map<int,vector<int>> row;  //Will contain info about which row is in which index\\n        unordered_map<int,vector<int>> col;  //Will contain info about which col is in which index\\n        for(int i=0;i<n;i++){\\n            row[stones[i][0]].push_back(i);\\n            col[stones[i][1]].push_back(i);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(!isStoneVisited[i]){ //That stone is not visited yet\\n                int num=numOfConnectedStones(stones,row,col,isStoneVisited,n,i);\\n                ans+=(num-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 262047,
                "title": "share-my-c-union-find-solution",
                "content": "public:\\n    vector<int> parent;\\n    int count;    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        int numofStones = stones.size();\\n        if(numofStones <= 1) return 0;\\n        \\n        for(int i = 0; i < numofStones; i++)\\n        {\\n            parent.push_back(i);\\n        }\\n        count = 0;\\n        for(int i = 0; i < numofStones; i++)\\n        {\\n            for(int j = i+1; j < numofStones; j++)\\n            {\\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                {\\n                    uni(i, j);\\n                }\\n                \\n            }\\n        }\\n        return count;\\n    }\\n    \\n    void uni(int i, int j)\\n    {\\n        i = find(i);\\n        j = find(j);\\n        if(i!= j)\\n        {\\n            parent[i] = j;\\n            count ++;\\n        }\\n    }\\n    \\n    int find(int x)\\n    {\\n        if(x != parent[x])\\n        {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "public:\\n    vector<int> parent;\\n    int count;    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        int numofStones = stones.size();\\n        if(numofStones <= 1) return 0;\\n        \\n        for(int i = 0; i < numofStones; i++)\\n        {\\n            parent.push_back(i);\\n        }\\n        count = 0;\\n        for(int i = 0; i < numofStones; i++)\\n        {\\n            for(int j = i+1; j < numofStones; j++)\\n            {\\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                {\\n                    uni(i, j);\\n                }\\n                \\n            }\\n        }\\n        return count;\\n    }\\n    \\n    void uni(int i, int j)\\n    {\\n        i = find(i);\\n        j = find(j);\\n        if(i!= j)\\n        {\\n            parent[i] = j;\\n            count ++;\\n        }\\n    }\\n    \\n    int find(int x)\\n    {\\n        if(x != parent[x])\\n        {\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 251228,
                "title": "the-idea-to-solve-this-problem-in-two-ways-c-dfs-and-disjointed-set",
                "content": "I share my thinking process for this problem. I think after sorting out the process the solution becomes obvious.\\nSo here they are:\\n\\n2 stones are connected when they have same x or y axis value.\\nNow split the stones into groups, each of which contains connected stones.\\nA safe way to remove redundant stones is to always remove the leaf nodes, who has got only one edges in the graph. If it\\'s got no edge on it, i.e, an isolated node, then it can\\'t be removed.\\n\\nSo this is a greedy approach: whenver there\\'re more than 1 node that can be removed at some point, always remove the node who\\'s got least connections with others first.\\nKeep going until only 1 stone left for each group.\\n\\ne.g., in the graph below the way to remove most stones is to remove C(or B) first.\\nIf A is removed first then B and C can\\'t be removed any more.\\n.A       .B\\n\\n.C\\nNote that it can happen that a group can have no leaf nodes: each of the node connects to more than 1 other nodes. In this case we\\'re even easier to reach the goal (leaving only 1 node in that group), breaking the tie by just removing an arbitrary one.\\nAlso note that we don\\'t need to actually do the removal because the question only need the maximum number of stones removed.\\nSo all in all, this question equals to be asking, how many disjointed sets are there?\\n\\nWhat\\'s left is simple: build the graph, do a DFS, while counting the number of trees.\\nAlternatively you can make use of the idea of disjointed set to find out how many disjointed sets are there.\\nFollowing are code for DFS and Disjointed set.\\n\\n```\\nclass Solution {\\npublic:\\n\\tint removeStones(vector<vector<int>>& stones) {\\n\\t\\tint n = stones.size();\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tvector<vector<int>> adjList(n);\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = i + 1; j < n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tadjList[i].push_back(j);\\n\\t\\t\\t\\t\\tadjList[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\tvector<bool> visited(n, false);\\n\\t\\tint trees = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (visited[i])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttrees++;\\n\\n\\t\\t\\tstack<int> path;\\n\\t\\t\\tpath.push(i);\\n\\t\\t\\twhile (!path.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint top = path.top();\\n\\t\\t\\t\\tvisited[top] = true;\\n\\t\\t\\t\\tbool bNewNode = false;\\n\\t\\t\\t\\tfor (int j = 0; j < adjList[top].size(); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (!visited[adjList[top][j]])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbNewNode = true;\\n\\t\\t\\t\\t\\t\\tpath.push(adjList[top][j]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!bNewNode)\\n\\t\\t\\t\\t\\tpath.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn n - trees;\\n\\t}\\n};\\n```\\n\\nFollowing is the solution for Disjointed set. Rank heuristic and Path compression are both applied to make it quicker.\\nThe LC time is not really quick tho. Perhaps the O(n^2) time used for searching for adjacent stones slows down the solution.\\nIf you\\'re unfamiliar with terms mentioned above, I suggest that you read some background material coz it\\'s hard to explain that in some paragraph. Also, reading and understanding it helps you use it in other situations. - I\\'m new to this as well so I spent some time reading it before I wrote the code.\\n\\n```\\nclass Solution {\\n\\tclass CSet\\n\\t{\\n\\tpublic:\\n\\t\\tint rank;\\n\\t\\tCSet* parent;\\n\\t};\\n\\tCSet* makeSet(int stone)\\n\\t{\\n\\t\\tauto* p = new CSet();\\n\\t\\tp->parent = p;\\n\\t\\tp->rank = 0;\\n\\t\\treturn p;\\n\\t}\\n\\tCSet* findSet(CSet* x)\\n\\t{\\n\\t\\tif (x->parent != x)\\n\\t\\t\\tx->parent = findSet(x->parent);\\n\\t\\treturn x->parent;\\n\\t}\\n\\tvoid union_(CSet* x, CSet* y)\\n\\t{\\n\\t\\tlink(findSet(x), findSet(y));\\n\\t}\\n\\tvoid link(CSet* x, CSet* y)\\n\\t{\\n\\t\\tif (x->rank > y->rank)\\n\\t\\t{\\n\\t\\t\\ty->parent = x;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tx->parent = y;\\n\\t\\t\\tif (x->rank == y->rank)\\n\\t\\t\\t\\ty->rank++;\\n\\t\\t}\\n\\t}\\n\\npublic:\\n\\tint removeStones(vector<vector<int>>& stones) {\\n\\t\\tint n = stones.size();\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tvector<CSet*> sets(n);\\n\\t\\tfor (int i = 0; i < stones.size(); i++)\\n\\t\\t{\\n\\t\\t\\tsets[i] = makeSet(i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = i + 1; j < n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ((stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) && findSet(sets[i]) != findSet(sets[j]))\\n\\t\\t\\t\\t\\tunion_(findSet(sets[i]), findSet(sets[j]));\\n\\t\\t\\t}\\n\\t\\tset<CSet*> parents;\\n\\t\\tfor (auto p : sets)\\n\\t\\t\\tparents.insert(findSet(p));\\n\\t\\treturn n - parents.size();\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint removeStones(vector<vector<int>>& stones) {\\n\\t\\tint n = stones.size();\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tvector<vector<int>> adjList(n);\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = i + 1; j < n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tadjList[i].push_back(j);\\n\\t\\t\\t\\t\\tadjList[j].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\tvector<bool> visited(n, false);\\n\\t\\tint trees = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (visited[i])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\ttrees++;\\n\\n\\t\\t\\tstack<int> path;\\n\\t\\t\\tpath.push(i);\\n\\t\\t\\twhile (!path.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint top = path.top();\\n\\t\\t\\t\\tvisited[top] = true;\\n\\t\\t\\t\\tbool bNewNode = false;\\n\\t\\t\\t\\tfor (int j = 0; j < adjList[top].size(); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (!visited[adjList[top][j]])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tbNewNode = true;\\n\\t\\t\\t\\t\\t\\tpath.push(adjList[top][j]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!bNewNode)\\n\\t\\t\\t\\t\\tpath.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn n - trees;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\n\\tclass CSet\\n\\t{\\n\\tpublic:\\n\\t\\tint rank;\\n\\t\\tCSet* parent;\\n\\t};\\n\\tCSet* makeSet(int stone)\\n\\t{\\n\\t\\tauto* p = new CSet();\\n\\t\\tp->parent = p;\\n\\t\\tp->rank = 0;\\n\\t\\treturn p;\\n\\t}\\n\\tCSet* findSet(CSet* x)\\n\\t{\\n\\t\\tif (x->parent != x)\\n\\t\\t\\tx->parent = findSet(x->parent);\\n\\t\\treturn x->parent;\\n\\t}\\n\\tvoid union_(CSet* x, CSet* y)\\n\\t{\\n\\t\\tlink(findSet(x), findSet(y));\\n\\t}\\n\\tvoid link(CSet* x, CSet* y)\\n\\t{\\n\\t\\tif (x->rank > y->rank)\\n\\t\\t{\\n\\t\\t\\ty->parent = x;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tx->parent = y;\\n\\t\\t\\tif (x->rank == y->rank)\\n\\t\\t\\t\\ty->rank++;\\n\\t\\t}\\n\\t}\\n\\npublic:\\n\\tint removeStones(vector<vector<int>>& stones) {\\n\\t\\tint n = stones.size();\\n\\t\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tvector<CSet*> sets(n);\\n\\t\\tfor (int i = 0; i < stones.size(); i++)\\n\\t\\t{\\n\\t\\t\\tsets[i] = makeSet(i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tfor (int j = i + 1; j < n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ((stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) && findSet(sets[i]) != findSet(sets[j]))\\n\\t\\t\\t\\t\\tunion_(findSet(sets[i]), findSet(sets[j]));\\n\\t\\t\\t}\\n\\t\\tset<CSet*> parents;\\n\\t\\tfor (auto p : sets)\\n\\t\\t\\tparents.insert(findSet(p));\\n\\t\\treturn n - parents.size();\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246931,
                "title": "python-union-find-general-approach",
                "content": "Similar approach can be followed for \\n\\n1. [ Number of Islands II](https://leetcode.com/problems/number-of-islands-ii/discuss/246928/Union-find-(general-approach))\\n2. [Couples Holding Hands](https://leetcode.com/problems/couples-holding-hands/discuss/246929/Python-union-find-beats-100)\\n3. [Most Stones Removed](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/246931/Python-union-find-(general-approach))\\n4. [Redundant Connection](https://leetcode.com/problems/redundant-connection/discuss/246972/Union-find-python-(general-approach)-beats-99)\\n\\n```python\\nclass UnionFind(object):\\n    def __init__(self):\\n        self.parents = {}\\n        self.count = 0\\n    \\n    def make_set(self, x):\\n        self.parents[x] = x\\n        self.count += 1\\n        \\n    def find(self, x):\\n        if x not in self.parents:\\n            self.make_set(x)\\n            return x\\n        elif self.parents[x] == x:\\n            return x\\n        self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        x_set = self.find(x)\\n        y_set = self.find(y)\\n        if x_set != y_set:\\n            self.parents[x_set] = y_set\\n            self.count -= 1\\n\\nclass Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(stones)\\n        uf = UnionFind()\\n        \\n        for x, y in stones:\\n            uf.union(x, ~y)\\n        \\n        return n - uf.count\\n```",
                "solutionTags": [],
                "code": "```python\\nclass UnionFind(object):\\n    def __init__(self):\\n        self.parents = {}\\n        self.count = 0\\n    \\n    def make_set(self, x):\\n        self.parents[x] = x\\n        self.count += 1\\n        \\n    def find(self, x):\\n        if x not in self.parents:\\n            self.make_set(x)\\n            return x\\n        elif self.parents[x] == x:\\n            return x\\n        self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        x_set = self.find(x)\\n        y_set = self.find(y)\\n        if x_set != y_set:\\n            self.parents[x_set] = y_set\\n            self.count -= 1\\n\\nclass Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(stones)\\n        uf = UnionFind()\\n        \\n        for x, y in stones:\\n            uf.union(x, ~y)\\n        \\n        return n - uf.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208964,
                "title": "dfs-hash-table-o-n-2-beats-93-count-number-of-groups-40-line-c",
                "content": "A group of stones is defined as all stones that can be connected by rows or columns, which means each stone in the group is at least on the same row or column with another stone in the group. A group is essentially a connected graph. All stones in the same group are removable except the last one. Thus, the totoal number of stones remaining is the number of groups. \\nWe can do a DFS on each stone to count the total number groups. DFS is faster than Union Find, because the union step may take more than O(1) time. \\n\\nTime Complexity: O(n^2) \\n```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n\\t\\tint gp=0;\\n\\t\\tvector<int> vc(stones.size(),-1);\\n\\t\\tunordered_map<int,vector<int>> row, col;// row,col as key\\n\\t\\t\\n\\t\\tfor( int i=0; i<stones.size(); i++){// build graph \\n\\t\\t\\templaceUm( stones[i][0], i, row);\\n\\t\\t\\templaceUm( stones[i][1], i, col);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor( int i=0; i<stones.size(); i++)\\n\\t\\t\\tif(vc[i]==-1)   dfs( i, ++gp, vc, stones, row, col);\\n\\t\\t\\n\\t\\treturn stones.size()-gp;\\n    }\\n\\t\\nprotected:\\n\\tvoid emplaceUm( int key, int i, unordered_map<int,vector<int>>& um){\\n\\t\\tunordered_map<int,vector<int>>::iterator umi=um.find(key);\\n\\t\\tif(umi!=um.end())   umi->second.push_back(i);\\n        else    um.emplace(key,vector<int>{i});\\n\\t\\treturn ;\\n\\t}\\n\\t\\n\\tvoid dfs( int i, int gp, vector<int>& vc, vector<vector<int>>& stones, \\n\\t\\tunordered_map<int,vector<int>>& row, unordered_map<int,vector<int>>& col){\\n\\t\\tif(vc[i]==-1)\\tvc[i]=gp;\\n\\t\\telse\\treturn ;\\n\\t\\t\\n\\t\\tunordered_map<int,vector<int>>::iterator umi=row.find(stones[i][0]);\\n\\t\\tfor( int j=0; j<umi->second.size(); j++)\\n\\t\\t\\tdfs( umi->second[j],gp,vc,stones,row,col);\\n\\t\\t\\n\\t\\tumi=col.find(stones[i][1]);\\n\\t\\tfor( int j=0; j<umi->second.size(); j++)\\n\\t\\t\\tdfs( umi->second[j],gp,vc,stones,row,col);\\n\\t\\t\\n\\t\\treturn ;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n\\t\\tint gp=0;\\n\\t\\tvector<int> vc(stones.size(),-1);\\n\\t\\tunordered_map<int,vector<int>> row, col;// row,col as key\\n\\t\\t\\n\\t\\tfor( int i=0; i<stones.size(); i++){// build graph \\n\\t\\t\\templaceUm( stones[i][0], i, row);\\n\\t\\t\\templaceUm( stones[i][1], i, col);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor( int i=0; i<stones.size(); i++)\\n\\t\\t\\tif(vc[i]==-1)   dfs( i, ++gp, vc, stones, row, col);\\n\\t\\t\\n\\t\\treturn stones.size()-gp;\\n    }\\n\\t\\nprotected:\\n\\tvoid emplaceUm( int key, int i, unordered_map<int,vector<int>>& um){\\n\\t\\tunordered_map<int,vector<int>>::iterator umi=um.find(key);\\n\\t\\tif(umi!=um.end())   umi->second.push_back(i);\\n        else    um.emplace(key,vector<int>{i});\\n\\t\\treturn ;\\n\\t}\\n\\t\\n\\tvoid dfs( int i, int gp, vector<int>& vc, vector<vector<int>>& stones, \\n\\t\\tunordered_map<int,vector<int>>& row, unordered_map<int,vector<int>>& col){\\n\\t\\tif(vc[i]==-1)\\tvc[i]=gp;\\n\\t\\telse\\treturn ;\\n\\t\\t\\n\\t\\tunordered_map<int,vector<int>>::iterator umi=row.find(stones[i][0]);\\n\\t\\tfor( int j=0; j<umi->second.size(); j++)\\n\\t\\t\\tdfs( umi->second[j],gp,vc,stones,row,col);\\n\\t\\t\\n\\t\\tumi=col.find(stones[i][1]);\\n\\t\\tfor( int j=0; j<umi->second.size(); j++)\\n\\t\\t\\tdfs( umi->second[j],gp,vc,stones,row,col);\\n\\t\\t\\n\\t\\treturn ;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205573,
                "title": "javascript-union-find-dfs",
                "content": "**Union Find**\\n```\\nvar removeStones = function(stones) {\\n    let upperBound = -Infinity;\\n    \\n    for(let [row, col] of stones) {\\n        upperBound = Math.max(row, col, upperBound);\\n    }\\n    \\n    const root = new Array((upperBound + 1) * 2)\\n\\t\\t.fill(0)\\n\\t\\t.map((a,i) => i);\\n    \\n    const rank = new Array((upperBound + 1) * 2).fill(0);\\n    \\n    function find(t) {\\n        if(root[t] !== t) {\\n            root[t] = find(root[t]); // path compression\\n        }\\n        return root[t];\\n    }\\n    \\n    function union(a,b) {\\n        let rootA = find(a);\\n        let rootB = find(b);\\n        if(rank[rootA] === rank[rootB]) {\\n            root[rootB] = rootA;\\n            rank[rootA] += 1;\\n        } else if (rank[rootA] < rank[rootB]) {\\n            root[rootA] = rootB;\\n        } else {\\n            root[rootB] = rootA;\\n        }\\n    }\\n    \\n    for(let [row,col] of stones) {\\n        union(row, col+upperBound+1);\\n    }\\n    \\n    const set = new Set();\\n    \\n    for(let [row,col] of stones) {\\n        set.add(find(row));\\n    }\\n    \\n    return stones.length - set.size;\\n};\\n```\\n**DFS**\\n```\\nvar removeStones = function(stones) {\\n    \\n    const rows = {};\\n    const cols = {};\\n    \\n    for(let stone of stones) {\\n        if(!rows[stone[0]]) {\\n            rows[stone[0]] = [];\\n        }\\n        if(!cols[stone[1]]) {\\n            cols[stone[1]] = [];\\n        }\\n        rows[stone[0]].push(stone[1]);\\n        cols[stone[1]].push(stone[0]);\\n    }\\n    \\n    const visited = {};\\n    let numConnected = 0;\\n    function dfs(row, col) {\\n        for(let e of rows[row]) {\\n            const key = `${row},${e}`;\\n            if(!visited[key]) {\\n                visited[key] = true;\\n                dfs(row, e);\\n            }\\n        }\\n        for(let e of cols[col]) {\\n            const key = `${e},${col}`;\\n            if(!visited[key]) {\\n                visited[key] = true;\\n                dfs(e, col);\\n            }\\n        }\\n    }\\n    \\n    for(let stone of stones) {\\n        const key = `${stone[0]},${stone[1]}`;\\n        if(!visited[key]) {\\n            dfs(stone[0], stone[1]);\\n            numConnected += 1;\\n        }\\n    }\\n    \\n    return stones.length - numConnected;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nvar removeStones = function(stones) {\\n    let upperBound = -Infinity;\\n    \\n    for(let [row, col] of stones) {\\n        upperBound = Math.max(row, col, upperBound);\\n    }\\n    \\n    const root = new Array((upperBound + 1) * 2)\\n\\t\\t.fill(0)\\n\\t\\t.map((a,i) => i);\\n    \\n    const rank = new Array((upperBound + 1) * 2).fill(0);\\n    \\n    function find(t) {\\n        if(root[t] !== t) {\\n            root[t] = find(root[t]); // path compression\\n        }\\n        return root[t];\\n    }\\n    \\n    function union(a,b) {\\n        let rootA = find(a);\\n        let rootB = find(b);\\n        if(rank[rootA] === rank[rootB]) {\\n            root[rootB] = rootA;\\n            rank[rootA] += 1;\\n        } else if (rank[rootA] < rank[rootB]) {\\n            root[rootA] = rootB;\\n        } else {\\n            root[rootB] = rootA;\\n        }\\n    }\\n    \\n    for(let [row,col] of stones) {\\n        union(row, col+upperBound+1);\\n    }\\n    \\n    const set = new Set();\\n    \\n    for(let [row,col] of stones) {\\n        set.add(find(row));\\n    }\\n    \\n    return stones.length - set.size;\\n};\\n```\n```\\nvar removeStones = function(stones) {\\n    \\n    const rows = {};\\n    const cols = {};\\n    \\n    for(let stone of stones) {\\n        if(!rows[stone[0]]) {\\n            rows[stone[0]] = [];\\n        }\\n        if(!cols[stone[1]]) {\\n            cols[stone[1]] = [];\\n        }\\n        rows[stone[0]].push(stone[1]);\\n        cols[stone[1]].push(stone[0]);\\n    }\\n    \\n    const visited = {};\\n    let numConnected = 0;\\n    function dfs(row, col) {\\n        for(let e of rows[row]) {\\n            const key = `${row},${e}`;\\n            if(!visited[key]) {\\n                visited[key] = true;\\n                dfs(row, e);\\n            }\\n        }\\n        for(let e of cols[col]) {\\n            const key = `${e},${col}`;\\n            if(!visited[key]) {\\n                visited[key] = true;\\n                dfs(e, col);\\n            }\\n        }\\n    }\\n    \\n    for(let stone of stones) {\\n        const key = `${stone[0]},${stone[1]}`;\\n        if(!visited[key]) {\\n            dfs(stone[0], stone[1]);\\n            numConnected += 1;\\n        }\\n    }\\n    \\n    return stones.length - numConnected;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3696154,
                "title": "c-dsu-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass DSU\\n{\\npublic:\\n    vector<int> rank, parent, size;\\n    DSU(int n)\\n    {\\n       \\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node)\\n    {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n   \\n    void unionBySize(int u, int v)\\n    {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v)\\n            return;\\n        if (size[ulp_u] < size[ulp_v])\\n        {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else\\n        {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }    \\n};\\n\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n\\n    int n=stones.size();\\n\\n    int maxrow=0;\\n    int maxcol=0;\\n\\n    for(auto it:stones){\\n        maxrow=max(maxrow,it[0]);\\n        maxcol=max(maxcol,it[1]);\\n    }\\n\\n    DSU ds(maxrow+maxcol+1);\\n\\n    vector<int> vis(maxrow+maxcol+2,0);\\n\\n    for(auto it:stones){\\n        int x=it[0];\\n        int y=maxrow+it[1]+1;\\n\\n        vis[x]=1;\\n        vis[y]=1;\\n\\n        if(ds.findUPar(x)!=ds.findUPar(y)){\\n            ds.unionBySize(x,y);\\n        }\\n        \\n    }\\n\\n    int m=vis.size();\\n\\n    unordered_set<int> st;\\n\\n    for(int i=0;i<m;i++){\\n        if(vis[i]==1){\\n            st.insert(ds.findUPar(i));\\n        }\\n    }\\n\\n    return stones.size()-st.size();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\n\\nclass DSU\\n{\\npublic:\\n    vector<int> rank, parent, size;\\n    DSU(int n)\\n    {\\n       \\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node)\\n    {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n   \\n    void unionBySize(int u, int v)\\n    {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v)\\n            return;\\n        if (size[ulp_u] < size[ulp_v])\\n        {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else\\n        {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }    \\n};\\n\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n\\n    int n=stones.size();\\n\\n    int maxrow=0;\\n    int maxcol=0;\\n\\n    for(auto it:stones){\\n        maxrow=max(maxrow,it[0]);\\n        maxcol=max(maxcol,it[1]);\\n    }\\n\\n    DSU ds(maxrow+maxcol+1);\\n\\n    vector<int> vis(maxrow+maxcol+2,0);\\n\\n    for(auto it:stones){\\n        int x=it[0];\\n        int y=maxrow+it[1]+1;\\n\\n        vis[x]=1;\\n        vis[y]=1;\\n\\n        if(ds.findUPar(x)!=ds.findUPar(y)){\\n            ds.unionBySize(x,y);\\n        }\\n        \\n    }\\n\\n    int m=vis.size();\\n\\n    unordered_set<int> st;\\n\\n    for(int i=0;i<m;i++){\\n        if(vis[i]==1){\\n            st.insert(ds.findUPar(i));\\n        }\\n    }\\n\\n    return stones.size()-st.size();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601488,
                "title": "easiest-code-disjoint-set-union-by-size-striver-s-method",
                "content": "# ***Any queries and doubts regarding the code and approach ? Kindly comment it down :)***\\n\\n# Code\\n```\\nclass DisjointSet {\\npublic: \\n    vector<int> rank, parent, size; \\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n}; \\n\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n=stones.size();\\n        int mrow=0;\\n        int mcol=0;\\n        for(auto it:stones){\\n            mrow=max(mrow,it[0]);\\n            mcol=max(mcol,it[1]);\\n        }\\n        DisjointSet ds(mrow+mcol+1);\\n        unordered_map<int,int> mp;\\n        for(auto it:stones){\\n            int nrow=it[0]; //node row\\n            int ncol=it[1]+mrow+1; //node col\\n            ds.unionBySize(nrow,ncol);\\n            mp[nrow]=1;\\n            mp[ncol]=1;\\n        }\\n        int cnt=0;\\n        for(auto it:mp){\\n            if(ds.findUPar(it.first)==it.first) cnt++;\\n        }\\n        return n-cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\npublic: \\n    vector<int> rank, parent, size; \\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n}; \\n\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n=stones.size();\\n        int mrow=0;\\n        int mcol=0;\\n        for(auto it:stones){\\n            mrow=max(mrow,it[0]);\\n            mcol=max(mcol,it[1]);\\n        }\\n        DisjointSet ds(mrow+mcol+1);\\n        unordered_map<int,int> mp;\\n        for(auto it:stones){\\n            int nrow=it[0]; //node row\\n            int ncol=it[1]+mrow+1; //node col\\n            ds.unionBySize(nrow,ncol);\\n            mp[nrow]=1;\\n            mp[ncol]=1;\\n        }\\n        int cnt=0;\\n        for(auto it:mp){\\n            if(ds.findUPar(it.first)==it.first) cnt++;\\n        }\\n        return n-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491117,
                "title": "python-easy-union-find-explained",
                "content": "**We can say that if a stone is in the same row or in same column then it is a part of one component and no. of stones that can be removed from one component is n1(no. of stones in component 1)-1. So, total no. of stones that can be removed is n(given no. of stones) - c(no. of components)**\\n\\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        def find(u):\\n            if u==parent[u]:\\n                return u\\n            else:\\n                parent[u]=find(parent[u])\\n                return parent[u]\\n        def union(u,v):\\n            pu,pv=find(u),find(v)\\n            if pu==pv:\\n                return \\n            if size[pv]>size[pu]:\\n                parent[pu]=pv\\n                size[pv]+=size[pu]\\n            else:\\n                parent[pv]=pu\\n                size[pu]+=size[pv]\\n        \\n        n=len(stones)\\n        mr=mc=0\\n        for i,j in stones:\\n            mr=max(mr,i)\\n            mc=max(mc,j)\\n        parent=[i for i in range(mr+mc+2)]\\n        size=[1 for i in range(mr+mc+2)]\\n        d={} # created a dictionary to store the rows and columns which are visited\\n        for i,j in stones:\\n            union(i,j+mr+1)\\n            d[i]=1\\n            d[j+mr+1]=1\\n        c=0 \\n        for i in d:\\n            if find(i)==i:\\n                c+=1 # counting the no. of components\\n        return n-c\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        def find(u):\\n            if u==parent[u]:\\n                return u\\n            else:\\n                parent[u]=find(parent[u])\\n                return parent[u]\\n        def union(u,v):\\n            pu,pv=find(u),find(v)\\n            if pu==pv:\\n                return \\n            if size[pv]>size[pu]:\\n                parent[pu]=pv\\n                size[pv]+=size[pu]\\n            else:\\n                parent[pv]=pu\\n                size[pu]+=size[pv]\\n        \\n        n=len(stones)\\n        mr=mc=0\\n        for i,j in stones:\\n            mr=max(mr,i)\\n            mc=max(mc,j)\\n        parent=[i for i in range(mr+mc+2)]\\n        size=[1 for i in range(mr+mc+2)]\\n        d={} # created a dictionary to store the rows and columns which are visited\\n        for i,j in stones:\\n            union(i,j+mr+1)\\n            d[i]=1\\n            d[j+mr+1]=1\\n        c=0 \\n        for i in d:\\n            if find(i)==i:\\n                c+=1 # counting the no. of components\\n        return n-c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410214,
                "title": "dfs-union-find",
                "content": "# Method 1\\n```\\nclass Solution {\\nprivate:\\n    int cc = 0;\\n    void buildGraph(vector<vector<int>>&S,vector<int> g[],int n){\\n        for(int i=0; i<n; ++i){\\n            for(int j=1; j<n; ++j){\\n                if(S[i][0] == S[j][0] || S[i][1] == S[j][1]){\\n                    g[i].push_back(j);\\n                    g[j].push_back(i);\\n                }\\n            }\\n        }\\n    }\\n    void dfs(int node,vector<int> g[],vector<bool>&vis){\\n        vis[node] = 1;\\n        cc++;\\n        for(int&child: g[node]){\\n            if(!vis[child])\\n                dfs(child,g,vis);\\n        }\\n    }\\npublic:\\n    int removeStones(vector<vector<int>>& S) {\\n        int n = size(S), ans = 0;\\n        vector<bool> vis(n,false);\\n        vector<int> g[n];\\n        buildGraph(S,g,n);\\n        // dfs traversal\\n        for(int i=0; i<n; ++i){\\n            if(!vis[i]){\\n                cc = 0;\\n                dfs(i,g,vis);\\n                ans += cc-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Method 2\\n```\\nclass DSU{\\n    private:\\n        const int N = 1e6+10;\\n        vector<int> parent, size, rank;\\n    public:\\n        DSU(){\\n            parent.resize(N);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(N,1);\\n            rank.resize(N,0);\\n        }\\n        DSU(int n){\\n            parent.resize(n+1);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(n+1,1);\\n            rank.resize(n+1,0);\\n        }\\n        int find(int v){\\n            if(parent[v] == v) return v;\\n            //path compression\\n            return parent[v] = find(parent[v]);\\n        }\\n        void unionS(int a,int b){\\n            a = find(a);\\n            b = find(b);\\n            if(a!=b){\\n                //union by size\\n                if(size[a] < size[b]) swap(a,b);\\n                parent[b] = a;\\n                size[a] += size[b];\\n            }\\n        }\\n        void unionR(int x, int y) {\\n            x = find(x), y = find(y);\\n            if(x == y) return;\\n            //union by rank\\n            else if(rank[x] < rank[y]) parent[x] = y;\\n            else if (rank[x] > rank[y]) parent[y] = x;\\n            else parent[y] = x,rank[x]++;\\n      }\\n};\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& S) {\\n        int n = size(S), cc = 0;\\n        DSU ds(n-1);\\n        for(int i=0; i<n; ++i){\\n            for(int j=1; j<n; ++j){\\n                if(S[i][0] == S[j][0] || S[i][1] == S[j][1]){\\n                    ds.unionS(i,j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; ++i) if(ds.find(i) == i) cc++;\\n        return n - cc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int cc = 0;\\n    void buildGraph(vector<vector<int>>&S,vector<int> g[],int n){\\n        for(int i=0; i<n; ++i){\\n            for(int j=1; j<n; ++j){\\n                if(S[i][0] == S[j][0] || S[i][1] == S[j][1]){\\n                    g[i].push_back(j);\\n                    g[j].push_back(i);\\n                }\\n            }\\n        }\\n    }\\n    void dfs(int node,vector<int> g[],vector<bool>&vis){\\n        vis[node] = 1;\\n        cc++;\\n        for(int&child: g[node]){\\n            if(!vis[child])\\n                dfs(child,g,vis);\\n        }\\n    }\\npublic:\\n    int removeStones(vector<vector<int>>& S) {\\n        int n = size(S), ans = 0;\\n        vector<bool> vis(n,false);\\n        vector<int> g[n];\\n        buildGraph(S,g,n);\\n        // dfs traversal\\n        for(int i=0; i<n; ++i){\\n            if(!vis[i]){\\n                cc = 0;\\n                dfs(i,g,vis);\\n                ans += cc-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass DSU{\\n    private:\\n        const int N = 1e6+10;\\n        vector<int> parent, size, rank;\\n    public:\\n        DSU(){\\n            parent.resize(N);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(N,1);\\n            rank.resize(N,0);\\n        }\\n        DSU(int n){\\n            parent.resize(n+1);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(n+1,1);\\n            rank.resize(n+1,0);\\n        }\\n        int find(int v){\\n            if(parent[v] == v) return v;\\n            //path compression\\n            return parent[v] = find(parent[v]);\\n        }\\n        void unionS(int a,int b){\\n            a = find(a);\\n            b = find(b);\\n            if(a!=b){\\n                //union by size\\n                if(size[a] < size[b]) swap(a,b);\\n                parent[b] = a;\\n                size[a] += size[b];\\n            }\\n        }\\n        void unionR(int x, int y) {\\n            x = find(x), y = find(y);\\n            if(x == y) return;\\n            //union by rank\\n            else if(rank[x] < rank[y]) parent[x] = y;\\n            else if (rank[x] > rank[y]) parent[y] = x;\\n            else parent[y] = x,rank[x]++;\\n      }\\n};\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& S) {\\n        int n = size(S), cc = 0;\\n        DSU ds(n-1);\\n        for(int i=0; i<n; ++i){\\n            for(int j=1; j<n; ++j){\\n                if(S[i][0] == S[j][0] || S[i][1] == S[j][1]){\\n                    ds.unionS(i,j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; ++i) if(ds.find(i) == i) cc++;\\n        return n - cc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056106,
                "title": "c-dsu-explained-with-approach",
                "content": "**Please Upvote if you find the solution helpful :) Will really mean a lot**\\n\\n# Intuition\\nAfter careful observation, we find \\nMax removable stones = n(total stones) - no of components(all stones sharing common row or column are part of component)\\nThis is because for every component, we can remove k - 1 stones, where k is no of stones in that component\\nso (K1 - 1) + (K2 - 1) + (K3 - 1) + .... = (k1 + k2 + k3+...) + (1+1+1+...) = (n - no_of_components)\\n\\n# Approach\\nWe can use Disjoint set to find total no of components.\\nForm components by using the following rule:- if any stone shares a row or column with another stone, they are part of same component.\\nAfter all components are formed, find the no of components(i.e no of ultimate parents)\\nand return ans = n - no_of_components.\\n# Complexity\\n- Time complexity: O(N^2), where N = total no of stones\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(N), where N = total no of stones\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet\\n{\\npublic:\\n    vector<int> parent, size;\\n    DisjointSet(int n)\\n    {\\n        size.resize(n + 1, 1);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++)\\n            parent[i] = i;\\n    }\\n\\n    // methods\\n    int getparent(int node)\\n    {\\n        // if node is itself ultimate parent, return node\\n        if (node == parent[node])\\n            return node;\\n        // path compression\\n        return parent[node] = getparent(parent[node]);\\n    }\\n\\n    void unionbysize(int u, int v)\\n    {\\n        int pu = getparent(u);\\n        int pv = getparent(v);\\n        // if already of same component, then no union needed\\n        if (pu == pv)\\n            return;\\n        // else unionize them\\n        if (size[pu] < size[pv])\\n        {\\n            parent[pu] = pv;\\n            size[pv] += size[pu];\\n        }\\n        else\\n        {\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n    DisjointSet ds(n);\\n\\n    // O(n*n)\\n    // Form components by using the following rule:- \\n    // if any stone shares a row or column with another stone, they are part of same component\\n    for (int i = 0; i < n; i++)\\n    {\\n        int xi = stones[i][0];\\n        int yi = stones[i][1];\\n        for (int j = 0; j < n; j++)\\n        {\\n            int xj = stones[j][0];\\n            int yj = stones[j][1];\\n            // if any common row or column found between 2 stones, unionize them (same component)\\n            if ((xi == xj || yi == yj) && i != j)\\n                ds.unionbysize(i, j);\\n        }\\n    }\\n\\n    // find total components\\n    // no of components = total no of ultimate parents\\n    int cnt = 0;\\n    for (int i = 0; i < n; i++)\\n        if (i == ds.getparent(i))\\n            cnt++;\\n\\n    // Max removable stones = n(total stones) - no of components\\n    return n - cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet\\n{\\npublic:\\n    vector<int> parent, size;\\n    DisjointSet(int n)\\n    {\\n        size.resize(n + 1, 1);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++)\\n            parent[i] = i;\\n    }\\n\\n    // methods\\n    int getparent(int node)\\n    {\\n        // if node is itself ultimate parent, return node\\n        if (node == parent[node])\\n            return node;\\n        // path compression\\n        return parent[node] = getparent(parent[node]);\\n    }\\n\\n    void unionbysize(int u, int v)\\n    {\\n        int pu = getparent(u);\\n        int pv = getparent(v);\\n        // if already of same component, then no union needed\\n        if (pu == pv)\\n            return;\\n        // else unionize them\\n        if (size[pu] < size[pv])\\n        {\\n            parent[pu] = pv;\\n            size[pv] += size[pu];\\n        }\\n        else\\n        {\\n            parent[pv] = pu;\\n            size[pu] += size[pv];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n    DisjointSet ds(n);\\n\\n    // O(n*n)\\n    // Form components by using the following rule:- \\n    // if any stone shares a row or column with another stone, they are part of same component\\n    for (int i = 0; i < n; i++)\\n    {\\n        int xi = stones[i][0];\\n        int yi = stones[i][1];\\n        for (int j = 0; j < n; j++)\\n        {\\n            int xj = stones[j][0];\\n            int yj = stones[j][1];\\n            // if any common row or column found between 2 stones, unionize them (same component)\\n            if ((xi == xj || yi == yj) && i != j)\\n                ds.unionbysize(i, j);\\n        }\\n    }\\n\\n    // find total components\\n    // no of components = total no of ultimate parents\\n    int cnt = 0;\\n    for (int i = 0; i < n; i++)\\n        if (i == ds.getparent(i))\\n            cnt++;\\n\\n    // Max removable stones = n(total stones) - no of components\\n    return n - cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031189,
                "title": "logic-explained-dfs-count-no-of-disconnected-component-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nForm the edge between those point which shares either the same row or the same column.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nX-----X\\n|\\n|\\nX\\n\\nX  represents the node or vertex or points\\n| or -- represents the edge\\n\\nyou can delete atmost 2 point/vertex/node\\n\\nso find the number of diconnected component and subtract it from number of node/vertex/point.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V+E) + space used by recursion\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int>visited;\\n    void dfs(int currNode,vector<int>adj[]){\\n        visited[currNode]=1;\\n        for(auto adjNode:adj[currNode]){\\n            if(!visited[adjNode]){\\n                dfs(adjNode,adj);\\n            }\\n        }\\n    }\\n\\n    int removeStones(vector<vector<int>>& stones) {\\n\\n        int n = stones.size();\\n        ans=0;\\n        vector<int>adj[n];\\n        for(int i=0;i<n;i++){\\n            int xi = stones[i][0];\\n            int yi = stones[i][1];\\n            for(int j=0;j<n;j++){\\n                int xj = stones[j][0];\\n                int yj = stones[j][1];\\n                if((xi==xj || yi==yj) and i!=j){\\n                    adj[i].push_back(j);\\n                }\\n            }\\n        }\\n        visited.resize(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                dfs(i,adj);\\n                ans++;\\n            }\\n        }\\n\\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int>visited;\\n    void dfs(int currNode,vector<int>adj[]){\\n        visited[currNode]=1;\\n        for(auto adjNode:adj[currNode]){\\n            if(!visited[adjNode]){\\n                dfs(adjNode,adj);\\n            }\\n        }\\n    }\\n\\n    int removeStones(vector<vector<int>>& stones) {\\n\\n        int n = stones.size();\\n        ans=0;\\n        vector<int>adj[n];\\n        for(int i=0;i<n;i++){\\n            int xi = stones[i][0];\\n            int yi = stones[i][1];\\n            for(int j=0;j<n;j++){\\n                int xj = stones[j][0];\\n                int yj = stones[j][1];\\n                if((xi==xj || yi==yj) and i!=j){\\n                    adj[i].push_back(j);\\n                }\\n            }\\n        }\\n        visited.resize(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                dfs(i,adj);\\n                ans++;\\n            }\\n        }\\n\\n        return n-ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916427,
                "title": "c-dsu-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(stones.size())\\n\\n- Space complexity:O(r+c)\\n\\n# Code\\n```\\nclass disjointset{\\n    public:\\n    vector<int>par;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        for(int i=0; i<=n; i++){par[i]=i;}\\n    }\\n    int findp(int u){\\n        if(u==par[u]){\\n            return u;\\n        }\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        par[findp(u)]=par[findp(v)];\\n    }\\n};\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int r=0, c=0;\\n        for(auto it: stones){\\n            r=max(r, it[0]);\\n            c=max(c, it[1]);\\n        }\\n        disjointset d(r+c+1);\\n        int cnt=0;\\n        set<int>s;\\n        for(auto it: stones){\\n            d.un(it[0], 1+r+it[1]);\\n            s.insert(it[0]);\\n            s.insert(it[1]+r+1);\\n        }\\n        for(auto it: s){\\n            if(d.findp(it)==it){\\n                cnt++;\\n            }\\n        }\\n        return stones.size()-cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass disjointset{\\n    public:\\n    vector<int>par;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        for(int i=0; i<=n; i++){par[i]=i;}\\n    }\\n    int findp(int u){\\n        if(u==par[u]){\\n            return u;\\n        }\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        par[findp(u)]=par[findp(v)];\\n    }\\n};\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int r=0, c=0;\\n        for(auto it: stones){\\n            r=max(r, it[0]);\\n            c=max(c, it[1]);\\n        }\\n        disjointset d(r+c+1);\\n        int cnt=0;\\n        set<int>s;\\n        for(auto it: stones){\\n            d.un(it[0], 1+r+it[1]);\\n            s.insert(it[0]);\\n            s.insert(it[1]+r+1);\\n        }\\n        for(auto it: s){\\n            if(d.findp(it)==it){\\n                cnt++;\\n            }\\n        }\\n        return stones.size()-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815368,
                "title": "java-solution-with-stone-class-simple-beats-90-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public class Stone{\\n      int row;\\n      int col;\\n      boolean isVisitted = false;\\n      Stone(int row, int col){\\n        this.row = row;\\n        this.col = col;\\n      }\\n    }\\n    Map<Integer, Set<Stone>> rowStonesMap = new HashMap<>();\\n    Map<Integer, Set<Stone>> colStonesMap = new HashMap<>();\\n    \\n    public void dfs(Stone st){\\n      if(st.isVisitted) return;\\n      st.isVisitted = true;\\n      for(Stone vstSt:colStonesMap.get(st.col)){\\n          \\n          dfs(vstSt);\\n      }\\n      for(Stone vstSt:rowStonesMap.get(st.row)){\\n          dfs(vstSt);\\n      }\\n    }\\n\\n    public int removeStones(int[][] stones) {\\n      for(int[] stCoord:stones){\\n        int row = stCoord[0];\\n        int col = stCoord[1];\\n        Stone st = new Stone(row,col);\\n        rowStonesMap.putIfAbsent(row, new HashSet<Stone>());\\n        rowStonesMap.get(row).add(st);\\n        colStonesMap.putIfAbsent(col, new HashSet<Stone>());\\n        colStonesMap.get(col).add(st);\\n      }\\n      int islands = 0;\\n      //let\\'s go throw all stones\\n      for(Set<Stone> setStones:rowStonesMap.values()){\\n        for(Stone st:setStones){\\n          if(st.isVisitted) continue;\\n          islands++;\\n          dfs(st);\\n        }\\n      }\\n      return stones.length - islands;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public class Stone{\\n      int row;\\n      int col;\\n      boolean isVisitted = false;\\n      Stone(int row, int col){\\n        this.row = row;\\n        this.col = col;\\n      }\\n    }\\n    Map<Integer, Set<Stone>> rowStonesMap = new HashMap<>();\\n    Map<Integer, Set<Stone>> colStonesMap = new HashMap<>();\\n    \\n    public void dfs(Stone st){\\n      if(st.isVisitted) return;\\n      st.isVisitted = true;\\n      for(Stone vstSt:colStonesMap.get(st.col)){\\n          \\n          dfs(vstSt);\\n      }\\n      for(Stone vstSt:rowStonesMap.get(st.row)){\\n          dfs(vstSt);\\n      }\\n    }\\n\\n    public int removeStones(int[][] stones) {\\n      for(int[] stCoord:stones){\\n        int row = stCoord[0];\\n        int col = stCoord[1];\\n        Stone st = new Stone(row,col);\\n        rowStonesMap.putIfAbsent(row, new HashSet<Stone>());\\n        rowStonesMap.get(row).add(st);\\n        colStonesMap.putIfAbsent(col, new HashSet<Stone>());\\n        colStonesMap.get(col).add(st);\\n      }\\n      int islands = 0;\\n      //let\\'s go throw all stones\\n      for(Set<Stone> setStones:rowStonesMap.values()){\\n        for(Stone st:setStones){\\n          if(st.isVisitted) continue;\\n          islands++;\\n          dfs(st);\\n        }\\n      }\\n      return stones.length - islands;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814935,
                "title": "c-dfs-readable-code",
                "content": "Similar problem to num of islands\\n\\nWe want to group all stones on the same column/row as 1 connected component. It can be proven that no matter if it\\'s an even or odd number of stones in the connected component, we will remove every stone except 1 last stone. Thus, every different connected component leaves 1 stone.\\n\\nWe return the difference between number of stones and the count of \"islands\" to get the number of stones removed.\\n```\\nclass Solution {\\npublic:\\n    vector<bool> visited;\\n    int removeStones(vector<vector<int>>& stones) {\\n        visited = vector<bool>(stones.size());\\n        int connectedComponents = 0;\\n        for(int i = 0; i < stones.size(); i++) {\\n            if(!visited[i]) {\\n                dfs(stones, visited, i);\\n                connectedComponents++;\\n            }\\n        }\\n        return stones.size() - connectedComponents;\\n    }\\n    \\n    void dfs(vector<vector<int>>& stones, vector<bool> &visited, int i) {\\n        visited[i] = true;\\n        for(int j = 0; j < stones.size(); j++) {\\n            if(visited[j]) continue;\\n\\t\\t\\t// Same row or col\\n            if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\\n                dfs(stones, visited, j);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> visited;\\n    int removeStones(vector<vector<int>>& stones) {\\n        visited = vector<bool>(stones.size());\\n        int connectedComponents = 0;\\n        for(int i = 0; i < stones.size(); i++) {\\n            if(!visited[i]) {\\n                dfs(stones, visited, i);\\n                connectedComponents++;\\n            }\\n        }\\n        return stones.size() - connectedComponents;\\n    }\\n    \\n    void dfs(vector<vector<int>>& stones, vector<bool> &visited, int i) {\\n        visited[i] = true;\\n        for(int j = 0; j < stones.size(); j++) {\\n            if(visited[j]) continue;\\n\\t\\t\\t// Same row or col\\n            if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\\n                dfs(stones, visited, j);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814752,
                "title": "easy-solution-in-c-using-dfs",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int n;\\n    void dfs(vector<vector<int>>& stones, vector<bool>& visited, int idx)\\n    {\\n        visited[idx] = true;\\n        for(int i = 0;i < n; i++)\\n        {\\n            if(visited[i] == false && (stones[idx][0] ==stones[i][0] || stones[idx][1] == stones[i][1])) // checking if not visited and check row by row and column by column\\n            {\\n                dfs(stones,visited,i);\\n            }\\n        }\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) \\n    {\\n        n = stones.size();\\n        vector<bool> visited(n , false);\\n        int count = n;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(visited[i] == true)\\n            {\\n                continue;\\n            }\\n            count--;\\n            dfs(stones , visited , i);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int n;\\n    void dfs(vector<vector<int>>& stones, vector<bool>& visited, int idx)\\n    {\\n        visited[idx] = true;\\n        for(int i = 0;i < n; i++)\\n        {\\n            if(visited[i] == false && (stones[idx][0] ==stones[i][0] || stones[idx][1] == stones[i][1])) // checking if not visited and check row by row and column by column\\n            {\\n                dfs(stones,visited,i);\\n            }\\n        }\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) \\n    {\\n        n = stones.size();\\n        vector<bool> visited(n , false);\\n        int count = n;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(visited[i] == true)\\n            {\\n                continue;\\n            }\\n            count--;\\n            dfs(stones , visited , i);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814684,
                "title": "java-graph-dfs-easy-solution",
                "content": "**PLEASE UPVOTE GUYS :(((**\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        boolean visited[] = new boolean[stones.length];\\n        int group = 0;\\n        for(int i=0;i<stones.length;i++){\\n            if(visited[i] != true){\\n                visited[i] = true;\\n                dfs(i, visited, stones);\\n                group++;\\n            }\\n        }\\n        return stones.length - group;\\n    }\\n    public void dfs(int indx, boolean[] visited, int[][] stones){\\n     for(int i=0;i<stones.length;i++){\\n         if(!visited[i] && (stones[i][0] == stones[indx][0] || stones[i][1] == stones[indx][1])){\\n             visited[i] = true;\\n             dfs(i, visited, stones);\\n         }\\n     }   \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int removeStones(int[][] stones) {\\n        boolean visited[] = new boolean[stones.length];\\n        int group = 0;\\n        for(int i=0;i<stones.length;i++){\\n            if(visited[i] != true){\\n                visited[i] = true;\\n                dfs(i, visited, stones);\\n                group++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2814516,
                "title": "c-dsu-union-find-graph",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rank, parent;\\n    int find(int a) {\\n        if(a == parent[a])\\n            return a;\\n        return parent[a] = find(parent[a]);\\n    }\\n    void Union(int a, int b) {\\n        int x = find(a), y = find(b);\\n        if(x != y) {\\n            if(rank[x] > rank[y]) \\n                parent[y] = x;\\n            else if(rank[x] < rank[y]) \\n                parent[x] = y;\\n            else {\\n                parent[y] = x;\\n                rank[x] += 1;\\n            }\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int maxRow = 0, maxCol = 0, res = 0;\\n        for(auto i : stones) {\\n            maxRow = max(maxRow, i[0]);\\n            maxCol = max(maxCol, i[1]);\\n        }\\n        int n = maxRow + maxCol + 2;\\n        rank.resize(n);\\n        parent.resize(n);\\n        for(int i = 0; i < n; i++)\\n            rank[i] = 0;\\n        for(int i = 0; i < n; i++)\\n            parent[i] = i;\\n        unordered_set<int> st;\\n        for(auto it : stones) {\\n            int a = it[0], b = it[1] + maxRow + 1;\\n            Union(a, b);\\n            st.insert(a);\\n            st.insert(b);\\n        }\\n        for(auto i : st) {\\n            if(find(i) == i)\\n                res++;\\n        }\\n        return stones.size() - res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rank, parent;\\n    int find(int a) {\\n        if(a == parent[a])\\n            return a;\\n        return parent[a] = find(parent[a]);\\n    }\\n    void Union(int a, int b) {\\n        int x = find(a), y = find(b);\\n        if(x != y) {\\n            if(rank[x] > rank[y]) \\n                parent[y] = x;\\n            else if(rank[x] < rank[y]) \\n                parent[x] = y;\\n            else {\\n                parent[y] = x;\\n                rank[x] += 1;\\n            }\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int maxRow = 0, maxCol = 0, res = 0;\\n        for(auto i : stones) {\\n            maxRow = max(maxRow, i[0]);\\n            maxCol = max(maxCol, i[1]);\\n        }\\n        int n = maxRow + maxCol + 2;\\n        rank.resize(n);\\n        parent.resize(n);\\n        for(int i = 0; i < n; i++)\\n            rank[i] = 0;\\n        for(int i = 0; i < n; i++)\\n            parent[i] = i;\\n        unordered_set<int> st;\\n        for(auto it : stones) {\\n            int a = it[0], b = it[1] + maxRow + 1;\\n            Union(a, b);\\n            st.insert(a);\\n            st.insert(b);\\n        }\\n        for(auto i : st) {\\n            if(find(i) == i)\\n                res++;\\n        }\\n        return stones.size() - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814485,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n, vis[1005];\\n\\n    bool check(vector<int> &stones1 ,vector<int> &stones2) {\\n        if(stones1[0] == stones2[0] or stones1[1] == stones2[1]) return true;\\n        return false;\\n    }\\n\\n    void dfs(int u, vector<vector<int>>& stones) {\\n        vis[u] = 1;\\n        for(int v=0; v<n; v++) {\\n            if(!vis[v] and check(stones[u], stones[v])) {\\n                dfs(v, stones);\\n            }\\n        }\\n    }\\n\\n    int removeStones(vector<vector<int>>& stones) {\\n        memset(vis, 0, sizeof(vis));\\n        n = stones.size();\\n\\n        int cnt = 0;\\n        for(int u=0; u<n; u++) {\\n            if(!vis[u]) {\\n                cnt++;\\n                dfs(u, stones);\\n            }\\n        }\\n\\n        int ans = n - cnt;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, vis[1005];\\n\\n    bool check(vector<int> &stones1 ,vector<int> &stones2) {\\n        if(stones1[0] == stones2[0] or stones1[1] == stones2[1]) return true;\\n        return false;\\n    }\\n\\n    void dfs(int u, vector<vector<int>>& stones) {\\n        vis[u] = 1;\\n        for(int v=0; v<n; v++) {\\n            if(!vis[v] and check(stones[u], stones[v])) {\\n                dfs(v, stones);\\n            }\\n        }\\n    }\\n\\n    int removeStones(vector<vector<int>>& stones) {\\n        memset(vis, 0, sizeof(vis));\\n        n = stones.size();\\n\\n        int cnt = 0;\\n        for(int u=0; u<n; u++) {\\n            if(!vis[u]) {\\n                cnt++;\\n                dfs(u, stones);\\n            }\\n        }\\n\\n        int ans = n - cnt;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814392,
                "title": "faster-than-98-5-less-memory-than-86-5",
                "content": "# Intuition\\nMy first intuition was wrong: I tried removing the stones that had fewest neighbors first, not counting those that had zero neighbors. This approach worked in about 2/3 of the the cases.\\n\\n# Approach\\nThe correct approach is to count connected components. The final answer is the total number of stones minus the number of connected components, because in each connected component there is one stone that cannot be removed.\\n\\n# Complexity\\n- Time complexity: Linear, $O(n)$.\\n\\n- Space complexity: Also linear.\\n\\n# Code\\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        h=defaultdict(list)\\n        v=defaultdict(list)\\n        for i, s in enumerate(stones):\\n            h[s[0]].append(i)\\n            v[s[1]].append(i)\\n        l=len(stones)\\n        g=[[] for i in range(l)]\\n        vlist=[0]*l\\n        for i, s in enumerate(stones):\\n            g[i]+=[j for j in h[s[0]] if j!=i]\\n            g[i]+=[j for j in v[s[1]] if j!=i]\\n        ans=l\\n        for i in range(l):\\n            if not vlist[i]:\\n                vlist[i]=1\\n                ans-=1\\n                q=[i]\\n                curs=0\\n                while curs<len(q):\\n                    tmp=q[curs]\\n                    for j in g[tmp]:\\n                        if not vlist[j]:\\n                            vlist[j]=1\\n                            q.append(j)\\n                    curs+=1\\n        return ans\\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        h=defaultdict(list)\\n        v=defaultdict(list)\\n        for i, s in enumerate(stones):\\n            h[s[0]].append(i)\\n            v[s[1]].append(i)\\n        l=len(stones)\\n        g=[[] for i in range(l)]\\n        vlist=[0]*l\\n        for i, s in enumerate(stones):\\n            g[i]+=[j for j in h[s[0]] if j!=i]\\n            g[i]+=[j for j in v[s[1]] if j!=i]\\n        ans=l\\n        for i in range(l):\\n            if not vlist[i]:\\n                vlist[i]=1\\n                ans-=1\\n                q=[i]\\n                curs=0\\n                while curs<len(q):\\n                    tmp=q[curs]\\n                    for j in g[tmp]:\\n                        if not vlist[j]:\\n                            vlist[j]=1\\n                            q.append(j)\\n                    curs+=1\\n        return ans\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814281,
                "title": "c-using-dfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int curr, vector<int> adjList[], vector<bool> &visited, int &len) {\\n\\t\\t\\tif(visited[curr]) return;\\n\\t\\t\\tvisited[curr] = true;\\n\\t\\t\\tlen++;\\n\\t\\t\\tfor(int next: adjList[curr]) {\\n\\t\\t\\t\\tdfs(next, adjList, visited, len);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint removeStones(vector<vector<int>>& stones) {\\n\\t\\t\\tint n = stones.size();\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tvector<int> adjList[n];\\n\\t\\t\\tvector<bool> visited(n);\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tfor(int j = i + 1; j < n; j++) {\\n\\t\\t\\t\\t\\tif(stones[i][0] - stones[j][0] == 0 || stones[i][1] - stones[j][1] == 0) {\\n\\t\\t\\t\\t\\t\\tadjList[i].push_back(j);\\n\\t\\t\\t\\t\\t\\tadjList[j].push_back(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < n; i++) {\\n\\t\\t\\t\\tif(!visited[i]) {\\n\\t\\t\\t\\t\\tint len = 0;\\n\\t\\t\\t\\t\\tdfs(i, adjList, visited, len);\\n\\t\\t\\t\\t\\tans += len - 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int curr, vector<int> adjList[], vector<bool> &visited, int &len) {\\n\\t\\t\\tif(visited[curr]) return;\\n\\t\\t\\tvisited[curr] = true;\\n\\t\\t\\tlen++;\\n\\t\\t\\tfor(int next: adjList[curr]) {\\n\\t\\t\\t\\tdfs(next, adjList, visited, len);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2814278,
                "title": "c-disjoint-set-union",
                "content": "\\n\\n# Code\\n```\\nclass DisjointSet {\\n     \\npublic: \\n    vector<int> rank, parent, size;\\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n}; \\nclass Solution {\\n    \\npublic:\\n    bool inSame(vector<int>&x,vector<int>&y){\\n        return (x[0]==y[0] || x[1]==y[1]);\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        //our ans is = no of stones - no of strongly connected graph\\n        int n = stones.size();\\n        DisjointSet ds(n);\\n        for(int i=0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                if(inSame(stones[i],stones[j])){\\n                    ds.unionByRank(i,j);\\n                }\\n            }\\n        }\\n        int nCom = 0;\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i]==i)nCom++;\\n        }\\n        return n-nCom;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\n     \\npublic: \\n    vector<int> rank, parent, size;\\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n}; \\nclass Solution {\\n    \\npublic:\\n    bool inSame(vector<int>&x,vector<int>&y){\\n        return (x[0]==y[0] || x[1]==y[1]);\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        //our ans is = no of stones - no of strongly connected graph\\n        int n = stones.size();\\n        DisjointSet ds(n);\\n        for(int i=0;i<n;i++){\\n            for(int j = i+1;j<n;j++){\\n                if(inSame(stones[i],stones[j])){\\n                    ds.unionByRank(i,j);\\n                }\\n            }\\n        }\\n        int nCom = 0;\\n        for(int i=0;i<n;i++){\\n            if(ds.parent[i]==i)nCom++;\\n        }\\n        return n-nCom;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814270,
                "title": "python-graph-dfs-76-faster-easy-clean-code-count-no-of-islands-easy-explanation",
                "content": "We can imagine all the points as 1 on **matrix** and relate this question with **Count no of islands** (only difference is that here the island is **connected even if it is in same row or same col**).\\nThen we just need to return **len(stones) - no_of_islands**, because we need to keep atleast one of the stone from each island.\\nSo for the first example:\\nstones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nwe can imagine it as\\n[[1, 1, 0]\\n [1, 0, 1]\\n [0, 1, 1]]\\n now when we apply our algorithm, we will get no_of_islands = 1.\\n So **answer = len(stones)-no_of_islands = 6-1 = 5.**\\n Do **Upvote** if this helped you!\\n Also **comment** your approach, would love to see new approach.\\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        # dfs\\n        # storing index in visited\\n        visited = set()\\n\\t\\t# storing index of all stones coming in same row(in rows) and same col(in cols)\\n        cols = {}\\n        rows = {}\\n        for i in range(len(stones)):\\n            stone = stones[i]\\n            row, col = stone\\n            if row in rows:\\n                rows[row].append(i)\\n            else:\\n                rows[row] = [i]\\n            \\n            if col in cols:\\n                cols[col].append(i)\\n            else:\\n                cols[col] = [i]\\n         \\n\\t\\t # almost similar to calculate no of islands.\\n        answer = 0\\n        for i in range(len(stones)):\\n            if i in visited:\\n                continue\\n            \\n            answer+=1\\n            self.dfs(stones, rows, cols, i, visited)\\n        \\n        return len(stones)-answer\\n    \\n    def dfs(self, stones, rows, cols, currIdx, visited):\\n        if currIdx in visited:\\n            return\\n        \\n        visited.add(currIdx)\\n        \\n        currRow, currCol = stones[currIdx]\\n        \\n\\t\\t# it is connected if in same row\\n        for nextIdx in rows[currRow]:\\n            if nextIdx==currIdx:\\n                continue\\n            self.dfs(stones, rows, cols, nextIdx, visited)\\n        \\n\\t\\t# it is connected if in same col\\n        for nextIdx in cols[currCol]:\\n            if nextIdx==currIdx:\\n                continue\\n            self.dfs(stones, rows, cols, nextIdx, visited)\\n        \\n        return\\n            \\n```\\n\\n![image](https://assets.leetcode.com/users/images/7149b33c-c6b3-46f5-8362-333d6af99b10_1668439243.398902.png)\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        # dfs\\n        # storing index in visited\\n        visited = set()\\n\\t\\t# storing index of all stones coming in same row(in rows) and same col(in cols)\\n        cols = {}\\n        rows = {}\\n        for i in range(len(stones)):\\n            stone = stones[i]\\n            row, col = stone\\n            if row in rows:\\n                rows[row].append(i)\\n            else:\\n                rows[row] = [i]\\n            \\n            if col in cols:\\n                cols[col].append(i)\\n            else:\\n                cols[col] = [i]\\n         \\n\\t\\t # almost similar to calculate no of islands.\\n        answer = 0\\n        for i in range(len(stones)):\\n            if i in visited:\\n                continue\\n            \\n            answer+=1\\n            self.dfs(stones, rows, cols, i, visited)\\n        \\n        return len(stones)-answer\\n    \\n    def dfs(self, stones, rows, cols, currIdx, visited):\\n        if currIdx in visited:\\n            return\\n        \\n        visited.add(currIdx)\\n        \\n        currRow, currCol = stones[currIdx]\\n        \\n\\t\\t# it is connected if in same row\\n        for nextIdx in rows[currRow]:\\n            if nextIdx==currIdx:\\n                continue\\n            self.dfs(stones, rows, cols, nextIdx, visited)\\n        \\n\\t\\t# it is connected if in same col\\n        for nextIdx in cols[currCol]:\\n            if nextIdx==currIdx:\\n                continue\\n            self.dfs(stones, rows, cols, nextIdx, visited)\\n        \\n        return\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814190,
                "title": "c-solution-easy-explanation-with-diagram",
                "content": "# Intuition\\nWe can think of each stone as a Node and the edges of that node goes to the stone/Node which has the same row or column.\\n\\nfor Example -> \\n\\n```\\nNode/stone ->   0       1       2       3       4\\nif stones = { {0,1} , {0,2} , {1,2} , {3,5} , {3,3} } ;\\n\\nthen we will have a graph that looks like this - > \\n\\n                                                    Stone/Node (x,y) \\n5 |                                    3 (3,5)\\n  |                                    |\\n4 |                                    |\\n  |                                    |   \\n3 |                                    4 (3,3)\\n  |\\n2 |        1 (0,2) - 2 (1,2)   \\n  |        |\\n1 |        0 (0,1)\\n  |\\n0 |_________________________________________________\\n           0         1        2        3\\n\\nHere , we have 2 separate graphs ( 0,1,2 ) and (3,4) ...\\nwe just need to find \\n\\nnumber of connected components in each graph - 1\\n\\nand add those.\\n\\nhere I am using bfs to find connected components because it was most intuitive for me, you can try union-find or dfs as others have done.\\n\\n```\\n# Complexity\\n- Time complexity: Number of nodes/stones which is just equal to size of stones \\n= $$O(N)$$ \\n\\n- Space complexity: As much needed to store the adjacency list which is \\n=  $$O(N + E)$$ \\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate : \\n    int ans = 0 ;\\n    unordered_map<int,bool> visited ;\\npublic:\\n    int bfs( int index , unordered_map<int,  vector<int>> &adj ){     \\n        int connected_components = 0 ;  \\n        queue<int> q ;\\n        q.push(index) ;\\n        visited[index] = true ;\\n        while(!q.empty()){\\n            int idx = q.front() ; q.pop() ;\\n            auto curr = adj[idx] ;\\n            for( auto node : curr ) {\\n                if(visited[node]) continue ;\\n                q.push(node) ;\\n                visited[node] = true ;\\n                connected_components++ ;\\n            }\\n        }\\n        return connected_components ;\\n    }\\n\\n    int removeStones(vector<vector<int>>& stones) {\\n        unordered_map<int, vector<int>> adj ;\\n        unordered_map<int ,vector<int>> x , y ;\\n        \\n        for( int i = 0 ; i < stones.size() ; i ++ ){\\n            for(auto xx : x[stones[i][0]] ) {  \\n                adj[i].push_back( xx ) ;\\n                adj[xx].push_back( i ) ;\\n            }\\n            for(auto yy : y[stones[i][1]]) {\\n                adj[i].push_back( yy ) ;\\n                adj[yy].push_back( i ) ;\\n            }\\n            x[stones[i][0]].push_back(i) ;\\n            y[stones[i][1]].push_back(i) ;    \\n        }\\n\\n        for(auto node : adj ) {\\n            if( visited[node.first] ) continue ;\\n            ans += bfs ( node.first , adj ) ;\\n        }\\n\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nNode/stone ->   0       1       2       3       4\\nif stones = { {0,1} , {0,2} , {1,2} , {3,5} , {3,3} } ;\\n\\nthen we will have a graph that looks like this - > \\n\\n                                                    Stone/Node (x,y) \\n5 |                                    3 (3,5)\\n  |                                    |\\n4 |                                    |\\n  |                                    |   \\n3 |                                    4 (3,3)\\n  |\\n2 |        1 (0,2) - 2 (1,2)   \\n  |        |\\n1 |        0 (0,1)\\n  |\\n0 |_________________________________________________\\n           0         1        2        3\\n\\nHere , we have 2 separate graphs ( 0,1,2 ) and (3,4) ...\\nwe just need to find \\n\\nnumber of connected components in each graph - 1\\n\\nand add those.\\n\\nhere I am using bfs to find connected components because it was most intuitive for me, you can try union-find or dfs as others have done.\\n\\n```\n```\\nclass Solution {\\nprivate : \\n    int ans = 0 ;\\n    unordered_map<int,bool> visited ;\\npublic:\\n    int bfs( int index , unordered_map<int,  vector<int>> &adj ){     \\n        int connected_components = 0 ;  \\n        queue<int> q ;\\n        q.push(index) ;\\n        visited[index] = true ;\\n        while(!q.empty()){\\n            int idx = q.front() ; q.pop() ;\\n            auto curr = adj[idx] ;\\n            for( auto node : curr ) {\\n                if(visited[node]) continue ;\\n                q.push(node) ;\\n                visited[node] = true ;\\n                connected_components++ ;\\n            }\\n        }\\n        return connected_components ;\\n    }\\n\\n    int removeStones(vector<vector<int>>& stones) {\\n        unordered_map<int, vector<int>> adj ;\\n        unordered_map<int ,vector<int>> x , y ;\\n        \\n        for( int i = 0 ; i < stones.size() ; i ++ ){\\n            for(auto xx : x[stones[i][0]] ) {  \\n                adj[i].push_back( xx ) ;\\n                adj[xx].push_back( i ) ;\\n            }\\n            for(auto yy : y[stones[i][1]]) {\\n                adj[i].push_back( yy ) ;\\n                adj[yy].push_back( i ) ;\\n            }\\n            x[stones[i][0]].push_back(i) ;\\n            y[stones[i][1]].push_back(i) ;    \\n        }\\n\\n        for(auto node : adj ) {\\n            if( visited[node.first] ) continue ;\\n            ans += bfs ( node.first , adj ) ;\\n        }\\n\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814094,
                "title": "java-using-unionfind-datastructure-with-a-reusable-union-find-template",
                "content": "This is a reusable union find template that can solve many question:\\n\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/unionfind/UnionFind.java\\n\\n\\nThis is the solution to this problem using the template\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/unionfind/MostStonesRemoved.java",
                "solutionTags": [
                    "Java"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2814068,
                "title": "python-clean-union-find-and-dfs-solutions",
                "content": "Imports and constants,\\n\\n```\\nfrom collections import Counter\\nfrom dataclasses import dataclass\\nfrom functools import cached_property\\nfrom typing import Generic, TypeVar\\n\\nT = TypeVar(\\'T\\')\\n```\\n\\nSolution,\\n\\n```python\\nclass Solution:\\n    def removeStones(self, stones: list[list[int]]) -> int:\\n        # return self.depth_first_search(stones)\\n        return self.union_find(stones)\\n\\n    @staticmethod\\n    def union_find(stones: list[list[int]]) -> int:\\n        \"\"\"\\n        @see https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)\\n        :param stones:\\n        :return:\\n        \"\"\"\\n        uf = UF[int]()  # can also use UF()\\n\\n        for u, v in stones:\\n            \"\"\"\\n            instead of ~v, we can use any one to one mapping such that it does not \\n            intersect with any value of u. So one idea is to map column values to \\n            negative of it -1. That is what we are using it. So,\\n            \\n            f(v) = ~v\\n                 = -v - 1\\n            \\n            Other options for f could be,\\n            \\n            f(v) = v + (1 + MAX_POSSIBLE_VALUE_OF_u)\\n            f(v) = -(v + x) where x is any fix positive number\\n            ... so on\\n            \"\"\"\\n            uf.union(u, ~v)\\n\\n        return len(stones) - uf.components\\n\\n    @staticmethod\\n    def depth_first_search(stones: list[list[int]]) -> int:\\n        \"\"\"\\n        @see https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/209369/Java-recursive-DFS-Short-and-easy-to-understand\\n        :param stones:\\n        :return:\\n        \"\"\"\\n        visited = set()\\n\\n        def dfs(r: int, c: int):\\n            visited.add((r, c))\\n\\n            for x, y in stones:\\n                if (x, y) not in visited and (x == r or y == c):\\n                    dfs(x, y)\\n\\n        components = 0\\n\\n        for i, j in stones:\\n            if (i, j) not in visited:\\n                dfs(i, j)\\n                components += 1\\n\\n        return len(stones) - components\\n```\\n\\nDefinition of **UF**,\\n\\n```python\\n@dataclass\\nclass UF(Generic[T]):\\n    \"\"\"\\n    Implementing union find algorithm\\n    \"\"\"\\n\\n    def find(self, u: T) -> T:\\n        self.check(u)\\n\\n        return self._find(u)\\n\\n    def _find(self, u: T) -> T:\\n        \"\"\"\\n        :return: representative node of cluster containing node \"u\"\\n        \"\"\"\\n        parent = self._parent\\n\\n        if u != (pu := parent[u]):\\n            parent[u] = self._find(pu)  # path compression\\n\\n        return parent[u]\\n\\n    def union(self, u: T, v: T) -> bool:\\n        \"\"\"\\n        merging clusters containing node \"u\" and node \"v\"\\n        :param u:\\n        :param v:\\n        :return: True if union/merge is needed else False\\n        \"\"\"\\n        self.check(u)\\n        self.check(v)\\n\\n        root_u, root_v = self.find(u), self.find(v)\\n\\n        if root_u == root_v:\\n            # merge not required as they belong to same cluster\\n            return False\\n        else:\\n            self._merge_roots(root_u, root_v)\\n            return True\\n\\n    def check(self, u: T):\\n        \"\"\"\\n        if node \"u\" is not in seen nodes then updating parent mapping\\n        :param u:\\n        \"\"\"\\n        self._parent.setdefault(u, u)  # if u not in self._parent then it becomes parent to itself\\n\\n    def _merge_roots(self, u: T, v: T):\\n        \"\"\"\\n        \"u\" and \"v\" are root nodes of two different clusters and the two\\n        clusters are to be merged. In this function, we determine which\\n        node should be made parent using rank and update parent accordingly.\\n\\n        Node with higher rank is made parent and in case of tie, \"v\" (\"u\" can\\n        also be chosen) node is chosen as parent and its rank is incremented\\n        by 1\\n\\n        :param u:\\n        :param v:\\n        \"\"\"\\n        rank = self._rank\\n\\n        if rank[u] > rank[v]:\\n            self._parent[v] = u\\n        else:\\n            self._parent[u] = v\\n\\n            if rank[u] == rank[v]:\\n                self._rank[v] += 1\\n\\n    @cached_property\\n    def _parent(self) -> dict[T, T]:\\n        \"\"\"\\n        :return: mapping from a node to its parent\\n        \"\"\"\\n        return {}\\n\\n    @cached_property\\n    def _rank(self) -> Counter[T]:\\n        \"\"\"\\n        :return: mapping from a node to its rank. Rank is used while merging clusters\\n        \"\"\"\\n        return Counter()\\n\\n    @property\\n    def components(self) -> int:\\n        return sum(u == p for u, p in self._parent.items())\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nfrom collections import Counter\\nfrom dataclasses import dataclass\\nfrom functools import cached_property\\nfrom typing import Generic, TypeVar\\n\\nT = TypeVar(\\'T\\')\\n```\n```python\\nclass Solution:\\n    def removeStones(self, stones: list[list[int]]) -> int:\\n        # return self.depth_first_search(stones)\\n        return self.union_find(stones)\\n\\n    @staticmethod\\n    def union_find(stones: list[list[int]]) -> int:\\n        \"\"\"\\n        @see https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)\\n        :param stones:\\n        :return:\\n        \"\"\"\\n        uf = UF[int]()  # can also use UF()\\n\\n        for u, v in stones:\\n            \"\"\"\\n            instead of ~v, we can use any one to one mapping such that it does not \\n            intersect with any value of u. So one idea is to map column values to \\n            negative of it -1. That is what we are using it. So,\\n            \\n            f(v) = ~v\\n                 = -v - 1\\n            \\n            Other options for f could be,\\n            \\n            f(v) = v + (1 + MAX_POSSIBLE_VALUE_OF_u)\\n            f(v) = -(v + x) where x is any fix positive number\\n            ... so on\\n            \"\"\"\\n            uf.union(u, ~v)\\n\\n        return len(stones) - uf.components\\n\\n    @staticmethod\\n    def depth_first_search(stones: list[list[int]]) -> int:\\n        \"\"\"\\n        @see https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/209369/Java-recursive-DFS-Short-and-easy-to-understand\\n        :param stones:\\n        :return:\\n        \"\"\"\\n        visited = set()\\n\\n        def dfs(r: int, c: int):\\n            visited.add((r, c))\\n\\n            for x, y in stones:\\n                if (x, y) not in visited and (x == r or y == c):\\n                    dfs(x, y)\\n\\n        components = 0\\n\\n        for i, j in stones:\\n            if (i, j) not in visited:\\n                dfs(i, j)\\n                components += 1\\n\\n        return len(stones) - components\\n```\n```python\\n@dataclass\\nclass UF(Generic[T]):\\n    \"\"\"\\n    Implementing union find algorithm\\n    \"\"\"\\n\\n    def find(self, u: T) -> T:\\n        self.check(u)\\n\\n        return self._find(u)\\n\\n    def _find(self, u: T) -> T:\\n        \"\"\"\\n        :return: representative node of cluster containing node \"u\"\\n        \"\"\"\\n        parent = self._parent\\n\\n        if u != (pu := parent[u]):\\n            parent[u] = self._find(pu)  # path compression\\n\\n        return parent[u]\\n\\n    def union(self, u: T, v: T) -> bool:\\n        \"\"\"\\n        merging clusters containing node \"u\" and node \"v\"\\n        :param u:\\n        :param v:\\n        :return: True if union/merge is needed else False\\n        \"\"\"\\n        self.check(u)\\n        self.check(v)\\n\\n        root_u, root_v = self.find(u), self.find(v)\\n\\n        if root_u == root_v:\\n            # merge not required as they belong to same cluster\\n            return False\\n        else:\\n            self._merge_roots(root_u, root_v)\\n            return True\\n\\n    def check(self, u: T):\\n        \"\"\"\\n        if node \"u\" is not in seen nodes then updating parent mapping\\n        :param u:\\n        \"\"\"\\n        self._parent.setdefault(u, u)  # if u not in self._parent then it becomes parent to itself\\n\\n    def _merge_roots(self, u: T, v: T):\\n        \"\"\"\\n        \"u\" and \"v\" are root nodes of two different clusters and the two\\n        clusters are to be merged. In this function, we determine which\\n        node should be made parent using rank and update parent accordingly.\\n\\n        Node with higher rank is made parent and in case of tie, \"v\" (\"u\" can\\n        also be chosen) node is chosen as parent and its rank is incremented\\n        by 1\\n\\n        :param u:\\n        :param v:\\n        \"\"\"\\n        rank = self._rank\\n\\n        if rank[u] > rank[v]:\\n            self._parent[v] = u\\n        else:\\n            self._parent[u] = v\\n\\n            if rank[u] == rank[v]:\\n                self._rank[v] += 1\\n\\n    @cached_property\\n    def _parent(self) -> dict[T, T]:\\n        \"\"\"\\n        :return: mapping from a node to its parent\\n        \"\"\"\\n        return {}\\n\\n    @cached_property\\n    def _rank(self) -> Counter[T]:\\n        \"\"\"\\n        :return: mapping from a node to its rank. Rank is used while merging clusters\\n        \"\"\"\\n        return Counter()\\n\\n    @property\\n    def components(self) -> int:\\n        return sum(u == p for u, p in self._parent.items())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813419,
                "title": "recursive-c",
                "content": "# Intuition\\nAfter many tries i have found a good hint, you can visualize the path as a tree, with every stone that derive from the root can be remove\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing an array of bools i can know if the stone is already been deleted and handle the cases\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int RemoveStones(int[][] stones)\\n    {\\n        var isRemovedSet = new bool[stones.Length];\\n        for (var s = 0; s < stones.Length; s++)\\n            if(!isRemovedSet[s]) RemoveStone(stones, isRemovedSet, s, s);\\n\\n        return isRemovedSet.Count(x => x);\\n    }\\n\\n    private void RemoveStone(int[][] stones, bool[] isRemoved, int cs, int initialIndex)\\n    {\\n        for (var s = 0; s < stones.Length; s++)\\n        {\\n            if(isRemoved[s] || initialIndex == s) continue;\\n            if ((stones[cs][0] - stones[s][0] == 0) != (stones[cs][1] - stones[s][1] == 0)) // XOR\\n            {\\n                isRemoved[s] = true;\\n                RemoveStone(stones, isRemoved, s, initialIndex);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int RemoveStones(int[][] stones)\\n    {\\n        var isRemovedSet = new bool[stones.Length];\\n        for (var s = 0; s < stones.Length; s++)\\n            if(!isRemovedSet[s]) RemoveStone(stones, isRemovedSet, s, s);\\n\\n        return isRemovedSet.Count(x => x);\\n    }\\n\\n    private void RemoveStone(int[][] stones, bool[] isRemoved, int cs, int initialIndex)\\n    {\\n        for (var s = 0; s < stones.Length; s++)\\n        {\\n            if(isRemoved[s] || initialIndex == s) continue;\\n            if ((stones[cs][0] - stones[s][0] == 0) != (stones[cs][1] - stones[s][1] == 0)) // XOR\\n            {\\n                isRemoved[s] = true;\\n                RemoveStone(stones, isRemoved, s, initialIndex);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813221,
                "title": "c-union-find-explained",
                "content": "**Observation:**\\na stone connects the row and column in which it is present\\nif we see one such connected component of rows and columns \\n\\neg. stone at [0, 1], [0, 3], [2, 1] all are connected by either same row or column\\nwe can remove all stones from one connected component except one\\n\\nConnected components will have same parents\\ntotal stones - no. of parents = no. of stones that can be removed\\n\\n**If it helps, please UPVOTE : )**\\n```\\nclass Solution {\\npublic:\\n    vector<int> parent, rank;\\n    \\n    int find(int x)\\n    {\\n        if(parent[x] == x)\\n            return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void _union(int x, int y)\\n    {\\n        int xRoot = find(x), yRoot = find(y);\\n        \\n        if(xRoot == yRoot)\\n            return;\\n        \\n        if(rank[xRoot] < rank[yRoot])\\n            parent[xRoot] = yRoot;\\n        \\n        else if(rank[xRoot] > rank[yRoot])\\n            parent[yRoot] = xRoot;\\n        \\n        else\\n        {\\n            parent[yRoot] = xRoot;\\n            rank[xRoot]++;\\n        }\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) \\n    {\\n        int n = stones.size();\\n        \\n        parent.resize(20002);           //0 <= xi, yi <= 10000, row = 0 to 10000 col = 10001 to 20001\\n        rank.resize(20002, 0);\\n        \\n        for(int i=0; i<20002; i++)      //initially apna parent khud\\n            parent[i] = i;\\n        \\n        for(auto i: stones)\\n            _union(i[0], 10001+i[1]);   //stone unifies x and y indices, unite row & col indices\\n        \\n        set<int> component;\\n        for(auto i: stones)\\n            component.insert(find(i[0])); //parents of all stones inserted(search only for i[0] because it is obvious i[0] and i[1] are connected and will have same parent \\n        \\n        return n - component.size();      //for each component, one stone cannot be removed\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent, rank;\\n    \\n    int find(int x)\\n    {\\n        if(parent[x] == x)\\n            return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void _union(int x, int y)\\n    {\\n        int xRoot = find(x), yRoot = find(y);\\n        \\n        if(xRoot == yRoot)\\n            return;\\n        \\n        if(rank[xRoot] < rank[yRoot])\\n            parent[xRoot] = yRoot;\\n        \\n        else if(rank[xRoot] > rank[yRoot])\\n            parent[yRoot] = xRoot;\\n        \\n        else\\n        {\\n            parent[yRoot] = xRoot;\\n            rank[xRoot]++;\\n        }\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) \\n    {\\n        int n = stones.size();\\n        \\n        parent.resize(20002);           //0 <= xi, yi <= 10000, row = 0 to 10000 col = 10001 to 20001\\n        rank.resize(20002, 0);\\n        \\n        for(int i=0; i<20002; i++)      //initially apna parent khud\\n            parent[i] = i;\\n        \\n        for(auto i: stones)\\n            _union(i[0], 10001+i[1]);   //stone unifies x and y indices, unite row & col indices\\n        \\n        set<int> component;\\n        for(auto i: stones)\\n            component.insert(find(i[0])); //parents of all stones inserted(search only for i[0] because it is obvious i[0] and i[1] are connected and will have same parent \\n        \\n        return n - component.size();      //for each component, one stone cannot be removed\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813188,
                "title": "c-dfs-graph-faster-easy-to-understand",
                "content": "* ***Using DFS***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<vector<int>>& points, int u, int n, vector<bool>& vis)\\n    {\\n        // mark the curr point as visited\\n\\n        vis[u] = true;\\n\\n        // traverse over all the points, if the point is not visited and the point is either in horizontal or vertical direction, then call dfs\\n\\n        for(int v = 0; v < n; v++)\\n        {\\n            if(vis[v] == false && (points[u][0] == points[v][0] || points[u][1] == points[v][1]))\\n            {\\n                dfs(points, v, n, vis);\\n            }\\n        }\\n    }\\n\\n    int removeStones(vector<vector<int>>& points) {\\n\\n        int n = points.size();\\n\\n        // declare a visited array\\n\\n        // initially all the points are unvisited\\n\\n        vector<bool> vis(n, false);\\n\\n        // we can\\'t remove all the points of a connected component one point will remain unremoved\\n\\n        // count will store the no. of connected components\\n\\n        int count = 0;\\n\\n        // traverse over points \\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            // if the point is not visited then call dfs\\n\\n            if(vis[i] == false)\\n            {\\n                dfs(points, i, n, vis);\\n\\n                // increment count\\n\\n                count++;\\n            }\\n        }\\n\\n        // count will be the no. of unremoved points\\n\\n        // n - count will be no. of removed points\\n\\n        return n - count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<vector<int>>& points, int u, int n, vector<bool>& vis)\\n    {\\n        // mark the curr point as visited\\n\\n        vis[u] = true;\\n\\n        // traverse over all the points, if the point is not visited and the point is either in horizontal or vertical direction, then call dfs\\n\\n        for(int v = 0; v < n; v++)\\n        {\\n            if(vis[v] == false && (points[u][0] == points[v][0] || points[u][1] == points[v][1]))\\n            {\\n                dfs(points, v, n, vis);\\n            }\\n        }\\n    }\\n\\n    int removeStones(vector<vector<int>>& points) {\\n\\n        int n = points.size();\\n\\n        // declare a visited array\\n\\n        // initially all the points are unvisited\\n\\n        vector<bool> vis(n, false);\\n\\n        // we can\\'t remove all the points of a connected component one point will remain unremoved\\n\\n        // count will store the no. of connected components\\n\\n        int count = 0;\\n\\n        // traverse over points \\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            // if the point is not visited then call dfs\\n\\n            if(vis[i] == false)\\n            {\\n                dfs(points, i, n, vis);\\n\\n                // increment count\\n\\n                count++;\\n            }\\n        }\\n\\n        // count will be the no. of unremoved points\\n\\n        // n - count will be no. of removed points\\n\\n        return n - count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813182,
                "title": "python-simple-bfs-explained-o-n-time-o-n-space",
                "content": "Say that two stones are part of the same \"structure\" if we can get from one to the other by a series of horizontal and vertical jumps, where each jump starts and ends at a stone. It is easy to prove (use induction) that we can remove all the stones except for one from each structure. Therefore, if we can count the number of structures, we will know how many stones will remain after finishing our removals.\\n\\nTo efficiently count the number of structures, we keep a map from each row number to the set of stones in that row, and likewise for columns. This way we can quickly look up a stone\\'s neighbors in its structure. \\n\\nFinally we perform a BFS from each stone, discovering all the stones in its structure. Critically, each stone that we visit in the BFS gets removed from our maps, so that we do not examine it multiple times. Without these removals, the runtime would be `O(n^2)` (e.g. consider the case where all the stones lie on the same row).   \\n\\n\\n\\n```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        stone_tuples = [(stone[0], stone[1]) for stone in stones]        \\n        rows_to_stones = defaultdict(set)\\n        cols_to_stones = defaultdict(set)    \\n        \\n        for stone_tuple in stone_tuples:\\n            row, col = stone_tuple\\n            rows_to_stones[row].add(stone_tuple)\\n            cols_to_stones[col].add(stone_tuple)\\n        \\n        def remove_stone(stone: Tuple[int, int]):\\n            row, col = stone\\n            rows_to_stones[row].remove(stone)\\n            cols_to_stones[col].remove(stone)\\n        \\n        num_structures = 0\\n        seen = set()\\n        for stone in stone_tuples:\\n            if stone in seen:\\n                continue\\n            \\n            num_structures += 1            \\n            q = deque([stone])\\n            seen.add(stone)\\n            remove_stone(stone)\\n            \\n            while q:\\n                row, col = q.popleft()\\n                for neighbor_stone in list(rows_to_stones[row]) + list(cols_to_stones[col]):\\n                    q.append(neighbor_stone)\\n                    seen.add(neighbor_stone)\\n                    remove_stone(neighbor_stone)\\n                    \\n        return len(stones) - num_structures",
                "solutionTags": [],
                "code": "Say that two stones are part of the same \"structure\" if we can get from one to the other by a series of horizontal and vertical jumps, where each jump starts and ends at a stone. It is easy to prove (use induction) that we can remove all the stones except for one from each structure. Therefore, if we can count the number of structures, we will know how many stones will remain after finishing our removals.\\n\\nTo efficiently count the number of structures, we keep a map from each row number to the set of stones in that row, and likewise for columns. This way we can quickly look up a stone\\'s neighbors in its structure. \\n\\nFinally we perform a BFS from each stone, discovering all the stones in its structure. Critically, each stone that we visit in the BFS gets removed from our maps, so that we do not examine it multiple times. Without these removals, the runtime would be `O(n^2)` (e.g. consider the case where all the stones lie on the same row).   \\n\\n\\n\\n```\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        stone_tuples = [(stone[0], stone[1]) for stone in stones]        \\n        rows_to_stones = defaultdict(set)\\n        cols_to_stones = defaultdict(set)    \\n        \\n        for stone_tuple in stone_tuples:\\n            row, col = stone_tuple\\n            rows_to_stones[row].add(stone_tuple)\\n            cols_to_stones[col].add(stone_tuple)\\n        \\n        def remove_stone(stone: Tuple[int, int]):\\n            row, col = stone\\n            rows_to_stones[row].remove(stone)\\n            cols_to_stones[col].remove(stone)\\n        \\n        num_structures = 0\\n        seen = set()\\n        for stone in stone_tuples:\\n            if stone in seen:\\n                continue\\n            \\n            num_structures += 1            \\n            q = deque([stone])\\n            seen.add(stone)\\n            remove_stone(stone)\\n            \\n            while q:\\n                row, col = q.popleft()\\n                for neighbor_stone in list(rows_to_stones[row]) + list(cols_to_stones[col]):\\n                    q.append(neighbor_stone)\\n                    seen.add(neighbor_stone)\\n                    remove_stone(neighbor_stone)\\n                    \\n        return len(stones) - num_structures",
                "codeTag": "Java"
            },
            {
                "id": 2812972,
                "title": "c-dsu-number-of-connected-components",
                "content": "Not the best concise code out there, but since I have interviews coming up, trying to write structured code. \\n# Intuition:\\n2 ways:\\n- Either perform union on points(n points available), by checking if they have matching x/y coordinates.\\n- Perform union on any of x or y axis. Reason behind this: a line with x coordinate 0 acts as a single component because all points on this line are connected as they can be removed because x coordinate is same. So just perform union on x value of all points by checking if they have matching y value.\\n\\nFind number of connected components. Subtract from number of points.\\n# Complexity\\n- Time complexity: O(n^2)\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass DSU {\\nprivate:\\n    unordered_map<int, int> parent;\\n    unordered_map<int, int> rank;\\n    int num;\\npublic:\\n    DSU() {\\n        parent.clear();\\n        rank.clear();\\n        num = 0;\\n    }\\n\\n    int numcomp() {\\n        return num;\\n    }\\n    \\n    void insertx(int);\\n    int find(int);\\n    void uf(int, int);\\n};\\n\\nvoid DSU::insertx(int x) {\\n    if(parent.find(x) != parent.end())\\n        return;\\n    parent[x] = x;\\n    rank[x] = 0;\\n    num++;\\n}\\n\\nint DSU::find(int x) {\\n    return (parent[x] == x) ? x : find(parent[x]); \\n}\\n\\nvoid DSU::uf(int a, int b) {\\n    int x = find(a);\\n    int y = find(b);\\n    if(x == y)  \\n        return;\\n    if(rank[x] < rank[y])   \\n        swap(x, y);\\n    parent[y] = x;\\n    if(rank[x] == rank[y])\\n        rank[x]++;\\n    num--;\\n}\\n\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& a) {\\n        int n = a.size();\\n        DSU x;\\n        for(int i = 0; i < n; i++) {\\n            x.insertx(a[i][0]);\\n            for(int j = i + 1; j < n; j++) {\\n                x.insertx(a[j][0]);\\n                if(a[i][1] == a[j][1])\\n                    x.uf(a[i][0], a[j][0]);\\n            }\\n        }\\n        return n - x.numcomp();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DSU {\\nprivate:\\n    unordered_map<int, int> parent;\\n    unordered_map<int, int> rank;\\n    int num;\\npublic:\\n    DSU() {\\n        parent.clear();\\n        rank.clear();\\n        num = 0;\\n    }\\n\\n    int numcomp() {\\n        return num;\\n    }\\n    \\n    void insertx(int);\\n    int find(int);\\n    void uf(int, int);\\n};\\n\\nvoid DSU::insertx(int x) {\\n    if(parent.find(x) != parent.end())\\n        return;\\n    parent[x] = x;\\n    rank[x] = 0;\\n    num++;\\n}\\n\\nint DSU::find(int x) {\\n    return (parent[x] == x) ? x : find(parent[x]); \\n}\\n\\nvoid DSU::uf(int a, int b) {\\n    int x = find(a);\\n    int y = find(b);\\n    if(x == y)  \\n        return;\\n    if(rank[x] < rank[y])   \\n        swap(x, y);\\n    parent[y] = x;\\n    if(rank[x] == rank[y])\\n        rank[x]++;\\n    num--;\\n}\\n\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& a) {\\n        int n = a.size();\\n        DSU x;\\n        for(int i = 0; i < n; i++) {\\n            x.insertx(a[i][0]);\\n            for(int j = i + 1; j < n; j++) {\\n                x.insertx(a[j][0]);\\n                if(a[i][1] == a[j][1])\\n                    x.uf(a[i][0], a[j][0]);\\n            }\\n        }\\n        return n - x.numcomp();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812876,
                "title": "c-easy-dfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        vector<bool> vis(n, 0);\\n\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                count++;\\n                dfsPath(i, vis, stones, n);\\n            }\\n        }\\n\\n        return n - count;\\n    }\\n\\n    void dfsPath(int idx, vector<bool> &vis, vector<vector<int>> &stones, int &n){\\n        vis[idx] = 1;\\n\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                // check if the cur stonr is at same row or col with parent stone\\n                if(stones[i][0] == stones[idx][0] || stones[i][1] == stones[idx][1]){\\n                    dfsPath(i, vis, stones, n);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        vector<bool> vis(n, 0);\\n\\n        int count = 0;\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                count++;\\n                dfsPath(i, vis, stones, n);\\n            }\\n        }\\n\\n        return n - count;\\n    }\\n\\n    void dfsPath(int idx, vector<bool> &vis, vector<vector<int>> &stones, int &n){\\n        vis[idx] = 1;\\n\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                // check if the cur stonr is at same row or col with parent stone\\n                if(stones[i][0] == stones[idx][0] || stones[i][1] == stones[idx][1]){\\n                    dfsPath(i, vis, stones, n);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812718,
                "title": "c-easy-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&pos1, vector<int>&pos2)\\n    {\\n        if (pos1[0] == pos2[0]) return true;\\n        if (pos1[1] == pos2[1]) return true;\\n        return false;\\n    }\\n    int findParent(vector<int>&parent, int node)\\n    {\\n        while(parent[node] != node) { node = parent[node]; }\\n        return node;\\n    }\\n    void merge(vector<int>&parent, int& componentCount, int node1, int node2)\\n    {\\n        int parent1 = findParent(parent, node1);\\n        int parent2 = findParent(parent, node2);\\n        if (parent1 != parent2) \\n        {\\n            componentCount--;\\n            parent[parent1] = parent2; \\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones)\\n    {\\n        int n = stones.size();\\n        vector<int>parent(n);\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n        int componentCount = n;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i; j < n; j++)\\n            {\\n                if (isValid(stones[i], stones[j]))\\n                    merge(parent, componentCount, i, j);\\n            }\\n        }\\n        return (n - componentCount); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&pos1, vector<int>&pos2)\\n    {\\n        if (pos1[0] == pos2[0]) return true;\\n        if (pos1[1] == pos2[1]) return true;\\n        return false;\\n    }\\n    int findParent(vector<int>&parent, int node)\\n    {\\n        while(parent[node] != node) { node = parent[node]; }\\n        return node;\\n    }\\n    void merge(vector<int>&parent, int& componentCount, int node1, int node2)\\n    {\\n        int parent1 = findParent(parent, node1);\\n        int parent2 = findParent(parent, node2);\\n        if (parent1 != parent2) \\n        {\\n            componentCount--;\\n            parent[parent1] = parent2; \\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones)\\n    {\\n        int n = stones.size();\\n        vector<int>parent(n);\\n        for (int i = 0; i < n; i++) parent[i] = i;\\n        int componentCount = n;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i; j < n; j++)\\n            {\\n                if (isValid(stones[i], stones[j]))\\n                    merge(parent, componentCount, i, j);\\n            }\\n        }\\n        return (n - componentCount); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812598,
                "title": "python-group-all-stones",
                "content": "**Solution**:\\n    Rather than consider how many stones we can remove, we should consider how many group of stones we can form. Then, for each group, we can remove all except one stone. Thus, start by building an adjacency list for rows and cols. Then, dfs through all stones and see how many group we can form. \\n\\n**Complexity**:\\n    Time: O(n)\\n    Space: O(n)\\n\\t\\n```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def removeStones(self, stones: list[list[int]]) -> int:\\n\\n        # Build adjacency lists for both rows and cols\\n        rows, cols = defaultdict(list), defaultdict(list)\\n        for col, row in stones:\\n            rows[col].append(row)\\n            cols[row].append(col)\\n\\n        # Group all stones using DFS\\n        # Initialzie a set to keep track of visited stone\\n        visited = set()\\n\\n        # Initialize a number of group found\\n        group = 0\\n\\n        # Iterate through all stones\\n        for col, row in stones:\\n\\n            # If we already visited the current stone, skip it\\n            if (row, col) in visited:\\n                continue\\n\\n            # Else, we have found a new group\\n            group += 1\\n\\n            # Add the current stone into the stack\\n            stack = [(row, col)]\\n            visited.add((row, col))\\n\\n            # Iterate until stack is empty\\n            while stack:\\n\\n                # Pop a stone\\n                row, col = stack.pop()\\n\\n                # Add all unvisited stones at the same col into the stack\\n                for nRow in rows[col]:\\n                    if (nRow, col) not in visited:\\n                        visited.add((nRow, col))\\n                        stack.append((nRow, col))\\n\\n                # Add all unvisted stones at the same row into the stack\\n                for nCol in cols[row]:\\n                    if (row, nCol) not in visited:\\n                        visited.add((row, nCol))\\n                        stack.append((row, nCol))\\n\\n        # Return the number of removed stones\\n        return len(stones) - group\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def removeStones(self, stones: list[list[int]]) -> int:\\n\\n        # Build adjacency lists for both rows and cols\\n        rows, cols = defaultdict(list), defaultdict(list)\\n        for col, row in stones:\\n            rows[col].append(row)\\n            cols[row].append(col)\\n\\n        # Group all stones using DFS\\n        # Initialzie a set to keep track of visited stone\\n        visited = set()\\n\\n        # Initialize a number of group found\\n        group = 0\\n\\n        # Iterate through all stones\\n        for col, row in stones:\\n\\n            # If we already visited the current stone, skip it\\n            if (row, col) in visited:\\n                continue\\n\\n            # Else, we have found a new group\\n            group += 1\\n\\n            # Add the current stone into the stack\\n            stack = [(row, col)]\\n            visited.add((row, col))\\n\\n            # Iterate until stack is empty\\n            while stack:\\n\\n                # Pop a stone\\n                row, col = stack.pop()\\n\\n                # Add all unvisited stones at the same col into the stack\\n                for nRow in rows[col]:\\n                    if (nRow, col) not in visited:\\n                        visited.add((nRow, col))\\n                        stack.append((nRow, col))\\n\\n                # Add all unvisted stones at the same row into the stack\\n                for nCol in cols[row]:\\n                    if (row, nCol) not in visited:\\n                        visited.add((row, nCol))\\n                        stack.append((row, nCol))\\n\\n        # Return the number of removed stones\\n        return len(stones) - group\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726689,
                "title": "c-7-liner-easy-sol",
                "content": "* `Can also be done using DSU and BFS`\\n* `TC = o(n) = number of stones.`\\n\\n```\\n// can also be done using bfs and dsu \\nclass Solution {\\n    unordered_map<int,vector<int>> gr,gc;\\n    map<pair<int,int>,bool> vis; int ans,c;\\n    void dfs(int i,int j){\\n        vis[{i,j}] = true; c++;\\n        for(auto c:gr[i]) if(!vis[{i,c}] and j!=c) dfs(i,c);\\n        for(auto r:gc[j]) if(!vis[{r,j}] and r!=i) dfs(r,j);\\n    }\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        for(auto it:stones) gc[it[1]].emplace_back(it[0]), gr[it[0]].emplace_back(it[1]);\\n        for(auto it:stones) if(!vis[{it[0],it[1]}]) c=0, dfs(it[0],it[1]), ans+=c-1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// can also be done using bfs and dsu \\nclass Solution {\\n    unordered_map<int,vector<int>> gr,gc;\\n    map<pair<int,int>,bool> vis; int ans,c;\\n    void dfs(int i,int j){\\n        vis[{i,j}] = true; c++;\\n        for(auto c:gr[i]) if(!vis[{i,c}] and j!=c) dfs(i,c);\\n        for(auto r:gc[j]) if(!vis[{r,j}] and r!=i) dfs(r,j);\\n    }\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        for(auto it:stones) gc[it[1]].emplace_back(it[0]), gr[it[0]].emplace_back(it[1]);\\n        for(auto it:stones) if(!vis[{it[0],it[1]}]) c=0, dfs(it[0],it[1]), ans+=c-1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686163,
                "title": "python-union-find-solution-readable-code",
                "content": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        def find(node):\\n            if root[node] == node: return node\\n            root[node] = find(root[node])\\n            return root[node]\\n        \\n        def union(n1, n2):\\n            r1, r2 = find(n1), find(n2)\\n            if r1 != r2:\\n                if rank[r1] > rank[r2]:\\n                    root[r2] = r1\\n                    rank[r1] += rank[r2]\\n                elif rank[r2] > rank[r1]:\\n                    root[r1] = r2\\n                    rank[r2] += rank[r1]\\n                else:\\n                    root[r1] = r2\\n                    rank[r2] += rank[r1]\\n                    \\n                    \\n        stones_len = len(stones)\\n        root = [i for i in range(stones_len)]\\n        rank = [1] * len(stones)\\n        row_map = defaultdict(list)\\n        col_map = defaultdict(list)\\n        for ind, stone in enumerate(stones):\\n            x,y = stone\\n            row_map[x].append(ind)\\n            col_map[y].append(ind)\\n            \\n        for row in row_map:\\n            same_row = row_map[row]\\n            for i in range(len(same_row) - 1):\\n                union(same_row[i], same_row[i + 1])\\n        for col in col_map:\\n            same_col = col_map[col]\\n            for j in range(len(same_col) - 1):\\n                union(same_col[j], same_col[j + 1])\\n        \\n        distinct_region = 0\\n        for r in range(len(root)):\\n            if find(r) == r: distinct_region += 1\\n        return stones_len - distinct_region\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        def find(node):\\n            if root[node] == node: return node\\n            root[node] = find(root[node])\\n            return root[node]\\n        \\n        def union(n1, n2):\\n            r1, r2 = find(n1), find(n2)\\n            if r1 != r2:\\n                if rank[r1] > rank[r2]:\\n                    root[r2] = r1\\n                    rank[r1] += rank[r2]\\n                elif rank[r2] > rank[r1]:\\n                    root[r1] = r2\\n                    rank[r2] += rank[r1]\\n                else:\\n                    root[r1] = r2\\n                    rank[r2] += rank[r1]\\n                    \\n                    \\n        stones_len = len(stones)\\n        root = [i for i in range(stones_len)]\\n        rank = [1] * len(stones)\\n        row_map = defaultdict(list)\\n        col_map = defaultdict(list)\\n        for ind, stone in enumerate(stones):\\n            x,y = stone\\n            row_map[x].append(ind)\\n            col_map[y].append(ind)\\n            \\n        for row in row_map:\\n            same_row = row_map[row]\\n            for i in range(len(same_row) - 1):\\n                union(same_row[i], same_row[i + 1])\\n        for col in col_map:\\n            same_col = col_map[col]\\n            for j in range(len(same_col) - 1):\\n                union(same_col[j], same_col[j + 1])\\n        \\n        distinct_region = 0\\n        for r in range(len(root)):\\n            if find(r) == r: distinct_region += 1\\n        return stones_len - distinct_region\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448256,
                "title": "python-do-dfs-to-identify-number-of-connected-comps-len-stones-of-comps",
                "content": "```\\n/*\\ntldr: identify the total number of components and \\nreturn the len of stones - # of connected components\\nwe can do a simple depth first traversal by create a graph\\nall the stones having same row are connected\\nall the stones having same column are connected\\ngraph = {(\\'r\\', r): {set of stones belonging to same row }, \\n(\\'c\\', c): {set of stones belonging to same column}}\\nstart with a stone which is unvisited and do a dfs traversal on that. \\nIdentify the number of connected components\\n*/\\n```\\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        h_map = {}\\n        for stone in stones:\\n            stone = tuple(stone)\\n            r, c = stone\\n            if (\\'r\\', r) in h_map:\\n                h_map[(\\'r\\', r)].add(stone)\\n            else:\\n                h_map[(\\'r\\', r)] = {stone}\\n                \\n            if (\\'c\\', c) in h_map:\\n                h_map[(\\'c\\', c)].add(stone)\\n            else:\\n                h_map[(\\'c\\', c)] = {stone}\\n        \\n        def dfs(stone):\\n            visited.add(stone)\\n            x, y = stone\\n            for s in h_map[(\\'r\\', x)]:\\n                if s not in visited:\\n                    dfs(tuple(s))\\n            for s in h_map[(\\'c\\', y)]:\\n                if s not in visited:\\n                    dfs(tuple(s))\\n            \\n        visited = set()\\n        count = 0\\n        for stone in stones:\\n            stone = tuple(stone)\\n            if stone not in visited:\\n                dfs(stone)\\n                count+=1\\n        return len(stones) - count\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\ntldr: identify the total number of components and \\nreturn the len of stones - # of connected components\\nwe can do a simple depth first traversal by create a graph\\nall the stones having same row are connected\\nall the stones having same column are connected\\ngraph = {(\\'r\\', r): {set of stones belonging to same row }, \\n(\\'c\\', c): {set of stones belonging to same column}}\\nstart with a stone which is unvisited and do a dfs traversal on that. \\nIdentify the number of connected components\\n*/\\n```\n```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        h_map = {}\\n        for stone in stones:\\n            stone = tuple(stone)\\n            r, c = stone\\n            if (\\'r\\', r) in h_map:\\n                h_map[(\\'r\\', r)].add(stone)\\n            else:\\n                h_map[(\\'r\\', r)] = {stone}\\n                \\n            if (\\'c\\', c) in h_map:\\n                h_map[(\\'c\\', c)].add(stone)\\n            else:\\n                h_map[(\\'c\\', c)] = {stone}\\n        \\n        def dfs(stone):\\n            visited.add(stone)\\n            x, y = stone\\n            for s in h_map[(\\'r\\', x)]:\\n                if s not in visited:\\n                    dfs(tuple(s))\\n            for s in h_map[(\\'c\\', y)]:\\n                if s not in visited:\\n                    dfs(tuple(s))\\n            \\n        visited = set()\\n        count = 0\\n        for stone in stones:\\n            stone = tuple(stone)\\n            if stone not in visited:\\n                dfs(stone)\\n                count+=1\\n        return len(stones) - count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352665,
                "title": "optimized-unionfind-well-commented-java-ac-solution",
                "content": "**Intuition** -  Join all the stones using union-find algo. A component in a graph can be single handedly replaced by only one node inside it - the rest of the nodes are removable. Since we want maximum number of stones that can be removed, we subtract the total number of components from the initial total number of stones.\\n\\n```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        // Intuition - Join all the stones using union-find algo. \\n        // A component in a graph can be single handedly replaced by only one node inside it - the rest of the nodes are removavble. \\n        // Since we want maximum number of stones that can be removed, we subtract the total number of components from the initial total number of stones.\\n        int l = stones.length;\\n        UnionFind uf = new UnionFind(l);\\n        for(int i=0; i<l-1; i++) {\\n            for(int j=i+1; j<l; j++) {\\n                int[] stone1 = stones[i];\\n                int[] stone2 = stones[j];\\n                \\n                // We can join stones only if at-least one of their co-ordinates are equal. \\n                if(stone1[0] == stone2[0] || stone1[1] == stone2[1]) {\\n                    uf.union(i, j);\\n                }\\n            }\\n        }\\n        \\n        return l - uf.countComponents();\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        int[] rank;\\n\\n        UnionFind(int size) {\\n            parent = new int[size];\\n            rank = new int[size];\\n            for(int i=0; i<size; i++) {\\n                parent[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n\\n        // Find - Path Compressed\\n        public int find(int x) {\\n            if (x == parent[x]) {\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]);\\n        }\\n\\n        // Union - Union by rank\\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                if (rank[rootX] > rank[rootY]) {\\n                    parent[rootY] = rootX;\\n                } else if (rank[rootX] < rank[rootY]) {\\n                    parent[rootX] = rootY;\\n                } else {\\n                    parent[rootY] = rootX;\\n                    rank[rootX] += 1;\\n                }\\n            }\\n        }\\n\\n        // Returns total number of components\\n        public int countComponents() {\\n            int ctr = 0;\\n            for(int i=0; i<parent.length; i++) {\\n                if (i == parent[i]) {\\n                    ctr++;\\n                }\\n            }\\n            return ctr;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        // Intuition - Join all the stones using union-find algo. \\n        // A component in a graph can be single handedly replaced by only one node inside it - the rest of the nodes are removavble. \\n        // Since we want maximum number of stones that can be removed, we subtract the total number of components from the initial total number of stones.\\n        int l = stones.length;\\n        UnionFind uf = new UnionFind(l);\\n        for(int i=0; i<l-1; i++) {\\n            for(int j=i+1; j<l; j++) {\\n                int[] stone1 = stones[i];\\n                int[] stone2 = stones[j];\\n                \\n                // We can join stones only if at-least one of their co-ordinates are equal. \\n                if(stone1[0] == stone2[0] || stone1[1] == stone2[1]) {\\n                    uf.union(i, j);\\n                }\\n            }\\n        }\\n        \\n        return l - uf.countComponents();\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        int[] rank;\\n\\n        UnionFind(int size) {\\n            parent = new int[size];\\n            rank = new int[size];\\n            for(int i=0; i<size; i++) {\\n                parent[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n\\n        // Find - Path Compressed\\n        public int find(int x) {\\n            if (x == parent[x]) {\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]);\\n        }\\n\\n        // Union - Union by rank\\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                if (rank[rootX] > rank[rootY]) {\\n                    parent[rootY] = rootX;\\n                } else if (rank[rootX] < rank[rootY]) {\\n                    parent[rootX] = rootY;\\n                } else {\\n                    parent[rootY] = rootX;\\n                    rank[rootX] += 1;\\n                }\\n            }\\n        }\\n\\n        // Returns total number of components\\n        public int countComponents() {\\n            int ctr = 0;\\n            for(int i=0; i<parent.length; i++) {\\n                if (i == parent[i]) {\\n                    ctr++;\\n                }\\n            }\\n            return ctr;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309454,
                "title": "basic-union-find-c",
                "content": "--> used indexes as the ids of union find\\n```\\nclass Solution {\\n    int find(int x,vector<int>& parent){\\n        return x == parent[x] ? x: find(parent[x],parent);\\n    }\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n=size(stones);\\n        vector<int> parent(n,0);\\n        for(int i=0; i<n; i++)\\n            parent[i] = i;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]){\\n                    int x = find(i,parent);\\n                    int y = find(j,parent);\\n                    \\n                    if(x != y) parent[y] = x;\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        \\n        for(int i=0; i<n; i++) \\n            cnt += (parent[i] == i);\\n        \\n        return n-cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int find(int x,vector<int>& parent){\\n        return x == parent[x] ? x: find(parent[x],parent);\\n    }\\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n=size(stones);\\n        vector<int> parent(n,0);\\n        for(int i=0; i<n; i++)\\n            parent[i] = i;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]){\\n                    int x = find(i,parent);\\n                    int y = find(j,parent);\\n                    \\n                    if(x != y) parent[y] = x;\\n                }\\n            }\\n        }\\n        int cnt=0;\\n        \\n        for(int i=0; i<n; i++) \\n            cnt += (parent[i] == i);\\n        \\n        return n-cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300693,
                "title": "c-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int parent[1006];\\n    int rank[1006];\\n    void make(int n)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n            rank[i]=0;\\n        }\\n    }\\n    int find(int node)\\n    {\\n        if(node==parent[node])\\n            return node; \\n        return parent[node]=find(parent[node]);\\n    }\\n    void union1(int u,int v)\\n    {\\n        u=find(u);\\n        v=find(v);\\n        if(rank[u]<rank[v])\\n            parent[u]=v;\\n        else if(rank[u]>rank[v])\\n            parent[v]=u;\\n        else\\n        {\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n=stones.size();\\n        make(n);\\n        int ans=0;\\n        for(int i=0;i<n-1;i++)\\n            for(int j=i+1;j<n;j++)\\n                if(stones[i][0]==stones[j][0]||stones[i][1]==stones[j][1])\\n                    union1(i,j);\\n        for(int i=0;i<n;i++)\\n            if(parent[i]==i)\\n                ans++;\\n        return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int parent[1006];\\n    int rank[1006];\\n    void make(int n)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n            rank[i]=0;\\n        }\\n    }\\n    int find(int node)\\n    {\\n        if(node==parent[node])\\n            return node; \\n        return parent[node]=find(parent[node]);\\n    }\\n    void union1(int u,int v)\\n    {\\n        u=find(u);\\n        v=find(v);\\n        if(rank[u]<rank[v])\\n            parent[u]=v;\\n        else if(rank[u]>rank[v])\\n            parent[v]=u;\\n        else\\n        {\\n            parent[v]=u;\\n            rank[u]++;\\n        }\\n    }\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n=stones.size();\\n        make(n);\\n        int ans=0;\\n        for(int i=0;i<n-1;i++)\\n            for(int j=i+1;j<n;j++)\\n                if(stones[i][0]==stones[j][0]||stones[i][1]==stones[j][1])\\n                    union1(i,j);\\n        for(int i=0;i<n;i++)\\n            if(parent[i]==i)\\n                ans++;\\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290038,
                "title": "c-code-with-explanation-number-of-island-concept",
                "content": "\\t void dfs(vector<vector<int>> &adj, int node, vector<int> &vis)\\n    {\\n        vis[node] = 1;\\n        for(int i=0;i<adj[node].size();i++)\\n        {\\n            if(!vis[adj[node][i]]) dfs(adj,adj[node][i],vis);\\n        }\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        int  n = stones.size();\\n        vector<vector<int>> adj(n);\\n        unordered_map<int,int> mapx;\\n        unordered_map<int,int> mapy;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(mapx.count(stones[i][0]))\\n            {\\n                adj[i].push_back(mapx[stones[i][0]]);\\n                adj[mapx[stones[i][0]]].push_back(i);\\n            }\\n            else mapx[stones[i][0]] = i;\\n            \\n            if(mapy.count(stones[i][1]))\\n            {\\n                adj[i].push_back(mapy[stones[i][1]]);\\n                adj[mapy[stones[i][1]]].push_back(i);\\n            }\\n            else  mapy[stones[i][1]] = i;\\n        }\\n        \\n        vector<int> vis(n,0);\\n        int res = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(adj,i,vis);\\n                res++;\\n            }\\n        }\\n        return n - res;\\n\\t}\\n\\nThe system stones on the 2D plane can be visualized as a graph having stones as the vertices and every 2 stones which have common x coordinate or y coordinate will have an egde between them.\\nAfter connecting all the stones accordingly (as mentioned above) you have to find the total number of connected components.\\nNow is the tricky part, For each components having s number of stones as vertices you can remove s-1 stones from that component. Just take some time and think about it , you will understand. \\nSince each component is made us of stones which are sharing coordinates and it is given in the ques that we have to remove the stones *which share coordinates* there fore we have to remove stones from the components considering one component at a time.\\nNow after removing the stones each component will left with only one stone so we have to calculate the total number of components which will be equal to the total number of stones left after the removal.",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "\\t void dfs(vector<vector<int>> &adj, int node, vector<int> &vis)\\n    {\\n        vis[node] = 1;\\n        for(int i=0;i<adj[node].size();i++)\\n        {\\n            if(!vis[adj[node][i]]) dfs(adj,adj[node][i],vis);\\n        }\\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        int  n = stones.size();\\n        vector<vector<int>> adj(n);\\n        unordered_map<int,int> mapx;\\n        unordered_map<int,int> mapy;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(mapx.count(stones[i][0]))\\n            {\\n                adj[i].push_back(mapx[stones[i][0]]);\\n                adj[mapx[stones[i][0]]].push_back(i);\\n            }\\n            else mapx[stones[i][0]] = i;\\n            \\n            if(mapy.count(stones[i][1]))\\n            {\\n                adj[i].push_back(mapy[stones[i][1]]);\\n                adj[mapy[stones[i][1]]].push_back(i);\\n            }\\n            else  mapy[stones[i][1]] = i;\\n        }\\n        \\n        vector<int> vis(n,0);\\n        int res = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(adj,i,vis);\\n                res++;\\n            }\\n        }\\n        return n - res;\\n\\t}\\n\\nThe system stones on the 2D plane can be visualized as a graph having stones as the vertices and every 2 stones which have common x coordinate or y coordinate will have an egde between them.\\nAfter connecting all the stones accordingly (as mentioned above) you have to find the total number of connected components.\\nNow is the tricky part, For each components having s number of stones as vertices you can remove s-1 stones from that component. Just take some time and think about it , you will understand. \\nSince each component is made us of stones which are sharing coordinates and it is given in the ques that we have to remove the stones *which share coordinates* there fore we have to remove stones from the components considering one component at a time.\\nNow after removing the stones each component will left with only one stone so we have to calculate the total number of components which will be equal to the total number of stones left after the removal.",
                "codeTag": "Unknown"
            },
            {
                "id": 2273655,
                "title": "c-quick-learner-union-find-dfs-7-solutions-top-players-improvements",
                "content": "June 13, 2022\\n\\nIt is hard to be a master of union find and DFS algorithm. I like to share my quick learning of C# solution after I chose to study various player solutions in weekly contest 112. \\n\\nAlso, I studied solutions written by various players, in weekly contest 112, ranking No. 5, 8, 12, 13, 16, 40, 58, 117, 176. The goal of my study is to read a lot of solutions, and learn to write a good one and enjoy the study. I did study those player code in 2019, and after three years, I like to share my C# solution as well.\\n\\nI think that it is a good idea to put together 7 solutions in one discuss post, so that I can enjoy reading various ideas one time in C# programming language. After I read those ideas to write DFS or union find algorithms, I can expedite my thought process and write a short version in less than 30 minutes time. \\n\\n**Lee215 | Analysis | My understanding**\\nI chose to study Lee215\\'s analysis, and learn how to analyze the problem first. \\n\\nProblem:\\nwe can remove a stone if and only if,\\nthere is another stone in the same column OR row.\\nWe try to remove as many as stones as possible.\\n\\n\\nOne sentence to solve:\\nConnected stones can be reduced to 1 stone,\\nthe maximum stones can be removed = stones number - islands number.\\nso just count the number of \"islands\".\\n\\n\\n1. Connected stones\\nTwo stones are connected if they are in the same row or same col.\\nConnected stones will build a connected graph.\\nIt\\'s obvious that in one connected graph,\\nwe can\\'t remove all stones.\\n\\nWe have to have one stone left.\\nAn intuition is that, in the best strategy, we can remove until 1 stone.\\n\\nI guess you may reach this step when solving the problem.\\nBut the important question is, how?\\n\\n**Lee215 | Union find algorithm | My understanding**\\nI chose to study Lee215 analysis first. \\n\\n7. Union-Find\\nI use union find to solve this problem.\\nAs I mentioned, the elements are not the points, but the indexes.\\n\\nfor each point, union two indexes.\\nreturn points number - union number\\nCopy a template of union-find,\\nwrite 2 lines above,\\nyou can solve this problem in several minutes.\\n\\n\\nComplexity\\nunion and find functions have worst case O(N), amortize O(1)\\nThe whole union-find solution with path compression,\\nhas O(N) Time, O(N) Space\\n\\n**Case study | Example 1 | All are connected**\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\n![image](https://assets.leetcode.com/users/images/1d13be95-6628-4754-b6b0-1121bf23cf89_1655160090.556042.jpeg)\\n\\nGiven stones in the array [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]], and I mark the matrix 3 x 3 using A, B, C, D, E, F, G, those six elements are marked as A, B, D, F, H, I. A and B are connected in the same row, A and D are connected in the same column, D and F are connected in the same row, F and I are connected in the same column, H and I are connected in the same row, so A, B, D, F, H and I are all connected in one disjoint set. D, B, F, H, I can be removed, and only one node needs to stay as parent node in one disjoint set. \\n\\n**Union find algorithm - 15 minutes warmup**\\nI always like to refresh my favorite lecture notes about union find algorithm lecture note. \\nhttps://algs4.cs.princeton.edu/15uf/\\n\\nEvery time I like to learn something new from the lecture notes. This time I like to quickly review weighted quick-union idea. It is fun to review algorithm in detail before I read C# implemented solutions. \\n\\nHere are 7 various ideas to write DFS/ Union find algorithms. Read one or two if you have time. Also I like to review those top player\\'s code and give some advice how to make improvements. \\n \\n1. DFS algorithm - Build an undirected graph, and then search using DFS - mark visited to avoid deadloop \\n2. DFS algorithm - Similar to Item 2 DFS algorithm. Two players chose DFS, almost same. Solution 1 is to define undirected graph using List<int>[1123], solution 2 is to define the graph using bool[1005][1005]. Only concern is sparse arrray, it is more space efficient to use List<int>[1123], but **List<IList<int>> is best choice**. \\n3. Union find algorithm - union API, getParent API, quick-union and path compression, I wrote code and then made mistake to mix Parent[] and GetParent() API. **Nothing can compare to my own practice**, and I had to read union find algorithm lecture notes, and then understand the disjoint set quick union, path compression, and also union of two disjoint sets. **Reading code is easy, but actual implementation shows my weakness in my learning on this union find algorithm back in 2019, after weekly contest**. \\n4. Union find algorithm - with Rank option, I like to learn how to define Rank, first design concern is when to increment one, second one is to assign high rank to be parent node when two disjoint sets union together. **In general, to write a working union find algorithm, there are at least three things to work on: path compression, quick union and also which one to be a root based on rank or size or other things**.  \\n5. Union find algorithm - Only getRoot API with path compression \\n6. Union find algorithm - getFather API with path compression\\n\\n7. Union algorithm - find API, union API, Size of disjoint set \\n\\nIt is one place to review all features of union find - how to define quick union, rank, size, and also path compression. I find that this is best and quick way to get familiar with union find algorithm and easy to review for a code assessment or learn an advanced graph algorithm. \\n\\nI think that it is important to review DFS solution first, since it takes less time to write and also easy to follow. \\n\\n**Follow up | Give an upvote to support**\\nJune 27, 2022\\nPlease give me an upvote to support me to write better and explain things better. We all are working hard to make improvments on problem solving. It takes a lot of effort to make a discuss post helpful; Learn and teach together, we all have weakness, but it takes wisdom to share good things in algorithm practice. \\n\\n**Solution 1: DFS**\\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones_rank_16\\n{\\n    class Program\\n    {\\n        /// <summary>\\n        /// Leetcode 947 remove stones\\n        /// </summary>\\n        /// <param name=\"args\"></param>\\n        static void Main(string[] args)\\n        {\\n            RunTestcase2(); \\n        }\\n\\n        public static void RunTestcase1()\\n        {\\n            var stones = new int[6][]{\\n                new int[]{0,0},\\n                new int[]{0,1},\\n                new int[]{1,0},\\n                new int[]{1,2},\\n                new int[]{2,1},\\n                new int[]{2,2}\\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        public static void RunTestcase2()\\n        {\\n            var stones = new int[5][]{\\n                new int[]{0,0},\\n                new int[]{0,2},\\n                new int[]{1,1},\\n                new int[]{2,0},\\n                new int[]{2,2}                \\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        public static List<int>[] graph = new List<int>[1123];\\n        public static int[] Visited = new int[1123];\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking/\\n        /// Ranking No. 16 sohelH\\n        /// Two tips to construct a undirected graph\\n        /// 1. brute force all possible edges\\n        /// 2. check if two nodes are in the same row or same column. If it is same row or column, \\n        /// then the two nodes are connected. \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            int length = stones.Length;\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                graph[i] = new List<int>();\\n                Visited[i] = 0;\\n            }\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                for (int j = i + 1; j < length; j++)\\n                {\\n                    int r1 = stones[i][0];\\n                    int c1 = stones[i][1];\\n                    int r2 = stones[j][0];\\n                    int c2 = stones[j][1];\\n\\n                    if (r1 == r2 || c1 == c2)\\n                    {\\n                        graph[i].Add(j);\\n                        graph[j].Add(i);\\n                    }\\n                }\\n            }\\n\\n            int components = 0;\\n            for (int i = 0; i < length; i++)\\n            {\\n                if (Visited[i] == 0)\\n                {\\n                    dfs(i);\\n                    components++;\\n                }\\n            }\\n\\n            return length - components;\\n        }\\n\\n        private static void dfs(int u)\\n        {\\n            if (Visited[u] == 1)\\n            {\\n                return;\\n            }\\n\\n            Visited[u] = 1;\\n            for (int i = 0; i < graph[u].Count; i++)\\n            {\\n                dfs(graph[u][i]);\\n            }\\n        }\\n    }\\n}\\n```\\nHere is another DFS solution. I like to read C# code and think about how to improve the code. \\n\\n**Solution 2: DFS | Second solution of DFS**\\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones___DFS\\n{\\n    class Program\\n    {\\n        /// <summary>\\n        /// Leetcode 947 remove stones\\n        /// </summary>\\n        /// <param name=\"args\"></param>\\n        static void Main(string[] args)\\n        {\\n            RunTestcase2(); \\n        }\\n\\n        public static void RunTestcase1()\\n        {\\n            var stones = new int[6][]{\\n                new int[]{0,0},\\n                new int[]{0,1},\\n                new int[]{1,0},\\n                new int[]{1,2},\\n                new int[]{2,1},\\n                new int[]{2,2}\\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        public static void RunTestcase2()\\n        {\\n            var stones = new int[5][]{\\n                new int[]{0,0},\\n                new int[]{0,2},\\n                new int[]{1,1},\\n                new int[]{2,0},\\n                new int[]{2,2}                \\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        public static int Rows; \\n        public static bool[][] graph = new bool[1005][];\\n        public static bool[]   visited = new bool[1005];\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking/\\n        /// Ranking No. 5 joon_young\\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            Rows = stones.Length;\\n\\n            for (int row = 0; row < 1005; row++)\\n            {\\n                graph[row] = new bool[1005];\\n            }\\n\\n            // reset to false\\n            for (int row = 0; row < 1005; row++)\\n            {\\n                visited[row] = false; \\n            }\\n\\n            for (int row = 0; row < Rows; row++)\\n            {\\n                for (int j = row + 1; j < Rows; j++)\\n                {\\n                    if (stones[row][0] == stones[j][0] ||\\n                        stones[row][1] == stones[j][1])\\n                    {\\n                        graph[row][j] = true;\\n                        graph[j][row] = true;\\n                    }\\n                }\\n            }\\n\\n            int result = 0;\\n            for (int row = 0; row < Rows; row++)\\n            {\\n                if(visited[row])\\n                {\\n                    continue;\\n                }\\n\\n                result++;\\n\\n                dfs(row);\\n            }\\n\\n            return Rows - result; \\n        }\\n\\n        private static void dfs(int id)\\n        {\\n            if (visited[id])\\n                return;\\n\\n            visited[id] = true; \\n\\n            for (int row = 0; row < Rows; row++)\\n            {\\n                if (graph[id][row])\\n                {\\n                    dfs(row);\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n**Solution 3: Union find algorithm | Learn from my mistakes**\\n\\nI learned the lesson, and getParent API should be called instead of calling parent[i]. \\n\\nIt is better to go over lecture notes to review union find algorithm first. \\nhttps://algs4.cs.princeton.edu/15uf/\\nhttps://algs4.cs.princeton.edu/15uf/QuickUnionPathCompressionUF.java.html\\n\\nIt is important to understand path compression, the binary tree should be flated and it is more efficient to do that. Also I need to learn again quick-union and path compression, getParent API has path-compression, and union API is a quick-union time complexity O(1) operation. \\n\\n\\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones_Rank_176\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            RunTestcase1();\\n        }\\n\\n        public static void RunTestcase1()\\n        {\\n            var stones = new int[7][]{\\n                new int[]{3, 2},\\n                new int[]{0, 0},\\n                new int[]{3, 3},\\n                new int[]{2, 1},\\n                new int[]{2, 3},\\n                new int[]{2, 2},\\n                new int[]{0, 2}\\n            };\\n\\n            var number = RemoveStones(stones); \\n        }\\n\\n        // [[3,3],[4,4],[1,4],[1,5],[2,3],[4,3],[2,4]]\\n        public static void RunTestcase2()\\n        {\\n            var stones = new int[7][]{\\n                new int[]{3, 3},\\n                new int[]{4, 4},\\n                new int[]{1, 4},\\n                new int[]{1, 5},\\n                new int[]{2, 3},\\n                new int[]{4, 3},\\n                new int[]{2, 4}\\n            };\\n\\n            var number = RemoveStones(stones);\\n        }\\n\\n        /// <summary>\\n        /// study code weekly contest 112\\n        /// Rank 176 \\n        /// https://leetcode.com/contest/weekly-contest-112/ranking/8/\\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            var length = stones.Length;\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                Parent[i] = i;              \\n            }           \\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                for (int j = i + 1; j < length; j++)\\n                {\\n                    if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                    {\\n                        if (Parent[i] != Parent[j])\\n                        {\\n                            union(i, j);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            int number = 0;\\n            for (int i = 0; i < length; i++)\\n            {\\n                if(i == Parent[i])\\n                {\\n                    number++;\\n                }\\n            }\\n\\n            return length - number; \\n        }\\n\\n        public static int[] Parent = new int[1005];\\n        public static int[] Rank   = new int[1005];\\n\\n        /// <summary>\\n        /// path compression\\n        /// https://algs4.cs.princeton.edu/15uf/QuickUnionPathCompressionUF.java.html\\n        /// </summary>\\n        /// <param name=\"x\"></param>\\n        /// <returns></returns>\\n        private static int getParent_Obsolete(int x)\\n        {           \\n            while (Parent[x] != x)\\n            {\\n                x = Parent[x];\\n            }\\n          \\n            return x; \\n        }\\n\\n        /// <summary>\\n        /// study code from \\n        /// https://algs4.cs.princeton.edu/15uf/QuickUnionPathCompressionUF.java.html\\n        /// </summary>\\n        /// <param name=\"p\"></param>\\n        /// <returns></returns>\\n        public static int getParent(int p)\\n        {\\n            int root = p;\\n            while (root != Parent[root])\\n            {\\n                root = Parent[root];\\n            }\\n\\n            while (p != root)\\n            {\\n                int newp = Parent[p];\\n                Parent[p] = root;\\n                p = newp;\\n            }\\n\\n            return root;\\n        }\\n\\n        /// <summary>\\n        /// this function has a bug \\n        /// var root1 = Parent[id1] -- should be -> var root1 = getParent(id1)\\n        /// In other words, I need to separate intermediate node from root node of tree.\\n        /// </summary>\\n        /// <param name=\"id1\"></param>\\n        /// <param name=\"id2\"></param>\\n        private static void union_Buggy(int id1, int id2)\\n        {\\n            var root1 = Parent[id1];\\n            var root2 = Parent[id2];            \\n\\n            Parent[root2] = root1;            \\n        }\\n\\n        private static void union(int id1, int id2)\\n        {\\n            var root1 = getParent(id1);\\n            var root2 = getParent(id2);\\n\\n            Parent[root2] = root1;\\n        }\\n    }\\n}\\n```\\n**Solution 3: Union find - Rank**\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones___union_join\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var stones = new int[6][]{\\n                new int[]{0,0},\\n                new int[]{0,1},\\n                new int[]{1,0},\\n                new int[]{1,2},\\n                new int[]{2,1},\\n                new int[]{2,2}\\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        public static int[] Parent;\\n        public static int[] Size;\\n        public static int[] Rank;\\n\\n        public static int   Total; \\n\\n        /// <summary>\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking\\n        /// rank No. 13 yangmei555\\n        /// \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            var length = stones.Length;\\n\\n            Parent = new int[length];\\n            Size = new int[length];\\n            Rank = new int[length];\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                Parent[i] = i;\\n                Size[i] = 1; \\n            }\\n\\n            Total = length;\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                for (int j = i + 1; j < length; j++)\\n                {\\n                    if (stones[i][0] == stones[j][0] ||\\n                       stones[i][1] == stones[j][1])\\n                    {\\n                        union(i, j);            \\n                    }\\n                }\\n            }\\n\\n            return length - Total; \\n        }\\n\\n        /// <summary>\\n        /// code review:\\n        /// union and rank is simplified, and this version of code is easy to follow\\n        /// Rule 1: Parent node has higher rank compared to its child node\\n        /// union is to connect two root nodes of tree. \\n        /// </summary>\\n        /// <param name=\"i\"></param>\\n        /// <param name=\"j\"></param>\\n        private static void union(int i, int j)\\n        {\\n            int id1 = find(i);\\n            int id2 = find(j);\\n\\n            if (id1 != id2)\\n            {\\n                Total--;\\n\\n                if (Rank[id1] <= Rank[id2])\\n                {\\n                    Parent[id1] = id2;\\n                    if (Rank[id1] == Rank[id2])\\n                    {\\n                        Rank[id2]++;\\n                    }\\n                }\\n                else\\n                {\\n                    Parent[id2] = id1; \\n                }\\n            }\\n        }\\n\\n        /// <summary>\\n        /// code review:\\n        /// find is to search tree structure and find the root of tree the node stays\\n        /// </summary>\\n        /// <param name=\"id\"></param>\\n        /// <returns></returns>\\n        private static int find(int id)\\n        {\\n            if (id != Parent[id])\\n            {\\n                Parent[id] = find(Parent[id]);\\n            }\\n\\n            return Parent[id];\\n        }\\n    }\\n}\\n\\n```\\n**4th solution: Union find algorithm** \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_ranking_117\\n{\\n    class Program\\n    {        \\n        public static void RunTestcase2()\\n        {\\n            var stones = new int[7][]{\\n                new int[]{3, 3},\\n                new int[]{4, 4},\\n                new int[]{1, 4},\\n                new int[]{1, 5},\\n                new int[]{2, 3},\\n                new int[]{4, 3},\\n                new int[]{2, 4}\\n            };\\n\\n            var number = RemoveStones(stones);\\n        }\\n\\n        static void Main(string[] args)\\n        {\\n            RunTestcase2(); \\n        }\\n\\n        /// <summary>\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking/5/\\n        /// rank 117\\n        /// yajingleo\\n        /// \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            var length = stones.Length;\\n            var root = new int[length];\\n            for (int i = 0; i < length; i++)\\n            {\\n                root[i] = i;\\n            }\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                for (int j = 0; j < length; j++)\\n                {\\n                    if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                    {\\n                        var root1 = getRoot(root, i);\\n                        var root2 = getRoot(root, j);\\n\\n                        // given constraint on the root, smaller index will be the root. \\n                        root[root2] = root1;\\n                    }\\n                }\\n            }\\n\\n            int result = length;\\n            for(int i = 0; i < length; i++)\\n            {\\n                if(root[i] == i)\\n                {\\n                    result--; \\n                }\\n            }\\n\\n            return result; \\n        }\\n\\n        /// <summary>\\n        /// code review April 4, 2019\\n        /// It is better to use while loop instead of recursive function\\n        /// </summary>\\n        /// <param name=\"root\"></param>\\n        /// <param name=\"i\"></param>\\n        /// <returns></returns>\\n        private static int getRoot(int[] root, int i)\\n        {\\n            while (root[i] != i)\\n            {\\n                i = root[i];\\n            }\\n\\n            return i; \\n        }\\n    }\\n}\\n```\\n\\n**Solution 5: Union find algorithm** \\n\\nIt is interesting to read the code related to how to determine which one should be the parent when two nodes join the same disjoint set. The node with higher index is selected to be the root of disjoint set. \\n\\n```\\n for (int i = 0; i < rows; i++)\\n {\\n        for (int j = i + 1; j < rows; j++)\\n        {\\n               if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n               {\\n                    int fi = getFather(i);\\n                    int fj = getFather(j);\\n                    father[fi] = fj;\\n               }\\n        }\\n }       \\n```\\t\\t\\t\\nPay attention to the above double for loop, second loop variable j > i, and then j\\'s parent will be i\\'s parent\\'s parent. Interesting? How to avoid writing code related to rank, it is quick and easy way to make it consistent this way. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n\\n            var stones = new int[6][]{\\n                new int[]{0,0},\\n                new int[]{0,1},\\n                new int[]{1,0},\\n                new int[]{1,2},\\n                new int[]{2,1},\\n                new int[]{2,2}\\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        private static List<int> father;\\n\\n        /// <summary>\\n        /// \\n        /// </summary>\\n        /// <param name=\"i\"></param>\\n        /// <returns></returns>\\n        private static int getFather(int search)        \\n        {\\n            if (search == father[search])\\n            {\\n                return search;\\n            }\\n\\n            int root = getFather(father[search]);\\n\\n            father[search] = root;\\n\\n            return root;                            \\n        }\\n\\n        /// <summary>\\n        /// Leetcode 947\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking/\\n        /// ranking 8\\n        /// Windsfantasy6\\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            var rows = stones.Length;\\n\\n            father = new List<int>();\\n            for (int i = 0; i < rows; i++)\\n            {\\n                father.Add(i);\\n            }\\n\\n            for (int i = 0; i < rows; i++)\\n            {\\n                for (int j = i + 1; j < rows; j++)\\n                {\\n                    if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                    {\\n                        int fi = getFather(i);\\n                        int fj = getFather(j);\\n                        father[fi] = fj;\\n                    }\\n                }\\n            }        \\n\\n            // Disjoint set count upper limit -> total number of rows or columns\\n            int result = 0;\\n\\n            for (int i = 0; i < rows; i++)\\n            {\\n                int fi = getFather(i);\\n                if (i == fi)\\n                {\\n                    result++;\\n                }\\n            }\\n\\n            return rows - result; \\n        }\\n    }\\n}\\n```\\n\\n\\n\\n**Solution 7: Union find algorithm** \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones___union_join\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var stones = new int[6][]{\\n                new int[]{0,0},\\n                new int[]{0,1},\\n                new int[]{1,0},\\n                new int[]{1,2},\\n                new int[]{2,1},\\n                new int[]{2,2}\\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n        \\n        public static int[] Size   = new int[1005];\\n        public static int[] Parent = new int[1005];\\n\\n        /// <summary>\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking\\n        /// rank No. 40 biltharesatyendra\\n        /// \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            var length = stones.Length;\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                Parent[i] = i;\\n                Size[i] = 1;\\n            }          \\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                for (int j = i + 1; j < length; j++)\\n                {\\n                    if (stones[i][0] == stones[j][0] ||\\n                        stones[i][1] == stones[j][1])\\n                    {\\n                        union(i, j);\\n                    }\\n                }\\n            }\\n\\n            // count of disjoint sets\\n            int answer = 0;\\n            for (int i = 0; i < length; i++)\\n            {\\n                if (find(i) == i)\\n                {\\n                    answer += Size[i] - 1; \\n                }\\n            }\\n\\n            return answer;\\n        }\\n\\n        /// <summary>\\n        /// code review:\\n        /// union and rank is simplified, and this version of code is easy to follow\\n        /// Rule 1: Parent node has higher rank compared to its child node\\n        /// union is to connect two root nodes of tree, not input arguments id1 and id2.  \\n        /// </summary>\\n        /// <param name=\"i\"></param>\\n        /// <param name=\"j\"></param>\\n        private static void union(int id1, int id2)\\n        {\\n            id1 = find(id1); // To avoid the bug to confuse id1 and find(id1), change id1\\'s value\\n            id2 = find(id2);\\n\\n            if (id1 == id2)\\n            {\\n                return;\\n            }\\n\\n            if (Size[id1] < Size[id2])\\n            {\\n                swap(ref id1, ref id2);\\n            };            \\n            \\n            Parent[id2] = id1;\\n            Size[id1] += Size[id2];           \\n        }\\n\\n        public static void swap(ref int x, ref int y)\\n        {\\n            var tmp = x;\\n            x = y;\\n            y = tmp; \\n        }\\n\\n        /// <summary>\\n        /// code review:\\n        /// find is to search tree structure and find the root of tree the node stays\\n        /// </summary>\\n        /// <param name=\"id\"></param>\\n        /// <returns></returns>\\n        private static int find(int id)\\n        {\\n            if (id != Parent[id])\\n            {\\n                Parent[id] = find(Parent[id]);\\n            }\\n\\n            return Parent[id];\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones_rank_16\\n{\\n    class Program\\n    {\\n        /// <summary>\\n        /// Leetcode 947 remove stones\\n        /// </summary>\\n        /// <param name=\"args\"></param>\\n        static void Main(string[] args)\\n        {\\n            RunTestcase2(); \\n        }\\n\\n        public static void RunTestcase1()\\n        {\\n            var stones = new int[6][]{\\n                new int[]{0,0},\\n                new int[]{0,1},\\n                new int[]{1,0},\\n                new int[]{1,2},\\n                new int[]{2,1},\\n                new int[]{2,2}\\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        public static void RunTestcase2()\\n        {\\n            var stones = new int[5][]{\\n                new int[]{0,0},\\n                new int[]{0,2},\\n                new int[]{1,1},\\n                new int[]{2,0},\\n                new int[]{2,2}                \\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        public static List<int>[] graph = new List<int>[1123];\\n        public static int[] Visited = new int[1123];\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking/\\n        /// Ranking No. 16 sohelH\\n        /// Two tips to construct a undirected graph\\n        /// 1. brute force all possible edges\\n        /// 2. check if two nodes are in the same row or same column. If it is same row or column, \\n        /// then the two nodes are connected. \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            int length = stones.Length;\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                graph[i] = new List<int>();\\n                Visited[i] = 0;\\n            }\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                for (int j = i + 1; j < length; j++)\\n                {\\n                    int r1 = stones[i][0];\\n                    int c1 = stones[i][1];\\n                    int r2 = stones[j][0];\\n                    int c2 = stones[j][1];\\n\\n                    if (r1 == r2 || c1 == c2)\\n                    {\\n                        graph[i].Add(j);\\n                        graph[j].Add(i);\\n                    }\\n                }\\n            }\\n\\n            int components = 0;\\n            for (int i = 0; i < length; i++)\\n            {\\n                if (Visited[i] == 0)\\n                {\\n                    dfs(i);\\n                    components++;\\n                }\\n            }\\n\\n            return length - components;\\n        }\\n\\n        private static void dfs(int u)\\n        {\\n            if (Visited[u] == 1)\\n            {\\n                return;\\n            }\\n\\n            Visited[u] = 1;\\n            for (int i = 0; i < graph[u].Count; i++)\\n            {\\n                dfs(graph[u][i]);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones___DFS\\n{\\n    class Program\\n    {\\n        /// <summary>\\n        /// Leetcode 947 remove stones\\n        /// </summary>\\n        /// <param name=\"args\"></param>\\n        static void Main(string[] args)\\n        {\\n            RunTestcase2(); \\n        }\\n\\n        public static void RunTestcase1()\\n        {\\n            var stones = new int[6][]{\\n                new int[]{0,0},\\n                new int[]{0,1},\\n                new int[]{1,0},\\n                new int[]{1,2},\\n                new int[]{2,1},\\n                new int[]{2,2}\\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        public static void RunTestcase2()\\n        {\\n            var stones = new int[5][]{\\n                new int[]{0,0},\\n                new int[]{0,2},\\n                new int[]{1,1},\\n                new int[]{2,0},\\n                new int[]{2,2}                \\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        public static int Rows; \\n        public static bool[][] graph = new bool[1005][];\\n        public static bool[]   visited = new bool[1005];\\n\\n        /// <summary>\\n        /// study code\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking/\\n        /// Ranking No. 5 joon_young\\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            Rows = stones.Length;\\n\\n            for (int row = 0; row < 1005; row++)\\n            {\\n                graph[row] = new bool[1005];\\n            }\\n\\n            // reset to false\\n            for (int row = 0; row < 1005; row++)\\n            {\\n                visited[row] = false; \\n            }\\n\\n            for (int row = 0; row < Rows; row++)\\n            {\\n                for (int j = row + 1; j < Rows; j++)\\n                {\\n                    if (stones[row][0] == stones[j][0] ||\\n                        stones[row][1] == stones[j][1])\\n                    {\\n                        graph[row][j] = true;\\n                        graph[j][row] = true;\\n                    }\\n                }\\n            }\\n\\n            int result = 0;\\n            for (int row = 0; row < Rows; row++)\\n            {\\n                if(visited[row])\\n                {\\n                    continue;\\n                }\\n\\n                result++;\\n\\n                dfs(row);\\n            }\\n\\n            return Rows - result; \\n        }\\n\\n        private static void dfs(int id)\\n        {\\n            if (visited[id])\\n                return;\\n\\n            visited[id] = true; \\n\\n            for (int row = 0; row < Rows; row++)\\n            {\\n                if (graph[id][row])\\n                {\\n                    dfs(row);\\n                }\\n            }\\n        }\\n    }\\n}\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones_Rank_176\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            RunTestcase1();\\n        }\\n\\n        public static void RunTestcase1()\\n        {\\n            var stones = new int[7][]{\\n                new int[]{3, 2},\\n                new int[]{0, 0},\\n                new int[]{3, 3},\\n                new int[]{2, 1},\\n                new int[]{2, 3},\\n                new int[]{2, 2},\\n                new int[]{0, 2}\\n            };\\n\\n            var number = RemoveStones(stones); \\n        }\\n\\n        // [[3,3],[4,4],[1,4],[1,5],[2,3],[4,3],[2,4]]\\n        public static void RunTestcase2()\\n        {\\n            var stones = new int[7][]{\\n                new int[]{3, 3},\\n                new int[]{4, 4},\\n                new int[]{1, 4},\\n                new int[]{1, 5},\\n                new int[]{2, 3},\\n                new int[]{4, 3},\\n                new int[]{2, 4}\\n            };\\n\\n            var number = RemoveStones(stones);\\n        }\\n\\n        /// <summary>\\n        /// study code weekly contest 112\\n        /// Rank 176 \\n        /// https://leetcode.com/contest/weekly-contest-112/ranking/8/\\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            var length = stones.Length;\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                Parent[i] = i;              \\n            }           \\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                for (int j = i + 1; j < length; j++)\\n                {\\n                    if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                    {\\n                        if (Parent[i] != Parent[j])\\n                        {\\n                            union(i, j);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            int number = 0;\\n            for (int i = 0; i < length; i++)\\n            {\\n                if(i == Parent[i])\\n                {\\n                    number++;\\n                }\\n            }\\n\\n            return length - number; \\n        }\\n\\n        public static int[] Parent = new int[1005];\\n        public static int[] Rank   = new int[1005];\\n\\n        /// <summary>\\n        /// path compression\\n        /// https://algs4.cs.princeton.edu/15uf/QuickUnionPathCompressionUF.java.html\\n        /// </summary>\\n        /// <param name=\"x\"></param>\\n        /// <returns></returns>\\n        private static int getParent_Obsolete(int x)\\n        {           \\n            while (Parent[x] != x)\\n            {\\n                x = Parent[x];\\n            }\\n          \\n            return x; \\n        }\\n\\n        /// <summary>\\n        /// study code from \\n        /// https://algs4.cs.princeton.edu/15uf/QuickUnionPathCompressionUF.java.html\\n        /// </summary>\\n        /// <param name=\"p\"></param>\\n        /// <returns></returns>\\n        public static int getParent(int p)\\n        {\\n            int root = p;\\n            while (root != Parent[root])\\n            {\\n                root = Parent[root];\\n            }\\n\\n            while (p != root)\\n            {\\n                int newp = Parent[p];\\n                Parent[p] = root;\\n                p = newp;\\n            }\\n\\n            return root;\\n        }\\n\\n        /// <summary>\\n        /// this function has a bug \\n        /// var root1 = Parent[id1] -- should be -> var root1 = getParent(id1)\\n        /// In other words, I need to separate intermediate node from root node of tree.\\n        /// </summary>\\n        /// <param name=\"id1\"></param>\\n        /// <param name=\"id2\"></param>\\n        private static void union_Buggy(int id1, int id2)\\n        {\\n            var root1 = Parent[id1];\\n            var root2 = Parent[id2];            \\n\\n            Parent[root2] = root1;            \\n        }\\n\\n        private static void union(int id1, int id2)\\n        {\\n            var root1 = getParent(id1);\\n            var root2 = getParent(id2);\\n\\n            Parent[root2] = root1;\\n        }\\n    }\\n}\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones___union_join\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var stones = new int[6][]{\\n                new int[]{0,0},\\n                new int[]{0,1},\\n                new int[]{1,0},\\n                new int[]{1,2},\\n                new int[]{2,1},\\n                new int[]{2,2}\\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        public static int[] Parent;\\n        public static int[] Size;\\n        public static int[] Rank;\\n\\n        public static int   Total; \\n\\n        /// <summary>\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking\\n        /// rank No. 13 yangmei555\\n        /// \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            var length = stones.Length;\\n\\n            Parent = new int[length];\\n            Size = new int[length];\\n            Rank = new int[length];\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                Parent[i] = i;\\n                Size[i] = 1; \\n            }\\n\\n            Total = length;\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                for (int j = i + 1; j < length; j++)\\n                {\\n                    if (stones[i][0] == stones[j][0] ||\\n                       stones[i][1] == stones[j][1])\\n                    {\\n                        union(i, j);            \\n                    }\\n                }\\n            }\\n\\n            return length - Total; \\n        }\\n\\n        /// <summary>\\n        /// code review:\\n        /// union and rank is simplified, and this version of code is easy to follow\\n        /// Rule 1: Parent node has higher rank compared to its child node\\n        /// union is to connect two root nodes of tree. \\n        /// </summary>\\n        /// <param name=\"i\"></param>\\n        /// <param name=\"j\"></param>\\n        private static void union(int i, int j)\\n        {\\n            int id1 = find(i);\\n            int id2 = find(j);\\n\\n            if (id1 != id2)\\n            {\\n                Total--;\\n\\n                if (Rank[id1] <= Rank[id2])\\n                {\\n                    Parent[id1] = id2;\\n                    if (Rank[id1] == Rank[id2])\\n                    {\\n                        Rank[id2]++;\\n                    }\\n                }\\n                else\\n                {\\n                    Parent[id2] = id1; \\n                }\\n            }\\n        }\\n\\n        /// <summary>\\n        /// code review:\\n        /// find is to search tree structure and find the root of tree the node stays\\n        /// </summary>\\n        /// <param name=\"id\"></param>\\n        /// <returns></returns>\\n        private static int find(int id)\\n        {\\n            if (id != Parent[id])\\n            {\\n                Parent[id] = find(Parent[id]);\\n            }\\n\\n            return Parent[id];\\n        }\\n    }\\n}\\n\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_ranking_117\\n{\\n    class Program\\n    {        \\n        public static void RunTestcase2()\\n        {\\n            var stones = new int[7][]{\\n                new int[]{3, 3},\\n                new int[]{4, 4},\\n                new int[]{1, 4},\\n                new int[]{1, 5},\\n                new int[]{2, 3},\\n                new int[]{4, 3},\\n                new int[]{2, 4}\\n            };\\n\\n            var number = RemoveStones(stones);\\n        }\\n\\n        static void Main(string[] args)\\n        {\\n            RunTestcase2(); \\n        }\\n\\n        /// <summary>\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking/5/\\n        /// rank 117\\n        /// yajingleo\\n        /// \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            var length = stones.Length;\\n            var root = new int[length];\\n            for (int i = 0; i < length; i++)\\n            {\\n                root[i] = i;\\n            }\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                for (int j = 0; j < length; j++)\\n                {\\n                    if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                    {\\n                        var root1 = getRoot(root, i);\\n                        var root2 = getRoot(root, j);\\n\\n                        // given constraint on the root, smaller index will be the root. \\n                        root[root2] = root1;\\n                    }\\n                }\\n            }\\n\\n            int result = length;\\n            for(int i = 0; i < length; i++)\\n            {\\n                if(root[i] == i)\\n                {\\n                    result--; \\n                }\\n            }\\n\\n            return result; \\n        }\\n\\n        /// <summary>\\n        /// code review April 4, 2019\\n        /// It is better to use while loop instead of recursive function\\n        /// </summary>\\n        /// <param name=\"root\"></param>\\n        /// <param name=\"i\"></param>\\n        /// <returns></returns>\\n        private static int getRoot(int[] root, int i)\\n        {\\n            while (root[i] != i)\\n            {\\n                i = root[i];\\n            }\\n\\n            return i; \\n        }\\n    }\\n}\\n```\n```\\n for (int i = 0; i < rows; i++)\\n {\\n        for (int j = i + 1; j < rows; j++)\\n        {\\n               if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n               {\\n                    int fi = getFather(i);\\n                    int fj = getFather(j);\\n                    father[fi] = fj;\\n               }\\n        }\\n }       \\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n\\n            var stones = new int[6][]{\\n                new int[]{0,0},\\n                new int[]{0,1},\\n                new int[]{1,0},\\n                new int[]{1,2},\\n                new int[]{2,1},\\n                new int[]{2,2}\\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n\\n        private static List<int> father;\\n\\n        /// <summary>\\n        /// \\n        /// </summary>\\n        /// <param name=\"i\"></param>\\n        /// <returns></returns>\\n        private static int getFather(int search)        \\n        {\\n            if (search == father[search])\\n            {\\n                return search;\\n            }\\n\\n            int root = getFather(father[search]);\\n\\n            father[search] = root;\\n\\n            return root;                            \\n        }\\n\\n        /// <summary>\\n        /// Leetcode 947\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking/\\n        /// ranking 8\\n        /// Windsfantasy6\\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            var rows = stones.Length;\\n\\n            father = new List<int>();\\n            for (int i = 0; i < rows; i++)\\n            {\\n                father.Add(i);\\n            }\\n\\n            for (int i = 0; i < rows; i++)\\n            {\\n                for (int j = i + 1; j < rows; j++)\\n                {\\n                    if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                    {\\n                        int fi = getFather(i);\\n                        int fj = getFather(j);\\n                        father[fi] = fj;\\n                    }\\n                }\\n            }        \\n\\n            // Disjoint set count upper limit -> total number of rows or columns\\n            int result = 0;\\n\\n            for (int i = 0; i < rows; i++)\\n            {\\n                int fi = getFather(i);\\n                if (i == fi)\\n                {\\n                    result++;\\n                }\\n            }\\n\\n            return rows - result; \\n        }\\n    }\\n}\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _947_remove_stones___union_join\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var stones = new int[6][]{\\n                new int[]{0,0},\\n                new int[]{0,1},\\n                new int[]{1,0},\\n                new int[]{1,2},\\n                new int[]{2,1},\\n                new int[]{2,2}\\n            };\\n\\n            var result = RemoveStones(stones);\\n        }\\n        \\n        public static int[] Size   = new int[1005];\\n        public static int[] Parent = new int[1005];\\n\\n        /// <summary>\\n        /// https://leetcode.com/contest/weekly-contest-112/ranking\\n        /// rank No. 40 biltharesatyendra\\n        /// \\n        /// </summary>\\n        /// <param name=\"stones\"></param>\\n        /// <returns></returns>\\n        public static int RemoveStones(int[][] stones)\\n        {\\n            var length = stones.Length;\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                Parent[i] = i;\\n                Size[i] = 1;\\n            }          \\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                for (int j = i + 1; j < length; j++)\\n                {\\n                    if (stones[i][0] == stones[j][0] ||\\n                        stones[i][1] == stones[j][1])\\n                    {\\n                        union(i, j);\\n                    }\\n                }\\n            }\\n\\n            // count of disjoint sets\\n            int answer = 0;\\n            for (int i = 0; i < length; i++)\\n            {\\n                if (find(i) == i)\\n                {\\n                    answer += Size[i] - 1; \\n                }\\n            }\\n\\n            return answer;\\n        }\\n\\n        /// <summary>\\n        /// code review:\\n        /// union and rank is simplified, and this version of code is easy to follow\\n        /// Rule 1: Parent node has higher rank compared to its child node\\n        /// union is to connect two root nodes of tree, not input arguments id1 and id2.  \\n        /// </summary>\\n        /// <param name=\"i\"></param>\\n        /// <param name=\"j\"></param>\\n        private static void union(int id1, int id2)\\n        {\\n            id1 = find(id1); // To avoid the bug to confuse id1 and find(id1), change id1\\'s value\\n            id2 = find(id2);\\n\\n            if (id1 == id2)\\n            {\\n                return;\\n            }\\n\\n            if (Size[id1] < Size[id2])\\n            {\\n                swap(ref id1, ref id2);\\n            };            \\n            \\n            Parent[id2] = id1;\\n            Size[id1] += Size[id2];           \\n        }\\n\\n        public static void swap(ref int x, ref int y)\\n        {\\n            var tmp = x;\\n            x = y;\\n            y = tmp; \\n        }\\n\\n        /// <summary>\\n        /// code review:\\n        /// find is to search tree structure and find the root of tree the node stays\\n        /// </summary>\\n        /// <param name=\"id\"></param>\\n        /// <returns></returns>\\n        private static int find(int id)\\n        {\\n            if (id != Parent[id])\\n            {\\n                Parent[id] = find(Parent[id]);\\n            }\\n\\n            return Parent[id];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180148,
                "title": "c-union-find-solution-with-explanation",
                "content": "We connect those stones with same row and column. Notice that in a connected component we can remove at max all the stones except one. This can be proved by induction. So the answer is simply number of stones - number of connected components in the graph. To group the stones, we use DSU/Union-Find. First we set the co-ordinates of the stones such that x and y never collide(see code : makes our dsu simpler). After this, we unify the same point\\'s x and y co-ordinate and put other points if any of these co-oridnates match. \\n#### Code\\n```cpp\\nclass Solution {\\npublic:\\n    int findParent(int x, unordered_map<int, int> &parent){\\n        if(x == parent[x]) return x; \\n        return parent[x] = findParent(parent[x], parent); \\n    }\\n    \\n    void unify(int x, int y, unordered_map<int, int> &parent){\\n        int px = findParent(x, parent), py = findParent(y, parent); \\n        if(px == py)return ; \\n        parent[py] = px; \\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        unordered_map<int, int> parent; \\n        for(auto stone : stones){\\n\\t        // we do this to avoid any collisions in the row and column\\n            int x = stone[0] + 1; \\n            int y = -(stone[1] + 1); \\n            parent[x] = x; \\n            parent[y] = y; \\n        }\\n        // Unifying x, y of the same stone and grouping the stones \\n        for(auto stone : stones){\\n            int x = stone[0] + 1; \\n            int y = -(stone[1] + 1); \\n            unify(x, y, parent); \\n        }\\n        \\n        unordered_set<int> s; \\n        for(auto x : parent){\\n            s.insert(findParent(x.second, parent));\\n        }\\n        \\n        return  stones.size() - s.size(); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findParent(int x, unordered_map<int, int> &parent){\\n        if(x == parent[x]) return x; \\n        return parent[x] = findParent(parent[x], parent); \\n    }\\n    \\n    void unify(int x, int y, unordered_map<int, int> &parent){\\n        int px = findParent(x, parent), py = findParent(y, parent); \\n        if(px == py)return ; \\n        parent[py] = px; \\n    }\\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        unordered_map<int, int> parent; \\n        for(auto stone : stones){\\n\\t        // we do this to avoid any collisions in the row and column\\n            int x = stone[0] + 1; \\n            int y = -(stone[1] + 1); \\n            parent[x] = x; \\n            parent[y] = y; \\n        }\\n        // Unifying x, y of the same stone and grouping the stones \\n        for(auto stone : stones){\\n            int x = stone[0] + 1; \\n            int y = -(stone[1] + 1); \\n            unify(x, y, parent); \\n        }\\n        \\n        unordered_set<int> s; \\n        for(auto x : parent){\\n            s.insert(findParent(x.second, parent));\\n        }\\n        \\n        return  stones.size() - s.size(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2134692,
                "title": "java-union-find-solution",
                "content": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        UnionFind uf = new UnionFind(stones.length);\\n        for(int[] stone: stones)\\n            uf.map.put(stone[0] + \" \" + stone[1], stone[0] + \" \" + stone[1]);\\n        \\n        for(int i = 0; i < stones.length; i++)\\n        {\\n            String a = stones[i][0] + \" \" + stones[i][1];\\n            for(int j = i + 1; j < stones.length; j++)\\n            {\\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                {\\n                    String b = stones[j][0] + \" \" + stones[j][1];\\n                    uf.Union(a, b);\\n                }\\n            }\\n        }\\n        \\n        return stones.length - uf.components;\\n    }\\n    \\n    class UnionFind {\\n        HashMap<String, String> map;\\n        int components;\\n        \\n        public UnionFind(int n)\\n        {\\n            components = n;\\n            map = new HashMap();\\n        }\\n        \\n        private String Find(String a)\\n        {\\n            if(!map.get(a).equals(a))\\n                map.put(a, Find(map.get(a)));\\n            \\n            return map.get(a);\\n        }\\n        \\n        private boolean Union(String a, String b)\\n        {\\n            String parentA = Find(a);\\n            String parentB = Find(b);\\n            if(parentA.equals(parentB))\\n                return false;\\n            \\n            map.put(parentA, parentB);\\n            components--;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        UnionFind uf = new UnionFind(stones.length);\\n        for(int[] stone: stones)\\n            uf.map.put(stone[0] + \" \" + stone[1], stone[0] + \" \" + stone[1]);\\n        \\n        for(int i = 0; i < stones.length; i++)\\n        {\\n            String a = stones[i][0] + \" \" + stones[i][1];\\n            for(int j = i + 1; j < stones.length; j++)\\n            {\\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\\n                {\\n                    String b = stones[j][0] + \" \" + stones[j][1];\\n                    uf.Union(a, b);\\n                }\\n            }\\n        }\\n        \\n        return stones.length - uf.components;\\n    }\\n    \\n    class UnionFind {\\n        HashMap<String, String> map;\\n        int components;\\n        \\n        public UnionFind(int n)\\n        {\\n            components = n;\\n            map = new HashMap();\\n        }\\n        \\n        private String Find(String a)\\n        {\\n            if(!map.get(a).equals(a))\\n                map.put(a, Find(map.get(a)));\\n            \\n            return map.get(a);\\n        }\\n        \\n        private boolean Union(String a, String b)\\n        {\\n            String parentA = Find(a);\\n            String parentB = Find(b);\\n            if(parentA.equals(parentB))\\n                return false;\\n            \\n            map.put(parentA, parentB);\\n            components--;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117075,
                "title": "python-3-union-find",
                "content": "\\tclass Solution:\\n    def __init__(self):\\n        self.n = 1000\\n        self.father = [i for i in range(self.n)]\\n    \\n    def find(self, u):\\n        if u == self.father[u]:\\n            return u\\n        self.father[u] = self.find(self.father[u])\\n        return self.father[u]\\n    \\n    def join(self, u, v):\\n        u = self.find(u)\\n        v = self.find(v)\\n        if u == v:\\n            return\\n        self.father[v] = u\\n    \\n    def same(self, u, v):\\n        return self.find(u) == self.find(v)\\n    \\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        if len(stones) == 1:\\n            return 0\\n        \\n        for i in range(len(stones)):\\n            cur = stones[i]\\n            for j in range(i+1, len(stones)):\\n                if stones[j][0] == cur[0] or stones[j][1] == cur[1]:\\n                    self.join(i, j)\\n        \\n        ans = 0\\n        for i in range(len(stones)):\\n            if self.father[i] != i:\\n                ans += 1\\n        \\n        return ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def __init__(self):\\n        self.n = 1000\\n        self.father = [i for i in range(self.n)]\\n    \\n    def find(self, u):\\n        if u == self.father[u]:\\n            return u\\n        self.father[u] = self.find(self.father[u])\\n        return self.father[u]\\n    \\n    def join(self, u, v):\\n        u = self.find(u)\\n        v = self.find(v)\\n        if u == v:\\n            return\\n        self.father[v] = u\\n    \\n    def same(self, u, v):\\n        return self.find(u) == self.find(v)\\n    \\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        if len(stones) == 1:\\n            return 0\\n        \\n        for i in range(len(stones)):\\n            cur = stones[i]\\n            for j in range(i+1, len(stones)):\\n                if stones[j][0] == cur[0] or stones[j][1] == cur[1]:\\n                    self.join(i, j)\\n        \\n        ans = 0\\n        for i in range(len(stones)):\\n            if self.father[i] != i:\\n                ans += 1\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2052245,
                "title": "c-union-find",
                "content": "```\\nclass Solution {\\n    vector<int> parents;\\n    \\n    int Find(int a) {\\n        if (parents[a] != a) {\\n            parents[a] = Find(parents[a]);\\n        }\\n        \\n        return parents[a];\\n    }\\n    \\n    void Union(int a, int b) {\\n        if (a < b) {\\n            parents[a] = b;\\n        } else {\\n            parents[b] = a;\\n        }\\n    }\\n    \\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        \\n        parents.resize(n);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            parents[i] = i;\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\\n                    int pa = Find(i);\\n                    int pb = Find(j);\\n                    \\n                    if (pa != pb) {\\n                        Union(pa, pb);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cnt += parents[i] == i;\\n        }\\n        \\n        return n - cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> parents;\\n    \\n    int Find(int a) {\\n        if (parents[a] != a) {\\n            parents[a] = Find(parents[a]);\\n        }\\n        \\n        return parents[a];\\n    }\\n    \\n    void Union(int a, int b) {\\n        if (a < b) {\\n            parents[a] = b;\\n        } else {\\n            parents[b] = a;\\n        }\\n    }\\n    \\npublic:\\n    int removeStones(vector<vector<int>>& stones) {\\n        int n = stones.size();\\n        \\n        parents.resize(n);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            parents[i] = i;\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = i + 1; j < n; ++j) {\\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\\n                    int pa = Find(i);\\n                    int pb = Find(j);\\n                    \\n                    if (pa != pb) {\\n                        Union(pa, pb);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cnt += parents[i] == i;\\n        }\\n        \\n        return n - cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985401,
                "title": "python-simple-dfs",
                "content": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        n = len(stones)\\n        graph = defaultdict(list)\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\\n                    graph[i].append(j)\\n                    graph[j].append(i)\\n                    \\n        def dfs(idx):\\n            visited[idx] = True\\n            for nei in graph[idx]:\\n                if not visited[nei]:\\n                    dfs(nei)\\n                    \\n        visited = [False] * n\\n        res = 0\\n        for i in range(n):\\n            if not visited[i]:\\n                res += 1\\n                dfs(i)\\n                \\n        return n - res\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        n = len(stones)\\n        graph = defaultdict(list)\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:\\n                    graph[i].append(j)\\n                    graph[j].append(i)\\n                    \\n        def dfs(idx):\\n            visited[idx] = True\\n            for nei in graph[idx]:\\n                if not visited[nei]:\\n                    dfs(nei)\\n                    \\n        visited = [False] * n\\n        res = 0\\n        for i in range(n):\\n            if not visited[i]:\\n                res += 1\\n                dfs(i)\\n                \\n        return n - res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665655,
                "title": "concise-java-unionfind",
                "content": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        int n = stones.length;\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\\n                    uf.union(i, j);\\n                }\\n            }\\n        }\\n        return n - uf.count;\\n    }\\n}\\n\\nclass UnionFind {\\n    public int[] rank;\\n    public int[] root;\\n    public int count;\\n\\n    public UnionFind(int n) {\\n        rank = new int[n];\\n        root = new int[n];\\n        count = n;\\n        for (int i = 0; i < n; i++) {\\n            rank[i] = 1;\\n            root[i] = i;\\n        }\\n    }\\n\\n    public void union(int i, int j) {\\n        int rootI = find(i);\\n        int rootJ = find(j);\\n        if (rootI != rootJ) {\\n            if (rank[i] == rank[j]) {\\n                rank[i] += 1;\\n                root[rootJ] = rootI;\\n            } else if (rank[i] > rank[j]) {\\n                root[rootJ] = rootI;\\n            } else {\\n                root[rootI] = rootJ;\\n            }\\n            count--;\\n        }\\n    }\\n\\n    private int find(int i) {\\n        if (i == root[i])\\n            return i;\\n        else\\n            return root[i] = find(root[i]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public int removeStones(int[][] stones) {\\n        int n = stones.length;\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = i + 1; j < n; j++) {\\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\\n                    uf.union(i, j);\\n                }\\n            }\\n        }\\n        return n - uf.count;\\n    }\\n}\\n\\nclass UnionFind {\\n    public int[] rank;\\n    public int[] root;\\n    public int count;\\n\\n    public UnionFind(int n) {\\n        rank = new int[n];\\n        root = new int[n];\\n        count = n;\\n        for (int i = 0; i < n; i++) {\\n            rank[i] = 1;\\n            root[i] = i;\\n        }\\n    }\\n\\n    public void union(int i, int j) {\\n        int rootI = find(i);\\n        int rootJ = find(j);\\n        if (rootI != rootJ) {\\n            if (rank[i] == rank[j]) {\\n                rank[i] += 1;\\n                root[rootJ] = rootI;\\n            } else if (rank[i] > rank[j]) {\\n                root[rootJ] = rootI;\\n            } else {\\n                root[rootI] = rootJ;\\n            }\\n            count--;\\n        }\\n    }\\n\\n    private int find(int i) {\\n        if (i == root[i])\\n            return i;\\n        else\\n            return root[i] = find(root[i]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659025,
                "title": "bfs-hashmap",
                "content": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        # create a completed graph, use graphX to store the node with same x axis and use graphY to store  the node with the same y axis\\n        # Use BFS\\n        # Use visited to store the passed node\\n        # for one conneted graph count the (node number -1), and let it be ni\\n        # At the end, add all the ni in each connected graphs\\n        # Time: O(V+E) Space:O(V+E)\\n        \\n        \\n        hmapX = defaultdict(list)\\n        hmapY = defaultdict(list)\\n        for st in stones:\\n            hmapX[st[0]].append(tuple(st))\\n            hmapY[st[1]].append(tuple(st))\\n        print(hmapX)\\n        print(hmapY)\\n        \\n        visited = set()\\n        \\n        count = 0 \\n        for st in stones:\\n            if tuple(st) not in visited:\\n                queue =deque([tuple(st)])\\n                while queue:\\n                    curr = queue.popleft()\\n                    count += 1\\n                    visited.add(curr)\\n                    for nei in hmapX[curr[0]]:\\n                        if nei not in visited:\\n                            queue.append(nei)\\n                            visited.add(nei)\\n                    for nei in hmapY[curr[1]]:\\n                        if nei not in visited:\\n                            queue.append(nei)\\n                            visited.add(nei)\\n                count -= 1\\n        return count\\n                \\n            \\n            \\n            \\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        # create a completed graph, use graphX to store the node with same x axis and use graphY to store  the node with the same y axis\\n        # Use BFS\\n        # Use visited to store the passed node\\n        # for one conneted graph count the (node number -1), and let it be ni\\n        # At the end, add all the ni in each connected graphs\\n        # Time: O(V+E) Space:O(V+E)\\n        \\n        \\n        hmapX = defaultdict(list)\\n        hmapY = defaultdict(list)\\n        for st in stones:\\n            hmapX[st[0]].append(tuple(st))\\n            hmapY[st[1]].append(tuple(st))\\n        print(hmapX)\\n        print(hmapY)\\n        \\n        visited = set()\\n        \\n        count = 0 \\n        for st in stones:\\n            if tuple(st) not in visited:\\n                queue =deque([tuple(st)])\\n                while queue:\\n                    curr = queue.popleft()\\n                    count += 1\\n                    visited.add(curr)\\n                    for nei in hmapX[curr[0]]:\\n                        if nei not in visited:\\n                            queue.append(nei)\\n                            visited.add(nei)\\n                    for nei in hmapY[curr[1]]:\\n                        if nei not in visited:\\n                            queue.append(nei)\\n                            visited.add(nei)\\n                count -= 1\\n        return count\\n                \\n            \\n            \\n            \\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545054,
                "title": "typescript-commented-solution-96-130ms",
                "content": "I don\\'t know the Union and Find terms, I\\'m not sure whether or not this solution is equivalent to those solutions. But this is how I conceptualize the problem and it seems to run fairly fast.\\n\\n----\\n\\nConsider the stones to be nodes in a graph. If two stones share a row or column, they are connected.\\n\\nIf we have a collection of connected nodes (a graph), in any configuration, we can always remove all but 1 of those nodes.\\n\\n```typescript\\n// x-x-x  \\n//   |    remove left node, right node, and bottom node.\\n//   x \\n//\\n// x-x\\n// | |   remove nodes in a clockwise fashion\\n// x-x\\n//\\n// x-x  remove one node\\n//\\n// x-x-x-x-x  remove nodes from end to end.\\n```\\n\\n\\nKnowing this, we can write our program to track connected graphs from the stones, count the number of nodes in each graph, and compute the result from the list of graphs.\\n\\n```typescript\\ntype Graph = {\\n    rows: Set<number>;\\n    cols: Set<number>;\\n    count: number;\\n}\\nfunction removeStones(stones: Array<[number,number]>): number {\\n    \\n    // Keep track of all unique graphs separately for ease of lookup later.\\n    const allGraphs = new Set<Graph>();\\n    \\n    // Keep an index of all of our graphs by the rows and columns each of them have.\\n    const graphs = {\\n        byRow: new Map<number, Graph>(),\\n        byCol: new Map<number, Graph>(),\\n    };\\n    \\n    // Loop through every stone and compare it against our list of known graphs.\\n    for(const [x,y] of stones) {\\n        // Look up any graphs this stone can connect to.\\n        const rowGraph = graphs.byRow.get(x);\\n        const colGraph = graphs.byCol.get(y);\\n        \\n        \\n        if(rowGraph === colGraph) {\\n            // Both graphs are the same, but are they defined?\\n            if(rowGraph) {\\n                // This stone completes a cycle on an existing graph\\n                // e.g.\\n                // x - x\\n                // |   |\\n                // x -(x) <--- this guy.\\n                // No new rows or columns added.\\n                rowGraph.count++;\\n            } else {\\n                // This stone is connected to no existing graphs,\\n                // So it starts its own graph.\\n                const newGraph = {\\n                    rows: new Set([x]),\\n                    cols: new Set([y]),\\n                    count: 1\\n                };\\n                // Add the graph to our global list, and index it by its row/col\\n                allGraphs.add(newGraph);\\n                graphs.byRow.set(x, newGraph);\\n                graphs.byCol.set(y, newGraph);\\n            }\\n        } else if(rowGraph && !colGraph) {\\n            // This stone connects to 1 existing graph by its row.\\n            // Its column is new to this graph, so track it.\\n            rowGraph.cols.add(y);\\n            // Update the index to point to this graph for the new column\\n            graphs.byCol.set(y, rowGraph);\\n            // The size of our graph increases!\\n            rowGraph.count++;\\n        } else if(colGraph && !rowGraph) {\\n            // This stone connects to 1 existing graph by its column.\\n            // Its row is new to this graph, so track it.\\n            colGraph.rows.add(x)\\n            // Update the index to point to this graph for the new row\\n            graphs.byRow.set(x, colGraph);\\n            // The size of our graph increases!\\n            colGraph.count++;\\n        } else {\\n            // This stone matches two existing graphs!\\n            // We should merge the two graphs and update our row/col indexes\\n            \\n            // Optional optimization: Let\\'s have the graph with more rows/cols consume the one with fewer.\\n            //       This reduces the number of updates we will make to our rol/col index\\n            const [smaller, bigger] = getGraphSpan(rowGraph) > getGraphSpan(colGraph) \\n                ? [colGraph, rowGraph]\\n                : [rowGraph, colGraph];\\n            \\n            // Take every row in our smaller graph,\\n            // Update the row index to point to the bigger graph,\\n            // and add the rows to the bigger graph\\'s list\\n            smaller.rows.forEach((r) => {\\n                graphs.byRow.set(r, bigger)\\n                bigger.rows.add(r);\\n            });\\n            \\n            // Take every column in our smaller graph,\\n            // Update the column index to point to the bigger graph,\\n            // and add the column to the bigger graph\\'s list\\n            smaller.cols.forEach((c) => {\\n                graphs.byCol.set(c, bigger);\\n                bigger.cols.add(c);\\n            });\\n            \\n            // We\\'re adding all of the smaller graph\\'s nodes, plus one brand new one that formed the union of the graphs.\\n            bigger.count += smaller.count + 1;\\n            // Remove the smaller graph from our list of all graphs.\\n            allGraphs.delete(smaller);\\n        }\\n    }\\n    \\n    return Array.from(allGraphs).               // Take all final remaining graphs\\n        filter(g => g.count > 1).               // Ignore any graphs of size 1 (they can\\'t be removed)\\n        map(g => g.count - 1).                  // Get the number of stones that can be removed from this graph\\n        reduce((acc, next) => acc + next, 0);   // Sum them all together.\\n};\\n\\n// Return the number of rows & columns this graph spans.\\nfunction getGraphSpan(g: Graph) {\\n    return g.rows.size + g.cols.size;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\n// x-x-x  \\n//   |    remove left node, right node, and bottom node.\\n//   x \\n//\\n// x-x\\n// | |   remove nodes in a clockwise fashion\\n// x-x\\n//\\n// x-x  remove one node\\n//\\n// x-x-x-x-x  remove nodes from end to end.\\n```\n```typescript\\ntype Graph = {\\n    rows: Set<number>;\\n    cols: Set<number>;\\n    count: number;\\n}\\nfunction removeStones(stones: Array<[number,number]>): number {\\n    \\n    // Keep track of all unique graphs separately for ease of lookup later.\\n    const allGraphs = new Set<Graph>();\\n    \\n    // Keep an index of all of our graphs by the rows and columns each of them have.\\n    const graphs = {\\n        byRow: new Map<number, Graph>(),\\n        byCol: new Map<number, Graph>(),\\n    };\\n    \\n    // Loop through every stone and compare it against our list of known graphs.\\n    for(const [x,y] of stones) {\\n        // Look up any graphs this stone can connect to.\\n        const rowGraph = graphs.byRow.get(x);\\n        const colGraph = graphs.byCol.get(y);\\n        \\n        \\n        if(rowGraph === colGraph) {\\n            // Both graphs are the same, but are they defined?\\n            if(rowGraph) {\\n                // This stone completes a cycle on an existing graph\\n                // e.g.\\n                // x - x\\n                // |   |\\n                // x -(x) <--- this guy.\\n                // No new rows or columns added.\\n                rowGraph.count++;\\n            } else {\\n                // This stone is connected to no existing graphs,\\n                // So it starts its own graph.\\n                const newGraph = {\\n                    rows: new Set([x]),\\n                    cols: new Set([y]),\\n                    count: 1\\n                };\\n                // Add the graph to our global list, and index it by its row/col\\n                allGraphs.add(newGraph);\\n                graphs.byRow.set(x, newGraph);\\n                graphs.byCol.set(y, newGraph);\\n            }\\n        } else if(rowGraph && !colGraph) {\\n            // This stone connects to 1 existing graph by its row.\\n            // Its column is new to this graph, so track it.\\n            rowGraph.cols.add(y);\\n            // Update the index to point to this graph for the new column\\n            graphs.byCol.set(y, rowGraph);\\n            // The size of our graph increases!\\n            rowGraph.count++;\\n        } else if(colGraph && !rowGraph) {\\n            // This stone connects to 1 existing graph by its column.\\n            // Its row is new to this graph, so track it.\\n            colGraph.rows.add(x)\\n            // Update the index to point to this graph for the new row\\n            graphs.byRow.set(x, colGraph);\\n            // The size of our graph increases!\\n            colGraph.count++;\\n        } else {\\n            // This stone matches two existing graphs!\\n            // We should merge the two graphs and update our row/col indexes\\n            \\n            // Optional optimization: Let\\'s have the graph with more rows/cols consume the one with fewer.\\n            //       This reduces the number of updates we will make to our rol/col index\\n            const [smaller, bigger] = getGraphSpan(rowGraph) > getGraphSpan(colGraph) \\n                ? [colGraph, rowGraph]\\n                : [rowGraph, colGraph];\\n            \\n            // Take every row in our smaller graph,\\n            // Update the row index to point to the bigger graph,\\n            // and add the rows to the bigger graph\\'s list\\n            smaller.rows.forEach((r) => {\\n                graphs.byRow.set(r, bigger)\\n                bigger.rows.add(r);\\n            });\\n            \\n            // Take every column in our smaller graph,\\n            // Update the column index to point to the bigger graph,\\n            // and add the column to the bigger graph\\'s list\\n            smaller.cols.forEach((c) => {\\n                graphs.byCol.set(c, bigger);\\n                bigger.cols.add(c);\\n            });\\n            \\n            // We\\'re adding all of the smaller graph\\'s nodes, plus one brand new one that formed the union of the graphs.\\n            bigger.count += smaller.count + 1;\\n            // Remove the smaller graph from our list of all graphs.\\n            allGraphs.delete(smaller);\\n        }\\n    }\\n    \\n    return Array.from(allGraphs).               // Take all final remaining graphs\\n        filter(g => g.count > 1).               // Ignore any graphs of size 1 (they can\\'t be removed)\\n        map(g => g.count - 1).                  // Get the number of stones that can be removed from this graph\\n        reduce((acc, next) => acc + next, 0);   // Sum them all together.\\n};\\n\\n// Return the number of rows & columns this graph spans.\\nfunction getGraphSpan(g: Graph) {\\n    return g.rows.size + g.cols.size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1493492,
                "title": "easy-union-find-implementation",
                "content": "```\\nint find(vector<int>& parent, int i)\\n{\\n    if (parent[i] == -1)\\n        return i;\\n    return find(parent, parent[i]);\\n}\\n \\n \\nvoid Union( vector<int>&  parent, int x, int y)\\n{\\n    parent[x] = y;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        int n=stones.size();\\n        vector<int> parent(n,-1);\\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<n;i++){\\n               \\n                if((stones[j][0]==stones[i][0])||(stones[j][1]==stones[i][1]) ){\\n                     int x = find(parent, i);\\n                     int y = find(parent, j);\\n                    if(x==y) continue;\\n                  Union(parent, y, x);\\n                   \\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n         for(int i=0;i<n;i++)    if(parent[i]==-1) ans++;\\n          \\n                                \\n        \\n        return n-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint find(vector<int>& parent, int i)\\n{\\n    if (parent[i] == -1)\\n        return i;\\n    return find(parent, parent[i]);\\n}\\n \\n \\nvoid Union( vector<int>&  parent, int x, int y)\\n{\\n    parent[x] = y;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    \\n    int removeStones(vector<vector<int>>& stones) {\\n        \\n        int n=stones.size();\\n        vector<int> parent(n,-1);\\n        for(int j=0;j<n;j++){\\n            for(int i=0;i<n;i++){\\n               \\n                if((stones[j][0]==stones[i][0])||(stones[j][1]==stones[i][1]) ){\\n                     int x = find(parent, i);\\n                     int y = find(parent, j);\\n                    if(x==y) continue;\\n                  Union(parent, y, x);\\n                   \\n                }\\n            }\\n        }\\n        \\n        int ans=0;\\n         for(int i=0;i<n;i++)    if(parent[i]==-1) ans++;\\n          \\n                                \\n        \\n        return n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483710,
                "title": "java-easy-to-understand-iterative-bfs-solution-o-n",
                "content": "The problem revolves around the fact that we need to find the size of connected components.\\nIn the end, each component will have one stone left.\\nKey Observation:\\n* Each stone can belong to only one component, so we visit each stone only once.\\n* We use BFS like approach, and mark all the stones reachable from the particular stone.\\n\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> row;\\n    Map<Integer, List<Integer>> col;\\n    boolean[] visited;\\n    public int removeStones(int[][] stones) {\\n        row = new HashMap<>();\\n        col = new HashMap<>();\\n        int n = stones.length;\\n        \\n        for(int i=0; i<n; i++){\\n            if(!row.containsKey(stones[i][0]))\\n                row.put(stones[i][0], new ArrayList<>());\\n            if(!col.containsKey(stones[i][1]))\\n                col.put(stones[i][1], new ArrayList<>());\\n            \\n            row.get(stones[i][0]).add(i);\\n            col.get(stones[i][1]).add(i);\\n        }\\n        \\n        visited = new boolean[n];\\n        Arrays.fill(visited, false);\\n        \\n        int res=0;\\n        for(int i=0; i<n; i++){\\n\\t\\t\\t/* For each component */\\n            if(!visited[i]){\\n                    visited[i] = true;\\n                    res += solve(i, stones);\\n            }   \\n        }\\n        return res;\\n    }\\n    \\n    public int solve(int index, int[][] stones){\\n        int n = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(index);\\n        while(queue.size()>0){\\n            n++;\\n            int curr = queue.poll();\\n            for(int r: row.get(stones[curr][0])){\\n                if(!visited[r]){\\n                    visited[r] = true;\\n                    queue.add(r);\\n                }\\n            }\\n            for(int c: col.get(stones[curr][1])){\\n                if(!visited[c]){\\n                   visited[c] = true;\\n                    queue.add(c);\\n                }\\n            }\\n        }\\n        return n-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> row;\\n    Map<Integer, List<Integer>> col;\\n    boolean[] visited;\\n    public int removeStones(int[][] stones) {\\n        row = new HashMap<>();\\n        col = new HashMap<>();\\n        int n = stones.length;\\n        \\n        for(int i=0; i<n; i++){\\n            if(!row.containsKey(stones[i][0]))\\n                row.put(stones[i][0], new ArrayList<>());\\n            if(!col.containsKey(stones[i][1]))\\n                col.put(stones[i][1], new ArrayList<>());\\n            \\n            row.get(stones[i][0]).add(i);\\n            col.get(stones[i][1]).add(i);\\n        }\\n        \\n        visited = new boolean[n];\\n        Arrays.fill(visited, false);\\n        \\n        int res=0;\\n        for(int i=0; i<n; i++){\\n\\t\\t\\t/* For each component */\\n            if(!visited[i]){\\n                    visited[i] = true;\\n                    res += solve(i, stones);\\n            }   \\n        }\\n        return res;\\n    }\\n    \\n    public int solve(int index, int[][] stones){\\n        int n = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(index);\\n        while(queue.size()>0){\\n            n++;\\n            int curr = queue.poll();\\n            for(int r: row.get(stones[curr][0])){\\n                if(!visited[r]){\\n                    visited[r] = true;\\n                    queue.add(r);\\n                }\\n            }\\n            for(int c: col.get(stones[curr][1])){\\n                if(!visited[c]){\\n                   visited[c] = true;\\n                    queue.add(c);\\n                }\\n            }\\n        }\\n        return n-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396712,
                "title": "python-dfs-graph-creation-strategy",
                "content": "The graph creation strategy is an important aspect of this problem. For this, I only have edges to a node from the just previous node(s) and just next node(s) in the row/column.\\nAfter that, its similar problem to finding different connected components. Answer is number of nodes in connected components (exluding one node from each component since that can\\'t be deleted)\\n\\n```\\nclass Solution:\\n    def dfs(self, adj_list, vis, node):\\n        ans = 1\\n        vis.add(node)\\n        \\n        for neig in adj_list.get(node, []):\\n            if neig not in vis:\\n                ans += self.dfs(adj_list, vis, neig)\\n\\t\\t\\t\\t\\n        return ans\\n        \\n    \\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        stones.sort()\\n        last_x = collections.defaultdict(lambda: (-1,-1))\\n        last_y = collections.defaultdict(lambda: (-1,-1))\\n        adj_list = collections.defaultdict(lambda: [])\\n        \\n        for x, y in stones:\\n            if last_x[x] != (-1,-1):\\n                adj_list[last_x[x]].append((x,y))\\n                adj_list[(x,y)].append(last_x[x])\\n            if last_y[y] != (-1,-1):\\n                adj_list[last_y[y]].append((x,y))\\n                adj_list[(x,y)].append(last_y[y])\\n            \\n            last_x[x] = (x,y)\\n            last_y[y] = (x,y)\\n\\n        ans = 0\\n        vis = set()\\n        for k, v in adj_list.items():\\n            if k not in vis:\\n                ans += self.dfs(adj_list, vis, k) - 1\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def dfs(self, adj_list, vis, node):\\n        ans = 1\\n        vis.add(node)\\n        \\n        for neig in adj_list.get(node, []):\\n            if neig not in vis:\\n                ans += self.dfs(adj_list, vis, neig)\\n\\t\\t\\t\\t\\n        return ans\\n        \\n    \\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        stones.sort()\\n        last_x = collections.defaultdict(lambda: (-1,-1))\\n        last_y = collections.defaultdict(lambda: (-1,-1))\\n        adj_list = collections.defaultdict(lambda: [])\\n        \\n        for x, y in stones:\\n            if last_x[x] != (-1,-1):\\n                adj_list[last_x[x]].append((x,y))\\n                adj_list[(x,y)].append(last_x[x])\\n            if last_y[y] != (-1,-1):\\n                adj_list[last_y[y]].append((x,y))\\n                adj_list[(x,y)].append(last_y[y])\\n            \\n            last_x[x] = (x,y)\\n            last_y[y] = (x,y)\\n\\n        ans = 0\\n        vis = set()\\n        for k, v in adj_list.items():\\n            if k not in vis:\\n                ans += self.dfs(adj_list, vis, k) - 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564697,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1565691,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1683883,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1565235,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1565859,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1565683,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1565210,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1567409,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1572551,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1569683,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1564697,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1565691,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1683883,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1565235,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1565859,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1565683,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1565210,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1567409,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1572551,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1569683,
                "content": [
                    {
                        "username": "Dacredible",
                        "content": "What is the inputs stands for? Is it stands for the cordinate\\'s of the stone? Also What does remove and moves means here? And what\\'s the goal?"
                    },
                    {
                        "username": "Sudhir_Ghagare",
                        "content": "Here different stones are placed at given co-ordinate and we are suppose to remove the stones whose co-ordinate are same [can be ROWS OR COLUMN], or goal is to return max stones which can be removed from the grid."
                    },
                    {
                        "username": "Unavailable503",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nexpectd 4\\nshouldn\\'t the expected be 3?  standing on stone [1,1] I can remove [3,1], [3,2], [0,2]\\n"
                    },
                    {
                        "username": "slch",
                        "content": "[@hiteshchaurasia98](/hiteshchaurasia98) ohhhh, true"
                    },
                    {
                        "username": "hiteshchaurasia98",
                        "content": "I understand your concern, but I think here we can select any stone and remove that are connected to it.\\n[1,1] -> [3,1], [3,2], [0,2]\\nthen remove [4,4] as it still share same row with [4,0]. And that will make total count to 4."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT 1 :\\nInstead of viewing this question as \"Remove the maximum number of stones with the same rows and columns\", you may take this question to be \"What is the number of stones that can be reached from one another, if reaching stone A to stone B requires either stone A and B having same row or column.\\n\\nHINT 2 :\\nLet us assume that the number of given stones is \"num\"\\nIf we look at all the stone clusters connected to one another, what is the number of stones that you can remove?\\nExample : In the below given grid, if \\'0\\' represents stones \\nX X 0 X X\\n0 X 0 X X\\nX X X X X\\n0 X X X 0\\n\\nWe can map all the stones to one another using basic traversal algorithms.\\nFor EACH SUCH CLUSTER of stones that can be connected in the grid, the number of stones that can be removed is number of stones in that cluster - 1.\\n\\nIf we now add the number of clusters and all the number of stones that can be remove :-\\n(Stones in Cluster 1- 1) + (C2 -1) + (C3 -1) + ......\\n= C1 + C2 + C3 +..... - (number of clusters)\\n= Total number of stones - Number of Clusters\\n\\n \\nWhich will be the solution to this problem.\\n\\n"
                    },
                    {
                        "username": "skdkim",
                        "content": "I decided to write a post about the examples because I got really confused at first and unlike a real interview, you can\\'t ask someone for clarification or have someone else stop you when you make a completely wrong assumption.\\n\\nWe\\'ll look at example 2 and 3 today.\\nWork through Example 1 yourself to see if you get it after my explanation.\\n\\nFirst off they give us coordinates so you can expect some sort of grid.\\nImagine the horizontal lines yourself\\n\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nExample 2:\\n__0 | 1 | 2\\n0   X | _ | X\\n1  __| X |\\n2   X |  __| X\\n\\nThe way a MOVE is describe is confusing as heck.\\nIn simpler terms, a move is an X (stone) trying to get out of the grid but it can\\'t leave unless someone is there to cover for it.\\nThink of it like, you are working the cash register and you need to use the \"bathroom\" but you can\\'t just go. \\nYou need someone to man the station.\\n\\nBy the way, these stone are never coming back.\\nOnce it see\\'s another stone in it\\'s row or column, it give itself permission to leave immediately.\\nThis is why in example 2, the last stone to leave will be left with no one to cover for them.\\nThe stone in the middle never had a chance.\\n\\nExample 3:\\nThe grid is just one unit.\\nThe stone is manning the whole store by alone. \\nIt can\\'t go for the bathroom break.\\n\\nExample 1:\\nInput: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\\nOutput: 5\\n\\nExample 2:\\nInput: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\\nOutput: 3\\n\\nExample 3:\\nInput: stones = [[0,0]]\\nOutput: 0"
                    },
                    {
                        "username": "MingyaoLiu",
                        "content": "The answer provided by test is 4,\\nI just don\\'t get how the result is 4, I can only find 3 to be the max steps.\\n[4, 4] and [4, 0] is not on the same line as any other, which means the max would be [1,1], [3,1], [3,2], [0,2], which is 3 steps.\\n\\nPlease help thanks."
                    },
                    {
                        "username": "awice",
                        "content": "During the weekly contest, the examples for this question were incorrectly written as the number of stones left instead of the number of stones taken.  (number of stones left + number of stones taken = total number of stones).  I regret the error.\\n\\nWithin 5 minutes of the problem being submitted on the Contest Q&A system, the error was corrected: a notice was placed in Q&A, there was contest announcement, as well as the description being fixed.  Additionally, a rejudgment was done to accept any of the two suggested answers (\"x\" or \"total - x\").  This resulted in a change on the rankings as some people who previously got WA got AC on their first (or subsequent) submissions.\\n\\nWe have adjusted our contest procedures to try to limit these mistakes going forward.  Thank you.\\n"
                    },
                    {
                        "username": "chris4FB",
                        "content": "During the contest, the description is different with the one after contest finishes. Look at the screenshoot for details.\\n\\nDuring contest\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118912.png)\\noutputs for examples 1 and 2 are 1 and 2 respectively. \\n\\nAfter contest, look at the descriptions and examples again.\\n![image](https://assets.leetcode.com/users/chris4fb/image_1543118995.png)\\nI found that the outputs given for the same examples 1 and 2 are 5 and 3.\\n\\nIt sucks.\\n"
                    },
                    {
                        "username": "21stCenturyLegend",
                        "content": "I have wasted an hour to understand but still not able to understand what is the problem statement. I am scratching my head. I don\\'t want to see someone else solution before attempting question. Please anyone explain problem statement in layman terms."
                    },
                    {
                        "username": "nirnaykorde",
                        "content": "Use geogebra and plot it on the graph you will get it\\n"
                    },
                    {
                        "username": "padigender",
                        "content": "Why is the answer to [[0,1],[1,0]] 0 ? and not 1. Can someone please explain."
                    },
                    {
                        "username": "Nishat_Mahabub",
                        "content": "Same question here\\n"
                    },
                    {
                        "username": "user8897S",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]] returns 4 as expected, why?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    }
                ]
            },
            {
                "id": 1569391,
                "content": [
                    {
                        "username": "hokkaido2097",
                        "content": "\\n[[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\nHow can this be three? The word `move` seems to imply sequentiality and not simultaneity? \\n\\n`row 1, col: 1 @ [0,2]` -> The two on row 1 is on the same column as `row: 4, col: 1 @ [2, 2]` and can be removed\\n`row 2, col: 0 @ [1,1]` -> The one on column 0 is one the same row as `row: 2, col: 1 @ [1, 1]` and can be removed.\\n`row 3, col: 0 @ [2,0]` -> The two on row 3 is on the same column as `row: 4, col: 0 @ [2, 2]` and can be removed.\\n\\nSo far we have three matches, but this leaves us with the last row 4, where the we have two two\\'s and as such one should be removable?\\n\\n`row 4, col: 0 @ [2,2]` -> The two is shared with `row: 4, col: 1 @ [2, 2]`\\n\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It's very interesting that we can treat [x, y] not as a stone location, but rather as an edge from point x to point y (with some twist)."
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "Solution of this  problem is not as easy as it looks."
                    },
                    {
                        "username": "rahulpqr",
                        "content": "All (67/68) but one test case is passing. And I am not able to debug that because the dataset is huge for that one test case. Can someone help me by having a second eye on this ?\n\n```javascript \nlet rowMap;\nlet colMap;\nlet visited;\nconst removeStones = function(stones) {\n    rowMap = {};\n    colMap = {};\n    visited = new Set();\n    let count = 0;\n\n    if (stones.length <= 1) {\n        return 0;\n    }\n\n    for (const stone of stones) {\n        let row = stone[0];\n        let col = stone[1];\n        rowMap[row] = rowMap[row] ? rowMap[row].add(col) : new Set([col]);\n        colMap[col] = colMap[col] ? colMap[col].add(row) : new Set([row]);\n    }\n    for (const stone of stones) {\n        // console.log(stone, visited);\n        if (visited.has(`${stone[0]}${stone[1]}`)) {\n            continue;\n        }\n        count++;\n        dfs(stone);\n    }\n    return stones.length - count;\n};\n\nfunction dfs(stone) {\n    if (visited.has(`${stone[0]}${stone[1]}`)) {\n        return;\n    }\n    visited.add(`${stone[0]}${stone[1]}`);\n    if (rowMap[stone[0]]) {\n        for (let col of rowMap[stone[0]]) {\n            dfs([stone[0], col]);\n        }\n    }\n    if (colMap[stone[1]]) {\n        for (let row of colMap[stone[1]]) {\n            dfs([row, stone[1]]);\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "ndav",
                        "content": "I have the same problem, it\\'s an off by one.."
                    },
                    {
                        "username": "agggent99",
                        "content": "Suppose we have points [[0,0], [0,1], [1,0], [1,1]]\\nHow can we remove 3 stones ? \\nsince if we keep [0,0] then  we can only remove [0,1] and [1,0]. because [1,1] has neither row nor column common with [0,0].\\nSimilarly for other points as well.\\nSo that means atmax I can remove 2 stones ?"
                    },
                    {
                        "username": "KaziRomel",
                        "content": "[1,1] can be removed since [1,0] has same row number. [1,0] can be removed since [0,0] has same column number and [0,1] can be removed since [0,0] has same row number."
                    },
                    {
                        "username": "voldemort_13",
                        "content": "Stone at [1,1] can be removed because it has same row with stone at [1,0] which can be thrown and also same column with stone at [0,1] which again can be removed as you had found it .\\nSo we are going from [0,0] to [0,1] then from [0,1] to [1,1] then from [1,1] to [1,0]. So three stones can be thrown."
                    },
                    {
                        "username": "AEni",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nsays expected is 4.\\nBut if we calculate the conencted component size, the maximum component has size 4 so the result should be 3. Am i missing something?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "anhmiuhv",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\n\\nWhy the result is 4 instead of 3?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "rarara",
                        "content": "Please someone help me understand why we need to use `~y` when building union find structure for these edges?\\n\\nSee this [answer](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)) for reference for what I am talking about."
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good Question, You can easily do it if your concepts of trees, graphs and connected components are clear."
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "How is this problem tagged as Medium "
                    }
                ]
            },
            {
                "id": 1684392,
                "content": [
                    {
                        "username": "hokkaido2097",
                        "content": "\\n[[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\nHow can this be three? The word `move` seems to imply sequentiality and not simultaneity? \\n\\n`row 1, col: 1 @ [0,2]` -> The two on row 1 is on the same column as `row: 4, col: 1 @ [2, 2]` and can be removed\\n`row 2, col: 0 @ [1,1]` -> The one on column 0 is one the same row as `row: 2, col: 1 @ [1, 1]` and can be removed.\\n`row 3, col: 0 @ [2,0]` -> The two on row 3 is on the same column as `row: 4, col: 0 @ [2, 2]` and can be removed.\\n\\nSo far we have three matches, but this leaves us with the last row 4, where the we have two two\\'s and as such one should be removable?\\n\\n`row 4, col: 0 @ [2,2]` -> The two is shared with `row: 4, col: 1 @ [2, 2]`\\n\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It's very interesting that we can treat [x, y] not as a stone location, but rather as an edge from point x to point y (with some twist)."
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "Solution of this  problem is not as easy as it looks."
                    },
                    {
                        "username": "rahulpqr",
                        "content": "All (67/68) but one test case is passing. And I am not able to debug that because the dataset is huge for that one test case. Can someone help me by having a second eye on this ?\n\n```javascript \nlet rowMap;\nlet colMap;\nlet visited;\nconst removeStones = function(stones) {\n    rowMap = {};\n    colMap = {};\n    visited = new Set();\n    let count = 0;\n\n    if (stones.length <= 1) {\n        return 0;\n    }\n\n    for (const stone of stones) {\n        let row = stone[0];\n        let col = stone[1];\n        rowMap[row] = rowMap[row] ? rowMap[row].add(col) : new Set([col]);\n        colMap[col] = colMap[col] ? colMap[col].add(row) : new Set([row]);\n    }\n    for (const stone of stones) {\n        // console.log(stone, visited);\n        if (visited.has(`${stone[0]}${stone[1]}`)) {\n            continue;\n        }\n        count++;\n        dfs(stone);\n    }\n    return stones.length - count;\n};\n\nfunction dfs(stone) {\n    if (visited.has(`${stone[0]}${stone[1]}`)) {\n        return;\n    }\n    visited.add(`${stone[0]}${stone[1]}`);\n    if (rowMap[stone[0]]) {\n        for (let col of rowMap[stone[0]]) {\n            dfs([stone[0], col]);\n        }\n    }\n    if (colMap[stone[1]]) {\n        for (let row of colMap[stone[1]]) {\n            dfs([row, stone[1]]);\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "ndav",
                        "content": "I have the same problem, it\\'s an off by one.."
                    },
                    {
                        "username": "agggent99",
                        "content": "Suppose we have points [[0,0], [0,1], [1,0], [1,1]]\\nHow can we remove 3 stones ? \\nsince if we keep [0,0] then  we can only remove [0,1] and [1,0]. because [1,1] has neither row nor column common with [0,0].\\nSimilarly for other points as well.\\nSo that means atmax I can remove 2 stones ?"
                    },
                    {
                        "username": "KaziRomel",
                        "content": "[1,1] can be removed since [1,0] has same row number. [1,0] can be removed since [0,0] has same column number and [0,1] can be removed since [0,0] has same row number."
                    },
                    {
                        "username": "voldemort_13",
                        "content": "Stone at [1,1] can be removed because it has same row with stone at [1,0] which can be thrown and also same column with stone at [0,1] which again can be removed as you had found it .\\nSo we are going from [0,0] to [0,1] then from [0,1] to [1,1] then from [1,1] to [1,0]. So three stones can be thrown."
                    },
                    {
                        "username": "AEni",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nsays expected is 4.\\nBut if we calculate the conencted component size, the maximum component has size 4 so the result should be 3. Am i missing something?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "anhmiuhv",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\n\\nWhy the result is 4 instead of 3?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "rarara",
                        "content": "Please someone help me understand why we need to use `~y` when building union find structure for these edges?\\n\\nSee this [answer](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)) for reference for what I am talking about."
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good Question, You can easily do it if your concepts of trees, graphs and connected components are clear."
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "How is this problem tagged as Medium "
                    }
                ]
            },
            {
                "id": 1684038,
                "content": [
                    {
                        "username": "hokkaido2097",
                        "content": "\\n[[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\nHow can this be three? The word `move` seems to imply sequentiality and not simultaneity? \\n\\n`row 1, col: 1 @ [0,2]` -> The two on row 1 is on the same column as `row: 4, col: 1 @ [2, 2]` and can be removed\\n`row 2, col: 0 @ [1,1]` -> The one on column 0 is one the same row as `row: 2, col: 1 @ [1, 1]` and can be removed.\\n`row 3, col: 0 @ [2,0]` -> The two on row 3 is on the same column as `row: 4, col: 0 @ [2, 2]` and can be removed.\\n\\nSo far we have three matches, but this leaves us with the last row 4, where the we have two two\\'s and as such one should be removable?\\n\\n`row 4, col: 0 @ [2,2]` -> The two is shared with `row: 4, col: 1 @ [2, 2]`\\n\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It's very interesting that we can treat [x, y] not as a stone location, but rather as an edge from point x to point y (with some twist)."
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "Solution of this  problem is not as easy as it looks."
                    },
                    {
                        "username": "rahulpqr",
                        "content": "All (67/68) but one test case is passing. And I am not able to debug that because the dataset is huge for that one test case. Can someone help me by having a second eye on this ?\n\n```javascript \nlet rowMap;\nlet colMap;\nlet visited;\nconst removeStones = function(stones) {\n    rowMap = {};\n    colMap = {};\n    visited = new Set();\n    let count = 0;\n\n    if (stones.length <= 1) {\n        return 0;\n    }\n\n    for (const stone of stones) {\n        let row = stone[0];\n        let col = stone[1];\n        rowMap[row] = rowMap[row] ? rowMap[row].add(col) : new Set([col]);\n        colMap[col] = colMap[col] ? colMap[col].add(row) : new Set([row]);\n    }\n    for (const stone of stones) {\n        // console.log(stone, visited);\n        if (visited.has(`${stone[0]}${stone[1]}`)) {\n            continue;\n        }\n        count++;\n        dfs(stone);\n    }\n    return stones.length - count;\n};\n\nfunction dfs(stone) {\n    if (visited.has(`${stone[0]}${stone[1]}`)) {\n        return;\n    }\n    visited.add(`${stone[0]}${stone[1]}`);\n    if (rowMap[stone[0]]) {\n        for (let col of rowMap[stone[0]]) {\n            dfs([stone[0], col]);\n        }\n    }\n    if (colMap[stone[1]]) {\n        for (let row of colMap[stone[1]]) {\n            dfs([row, stone[1]]);\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "ndav",
                        "content": "I have the same problem, it\\'s an off by one.."
                    },
                    {
                        "username": "agggent99",
                        "content": "Suppose we have points [[0,0], [0,1], [1,0], [1,1]]\\nHow can we remove 3 stones ? \\nsince if we keep [0,0] then  we can only remove [0,1] and [1,0]. because [1,1] has neither row nor column common with [0,0].\\nSimilarly for other points as well.\\nSo that means atmax I can remove 2 stones ?"
                    },
                    {
                        "username": "KaziRomel",
                        "content": "[1,1] can be removed since [1,0] has same row number. [1,0] can be removed since [0,0] has same column number and [0,1] can be removed since [0,0] has same row number."
                    },
                    {
                        "username": "voldemort_13",
                        "content": "Stone at [1,1] can be removed because it has same row with stone at [1,0] which can be thrown and also same column with stone at [0,1] which again can be removed as you had found it .\\nSo we are going from [0,0] to [0,1] then from [0,1] to [1,1] then from [1,1] to [1,0]. So three stones can be thrown."
                    },
                    {
                        "username": "AEni",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nsays expected is 4.\\nBut if we calculate the conencted component size, the maximum component has size 4 so the result should be 3. Am i missing something?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "anhmiuhv",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\n\\nWhy the result is 4 instead of 3?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "rarara",
                        "content": "Please someone help me understand why we need to use `~y` when building union find structure for these edges?\\n\\nSee this [answer](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)) for reference for what I am talking about."
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good Question, You can easily do it if your concepts of trees, graphs and connected components are clear."
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "How is this problem tagged as Medium "
                    }
                ]
            },
            {
                "id": 1669616,
                "content": [
                    {
                        "username": "hokkaido2097",
                        "content": "\\n[[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\nHow can this be three? The word `move` seems to imply sequentiality and not simultaneity? \\n\\n`row 1, col: 1 @ [0,2]` -> The two on row 1 is on the same column as `row: 4, col: 1 @ [2, 2]` and can be removed\\n`row 2, col: 0 @ [1,1]` -> The one on column 0 is one the same row as `row: 2, col: 1 @ [1, 1]` and can be removed.\\n`row 3, col: 0 @ [2,0]` -> The two on row 3 is on the same column as `row: 4, col: 0 @ [2, 2]` and can be removed.\\n\\nSo far we have three matches, but this leaves us with the last row 4, where the we have two two\\'s and as such one should be removable?\\n\\n`row 4, col: 0 @ [2,2]` -> The two is shared with `row: 4, col: 1 @ [2, 2]`\\n\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It's very interesting that we can treat [x, y] not as a stone location, but rather as an edge from point x to point y (with some twist)."
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "Solution of this  problem is not as easy as it looks."
                    },
                    {
                        "username": "rahulpqr",
                        "content": "All (67/68) but one test case is passing. And I am not able to debug that because the dataset is huge for that one test case. Can someone help me by having a second eye on this ?\n\n```javascript \nlet rowMap;\nlet colMap;\nlet visited;\nconst removeStones = function(stones) {\n    rowMap = {};\n    colMap = {};\n    visited = new Set();\n    let count = 0;\n\n    if (stones.length <= 1) {\n        return 0;\n    }\n\n    for (const stone of stones) {\n        let row = stone[0];\n        let col = stone[1];\n        rowMap[row] = rowMap[row] ? rowMap[row].add(col) : new Set([col]);\n        colMap[col] = colMap[col] ? colMap[col].add(row) : new Set([row]);\n    }\n    for (const stone of stones) {\n        // console.log(stone, visited);\n        if (visited.has(`${stone[0]}${stone[1]}`)) {\n            continue;\n        }\n        count++;\n        dfs(stone);\n    }\n    return stones.length - count;\n};\n\nfunction dfs(stone) {\n    if (visited.has(`${stone[0]}${stone[1]}`)) {\n        return;\n    }\n    visited.add(`${stone[0]}${stone[1]}`);\n    if (rowMap[stone[0]]) {\n        for (let col of rowMap[stone[0]]) {\n            dfs([stone[0], col]);\n        }\n    }\n    if (colMap[stone[1]]) {\n        for (let row of colMap[stone[1]]) {\n            dfs([row, stone[1]]);\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "ndav",
                        "content": "I have the same problem, it\\'s an off by one.."
                    },
                    {
                        "username": "agggent99",
                        "content": "Suppose we have points [[0,0], [0,1], [1,0], [1,1]]\\nHow can we remove 3 stones ? \\nsince if we keep [0,0] then  we can only remove [0,1] and [1,0]. because [1,1] has neither row nor column common with [0,0].\\nSimilarly for other points as well.\\nSo that means atmax I can remove 2 stones ?"
                    },
                    {
                        "username": "KaziRomel",
                        "content": "[1,1] can be removed since [1,0] has same row number. [1,0] can be removed since [0,0] has same column number and [0,1] can be removed since [0,0] has same row number."
                    },
                    {
                        "username": "voldemort_13",
                        "content": "Stone at [1,1] can be removed because it has same row with stone at [1,0] which can be thrown and also same column with stone at [0,1] which again can be removed as you had found it .\\nSo we are going from [0,0] to [0,1] then from [0,1] to [1,1] then from [1,1] to [1,0]. So three stones can be thrown."
                    },
                    {
                        "username": "AEni",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nsays expected is 4.\\nBut if we calculate the conencted component size, the maximum component has size 4 so the result should be 3. Am i missing something?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "anhmiuhv",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\n\\nWhy the result is 4 instead of 3?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "rarara",
                        "content": "Please someone help me understand why we need to use `~y` when building union find structure for these edges?\\n\\nSee this [answer](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)) for reference for what I am talking about."
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good Question, You can easily do it if your concepts of trees, graphs and connected components are clear."
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "How is this problem tagged as Medium "
                    }
                ]
            },
            {
                "id": 1575328,
                "content": [
                    {
                        "username": "hokkaido2097",
                        "content": "\\n[[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\nHow can this be three? The word `move` seems to imply sequentiality and not simultaneity? \\n\\n`row 1, col: 1 @ [0,2]` -> The two on row 1 is on the same column as `row: 4, col: 1 @ [2, 2]` and can be removed\\n`row 2, col: 0 @ [1,1]` -> The one on column 0 is one the same row as `row: 2, col: 1 @ [1, 1]` and can be removed.\\n`row 3, col: 0 @ [2,0]` -> The two on row 3 is on the same column as `row: 4, col: 0 @ [2, 2]` and can be removed.\\n\\nSo far we have three matches, but this leaves us with the last row 4, where the we have two two\\'s and as such one should be removable?\\n\\n`row 4, col: 0 @ [2,2]` -> The two is shared with `row: 4, col: 1 @ [2, 2]`\\n\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It's very interesting that we can treat [x, y] not as a stone location, but rather as an edge from point x to point y (with some twist)."
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "Solution of this  problem is not as easy as it looks."
                    },
                    {
                        "username": "rahulpqr",
                        "content": "All (67/68) but one test case is passing. And I am not able to debug that because the dataset is huge for that one test case. Can someone help me by having a second eye on this ?\n\n```javascript \nlet rowMap;\nlet colMap;\nlet visited;\nconst removeStones = function(stones) {\n    rowMap = {};\n    colMap = {};\n    visited = new Set();\n    let count = 0;\n\n    if (stones.length <= 1) {\n        return 0;\n    }\n\n    for (const stone of stones) {\n        let row = stone[0];\n        let col = stone[1];\n        rowMap[row] = rowMap[row] ? rowMap[row].add(col) : new Set([col]);\n        colMap[col] = colMap[col] ? colMap[col].add(row) : new Set([row]);\n    }\n    for (const stone of stones) {\n        // console.log(stone, visited);\n        if (visited.has(`${stone[0]}${stone[1]}`)) {\n            continue;\n        }\n        count++;\n        dfs(stone);\n    }\n    return stones.length - count;\n};\n\nfunction dfs(stone) {\n    if (visited.has(`${stone[0]}${stone[1]}`)) {\n        return;\n    }\n    visited.add(`${stone[0]}${stone[1]}`);\n    if (rowMap[stone[0]]) {\n        for (let col of rowMap[stone[0]]) {\n            dfs([stone[0], col]);\n        }\n    }\n    if (colMap[stone[1]]) {\n        for (let row of colMap[stone[1]]) {\n            dfs([row, stone[1]]);\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "ndav",
                        "content": "I have the same problem, it\\'s an off by one.."
                    },
                    {
                        "username": "agggent99",
                        "content": "Suppose we have points [[0,0], [0,1], [1,0], [1,1]]\\nHow can we remove 3 stones ? \\nsince if we keep [0,0] then  we can only remove [0,1] and [1,0]. because [1,1] has neither row nor column common with [0,0].\\nSimilarly for other points as well.\\nSo that means atmax I can remove 2 stones ?"
                    },
                    {
                        "username": "KaziRomel",
                        "content": "[1,1] can be removed since [1,0] has same row number. [1,0] can be removed since [0,0] has same column number and [0,1] can be removed since [0,0] has same row number."
                    },
                    {
                        "username": "voldemort_13",
                        "content": "Stone at [1,1] can be removed because it has same row with stone at [1,0] which can be thrown and also same column with stone at [0,1] which again can be removed as you had found it .\\nSo we are going from [0,0] to [0,1] then from [0,1] to [1,1] then from [1,1] to [1,0]. So three stones can be thrown."
                    },
                    {
                        "username": "AEni",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nsays expected is 4.\\nBut if we calculate the conencted component size, the maximum component has size 4 so the result should be 3. Am i missing something?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "anhmiuhv",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\n\\nWhy the result is 4 instead of 3?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "rarara",
                        "content": "Please someone help me understand why we need to use `~y` when building union find structure for these edges?\\n\\nSee this [answer](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)) for reference for what I am talking about."
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good Question, You can easily do it if your concepts of trees, graphs and connected components are clear."
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "How is this problem tagged as Medium "
                    }
                ]
            },
            {
                "id": 1573280,
                "content": [
                    {
                        "username": "hokkaido2097",
                        "content": "\\n[[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\nHow can this be three? The word `move` seems to imply sequentiality and not simultaneity? \\n\\n`row 1, col: 1 @ [0,2]` -> The two on row 1 is on the same column as `row: 4, col: 1 @ [2, 2]` and can be removed\\n`row 2, col: 0 @ [1,1]` -> The one on column 0 is one the same row as `row: 2, col: 1 @ [1, 1]` and can be removed.\\n`row 3, col: 0 @ [2,0]` -> The two on row 3 is on the same column as `row: 4, col: 0 @ [2, 2]` and can be removed.\\n\\nSo far we have three matches, but this leaves us with the last row 4, where the we have two two\\'s and as such one should be removable?\\n\\n`row 4, col: 0 @ [2,2]` -> The two is shared with `row: 4, col: 1 @ [2, 2]`\\n\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It's very interesting that we can treat [x, y] not as a stone location, but rather as an edge from point x to point y (with some twist)."
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "Solution of this  problem is not as easy as it looks."
                    },
                    {
                        "username": "rahulpqr",
                        "content": "All (67/68) but one test case is passing. And I am not able to debug that because the dataset is huge for that one test case. Can someone help me by having a second eye on this ?\n\n```javascript \nlet rowMap;\nlet colMap;\nlet visited;\nconst removeStones = function(stones) {\n    rowMap = {};\n    colMap = {};\n    visited = new Set();\n    let count = 0;\n\n    if (stones.length <= 1) {\n        return 0;\n    }\n\n    for (const stone of stones) {\n        let row = stone[0];\n        let col = stone[1];\n        rowMap[row] = rowMap[row] ? rowMap[row].add(col) : new Set([col]);\n        colMap[col] = colMap[col] ? colMap[col].add(row) : new Set([row]);\n    }\n    for (const stone of stones) {\n        // console.log(stone, visited);\n        if (visited.has(`${stone[0]}${stone[1]}`)) {\n            continue;\n        }\n        count++;\n        dfs(stone);\n    }\n    return stones.length - count;\n};\n\nfunction dfs(stone) {\n    if (visited.has(`${stone[0]}${stone[1]}`)) {\n        return;\n    }\n    visited.add(`${stone[0]}${stone[1]}`);\n    if (rowMap[stone[0]]) {\n        for (let col of rowMap[stone[0]]) {\n            dfs([stone[0], col]);\n        }\n    }\n    if (colMap[stone[1]]) {\n        for (let row of colMap[stone[1]]) {\n            dfs([row, stone[1]]);\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "ndav",
                        "content": "I have the same problem, it\\'s an off by one.."
                    },
                    {
                        "username": "agggent99",
                        "content": "Suppose we have points [[0,0], [0,1], [1,0], [1,1]]\\nHow can we remove 3 stones ? \\nsince if we keep [0,0] then  we can only remove [0,1] and [1,0]. because [1,1] has neither row nor column common with [0,0].\\nSimilarly for other points as well.\\nSo that means atmax I can remove 2 stones ?"
                    },
                    {
                        "username": "KaziRomel",
                        "content": "[1,1] can be removed since [1,0] has same row number. [1,0] can be removed since [0,0] has same column number and [0,1] can be removed since [0,0] has same row number."
                    },
                    {
                        "username": "voldemort_13",
                        "content": "Stone at [1,1] can be removed because it has same row with stone at [1,0] which can be thrown and also same column with stone at [0,1] which again can be removed as you had found it .\\nSo we are going from [0,0] to [0,1] then from [0,1] to [1,1] then from [1,1] to [1,0]. So three stones can be thrown."
                    },
                    {
                        "username": "AEni",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nsays expected is 4.\\nBut if we calculate the conencted component size, the maximum component has size 4 so the result should be 3. Am i missing something?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "anhmiuhv",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\n\\nWhy the result is 4 instead of 3?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "rarara",
                        "content": "Please someone help me understand why we need to use `~y` when building union find structure for these edges?\\n\\nSee this [answer](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)) for reference for what I am talking about."
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good Question, You can easily do it if your concepts of trees, graphs and connected components are clear."
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "How is this problem tagged as Medium "
                    }
                ]
            },
            {
                "id": 1572925,
                "content": [
                    {
                        "username": "hokkaido2097",
                        "content": "\\n[[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\nHow can this be three? The word `move` seems to imply sequentiality and not simultaneity? \\n\\n`row 1, col: 1 @ [0,2]` -> The two on row 1 is on the same column as `row: 4, col: 1 @ [2, 2]` and can be removed\\n`row 2, col: 0 @ [1,1]` -> The one on column 0 is one the same row as `row: 2, col: 1 @ [1, 1]` and can be removed.\\n`row 3, col: 0 @ [2,0]` -> The two on row 3 is on the same column as `row: 4, col: 0 @ [2, 2]` and can be removed.\\n\\nSo far we have three matches, but this leaves us with the last row 4, where the we have two two\\'s and as such one should be removable?\\n\\n`row 4, col: 0 @ [2,2]` -> The two is shared with `row: 4, col: 1 @ [2, 2]`\\n\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It's very interesting that we can treat [x, y] not as a stone location, but rather as an edge from point x to point y (with some twist)."
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "Solution of this  problem is not as easy as it looks."
                    },
                    {
                        "username": "rahulpqr",
                        "content": "All (67/68) but one test case is passing. And I am not able to debug that because the dataset is huge for that one test case. Can someone help me by having a second eye on this ?\n\n```javascript \nlet rowMap;\nlet colMap;\nlet visited;\nconst removeStones = function(stones) {\n    rowMap = {};\n    colMap = {};\n    visited = new Set();\n    let count = 0;\n\n    if (stones.length <= 1) {\n        return 0;\n    }\n\n    for (const stone of stones) {\n        let row = stone[0];\n        let col = stone[1];\n        rowMap[row] = rowMap[row] ? rowMap[row].add(col) : new Set([col]);\n        colMap[col] = colMap[col] ? colMap[col].add(row) : new Set([row]);\n    }\n    for (const stone of stones) {\n        // console.log(stone, visited);\n        if (visited.has(`${stone[0]}${stone[1]}`)) {\n            continue;\n        }\n        count++;\n        dfs(stone);\n    }\n    return stones.length - count;\n};\n\nfunction dfs(stone) {\n    if (visited.has(`${stone[0]}${stone[1]}`)) {\n        return;\n    }\n    visited.add(`${stone[0]}${stone[1]}`);\n    if (rowMap[stone[0]]) {\n        for (let col of rowMap[stone[0]]) {\n            dfs([stone[0], col]);\n        }\n    }\n    if (colMap[stone[1]]) {\n        for (let row of colMap[stone[1]]) {\n            dfs([row, stone[1]]);\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "ndav",
                        "content": "I have the same problem, it\\'s an off by one.."
                    },
                    {
                        "username": "agggent99",
                        "content": "Suppose we have points [[0,0], [0,1], [1,0], [1,1]]\\nHow can we remove 3 stones ? \\nsince if we keep [0,0] then  we can only remove [0,1] and [1,0]. because [1,1] has neither row nor column common with [0,0].\\nSimilarly for other points as well.\\nSo that means atmax I can remove 2 stones ?"
                    },
                    {
                        "username": "KaziRomel",
                        "content": "[1,1] can be removed since [1,0] has same row number. [1,0] can be removed since [0,0] has same column number and [0,1] can be removed since [0,0] has same row number."
                    },
                    {
                        "username": "voldemort_13",
                        "content": "Stone at [1,1] can be removed because it has same row with stone at [1,0] which can be thrown and also same column with stone at [0,1] which again can be removed as you had found it .\\nSo we are going from [0,0] to [0,1] then from [0,1] to [1,1] then from [1,1] to [1,0]. So three stones can be thrown."
                    },
                    {
                        "username": "AEni",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nsays expected is 4.\\nBut if we calculate the conencted component size, the maximum component has size 4 so the result should be 3. Am i missing something?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "anhmiuhv",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\n\\nWhy the result is 4 instead of 3?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "rarara",
                        "content": "Please someone help me understand why we need to use `~y` when building union find structure for these edges?\\n\\nSee this [answer](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)) for reference for what I am talking about."
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good Question, You can easily do it if your concepts of trees, graphs and connected components are clear."
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "How is this problem tagged as Medium "
                    }
                ]
            },
            {
                "id": 1572463,
                "content": [
                    {
                        "username": "hokkaido2097",
                        "content": "\\n[[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\nHow can this be three? The word `move` seems to imply sequentiality and not simultaneity? \\n\\n`row 1, col: 1 @ [0,2]` -> The two on row 1 is on the same column as `row: 4, col: 1 @ [2, 2]` and can be removed\\n`row 2, col: 0 @ [1,1]` -> The one on column 0 is one the same row as `row: 2, col: 1 @ [1, 1]` and can be removed.\\n`row 3, col: 0 @ [2,0]` -> The two on row 3 is on the same column as `row: 4, col: 0 @ [2, 2]` and can be removed.\\n\\nSo far we have three matches, but this leaves us with the last row 4, where the we have two two\\'s and as such one should be removable?\\n\\n`row 4, col: 0 @ [2,2]` -> The two is shared with `row: 4, col: 1 @ [2, 2]`\\n\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It's very interesting that we can treat [x, y] not as a stone location, but rather as an edge from point x to point y (with some twist)."
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "Solution of this  problem is not as easy as it looks."
                    },
                    {
                        "username": "rahulpqr",
                        "content": "All (67/68) but one test case is passing. And I am not able to debug that because the dataset is huge for that one test case. Can someone help me by having a second eye on this ?\n\n```javascript \nlet rowMap;\nlet colMap;\nlet visited;\nconst removeStones = function(stones) {\n    rowMap = {};\n    colMap = {};\n    visited = new Set();\n    let count = 0;\n\n    if (stones.length <= 1) {\n        return 0;\n    }\n\n    for (const stone of stones) {\n        let row = stone[0];\n        let col = stone[1];\n        rowMap[row] = rowMap[row] ? rowMap[row].add(col) : new Set([col]);\n        colMap[col] = colMap[col] ? colMap[col].add(row) : new Set([row]);\n    }\n    for (const stone of stones) {\n        // console.log(stone, visited);\n        if (visited.has(`${stone[0]}${stone[1]}`)) {\n            continue;\n        }\n        count++;\n        dfs(stone);\n    }\n    return stones.length - count;\n};\n\nfunction dfs(stone) {\n    if (visited.has(`${stone[0]}${stone[1]}`)) {\n        return;\n    }\n    visited.add(`${stone[0]}${stone[1]}`);\n    if (rowMap[stone[0]]) {\n        for (let col of rowMap[stone[0]]) {\n            dfs([stone[0], col]);\n        }\n    }\n    if (colMap[stone[1]]) {\n        for (let row of colMap[stone[1]]) {\n            dfs([row, stone[1]]);\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "ndav",
                        "content": "I have the same problem, it\\'s an off by one.."
                    },
                    {
                        "username": "agggent99",
                        "content": "Suppose we have points [[0,0], [0,1], [1,0], [1,1]]\\nHow can we remove 3 stones ? \\nsince if we keep [0,0] then  we can only remove [0,1] and [1,0]. because [1,1] has neither row nor column common with [0,0].\\nSimilarly for other points as well.\\nSo that means atmax I can remove 2 stones ?"
                    },
                    {
                        "username": "KaziRomel",
                        "content": "[1,1] can be removed since [1,0] has same row number. [1,0] can be removed since [0,0] has same column number and [0,1] can be removed since [0,0] has same row number."
                    },
                    {
                        "username": "voldemort_13",
                        "content": "Stone at [1,1] can be removed because it has same row with stone at [1,0] which can be thrown and also same column with stone at [0,1] which again can be removed as you had found it .\\nSo we are going from [0,0] to [0,1] then from [0,1] to [1,1] then from [1,1] to [1,0]. So three stones can be thrown."
                    },
                    {
                        "username": "AEni",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nsays expected is 4.\\nBut if we calculate the conencted component size, the maximum component has size 4 so the result should be 3. Am i missing something?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "anhmiuhv",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\n\\nWhy the result is 4 instead of 3?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "rarara",
                        "content": "Please someone help me understand why we need to use `~y` when building union find structure for these edges?\\n\\nSee this [answer](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)) for reference for what I am talking about."
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good Question, You can easily do it if your concepts of trees, graphs and connected components are clear."
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "How is this problem tagged as Medium "
                    }
                ]
            },
            {
                "id": 2059160,
                "content": [
                    {
                        "username": "hokkaido2097",
                        "content": "\\n[[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\nHow can this be three? The word `move` seems to imply sequentiality and not simultaneity? \\n\\n`row 1, col: 1 @ [0,2]` -> The two on row 1 is on the same column as `row: 4, col: 1 @ [2, 2]` and can be removed\\n`row 2, col: 0 @ [1,1]` -> The one on column 0 is one the same row as `row: 2, col: 1 @ [1, 1]` and can be removed.\\n`row 3, col: 0 @ [2,0]` -> The two on row 3 is on the same column as `row: 4, col: 0 @ [2, 2]` and can be removed.\\n\\nSo far we have three matches, but this leaves us with the last row 4, where the we have two two\\'s and as such one should be removable?\\n\\n`row 4, col: 0 @ [2,2]` -> The two is shared with `row: 4, col: 1 @ [2, 2]`\\n\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It's very interesting that we can treat [x, y] not as a stone location, but rather as an edge from point x to point y (with some twist)."
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "Solution of this  problem is not as easy as it looks."
                    },
                    {
                        "username": "rahulpqr",
                        "content": "All (67/68) but one test case is passing. And I am not able to debug that because the dataset is huge for that one test case. Can someone help me by having a second eye on this ?\n\n```javascript \nlet rowMap;\nlet colMap;\nlet visited;\nconst removeStones = function(stones) {\n    rowMap = {};\n    colMap = {};\n    visited = new Set();\n    let count = 0;\n\n    if (stones.length <= 1) {\n        return 0;\n    }\n\n    for (const stone of stones) {\n        let row = stone[0];\n        let col = stone[1];\n        rowMap[row] = rowMap[row] ? rowMap[row].add(col) : new Set([col]);\n        colMap[col] = colMap[col] ? colMap[col].add(row) : new Set([row]);\n    }\n    for (const stone of stones) {\n        // console.log(stone, visited);\n        if (visited.has(`${stone[0]}${stone[1]}`)) {\n            continue;\n        }\n        count++;\n        dfs(stone);\n    }\n    return stones.length - count;\n};\n\nfunction dfs(stone) {\n    if (visited.has(`${stone[0]}${stone[1]}`)) {\n        return;\n    }\n    visited.add(`${stone[0]}${stone[1]}`);\n    if (rowMap[stone[0]]) {\n        for (let col of rowMap[stone[0]]) {\n            dfs([stone[0], col]);\n        }\n    }\n    if (colMap[stone[1]]) {\n        for (let row of colMap[stone[1]]) {\n            dfs([row, stone[1]]);\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "ndav",
                        "content": "I have the same problem, it\\'s an off by one.."
                    },
                    {
                        "username": "agggent99",
                        "content": "Suppose we have points [[0,0], [0,1], [1,0], [1,1]]\\nHow can we remove 3 stones ? \\nsince if we keep [0,0] then  we can only remove [0,1] and [1,0]. because [1,1] has neither row nor column common with [0,0].\\nSimilarly for other points as well.\\nSo that means atmax I can remove 2 stones ?"
                    },
                    {
                        "username": "KaziRomel",
                        "content": "[1,1] can be removed since [1,0] has same row number. [1,0] can be removed since [0,0] has same column number and [0,1] can be removed since [0,0] has same row number."
                    },
                    {
                        "username": "voldemort_13",
                        "content": "Stone at [1,1] can be removed because it has same row with stone at [1,0] which can be thrown and also same column with stone at [0,1] which again can be removed as you had found it .\\nSo we are going from [0,0] to [0,1] then from [0,1] to [1,1] then from [1,1] to [1,0]. So three stones can be thrown."
                    },
                    {
                        "username": "AEni",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nsays expected is 4.\\nBut if we calculate the conencted component size, the maximum component has size 4 so the result should be 3. Am i missing something?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "anhmiuhv",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\n\\nWhy the result is 4 instead of 3?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "rarara",
                        "content": "Please someone help me understand why we need to use `~y` when building union find structure for these edges?\\n\\nSee this [answer](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)) for reference for what I am talking about."
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good Question, You can easily do it if your concepts of trees, graphs and connected components are clear."
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "How is this problem tagged as Medium "
                    }
                ]
            },
            {
                "id": 1926855,
                "content": [
                    {
                        "username": "hokkaido2097",
                        "content": "\\n[[0,0],[0,2],[1,1],[2,0],[2,2]]\\n\\nHow can this be three? The word `move` seems to imply sequentiality and not simultaneity? \\n\\n`row 1, col: 1 @ [0,2]` -> The two on row 1 is on the same column as `row: 4, col: 1 @ [2, 2]` and can be removed\\n`row 2, col: 0 @ [1,1]` -> The one on column 0 is one the same row as `row: 2, col: 1 @ [1, 1]` and can be removed.\\n`row 3, col: 0 @ [2,0]` -> The two on row 3 is on the same column as `row: 4, col: 0 @ [2, 2]` and can be removed.\\n\\nSo far we have three matches, but this leaves us with the last row 4, where the we have two two\\'s and as such one should be removable?\\n\\n`row 4, col: 0 @ [2,2]` -> The two is shared with `row: 4, col: 1 @ [2, 2]`\\n\\n"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It's very interesting that we can treat [x, y] not as a stone location, but rather as an edge from point x to point y (with some twist)."
                    },
                    {
                        "username": "ganapati_biswas",
                        "content": "Solution of this  problem is not as easy as it looks."
                    },
                    {
                        "username": "rahulpqr",
                        "content": "All (67/68) but one test case is passing. And I am not able to debug that because the dataset is huge for that one test case. Can someone help me by having a second eye on this ?\n\n```javascript \nlet rowMap;\nlet colMap;\nlet visited;\nconst removeStones = function(stones) {\n    rowMap = {};\n    colMap = {};\n    visited = new Set();\n    let count = 0;\n\n    if (stones.length <= 1) {\n        return 0;\n    }\n\n    for (const stone of stones) {\n        let row = stone[0];\n        let col = stone[1];\n        rowMap[row] = rowMap[row] ? rowMap[row].add(col) : new Set([col]);\n        colMap[col] = colMap[col] ? colMap[col].add(row) : new Set([row]);\n    }\n    for (const stone of stones) {\n        // console.log(stone, visited);\n        if (visited.has(`${stone[0]}${stone[1]}`)) {\n            continue;\n        }\n        count++;\n        dfs(stone);\n    }\n    return stones.length - count;\n};\n\nfunction dfs(stone) {\n    if (visited.has(`${stone[0]}${stone[1]}`)) {\n        return;\n    }\n    visited.add(`${stone[0]}${stone[1]}`);\n    if (rowMap[stone[0]]) {\n        for (let col of rowMap[stone[0]]) {\n            dfs([stone[0], col]);\n        }\n    }\n    if (colMap[stone[1]]) {\n        for (let row of colMap[stone[1]]) {\n            dfs([row, stone[1]]);\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "ndav",
                        "content": "I have the same problem, it\\'s an off by one.."
                    },
                    {
                        "username": "agggent99",
                        "content": "Suppose we have points [[0,0], [0,1], [1,0], [1,1]]\\nHow can we remove 3 stones ? \\nsince if we keep [0,0] then  we can only remove [0,1] and [1,0]. because [1,1] has neither row nor column common with [0,0].\\nSimilarly for other points as well.\\nSo that means atmax I can remove 2 stones ?"
                    },
                    {
                        "username": "KaziRomel",
                        "content": "[1,1] can be removed since [1,0] has same row number. [1,0] can be removed since [0,0] has same column number and [0,1] can be removed since [0,0] has same row number."
                    },
                    {
                        "username": "voldemort_13",
                        "content": "Stone at [1,1] can be removed because it has same row with stone at [1,0] which can be thrown and also same column with stone at [0,1] which again can be removed as you had found it .\\nSo we are going from [0,0] to [0,1] then from [0,1] to [1,1] then from [1,1] to [1,0]. So three stones can be thrown."
                    },
                    {
                        "username": "AEni",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\nsays expected is 4.\\nBut if we calculate the conencted component size, the maximum component has size 4 so the result should be 3. Am i missing something?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "anhmiuhv",
                        "content": "[[3,2],[3,1],[4,4],[1,1],[0,2],[4,0]]\\n\\nWhy the result is 4 instead of 3?"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1. \\nSo, It will be 4."
                    },
                    {
                        "username": "rarara",
                        "content": "Please someone help me understand why we need to use `~y` when building union find structure for these edges?\\n\\nSee this [answer](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/197668/Count-the-Number-of-Islands-O(N)) for reference for what I am talking about."
                    },
                    {
                        "username": "SeineAle",
                        "content": "Good Question, You can easily do it if your concepts of trees, graphs and connected components are clear."
                    },
                    {
                        "username": "TLE_c0der",
                        "content": "How is this problem tagged as Medium "
                    }
                ]
            },
            {
                "id": 1909429,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "Solution is not intuitive at all. "
                    },
                    {
                        "username": "gadmo",
                        "content": "conceptually this is an 'hard' problem. once you understand it - its just a simple dfs."
                    },
                    {
                        "username": "Harshal7565",
                        "content": "How can I get rid of this testcase [[0,1],[1,0]]\n\nMy code - \n `\nclass Solution {    \npublic int removeStones(int[][] stones) {\n        int count = 0;\n        int n = getMaxNumber(stones);\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < stones.length; i++) {\n            graph.get(stones[i][0]).add(stones[i][1]);\n            graph.get(stones[i][1]).add(stones[i][0]);\n        }\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, graph);\n                count++;\n            }\n        }\n        return stones.length - count;\n    }\n\n    public void dfs(int s, boolean[] visited, List<List<Integer>> graph) {\n        Stack<Integer> st = new Stack<>();\n        st.push(s);\n        visited[s] = true;\n        while (!st.isEmpty()) {\n            int u = st.pop();\n            for (int i = 0; i < graph.get(u).size(); i++) {\n                int v = graph.get(u).get(i);\n                if (!visited[v]) {\n                    visited[v] = true;\n                    st.push(v);\n                }\n            }\n        }\n    }\n\n    public static int getMaxNumber(int[][] array) {\n\t    int maxNumber = array[0][0];\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                if (array[i][j] > maxNumber) {\n                maxNumber = array[i][j];\n                }\n            }\n        }\n        return maxNumber + 1;\n    }\n}`"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "If you use union-find, it would be very easy."
                    },
                    {
                        "username": "bryanba",
                        "content": "class Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return self.remove_stones(stones)\\n\\n    def calc_lengths(self,diction):\\n        diction_len = {}\\n        \\n        for key in diction:\\n            diction_len[key] = len(diction[key])\\n        \\n        dic = dict(sorted(diction_len.items(), key=lambda item: item[1]))\\n        return dic\\n\\n\\n    def remove_stones(self,stones):\\n        \\n        stones.sort()\\n        diction = {}\\n        \\n        for i in range(len(stones)):\\n            diction[(stones[i][0],stones[i][1])] = [x for x in stones if((x[0] == stones[i][0] or x[1] == stones[i][1]) and (x != stones[i]))]\\n\\n        res = 0\\n        while(True):\\n            diction_len = self.calc_lengths(diction)\\n            diction_bool = any(x >= 1 for x in diction_len.values()) and len(diction) > 1\\n            if(not diction_bool):\\n                break\\n            mini = list(diction_len.keys())[0]\\n            for key,l in diction.items():\\n                for val in l:\\n                    if(val == list(mini)):\\n                        diction[key].remove(val)\\n            del diction[mini]\\n            if(diction_len[mini] > 0):\\n                res += 1\\n            \\n        return res    \\n\\nWHY ISN\\'T IT WORKING, IT WORKS ON MY IDE HELP PLEASE"
                    },
                    {
                        "username": "connorharris",
                        "content": "Idea for a solution:\\n\\nThink about the problem as a graph problem. Stones are vertices, and edges connect stones on the same row or column.\\n\\nNow think about a more general problem: you have a general graph and and you can remove any vertex that isn\\'t isolated. How many vertices can you remove? It turns out that you can remove every vertex but one from each connected component. One way to do this is to compute a DFS tree for every connected component, and then repeatedly remove leaves from the DFS tree using postorder traversal until you get to one vertex. Since the remaining DFS tree stays connected after you remove a leaf, the component as a whole (which contains all the edges in the DFS tree plus possibly some extra ones) also stays connected, so removing a leaf won\\'t create any isolated vertices until you remove the second-to-last vertex to create a one-vertex graph.\\n\\nSo the answer is just the number of stones in the graph minus the number of connected components, and you can count connected components in a graph in linear time with DFS."
                    },
                    {
                        "username": "user0783WN",
                        "content": "BFS solution:\\n1 create color array to coloring the visited node\\n2 create adjacent list List<List<Integer>> to record all the adjacent node index for each node\\n3 visit each node, if the node is already colored, continue\\n4 BFS search all the adjacent node\\nwhile(!nodeIndexQ.isEmpy()){\\n  int[] currNodeIndex = nodeIndexQ.poll();\\n  for(int index : adjacentNodeIndexList){\\n      if(color[index] is colored){\\n        continue;      \\n     }\\n     color[index] = colored\\n     nodeQ.add(index);\\n }\\n}\\n5 once BFS search is done on current node, total group++;\\n6 once loop is done, return stones.length - total"
                    },
                    {
                        "username": "itsmemo",
                        "content": "I guess this problem\\'s description has been changed but examples and the test cases left untouched. According to the current definition you cannot remove 5 stones for the first example. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "For testcase [[0,1],[1,0]], how is the expected output 0 and not 1?  If we remove either of the stone at 01 or 10, there will only be one stone left. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "[@Minamikaze392](/Minamikaze392) Thanks! Makes sense now. It\\'s my logic that\\'s problem. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "```\\n     |stone\\n-----|-----\\nstone|\\n```\\nThey don\\'t share the same row or column, so you cannot remove one of them."
                    },
                    {
                        "username": "hotsixredbull",
                        "content": "I\\'m having a hard time to check if there\\'s any case that visiting order matters to find maximum removal. if the case exists, i think i need to search all the paths starting from every stone. Any ideas?"
                    }
                ]
            },
            {
                "id": 1882042,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "Solution is not intuitive at all. "
                    },
                    {
                        "username": "gadmo",
                        "content": "conceptually this is an 'hard' problem. once you understand it - its just a simple dfs."
                    },
                    {
                        "username": "Harshal7565",
                        "content": "How can I get rid of this testcase [[0,1],[1,0]]\n\nMy code - \n `\nclass Solution {    \npublic int removeStones(int[][] stones) {\n        int count = 0;\n        int n = getMaxNumber(stones);\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < stones.length; i++) {\n            graph.get(stones[i][0]).add(stones[i][1]);\n            graph.get(stones[i][1]).add(stones[i][0]);\n        }\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, graph);\n                count++;\n            }\n        }\n        return stones.length - count;\n    }\n\n    public void dfs(int s, boolean[] visited, List<List<Integer>> graph) {\n        Stack<Integer> st = new Stack<>();\n        st.push(s);\n        visited[s] = true;\n        while (!st.isEmpty()) {\n            int u = st.pop();\n            for (int i = 0; i < graph.get(u).size(); i++) {\n                int v = graph.get(u).get(i);\n                if (!visited[v]) {\n                    visited[v] = true;\n                    st.push(v);\n                }\n            }\n        }\n    }\n\n    public static int getMaxNumber(int[][] array) {\n\t    int maxNumber = array[0][0];\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                if (array[i][j] > maxNumber) {\n                maxNumber = array[i][j];\n                }\n            }\n        }\n        return maxNumber + 1;\n    }\n}`"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "If you use union-find, it would be very easy."
                    },
                    {
                        "username": "bryanba",
                        "content": "class Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return self.remove_stones(stones)\\n\\n    def calc_lengths(self,diction):\\n        diction_len = {}\\n        \\n        for key in diction:\\n            diction_len[key] = len(diction[key])\\n        \\n        dic = dict(sorted(diction_len.items(), key=lambda item: item[1]))\\n        return dic\\n\\n\\n    def remove_stones(self,stones):\\n        \\n        stones.sort()\\n        diction = {}\\n        \\n        for i in range(len(stones)):\\n            diction[(stones[i][0],stones[i][1])] = [x for x in stones if((x[0] == stones[i][0] or x[1] == stones[i][1]) and (x != stones[i]))]\\n\\n        res = 0\\n        while(True):\\n            diction_len = self.calc_lengths(diction)\\n            diction_bool = any(x >= 1 for x in diction_len.values()) and len(diction) > 1\\n            if(not diction_bool):\\n                break\\n            mini = list(diction_len.keys())[0]\\n            for key,l in diction.items():\\n                for val in l:\\n                    if(val == list(mini)):\\n                        diction[key].remove(val)\\n            del diction[mini]\\n            if(diction_len[mini] > 0):\\n                res += 1\\n            \\n        return res    \\n\\nWHY ISN\\'T IT WORKING, IT WORKS ON MY IDE HELP PLEASE"
                    },
                    {
                        "username": "connorharris",
                        "content": "Idea for a solution:\\n\\nThink about the problem as a graph problem. Stones are vertices, and edges connect stones on the same row or column.\\n\\nNow think about a more general problem: you have a general graph and and you can remove any vertex that isn\\'t isolated. How many vertices can you remove? It turns out that you can remove every vertex but one from each connected component. One way to do this is to compute a DFS tree for every connected component, and then repeatedly remove leaves from the DFS tree using postorder traversal until you get to one vertex. Since the remaining DFS tree stays connected after you remove a leaf, the component as a whole (which contains all the edges in the DFS tree plus possibly some extra ones) also stays connected, so removing a leaf won\\'t create any isolated vertices until you remove the second-to-last vertex to create a one-vertex graph.\\n\\nSo the answer is just the number of stones in the graph minus the number of connected components, and you can count connected components in a graph in linear time with DFS."
                    },
                    {
                        "username": "user0783WN",
                        "content": "BFS solution:\\n1 create color array to coloring the visited node\\n2 create adjacent list List<List<Integer>> to record all the adjacent node index for each node\\n3 visit each node, if the node is already colored, continue\\n4 BFS search all the adjacent node\\nwhile(!nodeIndexQ.isEmpy()){\\n  int[] currNodeIndex = nodeIndexQ.poll();\\n  for(int index : adjacentNodeIndexList){\\n      if(color[index] is colored){\\n        continue;      \\n     }\\n     color[index] = colored\\n     nodeQ.add(index);\\n }\\n}\\n5 once BFS search is done on current node, total group++;\\n6 once loop is done, return stones.length - total"
                    },
                    {
                        "username": "itsmemo",
                        "content": "I guess this problem\\'s description has been changed but examples and the test cases left untouched. According to the current definition you cannot remove 5 stones for the first example. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "For testcase [[0,1],[1,0]], how is the expected output 0 and not 1?  If we remove either of the stone at 01 or 10, there will only be one stone left. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "[@Minamikaze392](/Minamikaze392) Thanks! Makes sense now. It\\'s my logic that\\'s problem. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "```\\n     |stone\\n-----|-----\\nstone|\\n```\\nThey don\\'t share the same row or column, so you cannot remove one of them."
                    },
                    {
                        "username": "hotsixredbull",
                        "content": "I\\'m having a hard time to check if there\\'s any case that visiting order matters to find maximum removal. if the case exists, i think i need to search all the paths starting from every stone. Any ideas?"
                    }
                ]
            },
            {
                "id": 1851596,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "Solution is not intuitive at all. "
                    },
                    {
                        "username": "gadmo",
                        "content": "conceptually this is an 'hard' problem. once you understand it - its just a simple dfs."
                    },
                    {
                        "username": "Harshal7565",
                        "content": "How can I get rid of this testcase [[0,1],[1,0]]\n\nMy code - \n `\nclass Solution {    \npublic int removeStones(int[][] stones) {\n        int count = 0;\n        int n = getMaxNumber(stones);\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < stones.length; i++) {\n            graph.get(stones[i][0]).add(stones[i][1]);\n            graph.get(stones[i][1]).add(stones[i][0]);\n        }\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, graph);\n                count++;\n            }\n        }\n        return stones.length - count;\n    }\n\n    public void dfs(int s, boolean[] visited, List<List<Integer>> graph) {\n        Stack<Integer> st = new Stack<>();\n        st.push(s);\n        visited[s] = true;\n        while (!st.isEmpty()) {\n            int u = st.pop();\n            for (int i = 0; i < graph.get(u).size(); i++) {\n                int v = graph.get(u).get(i);\n                if (!visited[v]) {\n                    visited[v] = true;\n                    st.push(v);\n                }\n            }\n        }\n    }\n\n    public static int getMaxNumber(int[][] array) {\n\t    int maxNumber = array[0][0];\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                if (array[i][j] > maxNumber) {\n                maxNumber = array[i][j];\n                }\n            }\n        }\n        return maxNumber + 1;\n    }\n}`"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "If you use union-find, it would be very easy."
                    },
                    {
                        "username": "bryanba",
                        "content": "class Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return self.remove_stones(stones)\\n\\n    def calc_lengths(self,diction):\\n        diction_len = {}\\n        \\n        for key in diction:\\n            diction_len[key] = len(diction[key])\\n        \\n        dic = dict(sorted(diction_len.items(), key=lambda item: item[1]))\\n        return dic\\n\\n\\n    def remove_stones(self,stones):\\n        \\n        stones.sort()\\n        diction = {}\\n        \\n        for i in range(len(stones)):\\n            diction[(stones[i][0],stones[i][1])] = [x for x in stones if((x[0] == stones[i][0] or x[1] == stones[i][1]) and (x != stones[i]))]\\n\\n        res = 0\\n        while(True):\\n            diction_len = self.calc_lengths(diction)\\n            diction_bool = any(x >= 1 for x in diction_len.values()) and len(diction) > 1\\n            if(not diction_bool):\\n                break\\n            mini = list(diction_len.keys())[0]\\n            for key,l in diction.items():\\n                for val in l:\\n                    if(val == list(mini)):\\n                        diction[key].remove(val)\\n            del diction[mini]\\n            if(diction_len[mini] > 0):\\n                res += 1\\n            \\n        return res    \\n\\nWHY ISN\\'T IT WORKING, IT WORKS ON MY IDE HELP PLEASE"
                    },
                    {
                        "username": "connorharris",
                        "content": "Idea for a solution:\\n\\nThink about the problem as a graph problem. Stones are vertices, and edges connect stones on the same row or column.\\n\\nNow think about a more general problem: you have a general graph and and you can remove any vertex that isn\\'t isolated. How many vertices can you remove? It turns out that you can remove every vertex but one from each connected component. One way to do this is to compute a DFS tree for every connected component, and then repeatedly remove leaves from the DFS tree using postorder traversal until you get to one vertex. Since the remaining DFS tree stays connected after you remove a leaf, the component as a whole (which contains all the edges in the DFS tree plus possibly some extra ones) also stays connected, so removing a leaf won\\'t create any isolated vertices until you remove the second-to-last vertex to create a one-vertex graph.\\n\\nSo the answer is just the number of stones in the graph minus the number of connected components, and you can count connected components in a graph in linear time with DFS."
                    },
                    {
                        "username": "user0783WN",
                        "content": "BFS solution:\\n1 create color array to coloring the visited node\\n2 create adjacent list List<List<Integer>> to record all the adjacent node index for each node\\n3 visit each node, if the node is already colored, continue\\n4 BFS search all the adjacent node\\nwhile(!nodeIndexQ.isEmpy()){\\n  int[] currNodeIndex = nodeIndexQ.poll();\\n  for(int index : adjacentNodeIndexList){\\n      if(color[index] is colored){\\n        continue;      \\n     }\\n     color[index] = colored\\n     nodeQ.add(index);\\n }\\n}\\n5 once BFS search is done on current node, total group++;\\n6 once loop is done, return stones.length - total"
                    },
                    {
                        "username": "itsmemo",
                        "content": "I guess this problem\\'s description has been changed but examples and the test cases left untouched. According to the current definition you cannot remove 5 stones for the first example. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "For testcase [[0,1],[1,0]], how is the expected output 0 and not 1?  If we remove either of the stone at 01 or 10, there will only be one stone left. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "[@Minamikaze392](/Minamikaze392) Thanks! Makes sense now. It\\'s my logic that\\'s problem. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "```\\n     |stone\\n-----|-----\\nstone|\\n```\\nThey don\\'t share the same row or column, so you cannot remove one of them."
                    },
                    {
                        "username": "hotsixredbull",
                        "content": "I\\'m having a hard time to check if there\\'s any case that visiting order matters to find maximum removal. if the case exists, i think i need to search all the paths starting from every stone. Any ideas?"
                    }
                ]
            },
            {
                "id": 1843835,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "Solution is not intuitive at all. "
                    },
                    {
                        "username": "gadmo",
                        "content": "conceptually this is an 'hard' problem. once you understand it - its just a simple dfs."
                    },
                    {
                        "username": "Harshal7565",
                        "content": "How can I get rid of this testcase [[0,1],[1,0]]\n\nMy code - \n `\nclass Solution {    \npublic int removeStones(int[][] stones) {\n        int count = 0;\n        int n = getMaxNumber(stones);\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < stones.length; i++) {\n            graph.get(stones[i][0]).add(stones[i][1]);\n            graph.get(stones[i][1]).add(stones[i][0]);\n        }\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, graph);\n                count++;\n            }\n        }\n        return stones.length - count;\n    }\n\n    public void dfs(int s, boolean[] visited, List<List<Integer>> graph) {\n        Stack<Integer> st = new Stack<>();\n        st.push(s);\n        visited[s] = true;\n        while (!st.isEmpty()) {\n            int u = st.pop();\n            for (int i = 0; i < graph.get(u).size(); i++) {\n                int v = graph.get(u).get(i);\n                if (!visited[v]) {\n                    visited[v] = true;\n                    st.push(v);\n                }\n            }\n        }\n    }\n\n    public static int getMaxNumber(int[][] array) {\n\t    int maxNumber = array[0][0];\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                if (array[i][j] > maxNumber) {\n                maxNumber = array[i][j];\n                }\n            }\n        }\n        return maxNumber + 1;\n    }\n}`"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "If you use union-find, it would be very easy."
                    },
                    {
                        "username": "bryanba",
                        "content": "class Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return self.remove_stones(stones)\\n\\n    def calc_lengths(self,diction):\\n        diction_len = {}\\n        \\n        for key in diction:\\n            diction_len[key] = len(diction[key])\\n        \\n        dic = dict(sorted(diction_len.items(), key=lambda item: item[1]))\\n        return dic\\n\\n\\n    def remove_stones(self,stones):\\n        \\n        stones.sort()\\n        diction = {}\\n        \\n        for i in range(len(stones)):\\n            diction[(stones[i][0],stones[i][1])] = [x for x in stones if((x[0] == stones[i][0] or x[1] == stones[i][1]) and (x != stones[i]))]\\n\\n        res = 0\\n        while(True):\\n            diction_len = self.calc_lengths(diction)\\n            diction_bool = any(x >= 1 for x in diction_len.values()) and len(diction) > 1\\n            if(not diction_bool):\\n                break\\n            mini = list(diction_len.keys())[0]\\n            for key,l in diction.items():\\n                for val in l:\\n                    if(val == list(mini)):\\n                        diction[key].remove(val)\\n            del diction[mini]\\n            if(diction_len[mini] > 0):\\n                res += 1\\n            \\n        return res    \\n\\nWHY ISN\\'T IT WORKING, IT WORKS ON MY IDE HELP PLEASE"
                    },
                    {
                        "username": "connorharris",
                        "content": "Idea for a solution:\\n\\nThink about the problem as a graph problem. Stones are vertices, and edges connect stones on the same row or column.\\n\\nNow think about a more general problem: you have a general graph and and you can remove any vertex that isn\\'t isolated. How many vertices can you remove? It turns out that you can remove every vertex but one from each connected component. One way to do this is to compute a DFS tree for every connected component, and then repeatedly remove leaves from the DFS tree using postorder traversal until you get to one vertex. Since the remaining DFS tree stays connected after you remove a leaf, the component as a whole (which contains all the edges in the DFS tree plus possibly some extra ones) also stays connected, so removing a leaf won\\'t create any isolated vertices until you remove the second-to-last vertex to create a one-vertex graph.\\n\\nSo the answer is just the number of stones in the graph minus the number of connected components, and you can count connected components in a graph in linear time with DFS."
                    },
                    {
                        "username": "user0783WN",
                        "content": "BFS solution:\\n1 create color array to coloring the visited node\\n2 create adjacent list List<List<Integer>> to record all the adjacent node index for each node\\n3 visit each node, if the node is already colored, continue\\n4 BFS search all the adjacent node\\nwhile(!nodeIndexQ.isEmpy()){\\n  int[] currNodeIndex = nodeIndexQ.poll();\\n  for(int index : adjacentNodeIndexList){\\n      if(color[index] is colored){\\n        continue;      \\n     }\\n     color[index] = colored\\n     nodeQ.add(index);\\n }\\n}\\n5 once BFS search is done on current node, total group++;\\n6 once loop is done, return stones.length - total"
                    },
                    {
                        "username": "itsmemo",
                        "content": "I guess this problem\\'s description has been changed but examples and the test cases left untouched. According to the current definition you cannot remove 5 stones for the first example. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "For testcase [[0,1],[1,0]], how is the expected output 0 and not 1?  If we remove either of the stone at 01 or 10, there will only be one stone left. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "[@Minamikaze392](/Minamikaze392) Thanks! Makes sense now. It\\'s my logic that\\'s problem. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "```\\n     |stone\\n-----|-----\\nstone|\\n```\\nThey don\\'t share the same row or column, so you cannot remove one of them."
                    },
                    {
                        "username": "hotsixredbull",
                        "content": "I\\'m having a hard time to check if there\\'s any case that visiting order matters to find maximum removal. if the case exists, i think i need to search all the paths starting from every stone. Any ideas?"
                    }
                ]
            },
            {
                "id": 1839436,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "Solution is not intuitive at all. "
                    },
                    {
                        "username": "gadmo",
                        "content": "conceptually this is an 'hard' problem. once you understand it - its just a simple dfs."
                    },
                    {
                        "username": "Harshal7565",
                        "content": "How can I get rid of this testcase [[0,1],[1,0]]\n\nMy code - \n `\nclass Solution {    \npublic int removeStones(int[][] stones) {\n        int count = 0;\n        int n = getMaxNumber(stones);\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < stones.length; i++) {\n            graph.get(stones[i][0]).add(stones[i][1]);\n            graph.get(stones[i][1]).add(stones[i][0]);\n        }\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, graph);\n                count++;\n            }\n        }\n        return stones.length - count;\n    }\n\n    public void dfs(int s, boolean[] visited, List<List<Integer>> graph) {\n        Stack<Integer> st = new Stack<>();\n        st.push(s);\n        visited[s] = true;\n        while (!st.isEmpty()) {\n            int u = st.pop();\n            for (int i = 0; i < graph.get(u).size(); i++) {\n                int v = graph.get(u).get(i);\n                if (!visited[v]) {\n                    visited[v] = true;\n                    st.push(v);\n                }\n            }\n        }\n    }\n\n    public static int getMaxNumber(int[][] array) {\n\t    int maxNumber = array[0][0];\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                if (array[i][j] > maxNumber) {\n                maxNumber = array[i][j];\n                }\n            }\n        }\n        return maxNumber + 1;\n    }\n}`"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "If you use union-find, it would be very easy."
                    },
                    {
                        "username": "bryanba",
                        "content": "class Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return self.remove_stones(stones)\\n\\n    def calc_lengths(self,diction):\\n        diction_len = {}\\n        \\n        for key in diction:\\n            diction_len[key] = len(diction[key])\\n        \\n        dic = dict(sorted(diction_len.items(), key=lambda item: item[1]))\\n        return dic\\n\\n\\n    def remove_stones(self,stones):\\n        \\n        stones.sort()\\n        diction = {}\\n        \\n        for i in range(len(stones)):\\n            diction[(stones[i][0],stones[i][1])] = [x for x in stones if((x[0] == stones[i][0] or x[1] == stones[i][1]) and (x != stones[i]))]\\n\\n        res = 0\\n        while(True):\\n            diction_len = self.calc_lengths(diction)\\n            diction_bool = any(x >= 1 for x in diction_len.values()) and len(diction) > 1\\n            if(not diction_bool):\\n                break\\n            mini = list(diction_len.keys())[0]\\n            for key,l in diction.items():\\n                for val in l:\\n                    if(val == list(mini)):\\n                        diction[key].remove(val)\\n            del diction[mini]\\n            if(diction_len[mini] > 0):\\n                res += 1\\n            \\n        return res    \\n\\nWHY ISN\\'T IT WORKING, IT WORKS ON MY IDE HELP PLEASE"
                    },
                    {
                        "username": "connorharris",
                        "content": "Idea for a solution:\\n\\nThink about the problem as a graph problem. Stones are vertices, and edges connect stones on the same row or column.\\n\\nNow think about a more general problem: you have a general graph and and you can remove any vertex that isn\\'t isolated. How many vertices can you remove? It turns out that you can remove every vertex but one from each connected component. One way to do this is to compute a DFS tree for every connected component, and then repeatedly remove leaves from the DFS tree using postorder traversal until you get to one vertex. Since the remaining DFS tree stays connected after you remove a leaf, the component as a whole (which contains all the edges in the DFS tree plus possibly some extra ones) also stays connected, so removing a leaf won\\'t create any isolated vertices until you remove the second-to-last vertex to create a one-vertex graph.\\n\\nSo the answer is just the number of stones in the graph minus the number of connected components, and you can count connected components in a graph in linear time with DFS."
                    },
                    {
                        "username": "user0783WN",
                        "content": "BFS solution:\\n1 create color array to coloring the visited node\\n2 create adjacent list List<List<Integer>> to record all the adjacent node index for each node\\n3 visit each node, if the node is already colored, continue\\n4 BFS search all the adjacent node\\nwhile(!nodeIndexQ.isEmpy()){\\n  int[] currNodeIndex = nodeIndexQ.poll();\\n  for(int index : adjacentNodeIndexList){\\n      if(color[index] is colored){\\n        continue;      \\n     }\\n     color[index] = colored\\n     nodeQ.add(index);\\n }\\n}\\n5 once BFS search is done on current node, total group++;\\n6 once loop is done, return stones.length - total"
                    },
                    {
                        "username": "itsmemo",
                        "content": "I guess this problem\\'s description has been changed but examples and the test cases left untouched. According to the current definition you cannot remove 5 stones for the first example. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "For testcase [[0,1],[1,0]], how is the expected output 0 and not 1?  If we remove either of the stone at 01 or 10, there will only be one stone left. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "[@Minamikaze392](/Minamikaze392) Thanks! Makes sense now. It\\'s my logic that\\'s problem. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "```\\n     |stone\\n-----|-----\\nstone|\\n```\\nThey don\\'t share the same row or column, so you cannot remove one of them."
                    },
                    {
                        "username": "hotsixredbull",
                        "content": "I\\'m having a hard time to check if there\\'s any case that visiting order matters to find maximum removal. if the case exists, i think i need to search all the paths starting from every stone. Any ideas?"
                    }
                ]
            },
            {
                "id": 1811005,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "Solution is not intuitive at all. "
                    },
                    {
                        "username": "gadmo",
                        "content": "conceptually this is an 'hard' problem. once you understand it - its just a simple dfs."
                    },
                    {
                        "username": "Harshal7565",
                        "content": "How can I get rid of this testcase [[0,1],[1,0]]\n\nMy code - \n `\nclass Solution {    \npublic int removeStones(int[][] stones) {\n        int count = 0;\n        int n = getMaxNumber(stones);\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < stones.length; i++) {\n            graph.get(stones[i][0]).add(stones[i][1]);\n            graph.get(stones[i][1]).add(stones[i][0]);\n        }\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, graph);\n                count++;\n            }\n        }\n        return stones.length - count;\n    }\n\n    public void dfs(int s, boolean[] visited, List<List<Integer>> graph) {\n        Stack<Integer> st = new Stack<>();\n        st.push(s);\n        visited[s] = true;\n        while (!st.isEmpty()) {\n            int u = st.pop();\n            for (int i = 0; i < graph.get(u).size(); i++) {\n                int v = graph.get(u).get(i);\n                if (!visited[v]) {\n                    visited[v] = true;\n                    st.push(v);\n                }\n            }\n        }\n    }\n\n    public static int getMaxNumber(int[][] array) {\n\t    int maxNumber = array[0][0];\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                if (array[i][j] > maxNumber) {\n                maxNumber = array[i][j];\n                }\n            }\n        }\n        return maxNumber + 1;\n    }\n}`"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "If you use union-find, it would be very easy."
                    },
                    {
                        "username": "bryanba",
                        "content": "class Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return self.remove_stones(stones)\\n\\n    def calc_lengths(self,diction):\\n        diction_len = {}\\n        \\n        for key in diction:\\n            diction_len[key] = len(diction[key])\\n        \\n        dic = dict(sorted(diction_len.items(), key=lambda item: item[1]))\\n        return dic\\n\\n\\n    def remove_stones(self,stones):\\n        \\n        stones.sort()\\n        diction = {}\\n        \\n        for i in range(len(stones)):\\n            diction[(stones[i][0],stones[i][1])] = [x for x in stones if((x[0] == stones[i][0] or x[1] == stones[i][1]) and (x != stones[i]))]\\n\\n        res = 0\\n        while(True):\\n            diction_len = self.calc_lengths(diction)\\n            diction_bool = any(x >= 1 for x in diction_len.values()) and len(diction) > 1\\n            if(not diction_bool):\\n                break\\n            mini = list(diction_len.keys())[0]\\n            for key,l in diction.items():\\n                for val in l:\\n                    if(val == list(mini)):\\n                        diction[key].remove(val)\\n            del diction[mini]\\n            if(diction_len[mini] > 0):\\n                res += 1\\n            \\n        return res    \\n\\nWHY ISN\\'T IT WORKING, IT WORKS ON MY IDE HELP PLEASE"
                    },
                    {
                        "username": "connorharris",
                        "content": "Idea for a solution:\\n\\nThink about the problem as a graph problem. Stones are vertices, and edges connect stones on the same row or column.\\n\\nNow think about a more general problem: you have a general graph and and you can remove any vertex that isn\\'t isolated. How many vertices can you remove? It turns out that you can remove every vertex but one from each connected component. One way to do this is to compute a DFS tree for every connected component, and then repeatedly remove leaves from the DFS tree using postorder traversal until you get to one vertex. Since the remaining DFS tree stays connected after you remove a leaf, the component as a whole (which contains all the edges in the DFS tree plus possibly some extra ones) also stays connected, so removing a leaf won\\'t create any isolated vertices until you remove the second-to-last vertex to create a one-vertex graph.\\n\\nSo the answer is just the number of stones in the graph minus the number of connected components, and you can count connected components in a graph in linear time with DFS."
                    },
                    {
                        "username": "user0783WN",
                        "content": "BFS solution:\\n1 create color array to coloring the visited node\\n2 create adjacent list List<List<Integer>> to record all the adjacent node index for each node\\n3 visit each node, if the node is already colored, continue\\n4 BFS search all the adjacent node\\nwhile(!nodeIndexQ.isEmpy()){\\n  int[] currNodeIndex = nodeIndexQ.poll();\\n  for(int index : adjacentNodeIndexList){\\n      if(color[index] is colored){\\n        continue;      \\n     }\\n     color[index] = colored\\n     nodeQ.add(index);\\n }\\n}\\n5 once BFS search is done on current node, total group++;\\n6 once loop is done, return stones.length - total"
                    },
                    {
                        "username": "itsmemo",
                        "content": "I guess this problem\\'s description has been changed but examples and the test cases left untouched. According to the current definition you cannot remove 5 stones for the first example. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "For testcase [[0,1],[1,0]], how is the expected output 0 and not 1?  If we remove either of the stone at 01 or 10, there will only be one stone left. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "[@Minamikaze392](/Minamikaze392) Thanks! Makes sense now. It\\'s my logic that\\'s problem. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "```\\n     |stone\\n-----|-----\\nstone|\\n```\\nThey don\\'t share the same row or column, so you cannot remove one of them."
                    },
                    {
                        "username": "hotsixredbull",
                        "content": "I\\'m having a hard time to check if there\\'s any case that visiting order matters to find maximum removal. if the case exists, i think i need to search all the paths starting from every stone. Any ideas?"
                    }
                ]
            },
            {
                "id": 1769167,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "Solution is not intuitive at all. "
                    },
                    {
                        "username": "gadmo",
                        "content": "conceptually this is an 'hard' problem. once you understand it - its just a simple dfs."
                    },
                    {
                        "username": "Harshal7565",
                        "content": "How can I get rid of this testcase [[0,1],[1,0]]\n\nMy code - \n `\nclass Solution {    \npublic int removeStones(int[][] stones) {\n        int count = 0;\n        int n = getMaxNumber(stones);\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < stones.length; i++) {\n            graph.get(stones[i][0]).add(stones[i][1]);\n            graph.get(stones[i][1]).add(stones[i][0]);\n        }\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, graph);\n                count++;\n            }\n        }\n        return stones.length - count;\n    }\n\n    public void dfs(int s, boolean[] visited, List<List<Integer>> graph) {\n        Stack<Integer> st = new Stack<>();\n        st.push(s);\n        visited[s] = true;\n        while (!st.isEmpty()) {\n            int u = st.pop();\n            for (int i = 0; i < graph.get(u).size(); i++) {\n                int v = graph.get(u).get(i);\n                if (!visited[v]) {\n                    visited[v] = true;\n                    st.push(v);\n                }\n            }\n        }\n    }\n\n    public static int getMaxNumber(int[][] array) {\n\t    int maxNumber = array[0][0];\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                if (array[i][j] > maxNumber) {\n                maxNumber = array[i][j];\n                }\n            }\n        }\n        return maxNumber + 1;\n    }\n}`"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "If you use union-find, it would be very easy."
                    },
                    {
                        "username": "bryanba",
                        "content": "class Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return self.remove_stones(stones)\\n\\n    def calc_lengths(self,diction):\\n        diction_len = {}\\n        \\n        for key in diction:\\n            diction_len[key] = len(diction[key])\\n        \\n        dic = dict(sorted(diction_len.items(), key=lambda item: item[1]))\\n        return dic\\n\\n\\n    def remove_stones(self,stones):\\n        \\n        stones.sort()\\n        diction = {}\\n        \\n        for i in range(len(stones)):\\n            diction[(stones[i][0],stones[i][1])] = [x for x in stones if((x[0] == stones[i][0] or x[1] == stones[i][1]) and (x != stones[i]))]\\n\\n        res = 0\\n        while(True):\\n            diction_len = self.calc_lengths(diction)\\n            diction_bool = any(x >= 1 for x in diction_len.values()) and len(diction) > 1\\n            if(not diction_bool):\\n                break\\n            mini = list(diction_len.keys())[0]\\n            for key,l in diction.items():\\n                for val in l:\\n                    if(val == list(mini)):\\n                        diction[key].remove(val)\\n            del diction[mini]\\n            if(diction_len[mini] > 0):\\n                res += 1\\n            \\n        return res    \\n\\nWHY ISN\\'T IT WORKING, IT WORKS ON MY IDE HELP PLEASE"
                    },
                    {
                        "username": "connorharris",
                        "content": "Idea for a solution:\\n\\nThink about the problem as a graph problem. Stones are vertices, and edges connect stones on the same row or column.\\n\\nNow think about a more general problem: you have a general graph and and you can remove any vertex that isn\\'t isolated. How many vertices can you remove? It turns out that you can remove every vertex but one from each connected component. One way to do this is to compute a DFS tree for every connected component, and then repeatedly remove leaves from the DFS tree using postorder traversal until you get to one vertex. Since the remaining DFS tree stays connected after you remove a leaf, the component as a whole (which contains all the edges in the DFS tree plus possibly some extra ones) also stays connected, so removing a leaf won\\'t create any isolated vertices until you remove the second-to-last vertex to create a one-vertex graph.\\n\\nSo the answer is just the number of stones in the graph minus the number of connected components, and you can count connected components in a graph in linear time with DFS."
                    },
                    {
                        "username": "user0783WN",
                        "content": "BFS solution:\\n1 create color array to coloring the visited node\\n2 create adjacent list List<List<Integer>> to record all the adjacent node index for each node\\n3 visit each node, if the node is already colored, continue\\n4 BFS search all the adjacent node\\nwhile(!nodeIndexQ.isEmpy()){\\n  int[] currNodeIndex = nodeIndexQ.poll();\\n  for(int index : adjacentNodeIndexList){\\n      if(color[index] is colored){\\n        continue;      \\n     }\\n     color[index] = colored\\n     nodeQ.add(index);\\n }\\n}\\n5 once BFS search is done on current node, total group++;\\n6 once loop is done, return stones.length - total"
                    },
                    {
                        "username": "itsmemo",
                        "content": "I guess this problem\\'s description has been changed but examples and the test cases left untouched. According to the current definition you cannot remove 5 stones for the first example. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "For testcase [[0,1],[1,0]], how is the expected output 0 and not 1?  If we remove either of the stone at 01 or 10, there will only be one stone left. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "[@Minamikaze392](/Minamikaze392) Thanks! Makes sense now. It\\'s my logic that\\'s problem. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "```\\n     |stone\\n-----|-----\\nstone|\\n```\\nThey don\\'t share the same row or column, so you cannot remove one of them."
                    },
                    {
                        "username": "hotsixredbull",
                        "content": "I\\'m having a hard time to check if there\\'s any case that visiting order matters to find maximum removal. if the case exists, i think i need to search all the paths starting from every stone. Any ideas?"
                    }
                ]
            },
            {
                "id": 1753191,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "Solution is not intuitive at all. "
                    },
                    {
                        "username": "gadmo",
                        "content": "conceptually this is an 'hard' problem. once you understand it - its just a simple dfs."
                    },
                    {
                        "username": "Harshal7565",
                        "content": "How can I get rid of this testcase [[0,1],[1,0]]\n\nMy code - \n `\nclass Solution {    \npublic int removeStones(int[][] stones) {\n        int count = 0;\n        int n = getMaxNumber(stones);\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < stones.length; i++) {\n            graph.get(stones[i][0]).add(stones[i][1]);\n            graph.get(stones[i][1]).add(stones[i][0]);\n        }\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, graph);\n                count++;\n            }\n        }\n        return stones.length - count;\n    }\n\n    public void dfs(int s, boolean[] visited, List<List<Integer>> graph) {\n        Stack<Integer> st = new Stack<>();\n        st.push(s);\n        visited[s] = true;\n        while (!st.isEmpty()) {\n            int u = st.pop();\n            for (int i = 0; i < graph.get(u).size(); i++) {\n                int v = graph.get(u).get(i);\n                if (!visited[v]) {\n                    visited[v] = true;\n                    st.push(v);\n                }\n            }\n        }\n    }\n\n    public static int getMaxNumber(int[][] array) {\n\t    int maxNumber = array[0][0];\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                if (array[i][j] > maxNumber) {\n                maxNumber = array[i][j];\n                }\n            }\n        }\n        return maxNumber + 1;\n    }\n}`"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "If you use union-find, it would be very easy."
                    },
                    {
                        "username": "bryanba",
                        "content": "class Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return self.remove_stones(stones)\\n\\n    def calc_lengths(self,diction):\\n        diction_len = {}\\n        \\n        for key in diction:\\n            diction_len[key] = len(diction[key])\\n        \\n        dic = dict(sorted(diction_len.items(), key=lambda item: item[1]))\\n        return dic\\n\\n\\n    def remove_stones(self,stones):\\n        \\n        stones.sort()\\n        diction = {}\\n        \\n        for i in range(len(stones)):\\n            diction[(stones[i][0],stones[i][1])] = [x for x in stones if((x[0] == stones[i][0] or x[1] == stones[i][1]) and (x != stones[i]))]\\n\\n        res = 0\\n        while(True):\\n            diction_len = self.calc_lengths(diction)\\n            diction_bool = any(x >= 1 for x in diction_len.values()) and len(diction) > 1\\n            if(not diction_bool):\\n                break\\n            mini = list(diction_len.keys())[0]\\n            for key,l in diction.items():\\n                for val in l:\\n                    if(val == list(mini)):\\n                        diction[key].remove(val)\\n            del diction[mini]\\n            if(diction_len[mini] > 0):\\n                res += 1\\n            \\n        return res    \\n\\nWHY ISN\\'T IT WORKING, IT WORKS ON MY IDE HELP PLEASE"
                    },
                    {
                        "username": "connorharris",
                        "content": "Idea for a solution:\\n\\nThink about the problem as a graph problem. Stones are vertices, and edges connect stones on the same row or column.\\n\\nNow think about a more general problem: you have a general graph and and you can remove any vertex that isn\\'t isolated. How many vertices can you remove? It turns out that you can remove every vertex but one from each connected component. One way to do this is to compute a DFS tree for every connected component, and then repeatedly remove leaves from the DFS tree using postorder traversal until you get to one vertex. Since the remaining DFS tree stays connected after you remove a leaf, the component as a whole (which contains all the edges in the DFS tree plus possibly some extra ones) also stays connected, so removing a leaf won\\'t create any isolated vertices until you remove the second-to-last vertex to create a one-vertex graph.\\n\\nSo the answer is just the number of stones in the graph minus the number of connected components, and you can count connected components in a graph in linear time with DFS."
                    },
                    {
                        "username": "user0783WN",
                        "content": "BFS solution:\\n1 create color array to coloring the visited node\\n2 create adjacent list List<List<Integer>> to record all the adjacent node index for each node\\n3 visit each node, if the node is already colored, continue\\n4 BFS search all the adjacent node\\nwhile(!nodeIndexQ.isEmpy()){\\n  int[] currNodeIndex = nodeIndexQ.poll();\\n  for(int index : adjacentNodeIndexList){\\n      if(color[index] is colored){\\n        continue;      \\n     }\\n     color[index] = colored\\n     nodeQ.add(index);\\n }\\n}\\n5 once BFS search is done on current node, total group++;\\n6 once loop is done, return stones.length - total"
                    },
                    {
                        "username": "itsmemo",
                        "content": "I guess this problem\\'s description has been changed but examples and the test cases left untouched. According to the current definition you cannot remove 5 stones for the first example. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "For testcase [[0,1],[1,0]], how is the expected output 0 and not 1?  If we remove either of the stone at 01 or 10, there will only be one stone left. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "[@Minamikaze392](/Minamikaze392) Thanks! Makes sense now. It\\'s my logic that\\'s problem. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "```\\n     |stone\\n-----|-----\\nstone|\\n```\\nThey don\\'t share the same row or column, so you cannot remove one of them."
                    },
                    {
                        "username": "hotsixredbull",
                        "content": "I\\'m having a hard time to check if there\\'s any case that visiting order matters to find maximum removal. if the case exists, i think i need to search all the paths starting from every stone. Any ideas?"
                    }
                ]
            },
            {
                "id": 1684885,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "Solution is not intuitive at all. "
                    },
                    {
                        "username": "gadmo",
                        "content": "conceptually this is an 'hard' problem. once you understand it - its just a simple dfs."
                    },
                    {
                        "username": "Harshal7565",
                        "content": "How can I get rid of this testcase [[0,1],[1,0]]\n\nMy code - \n `\nclass Solution {    \npublic int removeStones(int[][] stones) {\n        int count = 0;\n        int n = getMaxNumber(stones);\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < stones.length; i++) {\n            graph.get(stones[i][0]).add(stones[i][1]);\n            graph.get(stones[i][1]).add(stones[i][0]);\n        }\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, graph);\n                count++;\n            }\n        }\n        return stones.length - count;\n    }\n\n    public void dfs(int s, boolean[] visited, List<List<Integer>> graph) {\n        Stack<Integer> st = new Stack<>();\n        st.push(s);\n        visited[s] = true;\n        while (!st.isEmpty()) {\n            int u = st.pop();\n            for (int i = 0; i < graph.get(u).size(); i++) {\n                int v = graph.get(u).get(i);\n                if (!visited[v]) {\n                    visited[v] = true;\n                    st.push(v);\n                }\n            }\n        }\n    }\n\n    public static int getMaxNumber(int[][] array) {\n\t    int maxNumber = array[0][0];\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                if (array[i][j] > maxNumber) {\n                maxNumber = array[i][j];\n                }\n            }\n        }\n        return maxNumber + 1;\n    }\n}`"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "If you use union-find, it would be very easy."
                    },
                    {
                        "username": "bryanba",
                        "content": "class Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return self.remove_stones(stones)\\n\\n    def calc_lengths(self,diction):\\n        diction_len = {}\\n        \\n        for key in diction:\\n            diction_len[key] = len(diction[key])\\n        \\n        dic = dict(sorted(diction_len.items(), key=lambda item: item[1]))\\n        return dic\\n\\n\\n    def remove_stones(self,stones):\\n        \\n        stones.sort()\\n        diction = {}\\n        \\n        for i in range(len(stones)):\\n            diction[(stones[i][0],stones[i][1])] = [x for x in stones if((x[0] == stones[i][0] or x[1] == stones[i][1]) and (x != stones[i]))]\\n\\n        res = 0\\n        while(True):\\n            diction_len = self.calc_lengths(diction)\\n            diction_bool = any(x >= 1 for x in diction_len.values()) and len(diction) > 1\\n            if(not diction_bool):\\n                break\\n            mini = list(diction_len.keys())[0]\\n            for key,l in diction.items():\\n                for val in l:\\n                    if(val == list(mini)):\\n                        diction[key].remove(val)\\n            del diction[mini]\\n            if(diction_len[mini] > 0):\\n                res += 1\\n            \\n        return res    \\n\\nWHY ISN\\'T IT WORKING, IT WORKS ON MY IDE HELP PLEASE"
                    },
                    {
                        "username": "connorharris",
                        "content": "Idea for a solution:\\n\\nThink about the problem as a graph problem. Stones are vertices, and edges connect stones on the same row or column.\\n\\nNow think about a more general problem: you have a general graph and and you can remove any vertex that isn\\'t isolated. How many vertices can you remove? It turns out that you can remove every vertex but one from each connected component. One way to do this is to compute a DFS tree for every connected component, and then repeatedly remove leaves from the DFS tree using postorder traversal until you get to one vertex. Since the remaining DFS tree stays connected after you remove a leaf, the component as a whole (which contains all the edges in the DFS tree plus possibly some extra ones) also stays connected, so removing a leaf won\\'t create any isolated vertices until you remove the second-to-last vertex to create a one-vertex graph.\\n\\nSo the answer is just the number of stones in the graph minus the number of connected components, and you can count connected components in a graph in linear time with DFS."
                    },
                    {
                        "username": "user0783WN",
                        "content": "BFS solution:\\n1 create color array to coloring the visited node\\n2 create adjacent list List<List<Integer>> to record all the adjacent node index for each node\\n3 visit each node, if the node is already colored, continue\\n4 BFS search all the adjacent node\\nwhile(!nodeIndexQ.isEmpy()){\\n  int[] currNodeIndex = nodeIndexQ.poll();\\n  for(int index : adjacentNodeIndexList){\\n      if(color[index] is colored){\\n        continue;      \\n     }\\n     color[index] = colored\\n     nodeQ.add(index);\\n }\\n}\\n5 once BFS search is done on current node, total group++;\\n6 once loop is done, return stones.length - total"
                    },
                    {
                        "username": "itsmemo",
                        "content": "I guess this problem\\'s description has been changed but examples and the test cases left untouched. According to the current definition you cannot remove 5 stones for the first example. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "For testcase [[0,1],[1,0]], how is the expected output 0 and not 1?  If we remove either of the stone at 01 or 10, there will only be one stone left. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "[@Minamikaze392](/Minamikaze392) Thanks! Makes sense now. It\\'s my logic that\\'s problem. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "```\\n     |stone\\n-----|-----\\nstone|\\n```\\nThey don\\'t share the same row or column, so you cannot remove one of them."
                    },
                    {
                        "username": "hotsixredbull",
                        "content": "I\\'m having a hard time to check if there\\'s any case that visiting order matters to find maximum removal. if the case exists, i think i need to search all the paths starting from every stone. Any ideas?"
                    }
                ]
            },
            {
                "id": 1684371,
                "content": [
                    {
                        "username": "user3366Sy",
                        "content": "Solution is not intuitive at all. "
                    },
                    {
                        "username": "gadmo",
                        "content": "conceptually this is an 'hard' problem. once you understand it - its just a simple dfs."
                    },
                    {
                        "username": "Harshal7565",
                        "content": "How can I get rid of this testcase [[0,1],[1,0]]\n\nMy code - \n `\nclass Solution {    \npublic int removeStones(int[][] stones) {\n        int count = 0;\n        int n = getMaxNumber(stones);\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < stones.length; i++) {\n            graph.get(stones[i][0]).add(stones[i][1]);\n            graph.get(stones[i][1]).add(stones[i][0]);\n        }\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i, visited, graph);\n                count++;\n            }\n        }\n        return stones.length - count;\n    }\n\n    public void dfs(int s, boolean[] visited, List<List<Integer>> graph) {\n        Stack<Integer> st = new Stack<>();\n        st.push(s);\n        visited[s] = true;\n        while (!st.isEmpty()) {\n            int u = st.pop();\n            for (int i = 0; i < graph.get(u).size(); i++) {\n                int v = graph.get(u).get(i);\n                if (!visited[v]) {\n                    visited[v] = true;\n                    st.push(v);\n                }\n            }\n        }\n    }\n\n    public static int getMaxNumber(int[][] array) {\n\t    int maxNumber = array[0][0];\n        for (int i = 0; i < array.length; i++) {\n            for (int j = 0; j < array[i].length; j++) {\n                if (array[i][j] > maxNumber) {\n                maxNumber = array[i][j];\n                }\n            }\n        }\n        return maxNumber + 1;\n    }\n}`"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "If you use union-find, it would be very easy."
                    },
                    {
                        "username": "bryanba",
                        "content": "class Solution(object):\\n    def removeStones(self, stones):\\n        \"\"\"\\n        :type stones: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return self.remove_stones(stones)\\n\\n    def calc_lengths(self,diction):\\n        diction_len = {}\\n        \\n        for key in diction:\\n            diction_len[key] = len(diction[key])\\n        \\n        dic = dict(sorted(diction_len.items(), key=lambda item: item[1]))\\n        return dic\\n\\n\\n    def remove_stones(self,stones):\\n        \\n        stones.sort()\\n        diction = {}\\n        \\n        for i in range(len(stones)):\\n            diction[(stones[i][0],stones[i][1])] = [x for x in stones if((x[0] == stones[i][0] or x[1] == stones[i][1]) and (x != stones[i]))]\\n\\n        res = 0\\n        while(True):\\n            diction_len = self.calc_lengths(diction)\\n            diction_bool = any(x >= 1 for x in diction_len.values()) and len(diction) > 1\\n            if(not diction_bool):\\n                break\\n            mini = list(diction_len.keys())[0]\\n            for key,l in diction.items():\\n                for val in l:\\n                    if(val == list(mini)):\\n                        diction[key].remove(val)\\n            del diction[mini]\\n            if(diction_len[mini] > 0):\\n                res += 1\\n            \\n        return res    \\n\\nWHY ISN\\'T IT WORKING, IT WORKS ON MY IDE HELP PLEASE"
                    },
                    {
                        "username": "connorharris",
                        "content": "Idea for a solution:\\n\\nThink about the problem as a graph problem. Stones are vertices, and edges connect stones on the same row or column.\\n\\nNow think about a more general problem: you have a general graph and and you can remove any vertex that isn\\'t isolated. How many vertices can you remove? It turns out that you can remove every vertex but one from each connected component. One way to do this is to compute a DFS tree for every connected component, and then repeatedly remove leaves from the DFS tree using postorder traversal until you get to one vertex. Since the remaining DFS tree stays connected after you remove a leaf, the component as a whole (which contains all the edges in the DFS tree plus possibly some extra ones) also stays connected, so removing a leaf won\\'t create any isolated vertices until you remove the second-to-last vertex to create a one-vertex graph.\\n\\nSo the answer is just the number of stones in the graph minus the number of connected components, and you can count connected components in a graph in linear time with DFS."
                    },
                    {
                        "username": "user0783WN",
                        "content": "BFS solution:\\n1 create color array to coloring the visited node\\n2 create adjacent list List<List<Integer>> to record all the adjacent node index for each node\\n3 visit each node, if the node is already colored, continue\\n4 BFS search all the adjacent node\\nwhile(!nodeIndexQ.isEmpy()){\\n  int[] currNodeIndex = nodeIndexQ.poll();\\n  for(int index : adjacentNodeIndexList){\\n      if(color[index] is colored){\\n        continue;      \\n     }\\n     color[index] = colored\\n     nodeQ.add(index);\\n }\\n}\\n5 once BFS search is done on current node, total group++;\\n6 once loop is done, return stones.length - total"
                    },
                    {
                        "username": "itsmemo",
                        "content": "I guess this problem\\'s description has been changed but examples and the test cases left untouched. According to the current definition you cannot remove 5 stones for the first example. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "For testcase [[0,1],[1,0]], how is the expected output 0 and not 1?  If we remove either of the stone at 01 or 10, there will only be one stone left. "
                    },
                    {
                        "username": "MansiDhruv",
                        "content": "[@Minamikaze392](/Minamikaze392) Thanks! Makes sense now. It\\'s my logic that\\'s problem. "
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "```\\n     |stone\\n-----|-----\\nstone|\\n```\\nThey don\\'t share the same row or column, so you cannot remove one of them."
                    },
                    {
                        "username": "hotsixredbull",
                        "content": "I\\'m having a hard time to check if there\\'s any case that visiting order matters to find maximum removal. if the case exists, i think i need to search all the paths starting from every stone. Any ideas?"
                    }
                ]
            },
            {
                "id": 1684330,
                "content": [
                    {
                        "username": "rsaxena123",
                        "content": "Why is the answer the number of stones minus the number of connected components?\\n\\nFor example say you have stones x1-x6.\\nif there are two groups of connected components [x1-x4], [x5-6] n - # of groups (6-2) is 4 but you could remove 3 stones from the first group\\n\\nhowever if the connected components are [x1-x5], [x6] n - # of groups is still 4 but you could remove 4 stones from the first group. \\n\\nCan someone provide examples why this holds true?"
                    },
                    {
                        "username": "SajalGupta",
                        "content": "Similar to count islands --- \\nIn this problem --- stones that have same row or col can consider in an islands\\nso, no. of islands == stones that can\\'t be removed\\nResult = total stones - no. of  stones that can\\'t removed = no. of stones that can removed"
                    },
                    {
                        "username": "TheSeer507",
                        "content": "Hard question to be honest, but this one provides lots of essential tools to tackle more complicated questions and also most of real case scenarios you will come across. Try solving it with DFS method and then try with Union as is the most efficient one. Hope it helps."
                    },
                    {
                        "username": "tumzied",
                        "content": "stones = [[0,1],[1,0],[1,1]]\\nexpectd 2\\nshouldn\\'t the expected be 1?\\nonly stone coordinate [1,1] should be remove?\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "This question want to return the `largest possible number` of stones that can be removed.\\nIf you remove stones [0,1] or [1,0] not [1,1],\\nthen you can remove another one.\\nSo, it will be 2."
                    },
                    {
                        "username": "aditi1602",
                        "content": "Can\\'t get the question. Please help."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint : n - (count of connected components)... \\n```\\n vis[i] = 1;\\nfor(int idx = 0; idx < n; idx++) {\\n     if(!vis[idx] && check(stones[i], stones[idx])) {\\n     dfs(stones, idx);\\n  }\\n}\\n    \\n\\n```"
                    },
                    {
                        "username": "Indra_22",
                        "content": "which data structure we have to apply in this question "
                    },
                    {
                        "username": "sparklingness",
                        "content": "You can use a graph.. union-find."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This connected components notion is new to me, any recommendations about some resources where I/ others could learn more on these topics?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@sparklingness](/sparklingness) thanks!"
                    },
                    {
                        "username": "sparklingness",
                        "content": "If you check this leetcode topic card(Graph -> Disjoint set),\\nyou will get an idea!\\nhttps://leetcode.com/explore/learn/card/graph/618/disjoint-set/\\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "For the input \\nstones =\\n[[0,1],[0,2],[4,3],[2,4],[0,3],[1,1]]\\nexpected 4\\nshouldn\\'t the expected be 3? as at max we can remove 3 like [0,1],[0,2],[0,3]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1.\\nSo, It will be 4."
                    },
                    {
                        "username": "ixabhay",
                        "content": "Chotto matte!\nstones = [[0,1],[1,0],[1,1]]\nOutput: 1\nExpected: 2\nHow come?\nIf anyone else comes across it,\nthe order by which stone are removed is not necessarily right to left. Nice one.\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "At max you can remove 2, which are [0,1] as for this [1,1] is the conflicting and [1,0] as for this also [1,1] is conflicting.\\nWe need to remove maximum number of stones to avoid conflicts.\\nSo minimum is 1 which is by removing [1,1] and maximum is 2"
                    }
                ]
            },
            {
                "id": 1684306,
                "content": [
                    {
                        "username": "rsaxena123",
                        "content": "Why is the answer the number of stones minus the number of connected components?\\n\\nFor example say you have stones x1-x6.\\nif there are two groups of connected components [x1-x4], [x5-6] n - # of groups (6-2) is 4 but you could remove 3 stones from the first group\\n\\nhowever if the connected components are [x1-x5], [x6] n - # of groups is still 4 but you could remove 4 stones from the first group. \\n\\nCan someone provide examples why this holds true?"
                    },
                    {
                        "username": "SajalGupta",
                        "content": "Similar to count islands --- \\nIn this problem --- stones that have same row or col can consider in an islands\\nso, no. of islands == stones that can\\'t be removed\\nResult = total stones - no. of  stones that can\\'t removed = no. of stones that can removed"
                    },
                    {
                        "username": "TheSeer507",
                        "content": "Hard question to be honest, but this one provides lots of essential tools to tackle more complicated questions and also most of real case scenarios you will come across. Try solving it with DFS method and then try with Union as is the most efficient one. Hope it helps."
                    },
                    {
                        "username": "tumzied",
                        "content": "stones = [[0,1],[1,0],[1,1]]\\nexpectd 2\\nshouldn\\'t the expected be 1?\\nonly stone coordinate [1,1] should be remove?\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "This question want to return the `largest possible number` of stones that can be removed.\\nIf you remove stones [0,1] or [1,0] not [1,1],\\nthen you can remove another one.\\nSo, it will be 2."
                    },
                    {
                        "username": "aditi1602",
                        "content": "Can\\'t get the question. Please help."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint : n - (count of connected components)... \\n```\\n vis[i] = 1;\\nfor(int idx = 0; idx < n; idx++) {\\n     if(!vis[idx] && check(stones[i], stones[idx])) {\\n     dfs(stones, idx);\\n  }\\n}\\n    \\n\\n```"
                    },
                    {
                        "username": "Indra_22",
                        "content": "which data structure we have to apply in this question "
                    },
                    {
                        "username": "sparklingness",
                        "content": "You can use a graph.. union-find."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This connected components notion is new to me, any recommendations about some resources where I/ others could learn more on these topics?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@sparklingness](/sparklingness) thanks!"
                    },
                    {
                        "username": "sparklingness",
                        "content": "If you check this leetcode topic card(Graph -> Disjoint set),\\nyou will get an idea!\\nhttps://leetcode.com/explore/learn/card/graph/618/disjoint-set/\\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "For the input \\nstones =\\n[[0,1],[0,2],[4,3],[2,4],[0,3],[1,1]]\\nexpected 4\\nshouldn\\'t the expected be 3? as at max we can remove 3 like [0,1],[0,2],[0,3]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1.\\nSo, It will be 4."
                    },
                    {
                        "username": "ixabhay",
                        "content": "Chotto matte!\nstones = [[0,1],[1,0],[1,1]]\nOutput: 1\nExpected: 2\nHow come?\nIf anyone else comes across it,\nthe order by which stone are removed is not necessarily right to left. Nice one.\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "At max you can remove 2, which are [0,1] as for this [1,1] is the conflicting and [1,0] as for this also [1,1] is conflicting.\\nWe need to remove maximum number of stones to avoid conflicts.\\nSo minimum is 1 which is by removing [1,1] and maximum is 2"
                    }
                ]
            },
            {
                "id": 1684237,
                "content": [
                    {
                        "username": "rsaxena123",
                        "content": "Why is the answer the number of stones minus the number of connected components?\\n\\nFor example say you have stones x1-x6.\\nif there are two groups of connected components [x1-x4], [x5-6] n - # of groups (6-2) is 4 but you could remove 3 stones from the first group\\n\\nhowever if the connected components are [x1-x5], [x6] n - # of groups is still 4 but you could remove 4 stones from the first group. \\n\\nCan someone provide examples why this holds true?"
                    },
                    {
                        "username": "SajalGupta",
                        "content": "Similar to count islands --- \\nIn this problem --- stones that have same row or col can consider in an islands\\nso, no. of islands == stones that can\\'t be removed\\nResult = total stones - no. of  stones that can\\'t removed = no. of stones that can removed"
                    },
                    {
                        "username": "TheSeer507",
                        "content": "Hard question to be honest, but this one provides lots of essential tools to tackle more complicated questions and also most of real case scenarios you will come across. Try solving it with DFS method and then try with Union as is the most efficient one. Hope it helps."
                    },
                    {
                        "username": "tumzied",
                        "content": "stones = [[0,1],[1,0],[1,1]]\\nexpectd 2\\nshouldn\\'t the expected be 1?\\nonly stone coordinate [1,1] should be remove?\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "This question want to return the `largest possible number` of stones that can be removed.\\nIf you remove stones [0,1] or [1,0] not [1,1],\\nthen you can remove another one.\\nSo, it will be 2."
                    },
                    {
                        "username": "aditi1602",
                        "content": "Can\\'t get the question. Please help."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint : n - (count of connected components)... \\n```\\n vis[i] = 1;\\nfor(int idx = 0; idx < n; idx++) {\\n     if(!vis[idx] && check(stones[i], stones[idx])) {\\n     dfs(stones, idx);\\n  }\\n}\\n    \\n\\n```"
                    },
                    {
                        "username": "Indra_22",
                        "content": "which data structure we have to apply in this question "
                    },
                    {
                        "username": "sparklingness",
                        "content": "You can use a graph.. union-find."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This connected components notion is new to me, any recommendations about some resources where I/ others could learn more on these topics?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@sparklingness](/sparklingness) thanks!"
                    },
                    {
                        "username": "sparklingness",
                        "content": "If you check this leetcode topic card(Graph -> Disjoint set),\\nyou will get an idea!\\nhttps://leetcode.com/explore/learn/card/graph/618/disjoint-set/\\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "For the input \\nstones =\\n[[0,1],[0,2],[4,3],[2,4],[0,3],[1,1]]\\nexpected 4\\nshouldn\\'t the expected be 3? as at max we can remove 3 like [0,1],[0,2],[0,3]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1.\\nSo, It will be 4."
                    },
                    {
                        "username": "ixabhay",
                        "content": "Chotto matte!\nstones = [[0,1],[1,0],[1,1]]\nOutput: 1\nExpected: 2\nHow come?\nIf anyone else comes across it,\nthe order by which stone are removed is not necessarily right to left. Nice one.\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "At max you can remove 2, which are [0,1] as for this [1,1] is the conflicting and [1,0] as for this also [1,1] is conflicting.\\nWe need to remove maximum number of stones to avoid conflicts.\\nSo minimum is 1 which is by removing [1,1] and maximum is 2"
                    }
                ]
            },
            {
                "id": 1684070,
                "content": [
                    {
                        "username": "rsaxena123",
                        "content": "Why is the answer the number of stones minus the number of connected components?\\n\\nFor example say you have stones x1-x6.\\nif there are two groups of connected components [x1-x4], [x5-6] n - # of groups (6-2) is 4 but you could remove 3 stones from the first group\\n\\nhowever if the connected components are [x1-x5], [x6] n - # of groups is still 4 but you could remove 4 stones from the first group. \\n\\nCan someone provide examples why this holds true?"
                    },
                    {
                        "username": "SajalGupta",
                        "content": "Similar to count islands --- \\nIn this problem --- stones that have same row or col can consider in an islands\\nso, no. of islands == stones that can\\'t be removed\\nResult = total stones - no. of  stones that can\\'t removed = no. of stones that can removed"
                    },
                    {
                        "username": "TheSeer507",
                        "content": "Hard question to be honest, but this one provides lots of essential tools to tackle more complicated questions and also most of real case scenarios you will come across. Try solving it with DFS method and then try with Union as is the most efficient one. Hope it helps."
                    },
                    {
                        "username": "tumzied",
                        "content": "stones = [[0,1],[1,0],[1,1]]\\nexpectd 2\\nshouldn\\'t the expected be 1?\\nonly stone coordinate [1,1] should be remove?\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "This question want to return the `largest possible number` of stones that can be removed.\\nIf you remove stones [0,1] or [1,0] not [1,1],\\nthen you can remove another one.\\nSo, it will be 2."
                    },
                    {
                        "username": "aditi1602",
                        "content": "Can\\'t get the question. Please help."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint : n - (count of connected components)... \\n```\\n vis[i] = 1;\\nfor(int idx = 0; idx < n; idx++) {\\n     if(!vis[idx] && check(stones[i], stones[idx])) {\\n     dfs(stones, idx);\\n  }\\n}\\n    \\n\\n```"
                    },
                    {
                        "username": "Indra_22",
                        "content": "which data structure we have to apply in this question "
                    },
                    {
                        "username": "sparklingness",
                        "content": "You can use a graph.. union-find."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This connected components notion is new to me, any recommendations about some resources where I/ others could learn more on these topics?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@sparklingness](/sparklingness) thanks!"
                    },
                    {
                        "username": "sparklingness",
                        "content": "If you check this leetcode topic card(Graph -> Disjoint set),\\nyou will get an idea!\\nhttps://leetcode.com/explore/learn/card/graph/618/disjoint-set/\\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "For the input \\nstones =\\n[[0,1],[0,2],[4,3],[2,4],[0,3],[1,1]]\\nexpected 4\\nshouldn\\'t the expected be 3? as at max we can remove 3 like [0,1],[0,2],[0,3]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1.\\nSo, It will be 4."
                    },
                    {
                        "username": "ixabhay",
                        "content": "Chotto matte!\nstones = [[0,1],[1,0],[1,1]]\nOutput: 1\nExpected: 2\nHow come?\nIf anyone else comes across it,\nthe order by which stone are removed is not necessarily right to left. Nice one.\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "At max you can remove 2, which are [0,1] as for this [1,1] is the conflicting and [1,0] as for this also [1,1] is conflicting.\\nWe need to remove maximum number of stones to avoid conflicts.\\nSo minimum is 1 which is by removing [1,1] and maximum is 2"
                    }
                ]
            },
            {
                "id": 1683958,
                "content": [
                    {
                        "username": "rsaxena123",
                        "content": "Why is the answer the number of stones minus the number of connected components?\\n\\nFor example say you have stones x1-x6.\\nif there are two groups of connected components [x1-x4], [x5-6] n - # of groups (6-2) is 4 but you could remove 3 stones from the first group\\n\\nhowever if the connected components are [x1-x5], [x6] n - # of groups is still 4 but you could remove 4 stones from the first group. \\n\\nCan someone provide examples why this holds true?"
                    },
                    {
                        "username": "SajalGupta",
                        "content": "Similar to count islands --- \\nIn this problem --- stones that have same row or col can consider in an islands\\nso, no. of islands == stones that can\\'t be removed\\nResult = total stones - no. of  stones that can\\'t removed = no. of stones that can removed"
                    },
                    {
                        "username": "TheSeer507",
                        "content": "Hard question to be honest, but this one provides lots of essential tools to tackle more complicated questions and also most of real case scenarios you will come across. Try solving it with DFS method and then try with Union as is the most efficient one. Hope it helps."
                    },
                    {
                        "username": "tumzied",
                        "content": "stones = [[0,1],[1,0],[1,1]]\\nexpectd 2\\nshouldn\\'t the expected be 1?\\nonly stone coordinate [1,1] should be remove?\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "This question want to return the `largest possible number` of stones that can be removed.\\nIf you remove stones [0,1] or [1,0] not [1,1],\\nthen you can remove another one.\\nSo, it will be 2."
                    },
                    {
                        "username": "aditi1602",
                        "content": "Can\\'t get the question. Please help."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint : n - (count of connected components)... \\n```\\n vis[i] = 1;\\nfor(int idx = 0; idx < n; idx++) {\\n     if(!vis[idx] && check(stones[i], stones[idx])) {\\n     dfs(stones, idx);\\n  }\\n}\\n    \\n\\n```"
                    },
                    {
                        "username": "Indra_22",
                        "content": "which data structure we have to apply in this question "
                    },
                    {
                        "username": "sparklingness",
                        "content": "You can use a graph.. union-find."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This connected components notion is new to me, any recommendations about some resources where I/ others could learn more on these topics?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@sparklingness](/sparklingness) thanks!"
                    },
                    {
                        "username": "sparklingness",
                        "content": "If you check this leetcode topic card(Graph -> Disjoint set),\\nyou will get an idea!\\nhttps://leetcode.com/explore/learn/card/graph/618/disjoint-set/\\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "For the input \\nstones =\\n[[0,1],[0,2],[4,3],[2,4],[0,3],[1,1]]\\nexpected 4\\nshouldn\\'t the expected be 3? as at max we can remove 3 like [0,1],[0,2],[0,3]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1.\\nSo, It will be 4."
                    },
                    {
                        "username": "ixabhay",
                        "content": "Chotto matte!\nstones = [[0,1],[1,0],[1,1]]\nOutput: 1\nExpected: 2\nHow come?\nIf anyone else comes across it,\nthe order by which stone are removed is not necessarily right to left. Nice one.\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "At max you can remove 2, which are [0,1] as for this [1,1] is the conflicting and [1,0] as for this also [1,1] is conflicting.\\nWe need to remove maximum number of stones to avoid conflicts.\\nSo minimum is 1 which is by removing [1,1] and maximum is 2"
                    }
                ]
            },
            {
                "id": 1683804,
                "content": [
                    {
                        "username": "rsaxena123",
                        "content": "Why is the answer the number of stones minus the number of connected components?\\n\\nFor example say you have stones x1-x6.\\nif there are two groups of connected components [x1-x4], [x5-6] n - # of groups (6-2) is 4 but you could remove 3 stones from the first group\\n\\nhowever if the connected components are [x1-x5], [x6] n - # of groups is still 4 but you could remove 4 stones from the first group. \\n\\nCan someone provide examples why this holds true?"
                    },
                    {
                        "username": "SajalGupta",
                        "content": "Similar to count islands --- \\nIn this problem --- stones that have same row or col can consider in an islands\\nso, no. of islands == stones that can\\'t be removed\\nResult = total stones - no. of  stones that can\\'t removed = no. of stones that can removed"
                    },
                    {
                        "username": "TheSeer507",
                        "content": "Hard question to be honest, but this one provides lots of essential tools to tackle more complicated questions and also most of real case scenarios you will come across. Try solving it with DFS method and then try with Union as is the most efficient one. Hope it helps."
                    },
                    {
                        "username": "tumzied",
                        "content": "stones = [[0,1],[1,0],[1,1]]\\nexpectd 2\\nshouldn\\'t the expected be 1?\\nonly stone coordinate [1,1] should be remove?\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "This question want to return the `largest possible number` of stones that can be removed.\\nIf you remove stones [0,1] or [1,0] not [1,1],\\nthen you can remove another one.\\nSo, it will be 2."
                    },
                    {
                        "username": "aditi1602",
                        "content": "Can\\'t get the question. Please help."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint : n - (count of connected components)... \\n```\\n vis[i] = 1;\\nfor(int idx = 0; idx < n; idx++) {\\n     if(!vis[idx] && check(stones[i], stones[idx])) {\\n     dfs(stones, idx);\\n  }\\n}\\n    \\n\\n```"
                    },
                    {
                        "username": "Indra_22",
                        "content": "which data structure we have to apply in this question "
                    },
                    {
                        "username": "sparklingness",
                        "content": "You can use a graph.. union-find."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This connected components notion is new to me, any recommendations about some resources where I/ others could learn more on these topics?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@sparklingness](/sparklingness) thanks!"
                    },
                    {
                        "username": "sparklingness",
                        "content": "If you check this leetcode topic card(Graph -> Disjoint set),\\nyou will get an idea!\\nhttps://leetcode.com/explore/learn/card/graph/618/disjoint-set/\\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "For the input \\nstones =\\n[[0,1],[0,2],[4,3],[2,4],[0,3],[1,1]]\\nexpected 4\\nshouldn\\'t the expected be 3? as at max we can remove 3 like [0,1],[0,2],[0,3]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1.\\nSo, It will be 4."
                    },
                    {
                        "username": "ixabhay",
                        "content": "Chotto matte!\nstones = [[0,1],[1,0],[1,1]]\nOutput: 1\nExpected: 2\nHow come?\nIf anyone else comes across it,\nthe order by which stone are removed is not necessarily right to left. Nice one.\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "At max you can remove 2, which are [0,1] as for this [1,1] is the conflicting and [1,0] as for this also [1,1] is conflicting.\\nWe need to remove maximum number of stones to avoid conflicts.\\nSo minimum is 1 which is by removing [1,1] and maximum is 2"
                    }
                ]
            },
            {
                "id": 1683790,
                "content": [
                    {
                        "username": "rsaxena123",
                        "content": "Why is the answer the number of stones minus the number of connected components?\\n\\nFor example say you have stones x1-x6.\\nif there are two groups of connected components [x1-x4], [x5-6] n - # of groups (6-2) is 4 but you could remove 3 stones from the first group\\n\\nhowever if the connected components are [x1-x5], [x6] n - # of groups is still 4 but you could remove 4 stones from the first group. \\n\\nCan someone provide examples why this holds true?"
                    },
                    {
                        "username": "SajalGupta",
                        "content": "Similar to count islands --- \\nIn this problem --- stones that have same row or col can consider in an islands\\nso, no. of islands == stones that can\\'t be removed\\nResult = total stones - no. of  stones that can\\'t removed = no. of stones that can removed"
                    },
                    {
                        "username": "TheSeer507",
                        "content": "Hard question to be honest, but this one provides lots of essential tools to tackle more complicated questions and also most of real case scenarios you will come across. Try solving it with DFS method and then try with Union as is the most efficient one. Hope it helps."
                    },
                    {
                        "username": "tumzied",
                        "content": "stones = [[0,1],[1,0],[1,1]]\\nexpectd 2\\nshouldn\\'t the expected be 1?\\nonly stone coordinate [1,1] should be remove?\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "This question want to return the `largest possible number` of stones that can be removed.\\nIf you remove stones [0,1] or [1,0] not [1,1],\\nthen you can remove another one.\\nSo, it will be 2."
                    },
                    {
                        "username": "aditi1602",
                        "content": "Can\\'t get the question. Please help."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint : n - (count of connected components)... \\n```\\n vis[i] = 1;\\nfor(int idx = 0; idx < n; idx++) {\\n     if(!vis[idx] && check(stones[i], stones[idx])) {\\n     dfs(stones, idx);\\n  }\\n}\\n    \\n\\n```"
                    },
                    {
                        "username": "Indra_22",
                        "content": "which data structure we have to apply in this question "
                    },
                    {
                        "username": "sparklingness",
                        "content": "You can use a graph.. union-find."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This connected components notion is new to me, any recommendations about some resources where I/ others could learn more on these topics?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@sparklingness](/sparklingness) thanks!"
                    },
                    {
                        "username": "sparklingness",
                        "content": "If you check this leetcode topic card(Graph -> Disjoint set),\\nyou will get an idea!\\nhttps://leetcode.com/explore/learn/card/graph/618/disjoint-set/\\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "For the input \\nstones =\\n[[0,1],[0,2],[4,3],[2,4],[0,3],[1,1]]\\nexpected 4\\nshouldn\\'t the expected be 3? as at max we can remove 3 like [0,1],[0,2],[0,3]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1.\\nSo, It will be 4."
                    },
                    {
                        "username": "ixabhay",
                        "content": "Chotto matte!\nstones = [[0,1],[1,0],[1,1]]\nOutput: 1\nExpected: 2\nHow come?\nIf anyone else comes across it,\nthe order by which stone are removed is not necessarily right to left. Nice one.\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "At max you can remove 2, which are [0,1] as for this [1,1] is the conflicting and [1,0] as for this also [1,1] is conflicting.\\nWe need to remove maximum number of stones to avoid conflicts.\\nSo minimum is 1 which is by removing [1,1] and maximum is 2"
                    }
                ]
            },
            {
                "id": 1683779,
                "content": [
                    {
                        "username": "rsaxena123",
                        "content": "Why is the answer the number of stones minus the number of connected components?\\n\\nFor example say you have stones x1-x6.\\nif there are two groups of connected components [x1-x4], [x5-6] n - # of groups (6-2) is 4 but you could remove 3 stones from the first group\\n\\nhowever if the connected components are [x1-x5], [x6] n - # of groups is still 4 but you could remove 4 stones from the first group. \\n\\nCan someone provide examples why this holds true?"
                    },
                    {
                        "username": "SajalGupta",
                        "content": "Similar to count islands --- \\nIn this problem --- stones that have same row or col can consider in an islands\\nso, no. of islands == stones that can\\'t be removed\\nResult = total stones - no. of  stones that can\\'t removed = no. of stones that can removed"
                    },
                    {
                        "username": "TheSeer507",
                        "content": "Hard question to be honest, but this one provides lots of essential tools to tackle more complicated questions and also most of real case scenarios you will come across. Try solving it with DFS method and then try with Union as is the most efficient one. Hope it helps."
                    },
                    {
                        "username": "tumzied",
                        "content": "stones = [[0,1],[1,0],[1,1]]\\nexpectd 2\\nshouldn\\'t the expected be 1?\\nonly stone coordinate [1,1] should be remove?\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "This question want to return the `largest possible number` of stones that can be removed.\\nIf you remove stones [0,1] or [1,0] not [1,1],\\nthen you can remove another one.\\nSo, it will be 2."
                    },
                    {
                        "username": "aditi1602",
                        "content": "Can\\'t get the question. Please help."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint : n - (count of connected components)... \\n```\\n vis[i] = 1;\\nfor(int idx = 0; idx < n; idx++) {\\n     if(!vis[idx] && check(stones[i], stones[idx])) {\\n     dfs(stones, idx);\\n  }\\n}\\n    \\n\\n```"
                    },
                    {
                        "username": "Indra_22",
                        "content": "which data structure we have to apply in this question "
                    },
                    {
                        "username": "sparklingness",
                        "content": "You can use a graph.. union-find."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This connected components notion is new to me, any recommendations about some resources where I/ others could learn more on these topics?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@sparklingness](/sparklingness) thanks!"
                    },
                    {
                        "username": "sparklingness",
                        "content": "If you check this leetcode topic card(Graph -> Disjoint set),\\nyou will get an idea!\\nhttps://leetcode.com/explore/learn/card/graph/618/disjoint-set/\\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "For the input \\nstones =\\n[[0,1],[0,2],[4,3],[2,4],[0,3],[1,1]]\\nexpected 4\\nshouldn\\'t the expected be 3? as at max we can remove 3 like [0,1],[0,2],[0,3]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1.\\nSo, It will be 4."
                    },
                    {
                        "username": "ixabhay",
                        "content": "Chotto matte!\nstones = [[0,1],[1,0],[1,1]]\nOutput: 1\nExpected: 2\nHow come?\nIf anyone else comes across it,\nthe order by which stone are removed is not necessarily right to left. Nice one.\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "At max you can remove 2, which are [0,1] as for this [1,1] is the conflicting and [1,0] as for this also [1,1] is conflicting.\\nWe need to remove maximum number of stones to avoid conflicts.\\nSo minimum is 1 which is by removing [1,1] and maximum is 2"
                    }
                ]
            },
            {
                "id": 1683691,
                "content": [
                    {
                        "username": "rsaxena123",
                        "content": "Why is the answer the number of stones minus the number of connected components?\\n\\nFor example say you have stones x1-x6.\\nif there are two groups of connected components [x1-x4], [x5-6] n - # of groups (6-2) is 4 but you could remove 3 stones from the first group\\n\\nhowever if the connected components are [x1-x5], [x6] n - # of groups is still 4 but you could remove 4 stones from the first group. \\n\\nCan someone provide examples why this holds true?"
                    },
                    {
                        "username": "SajalGupta",
                        "content": "Similar to count islands --- \\nIn this problem --- stones that have same row or col can consider in an islands\\nso, no. of islands == stones that can\\'t be removed\\nResult = total stones - no. of  stones that can\\'t removed = no. of stones that can removed"
                    },
                    {
                        "username": "TheSeer507",
                        "content": "Hard question to be honest, but this one provides lots of essential tools to tackle more complicated questions and also most of real case scenarios you will come across. Try solving it with DFS method and then try with Union as is the most efficient one. Hope it helps."
                    },
                    {
                        "username": "tumzied",
                        "content": "stones = [[0,1],[1,0],[1,1]]\\nexpectd 2\\nshouldn\\'t the expected be 1?\\nonly stone coordinate [1,1] should be remove?\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "This question want to return the `largest possible number` of stones that can be removed.\\nIf you remove stones [0,1] or [1,0] not [1,1],\\nthen you can remove another one.\\nSo, it will be 2."
                    },
                    {
                        "username": "aditi1602",
                        "content": "Can\\'t get the question. Please help."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint : n - (count of connected components)... \\n```\\n vis[i] = 1;\\nfor(int idx = 0; idx < n; idx++) {\\n     if(!vis[idx] && check(stones[i], stones[idx])) {\\n     dfs(stones, idx);\\n  }\\n}\\n    \\n\\n```"
                    },
                    {
                        "username": "Indra_22",
                        "content": "which data structure we have to apply in this question "
                    },
                    {
                        "username": "sparklingness",
                        "content": "You can use a graph.. union-find."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This connected components notion is new to me, any recommendations about some resources where I/ others could learn more on these topics?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@sparklingness](/sparklingness) thanks!"
                    },
                    {
                        "username": "sparklingness",
                        "content": "If you check this leetcode topic card(Graph -> Disjoint set),\\nyou will get an idea!\\nhttps://leetcode.com/explore/learn/card/graph/618/disjoint-set/\\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "For the input \\nstones =\\n[[0,1],[0,2],[4,3],[2,4],[0,3],[1,1]]\\nexpected 4\\nshouldn\\'t the expected be 3? as at max we can remove 3 like [0,1],[0,2],[0,3]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1.\\nSo, It will be 4."
                    },
                    {
                        "username": "ixabhay",
                        "content": "Chotto matte!\nstones = [[0,1],[1,0],[1,1]]\nOutput: 1\nExpected: 2\nHow come?\nIf anyone else comes across it,\nthe order by which stone are removed is not necessarily right to left. Nice one.\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "At max you can remove 2, which are [0,1] as for this [1,1] is the conflicting and [1,0] as for this also [1,1] is conflicting.\\nWe need to remove maximum number of stones to avoid conflicts.\\nSo minimum is 1 which is by removing [1,1] and maximum is 2"
                    }
                ]
            },
            {
                "id": 1683647,
                "content": [
                    {
                        "username": "rsaxena123",
                        "content": "Why is the answer the number of stones minus the number of connected components?\\n\\nFor example say you have stones x1-x6.\\nif there are two groups of connected components [x1-x4], [x5-6] n - # of groups (6-2) is 4 but you could remove 3 stones from the first group\\n\\nhowever if the connected components are [x1-x5], [x6] n - # of groups is still 4 but you could remove 4 stones from the first group. \\n\\nCan someone provide examples why this holds true?"
                    },
                    {
                        "username": "SajalGupta",
                        "content": "Similar to count islands --- \\nIn this problem --- stones that have same row or col can consider in an islands\\nso, no. of islands == stones that can\\'t be removed\\nResult = total stones - no. of  stones that can\\'t removed = no. of stones that can removed"
                    },
                    {
                        "username": "TheSeer507",
                        "content": "Hard question to be honest, but this one provides lots of essential tools to tackle more complicated questions and also most of real case scenarios you will come across. Try solving it with DFS method and then try with Union as is the most efficient one. Hope it helps."
                    },
                    {
                        "username": "tumzied",
                        "content": "stones = [[0,1],[1,0],[1,1]]\\nexpectd 2\\nshouldn\\'t the expected be 1?\\nonly stone coordinate [1,1] should be remove?\\n"
                    },
                    {
                        "username": "sparklingness",
                        "content": "This question want to return the `largest possible number` of stones that can be removed.\\nIf you remove stones [0,1] or [1,0] not [1,1],\\nthen you can remove another one.\\nSo, it will be 2."
                    },
                    {
                        "username": "aditi1602",
                        "content": "Can\\'t get the question. Please help."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Hint : n - (count of connected components)... \\n```\\n vis[i] = 1;\\nfor(int idx = 0; idx < n; idx++) {\\n     if(!vis[idx] && check(stones[i], stones[idx])) {\\n     dfs(stones, idx);\\n  }\\n}\\n    \\n\\n```"
                    },
                    {
                        "username": "Indra_22",
                        "content": "which data structure we have to apply in this question "
                    },
                    {
                        "username": "sparklingness",
                        "content": "You can use a graph.. union-find."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This connected components notion is new to me, any recommendations about some resources where I/ others could learn more on these topics?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@sparklingness](/sparklingness) thanks!"
                    },
                    {
                        "username": "sparklingness",
                        "content": "If you check this leetcode topic card(Graph -> Disjoint set),\\nyou will get an idea!\\nhttps://leetcode.com/explore/learn/card/graph/618/disjoint-set/\\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "For the input \\nstones =\\n[[0,1],[0,2],[4,3],[2,4],[0,3],[1,1]]\\nexpected 4\\nshouldn\\'t the expected be 3? as at max we can remove 3 like [0,1],[0,2],[0,3]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "The first component will be [3,2],[3,1],[1,1],[0,2] --> we can remove. 3.\\nThe second component will be [4,4],[4,0] --> we can remove 1.\\nSo, It will be 4."
                    },
                    {
                        "username": "ixabhay",
                        "content": "Chotto matte!\nstones = [[0,1],[1,0],[1,1]]\nOutput: 1\nExpected: 2\nHow come?\nIf anyone else comes across it,\nthe order by which stone are removed is not necessarily right to left. Nice one.\n"
                    },
                    {
                        "username": "Rishabh_1936",
                        "content": "At max you can remove 2, which are [0,1] as for this [1,1] is the conflicting and [1,0] as for this also [1,1] is conflicting.\\nWe need to remove maximum number of stones to avoid conflicts.\\nSo minimum is 1 which is by removing [1,1] and maximum is 2"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Distance Value Between Two Arrays",
        "question_content": "<p>Given two integer arrays <code>arr1</code> and <code>arr2</code>, and the integer <code>d</code>, <em>return the distance value between the two arrays</em>.</p>\n\n<p>The distance value is defined as the number of elements <code>arr1[i]</code> such that there is not any element <code>arr2[j]</code> where <code>|arr1[i]-arr2[j]| &lt;= d</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> \nFor arr1[0]=4 we have: \n|4-10|=6 &gt; d=2 \n|4-9|=5 &gt; d=2 \n|4-1|=3 &gt; d=2 \n|4-8|=4 &gt; d=2 \nFor arr1[1]=5 we have: \n|5-10|=5 &gt; d=2 \n|5-9|=4 &gt; d=2 \n|5-1|=4 &gt; d=2 \n|5-8|=3 &gt; d=2\nFor arr1[2]=8 we have:\n<strong>|8-10|=2 &lt;= d=2</strong>\n<strong>|8-9|=1 &lt;= d=2</strong>\n|8-1|=7 &gt; d=2\n<strong>|8-8|=0 &lt;= d=2</strong>\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3\n<strong>Output:</strong> 2\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr1.length, arr2.length &lt;= 500</code></li>\n\t<li><code>-1000 &lt;= arr1[i], arr2[j] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= d &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1913945,
                "title": "problem-description-explained-in-simple-english",
                "content": "This question statement is so bad... It sounds like we are returning some distance value but we are not... \\n\\nWe are returning the number of elements in arr1 where all of its distances are MORE THAN than d. \\n\\n```\\nThe distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\\n```\\n\\nTranslation:\\n**Calculate the distance between arr1[i] and arr2[j] and find the number of elements in arr1 where it\\'s distances are NOT LESS THAN or EQUAL TO d.**\\n\\nExample:\\nInput: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2\\n\\nFor arr1[0] = 4 we have: \\n| 4 - 10 | = 6 > d=2 \\n| 4 - 9 | = 5 > d=2 \\n| 4 - 1 | = 3 > d=2 \\n| 4 - 8 | = 4 > d=2 \\n**This is valid because all distances are MORE THAN d**\\n\\nFor arr1[2] = 8 we have:\\n**| 8 - 10 | = 2 <= d=2** <-- This is INVALID. You can just stop here. \\n**| 8 - 9 | = 1 <= d=2**\\n| 8 - 1  |=7 > d=2\\n**| 8 - 8 | = 0 <= d=2**\\n**This is INVALID because there is at least 1 distance that is LESS THAN or EQUAL TO d**\\n\\nAnother Example:\\n\\n![image](https://assets.leetcode.com/users/images/07de6aeb-e720-431b-854c-2f633be5219e_1649212001.5952659.png)\\n",
                "solutionTags": [],
                "code": "```\\nThe distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 609472,
                "title": "java-binary-search-with-explanation",
                "content": "Expression ```|arr1[i] - arr2[j]| <= d``` equals to ```arr1[i] - d <= arr2[j] <= arr1[i] + d```. So for every value ```val``` in the array ```arr1``` we need to check (using binary search) if the array ```arr2``` contains any value in range from ```val - d``` to ```val + d```. If **not**, increment distance.\\n\\n```\\nclass Solution {\\n\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);    \\n        int distance = 0;\\n        \\n        for (int val : arr1) {\\n            if (notInRange(arr2, val - d, val + d)) {\\n                distance++;\\n            }\\n        }    \\n        \\n        return distance;\\n    }\\n    \\n    // Checks if the array doesn\\'t contain any value in range (from <= value <= to) using binary search\\n    private static boolean notInRange(int[] arr, int from, int to) {\\n        int start = 0;\\n        int end = arr.length - 1;\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (arr[mid] >= from && arr[mid] <= to) {\\n                return false;\\n            } else if (arr[mid] < from) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```|arr1[i] - arr2[j]| <= d```\n```arr1[i] - d <= arr2[j] <= arr1[i] + d```\n```val```\n```arr1```\n```arr2```\n```val - d```\n```val + d```\n```\\nclass Solution {\\n\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);    \\n        int distance = 0;\\n        \\n        for (int val : arr1) {\\n            if (notInRange(arr2, val - d, val + d)) {\\n                distance++;\\n            }\\n        }    \\n        \\n        return distance;\\n    }\\n    \\n    // Checks if the array doesn\\'t contain any value in range (from <= value <= to) using binary search\\n    private static boolean notInRange(int[] arr, int from, int to) {\\n        int start = 0;\\n        int end = arr.length - 1;\\n        \\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            if (arr[mid] >= from && arr[mid] <= to) {\\n                return false;\\n            } else if (arr[mid] < from) {\\n                start = mid + 1;\\n            } else {\\n                end = mid - 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546779,
                "title": "c-brute-force-or-binary-search",
                "content": "See more in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1. Brute Force\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-the-distance-value-between-two-arrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& A, vector<int>& B, int d) {\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            bool found = false;\\n            for (int j = 0; j < B.size() && !found; ++j) {\\n                if (abs(A[i] - B[j]) <= d) found = true;\\n            }\\n            if (!found) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Brute Force\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-the-distance-value-between-two-arrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& A, vector<int>& B, int d) {\\n        return count_if(begin(A), end(A), [&](const auto &a) {\\n            return all_of(begin(B), end(B), [&](const auto &b) {\\n                return abs(a - b) > d;\\n            });\\n        });\\n    }\\n};\\n```\\n\\n## Solution 3. Binary Search\\n\\nFor each `A[i]`, find the length of range `[A[i] - d, A[i] + d]` in array `B`. If the length is 0, then increment the answer.\\n\\nThe start point of the range (`A[i] - d`) can be found using `lower_bound(begin(B), end(B), A[i] - d)`.\\n\\nThe next element after the end point of the range (the element after `A[i] + d`) can be found using `upper_bound(begin(B), end(B), n + d)`.\\n\\nIf these two iterators are the same, it means the length of the range is 0.\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-the-distance-value-between-two-arrays/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& A, vector<int>& B, int d) {\\n        sort(begin(B), end(B));\\n        int ans = 0;\\n        for (int n : A) {\\n            if (upper_bound(begin(B), end(B), n + d) == lower_bound(begin(B), end(B), n - d)) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/find-the-distance-value-between-two-arrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& A, vector<int>& B, int d) {\\n        int ans = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            bool found = false;\\n            for (int j = 0; j < B.size() && !found; ++j) {\\n                if (abs(A[i] - B[j]) <= d) found = true;\\n            }\\n            if (!found) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/find-the-distance-value-between-two-arrays/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& A, vector<int>& B, int d) {\\n        return count_if(begin(A), end(A), [&](const auto &a) {\\n            return all_of(begin(B), end(B), [&](const auto &b) {\\n                return abs(a - b) > d;\\n            });\\n        });\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/find-the-distance-value-between-two-arrays/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& A, vector<int>& B, int d) {\\n        sort(begin(B), end(B));\\n        int ans = 0;\\n        for (int n : A) {\\n            if (upper_bound(begin(B), end(B), n + d) == lower_bound(begin(B), end(B), n - d)) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909718,
                "title": "c-binary-search-approach",
                "content": "The function **isValid(arr[i],d)** checks if there is a number present in arr2 & it is in the range **[arr[i] - d.......arr[i] + d]**, & if there is such number in arr2, then arr[i] does not contribute in answer, else it does.\\nThe binary-search works as we keep on getting close to the **num** so if there\\'s a case such that **abs(num - arr[j]) <= d** we will reach it in **log(arr2.size())**.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&arr,int target,int d){\\n        \\n        int low = 0, high = arr.size() - 1;\\n        while(low <= high){\\n            \\n            int mid = low + (high - low)/2;\\n            if(abs(arr[mid] - target) <= d){\\n                return false;\\n            }\\n            else if(arr[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    \\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        \\n        sort(arr2.begin(),arr2.end());\\n        \\n        int cnt = 0;\\n        for(auto num:arr1){\\n           if(isValid(arr2,num,d)){\\n               cnt++;\\n           } \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&arr,int target,int d){\\n        \\n        int low = 0, high = arr.size() - 1;\\n        while(low <= high){\\n            \\n            int mid = low + (high - low)/2;\\n            if(abs(arr[mid] - target) <= d){\\n                return false;\\n            }\\n            else if(arr[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    \\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        \\n        sort(arr2.begin(),arr2.end());\\n        \\n        int cnt = 0;\\n        for(auto num:arr1){\\n           if(isValid(arr2,num,d)){\\n               cnt++;\\n           } \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546501,
                "title": "python-two-pointers-o-n-log-n",
                "content": "```\\n\\n# Some remarks on how to interpret this algorithm.\\n#\\n# Each branch of the nested if-else statement will lead you to a single conclusion about your\\n# current configuration of pointers regarding two questions:\\n# 1. does the i-th element of arr1 sastisfies distance condition or not -- if not we drop i-th\\n# element, i.e. ignore augmenting distance counter and advance the pointer\\n# 2. is the j-th element of arr2 neccessary for comparisons with current or next elements of\\n# arr1 -- if not we advance the j pointer\\n#\\n# The concluding correction accounts for the tail of arr1 in the case when its values are greater\\n# than all of the arr2. I need it because my algorithm for the sake of simplicity and its\\n# correctness assumes that there will be always a concluding element of arr2 that is greater\\n# that any elmeent of arr1. You can see on the test sets it is not always the case, therefore is\\n# the correction.\\n\\n\\nclass Solution:\\n    def findTheDistanceValue(self, arr1, arr2, d):\\n        arr1.sort()\\n        arr2.sort()\\n        i = 0\\n        j = 0\\n        dist = 0\\n        while i < len(arr1) and j < len(arr2):\\n            if arr1[i] >= arr2[j]:\\n                if arr1[i] - arr2[j] > d:\\n                    j += 1\\n                else:\\n                    i += 1\\n            else:\\n                if arr2[j] - arr1[i] > d:\\n                    i += 1\\n                    dist += 1\\n                else:\\n                    i += 1\\n        dist += len(arr1) - i\\n        return dist\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# Some remarks on how to interpret this algorithm.\\n#\\n# Each branch of the nested if-else statement will lead you to a single conclusion about your\\n# current configuration of pointers regarding two questions:\\n# 1. does the i-th element of arr1 sastisfies distance condition or not -- if not we drop i-th\\n# element, i.e. ignore augmenting distance counter and advance the pointer\\n# 2. is the j-th element of arr2 neccessary for comparisons with current or next elements of\\n# arr1 -- if not we advance the j pointer\\n#\\n# The concluding correction accounts for the tail of arr1 in the case when its values are greater\\n# than all of the arr2. I need it because my algorithm for the sake of simplicity and its\\n# correctness assumes that there will be always a concluding element of arr2 that is greater\\n# that any elmeent of arr1. You can see on the test sets it is not always the case, therefore is\\n# the correction.\\n\\n\\nclass Solution:\\n    def findTheDistanceValue(self, arr1, arr2, d):\\n        arr1.sort()\\n        arr2.sort()\\n        i = 0\\n        j = 0\\n        dist = 0\\n        while i < len(arr1) and j < len(arr2):\\n            if arr1[i] >= arr2[j]:\\n                if arr1[i] - arr2[j] > d:\\n                    j += 1\\n                else:\\n                    i += 1\\n            else:\\n                if arr2[j] - arr1[i] > d:\\n                    i += 1\\n                    dist += 1\\n                else:\\n                    i += 1\\n        dist += len(arr1) - i\\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546484,
                "title": "python-1-line",
                "content": "**Python:**\\n```py\\n    def findTheDistanceValue(self, A, B, d):\\n        return sum(all(abs(a - b) > d for b in B) for a in A)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def findTheDistanceValue(self, A, B, d):\\n        return sum(all(abs(a - b) > d for b in B) for a in A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 546441,
                "title": "simple-java-solution-using-treeset",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int res = 0;\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for(int n : arr2)\\n            ts.add(n);\\n        \\n        for(int n : arr1){\\n            Integer higher = ts.ceiling(n);\\n            Integer lower = ts.floor(n);\\n            int diff = 0;\\n            if(higher == null){\\n                diff = Math.abs(lower - n);\\n            }else if(lower == null){\\n                diff = Math.abs(higher - n);\\n            }else{\\n                diff = Math.min(higher - n, n - lower);\\n            }\\n            if(diff > d)\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int res = 0;\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for(int n : arr2)\\n            ts.add(n);\\n        \\n        for(int n : arr1){\\n            Integer higher = ts.ceiling(n);\\n            Integer lower = ts.floor(n);\\n            int diff = 0;\\n            if(higher == null){\\n                diff = Math.abs(lower - n);\\n            }else if(lower == null){\\n                diff = Math.abs(higher - n);\\n            }else{\\n                diff = Math.min(higher - n, n - lower);\\n            }\\n            if(diff > d)\\n                res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547037,
                "title": "python-binary-search-nlog-n",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        \\n        def is_valid(val):\\n            l, r = 0, len(arr2)\\n            while l < r:\\n                mid = (l + r) // 2\\n                if abs(arr2[mid] - val) <= d:\\n                    return False\\n                elif arr2[mid] > val:\\n                    r = mid\\n                else:\\n                    l = mid + 1\\n            return True\\n\\n        return sum(is_valid(x) for x in arr1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        \\n        def is_valid(val):\\n            l, r = 0, len(arr2)\\n            while l < r:\\n                mid = (l + r) // 2\\n                if abs(arr2[mid] - val) <= d:\\n                    return False\\n                elif arr2[mid] > val:\\n                    r = mid\\n                else:\\n                    l = mid + 1\\n            return True\\n\\n        return sum(is_valid(x) for x in arr1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556113,
                "title": "concise-java-with-o-mlog-n-time",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        for(int num: arr2){\\n            tree.add(num);\\n        }\\n        int distance = 0;\\n        for(int i = 0; i < arr1.length; i++){\\n           int left = arr1[i] - d;\\n           int right = arr1[i] + d;\\n           Set<Integer> set = tree.subSet(left, right+1);\\n           if(set.isEmpty()){\\n             distance++;\\n           }\\n        }\\n      return distance;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        for(int num: arr2){\\n            tree.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 548876,
                "title": "c-optimal-solution-in-o-m-n-time-using-buckets",
                "content": "Surprisingly so far I haven\\'t seen an optimal solution for this easy problem. The optimal solution is not that \"easy\".\\nThe prototype of this problem is \\nhttps://leetcode.com/problems/contains-duplicate-iii/\\n\\nWe can do here almost the same, use buckets, each bucket represents a length of interval=d-1 using d consecutive numbers (special case for d=0).\\nIn each bucket store only the minimum and maximum value of the second array.\\nThen when we proceed the first array we need to check its bucket and the two neighbour buckets, since all other numbers are outside of [x-d,x+d] interval.\\n\\nThe running time is O(m+n), and using O(n) memory.\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n\\n        int ans=0;        \\n        unordered_map<int,pair<int,int>>mymap;\\n        \\n        for(int x:arr2){\\n            int offset=x/max(1,d);\\n            \\n            if(mymap.count(offset)==0){\\n                mymap[offset]={x,x};\\n                continue;\\n            }\\n            mymap[offset]={min(x,mymap[offset].first),max(x,mymap[offset].second)};\\n        }\\n        \\n        for(int x:arr1){\\n            int offset=x/max(1,d)-1;\\n            bool found=false;\\n            \\n            for(int j=-1;j<=1&&!found;j++,offset++){\\n               if(mymap.count(offset)==0)continue;\\n               if(abs(x-mymap[offset].first)<=d||abs(x-mymap[offset].second)<=d)found=true;\\n            }\\n            if(!found)ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n\\n        int ans=0;        \\n        unordered_map<int,pair<int,int>>mymap;\\n        \\n        for(int x:arr2){\\n            int offset=x/max(1,d);\\n            \\n            if(mymap.count(offset)==0){\\n                mymap[offset]={x,x};\\n                continue;\\n            }\\n            mymap[offset]={min(x,mymap[offset].first),max(x,mymap[offset].second)};\\n        }\\n        \\n        for(int x:arr1){\\n            int offset=x/max(1,d)-1;\\n            bool found=false;\\n            \\n            for(int j=-1;j<=1&&!found;j++,offset++){\\n               if(mymap.count(offset)==0)continue;\\n               if(abs(x-mymap[offset].first)<=d||abs(x-mymap[offset].second)<=d)found=true;\\n            }\\n            if(!found)ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2310362,
                "title": "misleading-description",
                "content": "Bad description of problem!",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1916796,
                "title": "runtime-0-ms-faster-than-100-00-of-c-binary-search-easy-simple-approach",
                "content": "***UPVOTE if you find it usefull and feel free to ask any doubt, thank you.***\\n```cpp\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int m = arr1.size();\\n        int n = arr2.size();\\n        sort(arr2.begin(), arr2.end());\\n        int cnt = 0;\\n        for (int i = 0; i < m; i++) {\\n            int l = 0, r = n-1, x = arr1[i] - d, y = arr1[i] + d;\\n            \\n            while (l <= r) {\\n                int mid = l+ (r-l)/2;\\n                if (arr2[mid] < x) {\\n                    l = mid + 1;\\n                } \\n                else if (arr2[mid] > y) {\\n                    r = mid - 1;\\n                } \\n                else {\\n                    cnt++; break;\\n                }\\n            }\\n        }\\n        return m - cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int m = arr1.size();\\n        int n = arr2.size();\\n        sort(arr2.begin(), arr2.end());\\n        int cnt = 0;\\n        for (int i = 0; i < m; i++) {\\n            int l = 0, r = n-1, x = arr1[i] - d, y = arr1[i] + d;\\n            \\n            while (l <= r) {\\n                int mid = l+ (r-l)/2;\\n                if (arr2[mid] < x) {\\n                    l = mid + 1;\\n                } \\n                else if (arr2[mid] > y) {\\n                    r = mid - 1;\\n                } \\n                else {\\n                    cnt++; break;\\n                }\\n            }\\n        }\\n        return m - cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602862,
                "title": "javascript-solution-1-line-50-100",
                "content": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    return arr1.filter(n1 => arr2.every(n2 => Math.abs(n1 - n2) > d)).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    return arr1.filter(n1 => arr2.every(n2 => Math.abs(n1 - n2) > d)).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 861631,
                "title": "my-java-solution-2-solutions-with-my-thougt-process",
                "content": "```\\n/* My thought process\\nHere I first goes with the brute force solution where we iterate through the both arrays using nested loops and we check for the condition given from the question and if any is satisfied we decrease 1 from the total length of first array because we have to return number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\\n\\n\\nThe other approach after looking the hint is, we can sort the second array. we can clearly make use of a TreeSet to  which when we add elements will be sorted in ascending order.\\nNow we goes throgh the first array, finds the lower and upperbound possible and finds the subsets of this range.\\nIf the set is empty, this indicates that our condition is met and we increment our count.\\n\\nFinally return this count.\\n\\n\\n*/\\n\\n\\n\\n\\n// O(nlogm)\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count = 0;\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        for (int number: arr2) {\\n            tree.add(number);\\n        }\\n        for (int i=0; i<arr1.length; i++) {\\n            int leftValue = arr1[i] - d;\\n            int rightValue = arr1[i] + d;\\n            Set<Integer> set = tree.subSet(leftValue, rightValue+1);\\n            if (set.isEmpty())\\n                count += 1;\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n// Brute force O(n^2)\\nclass Solution {\\n    public int findTheDistanceValue(int [] arr1, int [] arr2, int d) {\\n        int count = arr1.length;\\n        for (int i=0; i<arr1.length; i++) {\\n            for (int j=0; j<arr2.length; j++) {\\n                if (Math.abs(arr1[i] - arr2[j]) <= d) {\\n                    count -= 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n/* My thought process\\nHere I first goes with the brute force solution where we iterate through the both arrays using nested loops and we check for the condition given from the question and if any is satisfied we decrease 1 from the total length of first array because we have to return number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.\\n\\n\\nThe other approach after looking the hint is, we can sort the second array. we can clearly make use of a TreeSet to  which when we add elements will be sorted in ascending order.\\nNow we goes throgh the first array, finds the lower and upperbound possible and finds the subsets of this range.\\nIf the set is empty, this indicates that our condition is met and we increment our count.\\n\\nFinally return this count.\\n\\n\\n*/\\n\\n\\n\\n\\n// O(nlogm)\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count = 0;\\n        TreeSet<Integer> tree = new TreeSet<>();\\n        for (int number: arr2) {\\n            tree.add(number);\\n        }\\n        for (int i=0; i<arr1.length; i++) {\\n            int leftValue = arr1[i] - d;\\n            int rightValue = arr1[i] + d;\\n            Set<Integer> set = tree.subSet(leftValue, rightValue+1);\\n            if (set.isEmpty())\\n                count += 1;\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n// Brute force O(n^2)\\nclass Solution {\\n    public int findTheDistanceValue(int [] arr1, int [] arr2, int d) {\\n        int count = arr1.length;\\n        for (int i=0; i<arr1.length; i++) {\\n            for (int j=0; j<arr2.length; j++) {\\n                if (Math.abs(arr1[i] - arr2[j]) <= d) {\\n                    count -= 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228703,
                "title": "binary-search-and-brute-force-logic",
                "content": "\\n\\n# Brute Force Approach\\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        count=0\\n        for i in arr1:\\n            for j in arr2:\\n                if abs(i-j)<=d:\\n                    count+=1\\n                    break\\n        return len(arr1)-count\\n  #please upvote me it would encourage me alot\\n\\n\\n```\\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        count=0\\n        arr2.sort()\\n        for i in range(len(arr1)):\\n            left,right=0,len(arr2)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if abs(arr1[i]-arr2[mid])<=d:\\n                    count+=1\\n                    break\\n                elif arr1[i]<arr2[mid]:\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n        return len(arr1)-count\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        count=0\\n        for i in arr1:\\n            for j in arr2:\\n                if abs(i-j)<=d:\\n                    count+=1\\n                    break\\n        return len(arr1)-count\\n  #please upvote me it would encourage me alot\\n\\n\\n```\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        count=0\\n        arr2.sort()\\n        for i in range(len(arr1)):\\n            left,right=0,len(arr2)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if abs(arr1[i]-arr2[mid])<=d:\\n                    count+=1\\n                    break\\n                elif arr1[i]<arr2[mid]:\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n        return len(arr1)-count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299485,
                "title": "c-2-pointers-brute-force-o-n-m-and-binary-search-o-n-logm",
                "content": "```\\n// Brute Force 2 Pointer Soln\\n// Time: O(N.M)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d)\\n    {\\n        int distanceValue = 0;\\n        int pointer_one = -1;\\n        int pointer_two = -1;\\n        \\n        for (int pointer_one = 0; pointer_one < arr1.size(); pointer_one++) {\\n            pointer_two = 0;\\n            bool addNum = true;\\n            for (int pointer_two = 0; pointer_two < arr2.size(); pointer_two++) {\\n                if (abs(arr1[pointer_one] - arr2[pointer_two]) <= d)\\n                    addNum = false;\\n            }\\n            if (addNum)\\n                distanceValue++;\\n        }\\n        \\n        return distanceValue;\\n    }\\n};\\n```\\n\\n```\\n// Binary Search Soln\\n// Time: O(N.logM)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) \\n    {\\n        int distanceValue = 0;\\n        sort(arr2.begin(), arr2.end());\\n        \\n        for (int p1 = 0; p1 < arr1.size(); p1++) {\\n            int ai = arr1[p1];\\n            bool addNum = true;\\n            \\n            int l = 0;\\n            int r = arr2.size() - 1;\\n            int m = -1;\\n            \\n            while (l <= r) {\\n                m = l + (r - l) / 2;\\n                int aj = arr2[m];\\n                if (abs(aj - ai) <= d) {\\n                    addNum = false;\\n                    break;\\n                }\\n                else if (aj > ai)\\n                    r = m - 1;\\n                else\\n                    l = m + 1;\\n            }\\n            \\n            if (addNum)\\n                distanceValue++;\\n        }\\n        \\n        return distanceValue;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// Brute Force 2 Pointer Soln\\n// Time: O(N.M)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d)\\n    {\\n        int distanceValue = 0;\\n        int pointer_one = -1;\\n        int pointer_two = -1;\\n        \\n        for (int pointer_one = 0; pointer_one < arr1.size(); pointer_one++) {\\n            pointer_two = 0;\\n            bool addNum = true;\\n            for (int pointer_two = 0; pointer_two < arr2.size(); pointer_two++) {\\n                if (abs(arr1[pointer_one] - arr2[pointer_two]) <= d)\\n                    addNum = false;\\n            }\\n            if (addNum)\\n                distanceValue++;\\n        }\\n        \\n        return distanceValue;\\n    }\\n};\\n```\n```\\n// Binary Search Soln\\n// Time: O(N.logM)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) \\n    {\\n        int distanceValue = 0;\\n        sort(arr2.begin(), arr2.end());\\n        \\n        for (int p1 = 0; p1 < arr1.size(); p1++) {\\n            int ai = arr1[p1];\\n            bool addNum = true;\\n            \\n            int l = 0;\\n            int r = arr2.size() - 1;\\n            int m = -1;\\n            \\n            while (l <= r) {\\n                m = l + (r - l) / 2;\\n                int aj = arr2[m];\\n                if (abs(aj - ai) <= d) {\\n                    addNum = false;\\n                    break;\\n                }\\n                else if (aj > ai)\\n                    r = m - 1;\\n                else\\n                    l = m + 1;\\n            }\\n            \\n            if (addNum)\\n                distanceValue++;\\n        }\\n        \\n        return distanceValue;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646665,
                "title": "python-3-bucket-sort-o-n-with-optimisation-beats-98-6",
                "content": "Encouraged by [220. Contains Duplicate III (hard)](https://leetcode.com/problems/contains-duplicate-iii/solutions/3546546/python-bucketsort-o-n-beat-98-with-comments/)\\n\\n```python3 []\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        res, buckets = 0, dict() # (minVa, maxVal)\\n        \\n        def getKey(val):\\n            return val // d\\n        \\n        def addVal(val):\\n            key = getKey(val)\\n            #save only min and max value in bucket, others values not\\n            if key in buckets:\\n                if buckets[key][0] > val: buckets[key][0] = val\\n                elif buckets[key][1] < val: buckets[key][1] = val\\n            else:\\n                buckets[key] = [val, val]\\n        \\n        #initialize buckets     \\n        for val in arr2: addVal(val)\\n\\n        for val in arr1:\\n            key = getKey(val)\\n            if key in buckets: continue #in one bucket all values x < d\\n            #check sibling buckets\\n            if key - 1 in buckets and val - buckets[key-1][1] <= d: continue #maxVal from the left side is nearest\\n            if key + 1 in buckets and buckets[key+1][0] - val <= d: continue #minVal from the right side is nearest\\n            res += 1\\n\\n        return res\\n```\\n![Screenshot 2023-07-18 at 13.09.32.png](https://assets.leetcode.com/users/images/73652ca4-35ab-452e-b6c5-fe26419ae2cc_1689674998.8797338.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bucket Sort"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        res, buckets = 0, dict() # (minVa, maxVal)\\n        \\n        def getKey(val):\\n            return val // d\\n        \\n        def addVal(val):\\n            key = getKey(val)\\n            #save only min and max value in bucket, others values not\\n            if key in buckets:\\n                if buckets[key][0] > val: buckets[key][0] = val\\n                elif buckets[key][1] < val: buckets[key][1] = val\\n            else:\\n                buckets[key] = [val, val]\\n        \\n        #initialize buckets     \\n        for val in arr2: addVal(val)\\n\\n        for val in arr1:\\n            key = getKey(val)\\n            if key in buckets: continue #in one bucket all values x < d\\n            #check sibling buckets\\n            if key - 1 in buckets and val - buckets[key-1][1] <= d: continue #maxVal from the left side is nearest\\n            if key + 1 in buckets and buckets[key+1][0] - val <= d: continue #minVal from the right side is nearest\\n            res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328212,
                "title": "java-easy-to-understand-solution-using-binary-search",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int res = 0;\\n        \\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            int close = findClosest(arr2,arr1[i]);\\n            if(Math.abs(arr1[i]-close) > d)\\n                res++;\\n        }\\n        \\n        return res;\\n    }\\n    int findClosest(int[] arr,int target)\\n    {\\n        int d = Integer.MAX_VALUE;\\n        int low = 0,high = arr.length-1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(arr[mid] == target)\\n                return arr[mid];\\n            else if(arr[mid] < target)\\n            {\\n                low = mid+1;\\n            }\\n            else \\n            {\\n                high = mid-1;\\n            }\\n            d = Math.abs(target-arr[mid]) < Math.abs(target-d) ? arr[mid] : d;\\n        }\\n        return d;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int res = 0;\\n        \\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            int close = findClosest(arr2,arr1[i]);\\n            if(Math.abs(arr1[i]-close) > d)\\n                res++;\\n        }\\n        \\n        return res;\\n    }\\n    int findClosest(int[] arr,int target)\\n    {\\n        int d = Integer.MAX_VALUE;\\n        int low = 0,high = arr.length-1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            if(arr[mid] == target)\\n                return arr[mid];\\n            else if(arr[mid] < target)\\n            {\\n                low = mid+1;\\n            }\\n            else \\n            {\\n                high = mid-1;\\n            }\\n            d = Math.abs(target-arr[mid]) < Math.abs(target-d) ? arr[mid] : d;\\n        }\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662282,
                "title": "beats-98-o-m-n-log-n-optimal-solution-easy-to-understand-c",
                "content": "![image](https://assets.leetcode.com/users/images/d7dac5e7-09d7-4ac7-b48d-5e05877e9a35_1664943061.9190748.png)\\n\\n**If you like this solution, an upvote would be appreciated!! Thank you!**\\n```\\nclass Solution {\\npublic:\\n    // arr1 = M, arr2 = N\\n    // O((M+N)logN)\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        // O(NlogN)\\n        sort(arr2.begin(), arr2.end());\\n        int ans = 0;\\n        // O(MlogN)\\n        for (int num : arr1) {\\n            if (binarySearch(num, arr2, d)) ans++;\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    // O(logN)\\n    bool binarySearch(int num, vector<int>& arr, int d) {\\n        int lo = 0, hi = arr.size() - 1;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (abs(num - arr[mid]) <= d) return false;\\n\\n            if (arr[mid] > num) hi = mid - 1;\\n            else lo = mid + 1;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**If you like this solution, an upvote would be appreciated!! Thank you!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // arr1 = M, arr2 = N\\n    // O((M+N)logN)\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        // O(NlogN)\\n        sort(arr2.begin(), arr2.end());\\n        int ans = 0;\\n        // O(MlogN)\\n        for (int num : arr1) {\\n            if (binarySearch(num, arr2, d)) ans++;\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    // O(logN)\\n    bool binarySearch(int num, vector<int>& arr, int d) {\\n        int lo = 0, hi = arr.size() - 1;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (abs(num - arr[mid]) <= d) return false;\\n\\n            if (arr[mid] > num) hi = mid - 1;\\n            else lo = mid + 1;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332253,
                "title": "c-binary-search-with-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif no element in arr2  lie in this range \\n***[arr1[i]-d,arr1[i]+d]*** then arr1[i] contributes to the number we are returning\\n- if ***arr2[mid] < arr[i]*** and ***|arr1[i]-arr2[j]| > d*** then arr2[mid]  lies in the range [0,arr1[i]-d) and there is a possibilty that elements of arr2 which are after mid lies in the ***[arr1[i]-d,arr1[i]+d]*** to check if any element is present in this range we make low = mid +1 and if there is no element eventually high > low becomes termination condition and arr1[i] contributes in the result\\n- if ***arr2[mid] > arr[i]*** and ***|arr1[i]-arr2[j]| > d*** then arr2[mid]  lies in the range (arr1[i]+d,**\\u221E**) and there is a possibilty that elements of arr2 which are before mid lies in the ***[arr1[i]-d,arr1[i]+d]*** to check if any element is present in this range we make high=mid-1 and if there is no element eventually high > low becomes termination condition and arr1[i] contributes in the result\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) \\n    {\\n         sort(arr2.begin(),arr2.end());\\n         int result = 0;\\n         for(int i = 0; i<arr1.size(); i++)\\n        {\\n          int low = 0;\\n          int high = arr2.size()-1;\\n          while(low <= high)\\n          {\\n             int mid=low +(high-low)/2;\\n             if(abs(arr1[i]-arr2[mid]) <= d)\\n             {\\n                 break;\\n             }if(arr2[mid] < arr1[i]){\\n                 low = mid +1;\\n             }else{\\n                 high = mid-1;\\n             }\\n          }\\n          if(low > high){\\n              result++;\\n          }\\n        }\\n     return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) \\n    {\\n         sort(arr2.begin(),arr2.end());\\n         int result = 0;\\n         for(int i = 0; i<arr1.size(); i++)\\n        {\\n          int low = 0;\\n          int high = arr2.size()-1;\\n          while(low <= high)\\n          {\\n             int mid=low +(high-low)/2;\\n             if(abs(arr1[i]-arr2[mid]) <= d)\\n             {\\n                 break;\\n             }if(arr2[mid] < arr1[i]){\\n                 low = mid +1;\\n             }else{\\n                 high = mid-1;\\n             }\\n          }\\n          if(low > high){\\n              result++;\\n          }\\n        }\\n     return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284477,
                "title": "java-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int count = 0;\\n        for(int i=0;i<arr1.length;i++) {\\n            if(valid(arr2, arr1[i], d)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean valid(int [] arr, int k, int d) {\\n        int low = 0;\\n        int high = arr.length-1;\\n        while(low <= high) {\\n            int mid = (low+high)/2;\\n            int dif = arr[mid] - k;\\n            if(Math.abs(dif) <= d) {\\n                return false;\\n            } else if(arr[mid] > k) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int count = 0;\\n        for(int i=0;i<arr1.length;i++) {\\n            if(valid(arr2, arr1[i], d)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean valid(int [] arr, int k, int d) {\\n        int low = 0;\\n        int high = arr.length-1;\\n        while(low <= high) {\\n            int mid = (low+high)/2;\\n            int dif = arr[mid] - k;\\n            if(Math.abs(dif) <= d) {\\n                return false;\\n            } else if(arr[mid] > k) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015283,
                "title": "python-3-simple-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        n = len(arr2)\\n        arr2.sort()\\n        res = 0\\n        \\n        for num in arr1:\\n            low, high = 0, n - 1\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if abs(num - arr2[mid]) <= d:\\n                    break\\n                elif num < arr2[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            else:\\n                res += 1\\n        \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        n = len(arr2)\\n        arr2.sort()\\n        res = 0\\n        \\n        for num in arr1:\\n            low, high = 0, n - 1\\n            while low <= high:\\n                mid = (low + high) // 2\\n                if abs(num - arr2[mid]) <= d:\\n                    break\\n                elif num < arr2[mid]:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            else:\\n                res += 1\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2195646,
                "title": "poor-question-description-and-use-of-words-java-solution-using-binary-search-explained",
                "content": "\\nExpression **|arr1[i] - arr2[j]| <= d** equals to **arr1[i] - d <= arr2[j] <= arr1[i] + d** \\nSo for every value val in the array arr1 **(O(n))** we need to check (**using binary search** **(O(logm))** if the array **arr2 contains any value in range from val - d to val + d.** If not, increment distance. Overall Complexity is **O(nlogm)**\\n\\n```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);                  //Sorting arr2 in O(mlogm)\\n        int distance = 0;\\n        for (int i=0;i<arr1.length;i++)     //traversing arr1 in O(n)\\n        {\\n            int from=arr1[i]-d;             //We want to search for a Number in arr2 thats ranging between \\'from\\'\\n            int to=arr1[i]+d;               //to \\'to\\'.\\n            boolean flag=false;             //Assuming that there aint any such numbers in arr2\\n            \\n            int start = 0;                  //Using Binary Search to find the number in O(logm) making complexity O(nlogm)\\n            int end = arr2.length - 1;\\n           \\n            while (start <= end) \\n            {\\n                int mid = (end+start) / 2;\\n                if (arr2[mid] >= from && arr2[mid] <= to) \\n                {\\n                    flag=true;              //to denote we have found such a number between \\'from\\' and \\'to\\'\\n                    break;\\n                } \\n                else if (arr2[mid] < from) \\n                {\\n                    start = mid + 1;        //search in the subarray greater than mid\\n                } \\n                else \\n                {\\n                    end = mid - 1;          //search in the subarray lesser than mid\\n                }\\n            }\\n            if(!flag)                       //We dont want any \\'distance\\' value to satisfy, so negating the flag\\n                distance++;\\n        }    \\n        return distance;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);                  //Sorting arr2 in O(mlogm)\\n        int distance = 0;\\n        for (int i=0;i<arr1.length;i++)     //traversing arr1 in O(n)\\n        {\\n            int from=arr1[i]-d;             //We want to search for a Number in arr2 thats ranging between \\'from\\'\\n            int to=arr1[i]+d;               //to \\'to\\'.\\n            boolean flag=false;             //Assuming that there aint any such numbers in arr2\\n            \\n            int start = 0;                  //Using Binary Search to find the number in O(logm) making complexity O(nlogm)\\n            int end = arr2.length - 1;\\n           \\n            while (start <= end) \\n            {\\n                int mid = (end+start) / 2;\\n                if (arr2[mid] >= from && arr2[mid] <= to) \\n                {\\n                    flag=true;              //to denote we have found such a number between \\'from\\' and \\'to\\'\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2187432,
                "title": "javascript-binary-search",
                "content": "*I generally don\\'t mutate the array but it will be faster if you do*\\n\\n```\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    const sortedArr2 = [...arr2].sort((a,b) => a - b);\\n    let count = 0;\\n    \\n    for (let i = 0; i < arr1.length; i++) {\\n        count += binarySearch(arr1[i], sortedArr2, d);\\n    }\\n    \\n    return count;\\n};\\n\\nfunction binarySearch(currentValue, arr, distance) {\\n    let left = 0;\\n    let right = arr.length - 1;\\n    \\n    while (left <= right) {\\n        const mid = Math.floor((left + right) / 2);\\n        \\n        if (Math.abs(arr[mid] - currentValue) <= distance) {\\n            return 0;\\n        } else if (arr[mid] >= currentValue) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    return 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    const sortedArr2 = [...arr2].sort((a,b) => a - b);\\n    let count = 0;\\n    \\n    for (let i = 0; i < arr1.length; i++) {\\n        count += binarySearch(arr1[i], sortedArr2, d);\\n    }\\n    \\n    return count;\\n};\\n\\nfunction binarySearch(currentValue, arr, distance) {\\n    let left = 0;\\n    let right = arr.length - 1;\\n    \\n    while (left <= right) {\\n        const mid = Math.floor((left + right) / 2);\\n        \\n        if (Math.abs(arr[mid] - currentValue) <= distance) {\\n            return 0;\\n        } else if (arr[mid] >= currentValue) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    return 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2115090,
                "title": "javascript-4-methods-brute-bucket-two-pointers-binary-search",
                "content": "From the description (which is REALLY AWFUL), we have to ...\\n> Count the **# of arr1**, with NO items in arr2 **lies in its range** `[arr1[i]-d, arr1[i]+d]`. \\n\\ni.e. `arr1[i]`=4, `d`=2, we should check if there\\'s ANY `arr2[j]`=[2,6].\\n\\n.\\n**Brute Force**: implement`filter`one by one, O(m*n).\\n```\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    let count=0;\\n    for(let i=0; i<arr1.length; i++){\\n        if(!arr2.filter(v=>v>=arr1[i]-d && v<=arr1[i]+d).length){count++};\\n    }\\n    return count;\\n};\\n```\\n\\n**Bucket**: think *REVERSELY*.\\n\\nWhile brute-force need to check a range every time, we can **COLLECT ALL RANGES formed by `arr2` items** at first.\\nThen we just count how many `arr1` items **ESCAPES that range**.\\n\\n```\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    let bucket=new Array(2001).fill(0);\\n    for(let i=0; i<arr2.length; i++){\\n\\t\\t// mark all ranges arr2 may affect. \\n        for(let j=arr2[i]-d; j<=arr2[i]+d; j++){\\n            bucket[j+1000]++;\\n        }\\n    }\\n    return arr1.filter(v=>bucket[v+1000]==0).length;\\n};\\n```\\n\\n**Two Pointers**\\n\\nBy sorting, we can check the range WITHOUT jumping everywhere. The main points:\\n> `l` pointer: find the **FIRST index satisfied the LOWER bound** (>=`arr1[i]-d`).\\n> `r` pointer: find the **FIRST index NOT satisfied the UPPER bound** (>`arr1[i]+d`).\\n\\nif `l`==`r`, means there\\'s NO item lies in `[arr1[i]-d, arr1[i]+d]`.\\n\\n```\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    arr1.sort((a,b)=>a-b); arr2.sort((a,b)=>a-b);\\n    let l=r=0, count=0;\\n    for(let i=0; i<arr1.length; i++){\\n\\t\\t// l: first index IN the LB.\\n        while(arr2[l]<arr1[i]-d){l++};\\n\\t\\t// r: first index OUT of UB.\\n        while(arr2[r]<=arr1[i]+d){r++};\\n        count+=(r==l);\\n    }\\n    return count;\\n};\\n```\\n\\n**Binary Search**: implement two-pointers MORE EFFICIENTLY. \\n\\nWe execute binary search TWICE to find `l`&`r` as mentioned above\\nThen check whether they\\'re same or not.\\n\\n> Note: when `arr2`.length=1, we still have to know it is IN/OUT of range.\\n\\nSo I assign **`r`=arr2.length** rather than arr2.length-1 (or it would return 0 always).\\n\\n```\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    arr1.sort((a,b)=>a-b); arr2.sort((a,b)=>a-b);\\n    let count=0;\\n    for(let i=0; i<arr1.length; i++){\\n\\t\\t// l: first index IN the LB. r: first index OUT of UB. \\n        l=lb(arr1[i]); r=ub(arr1[i]);\\n        count+=(r==l);\\n    }\\n    return count;\\n    \\n    function lb(n){\\n        let l=0, r=arr2.length;\\n        while(l<r){\\n            let mid=l+Math.floor((r-l)/2);\\n            if(arr2[mid]<n-d){l=mid+1}\\n\\t\\t\\telse{r=mid};\\n        }\\n        return l;\\n    }\\n    function ub(n){\\n        let l=0, r=arr2.length;\\n        while(l<r){\\n            let mid=l+Math.floor((r-l)/2);\\n            if(arr2[mid]<=n+d){l=mid+1}\\n\\t\\t\\telse{r=mid};\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\nThanks for your reading and **up-voting** :)\\n\\n**\\u2B50 Check [HERE](https://github.com/Lynn19950915/LeetCode_King) for my full Leetcode Notes ~**",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    let count=0;\\n    for(let i=0; i<arr1.length; i++){\\n        if(!arr2.filter(v=>v>=arr1[i]-d && v<=arr1[i]+d).length){count++};\\n    }\\n    return count;\\n};\\n```\n```\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    let bucket=new Array(2001).fill(0);\\n    for(let i=0; i<arr2.length; i++){\\n\\t\\t// mark all ranges arr2 may affect. \\n        for(let j=arr2[i]-d; j<=arr2[i]+d; j++){\\n            bucket[j+1000]++;\\n        }\\n    }\\n    return arr1.filter(v=>bucket[v+1000]==0).length;\\n};\\n```\n```\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    arr1.sort((a,b)=>a-b); arr2.sort((a,b)=>a-b);\\n    let l=r=0, count=0;\\n    for(let i=0; i<arr1.length; i++){\\n\\t\\t// l: first index IN the LB.\\n        while(arr2[l]<arr1[i]-d){l++};\\n\\t\\t// r: first index OUT of UB.\\n        while(arr2[r]<=arr1[i]+d){r++};\\n        count+=(r==l);\\n    }\\n    return count;\\n};\\n```\n```\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    arr1.sort((a,b)=>a-b); arr2.sort((a,b)=>a-b);\\n    let count=0;\\n    for(let i=0; i<arr1.length; i++){\\n\\t\\t// l: first index IN the LB. r: first index OUT of UB. \\n        l=lb(arr1[i]); r=ub(arr1[i]);\\n        count+=(r==l);\\n    }\\n    return count;\\n    \\n    function lb(n){\\n        let l=0, r=arr2.length;\\n        while(l<r){\\n            let mid=l+Math.floor((r-l)/2);\\n            if(arr2[mid]<n-d){l=mid+1}\\n\\t\\t\\telse{r=mid};\\n        }\\n        return l;\\n    }\\n    function ub(n){\\n        let l=0, r=arr2.length;\\n        while(l<r){\\n            let mid=l+Math.floor((r-l)/2);\\n            if(arr2[mid]<=n+d){l=mid+1}\\n\\t\\t\\telse{r=mid};\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084605,
                "title": "java-binary-search-easy-approach",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int n = arr1.length, m = arr2.length, res = 0;\\n        Arrays.sort(arr2);\\n\\t\\t\\n\\t\\t// We will just search if there exist any number between range x-d & x+d in arr2 using binary search\\n        for(int x : arr1){\\n            if(!binarySearch(x-d, x+d, m, arr2)) res++;\\n        }\\n        return res;\\n    }\\n    \\n    public boolean binarySearch(int r1, int r2, int n, int[] arr){\\n        int l = 0, r = n-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(arr[mid] >= r1 && arr[mid]<=r2) return true;\\n            else if(arr[mid] < r1) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int n = arr1.length, m = arr2.length, res = 0;\\n        Arrays.sort(arr2);\\n\\t\\t\\n\\t\\t// We will just search if there exist any number between range x-d & x+d in arr2 using binary search\\n        for(int x : arr1){\\n            if(!binarySearch(x-d, x+d, m, arr2)) res++;\\n        }\\n        return res;\\n    }\\n    \\n    public boolean binarySearch(int r1, int r2, int n, int[] arr){\\n        int l = 0, r = n-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(arr[mid] >= r1 && arr[mid]<=r2) return true;\\n            else if(arr[mid] < r1) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2819322,
                "title": "python-simple-binary-search-solution-easy-to-understand",
                "content": "``` class Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        distance = len(arr1)\\n        for num in arr1:\\n            start = 0\\n            end = len(arr2) - 1\\n            while start <= end:\\n                mid = (start+end)//2\\n                if abs(num- arr2[mid]) <= d:\\n                    distance -= 1\\n                    break\\n                elif arr2[mid] > num :\\n                    end = mid-1\\n                elif arr2[mid] < num :\\n                    start = mid+1\\n        return distance",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "``` class Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        distance = len(arr1)\\n        for num in arr1:\\n            start = 0\\n            end = len(arr2) - 1\\n            while start <= end:\\n                mid = (start+end)//2\\n                if abs(num- arr2[mid]) <= d:\\n                    distance -= 1\\n                    break\\n                elif arr2[mid] > num :\\n                    end = mid-1\\n                elif arr2[mid] < num :\\n                    start = mid+1\\n        return distance",
                "codeTag": "Java"
            },
            {
                "id": 2694120,
                "title": "java-4ms-fast-solution",
                "content": "```\\n\\t\\tint count=0;\\n        int mark=0;\\n        double x;\\n        for(int i=0;i<arr1.length;i++){\\n            mark=0;\\n            for(int j=0;j<arr2.length;j++){\\n                x=Math.abs(arr1[i]-arr2[j]);\\n                if(x<=d){\\n                    j=arr2.length-1;\\n                }\\n                else{\\n                    mark++;\\n                }\\n            }\\n            if(mark==arr2.length){\\n                count++;\\n            }\\n        }\\n        return count;\\n\\t\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint count=0;\\n        int mark=0;\\n        double x;\\n        for(int i=0;i<arr1.length;i++){\\n            mark=0;\\n            for(int j=0;j<arr2.length;j++){\\n                x=Math.abs(arr1[i]-arr2[j]);\\n                if(x<=d){\\n                    j=arr2.length-1;\\n                }\\n                else{\\n                    mark++;\\n                }\\n            }\\n            if(mark==arr2.length){\\n                count++;\\n            }\\n        }\\n        return count;\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2373148,
                "title": "worst-problem-description",
                "content": "What is the problem ?\\n\\nThe only way to understand this problem is to read solution, because the description is not helping.\\n\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1192875,
                "title": "simple-python-bruteforce-solution",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        res = len(arr1)\\n        for i in arr1:\\n            for j in arr2:\\n                if(abs(i-j)>d):\\n                    continue\\n                else:\\n                    res-=1\\n                    break\\n        return res\\n        \\n```\\n\\n**If you found it useful, please upvote**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        res = len(arr1)\\n        for i in arr1:\\n            for j in arr2:\\n                if(abs(i-j)>d):\\n                    continue\\n                else:\\n                    res-=1\\n                    break\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1170388,
                "title": "python-code-using-binary-search",
                "content": "```\\nclass Solution(object):\\n    def findTheDistanceValue(self, arr1, arr2, d):\\n        arr2.sort()\\n        count=0\\n        for x in arr1:\\n            l, r = 0, len(arr2)\\n            while l < r:\\n                mid = (l + r) // 2\\n                if abs(arr2[mid] - x) <= d:\\n                    count-=1\\n                    break\\n                elif arr2[mid] > x:\\n                    r = mid\\n                else:\\n                    l = mid + 1\\n            count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def findTheDistanceValue(self, arr1, arr2, d):\\n        arr2.sort()\\n        count=0\\n        for x in arr1:\\n            l, r = 0, len(arr2)\\n            while l < r:\\n                mid = (l + r) // 2\\n                if abs(arr2[mid] - x) <= d:\\n                    count-=1\\n                    break\\n                elif arr2[mid] > x:\\n                    r = mid\\n                else:\\n                    l = mid + 1\\n            count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843087,
                "title": "go-solution-using-sorted-array",
                "content": "https://github.com/phea/leetcode-go\\n\\n```go\\nfunc findTheDistanceValue(arr1 []int, arr2 []int, d int) int {\\n\\tsort.Ints(arr2)\\n\\n\\tvar count int\\n\\tfor _, num := range arr1 {\\n\\t\\tminIdx := sort.SearchInts(arr2, num-d)\\n\\t\\tif minIdx < len(arr2) && arr2[minIdx] >= num-d && arr2[minIdx] <= num+d {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcount++\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc findTheDistanceValue(arr1 []int, arr2 []int, d int) int {\\n\\tsort.Ints(arr2)\\n\\n\\tvar count int\\n\\tfor _, num := range arr1 {\\n\\t\\tminIdx := sort.SearchInts(arr2, num-d)\\n\\t\\tif minIdx < len(arr2) && arr2[minIdx] >= num-d && arr2[minIdx] <= num+d {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcount++\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640002,
                "title": "python-short-and-simple",
                "content": "A number from arr1 adds to the distance value if the range(number - d, number + d + 1) is not in arr2.  So for each number in arr1, we just need to check whether that range overlaps with arr2.  \\n\\nConvert arr2 to a set, to speed up searching for the range within it.\\nConvert arr1 to a bag (a dictionary that counts occurrences of each number).  This way if arr1 = [1,1,1,3,4] we only need to check 1 once, and if it is valid then add 3 to res, as opposed to checking 1 three times.  \\n\\nIf the intersection between arr2 and range(number - d, number + d + 1) is empty, then that number adds to the distance value.  Repeat for all numbers in arr1 and you\\'re done.  \\n\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr1, arr2 = Counter(arr1), set(arr2)\\n        \\n        res = 0\\n        for num in arr1:\\n            target = range(num - d, num + d + 1)\\n            if not arr2.intersection(target):\\n                res += arr1[num]\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr1, arr2 = Counter(arr1), set(arr2)\\n        \\n        res = 0\\n        for num in arr1:\\n            target = range(num - d, num + d + 1)\\n            if not arr2.intersection(target):\\n                res += arr1[num]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205091,
                "title": "c-solution-with-comments-for-better-understanding-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(), arr2.end());\\n        \\n        // \"count\" : number of elements which follow the goven rule\\n        int count=0,low,high;\\n        for(auto x:arr1){\\n            // |arr1[i]- x| <= d    ,x= arr2[j]\\n            // so lowest value to find in arr2 is , low= arr[i]-d\\n            // and biggest value to find in arr2 is , high= arr[i]+d\\n            low= x-d, high= x+d;\\n            \\n            // finding iterator of low and high\\n            auto l= lower_bound(arr2.begin(), arr2.end(),low);\\n            auto h= lower_bound(arr2.begin(), arr2.end(),high);\\n            \\n            // check if l is equal to h , that mean range low to high is not present in arr2\\n            // also check is l iterator\\'s value is not equal to low of high \\n            if(l==h && (*l != low && *l != high)) count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(), arr2.end());\\n        \\n        // \"count\" : number of elements which follow the goven rule\\n        int count=0,low,high;\\n        for(auto x:arr1){\\n            // |arr1[i]- x| <= d    ,x= arr2[j]\\n            // so lowest value to find in arr2 is , low= arr[i]-d\\n            // and biggest value to find in arr2 is , high= arr[i]+d\\n            low= x-d, high= x+d;\\n            \\n            // finding iterator of low and high\\n            auto l= lower_bound(arr2.begin(), arr2.end(),low);\\n            auto h= lower_bound(arr2.begin(), arr2.end(),high);\\n            \\n            // check if l is equal to h , that mean range low to high is not present in arr2\\n            // also check is l iterator\\'s value is not equal to low of high \\n            if(l==h && (*l != low && *l != high)) count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311656,
                "title": "python-simple-python-solution-with-two-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n\\n# Approach 1 Using Binary Search : -\\n# Runtime: 173 ms, faster than 36.33% of Python3 online submissions for Find the Distance Value Between Two Arrays.\\n# Memory Usage: 14.1 MB, less than 41.37% of Python3 online submissions for Find the Distance Value Between Two Arrays.\\n\\n\\tclass Solution:\\n\\t\\tdef findTheDistanceValue(self, array1: List[int], array2: List[int], d: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tarray2 = sorted(array2)\\n\\n\\t\\t\\tfor num in array1:\\n\\n\\t\\t\\t\\tflag = True\\n\\n\\t\\t\\t\\tlow = 0\\n\\t\\t\\t\\thigh = len(array2)-1\\n\\n\\t\\t\\t\\twhile low <= high:\\n\\n\\t\\t\\t\\t\\tmid = (low + high) // 2\\n\\n\\t\\t\\t\\t\\tif abs(array2[mid] - num) <= d:\\n\\t\\t\\t\\t\\t\\tflag = False\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\\telif array2[mid] > num:\\n\\t\\t\\t\\t\\t\\thigh = mid - 1\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tlow = mid + 1;\\n\\n\\t\\t\\t\\tif flag == True:\\n\\n\\t\\t\\t\\t\\tresult = result + 1\\n\\n\\t\\t\\treturn result\\n\\n# Approach 2 Using Loop : -\\n# Runtime: 96 ms, faster than 50.33% of Python3 online submissions for Find the Distance Value Between Two Arrays.\\n# Memory Usage: 14.1 MB, less than 41.37% of Python3 online submissions for Find the Distance Value Between Two Arrays.\\n\\n\\tclass Solution:\\n\\t\\tdef findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n\\t\\t\\ts=0\\n\\t\\t\\tfor i in arr1:\\n\\t\\t\\t\\tt=0\\n\\t\\t\\t\\tfor j in arr2:\\n\\t\\t\\t\\t\\tif abs(i-j)<= d:\\n\\t\\t\\t\\t\\t\\tt=1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif t==0:\\n\\t\\t\\t\\t\\ts=s+1\\n\\t\\t\\treturn s\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n\\n# Approach 1 Using Binary Search : -\\n# Runtime: 173 ms, faster than 36.33% of Python3 online submissions for Find the Distance Value Between Two Arrays.\\n# Memory Usage: 14.1 MB, less than 41.37% of Python3 online submissions for Find the Distance Value Between Two Arrays.\\n\\n\\tclass Solution:\\n\\t\\tdef findTheDistanceValue(self, array1: List[int], array2: List[int], d: int) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tarray2 = sorted(array2)\\n\\n\\t\\t\\tfor num in array1:\\n\\n\\t\\t\\t\\tflag = True\\n\\n\\t\\t\\t\\tlow = 0\\n\\t\\t\\t\\thigh = len(array2)-1\\n\\n\\t\\t\\t\\twhile low <= high:\\n\\n\\t\\t\\t\\t\\tmid = (low + high) // 2\\n\\n\\t\\t\\t\\t\\tif abs(array2[mid] - num) <= d:\\n\\t\\t\\t\\t\\t\\tflag = False\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t\\telif array2[mid] > num:\\n\\t\\t\\t\\t\\t\\thigh = mid - 1\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tlow = mid + 1;\\n\\n\\t\\t\\t\\tif flag == True:\\n\\n\\t\\t\\t\\t\\tresult = result + 1\\n\\n\\t\\t\\treturn result\\n\\n# Approach 2 Using Loop : -\\n# Runtime: 96 ms, faster than 50.33% of Python3 online submissions for Find the Distance Value Between Two Arrays.\\n# Memory Usage: 14.1 MB, less than 41.37% of Python3 online submissions for Find the Distance Value Between Two Arrays.\\n\\n\\tclass Solution:\\n\\t\\tdef findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n\\t\\t\\ts=0\\n\\t\\t\\tfor i in arr1:\\n\\t\\t\\t\\tt=0\\n\\t\\t\\t\\tfor j in arr2:\\n\\t\\t\\t\\t\\tif abs(i-j)<= d:\\n\\t\\t\\t\\t\\t\\tt=1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif t==0:\\n\\t\\t\\t\\t\\ts=s+1\\n\\t\\t\\treturn s\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 2266088,
                "title": "c-faang-interview-optimized-code-insane",
                "content": "**STEP-1.**  **The function isValid(arr[i],d) checks if there is a number present in arr2 & it is in the range [arr[i] - d.......arr[i] + d], & if there is such number in arr2, then arr[i] does not contribute in answer, else it does.**\\n\\n**STEP-2** **The binary-search works as we keep on getting close to the num so if there\\'s a case such that abs(num - arr[j]) <= d we will reach it in log(arr2.size()).**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&arr,int target,int d){\\n        \\n        int low = 0, high = arr.size() - 1;\\n        while(low <= high){\\n            \\n            int mid = low + (high - low)/2;\\n            if(abs(arr[mid] - target) <= d){\\n                return false;\\n            }\\n            else if(arr[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    \\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        \\n        sort(arr2.begin(),arr2.end());\\n        \\n        int cnt = 0;\\n        for(auto num:arr1){\\n           if(isValid(arr2,num,d)){\\n               cnt++;\\n           } \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&arr,int target,int d){\\n        \\n        int low = 0, high = arr.size() - 1;\\n        while(low <= high){\\n            \\n            int mid = low + (high - low)/2;\\n            if(abs(arr[mid] - target) <= d){\\n                return false;\\n            }\\n            else if(arr[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    \\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        \\n        sort(arr2.begin(),arr2.end());\\n        \\n        int cnt = 0;\\n        for(auto num:arr1){\\n           if(isValid(arr2,num,d)){\\n               cnt++;\\n           } \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016308,
                "title": "4ms-90-faster-java-simple-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    boolean isValid(int arr[],int left,int right){\\n        int l=0,r=arr.length-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(arr[m]>=left&&arr[m]<=right)return false;\\n            if(arr[m]<left)l=m+1;\\n            else r=m-1;\\n        }\\n        return true;\\n    }\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n       Arrays.sort(arr2);\\n        int count=0;\\n        for(int num : arr1){\\n           if(isValid(arr2,num-d,num+d))count++;      \\n        }\\n        return count;\\n    }\\n}\\n```\\nTime : O(mlogm+nlogm) where m is length of array2 and n is length of array1\\nSpace : O(1) constant extra space\\n\\nPlease upvote if this is helpful",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    boolean isValid(int arr[],int left,int right){\\n        int l=0,r=arr.length-1;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(arr[m]>=left&&arr[m]<=right)return false;\\n            if(arr[m]<left)l=m+1;\\n            else r=m-1;\\n        }\\n        return true;\\n    }\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n       Arrays.sort(arr2);\\n        int count=0;\\n        for(int num : arr1){\\n           if(isValid(arr2,num-d,num+d))count++;      \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859630,
                "title": "python3-two-binary-searches",
                "content": "Algorithm\\nFor each element `x` in `arr1`, left binary search `x-d` and right binary search `x+d` in sorted `arr2`. If the two search returns the same index, there are no elements in `arr2` within `d` distance to `x`. Increment `ans` by 1. \\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        ans = 0\\n        for x in arr1: \\n            i = bisect_left(arr2, x-d)\\n            j = bisect_right(arr2, x+d)\\n            if i == j: ans += 1\\n        return ans \\n```\\n\\nIf it is not ideal to use both `bisect_left` and `bisect_right`. \\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        ans = 0\\n        for x in arr1: \\n            i = bisect_left(arr2, x-d)\\n            j = bisect_left(arr2, x+d+1)\\n            if i == j: ans += 1\\n        return ans \\n```\\n\\nEdit: \\nAlternatively, the approach in this [post](https://leetcode.com/problems/find-the-distance-value-between-two-arrays/discuss/546501/Python-two-pointers-O(n-log-n)) is also inspiring. \\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr1.sort()\\n        arr2.sort()\\n        ans = i = j = 0\\n        while i < len(arr1) and j < len(arr2): \\n            if arr1[i] <= arr2[j] + d: \\n                if arr1[i] < arr2[j] - d: ans += 1\\n                i += 1\\n            else: j += 1\\n        return ans + len(arr1) - i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        ans = 0\\n        for x in arr1: \\n            i = bisect_left(arr2, x-d)\\n            j = bisect_right(arr2, x+d)\\n            if i == j: ans += 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        ans = 0\\n        for x in arr1: \\n            i = bisect_left(arr2, x-d)\\n            j = bisect_left(arr2, x+d+1)\\n            if i == j: ans += 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr1.sort()\\n        arr2.sort()\\n        ans = i = j = 0\\n        while i < len(arr1) and j < len(arr2): \\n            if arr1[i] <= arr2[j] + d: \\n                if arr1[i] < arr2[j] - d: ans += 1\\n                i += 1\\n            else: j += 1\\n        return ans + len(arr1) - i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681172,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int length1 = arr1.length;\\n        int length2 = arr2.length;\\n        \\n        int distance = length1;\\n        \\n        for(int i=0; i<length1; i++){\\n            for(int j=0; j<length2; j++){\\n                if(Math.abs(arr1[i] - arr2[j]) <= d){\\n                    distance -= 1;\\n                    break;                  \\n                }\\n            }\\n            \\n        }\\n        \\n        return distance;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int length1 = arr1.length;\\n        int length2 = arr2.length;\\n        \\n        int distance = length1;\\n        \\n        for(int i=0; i<length1; i++){\\n            for(int j=0; j<length2; j++){\\n                if(Math.abs(arr1[i] - arr2[j]) <= d){\\n                    distance -= 1;\\n                    break;                  \\n                }\\n            }\\n            \\n        }\\n        \\n        return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552420,
                "title": "javascript-and-c-solutions",
                "content": "**Soluton #1**\\n\\nBrute-force comparision of all values `a` of `A` to all values `b` of `B`.  Return the count of values in `A` for which `abs(a - b) > T` where `T` is the input threshold.\\n\\n*Javascript*\\n```\\nlet findTheDistanceValue = (A, B, T) => A.filter(a => B.every(b => Math.abs(a - b) > T)).length;\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findTheDistanceValue(VI& A, VI& B, int T) {\\n        return count_if(A.begin(), A.end(), [&](auto a) {\\n            return all_of(B.begin(), B.end(), [=](auto b) { return abs(a - b) > T; });\\n        });\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution #2**\\n\\nSame idea as above, with @ajalbani\\'s optimization to check for \"not some less-than-or-equal to the threshold.\"\\n\\n*Javascript*\\n```\\nlet findTheDistanceValue = (A, B, T) => A.filter(a => !B.some(b => Math.abs(a - b) <= T)).length;\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findTheDistanceValue(VI& A, VI& B, int T) {\\n        return count_if(A.begin(), A.end(), [&](auto a) {\\n            return !any_of(B.begin(), B.end(), [&](auto b) { return abs(a - b) <= T; });\\n        });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet findTheDistanceValue = (A, B, T) => A.filter(a => B.every(b => Math.abs(a - b) > T)).length;\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findTheDistanceValue(VI& A, VI& B, int T) {\\n        return count_if(A.begin(), A.end(), [&](auto a) {\\n            return all_of(B.begin(), B.end(), [=](auto b) { return abs(a - b) > T; });\\n        });\\n    }\\n};\\n```\n```\\nlet findTheDistanceValue = (A, B, T) => A.filter(a => !B.some(b => Math.abs(a - b) <= T)).length;\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int findTheDistanceValue(VI& A, VI& B, int T) {\\n        return count_if(A.begin(), A.end(), [&](auto a) {\\n            return !any_of(B.begin(), B.end(), [&](auto b) { return abs(a - b) <= T; });\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546881,
                "title": "java-solution-with-binary-search-easy-to-understand",
                "content": "In Java doc,\\nArrays.binarySearch(int[] a, int key) returns the index of the search key, if it is contained in the array.\\nOtherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or a.length if all elements in the array are less than the specified key.\\n\\n```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count = 0;\\n        Arrays.sort(arr2);\\n        \\n        for (int num : arr1) {\\n            int index = Arrays.binarySearch(arr2, num);\\n            if (index >= 0) {  /* arr2 contains num */\\n                continue;\\n            }\\n            \\n            if (index == -1) {  /* num is smaller than the first element in sorted arr2 */\\n                if (Math.abs(num - arr2[0]) > d) {\\n                    count++;\\n                }\\n            } else if (index == -arr2.length - 1) {  /* num is larger than the last element in sorted arr2 */\\n                if (Math.abs(num - arr2[arr2.length - 1]) > d) {\\n                    count++;\\n                }\\n            } else {\\n                index = -index - 1;\\n                if (Math.abs(num - arr2[index]) > d && Math.abs(num - arr2[index - 1]) > d) {\\n                    count++;\\n                } \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count = 0;\\n        Arrays.sort(arr2);\\n        \\n        for (int num : arr1) {\\n            int index = Arrays.binarySearch(arr2, num);\\n            if (index >= 0) {  /* arr2 contains num */\\n                continue;\\n            }\\n            \\n            if (index == -1) {  /* num is smaller than the first element in sorted arr2 */\\n                if (Math.abs(num - arr2[0]) > d) {\\n                    count++;\\n                }\\n            } else if (index == -arr2.length - 1) {  /* num is larger than the last element in sorted arr2 */\\n                if (Math.abs(num - arr2[arr2.length - 1]) > d) {\\n                    count++;\\n                }\\n            } else {\\n                index = -index - 1;\\n                if (Math.abs(num - arr2[index]) > d && Math.abs(num - arr2[index - 1]) > d) {\\n                    count++;\\n                } \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546731,
                "title": "python-one-liner-in-o-n-log-m-with-explanation-and-long-version",
                "content": "This problem can be solved using a brute force ```O(n * m)``` algorithm because of the low constraints (```1 <= arr1.length, arr2.length <= 500```).\\nWe just need to check for every element in arr1 if there is no element in arr2 with a difference <= d:\\n```python\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        return sum(all(abs(a - b) > d for b in arr2) for a in arr1)\\n```\\nIf we want to improve on that we can sort arr2 and use binary search to find the number that is closest to ```arr1[i] - d``` in arr2 and check the difference. Including ```- d``` is important as it allows us to conclude that any value at a lower index does automatically fulfill ```|arr1[i] - arr2[j]| > d``` and we don\\'t have to check it separately. If we\\'d only search for ```arr1[i]``` we\\'d also have to check ```arr2[j - 1]```.\\nUsing binary search gives us an ```O(n log m)``` solution. Pythons included bisect_left returns the index where a new element should be inserted. If the element should be inserted at the end of the list that may be index m. Therefore the min-function is needed to have a proper binary search and to keep the index within bounds.\\n```python\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        return sum(abs(a - arr3[min(len(arr3) - 1, bisect.bisect_left(arr3, a - d))]) > d for arr3 in [sorted(arr2)] for a in arr1)\\n```\\nIf that was too much in one line for you here comes the long version:\\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        m = len(arr2)\\n        distance_value = 0\\n        \\n        for a in arr1:\\n            index = bisect.bisect_left(arr2, a - d)\\n            index = min(m - 1, index)\\n            b = arr2[index]\\n            \\n            if abs(a - b) > d:\\n                distance_value += 1\\n        \\n        return distance_value\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```O(n * m)```\n```1 <= arr1.length, arr2.length <= 500```\n```python\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        return sum(all(abs(a - b) > d for b in arr2) for a in arr1)\\n```\n```arr1[i] - d```\n```- d```\n```|arr1[i] - arr2[j]| > d```\n```arr1[i]```\n```arr2[j - 1]```\n```O(n log m)```\n```python\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        return sum(abs(a - arr3[min(len(arr3) - 1, bisect.bisect_left(arr3, a - d))]) > d for arr3 in [sorted(arr2)] for a in arr1)\\n```\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        m = len(arr2)\\n        distance_value = 0\\n        \\n        for a in arr1:\\n            index = bisect.bisect_left(arr2, a - d)\\n            index = min(m - 1, index)\\n            b = arr2[index]\\n            \\n            if abs(a - b) > d:\\n                distance_value += 1\\n        \\n        return distance_value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829401,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n\\t\\t\\tsort(arr2.begin(), arr2.end());\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0; i<arr1.size(); i++){\\n\\t\\t\\t\\tint st=0, en=arr2.size()-1, chk=1;\\n\\t\\t\\t\\twhile(st<=en){\\n\\t\\t\\t\\t\\tint mid=st+(en-st)/2;\\n\\t\\t\\t\\t\\tif(abs(arr2[mid]-arr1[i])<=d){chk=-1; break;}\\n\\t\\t\\t\\t\\telse if(arr2[mid]>arr1[i]){en=mid-1;}\\n\\t\\t\\t\\t\\telse{st=mid+1;}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(chk==1){cnt++;}\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n\\t\\t\\tsort(arr2.begin(), arr2.end());\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(int i=0; i<arr1.size(); i++){\\n\\t\\t\\t\\tint st=0, en=arr2.size()-1, chk=1;\\n\\t\\t\\t\\twhile(st<=en){\\n\\t\\t\\t\\t\\tint mid=st+(en-st)/2;\\n\\t\\t\\t\\t\\tif(abs(arr2[mid]-arr1[i])<=d){chk=-1; break;}",
                "codeTag": "Java"
            },
            {
                "id": 2701139,
                "title": "python-simple-solution-using-binary-search-faster-than-99-85",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        n1,n2,c = len(arr1),len(arr2),0\\n        arr2.sort()\\n        for i in arr1:\\n            l=0\\n            h=n2-1\\n            while l<=h:\\n                m=(l+h)//2\\n                if abs(i-arr2[m])<=d:\\n                    c+=1\\n                    break\\n                if arr2[m]>i:\\n                    h=m-1\\n                else:\\n                    l=m+1\\n        return n1-c\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        n1,n2,c = len(arr1),len(arr2),0\\n        arr2.sort()\\n        for i in arr1:\\n            l=0\\n            h=n2-1\\n            while l<=h:\\n                m=(l+h)//2\\n                if abs(i-arr2[m])<=d:\\n                    c+=1\\n                    break\\n                if arr2[m]>i:\\n                    h=m-1\\n                else:\\n                    l=m+1\\n        return n1-c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599116,
                "title": "c-easy-understanding-binary-search-fully-explained",
                "content": "**The idea::**\\n1-we want the number of elements which doesn\\'t result in arr1[i]-arr2[j]<=d.\\n2-the idea behind binary search is that when we find the first one that satisfy the formula above we don\\'t include it in the result and we stop.\\n3-So the binary search makes it faster that when you find that first element in arr2 which sastifies the formula quit(cause we know if there are any other elements they actually are bigger than this one so of course they satisfy the formula).\\n\\n**If it was helpful UPVOTE :)**\\n\\nclass Solution {\\n\\n    int binChk(vector<int>& arr2,int n,int d)\\n    {\\n        int l=0,r=arr2.size()-1,mid=0;\\n        while(l<=r)\\n        {\\n            mid=l+(r-l)/2;\\n            if(abs(arr2[mid]-n)<=d) return true;\\n            else if(arr2[mid]<n) l=mid+1;\\n            else r=mid-1;\\n        }\\n        return false;\\n    }\\npublic:\\n\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(),arr2.end());\\n        int cnt=0;\\n        for(int n:arr1)\\n        {\\n            if(!binChk(arr2,n,d)) cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\n    int binChk(vector<int>& arr2,int n,int d)\\n    {\\n        int l=0,r=arr2.size()-1,mid=0;\\n        while(l<=r)\\n        {\\n            mid=l+(r-l)/2;\\n            if(abs(arr2[mid]-n)<=d) return true;\\n            else if(arr2[mid]<n) l=mid+1;\\n            else r=mid-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2156181,
                "title": "javascript-efficient-solution-meme",
                "content": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    const arr2Sorted = arr2.sort((a, b) => a - b);\\n    let dist = 0;\\n    \\n    for (const num of arr1) {\\n        if (isDistanceValid(num, d, arr2Sorted)) {\\n            dist += 1;\\n        }\\n    }\\n    \\n    return dist;\\n};\\n\\nfunction isDistanceValid(number, dist, array) {\\n    let left = 0;\\n    let right = array.length - 1;\\n    \\n    while (left <= right) {\\n        const mid = Math.floor((right + left) / 2);\\n        \\n        if (Math.abs(number - array[mid]) <= dist) {\\n            return false;\\n        }\\n        \\n        if (array[mid] < number) {\\n            left = mid + 1;\\n        }\\n        \\n        if (array[mid] > number) {\\n            right = mid - 1;\\n        }\\n    }\\n    \\n    return true;\\n}\\n```\\n\\n**If you like solution or meme, upvote for motivate me**\\n\\nMeme#29 *see my other solutions for more memes!\\n\\n![image](https://assets.leetcode.com/users/images/ca12afc5-7968-4a2b-af3b-b8ba6b529a2f_1655320603.0663376.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    const arr2Sorted = arr2.sort((a, b) => a - b);\\n    let dist = 0;\\n    \\n    for (const num of arr1) {\\n        if (isDistanceValid(num, d, arr2Sorted)) {\\n            dist += 1;\\n        }\\n    }\\n    \\n    return dist;\\n};\\n\\nfunction isDistanceValid(number, dist, array) {\\n    let left = 0;\\n    let right = array.length - 1;\\n    \\n    while (left <= right) {\\n        const mid = Math.floor((right + left) / 2);\\n        \\n        if (Math.abs(number - array[mid]) <= dist) {\\n            return false;\\n        }\\n        \\n        if (array[mid] < number) {\\n            left = mid + 1;\\n        }\\n        \\n        if (array[mid] > number) {\\n            right = mid - 1;\\n        }\\n    }\\n    \\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1974248,
                "title": "java-2ms-beats-99-5-decompose-abs-into-comparisons-against-precomputed-arrays",
                "content": "There is always a tradeoff between time and space. In this case, I wondered if I could gain a speed up if I precomputed the `abs()` that is part of the highly repeated calculation of `|arr1[i]-arr2[j]| <= d`. Since `d` is a constant, and `arr2` is already known, could I create two arrays based on `arr2` that already had the `d` amount figured in? Since we are dealing with absolute value as well, there would need to be two such arrays. Therefore:\\n\\n1. We start with the given inequality: `|arr1[i] - arr2[j]| <= d`\\n\\n2. We decompose the absolute value into this 3-part inequality: `-d <= arr1[i] - arr2[j] <= d`\\n\\n3. We separate the 3-part inequality into two 2-part inequalities: (a) `-d <= arr1[i] - arr2[j]` && `arr1[i] - arr2[j] <= d` (Note that we must preserve the logical AND.)\\n\\n4. With basic algebra, we rewrite our two inequalities: (a) `-d + arr2[j] <= arr1[i]` && `arr1[i] <= d + arr2[j]`\\n\\n5. Rewriting to put the `arr1[i]` part on the left side: (a) `arr1[i] >= arr2[j] - d` && `arr1[i] <= arr2[j] + d`\\n\\n6. Finally, we precompute `arr2[j] - d` as a new array `a2j_minus_d` and same with `arr2[j] + d` as `a2j_plus_d`.\\n\\n**What is the speedup?**\\nIn Java code, using the original `(Math.abs(arr1_i - i) <= d)` had a max speed of 3ms (beasts 96.6%) according to the LeetCode judge engine.\\nAfter switching to Java code `(arr1_i <= a2j_plus_d[j] && arr1_i >= a2j_minus_d[j])` the max speed is now consistently 2ms (beats 99.5%). A gain of 3 percentage points. Not too bad! So we gain speed at the cost of creating two new arrays for easy lookup of the `arr2` and `d` computation, also without a possibly expensive `abs()` call.\\n\\n**What are possible drawbacks?**\\nBecause we precompute the two arrays, now `d` is now very baked in. Since `d` is an argument to `findTheDistanceValue()`, we can imagine (hypothetically) that perhaps the value of d could change from time to time (if we imagine a real-world scenario). We may want to be cautious about precomputing using a value that may be subject to change. That being said, even if `d` changes on every invocation of `findTheDistanceValue()`, it isn\\'t so bad to bake it into the two precomputed arrays because it still provides a speedup to us while we perform this specific invocation.\\n\\nThere is always something interesting to try with LeetCode problems, even the \"Easy\" ones!\\n\\n```\\n/*\\nRuntime: 2 ms, faster than 99.49% of Java online submissions for Find the Distance Value Between Two Arrays.\\nMemory Usage: 41.7 MB, less than 95.23% of Java online submissions for Find the Distance Value Between Two Arrays.\\n*/\\n\\nclass Solution {\\n    \\n    int[] a2j_plus_d;\\n    int[] a2j_minus_d;\\n    \\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        // strategy: decompose the absolute value computation into two comparisons against precomputed arrays.\\n        // one array is arr2[] plus d; the other array is arr2[] minus d\\n        \\n        // precomputation\\n        a2j_plus_d = new int[arr2.length];\\n        a2j_minus_d = new int[arr2.length];\\n        for (int j = 0; j < arr2.length; ++j) {\\n            a2j_plus_d[j] = arr2[j] + d;\\n            a2j_minus_d[j] = arr2[j] - d;\\n        }\\n      \\n        int distanceValue = 0;\\n      \\n        for (int i = 0; i < arr1.length; ++i) {\\n            distanceValue += distance(arr1[i]);\\n        }\\n      \\n        return distanceValue;\\n    }\\n  \\n    private final int distance(int arr1_i) {\\n        for (int j = 0; j < a2j_plus_d.length; ++j) {\\n            if (arr1_i <= a2j_plus_d[j] && arr1_i >= a2j_minus_d[j]) {\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 2 ms, faster than 99.49% of Java online submissions for Find the Distance Value Between Two Arrays.\\nMemory Usage: 41.7 MB, less than 95.23% of Java online submissions for Find the Distance Value Between Two Arrays.\\n*/\\n\\nclass Solution {\\n    \\n    int[] a2j_plus_d;\\n    int[] a2j_minus_d;\\n    \\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        // strategy: decompose the absolute value computation into two comparisons against precomputed arrays.\\n        // one array is arr2[] plus d; the other array is arr2[] minus d\\n        \\n        // precomputation\\n        a2j_plus_d = new int[arr2.length];\\n        a2j_minus_d = new int[arr2.length];\\n        for (int j = 0; j < arr2.length; ++j) {\\n            a2j_plus_d[j] = arr2[j] + d;\\n            a2j_minus_d[j] = arr2[j] - d;\\n        }\\n      \\n        int distanceValue = 0;\\n      \\n        for (int i = 0; i < arr1.length; ++i) {\\n            distanceValue += distance(arr1[i]);\\n        }\\n      \\n        return distanceValue;\\n    }\\n  \\n    private final int distance(int arr1_i) {\\n        for (int j = 0; j < a2j_plus_d.length; ++j) {\\n            if (arr1_i <= a2j_plus_d[j] && arr1_i >= a2j_minus_d[j]) {\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940961,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int count=0;\\n        \\n        for(int i=0;i<arr1.size();i++){\\n            bool cond_satisfied=true;\\n            for(int j=0;j<arr2.size();j++){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    cond_satisfied=false;    \\n                }\\n            }\\n             if(cond_satisfied==true){\\n                count++;\\n            }     \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int count=0;\\n        \\n        for(int i=0;i<arr1.size();i++){\\n            bool cond_satisfied=true;\\n            for(int j=0;j<arr2.size();j++){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    cond_satisfied=false;    \\n                }\\n            }\\n             if(cond_satisfied==true){\\n                count++;\\n            }     \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435049,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int c=0;\\n        for(int i=0;i<arr1.size();i++){\\n            char prime=true;\\n            for(int j=0;j<arr2.size();j++){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    prime=false;\\n                    break;\\n                }\\n            }\\n            if(prime)\\n                c++;\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int c=0;\\n        for(int i=0;i<arr1.size();i++){\\n            char prime=true;\\n            for(int j=0;j<arr2.size();j++){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    prime=false;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1054536,
                "title": "c-dp-100-o-n-k",
                "content": "```\\n\\n\\tint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int c[3001]={0},al=arr1.size(),ans=0,al2=arr2.size();\\n        while(al2--)\\n            ++c[arr2[al2]+1500];\\n        for(int i=1;i<3001;++i)\\n            c[i]+=c[i-1];\\n        while(al--){\\n            arr1[al]+=1500;\\n            if(c[arr1[al]+d]==c[arr1[al]-d-1])++ans;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\tint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int c[3001]={0},al=arr1.size(),ans=0,al2=arr2.size();\\n        while(al2--)\\n            ++c[arr2[al2]+1500];\\n        for(int i=1;i<3001;++i)\\n            c[i]+=c[i-1];\\n        while(al--){\\n            arr1[al]+=1500;\\n            if(c[arr1[al]+d]==c[arr1[al]-d-1])++ans;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 732007,
                "title": "javascript-binary-search-beats-80-runtime",
                "content": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    arr2.sort((a,b)=>{return a-b})\\n    return arr1.filter(x => isValid(x,arr2,d)).length\\n};\\n\\nlet isValid = (num,arr,d)=>{\\n    let low = 0,high = arr.length-1\\n    while(low <= high){\\n        let mid = Math.floor((low+high)/2)\\n        if(Math.abs(arr[mid]-num)<=d){\\n            return false   \\n        }else if(arr[mid] > num){\\n                    high = mid-1\\n                 }else{\\n                    low = mid+1\\n                 }\\n        \\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    arr2.sort((a,b)=>{return a-b})\\n    return arr1.filter(x => isValid(x,arr2,d)).length\\n};\\n\\nlet isValid = (num,arr,d)=>{\\n    let low = 0,high = arr.length-1\\n    while(low <= high){\\n        let mid = Math.floor((low+high)/2)\\n        if(Math.abs(arr[mid]-num)<=d){\\n            return false   \\n        }else if(arr[mid] > num){\\n                    high = mid-1\\n                 }else{\\n                    low = mid+1\\n                 }\\n        \\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 546739,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) \\n    {\\n        int result = 0;\\n        Array.Sort(arr2);\\n        foreach(var num in arr1)\\n        {\\n            int index1 = Array.BinarySearch(arr2, num + d), index2 = Array.BinarySearch(arr2, num - d);\\n            if(index1 < 0) \\n                index1 = ~index1 - 1;\\n            if(index2 < 0) \\n                index2 = ~index2;\\n            if(index2 > index1)\\n                result++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) \\n    {\\n        int result = 0;\\n        Array.Sort(arr2);\\n        foreach(var num in arr1)\\n        {\\n            int index1 = Array.BinarySearch(arr2, num + d), index2 = Array.BinarySearch(arr2, num - d);\\n            if(index1 < 0) \\n                index1 = ~index1 - 1;\\n            if(index2 < 0) \\n                index2 = ~index2;\\n            if(index2 > index1)\\n                result++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546571,
                "title": "cakewalk-solution-using-binary-search-and-another-one-using-lower-bound-stl",
                "content": "Using Binary Search\\n```\\nclass Solution {\\npublic:\\n    int binary(vector<int> arr2, int t)\\n    {\\n        int left = 0, right = arr2.size()-1;\\n        while(left <= right)\\n        {\\n            int mid = (left+right)/2 ;\\n            if(arr2[mid] >= t)\\n                right = mid-1 ;\\n            else \\n                left = mid+1;\\n        }\\n        return left ;\\n    }\\n    \\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int count = 0;\\n        sort(arr2.begin(), arr2.end());\\n        for(int i =0 ; i < arr1.size(); i++)\\n        {\\n            int val = binary(arr2, arr1[i]-d);\\n            if(val == arr2.size() || arr2[val] > arr1[i]+d)\\n                count++ ;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```\\n\\nUsing Lower Bound \\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int count = 0;\\n        sort(arr2.begin(), arr2.end());\\n        for(int i =0 ; i < arr1.size(); i++)\\n        {\\n            auto l1 = lower_bound(arr2.begin(), arr2.end(), arr1[i]-d);\\n            auto l2 = lower_bound(arr2.begin(), arr2.end(), arr1[i]+d);\\n            int tmp = l2-arr2.begin(), ab = arr1[i];\\n            if(l2-l1 == 0 && (l2 == arr2.end() || arr2[tmp] > ab+d))\\n            {\\n                count++ ;\\n            }\\n                \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binary(vector<int> arr2, int t)\\n    {\\n        int left = 0, right = arr2.size()-1;\\n        while(left <= right)\\n        {\\n            int mid = (left+right)/2 ;\\n            if(arr2[mid] >= t)\\n                right = mid-1 ;\\n            else \\n                left = mid+1;\\n        }\\n        return left ;\\n    }\\n    \\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int count = 0;\\n        sort(arr2.begin(), arr2.end());\\n        for(int i =0 ; i < arr1.size(); i++)\\n        {\\n            int val = binary(arr2, arr1[i]-d);\\n            if(val == arr2.size() || arr2[val] > arr1[i]+d)\\n                count++ ;\\n            \\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int count = 0;\\n        sort(arr2.begin(), arr2.end());\\n        for(int i =0 ; i < arr1.size(); i++)\\n        {\\n            auto l1 = lower_bound(arr2.begin(), arr2.end(), arr1[i]-d);\\n            auto l2 = lower_bound(arr2.begin(), arr2.end(), arr1[i]+d);\\n            int tmp = l2-arr2.begin(), ab = arr1[i];\\n            if(l2-l1 == 0 && (l2 == arr2.end() || arr2[tmp] > ab+d))\\n            {\\n                count++ ;\\n            }\\n                \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091221,
                "title": "easy-javascript-solution-beat-99-people",
                "content": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    let result = 0;\\n\\n    for(let i=0; i<arr1.length; i++){\\n        let flag = 0;\\n        for(let j=0; j<arr2.length; j++){\\n            if(Math.abs(arr1[i] - arr2[j]) <= d){\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0){\\n            result++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    let result = 0;\\n\\n    for(let i=0; i<arr1.length; i++){\\n        let flag = 0;\\n        for(let j=0; j<arr2.length; j++){\\n            if(Math.abs(arr1[i] - arr2[j]) <= d){\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0){\\n            result++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757605,
                "title": "beats-100-in-time-clean-and-easy-to-understand",
                "content": "# Intuition\\nBasic way would obviously to solve it using O(m*n) time i.e., For every element in arr1 check for elements in arr2 which verify the condition given abs(arr1[i]-arr2[j])<=d.\\n\\n# Approach\\nBetter way would be to search in arr2 using binary search after sorting it. During the search we check for any value in arr2 which lies inside the range of [arr1[i]-d, arr1[i]+d].\\n\\n# Complexity\\n- Time complexity:\\nT.C:- O((m*(nlogn))+(nlogn)) i.e., **O(m*(nlogn))** if m is size of arr1 and n is size of arr2.\\n\\n- Space complexity:\\nS.C:- **O(1)**, because we are not using any extra space.\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& arr,int num,int d)\\n    {\\n        int low=0,hi=arr.size()-1,mid;\\n        while(low<=hi)\\n        {\\n            mid=(low+hi)/2;\\n            if(arr[mid] < num-d)\\n                low=mid+1;\\n            else if(arr[mid]> num+d)\\n                hi=mid-1;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(),arr2.end());\\n        int ans=0;\\n        for(int i=0;i<arr1.size();i++)\\n        {\\n            if(isValid(arr2,arr1[i],d))\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& arr,int num,int d)\\n    {\\n        int low=0,hi=arr.size()-1,mid;\\n        while(low<=hi)\\n        {\\n            mid=(low+hi)/2;\\n            if(arr[mid] < num-d)\\n                low=mid+1;\\n            else if(arr[mid]> num+d)\\n                hi=mid-1;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(),arr2.end());\\n        int ans=0;\\n        for(int i=0;i<arr1.size();i++)\\n        {\\n            if(isValid(arr2,arr1[i],d))\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485868,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere i have use loop concept of searching.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n      int count=0;\\n      double x=0;\\n      for(int i=0;i<arr1.length;i++){\\n        int mark=0;\\n        for(int j=0;j<arr2.length;j++ ){\\n          x=Math.abs(arr1[i]-arr2[j]);\\n          if(x<=d){\\n            j=arr2.length-1;\\n          }\\n          else{\\n            mark++;\\n          }\\n        }\\n        if(mark==arr2.length)\\n        count++;\\n      }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n      int count=0;\\n      double x=0;\\n      for(int i=0;i<arr1.length;i++){\\n        int mark=0;\\n        for(int j=0;j<arr2.length;j++ ){\\n          x=Math.abs(arr1[i]-arr2[j]);\\n          if(x<=d){\\n            j=arr2.length-1;\\n          }\\n          else{\\n            mark++;\\n          }\\n        }\\n        if(mark==arr2.length)\\n        count++;\\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440728,
                "title": "naive-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        \\n        int count = 0;\\n        for(int i=0; i<arr1.size(); i++){\\n            bool flag = true;\\n            for(int j=0; j<arr2.size(); j++){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    flag = false;\\n                }\\n            }\\n            if(flag == true){\\n                count +=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        \\n        int count = 0;\\n        for(int i=0; i<arr1.size(); i++){\\n            bool flag = true;\\n            for(int j=0; j<arr2.size(); j++){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    flag = false;\\n                }\\n            }\\n            if(flag == true){\\n                count +=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976060,
                "title": "simple-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int n=arr1.size();\\n        int m=arr2.size();\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            count=0;\\n            while(j<m){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    count=0;\\n                    j=m-1;\\n                }\\n                else{\\n                    count++;\\n                }\\n                j++;\\n            }\\n            if(count>0){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int n=arr1.size();\\n        int m=arr2.size();\\n        int ans=0;\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int j=0;\\n            count=0;\\n            while(j<m){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    count=0;\\n                    j=m-1;\\n                }\\n                else{\\n                    count++;\\n                }\\n                j++;\\n            }\\n            if(count>0){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975369,
                "title": "python-brute-force-and-binary-search-solutions",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        ## Here is the Brute Force solution:\\n        ## Time complexity -> O(n*m)\\n        ## Space complexity -> O(1)\\n        \\n        \\n        def check(x, y, d):\\n            return abs(x - y) > d\\n        \\n        cnt = 0\\n        for n1 in arr1:\\n            is_valid = True\\n            for n2 in arr2:\\n                if not check(n1, n2, d):\\n                    is_valid = False\\n            if is_valid:\\n                cnt += 1\\n        return cnt\\n        \\n        ## Solution with Binary Search\\n        ## Time complexity -> O(n logn)\\n        ## Space complexity -> O(1)\\n        \\n        arr2.sort()\\n        res = 0\\n        \\n        for i in arr1:\\n            is_valid = True\\n            \\n            st = 0\\n            en = len(arr2) - 1\\n            while st <= en:\\n                m = (st + en) // 2\\n                \\n                if abs(arr2[m] - i) <= d:\\n                    is_valid = False\\n                    break\\n                \\n                elif arr2[m] > i:\\n                    en = m - 1\\n                else:\\n                    st = m + 1\\n            if is_valid:\\n                res += 1\\n                \\n        return res",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        ## Here is the Brute Force solution:\\n        ## Time complexity -> O(n*m)\\n        ## Space complexity -> O(1)\\n        \\n        \\n        def check(x, y, d):\\n            return abs(x - y) > d\\n        \\n        cnt = 0\\n        for n1 in arr1:\\n            is_valid = True\\n            for n2 in arr2:\\n                if not check(n1, n2, d):\\n                    is_valid = False\\n            if is_valid:\\n                cnt += 1\\n        return cnt\\n        \\n        ## Solution with Binary Search\\n        ## Time complexity -> O(n logn)\\n        ## Space complexity -> O(1)\\n        \\n        arr2.sort()\\n        res = 0\\n        \\n        for i in arr1:\\n            is_valid = True\\n            \\n            st = 0\\n            en = len(arr2) - 1\\n            while st <= en:\\n                m = (st + en) // 2\\n                \\n                if abs(arr2[m] - i) <= d:\\n                    is_valid = False\\n                    break\\n                \\n                elif arr2[m] > i:\\n                    en = m - 1\\n                else:\\n                    st = m + 1\\n            if is_valid:\\n                res += 1\\n                \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2892778,
                "title": "beats-99-54-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count=0; boolean flag=true;\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            flag=true;\\n            for(int j=0;j<arr2.length;j++){\\n                if(Math.abs(arr1[i]-arr2[j])<=d) {\\n                    flag=false; \\n                    break;\\n                }\\n            }\\n            if(flag) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count=0; boolean flag=true;\\n        for(int i=0;i<arr1.length;i++)\\n        {\\n            flag=true;\\n            for(int j=0;j<arr2.length;j++){\\n                if(Math.abs(arr1[i]-arr2[j])<=d) {\\n                    flag=false; \\n                    break;\\n                }\\n            }\\n            if(flag) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890887,
                "title": "easy-c-solution-binary-search-and-brute-force-both-approaches",
                "content": "## *Binary Search*\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        /* i-j<=d \\n        i-j <=d <= j-i range; */\\n        sort(arr2.begin(),arr2.end());\\n        int ans=0;\\n        for (auto val: arr1){\\n            int low=0; int high= arr2.size()-1;\\n            while (low<=high){\\n                int mid= low+ (high-low)/2;\\n                if (((val-arr2[mid])>= (-1*d)) && ((val-arr2[mid])<=d))break;\\n                if ((val-arr2[mid])>d)low= mid+1;\\n                if ((val-arr2[mid]) < (-1*d))high= mid-1;\\n            }\\n            if (low<=high)continue;\\n            else ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n## *Brute Force*\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int ans=0;\\n        for (int i=0; i<arr1.size(); i++){\\n            bool flg=1;\\n            for (int j=0; j<arr2.size(); j++){\\n                if (abs(arr1[i]-arr2[j])<=d){\\n                    flg=0; break;\\n                }\\n            }\\n            ans+= flg;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        /* i-j<=d \\n        i-j <=d <= j-i range; */\\n        sort(arr2.begin(),arr2.end());\\n        int ans=0;\\n        for (auto val: arr1){\\n            int low=0; int high= arr2.size()-1;\\n            while (low<=high){\\n                int mid= low+ (high-low)/2;\\n                if (((val-arr2[mid])>= (-1*d)) && ((val-arr2[mid])<=d))break;\\n                if ((val-arr2[mid])>d)low= mid+1;\\n                if ((val-arr2[mid]) < (-1*d))high= mid-1;\\n            }\\n            if (low<=high)continue;\\n            else ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int ans=0;\\n        for (int i=0; i<arr1.size(); i++){\\n            bool flg=1;\\n            for (int j=0; j<arr2.size(); j++){\\n                if (abs(arr1[i]-arr2[j])<=d){\\n                    flg=0; break;\\n                }\\n            }\\n            ans+= flg;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879151,
                "title": "c-solution-binary-search",
                "content": "# Intuition\\nWe have to count every element of arr1 that has difference or distance greater than given distance as d for every element of arr2.\\n\\n# Approach\\nFor distance of each element of arr1 from all element of arr2 we use binary search in arr2 for every element of arr1 for that we have to sort the second array then initialize low as 0 and high as arr2.size-1, i.e. last element and calculate mid and check if absolute difference between arr2[mid] and arr1[i] is greater or less than given distance d and,\\nIf less this element doen\\'t contribut to your count.\\nelse check if arr2[mid] is greater than or less than arr1[i] if greater than all the elemnts in right of mid are also greater so make high as mid-1 or else make low as mid+1\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int count=0;\\n        sort(arr2.begin(),arr2.end());\\n        for(int i=0;i<arr1.size();i++){\\n            int low=0;\\n            int high=arr2.size()-1;\\n            bool check=true;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(abs(arr1[i]-arr2[mid]) > d){\\n                    if(arr2[mid] > arr1[i])\\n                        high=mid-1;\\n                    else\\n                        low=mid+1;\\n                }\\n                else{\\n                    check=false;\\n                    break;\\n                }\\n            }\\n            if(check)\\n              count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int count=0;\\n        sort(arr2.begin(),arr2.end());\\n        for(int i=0;i<arr1.size();i++){\\n            int low=0;\\n            int high=arr2.size()-1;\\n            bool check=true;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(abs(arr1[i]-arr2[mid]) > d){\\n                    if(arr2[mid] > arr1[i])\\n                        high=mid-1;\\n                    else\\n                        low=mid+1;\\n                }\\n                else{\\n                    check=false;\\n                    break;\\n                }\\n            }\\n            if(check)\\n              count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874477,
                "title": "python-89-32-faster",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        x=0\\n        for i in arr1:\\n            c=1\\n            for j in arr2:\\n                if abs(i-j)<=d:\\n                    c=0\\n                    break \\n            if c:\\n                x+=1\\n        return x\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        x=0\\n        for i in arr1:\\n            c=1\\n            for j in arr2:\\n                if abs(i-j)<=d:\\n                    c=0\\n                    break \\n            if c:\\n                x+=1\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840742,
                "title": "java-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count = 0;\\n        for (int a : arr1) {\\n            boolean countIncrease = true;\\n            for (int b : arr2) {\\n                int dist = Math.abs(a - b);\\n                if (dist <= d) {\\n                    countIncrease = false;\\n                    break;\\n                }\\n            }\\n            if (countIncrease) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count = 0;\\n        for (int a : arr1) {\\n            boolean countIncrease = true;\\n            for (int b : arr2) {\\n                int dist = Math.abs(a - b);\\n                if (dist <= d) {\\n                    countIncrease = false;\\n                    break;\\n                }\\n            }\\n            if (countIncrease) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694105,
                "title": "python-simple-solution-faster-than-90-23",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        n1,n2,c = len(arr1),len(arr2),0\\n        for i in range(n1):\\n            c1=0\\n            for j in range(n2):\\n                if abs(arr1[i]-arr2[j])>d:\\n                    c1+=1\\n                else:\\n                    break\\n            if c1==n2:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        n1,n2,c = len(arr1),len(arr2),0\\n        for i in range(n1):\\n            c1=0\\n            for j in range(n2):\\n                if abs(arr1[i]-arr2[j])>d:\\n                    c1+=1\\n                else:\\n                    break\\n            if c1==n2:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579910,
                "title": "c-binary-search-easy-to-understand",
                "content": "**Code**\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int> &v, int lower, int higher){\\n        int l = 0, r = v.size();\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(v[mid] >= lower && v[mid] <= higher){\\n                return 0;\\n            } else if(v[mid] < lower){\\n                l = mid+1;\\n            } else{\\n                r = mid-1;\\n            }\\n        }\\n        return 1;\\n    }\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(), arr2.end());\\n        \\n        int counter = 0;\\n        for(int i = 0; i < arr1.size(); ++i){\\n            counter += countElements(arr2, arr1[i] - d, arr1[i] + d);\\n        }\\n        \\n        return counter;\\n    }\\n};\\n\\n```\\n**Output**\\n```\\nRuntime: 23 ms, faster than 39.65% of C++ online submissions for Find the Distance Value Between Two Arrays.\\nMemory Usage: 13 MB, less than 94.86% of C++ online submissions for Find the Distance Value Between Two Arrays.\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countElements(vector<int> &v, int lower, int higher){\\n        int l = 0, r = v.size();\\n        while(l <= r){\\n            int mid = l + (r-l)/2;\\n            if(v[mid] >= lower && v[mid] <= higher){\\n                return 0;\\n            } else if(v[mid] < lower){\\n                l = mid+1;\\n            } else{\\n                r = mid-1;\\n            }\\n        }\\n        return 1;\\n    }\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(), arr2.end());\\n        \\n        int counter = 0;\\n        for(int i = 0; i < arr1.size(); ++i){\\n            counter += countElements(arr2, arr1[i] - d, arr1[i] + d);\\n        }\\n        \\n        return counter;\\n    }\\n};\\n\\n```\n```\\nRuntime: 23 ms, faster than 39.65% of C++ online submissions for Find the Distance Value Between Two Arrays.\\nMemory Usage: 13 MB, less than 94.86% of C++ online submissions for Find the Distance Value Between Two Arrays.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419318,
                "title": "c-python-best-approach-solution",
                "content": "#### C++\\nRuntime: 15 ms, faster than 70.57% of C++ online submissions for Find the Distance Value Between Two Arrays.\\nMemory Usage: 13.2 MB, less than 29.43% of C++ online submissions for Find the Distance Value Between Two Arrays.\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int len = arr2.size();\\n\\t\\tint count = 0;\\n        sort(arr2.begin(), arr2.end());\\n        \\n        for(int i = 0; i < arr1.size(); i++) {\\n            bool flag = false;            \\n            int s = 0;\\n\\t\\t\\tint e = len - 1;\\n\\t\\t\\tint m;\\n            \\n            while(s <= e) {\\n                m = s + (e - s) / 2;\\n               if(abs(arr2[m] - arr1[i]) <= d) {\\n                    flag = true;\\n                    break;\\n               }\\n                \\n                else if(arr2[m] > arr1[i]) {\\n                    e = m - 1;\\n\\t\\t\\t\\t}\\n                \\n                else {\\n                    s = m + 1;\\n\\t\\t\\t\\t}\\n            }\\n            \\n            if(!flag) {\\n                count++;\\n\\t\\t\\t}\\n        }\\n        return count;\\n    }\\n};\\n```\\nTime Complexity - O(LogN)\\nSpace Complexity - O(1)\\n\\n#### Python\\nRuntime: 155 ms, faster than 48.58% of Python3 online submissions for Find the Distance Value Between Two Arrays.\\nMemory Usage: 14.1 MB, less than 41.69% of Python3 online submissions for Find the Distance Value Between Two Arrays.\\n\\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        distance = len(arr1)\\n        for num in arr1:\\n            start = 0\\n            end = len(arr2) - 1\\n            while start <= end:\\n                mid = (start+end)//2\\n                if abs(num- arr2[mid]) <= d:\\n                    distance -= 1\\n                    break\\n                elif arr2[mid] > num :\\n                    end = mid-1\\n                elif arr2[mid] < num :\\n                    start = mid+1\\n        return distance\\n```\\nTime Complexity - O(logN)\\nSpace Complexity - O(1)\\n\\n##### If you like the solution and find it understandable, then do upvote it & Share it with others.\\n##### If you found any error, any suggestions then do comment for any query\\n##### Thanks alot ! Cheers to your coding",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int len = arr2.size();\\n\\t\\tint count = 0;\\n        sort(arr2.begin(), arr2.end());\\n        \\n        for(int i = 0; i < arr1.size(); i++) {\\n            bool flag = false;            \\n            int s = 0;\\n\\t\\t\\tint e = len - 1;\\n\\t\\t\\tint m;\\n            \\n            while(s <= e) {\\n                m = s + (e - s) / 2;\\n               if(abs(arr2[m] - arr1[i]) <= d) {\\n                    flag = true;\\n                    break;\\n               }\\n                \\n                else if(arr2[m] > arr1[i]) {\\n                    e = m - 1;\\n\\t\\t\\t\\t}\\n                \\n                else {\\n                    s = m + 1;\\n\\t\\t\\t\\t}\\n            }\\n            \\n            if(!flag) {\\n                count++;\\n\\t\\t\\t}\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        distance = len(arr1)\\n        for num in arr1:\\n            start = 0\\n            end = len(arr2) - 1\\n            while start <= end:\\n                mid = (start+end)//2\\n                if abs(num- arr2[mid]) <= d:\\n                    distance -= 1\\n                    break\\n                elif arr2[mid] > num :\\n                    end = mid-1\\n                elif arr2[mid] < num :\\n                    start = mid+1\\n        return distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356023,
                "title": "python-iterative-binary-search-solution-well-documented",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        # binary search for diff <= d, if found return 0, else 1\\n        def binSearch(value: int) -> int:\\n            low, high = 0, len(arr2) - 1 \\n\\n            # Repeat until the pointers low and high meet each other\\n            while low <= high:              \\n                mid = (low + high) // 2\\n\\n                if abs(value-arr2[mid]) <= d: \\n                    return 0\\n                if v > arr2[mid]: \\n                    low = mid + 1               # go right side\\n                else: \\n                    high = mid - 1              # go left side\\n            \\n            # no such value found where diff <= d\\n            return 1\\n\\n        # sort the array so that we can perform binary-search\\n        arr2.sort()\\n\\n        # distance value count\\n        dValueCount = 0\\n        \\n        # search for diff <= d for each num \\n        for v in arr1:\\n            dValueCount += binSearch(v)\\n        return dValueCount\\n```\\nPlease UPVOTE\\uD83D\\uDC4D if you love\\u2764\\uFE0F this solution or learned something new.\\nIf you have any question, feel free to ask.\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        # binary search for diff <= d, if found return 0, else 1\\n        def binSearch(value: int) -> int:\\n            low, high = 0, len(arr2) - 1 \\n\\n            # Repeat until the pointers low and high meet each other\\n            while low <= high:              \\n                mid = (low + high) // 2\\n\\n                if abs(value-arr2[mid]) <= d: \\n                    return 0\\n                if v > arr2[mid]: \\n                    low = mid + 1               # go right side\\n                else: \\n                    high = mid - 1              # go left side\\n            \\n            # no such value found where diff <= d\\n            return 1\\n\\n        # sort the array so that we can perform binary-search\\n        arr2.sort()\\n\\n        # distance value count\\n        dValueCount = 0\\n        \\n        # search for diff <= d for each num \\n        for v in arr1:\\n            dValueCount += binSearch(v)\\n        return dValueCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297419,
                "title": "java-binary-search-easy-implementation-fast",
                "content": "```\\nclass Solution {\\n    public boolean distance(int [] arr, int k, int d) \\n    {\\n        int start = 0, last = arr.length-1;\\n        while(start<=last) \\n        {\\n            int mid = start + (last - start)/2;\\n            int diff = Math.abs(arr[mid] - k);\\n            if(diff <= d) \\n                return false;\\n            else if(arr[mid] > k) \\n                last = mid - 1;\\n            else \\n                start = mid + 1;\\n        }\\n        return true;\\n    }\\n    \\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int count = 0;\\n        for(int i=0;i<arr1.length;i++) \\n            if(distance(arr2, arr1[i], d)) \\n                count++;\\n        return count;  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean distance(int [] arr, int k, int d) \\n    {\\n        int start = 0, last = arr.length-1;\\n        while(start<=last) \\n        {\\n            int mid = start + (last - start)/2;\\n            int diff = Math.abs(arr[mid] - k);\\n            if(diff <= d) \\n                return false;\\n            else if(arr[mid] > k) \\n                last = mid - 1;\\n            else \\n                start = mid + 1;\\n        }\\n        return true;\\n    }\\n    \\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int count = 0;\\n        for(int i=0;i<arr1.length;i++) \\n            if(distance(arr2, arr1[i], d)) \\n                count++;\\n        return count;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266898,
                "title": "python-binary-search-faster-than-96-easy-to-read",
                "content": "```\\nclass Solution(object):\\n    def findTheDistanceValue(self, arr1, arr2, d):\\n        \"\"\"\\n        :type arr1: List[int]\\n        :type arr2: List[int]\\n        :type d: int\\n        :rtype: int\\n        \"\"\"\\n        arr2.sort()\\n        distance = len(arr1)\\n        for num in arr1:\\n            start = 0\\n            end = len(arr2) - 1\\n            while start <= end:\\n                mid = (start+end)//2\\n                if abs(num- arr2[mid]) <= d:\\n                    distance -= 1\\n                    break\\n                elif arr2[mid] > num :\\n                    end = mid-1\\n                elif arr2[mid] < num :\\n                    start = mid+1\\n        return distance\\n``",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def findTheDistanceValue(self, arr1, arr2, d):\\n        \"\"\"\\n        :type arr1: List[int]\\n        :type arr2: List[int]\\n        :type d: int\\n        :rtype: int\\n        \"\"\"\\n        arr2.sort()\\n        distance = len(arr1)\\n        for num in arr1:\\n            start = 0\\n            end = len(arr2) - 1\\n            while start <= end:\\n                mid = (start+end)//2\\n                if abs(num- arr2[mid]) <= d:\\n                    distance -= 1\\n                    break\\n                elif arr2[mid] > num :\\n                    end = mid-1\\n                elif arr2[mid] < num :\\n                    start = mid+1\\n        return distance\\n``",
                "codeTag": "Java"
            },
            {
                "id": 2164911,
                "title": "python-using-binary-search-fast-89",
                "content": "**<<< Do upvote if you like my solution.**\\nI used **binary search**. ```arr2``` needs to be sorted first.\\n\\n``` \\ndef findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n\\n\\tarr2.sort()\\n\\tlow = 0\\n\\thigh = len(arr2) - 1\\n\\tcount = 0\\n\\n\\tfor n in arr1:\\n\\t\\twhile low <= high:\\n\\t\\t\\tmid = low + (high-low)//2\\n\\t\\t\\tif abs(n - arr2[mid]) <= d:\\n\\t\\t\\t\\tcount -= 1 # to counter \\'count += 1\\' in end of loop\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif n <= arr2[mid]:\\n\\t\\t\\t\\thigh = mid - 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlow = mid + 1\\n\\t\\tlow = 0\\n\\t\\thigh = len(arr2) - 1\\n\\t\\tcount += 1    \\n\\n\\treturn count\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```arr2```\n``` \\ndef findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n\\n\\tarr2.sort()\\n\\tlow = 0\\n\\thigh = len(arr2) - 1\\n\\tcount = 0\\n\\n\\tfor n in arr1:\\n\\t\\twhile low <= high:\\n\\t\\t\\tmid = low + (high-low)//2\\n\\t\\t\\tif abs(n - arr2[mid]) <= d:\\n\\t\\t\\t\\tcount -= 1 # to counter \\'count += 1\\' in end of loop\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif n <= arr2[mid]:\\n\\t\\t\\t\\thigh = mid - 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlow = mid + 1\\n\\t\\tlow = 0\\n\\t\\thigh = len(arr2) - 1\\n\\t\\tcount += 1    \\n\\n\\treturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2139795,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] a, int[] b, int d) {\\n        Arrays.sort(b);\\n        int k=a.length,p=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(task(b,a[i]-d,a[i]+d))\\n                p++;\\n        }\\n        return p;\\n    }\\n    public boolean task(int a[] , int n , int m)\\n    {\\n        int i=0,j=a.length-1;\\n        while(i<=j)\\n        {\\n            int mid=i+(j-i)/2;\\n            if(a[mid]>=n&&a[mid]<=m)\\n                return false;\\n            else if(a[mid]<n)\\n                i=mid+1;\\n            else\\n                j=mid-1;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int findTheDistanceValue(int[] a, int[] b, int d) {\\n        Arrays.sort(b);\\n        int k=a.length,p=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(task(b,a[i]-d,a[i]+d))\\n                p++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2103513,
                "title": "c-two-approach-brute-force-binary-search",
                "content": "We need to check how many v in `arr1[]` can satisfy the following condition\\nfor all q in arr2[],  | q-v | > d. \\n\\n# Brute Force \\n```C++ \\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int err = 0;\\n        for(int i= 0;i<arr1.size();++i){\\n            for(int j = 0;j<arr2.size();++j){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    err++;\\n                    break;\\n                }\\n            }\\n        }\\n        return arr1.size() - err;\\n\\t}\\n};\\n```\\n\\n# Binary Search\\n```C++\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(),arr2.end());        \\n        int ans = 0;\\n        for(auto v:arr1){\\n            int L = 0, R = arr2.size() - 1;\\n            while(L <= R) {\\n                int M = L + (R-L)/2;\\n                if( v-d <= arr2[M] && arr2[M] <=v+d) break;\\n                if(arr2[M] > v+d)  R = M - 1; else L = M + 1;\\n            }\\n            ans+=(L>R);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```C++ \\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int err = 0;\\n        for(int i= 0;i<arr1.size();++i){\\n            for(int j = 0;j<arr2.size();++j){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    err++;\\n                    break;\\n                }\\n            }\\n        }\\n        return arr1.size() - err;\\n\\t}\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(),arr2.end());        \\n        int ans = 0;\\n        for(auto v:arr1){\\n            int L = 0, R = arr2.size() - 1;\\n            while(L <= R) {\\n                int M = L + (R-L)/2;\\n                if( v-d <= arr2[M] && arr2[M] <=v+d) break;\\n                if(arr2[M] > v+d)  R = M - 1; else L = M + 1;\\n            }\\n            ans+=(L>R);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082446,
                "title": "solved-using-binary-search-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(),arr2.end());\\n        int cnt=0;\\n        for(int i=0;i<arr1.size();i++)\\n        {\\n            bool flag=false;\\n            int l=arr1[i]-d;\\n            int r=arr1[i]+d;\\n            int start=0,end=arr2.size()-1;\\n            while(start<=end)\\n            {\\n                int mid=(end-start)/2+start;\\n                if(l<=arr2[mid] and arr2[mid]<=r)\\n                {\\n                    flag=true;\\n                    break;\\n                }\\n                else if(arr2[mid]>r)\\n                    end=mid-1;\\n                else if(arr2[mid]<l)\\n                    start=mid+1;\\n            }\\n            if(flag)\\n                continue;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(),arr2.end());\\n        int cnt=0;\\n        for(int i=0;i<arr1.size();i++)\\n        {\\n            bool flag=false;\\n            int l=arr1[i]-d;\\n            int r=arr1[i]+d;\\n            int start=0,end=arr2.size()-1;\\n            while(start<=end)\\n            {\\n                int mid=(end-start)/2+start;\\n                if(l<=arr2[mid] and arr2[mid]<=r)\\n                {\\n                    flag=true;\\n                    break;\\n                }\\n                else if(arr2[mid]>r)\\n                    end=mid-1;\\n                else if(arr2[mid]<l)\\n                    start=mid+1;\\n            }\\n            if(flag)\\n                continue;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074961,
                "title": "c-multi-solution",
                "content": "Runtime: 85 ms, faster than 94.20% of C# online submissions for Find the Distance Value Between Two Arrays.\\nMemory Usage: 40 MB, less than 32.85% of C# online submissions for Find the Distance Value Between Two Arrays.\\n```\\n// Solution 1: All pairs\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int retCount = 0;\\n        for (int i = 0; i < arr1.Length; i++)\\n        {\\n            bool flag = true;\\n            for (int j = 0; j < arr2.Length; j++)\\n            {\\n                if (Math.Abs(arr1[i] - arr2[j]) <= d)\\n                {\\n                    flag = false;\\n                    break;\\n                } \\n            }\\n            if (flag) retCount++;\\n        }\\n        return retCount;\\n    }\\n```\\n\\n```\\n// Solution 2: LINQ\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n         return arr1.Count(i => !arr2.Any(j => Math.Abs(i - j) <= d));\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/72656aaf-6e1e-4a48-b7d1-8c5b0d3a6b0c_1654142373.0535774.png)\\n\\n```\\n// Solution 3: Binary Search\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Array.Sort(arr2);\\n        var count = 0;\\n        for (int i = 0; i < arr1.Length; i++)\\n        {\\n            var flag = true;\\n            var left = 0;\\n            var right = arr2.Length - 1;\\n            while (left < right)\\n            {\\n                var pos = (left + right) / 2;\\n                if (Math.Abs(arr1[i] - arr2[pos]) <= d)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if (arr2[pos] > arr1[i] + d)\\n                    right = pos - 1;\\n                else\\n                    left = pos + 1;\\n            }\\n            if (flag && Math.Abs(arr1[i] - arr2[left]) > d)\\n                count++;        \\n        }\\n        return count;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/c44e6884-7894-497d-8077-fd3adb90d00d_1654148234.62089.png)\\n",
                "solutionTags": [],
                "code": "```\\n// Solution 1: All pairs\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int retCount = 0;\\n        for (int i = 0; i < arr1.Length; i++)\\n        {\\n            bool flag = true;\\n            for (int j = 0; j < arr2.Length; j++)\\n            {\\n                if (Math.Abs(arr1[i] - arr2[j]) <= d)\\n                {\\n                    flag = false;\\n                    break;\\n                } \\n            }\\n            if (flag) retCount++;\\n        }\\n        return retCount;\\n    }\\n```\n```\\n// Solution 2: LINQ\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n         return arr1.Count(i => !arr2.Any(j => Math.Abs(i - j) <= d));\\n    }\\n```\n```\\n// Solution 3: Binary Search\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Array.Sort(arr2);\\n        var count = 0;\\n        for (int i = 0; i < arr1.Length; i++)\\n        {\\n            var flag = true;\\n            var left = 0;\\n            var right = arr2.Length - 1;\\n            while (left < right)\\n            {\\n                var pos = (left + right) / 2;\\n                if (Math.Abs(arr1[i] - arr2[pos]) <= d)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if (arr2[pos] > arr1[i] + d)\\n                    right = pos - 1;\\n                else\\n                    left = pos + 1;\\n            }\\n            if (flag && Math.Abs(arr1[i] - arr2[left]) > d)\\n                count++;        \\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2071428,
                "title": "improved-problem-description-for-dummies",
                "content": "### Description\\n\\nGiven two unsorted integer arrays, `arr1` and `arr2`, and a target distance  `d` (integer), return how many elements from `arr1` have a distance from elements in `arr2` that are larger than `d`.\\n\\nThe distance between elements from  `arr1` and `arr2` is given by `| arr1[i] - arr2[j] |`. \\n\\nThus, the goal of the problem is to find how many elements in `arr1` can produce `| arr1[i] - arr2[j] | > d`.\\n\\n### Example\\n\\n#### Input:\\n```\\narr1 = [4,3,5]\\narr2 = [8,15,-1]\\nd = 3\\n```\\n\\n#### Expected Output:\\n```\\n2\\n```\\n\\n---\\n\\n### Explanation\\nBoth `arr1[0]` and `arr1[1]` have a distance larger than `d` with all elements from  `arr2`.\\n`arr1[2]` does not have a distance larger than `d` with all elements from `arr2`, just some of them.\\n\\n#### Verification\\n- Testing `arr1[0]`:\\n```\\n| 4 - 8 | > 3       (true)\\n| 4 - 15 | > 3      (true)\\n| 4 - (-1) | > 3    (true)\\n```\\n\\n- Testing `arr1[1]`:\\n```\\n| 3 - 8 | > 3       (true)\\n| 3 - 15 | > 3      (true)\\n| 3 - (-1) | > 3    (true)\\n```\\n\\n- Testing `arr1[2]`:\\n```\\n| 5 - 8 | > 3       (false)\\n| 5 - 15 | > 3      (true)\\n| 5 - (-1) | > 3    (true)\\n```",
                "solutionTags": [],
                "code": "```\\narr1 = [4,3,5]\\narr2 = [8,15,-1]\\nd = 3\\n```\n```\\n2\\n```\n```\\n| 4 - 8 | > 3       (true)\\n| 4 - 15 | > 3      (true)\\n| 4 - (-1) | > 3    (true)\\n```\n```\\n| 3 - 8 | > 3       (true)\\n| 3 - 15 | > 3      (true)\\n| 3 - (-1) | > 3    (true)\\n```\n```\\n| 5 - 8 | > 3       (false)\\n| 5 - 15 | > 3      (true)\\n| 5 - (-1) | > 3    (true)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2063265,
                "title": "99-71-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n      int ans=arr1.size();\\n       \\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n        \\n        for( int i=0 , j=0; i<arr1.size() && j<arr2.size() ; )\\n        {\\n            if(abs(arr1[i]-arr2[j])<=d)\\n            {\\n                i++;\\n                ans--;\\n            }\\n            else if(arr1[i]<arr2[j])\\n            {\\n                i++;\\n            }\\n            else if(arr1[i]>arr2[j])\\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n      int ans=arr1.size();\\n       \\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n        \\n        for( int i=0 , j=0; i<arr1.size() && j<arr2.size() ; )\\n        {\\n            if(abs(arr1[i]-arr2[j])<=d)\\n            {\\n                i++;\\n                ans--;\\n            }\\n            else if(arr1[i]<arr2[j])\\n            {\\n                i++;\\n            }\\n            else if(arr1[i]>arr2[j])\\n            {\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974872,
                "title": "golang-solution-binary-search",
                "content": "```\\nfunc findTheDistanceValue(arr1 []int, arr2 []int, d int) int {\\n    sort.Slice(arr2, func(i, j int) bool {\\n        return arr2[i] < arr2[j]\\n    })\\n    \\n    count := 0\\n    for _, v := range arr1 {\\n        if !checkInterval(arr2, v-d, v+d) {\\n            count++\\n        }\\n    }\\n    \\n    return count\\n}\\n\\nfunc checkInterval(arr []int, left int, right int) bool {\\n    start := 0\\n    end := len(arr) - 1\\n    \\n    for start <= end {\\n        middle := start + (end - start)/2\\n        \\n        if arr[middle] >= left && arr[middle] <= right {\\n            return true\\n        }\\n        \\n        if arr[middle] > right {\\n            end = middle - 1\\n        } else if arr[middle] < left {\\n            start = middle + 1\\n        }\\n    }\\n    \\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findTheDistanceValue(arr1 []int, arr2 []int, d int) int {\\n    sort.Slice(arr2, func(i, j int) bool {\\n        return arr2[i] < arr2[j]\\n    })\\n    \\n    count := 0\\n    for _, v := range arr1 {\\n        if !checkInterval(arr2, v-d, v+d) {\\n            count++\\n        }\\n    }\\n    \\n    return count\\n}\\n\\nfunc checkInterval(arr []int, left int, right int) bool {\\n    start := 0\\n    end := len(arr) - 1\\n    \\n    for start <= end {\\n        middle := start + (end - start)/2\\n        \\n        if arr[middle] >= left && arr[middle] <= right {\\n            return true\\n        }\\n        \\n        if arr[middle] > right {\\n            end = middle - 1\\n        } else if arr[middle] < left {\\n            start = middle + 1\\n        }\\n    }\\n    \\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1968577,
                "title": "python-o-n-log-n-nice-explanation",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        \\n        # sort the second array for binary search purpose\\n        arr2.sort()\\n        \\n        def bs(l,r,arr,k1,k2):\\n            # l and r are the starting and ending index of arr2\\n            \\n            # k1 and k2 is range between which the given condition is true\\n            \\n            while l<=r:\\n                mid=(l+r)//2 \\n                \\n                #if arr[mid] is in the range k1 and k2\\n                if arr[mid]>=k1 and arr[mid]<=k2:\\n                    return True\\n                \\n                #move the right pointer to the left if it is greater than k2\\n                elif arr[mid]>k2:\\n                    r=mid-1\\n                    \\n                #move the left pointer to the right of mid if it is less thank k1\\n                else:\\n                    l=mid+1 \\n                    \\n            # if no element satisfies the condition for element in arr1\\n            return False \\n        \\n        n=len(arr2)\\n        #initialise counter\\n        c=0\\n        \\n        #iterating arr1 to check the condition\\n        for ele in arr1:\\n            \\n            # range will be ele-d to ele+d\\n            if not bs(0,n-1,arr2,ele-d,ele+d):\\n                \\n                # increment if it does not satisfy\\n                c+=1\\n                \\n        return c\\n\\t\\t\\n\\t\\t#n=len(arr1)\\n\\t\\t#m=len(arr2)\\n\\t\\t\\n\\t\\t#sorting the array  -> m log(m)\\n\\t\\t#iterating and performing binary search  ->  n log(m)\\n\\t\\t#overall time complexity -> (n+m) log(m)\\n\\t\\t",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        \\n        # sort the second array for binary search purpose\\n        arr2.sort()\\n        \\n        def bs(l,r,arr,k1,k2):\\n            # l and r are the starting and ending index of arr2\\n            \\n            # k1 and k2 is range between which the given condition is true\\n            \\n            while l<=r:\\n                mid=(l+r)//2 \\n                \\n                #if arr[mid] is in the range k1 and k2\\n                if arr[mid]>=k1 and arr[mid]<=k2:\\n                    return True\\n                \\n                #move the right pointer to the left if it is greater than k2\\n                elif arr[mid]>k2:\\n                    r=mid-1\\n                    \\n                #move the left pointer to the right of mid if it is less thank k1\\n                else:\\n                    l=mid+1 \\n                    \\n            # if no element satisfies the condition for element in arr1\\n            return False \\n        \\n        n=len(arr2)\\n        #initialise counter\\n        c=0\\n        \\n        #iterating arr1 to check the condition\\n        for ele in arr1:\\n            \\n            # range will be ele-d to ele+d\\n            if not bs(0,n-1,arr2,ele-d,ele+d):\\n                \\n                # increment if it does not satisfy\\n                c+=1\\n                \\n        return c\\n\\t\\t\\n\\t\\t#n=len(arr1)\\n\\t\\t#m=len(arr2)\\n\\t\\t\\n\\t\\t#sorting the array  -> m log(m)\\n\\t\\t#iterating and performing binary search  ->  n log(m)\\n\\t\\t#overall time complexity -> (n+m) log(m)\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1932909,
                "title": "nlog-m-time-complexity-c-easy-or-watt-do-check-this",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    // this fun() will return closest distance of target from sorted array ar\\n    int findclosest(vector<int> &ar, int target)\\n    {\\n        int n = ar.size(), i = 0, j = n - 1;\\n        // here pos will tell the min possible distance;\\n        int pos = INT_MAX;\\n        while (i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n            if (ar[mid] == target)\\n            {\\n                return 0;\\n            }\\n            else if (target < ar[mid])\\n            {\\n                pos = min(abs(target - ar[mid]), pos);\\n                j = mid - 1;\\n            }\\n            else\\n            {\\n                pos = min(abs(target - ar[mid]), pos);\\n                i = mid + 1;\\n            }\\n        }\\n        return pos;\\n    }\\n\\n    // this fun() will return final ans\\n    int findTheDistanceValue(vector<int> &arr1, vector<int> &arr2, int d)\\n    {\\n        sort(arr2.begin(), arr2.end());\\n        int n = arr1.size(), m = arr2.size(), count = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            int ans = findclosest(arr2, arr1[i]);\\n            if (ans > d)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n    // this fun() will return closest distance of target from sorted array ar\\n    int findclosest(vector<int> &ar, int target)\\n    {\\n        int n = ar.size(), i = 0, j = n - 1;\\n        // here pos will tell the min possible distance;\\n        int pos = INT_MAX;\\n        while (i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n            if (ar[mid] == target)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1923419,
                "title": "java-binary-search-o-n-logn-with-explanation",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int res = 0;\\n        /*\\n            Approach : \\n            Sort the second array first, so that we can effectively search \\n            for the element we are searching for.\\n            \\n            Now, if mid == target or mid is atmost d distance apart, then we \\n            should stop searching, as we found an element, \\n            otherwise standard binary search, shorten our scope depending upon\\n            element is higher or lower.\\n            \\n            if no element found, then just do res++\\n            \\n        */\\n        for(int i : arr1){\\n            int low = 0;\\n            int high = arr2.length - 1;\\n            boolean found = false;\\n            \\n            while(low <= high){\\n                int mid = low + (high - low) / 2;\\n                if(arr2[mid] == i || Math.abs(arr2[mid] - i) <= d){\\n                    found = true;\\n                    break;\\n                }\\n                else if(arr2[mid] > i)\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n            \\n            if(!found)\\n                res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int res = 0;\\n        /*\\n            Approach : \\n            Sort the second array first, so that we can effectively search \\n            for the element we are searching for.\\n            \\n            Now, if mid == target or mid is atmost d distance apart, then we \\n            should stop searching, as we found an element, \\n            otherwise standard binary search, shorten our scope depending upon\\n            element is higher or lower.\\n            \\n            if no element found, then just do res++\\n            \\n        */\\n        for(int i : arr1){\\n            int low = 0;\\n            int high = arr2.length - 1;\\n            boolean found = false;\\n            \\n            while(low <= high){\\n                int mid = low + (high - low) / 2;\\n                if(arr2[mid] == i || Math.abs(arr2[mid] - i) <= d){\\n                    found = true;\\n                    break;\\n                }\\n                else if(arr2[mid] > i)\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n            \\n            if(!found)\\n                res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918815,
                "title": "python-binary-search-faster-than-91",
                "content": "An **Easy** question, while description is **Medium** to understand.\\n\\nFor every num in arr1, what we need to do is to find the closest num in arr2 to see if this is a valid number.\\n\\n```python\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        \"\"\"\\n        Runtime: 88 ms, faster than 91.26%\\n        Memory Usage: 14.1 MB, less than 9.91%\\n\\n        :param arr1: 1 <= arr1.length, arr2.length <= 500\\n                    -1000 <= arr1[i], arr2[j] <= 1000\\n                    0 <= d <= 100\\n        :param arr2:\\n        :param d:\\n        :return:\\n        \"\"\"\\n        if d == 0:\\n            return 0\\n        ret = 0\\n        arr2 = sorted(arr2)\\n        for num in arr1:\\n            lo, hi = 0, len(arr2) - 1\\n            valid = True\\n            while lo <= hi:\\n                mid = lo + (hi - lo) // 2\\n                if arr2[mid] == num or abs(num - arr2[mid]) <= d:\\n                    valid = False\\n                    break\\n                elif arr2[mid] < num:\\n                    lo = mid + 1\\n                else:\\n                    hi = mid - 1\\n            ret += valid\\n        return ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        \"\"\"\\n        Runtime: 88 ms, faster than 91.26%\\n        Memory Usage: 14.1 MB, less than 9.91%\\n\\n        :param arr1: 1 <= arr1.length, arr2.length <= 500\\n                    -1000 <= arr1[i], arr2[j] <= 1000\\n                    0 <= d <= 100\\n        :param arr2:\\n        :param d:\\n        :return:\\n        \"\"\"\\n        if d == 0:\\n            return 0\\n        ret = 0\\n        arr2 = sorted(arr2)\\n        for num in arr1:\\n            lo, hi = 0, len(arr2) - 1\\n            valid = True\\n            while lo <= hi:\\n                mid = lo + (hi - lo) // 2\\n                if arr2[mid] == num or abs(num - arr2[mid]) <= d:\\n                    valid = False\\n                    break\\n                elif arr2[mid] < num:\\n                    lo = mid + 1\\n                else:\\n                    hi = mid - 1\\n            ret += valid\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908455,
                "title": "java-binary-search-o-nlogn-logn",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int total = 0;\\n        for(int i = 0; i < arr1.length; i++) {\\n            if (!findDisFromArr(arr2, arr1[i] + d, arr1[i] - d)) {\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n    public boolean findDisFromArr(int[] arr, int top, int bottom) {\\n        int l = 0;\\n        int r = arr.length - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            if (arr[m] <= top && arr[m] >= bottom) {               \\n                return true;\\n            }\\n            else if(arr[m] < bottom) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int total = 0;\\n        for(int i = 0; i < arr1.length; i++) {\\n            if (!findDisFromArr(arr2, arr1[i] + d, arr1[i] - d)) {\\n                total++;\\n            }\\n        }\\n        return total;\\n    }\\n    public boolean findDisFromArr(int[] arr, int top, int bottom) {\\n        int l = 0;\\n        int r = arr.length - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            if (arr[m] <= top && arr[m] >= bottom) {               \\n                return true;\\n            }\\n            else if(arr[m] < bottom) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825087,
                "title": "java-two-pointers-easy-to-undestand",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int ans = arr1.length;\\n        int i = 0, j = 0;\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        while (i < arr1.length && j < arr2.length) {\\n            if (Math.abs(arr1[i] - arr2[j]) <= d) {\\n                i++;\\n                ans--;\\n            } else if (arr1[i] > arr2[j]) {\\n                j++;\\n            } else if (arr1[i] < arr2[j]) {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int ans = arr1.length;\\n        int i = 0, j = 0;\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        while (i < arr1.length && j < arr2.length) {\\n            if (Math.abs(arr1[i] - arr2[j]) <= d) {\\n                i++;\\n                ans--;\\n            } else if (arr1[i] > arr2[j]) {\\n                j++;\\n            } else if (arr1[i] < arr2[j]) {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476413,
                "title": "easiest-solution",
                "content": "This is a really easy problem. \\nThe only confusion you may face is due to the language of the question.\\n\\nAfter reading this solution and approach, you can solve this question in 2 mins or even less.\\n\\n**Question clarity:**\\n\\nIn the question you have to find how many elements in array 1 doesnot have any pair where |arr1[i]-arr2[j]| <= d.\\n\\nSo all we need to do is : \\n\\n**Approach** :\\n\\n1) We need to take a variable i.e. **res**  and initialise  it with the length of array1\\n2) Now for each element of array1, check if there is any element in array2 where |arr1[i]-arr2[j]| <= d this condition satisfies.\\n3) If you find any element in array2 where this condition is true, you have to reduce the **res** by 1 because we will not consider such element in arr1 where this condition is true\\n4) and also stop checking for this element \\n5) return result\\n\\n\\n**Code** : \\n\\n\\'\\'\\'\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count=arr1.length;\\n        for(int i=0;i<arr1.length;i++){\\n            for(int j=0;j<arr2.length;j++){\\n                int diff=Math.abs(arr1[i]-arr2[j]);\\n                if(diff<=d ){\\n                    count--;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\'\\'\\'\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count=arr1.length;\\n        for(int i=0;i<arr1.length;i++){\\n            for(int j=0;j<arr2.length;j++){\\n                int diff=Math.abs(arr1[i]-arr2[j]);\\n                if(diff<=d ){\\n                    count--;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1338617,
                "title": "using-binary-search-in-o-nlogn-time",
                "content": "Idea :\\n\\t\\t\\tSort the second array. Find the insert position (lower_bound) of each element of arr1 in the second array. Let it be **pos**. If ```arr1[i]-arr2[pos-1]  > d && arr2[pos]-arr[i] > d ```, then increment the ```count```. If the condition holds, this implies that all elements to the left and right are also greater than ```arr1[i]``` by ```d```.",
                "solutionTags": [],
                "code": "```arr1[i]-arr2[pos-1]  > d && arr2[pos]-arr[i] > d ```\n```count```\n```arr1[i]```\n```d```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120705,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        c=0\\n        for i in arr1:\\n            for j in arr2:\\n                if abs(i-j)<=d:\\n                    c+=1\\n                    break\\n        return len(arr1)-c",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        c=0\\n        for i in arr1:\\n            for j in arr2:\\n                if abs(i-j)<=d:\\n                    c+=1\\n                    break\\n        return len(arr1)-c",
                "codeTag": "Java"
            },
            {
                "id": 1099530,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int l1 = arr1.length;\\n        int l2 = arr2.length;\\n        \\n        int distance = l1;\\n        \\n        for (int i: arr1){\\n            for (int j: arr2){\\n                if(Math.abs(i - j) <= d){\\n                    distance -=1;\\n                    break;\\n                }\\n            }   \\n        }\\n        return distance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int l1 = arr1.length;\\n        int l2 = arr2.length;\\n        \\n        int distance = l1;\\n        \\n        for (int i: arr1){\\n            for (int j: arr2){\\n                if(Math.abs(i - j) <= d){\\n                    distance -=1;\\n                    break;\\n                }\\n            }   \\n        }\\n        return distance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092049,
                "title": "golang-solution-faster-than-100-with-explanation",
                "content": "The idea of this solution is to iterate through `arr1` and then inside each iteration iterate through `arr2`. If the absolute value of `arr1[i] - arr2[j]` is smaller than or equal to `d`, we know that `arr1[i]` can\\'t be added to the resulting counter, so we can just `break` from the loop.\\n\\nThere is a abs function because `math.Abs` takes longer. When using `math.Abs` we have to make `float64(arr1[i] - arr2[j])`, and then make the `int(math.Abs)`.\\n\\n```\\nfunc findTheDistanceValue(arr1 []int, arr2 []int, d int) int {\\n    res := 0\\n    shouldAdd := true\\n    for i := 0; i < len(arr1); i++ {\\n        for j := 0; j < len(arr2); j++ {\\n            if abs(arr1[i]-arr2[j]) <= d {\\n                shouldAdd = false\\n                break\\n            }\\n        }\\n        if shouldAdd {res++} else {shouldAdd = true}\\n    }\\n    return res\\n}\\n\\nfunc abs(n int) int {\\n    if n < 0 {\\n        return -n\\n    }\\n    return n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findTheDistanceValue(arr1 []int, arr2 []int, d int) int {\\n    res := 0\\n    shouldAdd := true\\n    for i := 0; i < len(arr1); i++ {\\n        for j := 0; j < len(arr2); j++ {\\n            if abs(arr1[i]-arr2[j]) <= d {\\n                shouldAdd = false\\n                break\\n            }\\n        }\\n        if shouldAdd {res++} else {shouldAdd = true}\\n    }\\n    return res\\n}\\n\\nfunc abs(n int) int {\\n    if n < 0 {\\n        return -n\\n    }\\n    return n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1067593,
                "title": "java-faster-than-100-o-nlogn-sort-sliding-window",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        var count = 0;\\n        var j = 0;\\n        for (int i = 0; i < arr1.length; i++) {\\n            var min = arr1[i] - d;\\n            var max = arr1[i] + d;\\n            while (j < arr2.length && arr2[j] < min) j++; //can be optimized with binary search\\n            if (isOutOfRange(arr2, j, min, max)) count++;\\n        }\\n        return count;\\n    }\\n    \\n    private static boolean isOutOfRange(int[] arr, int idx, int min, int max) {\\n        return idx == arr.length || !(min <= arr[idx] && arr[idx] <= max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr1);\\n        Arrays.sort(arr2);\\n        var count = 0;\\n        var j = 0;\\n        for (int i = 0; i < arr1.length; i++) {\\n            var min = arr1[i] - d;\\n            var max = arr1[i] + d;\\n            while (j < arr2.length && arr2[j] < min) j++; //can be optimized with binary search\\n            if (isOutOfRange(arr2, j, min, max)) count++;\\n        }\\n        return count;\\n    }\\n    \\n    private static boolean isOutOfRange(int[] arr, int idx, int min, int max) {\\n        return idx == arr.length || !(min <= arr[idx] && arr[idx] <= max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844558,
                "title": "python-one-line",
                "content": "```python\\nreturn sum([1 - any([abs(i-j) <= d for j in arr2]) for i in arr1])\\n```",
                "solutionTags": [],
                "code": "```python\\nreturn sum([1 - any([abs(i-j) <= d for j in arr2]) for i in arr1])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 749818,
                "title": "javascript-es6-1-line-with-reduce",
                "content": "```\\nvar findTheDistanceValue = function (arr1, arr2, d) {\\n  return arr1.reduce(\\n    (acc, cur) => (arr2.every((y) => Math.abs(cur - y) > d) ? acc + 1 : acc),\\n    0\\n  );\\n```\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findTheDistanceValue = function (arr1, arr2, d) {\\n  return arr1.reduce(\\n    (acc, cur) => (arr2.every((y) => Math.abs(cur - y) > d) ? acc + 1 : acc),\\n    0\\n  );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 734629,
                "title": "kotlin-simple-solution",
                "content": "```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun findTheDistanceValue(arr1: IntArray, arr2: IntArray, d: Int): Int {\\n     var ans = 0\\n    arr1.forEach { x ->\\n        var count = 0\\n        arr2.forEach { y ->\\n            if (abs(y - x) <= d )\\n                count++\\n        }\\n        if (count == 0)\\n            ans++\\n    }\\n    return ans\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun findTheDistanceValue(arr1: IntArray, arr2: IntArray, d: Int): Int {\\n     var ans = 0\\n    arr1.forEach { x ->\\n        var count = 0\\n        arr2.forEach { y ->\\n            if (abs(y - x) <= d )\\n                count++\\n        }\\n        if (count == 0)\\n            ans++\\n    }\\n    return ans\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720003,
                "title": "c-two-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    // Time: O(nlogn + mlogm)\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr1.begin(), arr1.end());\\n        sort(arr2.begin(), arr2.end());\\n        int i = 0;\\n        int j = 0;\\n        int res = 0;\\n        while (i < arr1.size() && j < arr2.size()) {\\n            if (arr1[i] > arr2[j]) {\\n                if (arr1[i] - arr2[j] > d) j++;\\n                else i++;\\n            } else {\\n                if (arr2[j] - arr1[i] > d) {\\n                    i++;\\n                    res++;\\n                } else i++;\\n            }\\n        }\\n        res += arr1.size() - i;\\n        return res;\\n    }\\n};\\n```\\n```\\nclass Solution2 {\\npublic:\\n    // Time: O(nlogm + mlogm)\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(), arr2.end());\\n        int res = 0;\\n        for (int i : arr1) {\\n            vector<int>::iterator up = upper_bound(arr2.begin(), arr2.end(), i + d);\\n            vector<int>::iterator low = lower_bound(arr2.begin(), arr2.end(), i - d);\\n            if (up == low) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time: O(nlogn + mlogm)\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr1.begin(), arr1.end());\\n        sort(arr2.begin(), arr2.end());\\n        int i = 0;\\n        int j = 0;\\n        int res = 0;\\n        while (i < arr1.size() && j < arr2.size()) {\\n            if (arr1[i] > arr2[j]) {\\n                if (arr1[i] - arr2[j] > d) j++;\\n                else i++;\\n            } else {\\n                if (arr2[j] - arr1[i] > d) {\\n                    i++;\\n                    res++;\\n                } else i++;\\n            }\\n        }\\n        res += arr1.size() - i;\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution2 {\\npublic:\\n    // Time: O(nlogm + mlogm)\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(), arr2.end());\\n        int res = 0;\\n        for (int i : arr1) {\\n            vector<int>::iterator up = upper_bound(arr2.begin(), arr2.end(), i + d);\\n            vector<int>::iterator low = lower_bound(arr2.begin(), arr2.end(), i - d);\\n            if (up == low) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679191,
                "title": "well-tortured-by-reading-again",
                "content": "I highly doubtly my English reading ability.\\n```\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int res = 0, diff = 0;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int n : arr2) set.add(n);\\n        for (int n : arr1) {\\n            Integer fl = set.floor(n), cl = set.ceiling(n);\\n            if (fl == null) diff = cl - n;\\n            else if (cl == null) diff = n - fl;\\n            else diff = Math.min(n - fl, cl - n);\\n            if (diff > d) res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int res = 0, diff = 0;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int n : arr2) set.add(n);\\n        for (int n : arr1) {\\n            Integer fl = set.floor(n), cl = set.ceiling(n);\\n            if (fl == null) diff = cl - n;\\n            else if (cl == null) diff = n - fl;\\n            else diff = Math.min(n - fl, cl - n);\\n            if (diff > d) res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 655554,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        return sum([sum([abs(i-j)>d for i in arr2])==len(arr2) for j in arr1])\\n```\\nif number of True matches length of arr2,  match += 1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        return sum([sum([abs(i-j)>d for i in arr2])==len(arr2) for j in arr1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602342,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n               boolean isElementMetDistanceCriteria = true;\\n        int count = 0;\\n        for (int i = 0; i < arr1.length; i++) {\\n            isElementMetDistanceCriteria = true;\\n            for (int j = 0; j < arr2.length; j++) {\\n                if (Math.abs(arr1[i] - arr2[j]) <= d) {\\n                    isElementMetDistanceCriteria = false;\\n                    break;\\n                }\\n\\n            }\\n\\n            if (isElementMetDistanceCriteria){\\n                count++;\\n            }\\n\\n\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n               boolean isElementMetDistanceCriteria = true;\\n        int count = 0;\\n        for (int i = 0; i < arr1.length; i++) {\\n            isElementMetDistanceCriteria = true;\\n            for (int j = 0; j < arr2.length; j++) {\\n                if (Math.abs(arr1[i] - arr2[j]) <= d) {\\n                    isElementMetDistanceCriteria = false;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 560934,
                "title": "python-o-nlogn-using-binary-search",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2 = sorted(arr2)\\n        count = 0\\n        for n in arr1:\\n            mid = bisect.bisect(arr2,n)\\n            if (0<=mid<len(arr2) and abs(arr2[mid]-n)<=d) or (0<=mid-1<len(arr2) and abs(arr2[mid-1]-n)<=d):\\n                continue\\n            else:\\n                count+=1\\n        return count",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2 = sorted(arr2)\\n        count = 0\\n        for n in arr1:\\n            mid = bisect.bisect(arr2,n)\\n            if (0<=mid<len(arr2) and abs(arr2[mid]-n)<=d) or (0<=mid-1<len(arr2) and abs(arr2[mid-1]-n)<=d):\\n                continue\\n            else:\\n                count+=1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 548444,
                "title": "c-binary-search",
                "content": "```\\nint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int n = arr1.size(), ans = 0;\\n        sort(arr2.begin(),arr2.end());\\n        for (auto x: arr1) {\\n            auto pt = lower_bound(arr2.begin(),arr2.end(),x);\\n            if (pt!=arr2.end()) {\\n                if (arr2[pt-arr2.begin()]-x<=d)\\n                    continue;\\n            }\\n            if (pt!=arr2.begin()) {\\n                --pt;\\n                if (x-arr2[pt-arr2.begin()]<=d)\\n                    continue;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int n = arr1.size(), ans = 0;\\n        sort(arr2.begin(),arr2.end());\\n        for (auto x: arr1) {\\n            auto pt = lower_bound(arr2.begin(),arr2.end(),x);\\n            if (pt!=arr2.end()) {\\n                if (arr2[pt-arr2.begin()]-x<=d)\\n                    continue;\\n            }\\n            if (pt!=arr2.begin()) {\\n                --pt;\\n                if (x-arr2[pt-arr2.begin()]<=d)\\n                    continue;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548013,
                "title": "c-simple-solution-using-binary-search",
                "content": "```\\npublic class Solution {\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Array.Sort(arr2);\\n        int result = 0;\\n        foreach (int x in arr1) {\\n            int index = ClosestBinarySearch(arr2, x);\\n            if (Math.Abs(x - arr2[index]) > d)\\n                result++;\\n        }\\n        return result;\\n    }\\n    \\n    private int ClosestBinarySearch(int[] arr, int x) {\\n        int i = 0;\\n        int j = arr.Length - 1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (arr[mid] > x)\\n                j = mid - 1;\\n            else if (arr[mid] < x)\\n                i = mid + 1;\\n            else\\n                return mid;\\n        }\\n        if (j < 0)\\n            return i;\\n        if (i == arr.Length)\\n            return j;\\n        return Math.Abs(arr[i] - x) < Math.Abs(arr[j] - x) ? i : j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Array.Sort(arr2);\\n        int result = 0;\\n        foreach (int x in arr1) {\\n            int index = ClosestBinarySearch(arr2, x);\\n            if (Math.Abs(x - arr2[index]) > d)\\n                result++;\\n        }\\n        return result;\\n    }\\n    \\n    private int ClosestBinarySearch(int[] arr, int x) {\\n        int i = 0;\\n        int j = arr.Length - 1;\\n        while (i <= j) {\\n            int mid = i + (j - i) / 2;\\n            if (arr[mid] > x)\\n                j = mid - 1;\\n            else if (arr[mid] < x)\\n                i = mid + 1;\\n            else\\n                return mid;\\n        }\\n        if (j < 0)\\n            return i;\\n        if (i == arr.Length)\\n            return j;\\n        return Math.Abs(arr[i] - x) < Math.Abs(arr[j] - x) ? i : j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547867,
                "title": "python-linearithmic-sol-by-bisection-90-w-comment",
                "content": "Python linearithmic sol by bisection\\n\\n---\\n**Implementation**:\\n\\n```\\nfrom bisect import bisect_left, bisect_right\\n\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        \\n        # pre-processing, keep arr2 in ascending order\\n        arr2.sort()\\n        \\n        counter_out_of_range_d = 0\\n        \\n        for element in arr1:\\n            \\n            left = bisect_left( arr2, element - d )\\n            right = bisect_right( arr2, element + d )\\n            \\n            if left == right:\\n                \\n                # if e-d, e+d is at the same index, then element e is out of range d\\n                counter_out_of_range_d += 1\\n                \\n        return counter_out_of_range_d\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about bisection.](https://docs.python.org/3.8/library/bisect.html)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\n\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        \\n        # pre-processing, keep arr2 in ascending order\\n        arr2.sort()\\n        \\n        counter_out_of_range_d = 0\\n        \\n        for element in arr1:\\n            \\n            left = bisect_left( arr2, element - d )\\n            right = bisect_right( arr2, element + d )\\n            \\n            if left == right:\\n                \\n                # if e-d, e+d is at the same index, then element e is out of range d\\n                counter_out_of_range_d += 1\\n                \\n        return counter_out_of_range_d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547150,
                "title": "java-sort-binary-search",
                "content": "1. Quick sort arr2: NlogN\\n2. For each item in arr1, binary search it in arr2. Compare the distance from its neighhours. NlogN.\\n3. Total time: O(NlogN); Space: O(1);\\n```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int n = arr2.length;\\n        Arrays.sort(arr2);\\n        \\n        int count = 0;\\n        for (int it: arr1){\\n            int idx = search(arr2, 0, n-1, it);\\n            if (idx < n && Math.abs(it-arr2[idx]) <= d||\\n                idx > 0 && Math.abs(it-arr2[idx-1]) <= d){\\n                count ++;\\n            }\\n        }\\n        \\n        return arr1.length - count;\\n    }\\n    \\n    private int search(int[] arr, int l, int r, int it){\\n        if (l > r) return l;\\n        \\n        int m = l + (r-l)/2;\\n        if (it == arr[m]){\\n            return m;\\n        } else if (it < arr[m]){\\n            return search(arr, l, m-1, it);\\n        } else {\\n            return search(arr, m+1, r, it);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int n = arr2.length;\\n        Arrays.sort(arr2);\\n        \\n        int count = 0;\\n        for (int it: arr1){\\n            int idx = search(arr2, 0, n-1, it);\\n            if (idx < n && Math.abs(it-arr2[idx]) <= d||\\n                idx > 0 && Math.abs(it-arr2[idx-1]) <= d){\\n                count ++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 546504,
                "title": "c-brute-force",
                "content": "```csharp\\npublic int FindTheDistanceValue(int[] arr1, int[] arr2, int d) \\n{\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < arr1.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < arr2.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(Math.Abs(arr1[i] - arr2[j]) <= d)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr1.Length - count;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int FindTheDistanceValue(int[] arr1, int[] arr2, int d) \\n{\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < arr1.Length; i++)\\n\\t{\\n\\t\\tfor(int j = 0; j < arr2.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif(Math.Abs(arr1[i] - arr2[j]) <= d)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn arr1.Length - count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091254,
                "title": "easy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    let count=0\\n    for(let i=0;i<arr1.length;i++){\\n        let c=0\\n        for(let j=0;j<arr2.length;j++){\\n            arr1[i]-arr2[j]\\n            const dis = Math.abs(arr1[i]-arr2[j]);\\n            if(dis<=d){\\n                c=1\\n                break;\\n            }\\n           \\n        }\\n        if(c===0){\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    let count=0\\n    for(let i=0;i<arr1.length;i++){\\n        let c=0\\n        for(let j=0;j<arr2.length;j++){\\n            arr1[i]-arr2[j]\\n            const dis = Math.abs(arr1[i]-arr2[j]);\\n            if(dis<=d){\\n                c=1\\n                break;\\n            }\\n           \\n        }\\n        if(c===0){\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091239,
                "title": "easy-js-solution-with-proper-comment",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    // set two variable count,flag\\n    let count = 0\\n    let flag ;\\n\\n    for(let i=0;i<arr1.length;i++){\\n        // every iteration flag will be 0\\n        flag = 0;\\n        for(let j=0;j<arr2.length;j++){\\n\\n            // if the absolute difference is lessthan or equal to d then flag set 1 and break\\n            if(Math.abs(arr1[i]-arr2[j]) <= d){\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        // count only increase when flag = 0 ie,\\n        if(flag == 0){\\n            count++\\n        }\\n    }\\n\\n    //  return the count\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    // set two variable count,flag\\n    let count = 0\\n    let flag ;\\n\\n    for(let i=0;i<arr1.length;i++){\\n        // every iteration flag will be 0\\n        flag = 0;\\n        for(let j=0;j<arr2.length;j++){\\n\\n            // if the absolute difference is lessthan or equal to d then flag set 1 and break\\n            if(Math.abs(arr1[i]-arr2[j]) <= d){\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        // count only increase when flag = 0 ie,\\n        if(flag == 0){\\n            count++\\n        }\\n    }\\n\\n    //  return the count\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732660,
                "title": "easy-solution-1-ms-100-beats-fully-explained",
                "content": "# Approach\\nThe given problem requires finding the distance value between two arrays, `arr1` and `arr2`. The distance value is defined as the number of elements in `arr1` that do not have any element in `arr2` within a certain distance `d`.\\n\\nTo solve this problem, we can use a simple approach:\\n\\n1. Initialize a variable `cnt` to keep track of the count of elements in `arr1` that satisfy the distance condition.\\n2. Iterate through each element, `value`, in `arr1`.\\n3. For each element in `arr1`, we need to check if there exists any element in `arr2` that satisfies the distance condition.\\n   - Create a helper function, `find`, which takes `arr2`, `value`, and `d` as parameters.\\n   - Inside the `find` function, iterate through each element, `num`, in `arr2`.\\n   - Check if the absolute difference between `value` and `num` is less than or equal to `d`. If it is, return `false` as the distance condition is not satisfied.\\n   - If no element in `arr2` satisfies the condition, return `true` from the `find` function.\\n4. If the `find` function returns `true` for an element in `arr1`, increment `cnt` by 1.\\n5. After iterating through all elements in `arr1`, return the value of `cnt` as the distance value between the two arrays.\\n\\nThis approach iterates through each element in `arr1` and checks if there is any element in `arr2` that satisfies the distance condition. The overall time complexity of this solution is O(n*m), where n and m are the lengths of `arr1` and `arr2`, respectively.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int cnt = 0;\\n        for(int value : arr1)\\n            if(find(arr2, value, d)) cnt++;\\n        return cnt;\\n    }\\n\\n    public boolean find(int[] arr2, int value, int d){\\n        for(int num : arr2)\\n            if(-d + num <= value && value <= num + d) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int cnt = 0;\\n        for(int value : arr1)\\n            if(find(arr2, value, d)) cnt++;\\n        return cnt;\\n    }\\n\\n    public boolean find(int[] arr2, int value, int d){\\n        for(int num : arr2)\\n            if(-d + num <= value && value <= num + d) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640948,
                "title": "easy-peasy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int n = arr1.size(), m = arr2.size();\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int flag = 0;\\n            for(int j=0; j<m; j++){\\n                if(abs(arr1[i] - arr2[j]) <= d){\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int n = arr1.size(), m = arr2.size();\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int flag = 0;\\n            for(int j=0; j<m; j++){\\n                if(abs(arr1[i] - arr2[j]) <= d){\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460385,
                "title": "easy-java-solution-using-two-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count=arr1.length;\\n                for (int i=0; i<arr1.length; i++) {\\n            for (int j=0; j<arr2.length; j++) {\\n                if (Math.abs(arr1[i] - arr2[j]) <= d) {\\n                    count -= 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count=arr1.length;\\n                for (int i=0; i<arr1.length; i++) {\\n            for (int j=0; j<arr2.length; j++) {\\n                if (Math.abs(arr1[i] - arr2[j]) <= d) {\\n                    count -= 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355586,
                "title": "find-the-distance-value-between-two-arrays-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int i, j, count=0;\\n        for(i=0 ; i<arr1.size() ; i++)\\n        {\\n            for(j=0 ; j<arr2.size() ; j++)\\n            {\\n                if(abs(arr1[i]-arr2[j])<=d)\\n                    break;\\n            }\\n            if(j==arr2.size())\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int i, j, count=0;\\n        for(i=0 ; i<arr1.size() ; i++)\\n        {\\n            for(j=0 ; j<arr2.size() ; j++)\\n            {\\n                if(abs(arr1[i]-arr2[j])<=d)\\n                    break;\\n            }\\n            if(j==arr2.size())\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300431,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int ans=0;\\n        for (int i =0;i<arr1.length;i++){\\n            for (int j =0;j<arr2.length;j++){\\n                if (Math.abs(arr1[i]-arr2[j])<=d){\\n                   ans++;\\n                   break;\\n                }\\n            }\\n        }\\n        return (arr1.length-ans);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int ans=0;\\n        for (int i =0;i<arr1.length;i++){\\n            for (int j =0;j<arr2.length;j++){\\n                if (Math.abs(arr1[i]-arr2[j])<=d){\\n                   ans++;\\n                   break;\\n                }\\n            }\\n        }\\n        return (arr1.length-ans);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266230,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int ans=0;\\n        for (int i =0;i<arr1.length;i++){\\n            for (int j =0;j<arr2.length;j++){\\n                if (Math.abs(arr1[i]-arr2[j])<=d){\\n                   ans++;\\n                   break;\\n                }\\n            }\\n        }\\n        return (arr1.length-ans);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int ans=0;\\n        for (int i =0;i<arr1.length;i++){\\n            for (int j =0;j<arr2.length;j++){\\n                if (Math.abs(arr1[i]-arr2[j])<=d){\\n                   ans++;\\n                   break;\\n                }\\n            }\\n        }\\n        return (arr1.length-ans);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229472,
                "title": "3ms-faster-than-99-46-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int res=0;\\n        for(auto it:arr1)\\n        {\\n            res++;\\n            for(auto i:arr2)\\n                if(abs(it-i)<=d)\\n                {\\n                    res--;\\n                    break;\\n                }\\n                \\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int res=0;\\n        for(auto it:arr1)\\n        {\\n            res++;\\n            for(auto i:arr2)\\n                if(abs(it-i)<=d)\\n                {\\n                    res--;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3216753,
                "title": "easy-approach-binary-search-explanation-o-nlogn-o-1-95-beats-in-time-2nd-method-brute-force-exp",
                "content": "# Intuition\\nSort both the arrays and apply binary search\\n\\n# Approach\\nSort the arr1 and arr2\\nApply binary search to find the element is in range of +- d \\nIf yes dont add it to result\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int res = 0;\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n        for(auto var:arr1)\\n        {\\n            int start = 0;\\n            int end = arr2.size()-1;\\n            int mid = (start + end)/2;\\n            res++;\\n            while(start <= end)\\n            {\\n                mid = (start + end)/2;\\n                if((arr2[mid] <= (d+var))  and (arr2[mid] >= (var-d)))\\n                {\\n                    res--;\\n                    break;\\n                }\\n                else if(arr2[mid] > (d+var))                    end = mid-1;\\n                else                                          start = mid+1;\\n            }\\n        }\\n        return res;\\n        //Brute force approach\\n        // int res = 0;\\n        // for(auto var1:arr1)\\n        // {\\n        //     res++;\\n        //     for(auto var2:arr2)\\n        //     {\\n        //         if(abs(var1-var2) <= d)\\n        //         {\\n        //             res--;\\n        //             break;\\n        //         }\\n        //     }\\n        // }\\n        // return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int res = 0;\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n        for(auto var:arr1)\\n        {\\n            int start = 0;\\n            int end = arr2.size()-1;\\n            int mid = (start + end)/2;\\n            res++;\\n            while(start <= end)\\n            {\\n                mid = (start + end)/2;\\n                if((arr2[mid] <= (d+var))  and (arr2[mid] >= (var-d)))\\n                {\\n                    res--;\\n                    break;\\n                }\\n                else if(arr2[mid] > (d+var))                    end = mid-1;\\n                else                                          start = mid+1;\\n            }\\n        }\\n        return res;\\n        //Brute force approach\\n        // int res = 0;\\n        // for(auto var1:arr1)\\n        // {\\n        //     res++;\\n        //     for(auto var2:arr2)\\n        //     {\\n        //         if(abs(var1-var2) <= d)\\n        //         {\\n        //             res--;\\n        //             break;\\n        //         }\\n        //     }\\n        // }\\n        // return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196994,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\npublic class Solution \\n{\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) \\n    {\\n        int result = 0;\\n        Array.Sort(arr2);\\n        foreach(var num in arr1)\\n        {\\n            int index1 = Array.BinarySearch(arr2, num + d), index2 = Array.BinarySearch(arr2, num - d);\\n            if(index1 < 0) \\n                index1 = ~index1 - 1;\\n            if(index2 < 0) \\n                index2 = ~index2;\\n            if(index2 > index1)\\n                result++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int FindTheDistanceValue(int[] arr1, int[] arr2, int d) \\n    {\\n        int result = 0;\\n        Array.Sort(arr2);\\n        foreach(var num in arr1)\\n        {\\n            int index1 = Array.BinarySearch(arr2, num + d), index2 = Array.BinarySearch(arr2, num - d);\\n            if(index1 < 0) \\n                index1 = ~index1 - 1;\\n            if(index2 < 0) \\n                index2 = ~index2;\\n            if(index2 > index1)\\n                result++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145717,
                "title": "python-3-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe sort the second array and perform binary search on it $$M$$ times in order to count the results.\\n\\n# Complexity\\n- Time complexity: $$O(min(N\\\\log(N), M\\\\log(N)))$$, where $$N$$ is the size of `arr2` and $$M$$ is the size of ``arr1``. First term is from sorting `arr2` and the second term is from querying the sorted array $$M$$ times.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$, probably taken by Python for the sorting.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2=sorted(arr2)\\n        res=0\\n        for num in arr1:\\n            idx = bisect.bisect_left(arr2, num)\\n            lower_within_limits = abs(arr2[min(len(arr2)-1, idx)]-num)>d\\n            higher_within_limits = abs(arr2[max(0, idx-1)]-num)>d\\n            if lower_within_limits and higher_within_limits:\\n                res+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2=sorted(arr2)\\n        res=0\\n        for num in arr1:\\n            idx = bisect.bisect_left(arr2, num)\\n            lower_within_limits = abs(arr2[min(len(arr2)-1, idx)]-num)>d\\n            higher_within_limits = abs(arr2[max(0, idx-1)]-num)>d\\n            if lower_within_limits and higher_within_limits:\\n                res+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069364,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int ans,z=0;\\n        for(int i=0;i<arr1.size();i++)\\n        {\\n            ans=0;\\n            for(int j=0;j<arr2.size();j++)\\n            {\\n                int a=abs(arr1[i]-arr2[j]);\\n                if(a<=d) ans++;\\n            }\\n            if(ans==0) z++;\\n        }\\n        return z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int ans,z=0;\\n        for(int i=0;i<arr1.size();i++)\\n        {\\n            ans=0;\\n            for(int j=0;j<arr2.size();j++)\\n            {\\n                int a=abs(arr1[i]-arr2[j]);\\n                if(a<=d) ans++;\\n            }\\n            if(ans==0) z++;\\n        }\\n        return z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021257,
                "title": "easy-to-understand-for-python-solve",
                "content": "\\n# Complexity\\n- Time comple: 94.12 %\\n- Space complexity: 80 %\\n# Understanding\\n- First I have sort arr2.\\n- Then iterate arr1.\\n- Search element that you need (BSA)\\n- If there is no such value, increase the value of c by 1.\\n- Loop until the element arr1 is finished.\\n\\n<h1><a href=\"https://leetcode.com/MAMuhammad571/\">My account<a></h1>\\n\\n# Code\\n```\\nclass Solution:\\n    def is_left(self, n: int, arr: list[int], d: int):\\n        l, r = 0, len(arr)-1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if abs(arr[m] - n) <= d:\\n                return True\\n            elif arr[m] > n:\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return False\\n\\n    def is_right(self, n: int, arr: list[int], d: int):\\n        l, r = 0, len(arr)-1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if abs(arr[m] - n) <= d:\\n                return True\\n            elif arr[m] < n:\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return False\\n\\n    def findTheDistanceValue(self, arr1: list[int], arr2: list[int], d: int) -> int:\\n        arr2.sort()\\n        c = 0\\n        for i in arr1:\\n            if not self.is_left(i, arr2, d):\\n                if not self.is_right(i, arr2, d):\\n                    print(i)\\n                    c += 1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def is_left(self, n: int, arr: list[int], d: int):\\n        l, r = 0, len(arr)-1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if abs(arr[m] - n) <= d:\\n                return True\\n            elif arr[m] > n:\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return False\\n\\n    def is_right(self, n: int, arr: list[int], d: int):\\n        l, r = 0, len(arr)-1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if abs(arr[m] - n) <= d:\\n                return True\\n            elif arr[m] < n:\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return False\\n\\n    def findTheDistanceValue(self, arr1: list[int], arr2: list[int], d: int) -> int:\\n        arr2.sort()\\n        c = 0\\n        for i in arr1:\\n            if not self.is_left(i, arr2, d):\\n                if not self.is_right(i, arr2, d):\\n                    print(i)\\n                    c += 1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972590,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func findTheDistanceValue(_ arr1: [Int], _ arr2: [Int], _ d: Int) -> Int {\\n        \\n        let a = arr2.sorted()\\n        \\n        func f(_ n: Int) -> Bool {\\n            guard abs(n - a[0]) > d, abs(n - a[a.count - 1]) > d else { return false }\\n            \\n            var l = 0\\n            var r = a.count - 1\\n            \\n            while l <= r {\\n                let m = (l + r) / 2\\n                if abs(n - a[m]) <= d { return false }\\n                if a[m] < n { l = m + 1 }\\n                else { r = m - 1 }\\n            }\\n            \\n            return true\\n        }\\n        \\n        return arr1.filter(f).count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findTheDistanceValue(_ arr1: [Int], _ arr2: [Int], _ d: Int) -> Int {\\n        \\n        let a = arr2.sorted()\\n        \\n        func f(_ n: Int) -> Bool {\\n            guard abs(n - a[0]) > d, abs(n - a[a.count - 1]) > d else { return false }\\n            \\n            var l = 0\\n            var r = a.count - 1\\n            \\n            while l <= r {\\n                let m = (l + r) / 2\\n                if abs(n - a[m]) <= d { return false }\\n                if a[m] < n { l = m + 1 }\\n                else { r = m - 1 }\\n            }\\n            \\n            return true\\n        }\\n        \\n        return arr1.filter(f).count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950539,
                "title": "c-binary-search-solution",
                "content": "# Understanding the problem\\n\\nFound [this](https://leetcode.com/problems/find-the-distance-value-between-two-arrays/discussion/comments/1566434) explanation on Discussion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- sorting arr2[ ] and checking if there is any element arr1[ i ] in between arr2[ i ] - d and arr2[ i ] + d\\n- if there is any element in between then we\\'ll reject that arr1[ i ] (will not count).\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(), arr2.end());\\n        int res=0;\\n        for(auto n : arr1){\\n            auto i = lower_bound(arr2.begin(), arr2.end(), n - d);\\n            auto j = upper_bound(arr2.begin(), arr2.end(), n + d);\\n            if(i == j) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(), arr2.end());\\n        int res=0;\\n        for(auto n : arr1){\\n            auto i = lower_bound(arr2.begin(), arr2.end(), n - d);\\n            auto j = upper_bound(arr2.begin(), arr2.end(), n + d);\\n            if(i == j) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932917,
                "title": "c-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    bool solve(int aarr,vector<int> arr2, int d)\\n    {\\n           for(int j=0;j<arr2.size();j++)\\n            {\\n                 if((abs(aarr-arr2[j])>d)==false)\\n                 {\\n                    return false;\\n                 }\\n            }return true;\\n    }\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) \\n    { int count=0;int temp=0;\\n        for(int i=0;i<arr1.size();i++)\\n        {  \\n            if(solve(arr1[i],arr2,d)==true)\\n            {\\n                count++;\\n            }\\n            \\n        }return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool solve(int aarr,vector<int> arr2, int d)\\n    {\\n           for(int j=0;j<arr2.size();j++)\\n            {\\n                 if((abs(aarr-arr2[j])>d)==false)\\n                 {\\n                    return false;\\n                 }\\n            }return true;\\n    }\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) \\n    { int count=0;int temp=0;\\n        for(int i=0;i<arr1.size();i++)\\n        {  \\n            if(solve(arr1[i],arr2,d)==true)\\n            {\\n                count++;\\n            }\\n            \\n        }return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874468,
                "title": "java-99-45-faster-solution",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count=0;\\n        int x=0;\\n        for(int i=0;i<arr1.length;i++){\\n            x=0;\\n            for(int j=0;j<arr2.length;j++){\\n                int diff=Math.abs(arr1[i]-arr2[j]);\\n                if(diff<=d){\\n                    j=arr2.length;\\n                }\\n                else{\\n                    x++;\\n                }\\n            }\\n            if(x==arr2.length){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count=0;\\n        int x=0;\\n        for(int i=0;i<arr1.length;i++){\\n            x=0;\\n            for(int j=0;j<arr2.length;j++){\\n                int diff=Math.abs(arr1[i]-arr2[j]);\\n                if(diff<=d){\\n                    j=arr2.length;\\n                }\\n                else{\\n                    x++;\\n                }\\n            }\\n            if(x==arr2.length){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855151,
                "title": "brute-force-and-binary-search-optimization",
                "content": "Count every arr1 element where the ***difference between arr1 element and every arr2 element is bigger than d***.\\n```ruby\\ndef find_the_distance_value(arr1, arr2, d)\\n  arr1.count { |num| arr2.none? { |n| n.between?(num - d, num + d) } }\\nend\\n```\\n\\n```ruby\\ndef find_the_distance_value(arr1, arr2, d)\\n  arr1.count { |num| arr2.all? { |num2| num2 < num - d || num2 > num + d } }\\nend\\n```\\nBinary search optimization\\n```ruby\\ndef find_the_distance_value(arr1, arr2, d)\\n  arr2.sort!\\n  arr1.count { |num| valid?(arr2, num - d, num + d) }\\nend\\n\\ndef valid?(arr, lower_bound, upper_bound)\\n  left = 0\\n  right = arr.length - 1\\n    \\n  while left <= right\\n    mid = (left + right)/2\\n      \\n    if arr[mid] >= lower_bound && arr[mid] <= upper_bound\\n      return false\\n    elsif arr[mid] >= lower_bound\\n      right = mid - 1\\n    else\\n      left = mid + 1\\n    end\\n  end\\n    \\n  true\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```ruby\\ndef find_the_distance_value(arr1, arr2, d)\\n  arr1.count { |num| arr2.none? { |n| n.between?(num - d, num + d) } }\\nend\\n```\n```ruby\\ndef find_the_distance_value(arr1, arr2, d)\\n  arr1.count { |num| arr2.all? { |num2| num2 < num - d || num2 > num + d } }\\nend\\n```\n```ruby\\ndef find_the_distance_value(arr1, arr2, d)\\n  arr2.sort!\\n  arr1.count { |num| valid?(arr2, num - d, num + d) }\\nend\\n\\ndef valid?(arr, lower_bound, upper_bound)\\n  left = 0\\n  right = arr.length - 1\\n    \\n  while left <= right\\n    mid = (left + right)/2\\n      \\n    if arr[mid] >= lower_bound && arr[mid] <= upper_bound\\n      return false\\n    elsif arr[mid] >= lower_bound\\n      right = mid - 1\\n    else\\n      left = mid + 1\\n    end\\n  end\\n    \\n  true\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2840406,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n  let res = 0;\\n    for(let i =0; i<arr1.length; i++){\\n      let sum = 0;\\n      for(let j = 0; j<arr2.length; j++){\\n        if(Math.abs(arr1[i]-arr2[j]) <=d){\\n          j = arr2.length;\\n        } else{\\n            sum++;\\n        }\\n       \\n      }\\n     if(sum === arr2.length){\\n       res++\\n     }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n  let res = 0;\\n    for(let i =0; i<arr1.length; i++){\\n      let sum = 0;\\n      for(let j = 0; j<arr2.length; j++){\\n        if(Math.abs(arr1[i]-arr2[j]) <=d){\\n          j = arr2.length;\\n        } else{\\n            sum++;\\n        }\\n       \\n      }\\n     if(sum === arr2.length){\\n       res++\\n     }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828187,
                "title": "c-solution-3-approaches-brute-force-two-pointers-binary-search",
                "content": "**Brute Force: Using Two For Loops**\\nTime Complexity ----> O(N*M), N and M are size of arr1 and arr2\\nAuxilary Space ------> O(1)\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int cnt = 0;\\n\\n        for(int i=0;i<arr1.size();i++){\\n            bool change = true;\\n            for(int j=0;j<arr2.size();j++){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    change = false;\\n                    break;\\n                }\\n            }\\n            if(change == true)\\n                cnt++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Two Pointer Approach**\\nTime Complexity : O(NlogN), N is array with maximum size\\nAuxilary Space: O(1)\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n        int cnt = arr1.size();\\n\\n        int i=0;\\n        int j=0;\\n\\n        while(i<arr1.size() && j<arr2.size()){\\n            if(abs(arr1[i]-arr2[j])<=d){\\n                cnt--;\\n                i++;\\n            }\\n            else if(arr1[i]>arr2[j])\\n                j++;\\n            else   \\n                i++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Binary Search Approach**\\nTime Complexity : O(NlogN), N is size of arr2\\nAuxilary Space: O(1)\\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int> &arr2, int target, int d){\\n        int start=0;\\n        int end=arr2.size()-1;\\n\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(abs(arr2[mid]-target)<=d)\\n                return false;\\n            else if(arr2[mid]>target)\\n                end = mid-1;\\n            else    \\n                start = mid+1; \\n        }\\n        return true;\\n    }\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(),arr2.end());\\n        \\n        int cnt = 0;\\n        for(auto num: arr1)\\n            if(isValid(arr2,num,d))\\n                cnt++;\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int cnt = 0;\\n\\n        for(int i=0;i<arr1.size();i++){\\n            bool change = true;\\n            for(int j=0;j<arr2.size();j++){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    change = false;\\n                    break;\\n                }\\n            }\\n            if(change == true)\\n                cnt++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n        int cnt = arr1.size();\\n\\n        int i=0;\\n        int j=0;\\n\\n        while(i<arr1.size() && j<arr2.size()){\\n            if(abs(arr1[i]-arr2[j])<=d){\\n                cnt--;\\n                i++;\\n            }\\n            else if(arr1[i]>arr2[j])\\n                j++;\\n            else   \\n                i++;\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int> &arr2, int target, int d){\\n        int start=0;\\n        int end=arr2.size()-1;\\n\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(abs(arr2[mid]-target)<=d)\\n                return false;\\n            else if(arr2[mid]>target)\\n                end = mid-1;\\n            else    \\n                start = mid+1; \\n        }\\n        return true;\\n    }\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(),arr2.end());\\n        \\n        int cnt = 0;\\n        for(auto num: arr1)\\n            if(isValid(arr2,num,d))\\n                cnt++;\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780913,
                "title": "python-amortized-in-o-n-m-99-79-time",
                "content": "We first save all elements in dict `D` with compression.\\nWith the help of this step we can easily find the neighbors without seeing every element in arr1.\\nFor an instance, d=3\\n```\\n1 -> 0\\n2 -> 0\\n3 -> 1\\n4 -> 1\\n5 -> 1\\n6 -> 2\\n7 -> 2\\n```\\nWe can just check the element in `D[1]` if we want to find the neighbors of `4`.\\nHowever, you might see that `1, 7` are also answers. So we check `D[4//3-1] D[4//3] D[4//3+1]` to make sure we cover every answer.\\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        D = {}\\n        w = max(d,1)\\n        for n in arr2:\\n            if(n//w in D):\\n                D[n//w].append(n) \\n            else:\\n                D[n//w] = [n]\\n        ans = 0\\n        for n in arr1:\\n            flag = False\\n            if(n//w in D):\\n                for cand in D[n//w]:\\n                    if(abs(cand-n)<=d):\\n                        flag = True\\n                        break\\n            if(flag==False and n//w -1 in D):\\n                for cand in D[n//w-1]:\\n                    if(abs(cand-n)<=d):\\n                        flag = True\\n                        break\\n            if(flag==False and n//w +1 in D):\\n                for cand in D[n//w+1]:\\n                    if(abs(cand-n)<=d):\\n                        flag = True\\n                        break\\n            if(flag==False):\\n                ans += 1\\n        return ans\\n\\t```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\n1 -> 0\\n2 -> 0\\n3 -> 1\\n4 -> 1\\n5 -> 1\\n6 -> 2\\n7 -> 2\\n```\n```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        D = {}\\n        w = max(d,1)\\n        for n in arr2:\\n            if(n//w in D):\\n                D[n//w].append(n) \\n            else:\\n                D[n//w] = [n]\\n        ans = 0\\n        for n in arr1:\\n            flag = False\\n            if(n//w in D):\\n                for cand in D[n//w]:\\n                    if(abs(cand-n)<=d):\\n                        flag = True\\n                        break\\n            if(flag==False and n//w -1 in D):\\n                for cand in D[n//w-1]:\\n                    if(abs(cand-n)<=d):\\n                        flag = True\\n                        break\\n            if(flag==False and n//w +1 in D):\\n                for cand in D[n//w+1]:\\n                    if(abs(cand-n)<=d):\\n                        flag = True\\n                        break\\n            if(flag==False):\\n                ans += 1\\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2705620,
                "title": "simple-solution-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int cnt=0;\\n        for(auto it: arr1){\\n            int flag=0;\\n            for(auto it1:arr2){\\n                if(abs(it-it1) >d){\\n                    flag=1;\\n                }\\n                else{\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag==1){\\n                cnt++;\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int cnt=0;\\n        for(auto it: arr1){\\n            int flag=0;\\n            for(auto it1:arr2){\\n                if(abs(it-it1) >d){\\n                    flag=1;\\n                }\\n                else{\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag==1){\\n                cnt++;\\n            }\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646423,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool isValid(int num,vector<int> &arr,int d){\\n     int l=0,h=arr.size()-1;\\n     while(l<=h){\\n         int mid=l+(h-l)/2;\\n         if(abs(num-arr[mid])<=d){\\n             return false;\\n         }\\n         else if(arr[mid]<num){\\n             l=mid+1;\\n         }\\n         else{\\n             h=mid-1;\\n         }\\n     }\\n     return true;\\n }\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n       int cnt=0;\\n       sort(arr2.begin(),arr2.end());\\n       for(int num:arr1){\\n           if(isValid(num,arr2,d)){\\n               cnt++;\\n           }\\n       }\\n       return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool isValid(int num,vector<int> &arr,int d){\\n     int l=0,h=arr.size()-1;\\n     while(l<=h){\\n         int mid=l+(h-l)/2;\\n         if(abs(num-arr[mid])<=d){\\n             return false;\\n         }\\n         else if(arr[mid]<num){\\n             l=mid+1;\\n         }\\n         else{\\n             h=mid-1;\\n         }\\n     }\\n     return true;\\n }\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n       int cnt=0;\\n       sort(arr2.begin(),arr2.end());\\n       for(int num:arr1){\\n           if(isValid(num,arr2,d)){\\n               cnt++;\\n           }\\n       }\\n       return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607702,
                "title": "using-binary-search-with-optimal-time-complexity-o-m-n-lgn",
                "content": "```\\ndef findTheDistanceValue(self, a: List[int], b : List[int], d: int) -> int:\\n        b.sort()\\n        counter = 0\\n        for i in a :\\n            m =  0 \\n            n = len(b)\\n            flag = 0\\n            while m < n :\\n                mid = (m + n) // 2 \\n                if i < b[mid] : n = mid\\n                if i > b[mid] : m = mid + 1\\n                if i == b[mid] : \\n                    flag = 1\\n                    break\\n            if flag == 1 : continue\\n            if m == n : \\n                if m == 0 and abs(i - b[m]) > d : counter += 1\\n                elif m == len(b) and abs(i - b[m-1]) > d : counter += 1\\n                elif abs(b[m-1] - i) > d and abs(b[m] - i) > d : counter += 1\\n        return counter\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ndef findTheDistanceValue(self, a: List[int], b : List[int], d: int) -> int:\\n        b.sort()\\n        counter = 0\\n        for i in a :\\n            m =  0 \\n            n = len(b)\\n            flag = 0\\n            while m < n :\\n                mid = (m + n) // 2 \\n                if i < b[mid] : n = mid\\n                if i > b[mid] : m = mid + 1\\n                if i == b[mid] : \\n                    flag = 1\\n                    break\\n            if flag == 1 : continue\\n            if m == n : \\n                if m == 0 and abs(i - b[m]) > d : counter += 1\\n                elif m == len(b) and abs(i - b[m-1]) > d : counter += 1\\n                elif abs(b[m-1] - i) > d and abs(b[m] - i) > d : counter += 1\\n        return counter\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2582029,
                "title": "python-simple-solution",
                "content": "\\t\\tc=0\\n        temp=0\\n        for i in arr1:\\n            for j in arr2:\\n                if(abs(i-j)<=d):\\n                    temp=1\\n            if(temp==1):\\n                temp=0\\n            else:\\n                c+=1\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t\\tc=0\\n        temp=0\\n        for i in arr1:\\n            for j in arr2:\\n                if(abs(i-j)<=d):\\n                    temp=1\\n            if(temp==1):\\n                temp=0\\n            else:\\n                c+=1\\n        return c",
                "codeTag": "Unknown"
            },
            {
                "id": 2563671,
                "title": "c-binary-search-easy-understanding-o-n-log-n",
                "content": "```\\n bool search(vector<int>&arr,int target,int d){\\n        \\n        int low = 0, high = arr.size() - 1;\\n        while(low <= high){\\n            \\n            int mid = low + (high - low)/2;\\n            if(abs(arr[mid] - target) <= d){\\n                return false;\\n            }\\n            else if(arr[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    \\n    int findTheDistanceValue(vector<int>& A, vector<int>& B, int d) {\\n        int valid = 0;\\n        int ans = 0;\\n        sort(B.begin() , B.end());\\n        int l =0 ,r = B.size()-1;\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (search(B , A[i] , d)) ans++;         \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n bool search(vector<int>&arr,int target,int d){\\n        \\n        int low = 0, high = arr.size() - 1;\\n        while(low <= high){\\n            \\n            int mid = low + (high - low)/2;\\n            if(abs(arr[mid] - target) <= d){\\n                return false;\\n            }\\n            else if(arr[mid] < target){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    \\n    int findTheDistanceValue(vector<int>& A, vector<int>& B, int d) {\\n        int valid = 0;\\n        int ans = 0;\\n        sort(B.begin() , B.end());\\n        int l =0 ,r = B.size()-1;\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (search(B , A[i] , d)) ans++;         \\n        }\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2530644,
                "title": "python3-solved-using-binary-search-and-considering-range-of-numbers",
                "content": "```\\nclass Solution:\\n    #Time-Complexity: O(len(arr1)*2d*log(len(arr2)))\\n    #Space-Complexity: O(1)\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        #initialize ans variable!\\n        ans = 0\\n        #helper function will compute whether particular element is in given array of elements,\\n        #of at least size 1!\\n        \\n        #to apply helper function on arr2, we need to make sure it\\'s sorted!\\n        arr2.sort()\\n        def helper(e, a):\\n            #involve binary search\\n            L, R = 0, len(a) - 1\\n            while L <= R:\\n                mid = (L+R) // 2\\n                if(a[mid] == e):\\n                    return True\\n                elif(a[mid] > e):\\n                    R = mid - 1\\n                    continue\\n                else:\\n                    L = mid + 1\\n                    continue\\n            return False\\n        \\n        #iterate through each and every element in arr1!\\n        for num in arr1:\\n            #flag will indicate whether current num is able to contribute to distance value!\\n            flag = True\\n            #iterate through possible values w/ respect to num that will make it\\n            #not contribute to distance value between two arrays!\\n            for i in range(num - d, num+d+1):\\n                #check if current i is in arr2!\\n                #if so, set flag off and break!\\n                if(helper(i, arr2)):\\n                    flag = False\\n                    break\\n            #check boolean flag!\\n            if(flag):\\n                ans += 1\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    #Time-Complexity: O(len(arr1)*2d*log(len(arr2)))\\n    #Space-Complexity: O(1)\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        #initialize ans variable!\\n        ans = 0\\n        #helper function will compute whether particular element is in given array of elements,\\n        #of at least size 1!\\n        \\n        #to apply helper function on arr2, we need to make sure it\\'s sorted!\\n        arr2.sort()\\n        def helper(e, a):\\n            #involve binary search\\n            L, R = 0, len(a) - 1\\n            while L <= R:\\n                mid = (L+R) // 2\\n                if(a[mid] == e):\\n                    return True\\n                elif(a[mid] > e):\\n                    R = mid - 1\\n                    continue\\n                else:\\n                    L = mid + 1\\n                    continue\\n            return False\\n        \\n        #iterate through each and every element in arr1!\\n        for num in arr1:\\n            #flag will indicate whether current num is able to contribute to distance value!\\n            flag = True\\n            #iterate through possible values w/ respect to num that will make it\\n            #not contribute to distance value between two arrays!\\n            for i in range(num - d, num+d+1):\\n                #check if current i is in arr2!\\n                #if so, set flag off and break!\\n                if(helper(i, arr2)):\\n                    flag = False\\n                    break\\n            #check boolean flag!\\n            if(flag):\\n                ans += 1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2529862,
                "title": "c-easy-binary-search-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(), arr2.end());\\n\\n        int ans = 0;\\n        for(auto i : arr1){\\n            int idx = lower_bound(arr2.begin(), arr2.end(), i-d) - arr2.begin();\\n            \\n            if(idx == arr2.size() || arr2[idx] > i+d)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr2.begin(), arr2.end());\\n\\n        int ans = 0;\\n        for(auto i : arr1){\\n            int idx = lower_bound(arr2.begin(), arr2.end(), i-d) - arr2.begin();\\n            \\n            if(idx == arr2.size() || arr2[idx] > i+d)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503961,
                "title": "java-solution-easy-to-understand",
                "content": "class Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        \\n        int s,e,mid;\\n        int count = 0;\\n        \\n        // sorting the second array\\n        Arrays.sort(arr2);\\n        \\n        for(int i=0;i<arr1.length;i++){\\n            s = 0;\\n            e = arr2.length-1;\\n            count++;\\n            while(s <= e){\\n                mid = s + (e-s)/2;\\n                if(Math.abs(arr2[mid]-arr1[i])<=d){\\n                    count--;\\n                    break;\\n                }\\n                if(arr2[mid]>arr1[i]) \\n                    e=mid-1;\\n                \\n                else s=mid+1;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        \\n        int s,e,mid;\\n        int count = 0;\\n        \\n        // sorting the second array\\n        Arrays.sort(arr2);\\n        \\n        for(int i=0;i<arr1.length;i++){\\n            s = 0;\\n            e = arr2.length-1;\\n            count++;\\n            while(s <= e){\\n                mid = s + (e-s)/2;\\n                if(Math.abs(arr2[mid]-arr1[i])<=d){\\n                    count--;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2440615,
                "title": "best-javascript-implementation-top-98-3",
                "content": "This Github repository, https://github.com/AnasImloul/Leetcode-solutions, have all the solutions I was looking for.\\nIt is extremely beneficial to have every solution available in one place. I hope it is useful to you as well.\\n```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    const arr2Sorted = arr2.sort((a, b) => a - b);\\n    let dist = 0;\\n    \\n    for (const num of arr1) {\\n        if (isDistanceValid(num, d, arr2Sorted)) {\\n            dist += 1;\\n        }\\n    }\\n    \\n    return dist;\\n};\\n\\nfunction isDistanceValid(number, dist, array) {\\n    let left = 0;\\n    let right = array.length - 1;\\n    \\n    while (left <= right) {\\n        const mid = Math.floor((right + left) / 2);\\n        \\n        if (Math.abs(number - array[mid]) <= dist) {\\n            return false;\\n        }\\n        \\n        if (array[mid] < number) {\\n            left = mid + 1;\\n        }\\n        \\n        if (array[mid] > number) {\\n            right = mid - 1;\\n        }\\n    }\\n    \\n    return true;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr1\\n * @param {number[]} arr2\\n * @param {number} d\\n * @return {number}\\n */\\nvar findTheDistanceValue = function(arr1, arr2, d) {\\n    const arr2Sorted = arr2.sort((a, b) => a - b);\\n    let dist = 0;\\n    \\n    for (const num of arr1) {\\n        if (isDistanceValid(num, d, arr2Sorted)) {\\n            dist += 1;\\n        }\\n    }\\n    \\n    return dist;\\n};\\n\\nfunction isDistanceValid(number, dist, array) {\\n    let left = 0;\\n    let right = array.length - 1;\\n    \\n    while (left <= right) {\\n        const mid = Math.floor((right + left) / 2);\\n        \\n        if (Math.abs(number - array[mid]) <= dist) {\\n            return false;\\n        }\\n        \\n        if (array[mid] < number) {\\n            left = mid + 1;\\n        }\\n        \\n        if (array[mid] > number) {\\n            right = mid - 1;\\n        }\\n    }\\n    \\n    return true;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2432219,
                "title": "python-binary-search-clean-solution",
                "content": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        res = 0\\n        for num in arr1:\\n            if not self.helper(arr2, num, d):\\n                res += 1\\n        return res\\n    \\n    def helper(self, arr, num, d):\\n        lo, hi = 0, len(arr) - 1\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if arr[mid] - d <= num <= arr[mid] + d:\\n                return True\\n            elif num < arr[mid] - d:\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.sort()\\n        res = 0\\n        for num in arr1:\\n            if not self.helper(arr2, num, d):\\n                res += 1\\n        return res\\n    \\n    def helper(self, arr, num, d):\\n        lo, hi = 0, len(arr) - 1\\n        while lo <= hi:\\n            mid = (lo + hi) // 2\\n            if arr[mid] - d <= num <= arr[mid] + d:\\n                return True\\n            elif num < arr[mid] - d:\\n                hi = mid - 1\\n            else:\\n                lo = mid + 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418971,
                "title": "c-faster-than-95-o-n-log-n-binary-search-short-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int len = arr2.size(), count = 0;\\n        sort(arr2.begin(), arr2.end());\\n        \\n        for(int i = 0; i < arr1.size(); i++)\\n        {\\n            bool flag = false;            \\n            int s = 0, e = len - 1, m;\\n            \\n            while(s <= e)\\n            {\\n                m = s + (e - s) / 2;\\n               if(abs(arr2[m] - arr1[i]) <= d)\\n               {\\n                    flag = true;\\n                    break;\\n               }\\n                else if(arr2[m] > arr1[i])\\n                    e = m - 1;\\n                else\\n                    s = m + 1;\\n            }\\n            if(!flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int len = arr2.size(), count = 0;\\n        sort(arr2.begin(), arr2.end());\\n        \\n        for(int i = 0; i < arr1.size(); i++)\\n        {\\n            bool flag = false;            \\n            int s = 0, e = len - 1, m;\\n            \\n            while(s <= e)\\n            {\\n                m = s + (e - s) / 2;\\n               if(abs(arr2[m] - arr1[i]) <= d)\\n               {\\n                    flag = true;\\n                    break;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 2380226,
                "title": "c-solution-94-faster-easy-to-understand",
                "content": "```\\nint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n       int n=arr1.size();\\n        int m=arr2.size();\\n        int count=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(abs(arr1[i]-arr2[j])<=d)\\n                {\\n                    count--; //eliminating the element for which there is atleast one element in arr2 where |arr1-arr2| <=d\\n                    break; //terminating the for loop \\n                }\\n               \\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n       int n=arr1.size();\\n        int m=arr2.size();\\n        int count=n;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(abs(arr1[i]-arr2[j])<=d)\\n                {\\n                    count--; //eliminating the element for which there is atleast one element in arr2 where |arr1-arr2| <=d\\n                    break; //terminating the for loop \\n                }\\n               \\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2353937,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int n = arr1.size(), ans = 0;\\n        sort(arr2.begin(),arr2.end());\\n        for (auto x: arr1) {\\n            auto pt = lower_bound(arr2.begin(),arr2.end(),x);\\n            if (pt!=arr2.end()) {\\n                if (arr2[pt-arr2.begin()]-x<=d)\\n                    continue;\\n            }\\n            if (pt!=arr2.begin()) {\\n                --pt;\\n                if (x-arr2[pt-arr2.begin()]<=d)\\n                    continue;\\n            }\\n            ++ans;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int n = arr1.size(), ans = 0;\\n        sort(arr2.begin(),arr2.end());\\n        for (auto x: arr1) {\\n            auto pt = lower_bound(arr2.begin(),arr2.end(),x);\\n            if (pt!=arr2.end()) {\\n                if (arr2[pt-arr2.begin()]-x<=d)\\n                    continue;\\n            }\\n            if (pt!=arr2.begin()) {\\n                --pt;\\n                if (x-arr2[pt-arr2.begin()]<=d)\\n                    continue;\\n            }\\n            ++ans;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351943,
                "title": "i-literally-have-no-idea-what-the-problem-is",
                "content": "**I literally have no idea what the problem is! the description with the example just doesn\\'t make sense**\\n\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2344674,
                "title": "python-short-simple",
                "content": "```\\ndef findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        cnt = 0\\n        for i in arr1:\\n            flag = 0\\n            for j in arr2:\\n                if abs(i-j) <= d:\\n                    flag = 1\\n                    break\\n            if flag == 0:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        cnt = 0\\n        for i in arr1:\\n            flag = 0\\n            for j in arr2:\\n                if abs(i-j) <= d:\\n                    flag = 1\\n                    break\\n            if flag == 0:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2330571,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int res = 0;\\n        for (int i = 0; i < arr1.length; i++) {\\n            if (!binarySearch(arr2, -d + arr1[i], d + arr1[i]))\\n                res++;\\n        }\\n        return res;\\n    }\\n\\n    private boolean binarySearch(int[] arr2, int i, int j) {\\n        int l = 0, r = arr2.length - 1;\\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (arr2[m] >= i && arr2[m] <= j)\\n                return true;\\n            else if (arr2[m] < i)\\n                l = m + 1;\\n            else\\n                r = m - 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int res = 0;\\n        for (int i = 0; i < arr1.length; i++) {\\n            if (!binarySearch(arr2, -d + arr1[i], d + arr1[i]))\\n                res++;\\n        }\\n        return res;\\n    }\\n\\n    private boolean binarySearch(int[] arr2, int i, int j) {\\n        int l = 0, r = arr2.length - 1;\\n        while (l <= r) {\\n            int m = (l + r) / 2;\\n            if (arr2[m] >= i && arr2[m] <= j)\\n                return true;\\n            else if (arr2[m] < i)\\n                l = m + 1;\\n            else\\n                r = m - 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292204,
                "title": "python-bisect-o-nlogn-clean-code",
                "content": "```\\nfrom bisect import bisect_right\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.extend([float(\\'inf\\'),float(\\'-inf\\')])\\n        arr2.sort()\\n        res = 0\\n        for a in arr1:\\n            i = bisect_right(arr2, a)\\n            gap = min(arr2[i]-a, a-arr2[i-1])\\n            if gap > d: res += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_right\\nclass Solution:\\n    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:\\n        arr2.extend([float(\\'inf\\'),float(\\'-inf\\')])\\n        arr2.sort()\\n        res = 0\\n        for a in arr1:\\n            i = bisect_right(arr2, a)\\n            gap = min(arr2[i]-a, a-arr2[i-1])\\n            if gap > d: res += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2284287,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int c,r=0;\\n        sort(arr2.begin(),arr2.end());\\n        for(int i=0;i<arr1.size();i++){\\n            c=0;\\n            for(int j=0;j<arr2.size();j++){\\n                if(abs(arr1[i]-arr2[j])<=d)\\n                    c++;\\n            }\\n            if(c==0)\\n                r++;\\n        }\\n        return r;              \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int c,r=0;\\n        sort(arr2.begin(),arr2.end());\\n        for(int i=0;i<arr1.size();i++){\\n            c=0;\\n            for(int j=0;j<arr2.size();j++){\\n                if(abs(arr1[i]-arr2[j])<=d)\\n                    c++;\\n            }\\n            if(c==0)\\n                r++;\\n        }\\n        return r;              \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283210,
                "title": "qs-ans-explained-find-the-distance-value-between-two-arrays-easiest-c-code",
                "content": "New to **Binary Search**?\\nTrying to do this Problem as it has **Easy** mark?\\nIt is one of the most difficult question if you consider the given **LeetCode** explanation!\\n\\nI strongly recommend you to go and read the given article where the Question description is explained in a very easy manner!\\n> [Problem description explained in simple English](https://leetcode.com/problems/find-the-distance-value-between-two-arrays/discuss/1913945/Problem-description-explained-in-simple-English)\\n\\nIf you understood what is the requirement or what to do for this problem but unable to Code it...\\nHere we go...\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // My Function\\n    // If the given input satisfies question statement\\n    // This will result in an increase in the counter.\\n    bool isValid(int num, vector<int>& arr2, int d){\\n        \\n        int lo = 0, hi = arr2.size() - 1;\\n        \\n        while (lo <= hi){\\n            \\n            int mid = lo + (hi - lo)/2;\\n            \\n            if (abs(arr2[mid] - num) <= d)\\n                return false;\\n            \\n            // For negative value in array\\n            // Cause subtracting from a negative value will cause higher result\\n            else if (arr2[mid] < num)   \\n                lo = mid + 1;\\n            \\n            // Subtracting a number from higher number will reselt higher value\\n            else\\n                hi = mid - 1;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    // Given Function\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        \\n        sort (arr2.begin(), arr2.end());\\n        \\n        int cnt = 0;\\n        for (auto it: arr1){\\n            \\n            if (isValid(it, arr2, d))\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // My Function\\n    // If the given input satisfies question statement\\n    // This will result in an increase in the counter.\\n    bool isValid(int num, vector<int>& arr2, int d){\\n        \\n        int lo = 0, hi = arr2.size() - 1;\\n        \\n        while (lo <= hi){\\n            \\n            int mid = lo + (hi - lo)/2;\\n            \\n            if (abs(arr2[mid] - num) <= d)\\n                return false;\\n            \\n            // For negative value in array\\n            // Cause subtracting from a negative value will cause higher result\\n            else if (arr2[mid] < num)   \\n                lo = mid + 1;\\n            \\n            // Subtracting a number from higher number will reselt higher value\\n            else\\n                hi = mid - 1;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    // Given Function\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        \\n        sort (arr2.begin(), arr2.end());\\n        \\n        int cnt = 0;\\n        for (auto it: arr1){\\n            \\n            if (isValid(it, arr2, d))\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235679,
                "title": "java-solution-easy-to-understand-solution-binary-search",
                "content": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int count = 0;\\n        \\n        for(int i = 0; i < arr1.length ; i++){\\n            if(Solve(arr2, arr1[i], d)){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public boolean Solve(int[] arr, int a, int d){\\n        int start = 0; \\n        int end = arr.length - 1;\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            if( Math.abs(arr[mid] - a) <= d){\\n                return false;\\n            }\\n            else if(arr[mid] > a){\\n                end = mid - 1;\\n            }\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        Arrays.sort(arr2);\\n        int count = 0;\\n        \\n        for(int i = 0; i < arr1.length ; i++){\\n            if(Solve(arr2, arr1[i], d)){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public boolean Solve(int[] arr, int a, int d){\\n        int start = 0; \\n        int end = arr.length - 1;\\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            if( Math.abs(arr[mid] - a) <= d){\\n                return false;\\n            }\\n            else if(arr[mid] > a){\\n                end = mid - 1;\\n            }\\n            else {\\n                start = mid + 1;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219012,
                "title": "c-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {  \\n        int distance = 0;\\n        for(int i=0;i<arr1.size();i++){\\n            bool flag = true;\\n            for(int j = 0;j<arr2.size();j++){\\n                if(abs(arr1[i]-arr2[j]) <= d){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n            distance++;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {  \\n        int distance = 0;\\n        for(int i=0;i<arr1.size();i++){\\n            bool flag = true;\\n            for(int j = 0;j<arr2.size();j++){\\n                if(abs(arr1[i]-arr2[j]) <= d){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag)\\n            distance++;\\n        }\\n        return distance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179099,
                "title": "c-solution-with-two-approaches-brute-force-binary-search",
                "content": "Brute force : \\n\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int ans = 0;\\n        for(int i = 0; i<size(arr1); i++){\\n            bool ok = true;\\n            for(int j = 0; j<size(arr2); j++){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    ok = false;\\n                }\\n            }\\n            if(ok) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTC: O(n*n)\\nSC: O(1)\\n\\nBinary search: \\n\\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr1.begin(),arr1.end());\\n        long ans = 0;\\n        sort(arr2.begin(), arr2.end());\\n        for(int i = 0; i<size(arr1); i++){\\n            long long start = 0, end = arr2.size()-1;\\n            int ok = 0;\\n            while(start<=end){\\n                long long mid = (end-start)/2 + start;\\n                if(abs(arr2[mid]-arr1[i])<=d){\\n                    ok++; \\n                    break;\\n                } else if(arr2[mid]>arr1[i]){\\n                    end = mid-1;\\n                } else {\\n                    start = mid+1;\\n                }\\n            }\\n            if(!ok) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTC: O(nlog(n))\\nSC: O(1)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        int ans = 0;\\n        for(int i = 0; i<size(arr1); i++){\\n            bool ok = true;\\n            for(int j = 0; j<size(arr2); j++){\\n                if(abs(arr1[i]-arr2[j])<=d){\\n                    ok = false;\\n                }\\n            }\\n            if(ok) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {\\n        sort(arr1.begin(),arr1.end());\\n        long ans = 0;\\n        sort(arr2.begin(), arr2.end());\\n        for(int i = 0; i<size(arr1); i++){\\n            long long start = 0, end = arr2.size()-1;\\n            int ok = 0;\\n            while(start<=end){\\n                long long mid = (end-start)/2 + start;\\n                if(abs(arr2[mid]-arr1[i])<=d){\\n                    ok++; \\n                    break;\\n                } else if(arr2[mid]>arr1[i]){\\n                    end = mid-1;\\n                } else {\\n                    start = mid+1;\\n                }\\n            }\\n            if(!ok) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174952,
                "title": "java-simple-to-understand",
                "content": "class Solution {\\npublic int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count = 0;\\n        for (int i = 0; i<arr1.length; i++){\\n            boolean flag = false;\\n            for (int j = 0; j<arr2.length; j++){\\n                if(Math.abs(arr1[i]-arr2[j]) <= d){\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(flag == false) count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic int findTheDistanceValue(int[] arr1, int[] arr2, int d) {\\n        int count = 0;\\n        for (int i = 0; i<arr1.length; i++){\\n            boolean flag = false;\\n            for (int j = 0; j<arr2.length; j++){\\n                if(Math.abs(arr1[i]-arr2[j]) <= d){\\n                    flag = true;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2173146,
                "title": "c-easy-to-understand-solution",
                "content": "```\\n\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\tint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<arr1.size();i++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint flag=0;\\n\\t\\t\\t\\t\\t\\t\\tfor(int j=0;j<arr2.size();j++)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!((abs(arr1[i]-arr2[j]))>d))\\n\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(flag==0)\\n\\t\\t\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t}   \\n\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\tint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\t\\t\\tfor(int i=0;i<arr1.size();i++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint flag=0;\\n\\t\\t\\t\\t\\t\\t\\tfor(int j=0;j<arr2.size();j++)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!((abs(arr1[i]-arr2[j]))>d))\\n\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(flag==0)\\n\\t\\t\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t}   \\n\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2161586,
                "title": "simple-c-solution-fastest-and-easy",
                "content": "\\t\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\t\\tint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\t\\t\\t\\tfor(int i=0;i<arr1.size();i++)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tbool pass=true;\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int j=0;j<arr2.size();j++)\\n\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!((abs(arr1[i]-arr2[j]))>d))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tpass=false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t\\tif(pass==true)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\treturn count;\\n\\t\\t\\t\\t\\t\\t}   \\n\\n\\t\\t\\t\\t\\t};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t\\tpublic:\\n\\t\\t\\t\\t\\t\\tint findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\t\\t\\t\\tfor(int i=0;i<arr1.size();i++)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tbool pass=true;\\n\\t\\t\\t\\t\\t\\t\\t\\tfor(int j=0;j<arr2.size();j++)\\n\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(!((abs(arr1[i]-arr2[j]))>d))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tpass=false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564568,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1566434,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1570892,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1651861,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1804430,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1758124,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1570489,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1804784,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1716116,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1772072,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1564568,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1566434,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1570892,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1651861,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1804430,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1758124,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1570489,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1804784,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1716116,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 1772072,
                "content": [
                    {
                        "username": "donutloop",
                        "content": "This description is pretty bad and example, language are very misleading."
                    },
                    {
                        "username": "eti-iniER",
                        "content": "I spent a lot of time testing different implementations and trying to deal with errors, before I realized that the question itself isn\\'t properly phrased. The example too is opaque unless you already know the answer.\\n\\nYou\\'re supposed to count the elements in arr1 that do NOT yield a value <= d when any element from arr2 is subtracted from it. To explain the example;\\n\\narr1[0] = 4 doesn\\'t violate the condition. Hence, we count it.\\narr1[1] = 5 also doesn\\'t violate the condition. We also count it, bringing our count to two.\\narr1[8] = 8 violates the condition, so it isn\\'t counted.\\n\\nSince that\\'s the end of arr1, the total number of GOOD numbers we have is 2. That\\'s why the output is 2"
                    },
                    {
                        "username": "sahil-rai",
                        "content": "Thanks dude\\n"
                    },
                    {
                        "username": "annhiliater_01",
                        "content": "nice explanation dude\\n"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "If anyone understand this question then please explain me."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "return the number of elements in arr1 for which there is no element in arr2 with an absolute difference smaller than or equal to d."
                    },
                    {
                        "username": "ansumanb",
                        "content": "Example 1:  \\n\\narr1 = [4,5,8] arr2 = [10,9,1,8] d = 2\\n\\n----arr1[0]---\\n|4-(10)|=6 6 <= 2 is False\\n|4-(9)|=5 5 <= 2 is False\\n|4-(1)|=3 3 <= 2 is False\\n|4-(8)|=4 4 <= 2 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|5-(10)|=5 5 <= 2 is False\\n|5-(9)|=4 4 <= 2 is False\\n|5-(1)|=4 4 <= 2 is False\\n|5-(8)|=3 3 <= 2 is False\\n\\nSince for this i=1 we have all false, consider this row\\n\\n----arr1[2]---\\n|8-(10)|=2 2 <= 2 is True\\n|8-(9)|=1 1 <= 2 is True\\n|8-(1)|=7 7 <= 2 is False\\n|8-(8)|=0 0 <= 2 is True\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 2: \\n\\narr1 = [1,4,2,3] arr2 = [-4,-3,6,10,20,30] d = 3\\n\\n----arr1[0]---\\n|1-(-4)|=5 5 <= 3 is False\\n|1-(-3)|=4 4 <= 3 is False\\n|1-(6)|=5 5 <= 3 is False\\n|1-(10)|=9 9 <= 3 is False\\n|1-(20)|=19 19 <= 3 is False\\n|1-(30)|=29 29 <= 3 is False\\n\\nSince for this i=0 we have all false, consider this row\\n\\n----arr1[1]---\\n|4-(-4)|=8 8 <= 3 is False\\n|4-(-3)|=7 7 <= 3 is False\\n|4-(6)|=2 2 <= 3 is True\\n|4-(10)|=6 6 <= 3 is False\\n|4-(20)|=16 16 <= 3 is False\\n|4-(30)|=26 26 <= 3 is False\\n\\n----arr1[2]---\\n|2-(-4)|=6 6 <= 3 is False\\n|2-(-3)|=5 5 <= 3 is False\\n|2-(6)|=4 4 <= 3 is False\\n|2-(10)|=8 8 <= 3 is False\\n|2-(20)|=18 18 <= 3 is False\\n|2-(30)|=28 28 <= 3 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-4)|=7 7 <= 3 is False\\n|3-(-3)|=6 6 <= 3 is False\\n|3-(6)|=3 3 <= 3 is True\\n|3-(10)|=7 7 <= 3 is False\\n|3-(20)|=17 17 <= 3 is False\\n|3-(30)|=27 27 <= 3 is False\\n\\n----\\nAnswer is total number of rows we have considered 2\\n\\nExample 3: \\n\\narr1 = [2,1,100,3] arr2 = [-5,-2,10,-3,7] d = 6\\n\\n----arr1[0]---\\n|2-(-5)|=7 7 <= 6 is False\\n|2-(-2)|=4 4 <= 6 is True\\n|2-(10)|=8 8 <= 6 is False\\n|2-(-3)|=5 5 <= 6 is True\\n|2-(7)|=5 5 <= 6 is True\\n\\n----arr1[1]---\\n|1-(-5)|=6 6 <= 6 is True\\n|1-(-2)|=3 3 <= 6 is True\\n|1-(10)|=9 9 <= 6 is False\\n|1-(-3)|=4 4 <= 6 is True\\n|1-(7)|=6 6 <= 6 is True\\n\\n----arr1[2]---\\n|100-(-5)|=105 105 <= 6 is False\\n|100-(-2)|=102 102 <= 6 is False\\n|100-(10)|=90 90 <= 6 is False\\n|100-(-3)|=103 103 <= 6 is False\\n|100-(7)|=93 93 <= 6 is False\\n\\nSince for this i=2 we have all false, consider this row\\n\\n----arr1[3]---\\n|3-(-5)|=8 8 <= 6 is False\\n|3-(-2)|=5 5 <= 6 is True\\n|3-(10)|=7 7 <= 6 is False\\n|3-(-3)|=6 6 <= 6 is True\\n|3-(7)|=4 4 <= 6 is True\\n\\n----\\nAnswer is total number of rows we have considered 1"
                    },
                    {
                        "username": "satyaki_",
                        "content": "what is i ?"
                    },
                    {
                        "username": "znxkznxk1030",
                        "content": "It seems like english test."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@SamirMishra27](/SamirMishra27) That's what the downvote button is for, you can then select that the description and/or examples are unclear. Although I don't think this one is that bad, maybe they have already updated it. "
                    },
                    {
                        "username": "SamirMishra27",
                        "content": "There should be a report button to report such questions with extremely poor explanation and no proper examples. "
                    },
                    {
                        "username": "JBozarov",
                        "content": "Very bad example given. I did not understand until read this discussion part. Thanks all  "
                    },
                    {
                        "username": "Skiller12",
                        "content": "Bhai let me understand if u would "
                    },
                    {
                        "username": "Nitish_Kumar1",
                        "content": "This code  has very Bad description it doesn\\'t  match with example given"
                    },
                    {
                        "username": "cameronwlewis",
                        "content": "Why is this listed in LeetCode\\'s Binary Search Study Plan? This question is an unintuitive situation to apply a binary search. \\n\\nNot to mention it\\'s an unintuitive question to begin with."
                    },
                    {
                        "username": "Godfather20",
                        "content": "I think question setter also doesn\\'t understand what he have written here. lol"
                    },
                    {
                        "username": "max77445",
                        "content": "lol"
                    },
                    {
                        "username": "MahmOud_GaD",
                        "content": "This description is pretty bad and test cases are very misleading."
                    }
                ]
            },
            {
                "id": 2004633,
                "content": [
                    {
                        "username": "Nikhil_Pall",
                        "content": "very bad explanation. Hard to understand input output for this problem\n\nWhat I understand and how I solved this problem :\nInput 1 : \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nExplanation : all the difference is greater than 2, (ans=1)\n\nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nExplanation : all the difference is greater than 2, (ans =2)\n\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\nExplanation : Here, there is some differences which is <= d, (so, here we will not increase the value) (ans=2)\n\nHence, the answer for this input is 2\n\n"
                    },
                    {
                        "username": "jisokoo",
                        "content": "Rephrased:\\nYou are given two integer arrays arr1 and arr2, and an integer d. The problem asks you to find the number of elements in arr1 that are at a distance of more than d from all the elements in arr2. Here, the distance between two integers a and b is defined as |a - b|.\\n\\nFor example, if arr1 = [4, 5, 8], arr2 = [10, 9, 1, 8], and d = 2, then the answer would be 2 because there are only two elements in arr1 (i.e., 4 and 5) that are at a distance of more than 2 from all the elements in arr2."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I\\'m going to translate the description:\\n\\nYou have to iterate over all the elements in `arr1` (let\\'s name those elements as `a`) and do the following:\\n\\n* Use that `a` and check if exists at least one element in `arr2` (let\\'s name it `b`) such that `abs(b - a) <= d`. If such element `b` exists, then `a` **will not** be part of the solution. If there is no such element `b`, then `a` **is** part of the solution.\\n\\nThe answer is how many `a` exists in `arr1`.\\n\\nThe hint is: sort `arr2` at the beginning of the solution, so now you can use binary search in `arr2`. Why? Because, you only have to check the **closest** element to `a`. One case is enough. Binary search helps with that. If you can check that the closest element is: `abs(b - a) <= d` then, it\\'s enough to tell if `a` is part of the solution or not.\\n\\nThere are edge cases, but I think this is enough to get started.\\n\\nTL;DR: One iteration for each element in `arr1`, and inside that iteration one binary search in `arr2`."
                    },
                    {
                        "username": "Prince_Singhal",
                        "content": "question explination is very bad "
                    },
                    {
                        "username": "mayankK135",
                        "content": "Simplest way is to use brute force using 2 for loops. \\nAlthough this problem is very poorly written with test case being of not much help"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Read the question carefully before you starting to code ."
                    },
                    {
                        "username": "chris_saechao",
                        "content": "# Here\\'s a simpler way to understand:\\n\\nFor each number in arr1, check if there\\'s a number in arr2 that\\'s within d distance (either less by d or more by d). If there isn\\'t, then this number from arr1 is considered \"distant\".\\n\\nCount all such \"distant\" numbers from arr1. This count is the \"distance value\" you need to return.\\n\\n# **Example:**\\n\\nLet\\'s say arr1 = [1, 4, 5], arr2 = [8, 10], and d = 2.\\n\\n* For arr1[0] which is 1, the closest number in arr2 is 8. The difference is 7 which is greater than d. So, 1 is \"distant\".\\n* For arr1[1] which is 4, the closest number in arr2 is 8. The difference is 4 which is greater than d. So, 4 is \"distant\".\\n* For arr1[2] which is 5, the closest number in arr2 is 8. The difference is 3 which is greater than d. So, 5 is \"distant\".\\n\\nAll numbers in arr1 are \"distant\" from numbers in arr2 by more than d. So, the distance value is 3."
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "FOR THOSE WHO DIDNT UNDERSTAND PROBLEM:\\nWhat we have to do is to return the number of rows I.e(i in arr1[i]) that satisfy the <=d condition and not the number of comparisons.\\nA simple nested for loop will do the trick."
                    },
                    {
                        "username": "sam_su_user",
                        "content": "The question and given examples are totally misleading. You have to count number of elements from arr1, after subtracted from all arr2 elements will greater than d."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Even my english teacher won\\'t able to pass this english test\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I heard when compared with  other platforms. leetcode provide simpler and short descripton which is easy to understand"
                    }
                ]
            },
            {
                "id": 1856365,
                "content": [
                    {
                        "username": "Nikhil_Pall",
                        "content": "very bad explanation. Hard to understand input output for this problem\n\nWhat I understand and how I solved this problem :\nInput 1 : \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nExplanation : all the difference is greater than 2, (ans=1)\n\nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nExplanation : all the difference is greater than 2, (ans =2)\n\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\nExplanation : Here, there is some differences which is <= d, (so, here we will not increase the value) (ans=2)\n\nHence, the answer for this input is 2\n\n"
                    },
                    {
                        "username": "jisokoo",
                        "content": "Rephrased:\\nYou are given two integer arrays arr1 and arr2, and an integer d. The problem asks you to find the number of elements in arr1 that are at a distance of more than d from all the elements in arr2. Here, the distance between two integers a and b is defined as |a - b|.\\n\\nFor example, if arr1 = [4, 5, 8], arr2 = [10, 9, 1, 8], and d = 2, then the answer would be 2 because there are only two elements in arr1 (i.e., 4 and 5) that are at a distance of more than 2 from all the elements in arr2."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I\\'m going to translate the description:\\n\\nYou have to iterate over all the elements in `arr1` (let\\'s name those elements as `a`) and do the following:\\n\\n* Use that `a` and check if exists at least one element in `arr2` (let\\'s name it `b`) such that `abs(b - a) <= d`. If such element `b` exists, then `a` **will not** be part of the solution. If there is no such element `b`, then `a` **is** part of the solution.\\n\\nThe answer is how many `a` exists in `arr1`.\\n\\nThe hint is: sort `arr2` at the beginning of the solution, so now you can use binary search in `arr2`. Why? Because, you only have to check the **closest** element to `a`. One case is enough. Binary search helps with that. If you can check that the closest element is: `abs(b - a) <= d` then, it\\'s enough to tell if `a` is part of the solution or not.\\n\\nThere are edge cases, but I think this is enough to get started.\\n\\nTL;DR: One iteration for each element in `arr1`, and inside that iteration one binary search in `arr2`."
                    },
                    {
                        "username": "Prince_Singhal",
                        "content": "question explination is very bad "
                    },
                    {
                        "username": "mayankK135",
                        "content": "Simplest way is to use brute force using 2 for loops. \\nAlthough this problem is very poorly written with test case being of not much help"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Read the question carefully before you starting to code ."
                    },
                    {
                        "username": "chris_saechao",
                        "content": "# Here\\'s a simpler way to understand:\\n\\nFor each number in arr1, check if there\\'s a number in arr2 that\\'s within d distance (either less by d or more by d). If there isn\\'t, then this number from arr1 is considered \"distant\".\\n\\nCount all such \"distant\" numbers from arr1. This count is the \"distance value\" you need to return.\\n\\n# **Example:**\\n\\nLet\\'s say arr1 = [1, 4, 5], arr2 = [8, 10], and d = 2.\\n\\n* For arr1[0] which is 1, the closest number in arr2 is 8. The difference is 7 which is greater than d. So, 1 is \"distant\".\\n* For arr1[1] which is 4, the closest number in arr2 is 8. The difference is 4 which is greater than d. So, 4 is \"distant\".\\n* For arr1[2] which is 5, the closest number in arr2 is 8. The difference is 3 which is greater than d. So, 5 is \"distant\".\\n\\nAll numbers in arr1 are \"distant\" from numbers in arr2 by more than d. So, the distance value is 3."
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "FOR THOSE WHO DIDNT UNDERSTAND PROBLEM:\\nWhat we have to do is to return the number of rows I.e(i in arr1[i]) that satisfy the <=d condition and not the number of comparisons.\\nA simple nested for loop will do the trick."
                    },
                    {
                        "username": "sam_su_user",
                        "content": "The question and given examples are totally misleading. You have to count number of elements from arr1, after subtracted from all arr2 elements will greater than d."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Even my english teacher won\\'t able to pass this english test\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I heard when compared with  other platforms. leetcode provide simpler and short descripton which is easy to understand"
                    }
                ]
            },
            {
                "id": 1796740,
                "content": [
                    {
                        "username": "Nikhil_Pall",
                        "content": "very bad explanation. Hard to understand input output for this problem\n\nWhat I understand and how I solved this problem :\nInput 1 : \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nExplanation : all the difference is greater than 2, (ans=1)\n\nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nExplanation : all the difference is greater than 2, (ans =2)\n\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\nExplanation : Here, there is some differences which is <= d, (so, here we will not increase the value) (ans=2)\n\nHence, the answer for this input is 2\n\n"
                    },
                    {
                        "username": "jisokoo",
                        "content": "Rephrased:\\nYou are given two integer arrays arr1 and arr2, and an integer d. The problem asks you to find the number of elements in arr1 that are at a distance of more than d from all the elements in arr2. Here, the distance between two integers a and b is defined as |a - b|.\\n\\nFor example, if arr1 = [4, 5, 8], arr2 = [10, 9, 1, 8], and d = 2, then the answer would be 2 because there are only two elements in arr1 (i.e., 4 and 5) that are at a distance of more than 2 from all the elements in arr2."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I\\'m going to translate the description:\\n\\nYou have to iterate over all the elements in `arr1` (let\\'s name those elements as `a`) and do the following:\\n\\n* Use that `a` and check if exists at least one element in `arr2` (let\\'s name it `b`) such that `abs(b - a) <= d`. If such element `b` exists, then `a` **will not** be part of the solution. If there is no such element `b`, then `a` **is** part of the solution.\\n\\nThe answer is how many `a` exists in `arr1`.\\n\\nThe hint is: sort `arr2` at the beginning of the solution, so now you can use binary search in `arr2`. Why? Because, you only have to check the **closest** element to `a`. One case is enough. Binary search helps with that. If you can check that the closest element is: `abs(b - a) <= d` then, it\\'s enough to tell if `a` is part of the solution or not.\\n\\nThere are edge cases, but I think this is enough to get started.\\n\\nTL;DR: One iteration for each element in `arr1`, and inside that iteration one binary search in `arr2`."
                    },
                    {
                        "username": "Prince_Singhal",
                        "content": "question explination is very bad "
                    },
                    {
                        "username": "mayankK135",
                        "content": "Simplest way is to use brute force using 2 for loops. \\nAlthough this problem is very poorly written with test case being of not much help"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Read the question carefully before you starting to code ."
                    },
                    {
                        "username": "chris_saechao",
                        "content": "# Here\\'s a simpler way to understand:\\n\\nFor each number in arr1, check if there\\'s a number in arr2 that\\'s within d distance (either less by d or more by d). If there isn\\'t, then this number from arr1 is considered \"distant\".\\n\\nCount all such \"distant\" numbers from arr1. This count is the \"distance value\" you need to return.\\n\\n# **Example:**\\n\\nLet\\'s say arr1 = [1, 4, 5], arr2 = [8, 10], and d = 2.\\n\\n* For arr1[0] which is 1, the closest number in arr2 is 8. The difference is 7 which is greater than d. So, 1 is \"distant\".\\n* For arr1[1] which is 4, the closest number in arr2 is 8. The difference is 4 which is greater than d. So, 4 is \"distant\".\\n* For arr1[2] which is 5, the closest number in arr2 is 8. The difference is 3 which is greater than d. So, 5 is \"distant\".\\n\\nAll numbers in arr1 are \"distant\" from numbers in arr2 by more than d. So, the distance value is 3."
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "FOR THOSE WHO DIDNT UNDERSTAND PROBLEM:\\nWhat we have to do is to return the number of rows I.e(i in arr1[i]) that satisfy the <=d condition and not the number of comparisons.\\nA simple nested for loop will do the trick."
                    },
                    {
                        "username": "sam_su_user",
                        "content": "The question and given examples are totally misleading. You have to count number of elements from arr1, after subtracted from all arr2 elements will greater than d."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Even my english teacher won\\'t able to pass this english test\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I heard when compared with  other platforms. leetcode provide simpler and short descripton which is easy to understand"
                    }
                ]
            },
            {
                "id": 1782399,
                "content": [
                    {
                        "username": "Nikhil_Pall",
                        "content": "very bad explanation. Hard to understand input output for this problem\n\nWhat I understand and how I solved this problem :\nInput 1 : \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nExplanation : all the difference is greater than 2, (ans=1)\n\nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nExplanation : all the difference is greater than 2, (ans =2)\n\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\nExplanation : Here, there is some differences which is <= d, (so, here we will not increase the value) (ans=2)\n\nHence, the answer for this input is 2\n\n"
                    },
                    {
                        "username": "jisokoo",
                        "content": "Rephrased:\\nYou are given two integer arrays arr1 and arr2, and an integer d. The problem asks you to find the number of elements in arr1 that are at a distance of more than d from all the elements in arr2. Here, the distance between two integers a and b is defined as |a - b|.\\n\\nFor example, if arr1 = [4, 5, 8], arr2 = [10, 9, 1, 8], and d = 2, then the answer would be 2 because there are only two elements in arr1 (i.e., 4 and 5) that are at a distance of more than 2 from all the elements in arr2."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I\\'m going to translate the description:\\n\\nYou have to iterate over all the elements in `arr1` (let\\'s name those elements as `a`) and do the following:\\n\\n* Use that `a` and check if exists at least one element in `arr2` (let\\'s name it `b`) such that `abs(b - a) <= d`. If such element `b` exists, then `a` **will not** be part of the solution. If there is no such element `b`, then `a` **is** part of the solution.\\n\\nThe answer is how many `a` exists in `arr1`.\\n\\nThe hint is: sort `arr2` at the beginning of the solution, so now you can use binary search in `arr2`. Why? Because, you only have to check the **closest** element to `a`. One case is enough. Binary search helps with that. If you can check that the closest element is: `abs(b - a) <= d` then, it\\'s enough to tell if `a` is part of the solution or not.\\n\\nThere are edge cases, but I think this is enough to get started.\\n\\nTL;DR: One iteration for each element in `arr1`, and inside that iteration one binary search in `arr2`."
                    },
                    {
                        "username": "Prince_Singhal",
                        "content": "question explination is very bad "
                    },
                    {
                        "username": "mayankK135",
                        "content": "Simplest way is to use brute force using 2 for loops. \\nAlthough this problem is very poorly written with test case being of not much help"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Read the question carefully before you starting to code ."
                    },
                    {
                        "username": "chris_saechao",
                        "content": "# Here\\'s a simpler way to understand:\\n\\nFor each number in arr1, check if there\\'s a number in arr2 that\\'s within d distance (either less by d or more by d). If there isn\\'t, then this number from arr1 is considered \"distant\".\\n\\nCount all such \"distant\" numbers from arr1. This count is the \"distance value\" you need to return.\\n\\n# **Example:**\\n\\nLet\\'s say arr1 = [1, 4, 5], arr2 = [8, 10], and d = 2.\\n\\n* For arr1[0] which is 1, the closest number in arr2 is 8. The difference is 7 which is greater than d. So, 1 is \"distant\".\\n* For arr1[1] which is 4, the closest number in arr2 is 8. The difference is 4 which is greater than d. So, 4 is \"distant\".\\n* For arr1[2] which is 5, the closest number in arr2 is 8. The difference is 3 which is greater than d. So, 5 is \"distant\".\\n\\nAll numbers in arr1 are \"distant\" from numbers in arr2 by more than d. So, the distance value is 3."
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "FOR THOSE WHO DIDNT UNDERSTAND PROBLEM:\\nWhat we have to do is to return the number of rows I.e(i in arr1[i]) that satisfy the <=d condition and not the number of comparisons.\\nA simple nested for loop will do the trick."
                    },
                    {
                        "username": "sam_su_user",
                        "content": "The question and given examples are totally misleading. You have to count number of elements from arr1, after subtracted from all arr2 elements will greater than d."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Even my english teacher won\\'t able to pass this english test\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I heard when compared with  other platforms. leetcode provide simpler and short descripton which is easy to understand"
                    }
                ]
            },
            {
                "id": 1740904,
                "content": [
                    {
                        "username": "Nikhil_Pall",
                        "content": "very bad explanation. Hard to understand input output for this problem\n\nWhat I understand and how I solved this problem :\nInput 1 : \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nExplanation : all the difference is greater than 2, (ans=1)\n\nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nExplanation : all the difference is greater than 2, (ans =2)\n\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\nExplanation : Here, there is some differences which is <= d, (so, here we will not increase the value) (ans=2)\n\nHence, the answer for this input is 2\n\n"
                    },
                    {
                        "username": "jisokoo",
                        "content": "Rephrased:\\nYou are given two integer arrays arr1 and arr2, and an integer d. The problem asks you to find the number of elements in arr1 that are at a distance of more than d from all the elements in arr2. Here, the distance between two integers a and b is defined as |a - b|.\\n\\nFor example, if arr1 = [4, 5, 8], arr2 = [10, 9, 1, 8], and d = 2, then the answer would be 2 because there are only two elements in arr1 (i.e., 4 and 5) that are at a distance of more than 2 from all the elements in arr2."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I\\'m going to translate the description:\\n\\nYou have to iterate over all the elements in `arr1` (let\\'s name those elements as `a`) and do the following:\\n\\n* Use that `a` and check if exists at least one element in `arr2` (let\\'s name it `b`) such that `abs(b - a) <= d`. If such element `b` exists, then `a` **will not** be part of the solution. If there is no such element `b`, then `a` **is** part of the solution.\\n\\nThe answer is how many `a` exists in `arr1`.\\n\\nThe hint is: sort `arr2` at the beginning of the solution, so now you can use binary search in `arr2`. Why? Because, you only have to check the **closest** element to `a`. One case is enough. Binary search helps with that. If you can check that the closest element is: `abs(b - a) <= d` then, it\\'s enough to tell if `a` is part of the solution or not.\\n\\nThere are edge cases, but I think this is enough to get started.\\n\\nTL;DR: One iteration for each element in `arr1`, and inside that iteration one binary search in `arr2`."
                    },
                    {
                        "username": "Prince_Singhal",
                        "content": "question explination is very bad "
                    },
                    {
                        "username": "mayankK135",
                        "content": "Simplest way is to use brute force using 2 for loops. \\nAlthough this problem is very poorly written with test case being of not much help"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Read the question carefully before you starting to code ."
                    },
                    {
                        "username": "chris_saechao",
                        "content": "# Here\\'s a simpler way to understand:\\n\\nFor each number in arr1, check if there\\'s a number in arr2 that\\'s within d distance (either less by d or more by d). If there isn\\'t, then this number from arr1 is considered \"distant\".\\n\\nCount all such \"distant\" numbers from arr1. This count is the \"distance value\" you need to return.\\n\\n# **Example:**\\n\\nLet\\'s say arr1 = [1, 4, 5], arr2 = [8, 10], and d = 2.\\n\\n* For arr1[0] which is 1, the closest number in arr2 is 8. The difference is 7 which is greater than d. So, 1 is \"distant\".\\n* For arr1[1] which is 4, the closest number in arr2 is 8. The difference is 4 which is greater than d. So, 4 is \"distant\".\\n* For arr1[2] which is 5, the closest number in arr2 is 8. The difference is 3 which is greater than d. So, 5 is \"distant\".\\n\\nAll numbers in arr1 are \"distant\" from numbers in arr2 by more than d. So, the distance value is 3."
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "FOR THOSE WHO DIDNT UNDERSTAND PROBLEM:\\nWhat we have to do is to return the number of rows I.e(i in arr1[i]) that satisfy the <=d condition and not the number of comparisons.\\nA simple nested for loop will do the trick."
                    },
                    {
                        "username": "sam_su_user",
                        "content": "The question and given examples are totally misleading. You have to count number of elements from arr1, after subtracted from all arr2 elements will greater than d."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Even my english teacher won\\'t able to pass this english test\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I heard when compared with  other platforms. leetcode provide simpler and short descripton which is easy to understand"
                    }
                ]
            },
            {
                "id": 2071930,
                "content": [
                    {
                        "username": "Nikhil_Pall",
                        "content": "very bad explanation. Hard to understand input output for this problem\n\nWhat I understand and how I solved this problem :\nInput 1 : \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nExplanation : all the difference is greater than 2, (ans=1)\n\nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nExplanation : all the difference is greater than 2, (ans =2)\n\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\nExplanation : Here, there is some differences which is <= d, (so, here we will not increase the value) (ans=2)\n\nHence, the answer for this input is 2\n\n"
                    },
                    {
                        "username": "jisokoo",
                        "content": "Rephrased:\\nYou are given two integer arrays arr1 and arr2, and an integer d. The problem asks you to find the number of elements in arr1 that are at a distance of more than d from all the elements in arr2. Here, the distance between two integers a and b is defined as |a - b|.\\n\\nFor example, if arr1 = [4, 5, 8], arr2 = [10, 9, 1, 8], and d = 2, then the answer would be 2 because there are only two elements in arr1 (i.e., 4 and 5) that are at a distance of more than 2 from all the elements in arr2."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I\\'m going to translate the description:\\n\\nYou have to iterate over all the elements in `arr1` (let\\'s name those elements as `a`) and do the following:\\n\\n* Use that `a` and check if exists at least one element in `arr2` (let\\'s name it `b`) such that `abs(b - a) <= d`. If such element `b` exists, then `a` **will not** be part of the solution. If there is no such element `b`, then `a` **is** part of the solution.\\n\\nThe answer is how many `a` exists in `arr1`.\\n\\nThe hint is: sort `arr2` at the beginning of the solution, so now you can use binary search in `arr2`. Why? Because, you only have to check the **closest** element to `a`. One case is enough. Binary search helps with that. If you can check that the closest element is: `abs(b - a) <= d` then, it\\'s enough to tell if `a` is part of the solution or not.\\n\\nThere are edge cases, but I think this is enough to get started.\\n\\nTL;DR: One iteration for each element in `arr1`, and inside that iteration one binary search in `arr2`."
                    },
                    {
                        "username": "Prince_Singhal",
                        "content": "question explination is very bad "
                    },
                    {
                        "username": "mayankK135",
                        "content": "Simplest way is to use brute force using 2 for loops. \\nAlthough this problem is very poorly written with test case being of not much help"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Read the question carefully before you starting to code ."
                    },
                    {
                        "username": "chris_saechao",
                        "content": "# Here\\'s a simpler way to understand:\\n\\nFor each number in arr1, check if there\\'s a number in arr2 that\\'s within d distance (either less by d or more by d). If there isn\\'t, then this number from arr1 is considered \"distant\".\\n\\nCount all such \"distant\" numbers from arr1. This count is the \"distance value\" you need to return.\\n\\n# **Example:**\\n\\nLet\\'s say arr1 = [1, 4, 5], arr2 = [8, 10], and d = 2.\\n\\n* For arr1[0] which is 1, the closest number in arr2 is 8. The difference is 7 which is greater than d. So, 1 is \"distant\".\\n* For arr1[1] which is 4, the closest number in arr2 is 8. The difference is 4 which is greater than d. So, 4 is \"distant\".\\n* For arr1[2] which is 5, the closest number in arr2 is 8. The difference is 3 which is greater than d. So, 5 is \"distant\".\\n\\nAll numbers in arr1 are \"distant\" from numbers in arr2 by more than d. So, the distance value is 3."
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "FOR THOSE WHO DIDNT UNDERSTAND PROBLEM:\\nWhat we have to do is to return the number of rows I.e(i in arr1[i]) that satisfy the <=d condition and not the number of comparisons.\\nA simple nested for loop will do the trick."
                    },
                    {
                        "username": "sam_su_user",
                        "content": "The question and given examples are totally misleading. You have to count number of elements from arr1, after subtracted from all arr2 elements will greater than d."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Even my english teacher won\\'t able to pass this english test\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I heard when compared with  other platforms. leetcode provide simpler and short descripton which is easy to understand"
                    }
                ]
            },
            {
                "id": 2030145,
                "content": [
                    {
                        "username": "Nikhil_Pall",
                        "content": "very bad explanation. Hard to understand input output for this problem\n\nWhat I understand and how I solved this problem :\nInput 1 : \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nExplanation : all the difference is greater than 2, (ans=1)\n\nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nExplanation : all the difference is greater than 2, (ans =2)\n\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\nExplanation : Here, there is some differences which is <= d, (so, here we will not increase the value) (ans=2)\n\nHence, the answer for this input is 2\n\n"
                    },
                    {
                        "username": "jisokoo",
                        "content": "Rephrased:\\nYou are given two integer arrays arr1 and arr2, and an integer d. The problem asks you to find the number of elements in arr1 that are at a distance of more than d from all the elements in arr2. Here, the distance between two integers a and b is defined as |a - b|.\\n\\nFor example, if arr1 = [4, 5, 8], arr2 = [10, 9, 1, 8], and d = 2, then the answer would be 2 because there are only two elements in arr1 (i.e., 4 and 5) that are at a distance of more than 2 from all the elements in arr2."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I\\'m going to translate the description:\\n\\nYou have to iterate over all the elements in `arr1` (let\\'s name those elements as `a`) and do the following:\\n\\n* Use that `a` and check if exists at least one element in `arr2` (let\\'s name it `b`) such that `abs(b - a) <= d`. If such element `b` exists, then `a` **will not** be part of the solution. If there is no such element `b`, then `a` **is** part of the solution.\\n\\nThe answer is how many `a` exists in `arr1`.\\n\\nThe hint is: sort `arr2` at the beginning of the solution, so now you can use binary search in `arr2`. Why? Because, you only have to check the **closest** element to `a`. One case is enough. Binary search helps with that. If you can check that the closest element is: `abs(b - a) <= d` then, it\\'s enough to tell if `a` is part of the solution or not.\\n\\nThere are edge cases, but I think this is enough to get started.\\n\\nTL;DR: One iteration for each element in `arr1`, and inside that iteration one binary search in `arr2`."
                    },
                    {
                        "username": "Prince_Singhal",
                        "content": "question explination is very bad "
                    },
                    {
                        "username": "mayankK135",
                        "content": "Simplest way is to use brute force using 2 for loops. \\nAlthough this problem is very poorly written with test case being of not much help"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Read the question carefully before you starting to code ."
                    },
                    {
                        "username": "chris_saechao",
                        "content": "# Here\\'s a simpler way to understand:\\n\\nFor each number in arr1, check if there\\'s a number in arr2 that\\'s within d distance (either less by d or more by d). If there isn\\'t, then this number from arr1 is considered \"distant\".\\n\\nCount all such \"distant\" numbers from arr1. This count is the \"distance value\" you need to return.\\n\\n# **Example:**\\n\\nLet\\'s say arr1 = [1, 4, 5], arr2 = [8, 10], and d = 2.\\n\\n* For arr1[0] which is 1, the closest number in arr2 is 8. The difference is 7 which is greater than d. So, 1 is \"distant\".\\n* For arr1[1] which is 4, the closest number in arr2 is 8. The difference is 4 which is greater than d. So, 4 is \"distant\".\\n* For arr1[2] which is 5, the closest number in arr2 is 8. The difference is 3 which is greater than d. So, 5 is \"distant\".\\n\\nAll numbers in arr1 are \"distant\" from numbers in arr2 by more than d. So, the distance value is 3."
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "FOR THOSE WHO DIDNT UNDERSTAND PROBLEM:\\nWhat we have to do is to return the number of rows I.e(i in arr1[i]) that satisfy the <=d condition and not the number of comparisons.\\nA simple nested for loop will do the trick."
                    },
                    {
                        "username": "sam_su_user",
                        "content": "The question and given examples are totally misleading. You have to count number of elements from arr1, after subtracted from all arr2 elements will greater than d."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Even my english teacher won\\'t able to pass this english test\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I heard when compared with  other platforms. leetcode provide simpler and short descripton which is easy to understand"
                    }
                ]
            },
            {
                "id": 2014005,
                "content": [
                    {
                        "username": "Nikhil_Pall",
                        "content": "very bad explanation. Hard to understand input output for this problem\n\nWhat I understand and how I solved this problem :\nInput 1 : \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nExplanation : all the difference is greater than 2, (ans=1)\n\nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nExplanation : all the difference is greater than 2, (ans =2)\n\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\nExplanation : Here, there is some differences which is <= d, (so, here we will not increase the value) (ans=2)\n\nHence, the answer for this input is 2\n\n"
                    },
                    {
                        "username": "jisokoo",
                        "content": "Rephrased:\\nYou are given two integer arrays arr1 and arr2, and an integer d. The problem asks you to find the number of elements in arr1 that are at a distance of more than d from all the elements in arr2. Here, the distance between two integers a and b is defined as |a - b|.\\n\\nFor example, if arr1 = [4, 5, 8], arr2 = [10, 9, 1, 8], and d = 2, then the answer would be 2 because there are only two elements in arr1 (i.e., 4 and 5) that are at a distance of more than 2 from all the elements in arr2."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I\\'m going to translate the description:\\n\\nYou have to iterate over all the elements in `arr1` (let\\'s name those elements as `a`) and do the following:\\n\\n* Use that `a` and check if exists at least one element in `arr2` (let\\'s name it `b`) such that `abs(b - a) <= d`. If such element `b` exists, then `a` **will not** be part of the solution. If there is no such element `b`, then `a` **is** part of the solution.\\n\\nThe answer is how many `a` exists in `arr1`.\\n\\nThe hint is: sort `arr2` at the beginning of the solution, so now you can use binary search in `arr2`. Why? Because, you only have to check the **closest** element to `a`. One case is enough. Binary search helps with that. If you can check that the closest element is: `abs(b - a) <= d` then, it\\'s enough to tell if `a` is part of the solution or not.\\n\\nThere are edge cases, but I think this is enough to get started.\\n\\nTL;DR: One iteration for each element in `arr1`, and inside that iteration one binary search in `arr2`."
                    },
                    {
                        "username": "Prince_Singhal",
                        "content": "question explination is very bad "
                    },
                    {
                        "username": "mayankK135",
                        "content": "Simplest way is to use brute force using 2 for loops. \\nAlthough this problem is very poorly written with test case being of not much help"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Read the question carefully before you starting to code ."
                    },
                    {
                        "username": "chris_saechao",
                        "content": "# Here\\'s a simpler way to understand:\\n\\nFor each number in arr1, check if there\\'s a number in arr2 that\\'s within d distance (either less by d or more by d). If there isn\\'t, then this number from arr1 is considered \"distant\".\\n\\nCount all such \"distant\" numbers from arr1. This count is the \"distance value\" you need to return.\\n\\n# **Example:**\\n\\nLet\\'s say arr1 = [1, 4, 5], arr2 = [8, 10], and d = 2.\\n\\n* For arr1[0] which is 1, the closest number in arr2 is 8. The difference is 7 which is greater than d. So, 1 is \"distant\".\\n* For arr1[1] which is 4, the closest number in arr2 is 8. The difference is 4 which is greater than d. So, 4 is \"distant\".\\n* For arr1[2] which is 5, the closest number in arr2 is 8. The difference is 3 which is greater than d. So, 5 is \"distant\".\\n\\nAll numbers in arr1 are \"distant\" from numbers in arr2 by more than d. So, the distance value is 3."
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "FOR THOSE WHO DIDNT UNDERSTAND PROBLEM:\\nWhat we have to do is to return the number of rows I.e(i in arr1[i]) that satisfy the <=d condition and not the number of comparisons.\\nA simple nested for loop will do the trick."
                    },
                    {
                        "username": "sam_su_user",
                        "content": "The question and given examples are totally misleading. You have to count number of elements from arr1, after subtracted from all arr2 elements will greater than d."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Even my english teacher won\\'t able to pass this english test\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I heard when compared with  other platforms. leetcode provide simpler and short descripton which is easy to understand"
                    }
                ]
            },
            {
                "id": 1991822,
                "content": [
                    {
                        "username": "Nikhil_Pall",
                        "content": "very bad explanation. Hard to understand input output for this problem\n\nWhat I understand and how I solved this problem :\nInput 1 : \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nExplanation : all the difference is greater than 2, (ans=1)\n\nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nExplanation : all the difference is greater than 2, (ans =2)\n\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\nExplanation : Here, there is some differences which is <= d, (so, here we will not increase the value) (ans=2)\n\nHence, the answer for this input is 2\n\n"
                    },
                    {
                        "username": "jisokoo",
                        "content": "Rephrased:\\nYou are given two integer arrays arr1 and arr2, and an integer d. The problem asks you to find the number of elements in arr1 that are at a distance of more than d from all the elements in arr2. Here, the distance between two integers a and b is defined as |a - b|.\\n\\nFor example, if arr1 = [4, 5, 8], arr2 = [10, 9, 1, 8], and d = 2, then the answer would be 2 because there are only two elements in arr1 (i.e., 4 and 5) that are at a distance of more than 2 from all the elements in arr2."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I\\'m going to translate the description:\\n\\nYou have to iterate over all the elements in `arr1` (let\\'s name those elements as `a`) and do the following:\\n\\n* Use that `a` and check if exists at least one element in `arr2` (let\\'s name it `b`) such that `abs(b - a) <= d`. If such element `b` exists, then `a` **will not** be part of the solution. If there is no such element `b`, then `a` **is** part of the solution.\\n\\nThe answer is how many `a` exists in `arr1`.\\n\\nThe hint is: sort `arr2` at the beginning of the solution, so now you can use binary search in `arr2`. Why? Because, you only have to check the **closest** element to `a`. One case is enough. Binary search helps with that. If you can check that the closest element is: `abs(b - a) <= d` then, it\\'s enough to tell if `a` is part of the solution or not.\\n\\nThere are edge cases, but I think this is enough to get started.\\n\\nTL;DR: One iteration for each element in `arr1`, and inside that iteration one binary search in `arr2`."
                    },
                    {
                        "username": "Prince_Singhal",
                        "content": "question explination is very bad "
                    },
                    {
                        "username": "mayankK135",
                        "content": "Simplest way is to use brute force using 2 for loops. \\nAlthough this problem is very poorly written with test case being of not much help"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Read the question carefully before you starting to code ."
                    },
                    {
                        "username": "chris_saechao",
                        "content": "# Here\\'s a simpler way to understand:\\n\\nFor each number in arr1, check if there\\'s a number in arr2 that\\'s within d distance (either less by d or more by d). If there isn\\'t, then this number from arr1 is considered \"distant\".\\n\\nCount all such \"distant\" numbers from arr1. This count is the \"distance value\" you need to return.\\n\\n# **Example:**\\n\\nLet\\'s say arr1 = [1, 4, 5], arr2 = [8, 10], and d = 2.\\n\\n* For arr1[0] which is 1, the closest number in arr2 is 8. The difference is 7 which is greater than d. So, 1 is \"distant\".\\n* For arr1[1] which is 4, the closest number in arr2 is 8. The difference is 4 which is greater than d. So, 4 is \"distant\".\\n* For arr1[2] which is 5, the closest number in arr2 is 8. The difference is 3 which is greater than d. So, 5 is \"distant\".\\n\\nAll numbers in arr1 are \"distant\" from numbers in arr2 by more than d. So, the distance value is 3."
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "FOR THOSE WHO DIDNT UNDERSTAND PROBLEM:\\nWhat we have to do is to return the number of rows I.e(i in arr1[i]) that satisfy the <=d condition and not the number of comparisons.\\nA simple nested for loop will do the trick."
                    },
                    {
                        "username": "sam_su_user",
                        "content": "The question and given examples are totally misleading. You have to count number of elements from arr1, after subtracted from all arr2 elements will greater than d."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Even my english teacher won\\'t able to pass this english test\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I heard when compared with  other platforms. leetcode provide simpler and short descripton which is easy to understand"
                    }
                ]
            },
            {
                "id": 1967704,
                "content": [
                    {
                        "username": "Nikhil_Pall",
                        "content": "very bad explanation. Hard to understand input output for this problem\n\nWhat I understand and how I solved this problem :\nInput 1 : \nFor arr1[0]=4 we have: \n|4-10|=6 > d=2 \n|4-9|=5 > d=2 \n|4-1|=3 > d=2 \n|4-8|=4 > d=2 \nExplanation : all the difference is greater than 2, (ans=1)\n\nFor arr1[1]=5 we have: \n|5-10|=5 > d=2 \n|5-9|=4 > d=2 \n|5-1|=4 > d=2 \n|5-8|=3 > d=2\nExplanation : all the difference is greater than 2, (ans =2)\n\nFor arr1[2]=8 we have:\n|8-10|=2 <= d=2\n|8-9|=1 <= d=2\n|8-1|=7 > d=2\n|8-8|=0 <= d=2\nExplanation : Here, there is some differences which is <= d, (so, here we will not increase the value) (ans=2)\n\nHence, the answer for this input is 2\n\n"
                    },
                    {
                        "username": "jisokoo",
                        "content": "Rephrased:\\nYou are given two integer arrays arr1 and arr2, and an integer d. The problem asks you to find the number of elements in arr1 that are at a distance of more than d from all the elements in arr2. Here, the distance between two integers a and b is defined as |a - b|.\\n\\nFor example, if arr1 = [4, 5, 8], arr2 = [10, 9, 1, 8], and d = 2, then the answer would be 2 because there are only two elements in arr1 (i.e., 4 and 5) that are at a distance of more than 2 from all the elements in arr2."
                    },
                    {
                        "username": "JuanQP",
                        "content": "I\\'m going to translate the description:\\n\\nYou have to iterate over all the elements in `arr1` (let\\'s name those elements as `a`) and do the following:\\n\\n* Use that `a` and check if exists at least one element in `arr2` (let\\'s name it `b`) such that `abs(b - a) <= d`. If such element `b` exists, then `a` **will not** be part of the solution. If there is no such element `b`, then `a` **is** part of the solution.\\n\\nThe answer is how many `a` exists in `arr1`.\\n\\nThe hint is: sort `arr2` at the beginning of the solution, so now you can use binary search in `arr2`. Why? Because, you only have to check the **closest** element to `a`. One case is enough. Binary search helps with that. If you can check that the closest element is: `abs(b - a) <= d` then, it\\'s enough to tell if `a` is part of the solution or not.\\n\\nThere are edge cases, but I think this is enough to get started.\\n\\nTL;DR: One iteration for each element in `arr1`, and inside that iteration one binary search in `arr2`."
                    },
                    {
                        "username": "Prince_Singhal",
                        "content": "question explination is very bad "
                    },
                    {
                        "username": "mayankK135",
                        "content": "Simplest way is to use brute force using 2 for loops. \\nAlthough this problem is very poorly written with test case being of not much help"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Read the question carefully before you starting to code ."
                    },
                    {
                        "username": "chris_saechao",
                        "content": "# Here\\'s a simpler way to understand:\\n\\nFor each number in arr1, check if there\\'s a number in arr2 that\\'s within d distance (either less by d or more by d). If there isn\\'t, then this number from arr1 is considered \"distant\".\\n\\nCount all such \"distant\" numbers from arr1. This count is the \"distance value\" you need to return.\\n\\n# **Example:**\\n\\nLet\\'s say arr1 = [1, 4, 5], arr2 = [8, 10], and d = 2.\\n\\n* For arr1[0] which is 1, the closest number in arr2 is 8. The difference is 7 which is greater than d. So, 1 is \"distant\".\\n* For arr1[1] which is 4, the closest number in arr2 is 8. The difference is 4 which is greater than d. So, 4 is \"distant\".\\n* For arr1[2] which is 5, the closest number in arr2 is 8. The difference is 3 which is greater than d. So, 5 is \"distant\".\\n\\nAll numbers in arr1 are \"distant\" from numbers in arr2 by more than d. So, the distance value is 3."
                    },
                    {
                        "username": "sahilmahadik99",
                        "content": "FOR THOSE WHO DIDNT UNDERSTAND PROBLEM:\\nWhat we have to do is to return the number of rows I.e(i in arr1[i]) that satisfy the <=d condition and not the number of comparisons.\\nA simple nested for loop will do the trick."
                    },
                    {
                        "username": "sam_su_user",
                        "content": "The question and given examples are totally misleading. You have to count number of elements from arr1, after subtracted from all arr2 elements will greater than d."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "Even my english teacher won\\'t able to pass this english test\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I heard when compared with  other platforms. leetcode provide simpler and short descripton which is easy to understand"
                    }
                ]
            }
        ]
    }
]